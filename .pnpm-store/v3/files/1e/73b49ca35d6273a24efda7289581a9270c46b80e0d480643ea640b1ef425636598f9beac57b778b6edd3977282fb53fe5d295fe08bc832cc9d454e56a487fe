{
  "version": 3,
  "sources": ["../src/sendPanic.ts"],
  "sourcesContent": ["import { getPlatform } from '@prisma/get-platform'\nimport archiver from 'archiver'\nimport Debug from '@prisma/debug'\nimport fs from 'fs'\nimport globby from 'globby'\nimport fetch from 'node-fetch'\nimport os from 'os'\nimport path from 'path'\nimport stripAnsi from 'strip-ansi'\nimport tmp from 'tmp'\nimport * as checkpoint from 'checkpoint-client'\nimport { maskSchema, mapScalarValues } from './utils/maskSchema'\nimport { RustPanic, ErrorArea } from './panic'\nimport { getProxyAgent } from '@prisma/fetch-engine'\nimport { IntrospectionEngine } from './IntrospectionEngine'\n\nconst debug = Debug('prisma:sendPanic')\n// cleanup the temporary files even when an uncaught exception occurs\ntmp.setGracefulCleanup()\n\nexport async function sendPanic(\n  error: RustPanic,\n  cliVersion: string,\n  binaryVersion: string,\n): Promise<number | void> {\n  try {\n    let schema: undefined | string\n    let maskedSchema: undefined | string\n    if (error.schemaPath) {\n      schema = fs.readFileSync(error.schemaPath, 'utf-8')\n    }\n    if (error.schema) {\n      schema = error.schema\n    }\n\n    if (schema) {\n      maskedSchema = maskSchema(schema)\n    }\n\n    let sqlDump: string | undefined\n    let dbVersion: string | undefined\n    // For a SQLite datasource like `url = \"file:dev.db\"` only error.schema will be defined\n    const schemaOrUrl = error.schema || error.introspectionUrl\n    if (error.area === ErrorArea.INTROSPECTION_CLI && schemaOrUrl) {\n      let engine: undefined | IntrospectionEngine\n      try {\n        engine = new IntrospectionEngine()\n        sqlDump = await engine.getDatabaseDescription(schemaOrUrl)\n        dbVersion = await engine.getDatabaseVersion(schemaOrUrl)\n        engine.stop()\n      } catch (e) {\n        debug(e)\n        if (engine && engine.isRunning) {\n          engine.stop()\n        }\n      }\n    }\n\n    const migrateRequest = error.request\n      ? JSON.stringify(\n          mapScalarValues(error.request, (value) => {\n            if (typeof value === 'string') {\n              return maskSchema(value)\n            }\n            return value\n          }),\n        )\n      : undefined\n\n    const params = {\n      area: error.area,\n      kind: ErrorKind.RUST_PANIC,\n      cliVersion,\n      binaryVersion,\n      command: getCommand(),\n      jsStackTrace: stripAnsi(error.stack || error.message),\n      rustStackTrace: error.rustStack,\n      operatingSystem: `${os.arch()} ${os.platform()} ${os.release()}`,\n      platform: await getPlatform(),\n      liftRequest: migrateRequest,\n      schemaFile: maskedSchema,\n      fingerprint: await checkpoint.getSignature(),\n      sqlDump: sqlDump,\n      dbVersion: dbVersion,\n    }\n\n    const signedUrl = await createErrorReport(params)\n\n    if (error.schemaPath) {\n      const zip = await makeErrorZip(error)\n      await uploadZip(zip, signedUrl)\n    }\n\n    const id = await makeErrorReportCompleted(signedUrl)\n    return id\n  } catch (e) {\n    debug(e)\n  }\n}\n\nfunction getCommand(): string {\n  // don't send url\n  if (process.argv[2] === 'introspect') {\n    return 'introspect'\n  } else if (process.argv[2] === 'db' && process.argv[3] === 'pull') {\n    return 'db pull'\n  }\n  return process.argv.slice(2).join(' ')\n}\n\nasync function uploadZip(zip: Buffer, url: string): Promise<any> {\n  return await fetch(url, {\n    method: 'PUT',\n    agent: getProxyAgent(url) as any,\n    headers: {\n      'Content-Length': String(zip.byteLength),\n    },\n    body: zip,\n  })\n}\n\nasync function makeErrorZip(error: RustPanic): Promise<Buffer> {\n  if (!error.schemaPath) {\n    throw new Error(`Can't make zip without schema path`)\n  }\n  const schemaDir = path.dirname(error.schemaPath)\n  const tmpFileObj = tmp.fileSync()\n  const outputFile = fs.createWriteStream(tmpFileObj.name)\n  const zip = archiver('zip', { zlib: { level: 9 } })\n\n  zip.pipe(outputFile)\n\n  // add schema file\n  const schemaFile = maskSchema(fs.readFileSync(error.schemaPath, 'utf-8'))\n  zip.append(schemaFile, { name: path.basename(error.schemaPath) })\n\n  if (fs.existsSync(schemaDir)) {\n    const filePaths = await globby('migrations/**/*', {\n      // globby doesn't have it in its types but it's part of mrmlnc/fast-glob\n      // @ts-ignore\n      cwd: schemaDir,\n    })\n\n    for (const filePath of filePaths) {\n      let file = fs.readFileSync(path.resolve(schemaDir, filePath), 'utf-8')\n      if (\n        filePath.endsWith('schema.prisma') ||\n        filePath.endsWith(path.basename(error.schemaPath))\n      ) {\n        // Remove credentials from schema datasource url\n        file = maskSchema(file)\n      }\n      zip.append(file, { name: path.basename(filePath) })\n    }\n  }\n\n  zip.finalize()\n\n  return new Promise((resolve, reject) => {\n    outputFile.on('close', () => {\n      const buffer = fs.readFileSync(tmpFileObj.name)\n      resolve(buffer)\n    })\n\n    zip.on('error', (err) => {\n      reject(err)\n    })\n  })\n}\n\nexport interface CreateErrorReportInput {\n  area: ErrorArea\n  binaryVersion: string\n  cliVersion: string\n  command: string\n  jsStackTrace: string\n  kind: ErrorKind\n  liftRequest?: string\n  operatingSystem: string\n  platform: string\n  rustStackTrace: string\n  schemaFile?: string\n  fingerprint?: string\n  sqlDump?: string\n  dbVersion?: string\n}\n\nexport enum ErrorKind {\n  JS_ERROR = 'JS_ERROR',\n  RUST_PANIC = 'RUST_PANIC',\n}\n\nexport async function createErrorReport(\n  data: CreateErrorReportInput,\n): Promise<string> {\n  const result = await request(\n    `mutation ($data: CreateErrorReportInput!) {\n    createErrorReport(data: $data)\n  }`,\n    { data },\n  )\n  return result.createErrorReport\n}\n\nexport async function makeErrorReportCompleted(\n  signedUrl: string,\n): Promise<number> {\n  const result = await request(\n    `mutation ($signedUrl: String!) {\n  markErrorReportCompleted(signedUrl: $signedUrl)\n}`,\n    { signedUrl },\n  )\n  return result.markErrorReportCompleted\n}\n\nasync function request(query: string, variables: any): Promise<any> {\n  const url = 'https://error-reports.prisma.sh/'\n  const body = JSON.stringify({\n    query,\n    variables,\n  })\n  return await fetch(url, {\n    method: 'POST',\n    agent: getProxyAgent(url) as any,\n    body,\n    headers: {\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n    },\n  })\n    .then((res) => res.json())\n    .then((res) => {\n      if (res.errors) {\n        throw new Error(JSON.stringify(res.errors))\n      }\n      return res.data\n    })\n}\n"],
  "mappings": "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",
  "names": []
}
