{
  "version": 3,
  "sources": ["../src/migrateEngineCommands.ts"],
  "sourcesContent": ["import { BinaryType } from '@prisma/fetch-engine'\nimport execa from 'execa'\nimport fs from 'fs'\nimport path from 'path'\nimport { promisify } from 'util'\nimport { getSchemaDir } from './cli/getSchema'\nimport { protocolToConnectorType } from './convertCredentials'\nimport { resolveBinary } from './resolveBinary'\n\nconst exists = promisify(fs.exists)\n\n// ### Exit codes\n// `0`: normal exit\n// `1`: abnormal (error) exit\n// `101`: panic\n// Non-zero exit codes should always be accompanied by a log message on stderr with the `ERROR` level.\nexport enum MigrateEngineExitCode {\n  Success = 0,\n  Error = 1,\n  Panic = 101,\n}\n\n// Logging and crash reporting happens through JSON logs on the Migration Engine's\n// stderr. Every line contains a single JSON object conforming to the following\n// interface:\n// {\"timestamp\":\"2021-06-11T15:35:34.084486+00:00\",\"level\":\"ERROR\",\"fields\":{\"is_panic\":false,\"error_code\":\"\",\"message\":\"Failed to delete SQLite database at `dev.db`.\\nNo such file or directory (os error 2)\\n\"},\"target\":\"migration_engine::logger\"}\n// {\"timestamp\":\"2021-06-11T15:35:34.320358+00:00\",\"level\":\"INFO\",\"fields\":{\"message\":\"Starting migration engine CLI\",\"git_hash\":\"a92947d63ede9b0b5b5aab253c2a7d9ad6cabe15\"},\"target\":\"migration_engine\"}\nexport interface MigrateEngineLogLine {\n  timestamp: string\n  level: LogLevel\n  fields: LogFields\n  target: string\n}\ntype LogLevel = 'INFO' | 'ERROR' | 'DEBUG' | 'WARN'\ninterface LogFields {\n  message: string\n  git_hash?: string\n  /// Hint from the engine to the CLI to log this line.\n  migrate_action?: 'log'\n  // Only for ERROR level messages\n  is_panic?: boolean\n  error_code?: string\n  [key: string]: any\n}\n\n// https://github.com/prisma/specs/tree/master/errors#common\nexport type DatabaseErrorCodes =\n  | 'P1000'\n  | 'P1001'\n  | 'P1002'\n  | 'P1003'\n  | 'P1009'\n  | 'P1010'\n\nexport type ConnectionResult = true | ConnectionError\n\nexport interface ConnectionError {\n  message: string\n  code: DatabaseErrorCodes\n}\n\nfunction parseJsonFromStderr(stderr: string): MigrateEngineLogLine[] {\n  // split by new line\n  const lines = stderr.split(/\\r?\\n/).slice(1) // Remove first element\n  const logs: any = []\n\n  for (const line of lines) {\n    const data = String(line)\n    try {\n      const json: MigrateEngineLogLine = JSON.parse(data)\n      logs.push(json)\n    } catch (e) {\n      throw new Error(`Could not parse migration engine response: ${e}`)\n    }\n  }\n\n  return logs\n}\n\nexport async function canConnectToDatabase(\n  connectionString: string,\n  cwd = process.cwd(),\n  migrationEnginePath?: string,\n): Promise<ConnectionResult> {\n  if (!connectionString) {\n    throw new Error(\n      'Connection url is empty. See https://www.prisma.io/docs/reference/database-reference/connection-urls',\n    )\n  }\n\n  const provider = protocolToConnectorType(`${connectionString.split(':')[0]}:`)\n\n  if (provider === 'sqlite') {\n    const sqliteExists = await doesSqliteDbExist(connectionString, cwd)\n    if (sqliteExists) {\n      return true\n    } else {\n      return {\n        code: 'P1003',\n        message: \"SQLite database file doesn't exist\",\n      }\n    }\n  }\n\n  try {\n    await execaCommand({\n      connectionString,\n      cwd,\n      migrationEnginePath,\n      engineCommandName: 'can-connect-to-database',\n    })\n  } catch (e) {\n    if (e.stderr) {\n      const logs = parseJsonFromStderr(e.stderr)\n      const error = logs.find(\n        (it) =>\n          it.level === 'ERROR' && it.target === 'migration_engine::logger',\n      )\n\n      if (error && error.fields.error_code && error.fields.message) {\n        return {\n          code: error.fields.error_code as DatabaseErrorCodes,\n          message: error.fields.message,\n        }\n      } else {\n        throw new Error(\n          `Migration engine error:\\n${logs\n            .map((log) => log.fields.message)\n            .join('\\n')}`,\n        )\n      }\n    } else {\n      throw new Error(`Migration engine exited.`)\n    }\n  }\n\n  return true\n}\n\nexport async function createDatabase(\n  connectionString: string,\n  cwd = process.cwd(),\n  migrationEnginePath?: string,\n) {\n  const dbExists = await canConnectToDatabase(\n    connectionString,\n    cwd,\n    migrationEnginePath,\n  )\n\n  // If database is already created, stop here, don't create it\n  if (dbExists === true) {\n    return false\n  }\n\n  try {\n    await execaCommand({\n      connectionString,\n      cwd,\n      migrationEnginePath,\n      engineCommandName: 'create-database',\n    })\n\n    return true\n  } catch (e) {\n    if (e.stderr) {\n      const logs = parseJsonFromStderr(e.stderr)\n      const error = logs.find(\n        (it) =>\n          it.level === 'ERROR' && it.target === 'migration_engine::logger',\n      )\n\n      if (error && error.fields.error_code && error.fields.message) {\n        throw new Error(`${error.fields.error_code}: ${error.fields.message}`)\n      } else {\n        throw new Error(\n          `Migration engine error:\\n${logs\n            .map((log) => log.fields.message)\n            .join('\\n')}`,\n        )\n      }\n    } else {\n      throw new Error(`Migration engine exited.`)\n    }\n  }\n}\n\nexport async function dropDatabase(\n  connectionString: string,\n  cwd = process.cwd(),\n  migrationEnginePath?: string,\n) {\n  try {\n    const result = await execaCommand({\n      connectionString,\n      cwd,\n      migrationEnginePath,\n      engineCommandName: 'drop-database',\n    })\n    if (\n      result &&\n      result.exitCode === 0 &&\n      result.stderr.includes('The database was successfully dropped')\n    ) {\n      return true\n    } else {\n      // We should not arrive here normally\n      throw Error(\n        `An error occurred during the drop: ${JSON.stringify(\n          result,\n          undefined,\n          2,\n        )}`,\n      )\n    }\n  } catch (e) {\n    if (e.stderr) {\n      const logs = parseJsonFromStderr(e.stderr)\n\n      throw new Error(\n        `Migration engine error:\\n${logs\n          .map((log) => log.fields.message)\n          .join('\\n')}`,\n      )\n    } else {\n      throw new Error(`Migration engine exited.`)\n    }\n  }\n}\n\nexport async function execaCommand({\n  connectionString,\n  cwd,\n  migrationEnginePath,\n  engineCommandName,\n}: {\n  connectionString: string\n  cwd: string\n  migrationEnginePath?: string\n  engineCommandName:\n    | 'create-database'\n    | 'drop-database'\n    | 'can-connect-to-database'\n}) {\n  migrationEnginePath =\n    migrationEnginePath || (await resolveBinary(BinaryType.migrationEngine))\n\n  try {\n    return await execa(\n      migrationEnginePath,\n      ['cli', '--datasource', connectionString, engineCommandName],\n      {\n        cwd,\n        env: {\n          RUST_BACKTRACE: '1',\n          RUST_LOG: 'info',\n        },\n      },\n    )\n  } catch (e) {\n    if (e.message) {\n      e.message = e.message.replace(connectionString, '<REDACTED>')\n    }\n    if (e.stdout) {\n      e.stdout = e.stdout.replace(connectionString, '<REDACTED>')\n    }\n    if (e.stderr) {\n      e.stderr = e.stderr.replace(connectionString, '<REDACTED>')\n    }\n    throw e\n  }\n}\n\nexport async function doesSqliteDbExist(\n  connectionString: string,\n  schemaDir?: string,\n): Promise<boolean> {\n  let filePath = connectionString\n\n  if (filePath.startsWith('file:')) {\n    filePath = filePath.slice(5)\n  } else if (filePath.startsWith('sqlite:')) {\n    filePath = filePath.slice(7)\n  }\n\n  const cwd = schemaDir || (await getSchemaDir())\n  if (!cwd) {\n    throw new Error(`Could not find schema.prisma in ${process.cwd()}`)\n  }\n\n  const absoluteTarget = path.resolve(cwd, filePath)\n\n  return exists(absoluteTarget)\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,0BAA2B;AAC3B,mBAAkB;AAClB,gBAAe;AACf,kBAAiB;AACjB,kBAA0B;AAC1B,uBAA6B;AAC7B,gCAAwC;AACxC,2BAA8B;AAE9B,MAAM,SAAS,2BAAU,kBAAG;AAOrB,IAAK;AAAL,UAAK,wBAAL;AACL,6DAAU,KAAV;AACA,2DAAQ,KAAR;AACA,2DAAQ,OAAR;AAAA,GAHU;AA6CZ,6BAA6B,QAAwC;AAEnE,QAAM,QAAQ,OAAO,MAAM,SAAS,MAAM;AAC1C,QAAM,OAAY;AAElB,aAAW,QAAQ,OAAO;AACxB,UAAM,OAAO,OAAO;AACpB,QAAI;AACF,YAAM,OAA6B,KAAK,MAAM;AAC9C,WAAK,KAAK;AAAA,aACH,GAAP;AACA,YAAM,IAAI,MAAM,8CAA8C;AAAA;AAAA;AAIlE,SAAO;AAAA;AAGT,oCACE,kBACA,MAAM,QAAQ,OACd,qBAC2B;AAC3B,MAAI,CAAC,kBAAkB;AACrB,UAAM,IAAI,MACR;AAAA;AAIJ,QAAM,WAAW,uDAAwB,GAAG,iBAAiB,MAAM,KAAK;AAExE,MAAI,aAAa,UAAU;AACzB,UAAM,eAAe,MAAM,kBAAkB,kBAAkB;AAC/D,QAAI,cAAc;AAChB,aAAO;AAAA,WACF;AACL,aAAO;AAAA,QACL,MAAM;AAAA,QACN,SAAS;AAAA;AAAA;AAAA;AAKf,MAAI;AACF,UAAM,aAAa;AAAA,MACjB;AAAA,MACA;AAAA,MACA;AAAA,MACA,mBAAmB;AAAA;AAAA,WAEd,GAAP;AACA,QAAI,EAAE,QAAQ;AACZ,YAAM,OAAO,oBAAoB,EAAE;AACnC,YAAM,QAAQ,KAAK,KACjB,CAAC,OACC,GAAG,UAAU,WAAW,GAAG,WAAW;AAG1C,UAAI,SAAS,MAAM,OAAO,cAAc,MAAM,OAAO,SAAS;AAC5D,eAAO;AAAA,UACL,MAAM,MAAM,OAAO;AAAA,UACnB,SAAS,MAAM,OAAO;AAAA;AAAA,aAEnB;AACL,cAAM,IAAI,MACR;AAAA,EAA4B,KACzB,IAAI,CAAC,QAAQ,IAAI,OAAO,SACxB,KAAK;AAAA;AAAA,WAGP;AACL,YAAM,IAAI,MAAM;AAAA;AAAA;AAIpB,SAAO;AAAA;AAGT,8BACE,kBACA,MAAM,QAAQ,OACd,qBACA;AACA,QAAM,WAAW,MAAM,qBACrB,kBACA,KACA;AAIF,MAAI,aAAa,MAAM;AACrB,WAAO;AAAA;AAGT,MAAI;AACF,UAAM,aAAa;AAAA,MACjB;AAAA,MACA;AAAA,MACA;AAAA,MACA,mBAAmB;AAAA;AAGrB,WAAO;AAAA,WACA,GAAP;AACA,QAAI,EAAE,QAAQ;AACZ,YAAM,OAAO,oBAAoB,EAAE;AACnC,YAAM,QAAQ,KAAK,KACjB,CAAC,OACC,GAAG,UAAU,WAAW,GAAG,WAAW;AAG1C,UAAI,SAAS,MAAM,OAAO,cAAc,MAAM,OAAO,SAAS;AAC5D,cAAM,IAAI,MAAM,GAAG,MAAM,OAAO,eAAe,MAAM,OAAO;AAAA,aACvD;AACL,cAAM,IAAI,MACR;AAAA,EAA4B,KACzB,IAAI,CAAC,QAAQ,IAAI,OAAO,SACxB,KAAK;AAAA;AAAA,WAGP;AACL,YAAM,IAAI,MAAM;AAAA;AAAA;AAAA;AAKtB,4BACE,kBACA,MAAM,QAAQ,OACd,qBACA;AACA,MAAI;AACF,UAAM,SAAS,MAAM,aAAa;AAAA,MAChC;AAAA,MACA;AAAA,MACA;AAAA,MACA,mBAAmB;AAAA;AAErB,QACE,UACA,OAAO,aAAa,KACpB,OAAO,OAAO,SAAS,0CACvB;AACA,aAAO;AAAA,WACF;AAEL,YAAM,MACJ,sCAAsC,KAAK,UACzC,QACA,QACA;AAAA;AAAA,WAIC,GAAP;AACA,QAAI,EAAE,QAAQ;AACZ,YAAM,OAAO,oBAAoB,EAAE;AAEnC,YAAM,IAAI,MACR;AAAA,EAA4B,KACzB,IAAI,CAAC,QAAQ,IAAI,OAAO,SACxB,KAAK;AAAA,WAEL;AACL,YAAM,IAAI,MAAM;AAAA;AAAA;AAAA;AAKtB,4BAAmC;AAAA,EACjC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,GASC;AACD,wBACE,uBAAwB,MAAM,wCAAc,+BAAW;AAEzD,MAAI;AACF,WAAO,MAAM,0BACX,qBACA,CAAC,OAAO,gBAAgB,kBAAkB,oBAC1C;AAAA,MACE;AAAA,MACA,KAAK;AAAA,QACH,gBAAgB;AAAA,QAChB,UAAU;AAAA;AAAA;AAAA,WAIT,GAAP;AACA,QAAI,EAAE,SAAS;AACb,QAAE,UAAU,EAAE,QAAQ,QAAQ,kBAAkB;AAAA;AAElD,QAAI,EAAE,QAAQ;AACZ,QAAE,SAAS,EAAE,OAAO,QAAQ,kBAAkB;AAAA;AAEhD,QAAI,EAAE,QAAQ;AACZ,QAAE,SAAS,EAAE,OAAO,QAAQ,kBAAkB;AAAA;AAEhD,UAAM;AAAA;AAAA;AAIV,iCACE,kBACA,WACkB;AAClB,MAAI,WAAW;AAEf,MAAI,SAAS,WAAW,UAAU;AAChC,eAAW,SAAS,MAAM;AAAA,aACjB,SAAS,WAAW,YAAY;AACzC,eAAW,SAAS,MAAM;AAAA;AAG5B,QAAM,MAAM,aAAc,MAAM;AAChC,MAAI,CAAC,KAAK;AACR,UAAM,IAAI,MAAM,mCAAmC,QAAQ;AAAA;AAG7D,QAAM,iBAAiB,oBAAK,QAAQ,KAAK;AAEzC,SAAO,OAAO;AAAA;",
  "names": []
}
