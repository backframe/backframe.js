{
  "version": 3,
  "sources": ["../../src/tools/byline.ts"],
  "sourcesContent": ["// Copyright (C) 2011-2015 John Hewson\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\nconst stream = require('stream'),\n  util = require('util')\n\n// convinience API\nexport default function byline(readStream, options?: any) {\n  return module.exports.createStream(readStream, options)\n}\n\n// basic API\nmodule.exports.createStream = function (readStream, options) {\n  if (readStream) {\n    return createLineStream(readStream, options)\n  } else {\n    return new LineStream(options)\n  }\n}\n\nexport function createLineStream(readStream, options) {\n  if (!readStream) {\n    throw new Error('expected readStream')\n  }\n  if (!readStream.readable) {\n    throw new Error('readStream must be readable')\n  }\n  const ls = new LineStream(options)\n  readStream.pipe(ls)\n  return ls\n}\n\n//\n// using the new node v0.10 \"streams2\" API\n//\n\nmodule.exports.LineStream = LineStream\n\nfunction LineStream(this, options) {\n  stream.Transform.call(this, options)\n  options = options || {}\n\n  // use objectMode to stop the output from being buffered\n  // which re-concatanates the lines, just without newlines.\n  this._readableState.objectMode = true\n  this._lineBuffer = []\n  this._keepEmptyLines = options.keepEmptyLines || false\n  this._lastChunkEndedWithCR = false\n\n  // take the source's encoding if we don't have one\n  this.on('pipe', function (this, src) {\n    if (!this.encoding) {\n      // but we can't do this for old-style streams\n      if (src instanceof stream.Readable) {\n        this.encoding = src._readableState.encoding\n      }\n    }\n  })\n}\nutil.inherits(LineStream, stream.Transform)\n\nLineStream.prototype._transform = function (chunk, encoding, done) {\n  // decode binary chunks as UTF-8\n  encoding = encoding || 'utf8'\n\n  if (Buffer.isBuffer(chunk)) {\n    if (encoding == 'buffer') {\n      chunk = chunk.toString() // utf8\n      encoding = 'utf8'\n    } else {\n      chunk = chunk.toString(encoding)\n    }\n  }\n  this._chunkEncoding = encoding\n\n  const lines = chunk.split(/\\r\\n|\\r|\\n/g)\n\n  // don't split CRLF which spans chunks\n  if (this._lastChunkEndedWithCR && chunk[0] == '\\n') {\n    lines.shift()\n  }\n\n  if (this._lineBuffer.length > 0) {\n    this._lineBuffer[this._lineBuffer.length - 1] += lines[0]\n    lines.shift()\n  }\n\n  this._lastChunkEndedWithCR = chunk[chunk.length - 1] == '\\r'\n  this._lineBuffer = this._lineBuffer.concat(lines)\n  this._pushBuffer(encoding, 1, done)\n}\n\nLineStream.prototype._pushBuffer = function (encoding, keep, done) {\n  // always buffer the last (possibly partial) line\n  while (this._lineBuffer.length > keep) {\n    const line = this._lineBuffer.shift()\n    // skip empty lines\n    if (this._keepEmptyLines || line.length > 0) {\n      if (!this.push(this._reencode(line, encoding))) {\n        // when the high-water mark is reached, defer pushes until the next tick\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const self = this\n        setImmediate(function () {\n          self._pushBuffer(encoding, keep, done)\n        })\n        return\n      }\n    }\n  }\n  done()\n}\n\nLineStream.prototype._flush = function (done) {\n  this._pushBuffer(this._chunkEncoding, 0, done)\n}\n\n// see Readable::push\nLineStream.prototype._reencode = function (line, chunkEncoding) {\n  if (this.encoding && this.encoding != chunkEncoding) {\n    return Buffer.from(line, chunkEncoding).toString(this.encoding)\n  } else if (this.encoding) {\n    // this should be the most common case, i.e. we're using an encoded source stream\n    return line\n  } else {\n    return Buffer.from(line, chunkEncoding)\n  }\n}\n"],
  "mappings": ";;;;;;;AAAA;AAAA;AAAA;AAAA;AAoBA,MAAM,SAAS,QAAQ,WACrB,OAAO,QAAQ;AAGF,gBAAgB,YAAY,SAAe;AACxD,SAAO,OAAO,QAAQ,aAAa,YAAY;AAAA;AAIjD,OAAO,QAAQ,eAAe,SAAU,YAAY,SAAS;AAC3D,MAAI,YAAY;AACd,WAAO,iBAAiB,YAAY;AAAA,SAC/B;AACL,WAAO,IAAI,WAAW;AAAA;AAAA;AAInB,0BAA0B,YAAY,SAAS;AACpD,MAAI,CAAC,YAAY;AACf,UAAM,IAAI,MAAM;AAAA;AAElB,MAAI,CAAC,WAAW,UAAU;AACxB,UAAM,IAAI,MAAM;AAAA;AAElB,QAAM,KAAK,IAAI,WAAW;AAC1B,aAAW,KAAK;AAChB,SAAO;AAAA;AAOT,OAAO,QAAQ,aAAa;AAE5B,oBAA0B,SAAS;AACjC,SAAO,UAAU,KAAK,MAAM;AAC5B,YAAU,WAAW;AAIrB,OAAK,eAAe,aAAa;AACjC,OAAK,cAAc;AACnB,OAAK,kBAAkB,QAAQ,kBAAkB;AACjD,OAAK,wBAAwB;AAG7B,OAAK,GAAG,QAAQ,SAAgB,KAAK;AACnC,QAAI,CAAC,KAAK,UAAU;AAElB,UAAI,eAAe,OAAO,UAAU;AAClC,aAAK,WAAW,IAAI,eAAe;AAAA;AAAA;AAAA;AAAA;AAK3C,KAAK,SAAS,YAAY,OAAO;AAEjC,WAAW,UAAU,aAAa,SAAU,OAAO,UAAU,MAAM;AAEjE,aAAW,YAAY;AAEvB,MAAI,OAAO,SAAS,QAAQ;AAC1B,QAAI,YAAY,UAAU;AACxB,cAAQ,MAAM;AACd,iBAAW;AAAA,WACN;AACL,cAAQ,MAAM,SAAS;AAAA;AAAA;AAG3B,OAAK,iBAAiB;AAEtB,QAAM,QAAQ,MAAM,MAAM;AAG1B,MAAI,KAAK,yBAAyB,MAAM,MAAM,MAAM;AAClD,UAAM;AAAA;AAGR,MAAI,KAAK,YAAY,SAAS,GAAG;AAC/B,SAAK,YAAY,KAAK,YAAY,SAAS,MAAM,MAAM;AACvD,UAAM;AAAA;AAGR,OAAK,wBAAwB,MAAM,MAAM,SAAS,MAAM;AACxD,OAAK,cAAc,KAAK,YAAY,OAAO;AAC3C,OAAK,YAAY,UAAU,GAAG;AAAA;AAGhC,WAAW,UAAU,cAAc,SAAU,UAAU,MAAM,MAAM;AAEjE,SAAO,KAAK,YAAY,SAAS,MAAM;AACrC,UAAM,OAAO,KAAK,YAAY;AAE9B,QAAI,KAAK,mBAAmB,KAAK,SAAS,GAAG;AAC3C,UAAI,CAAC,KAAK,KAAK,KAAK,UAAU,MAAM,YAAY;AAG9C,cAAM,OAAO;AACb,qBAAa,WAAY;AACvB,eAAK,YAAY,UAAU,MAAM;AAAA;AAEnC;AAAA;AAAA;AAAA;AAIN;AAAA;AAGF,WAAW,UAAU,SAAS,SAAU,MAAM;AAC5C,OAAK,YAAY,KAAK,gBAAgB,GAAG;AAAA;AAI3C,WAAW,UAAU,YAAY,SAAU,MAAM,eAAe;AAC9D,MAAI,KAAK,YAAY,KAAK,YAAY,eAAe;AACnD,WAAO,OAAO,KAAK,MAAM,eAAe,SAAS,KAAK;AAAA,aAC7C,KAAK,UAAU;AAExB,WAAO;AAAA,SACF;AACL,WAAO,OAAO,KAAK,MAAM;AAAA;AAAA;",
  "names": []
}
