{
  "version": 3,
  "sources": ["../src/convertCredentials.ts"],
  "sourcesContent": ["import { DatabaseCredentials } from './types'\nimport * as NodeURL from 'url'\nimport { ConnectorType } from '@prisma/generator-helper'\nimport path from 'path'\n\nexport function credentialsToUri(credentials: DatabaseCredentials): string {\n  const type = databaseTypeToProtocol(credentials.type)\n  if (credentials.type === 'mongodb') {\n    return credentials.uri!\n  }\n  const url = new NodeURL.URL(type + '//')\n\n  if (credentials.host) {\n    url.hostname = credentials.host\n  }\n\n  if (credentials.type === 'postgresql') {\n    if (credentials.database) {\n      url.pathname = '/' + credentials.database\n    }\n\n    if (credentials.schema) {\n      url.searchParams.set('schema', credentials.schema)\n    }\n\n    if (credentials.socket) {\n      url.host = credentials.socket\n    }\n  } else if (credentials.type === 'mysql') {\n    url.pathname = '/' + (credentials.database || credentials.schema || '')\n    if (credentials.socket) {\n      url.searchParams.set('socket', credentials.socket)\n    }\n  }\n\n  if (credentials.ssl) {\n    url.searchParams.set('sslmode', 'prefer')\n  }\n\n  if (credentials.user) {\n    url.username = credentials.user\n  }\n\n  if (credentials.password) {\n    url.password = credentials.password\n  }\n\n  if (credentials.port) {\n    url.port = String(credentials.port)\n  }\n\n  url.host = `${url.hostname}${url.port ? `:${url.port}` : ''}`\n\n  if (credentials.extraFields) {\n    for (const [key, value] of Object.entries(credentials.extraFields)) {\n      url.searchParams.set(key, value)\n    }\n  }\n\n  // trim away empty pathnames\n  if (url.pathname === '/') {\n    url.pathname = ''\n  }\n\n  if (credentials.type === 'sqlite') {\n    // if `file:../parent-dev.db` return as it is\n    return credentials.uri!\n  }\n\n  return url.toString()\n}\n\nexport function uriToCredentials(\n  connectionString: string,\n): DatabaseCredentials {\n  let uri: NodeURL.URL\n  try {\n    uri = new NodeURL.URL(connectionString)\n  } catch (e) {\n    throw new Error(\n      'Invalid data source URL, see https://www.prisma.io/docs/reference/database-reference/connection-urls',\n    )\n  }\n\n  const type = protocolToConnectorType(uri.protocol)\n\n  // needed, as the URL implementation adds empty strings\n  const exists = (str): boolean => str && str.length > 0\n\n  if (type === 'mongodb') {\n    return {\n      type,\n      uri: connectionString, // todo: set authsource as database if not provided explicitly\n    }\n  }\n\n  const extraFields = {}\n  const schema = uri.searchParams.get('schema')\n  const socket = uri.searchParams.get('socket')\n\n  for (const [name, value] of uri.searchParams) {\n    if (!['schema', 'socket'].includes(name)) {\n      extraFields[name] = value\n    }\n  }\n\n  let database: string | undefined = undefined\n  let defaultSchema: string | undefined = undefined\n\n  if (type === 'sqlite' && uri.pathname) {\n    if (uri.pathname.startsWith('file:')) {\n      database = uri.pathname.slice(5)\n    }\n    if (uri.pathname.startsWith('sqlite:')) {\n      database = uri.pathname.slice(7)\n    } else {\n      database = path.basename(uri.pathname)\n    }\n  } else if (uri.pathname.length > 1) {\n    database = uri.pathname.slice(1)\n\n    if (type === 'postgresql' && !database) {\n      // use postgres as default, it's 99% accurate\n      // could also be template1 for example in rare cases\n      database = 'postgres'\n    }\n  }\n\n  if (type === 'postgresql' && !schema) {\n    // default to public schema\n    defaultSchema = 'public'\n  }\n\n  return {\n    type,\n    host: exists(uri.hostname) ? uri.hostname : undefined,\n    user: exists(uri.username) ? uri.username : undefined,\n    port: exists(uri.port) ? Number(uri.port) : undefined,\n    password: exists(uri.password) ? uri.password : undefined,\n    database,\n    schema: schema || defaultSchema,\n    uri: connectionString,\n    ssl: Boolean(uri.searchParams.get('sslmode')),\n    socket: socket || undefined,\n    extraFields,\n  }\n}\n\nfunction databaseTypeToProtocol(databaseType: ConnectorType): string {\n  switch (databaseType) {\n    case 'postgresql':\n      return 'postgresql:'\n    case 'mysql':\n      return 'mysql:'\n    case 'mongodb':\n      return 'mongodb:'\n    case 'sqlite':\n      return 'sqlite:'\n    case 'sqlserver':\n      return 'sqlserver:'\n  }\n}\n\nexport function protocolToConnectorType(protocol: string): ConnectorType {\n  switch (protocol) {\n    case 'postgresql:':\n    case 'postgres:':\n      return 'postgresql'\n    case 'mongodb:':\n      return 'mongodb'\n    case 'mysql:':\n      return 'mysql'\n    case 'file:':\n    case 'sqlite:':\n      return 'sqlite'\n    case 'sqlserver:':\n    case 'jdbc:sqlserver:':\n      return 'sqlserver'\n  }\n\n  throw new Error(`Unknown database type ${protocol}`)\n}\n"],
  "mappings": "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",
  "names": []
}
