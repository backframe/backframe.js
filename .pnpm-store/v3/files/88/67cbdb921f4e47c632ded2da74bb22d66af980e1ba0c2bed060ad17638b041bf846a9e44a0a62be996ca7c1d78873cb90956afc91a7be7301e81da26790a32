{
  "version": 3,
  "sources": ["../../src/engine-commands/getConfig.ts"],
  "sourcesContent": ["import Debug from '@prisma/debug'\nimport { NodeAPILibraryTypes } from '@prisma/engine-core'\nimport { getCliQueryEngineBinaryType } from '@prisma/engines'\nimport { BinaryType } from '@prisma/fetch-engine'\nimport { DataSource, GeneratorConfig } from '@prisma/generator-helper'\nimport { isNodeAPISupported } from '@prisma/get-platform'\nimport chalk from 'chalk'\nimport execa from 'execa'\nimport fs from 'fs'\nimport tmpWrite from 'temp-write'\nimport { promisify } from 'util'\nimport { resolveBinary } from '../resolveBinary'\nimport { load } from '../utils/load'\n\nconst debug = Debug('prisma:getConfig')\n\nconst unlink = promisify(fs.unlink)\n\nconst MAX_BUFFER = 1_000_000_000\n\nexport interface ConfigMetaFormat {\n  datasources: DataSource[]\n  generators: GeneratorConfig[]\n  warnings: string[]\n}\n\nexport type GetConfigOptions = {\n  datamodel: string\n  cwd?: string\n  prismaPath?: string\n  datamodelPath?: string\n  retry?: number\n  ignoreEnvVarErrors?: boolean\n}\nexport class GetConfigError extends Error {\n  constructor(message: string) {\n    super(chalk.redBright.bold('Get config: ') + message)\n  }\n}\n// TODO add error handling functions\nexport async function getConfig(\n  options: GetConfigOptions,\n): Promise<ConfigMetaFormat> {\n  const cliEngineBinaryType = getCliQueryEngineBinaryType()\n  let data: ConfigMetaFormat | undefined\n  if (cliEngineBinaryType === BinaryType.libqueryEngine) {\n    data = await getConfigNodeAPI(options)\n  } else {\n    data = await getConfigBinary(options)\n  }\n\n  if (!data) throw new GetConfigError(`Failed to return any data`)\n\n  // TODO This has been outdated for ages and needs to be handled differently and/or removed\n  if (\n    data.datasources?.[0]?.provider === 'sqlite' &&\n    data.generators.some((g) => g.previewFeatures.includes('createMany'))\n  ) {\n    const message = `Database provider \"sqlite\" and the preview feature \"createMany\" can't be used at the same time.\n  Please either remove the \"createMany\" feature flag or use any other database type that Prisma supports: postgres, mysql or sqlserver.`\n    throw new GetConfigError(message)\n  }\n\n  return data\n}\n\nasync function getConfigNodeAPI(\n  options: GetConfigOptions,\n): Promise<ConfigMetaFormat> {\n  let data: ConfigMetaFormat | undefined\n  const queryEnginePath = await resolveBinary(\n    BinaryType.libqueryEngine,\n    options.prismaPath,\n  )\n  await isNodeAPISupported()\n  debug(`Using Node-API Query Engine at: ${queryEnginePath}`)\n  try {\n    const NodeAPIQueryEngineLibrary =\n      load<NodeAPILibraryTypes.Library>(queryEnginePath)\n    data = await NodeAPIQueryEngineLibrary.getConfig({\n      datamodel: options.datamodel,\n      datasourceOverrides: {},\n      ignoreEnvVarErrors: options.ignoreEnvVarErrors ?? false,\n      env: process.env,\n    })\n  } catch (e) {\n    let error\n    try {\n      error = JSON.parse(e.message)\n    } catch {\n      throw e\n    }\n    let message: string\n    if (error.error_code === 'P1012') {\n      message =\n        chalk.redBright(`Schema Parsing ${error.error_code}\\n\\n`) +\n        error.message +\n        '\\n'\n    } else {\n      message = chalk.redBright(`${error.error_code}\\n\\n`) + error\n    }\n    throw new GetConfigError(message)\n  }\n  return data\n}\n\nasync function getConfigBinary(\n  options: GetConfigOptions,\n): Promise<ConfigMetaFormat | undefined> {\n  let data: ConfigMetaFormat | undefined\n\n  const queryEnginePath = await resolveBinary(\n    BinaryType.queryEngine,\n    options.prismaPath,\n  )\n  debug(`Using Query Engine Binary at: ${queryEnginePath}`)\n\n  try {\n    let tempDatamodelPath: string | undefined = options.datamodelPath\n    if (!tempDatamodelPath) {\n      try {\n        tempDatamodelPath = await tmpWrite(options.datamodel!)\n      } catch (err) {\n        throw new GetConfigError('Unable to write temp data model path')\n      }\n    }\n    const engineArgs = []\n\n    const args = options.ignoreEnvVarErrors ? ['--ignoreEnvVarErrors'] : []\n\n    const result = await execa(\n      queryEnginePath,\n      [...engineArgs, 'cli', 'get-config', ...args],\n      {\n        cwd: options.cwd,\n        env: {\n          PRISMA_DML_PATH: tempDatamodelPath,\n          RUST_BACKTRACE: '1',\n        },\n        maxBuffer: MAX_BUFFER,\n      },\n    )\n\n    if (!options.datamodelPath) {\n      await unlink(tempDatamodelPath)\n    }\n\n    data = JSON.parse(result.stdout)\n  } catch (e) {\n    if (e.stderr || e.stdout) {\n      const error = e.stderr ? e.stderr : e.stout\n      let jsonError, message\n      try {\n        jsonError = JSON.parse(error)\n        message = `${chalk.redBright(jsonError.message)}\\n`\n        if (jsonError.error_code) {\n          if (jsonError.error_code === 'P1012') {\n            message =\n              chalk.redBright(`Schema Parsing ${jsonError.error_code}\\n\\n`) +\n              message\n          } else {\n            message = chalk.redBright(`${jsonError.error_code}\\n\\n`) + message\n          }\n        }\n      } catch (e) {\n        // if JSON parse / pretty handling fails, fallback to simple printing\n        throw new GetConfigError(error)\n      }\n\n      throw new GetConfigError(message)\n    }\n\n    throw new GetConfigError(e)\n  }\n  return data\n}\n"],
  "mappings": "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",
  "names": []
}
