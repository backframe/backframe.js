{
  "version": 3,
  "sources": ["../../src/engine-commands/getDmmf.ts"],
  "sourcesContent": ["import Debug from '@prisma/debug'\nimport { NodeAPILibraryTypes } from '@prisma/engine-core'\nimport { getCliQueryEngineBinaryType } from '@prisma/engines'\nimport { BinaryType } from '@prisma/fetch-engine'\nimport { DataSource, DMMF, GeneratorConfig } from '@prisma/generator-helper'\nimport { isNodeAPISupported } from '@prisma/get-platform'\nimport chalk from 'chalk'\nimport execa, { ExecaChildProcess, ExecaReturnValue } from 'execa'\nimport fs from 'fs'\nimport tmpWrite from 'temp-write'\nimport { promisify } from 'util'\nimport { resolveBinary } from '../resolveBinary'\nimport { load } from '../utils/load'\n\nconst debug = Debug('prisma:getDMMF')\n\nconst unlink = promisify(fs.unlink)\n\nconst MAX_BUFFER = 1_000_000_000\n\nexport interface ConfigMetaFormat {\n  datasources: DataSource[]\n  generators: GeneratorConfig[]\n  warnings: string[]\n}\n\nexport type GetDMMFOptions = {\n  datamodel?: string\n  cwd?: string\n  prismaPath?: string\n  datamodelPath?: string\n  retry?: number\n  previewFeatures?: string[]\n}\n// TODO add error handling functions\nexport async function getDMMF(options: GetDMMFOptions): Promise<DMMF.Document> {\n  warnOnDeprecatedFeatureFlag(options.previewFeatures)\n  const cliEngineBinaryType = getCliQueryEngineBinaryType()\n  let dmmf: DMMF.Document | undefined\n  if (cliEngineBinaryType === BinaryType.libqueryEngine) {\n    dmmf = await getDmmfNodeAPI(options)\n  } else {\n    dmmf = await getDmmfBinary(options)\n  }\n  return dmmf\n}\n\nasync function getDmmfNodeAPI(options: GetDMMFOptions): Promise<DMMF.Document> {\n  const queryEnginePath = await resolveBinary(\n    BinaryType.libqueryEngine,\n    options.prismaPath,\n  )\n  await isNodeAPISupported()\n\n  debug(`Using Node-API Query Engine at: ${queryEnginePath}`)\n  const NodeAPIQueryEngineLibrary =\n    load<NodeAPILibraryTypes.Library>(queryEnginePath)\n  const datamodel =\n    options.datamodel ?? fs.readFileSync(options.datamodelPath!, 'utf-8')\n  let dmmf: DMMF.Document | undefined\n  try {\n    dmmf = JSON.parse(\n      await NodeAPIQueryEngineLibrary.dmmf(datamodel),\n    ) as DMMF.Document\n  } catch (e) {\n    const error = JSON.parse(e.message)\n    const message = addMissingOpenSSLInfo(error.message)\n    throw new Error(chalk.redBright.bold('Schema parsing\\n') + message)\n  }\n  return dmmf\n}\n\nasync function getDmmfBinary(options: GetDMMFOptions): Promise<DMMF.Document> {\n  let result: ExecaChildProcess<string> | undefined | ExecaReturnValue<string>\n  const queryEnginePath = await resolveBinary(\n    BinaryType.queryEngine,\n    options.prismaPath,\n  )\n  debug(`Using Query Engine Binary at: ${queryEnginePath}`)\n\n  try {\n    let tempDatamodelPath: string | undefined = options.datamodelPath\n    if (!tempDatamodelPath) {\n      try {\n        tempDatamodelPath = await tmpWrite(options.datamodel!)\n      } catch (err) {\n        throw new Error(\n          chalk.redBright.bold('Get DMMF ') +\n            'unable to write temp data model path',\n        )\n      }\n    }\n    const execaOptions = {\n      cwd: options.cwd,\n      env: {\n        PRISMA_DML_PATH: tempDatamodelPath,\n        RUST_BACKTRACE: '1',\n        ...(process.env.NO_COLOR ? {} : { CLICOLOR_FORCE: '1' }),\n      },\n      maxBuffer: MAX_BUFFER,\n    }\n\n    const args = ['--enable-raw-queries', 'cli', 'dmmf']\n    result = await execa(queryEnginePath, args, execaOptions)\n\n    if (!options.datamodelPath) {\n      await unlink(tempDatamodelPath)\n    }\n\n    if (\n      result.stdout.includes('Please wait until the') &&\n      options.retry &&\n      options.retry > 0\n    ) {\n      debug('Retrying after \"Please wait until\"')\n      await new Promise((r) => setTimeout(r, 5000))\n      return getDMMF({\n        ...options,\n        retry: options.retry - 1,\n      })\n    }\n\n    // necessary, as sometimes the query engine prints some other stuff\n    const firstCurly = result.stdout.indexOf('{')\n    const stdout = result.stdout.slice(firstCurly)\n\n    return JSON.parse(stdout)\n  } catch (e) {\n    debug('getDMMF failed', e)\n    // If this unlikely event happens, try it at least once more\n    if (\n      e.message.includes('Command failed with exit code 26 (ETXTBSY)') &&\n      options.retry &&\n      options.retry > 0\n    ) {\n      await new Promise((resolve) => setTimeout(resolve, 500))\n      debug('Retrying after ETXTBSY')\n      return getDMMF({\n        ...options,\n        retry: options.retry - 1,\n      })\n    }\n    const output = e.stderr || e.stdout\n    if (output) {\n      let json\n      try {\n        json = JSON.parse(output)\n      } catch (e) {\n        //\n      }\n      let message = (json && json.message) || output\n      message = addMissingOpenSSLInfo(message)\n      throw new Error(chalk.redBright.bold('Schema parsing\\n') + message)\n    }\n    if (e.message.includes('in JSON at position')) {\n      throw new Error(\n        `Problem while parsing the query engine response at ${queryEnginePath}. ${result?.stdout}\\n${e.stack}`,\n      )\n    }\n    throw new Error(e)\n  }\n}\n\nfunction addMissingOpenSSLInfo(message: string) {\n  if (\n    message.includes(\n      'debian-openssl-1.1.x: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directory',\n    ) ||\n    message.includes(\n      'debian-openssl-1.0.x: error while loading shared libraries: libssl.so.1.0.0: cannot open shared object file: No such file or directory',\n    )\n  ) {\n    message += `\\n${chalk.green(\n      `Your linux installation misses the openssl package. You can install it like so:\\n`,\n    )}${chalk.green.bold('apt-get -qy update && apt-get -qy install openssl')}`\n  }\n  return message\n}\nfunction warnOnDeprecatedFeatureFlag(previewFeatures?: string[]) {\n  const getMessage = (flag: string) =>\n    `${chalk.blueBright(\n      'info',\n    )} The preview flag \"${flag}\" is not needed anymore, please remove it from your schema.prisma`\n\n  const removedFeatureFlagMap = {\n    insensitiveFilters: getMessage('insensitiveFilters'),\n    atomicNumberOperations: getMessage('atomicNumberOperations'),\n    connectOrCreate: getMessage('connectOrCreate'),\n    transaction: getMessage('transaction'),\n    transactionApi: getMessage('transactionApi'),\n    uncheckedScalarInputs: getMessage('uncheckedScalarInputs'),\n    nativeTypes: getMessage('nativeTypes'),\n    createMany: getMessage('createMany'),\n    groupBy: getMessage('groupBy'),\n  }\n\n  previewFeatures?.forEach((f) => {\n    const removedMessage = removedFeatureFlagMap[f]\n    if (removedMessage && !process.env.PRISMA_HIDE_PREVIEW_FLAG_WARNINGS) {\n      console.warn(removedMessage)\n    }\n  })\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA,mBAAkB;AAElB,qBAA4C;AAC5C,0BAA2B;AAE3B,0BAAmC;AACnC,mBAAkB;AAClB,mBAA2D;AAC3D,gBAAe;AACf,wBAAqB;AACrB,kBAA0B;AAC1B,2BAA8B;AAC9B,kBAAqB;AAErB,MAAM,QAAQ,0BAAM;AAEpB,MAAM,SAAS,2BAAU,kBAAG;AAE5B,MAAM,aAAa;AAiBnB,uBAA8B,SAAiD;AAC7E,8BAA4B,QAAQ;AACpC,QAAM,sBAAsB;AAC5B,MAAI;AACJ,MAAI,wBAAwB,+BAAW,gBAAgB;AACrD,WAAO,MAAM,eAAe;AAAA,SACvB;AACL,WAAO,MAAM,cAAc;AAAA;AAE7B,SAAO;AAAA;AAGT,8BAA8B,SAAiD;AA/C/E;AAgDE,QAAM,kBAAkB,MAAM,wCAC5B,+BAAW,gBACX,QAAQ;AAEV,QAAM;AAEN,QAAM,mCAAmC;AACzC,QAAM,4BACJ,sBAAkC;AACpC,QAAM,YACJ,cAAQ,cAAR,YAAqB,kBAAG,aAAa,QAAQ,eAAgB;AAC/D,MAAI;AACJ,MAAI;AACF,WAAO,KAAK,MACV,MAAM,0BAA0B,KAAK;AAAA,WAEhC,GAAP;AACA,UAAM,QAAQ,KAAK,MAAM,EAAE;AAC3B,UAAM,UAAU,sBAAsB,MAAM;AAC5C,UAAM,IAAI,MAAM,qBAAM,UAAU,KAAK,sBAAsB;AAAA;AAE7D,SAAO;AAAA;AAGT,6BAA6B,SAAiD;AAC5E,MAAI;AACJ,QAAM,kBAAkB,MAAM,wCAC5B,+BAAW,aACX,QAAQ;AAEV,QAAM,iCAAiC;AAEvC,MAAI;AACF,QAAI,oBAAwC,QAAQ;AACpD,QAAI,CAAC,mBAAmB;AACtB,UAAI;AACF,4BAAoB,MAAM,+BAAS,QAAQ;AAAA,eACpC,KAAP;AACA,cAAM,IAAI,MACR,qBAAM,UAAU,KAAK,eACnB;AAAA;AAAA;AAIR,UAAM,eAAe;AAAA,MACnB,KAAK,QAAQ;AAAA,MACb,KAAK;AAAA,QACH,iBAAiB;AAAA,QACjB,gBAAgB;AAAA,WACZ,QAAQ,IAAI,WAAW,KAAK,EAAE,gBAAgB;AAAA;AAAA,MAEpD,WAAW;AAAA;AAGb,UAAM,OAAO,CAAC,wBAAwB,OAAO;AAC7C,aAAS,MAAM,0BAAM,iBAAiB,MAAM;AAE5C,QAAI,CAAC,QAAQ,eAAe;AAC1B,YAAM,OAAO;AAAA;AAGf,QACE,OAAO,OAAO,SAAS,4BACvB,QAAQ,SACR,QAAQ,QAAQ,GAChB;AACA,YAAM;AACN,YAAM,IAAI,QAAQ,CAAC,MAAM,WAAW,GAAG;AACvC,aAAO,QAAQ;AAAA,WACV;AAAA,QACH,OAAO,QAAQ,QAAQ;AAAA;AAAA;AAK3B,UAAM,aAAa,OAAO,OAAO,QAAQ;AACzC,UAAM,SAAS,OAAO,OAAO,MAAM;AAEnC,WAAO,KAAK,MAAM;AAAA,WACX,GAAP;AACA,UAAM,kBAAkB;AAExB,QACE,EAAE,QAAQ,SAAS,iDACnB,QAAQ,SACR,QAAQ,QAAQ,GAChB;AACA,YAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS;AACnD,YAAM;AACN,aAAO,QAAQ;AAAA,WACV;AAAA,QACH,OAAO,QAAQ,QAAQ;AAAA;AAAA;AAG3B,UAAM,SAAS,EAAE,UAAU,EAAE;AAC7B,QAAI,QAAQ;AACV,UAAI;AACJ,UAAI;AACF,eAAO,KAAK,MAAM;AAAA,eACX,IAAP;AAAA;AAGF,UAAI,UAAW,QAAQ,KAAK,WAAY;AACxC,gBAAU,sBAAsB;AAChC,YAAM,IAAI,MAAM,qBAAM,UAAU,KAAK,sBAAsB;AAAA;AAE7D,QAAI,EAAE,QAAQ,SAAS,wBAAwB;AAC7C,YAAM,IAAI,MACR,sDAAsD,oBAAoB,iCAAQ;AAAA,EAAW,EAAE;AAAA;AAGnG,UAAM,IAAI,MAAM;AAAA;AAAA;AAIpB,+BAA+B,SAAiB;AAC9C,MACE,QAAQ,SACN,2IAEF,QAAQ,SACN,2IAEF;AACA,eAAW;AAAA,EAAK,qBAAM,MACpB;AAAA,KACE,qBAAM,MAAM,KAAK;AAAA;AAEvB,SAAO;AAAA;AAET,qCAAqC,iBAA4B;AAC/D,QAAM,aAAa,CAAC,SAClB,GAAG,qBAAM,WACP,6BACqB;AAEzB,QAAM,wBAAwB;AAAA,IAC5B,oBAAoB,WAAW;AAAA,IAC/B,wBAAwB,WAAW;AAAA,IACnC,iBAAiB,WAAW;AAAA,IAC5B,aAAa,WAAW;AAAA,IACxB,gBAAgB,WAAW;AAAA,IAC3B,uBAAuB,WAAW;AAAA,IAClC,aAAa,WAAW;AAAA,IACxB,YAAY,WAAW;AAAA,IACvB,SAAS,WAAW;AAAA;AAGtB,qDAAiB,QAAQ,CAAC,MAAM;AAC9B,UAAM,iBAAiB,sBAAsB;AAC7C,QAAI,kBAAkB,CAAC,QAAQ,IAAI,mCAAmC;AACpE,cAAQ,KAAK;AAAA;AAAA;AAAA;",
  "names": []
}
