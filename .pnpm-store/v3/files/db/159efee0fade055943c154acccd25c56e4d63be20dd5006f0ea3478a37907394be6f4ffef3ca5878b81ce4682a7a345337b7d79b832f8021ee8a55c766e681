{
  "version": 3,
  "sources": ["../../src/utils/getEnvPaths.ts"],
  "sourcesContent": ["import Debug from '@prisma/debug'\nimport findUp from 'find-up'\nimport path from 'path'\nimport fs from 'fs'\nimport { getSchemaPathFromPackageJsonSync } from '../cli/getSchema'\nimport { exists } from './tryLoadEnvs'\n\nconst debug = Debug('prisma:loadEnv')\n/**\n *  1. Search in project root\n *  1. Schema\n *    1. Search location from schema arg `--schema`\n *    1. Search location from pkgJSON `\"prisma\": {\"schema\": \"/path/to/schema.prisma\"}`\n *    1. Search default location `./prisma/.env`\n *    1. Search cwd `./.env`\n *\n * @returns `{ rootEnvPath, schemaEnvPath }`\n */\nexport function getEnvPaths(\n  schemaPath?: string | null,\n  opts: { cwd: string } = { cwd: process.cwd() },\n) {\n  const rootEnvPath = getProjectRootEnvPath({ cwd: opts.cwd }) ?? null\n  const schemaEnvPathFromArgs = schemaPathToEnvPath(schemaPath)\n  const schemaEnvPathFromPkgJson = schemaPathToEnvPath(\n    readSchemaPathFromPkgJson(),\n  )\n  const schemaEnvPaths = [\n    schemaEnvPathFromArgs, // 1 - Check --schema directory for .env\n    schemaEnvPathFromPkgJson, // 2 - Check package.json schema directory for .env\n    './prisma/.env', // 3 - Check ./prisma directory for .env\n    './.env', // 4 - Check cwd for .env\n  ]\n  const schemaEnvPath = schemaEnvPaths.find(exists)\n  return { rootEnvPath, schemaEnvPath }\n}\n\nfunction readSchemaPathFromPkgJson(): string | null {\n  try {\n    return getSchemaPathFromPackageJsonSync(process.cwd())\n  } catch {\n    return null\n  }\n}\n\nfunction getProjectRootEnvPath(\n  opts: findUp.Options | undefined,\n): string | null {\n  const pkgJsonPath = findUp.sync((dir) => {\n    const pkgPath = path.join(dir, 'package.json')\n    if (findUp.exists(pkgPath)) {\n      try {\n        const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'))\n        if (pkg['name'] !== '.prisma/client') {\n          debug(`project root found at ${pkgPath}`)\n          return pkgPath\n        }\n      } catch (e) {\n        debug(`skipping package.json at ${pkgPath}`)\n      }\n    }\n\n    return undefined\n  }, opts)\n\n  if (!pkgJsonPath) {\n    return null\n  }\n\n  const candidate = path.join(path.dirname(pkgJsonPath), '.env')\n  if (!fs.existsSync(candidate)) {\n    return null\n  }\n\n  return candidate\n}\n\nfunction schemaPathToEnvPath(schemaPath: string | null | undefined) {\n  if (!schemaPath) return null\n  return path.join(path.dirname(schemaPath), '.env')\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA,mBAAkB;AAClB,qBAAmB;AACnB,kBAAiB;AACjB,gBAAe;AACf,uBAAiD;AACjD,yBAAuB;AAEvB,MAAM,QAAQ,0BAAM;AAWb,qBACL,YACA,OAAwB,EAAE,KAAK,QAAQ,SACvC;AArBF;AAsBE,QAAM,cAAc,4BAAsB,EAAE,KAAK,KAAK,WAAlC,YAA4C;AAChE,QAAM,wBAAwB,oBAAoB;AAClD,QAAM,2BAA2B,oBAC/B;AAEF,QAAM,iBAAiB;AAAA,IACrB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAEF,QAAM,gBAAgB,eAAe,KAAK;AAC1C,SAAO,EAAE,aAAa;AAAA;AAGxB,qCAAoD;AAClD,MAAI;AACF,WAAO,uDAAiC,QAAQ;AAAA,WAC1C,GAAN;AACA,WAAO;AAAA;AAAA;AAIX,+BACE,MACe;AACf,QAAM,cAAc,uBAAO,KAAK,CAAC,QAAQ;AACvC,UAAM,UAAU,oBAAK,KAAK,KAAK;AAC/B,QAAI,uBAAO,OAAO,UAAU;AAC1B,UAAI;AACF,cAAM,MAAM,KAAK,MAAM,kBAAG,aAAa,SAAS;AAChD,YAAI,IAAI,YAAY,kBAAkB;AACpC,gBAAM,yBAAyB;AAC/B,iBAAO;AAAA;AAAA,eAEF,GAAP;AACA,cAAM,4BAA4B;AAAA;AAAA;AAItC,WAAO;AAAA,KACN;AAEH,MAAI,CAAC,aAAa;AAChB,WAAO;AAAA;AAGT,QAAM,YAAY,oBAAK,KAAK,oBAAK,QAAQ,cAAc;AACvD,MAAI,CAAC,kBAAG,WAAW,YAAY;AAC7B,WAAO;AAAA;AAGT,SAAO;AAAA;AAGT,6BAA6B,YAAuC;AAClE,MAAI,CAAC;AAAY,WAAO;AACxB,SAAO,oBAAK,KAAK,oBAAK,QAAQ,aAAa;AAAA;",
  "names": []
}
