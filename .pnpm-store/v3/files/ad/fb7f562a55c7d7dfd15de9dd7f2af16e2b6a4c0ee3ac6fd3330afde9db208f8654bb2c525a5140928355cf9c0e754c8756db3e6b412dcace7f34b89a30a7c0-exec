#!/usr/bin/env node
var __create2 = Object.create;
var __defProp2 = Object.defineProperty;
var __getProtoOf2 = Object.getPrototypeOf;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __markAsModule2 = (target) => __defProp2(target, "__esModule", {value: true});
var __commonJS = (callback, module2) => () => {
  if (!module2) {
    module2 = {exports: {}};
    callback(module2.exports, module2);
  }
  return module2.exports;
};
var __export2 = (target, all) => {
  for (var name in all)
    __defProp2(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames2(module2))
      if (!__hasOwnProp2.call(target, key) && key !== "default")
        __defProp2(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc2(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule2 = (module2) => {
  if (module2 && module2.__esModule)
    return module2;
  return __exportStar(__markAsModule2(__defProp2(module2 != null ? __create2(__getProtoOf2(module2)) : {}, "default", {value: module2, enumerable: true})), module2);
};

// ../../node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js
var require_color_name = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
});

// ../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js
var require_conversions = __commonJS((exports2, module2) => {
  var cssKeywords = require_color_name();
  var reverseKeywords = {};
  for (const key of Object.keys(cssKeywords)) {
    reverseKeywords[cssKeywords[key]] = key;
  }
  var convert = {
    rgb: {channels: 3, labels: "rgb"},
    hsl: {channels: 3, labels: "hsl"},
    hsv: {channels: 3, labels: "hsv"},
    hwb: {channels: 3, labels: "hwb"},
    cmyk: {channels: 4, labels: "cmyk"},
    xyz: {channels: 3, labels: "xyz"},
    lab: {channels: 3, labels: "lab"},
    lch: {channels: 3, labels: "lch"},
    hex: {channels: 1, labels: ["hex"]},
    keyword: {channels: 1, labels: ["keyword"]},
    ansi16: {channels: 1, labels: ["ansi16"]},
    ansi256: {channels: 1, labels: ["ansi256"]},
    hcg: {channels: 3, labels: ["h", "c", "g"]},
    apple: {channels: 3, labels: ["r16", "g16", "b16"]},
    gray: {channels: 1, labels: ["gray"]}
  };
  module2.exports = convert;
  for (const model of Object.keys(convert)) {
    if (!("channels" in convert[model])) {
      throw new Error("missing channels property: " + model);
    }
    if (!("labels" in convert[model])) {
      throw new Error("missing channel labels property: " + model);
    }
    if (convert[model].labels.length !== convert[model].channels) {
      throw new Error("channel and label counts mismatch: " + model);
    }
    const {channels, labels} = convert[model];
    delete convert[model].channels;
    delete convert[model].labels;
    Object.defineProperty(convert[model], "channels", {value: channels});
    Object.defineProperty(convert[model], "labels", {value: labels});
  }
  convert.rgb.hsl = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const delta = max - min;
    let h2;
    let s2;
    if (max === min) {
      h2 = 0;
    } else if (r === max) {
      h2 = (g - b) / delta;
    } else if (g === max) {
      h2 = 2 + (b - r) / delta;
    } else if (b === max) {
      h2 = 4 + (r - g) / delta;
    }
    h2 = Math.min(h2 * 60, 360);
    if (h2 < 0) {
      h2 += 360;
    }
    const l = (min + max) / 2;
    if (max === min) {
      s2 = 0;
    } else if (l <= 0.5) {
      s2 = delta / (max + min);
    } else {
      s2 = delta / (2 - max - min);
    }
    return [h2, s2 * 100, l * 100];
  };
  convert.rgb.hsv = function(rgb) {
    let rdif;
    let gdif;
    let bdif;
    let h2;
    let s2;
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const v = Math.max(r, g, b);
    const diff = v - Math.min(r, g, b);
    const diffc = function(c) {
      return (v - c) / 6 / diff + 1 / 2;
    };
    if (diff === 0) {
      h2 = 0;
      s2 = 0;
    } else {
      s2 = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);
      if (r === v) {
        h2 = bdif - gdif;
      } else if (g === v) {
        h2 = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h2 = 2 / 3 + gdif - rdif;
      }
      if (h2 < 0) {
        h2 += 1;
      } else if (h2 > 1) {
        h2 -= 1;
      }
    }
    return [
      h2 * 360,
      s2 * 100,
      v * 100
    ];
  };
  convert.rgb.hwb = function(rgb) {
    const r = rgb[0];
    const g = rgb[1];
    let b = rgb[2];
    const h2 = convert.rgb.hsl(rgb)[0];
    const w2 = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h2, w2 * 100, b * 100];
  };
  convert.rgb.cmyk = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const k = Math.min(1 - r, 1 - g, 1 - b);
    const c = (1 - r - k) / (1 - k) || 0;
    const m2 = (1 - g - k) / (1 - k) || 0;
    const y2 = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m2 * 100, y2 * 100, k * 100];
  };
  function comparativeDistance(x, y2) {
    return (x[0] - y2[0]) ** 2 + (x[1] - y2[1]) ** 2 + (x[2] - y2[2]) ** 2;
  }
  convert.rgb.keyword = function(rgb) {
    const reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    let currentClosestDistance = Infinity;
    let currentClosestKeyword;
    for (const keyword of Object.keys(cssKeywords)) {
      const value = cssKeywords[keyword];
      const distance = comparativeDistance(rgb, value);
      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }
    return currentClosestKeyword;
  };
  convert.keyword.rgb = function(keyword) {
    return cssKeywords[keyword];
  };
  convert.rgb.xyz = function(rgb) {
    let r = rgb[0] / 255;
    let g = rgb[1] / 255;
    let b = rgb[2] / 255;
    r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
    g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
    b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
    const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    const y2 = r * 0.2126 + g * 0.7152 + b * 0.0722;
    const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y2 * 100, z * 100];
  };
  convert.rgb.lab = function(rgb) {
    const xyz = convert.rgb.xyz(rgb);
    let x = xyz[0];
    let y2 = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y2 /= 100;
    z /= 108.883;
    x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y2 = y2 > 8856e-6 ? y2 ** (1 / 3) : 7.787 * y2 + 16 / 116;
    z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y2 - 16;
    const a = 500 * (x - y2);
    const b = 200 * (y2 - z);
    return [l, a, b];
  };
  convert.hsl.rgb = function(hsl) {
    const h2 = hsl[0] / 360;
    const s2 = hsl[1] / 100;
    const l = hsl[2] / 100;
    let t2;
    let t3;
    let val;
    if (s2 === 0) {
      val = l * 255;
      return [val, val, val];
    }
    if (l < 0.5) {
      t2 = l * (1 + s2);
    } else {
      t2 = l + s2 - l * s2;
    }
    const t1 = 2 * l - t2;
    const rgb = [0, 0, 0];
    for (let i = 0; i < 3; i++) {
      t3 = h2 + 1 / 3 * -(i - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }
      rgb[i] = val * 255;
    }
    return rgb;
  };
  convert.hsl.hsv = function(hsl) {
    const h2 = hsl[0];
    let s2 = hsl[1] / 100;
    let l = hsl[2] / 100;
    let smin = s2;
    const lmin = Math.max(l, 0.01);
    l *= 2;
    s2 *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v = (l + s2) / 2;
    const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s2 / (l + s2);
    return [h2, sv * 100, v * 100];
  };
  convert.hsv.rgb = function(hsv) {
    const h2 = hsv[0] / 60;
    const s2 = hsv[1] / 100;
    let v = hsv[2] / 100;
    const hi = Math.floor(h2) % 6;
    const f = h2 - Math.floor(h2);
    const p = 255 * v * (1 - s2);
    const q = 255 * v * (1 - s2 * f);
    const t = 255 * v * (1 - s2 * (1 - f));
    v *= 255;
    switch (hi) {
      case 0:
        return [v, t, p];
      case 1:
        return [q, v, p];
      case 2:
        return [p, v, t];
      case 3:
        return [p, q, v];
      case 4:
        return [t, p, v];
      case 5:
        return [v, p, q];
    }
  };
  convert.hsv.hsl = function(hsv) {
    const h2 = hsv[0];
    const s2 = hsv[1] / 100;
    const v = hsv[2] / 100;
    const vmin = Math.max(v, 0.01);
    let sl;
    let l;
    l = (2 - s2) * v;
    const lmin = (2 - s2) * vmin;
    sl = s2 * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h2, sl * 100, l * 100];
  };
  convert.hwb.rgb = function(hwb) {
    const h2 = hwb[0] / 360;
    let wh = hwb[1] / 100;
    let bl = hwb[2] / 100;
    const ratio = wh + bl;
    let f;
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    const i = Math.floor(6 * h2);
    const v = 1 - bl;
    f = 6 * h2 - i;
    if ((i & 1) !== 0) {
      f = 1 - f;
    }
    const n = wh + f * (v - wh);
    let r;
    let g;
    let b;
    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;
      case 1:
        r = n;
        g = v;
        b = wh;
        break;
      case 2:
        r = wh;
        g = v;
        b = n;
        break;
      case 3:
        r = wh;
        g = n;
        b = v;
        break;
      case 4:
        r = n;
        g = wh;
        b = v;
        break;
      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }
    return [r * 255, g * 255, b * 255];
  };
  convert.cmyk.rgb = function(cmyk) {
    const c = cmyk[0] / 100;
    const m2 = cmyk[1] / 100;
    const y2 = cmyk[2] / 100;
    const k = cmyk[3] / 100;
    const r = 1 - Math.min(1, c * (1 - k) + k);
    const g = 1 - Math.min(1, m2 * (1 - k) + k);
    const b = 1 - Math.min(1, y2 * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.rgb = function(xyz) {
    const x = xyz[0] / 100;
    const y2 = xyz[1] / 100;
    const z = xyz[2] / 100;
    let r;
    let g;
    let b;
    r = x * 3.2406 + y2 * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y2 * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y2 * -0.204 + z * 1.057;
    r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
    g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
    b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.lab = function(xyz) {
    let x = xyz[0];
    let y2 = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y2 /= 100;
    z /= 108.883;
    x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y2 = y2 > 8856e-6 ? y2 ** (1 / 3) : 7.787 * y2 + 16 / 116;
    z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y2 - 16;
    const a = 500 * (x - y2);
    const b = 200 * (y2 - z);
    return [l, a, b];
  };
  convert.lab.xyz = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let x;
    let y2;
    let z;
    y2 = (l + 16) / 116;
    x = a / 500 + y2;
    z = y2 - b / 200;
    const y22 = y2 ** 3;
    const x2 = x ** 3;
    const z2 = z ** 3;
    y2 = y22 > 8856e-6 ? y22 : (y2 - 16 / 116) / 7.787;
    x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y2 *= 100;
    z *= 108.883;
    return [x, y2, z];
  };
  convert.lab.lch = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let h2;
    const hr = Math.atan2(b, a);
    h2 = hr * 360 / 2 / Math.PI;
    if (h2 < 0) {
      h2 += 360;
    }
    const c = Math.sqrt(a * a + b * b);
    return [l, c, h2];
  };
  convert.lch.lab = function(lch) {
    const l = lch[0];
    const c = lch[1];
    const h2 = lch[2];
    const hr = h2 / 360 * 2 * Math.PI;
    const a = c * Math.cos(hr);
    const b = c * Math.sin(hr);
    return [l, a, b];
  };
  convert.rgb.ansi16 = function(args2, saturation = null) {
    const [r, g, b] = args2;
    let value = saturation === null ? convert.rgb.hsv(args2)[2] : saturation;
    value = Math.round(value / 50);
    if (value === 0) {
      return 30;
    }
    let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value === 2) {
      ansi += 60;
    }
    return ansi;
  };
  convert.hsv.ansi16 = function(args2) {
    return convert.rgb.ansi16(convert.hsv.rgb(args2), args2[2]);
  };
  convert.rgb.ansi256 = function(args2) {
    const r = args2[0];
    const g = args2[1];
    const b = args2[2];
    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }
      if (r > 248) {
        return 231;
      }
      return Math.round((r - 8) / 247 * 24) + 232;
    }
    const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };
  convert.ansi16.rgb = function(args2) {
    let color = args2 % 10;
    if (color === 0 || color === 7) {
      if (args2 > 50) {
        color += 3.5;
      }
      color = color / 10.5 * 255;
      return [color, color, color];
    }
    const mult = (~~(args2 > 50) + 1) * 0.5;
    const r = (color & 1) * mult * 255;
    const g = (color >> 1 & 1) * mult * 255;
    const b = (color >> 2 & 1) * mult * 255;
    return [r, g, b];
  };
  convert.ansi256.rgb = function(args2) {
    if (args2 >= 232) {
      const c = (args2 - 232) * 10 + 8;
      return [c, c, c];
    }
    args2 -= 16;
    let rem;
    const r = Math.floor(args2 / 36) / 5 * 255;
    const g = Math.floor((rem = args2 % 36) / 6) / 5 * 255;
    const b = rem % 6 / 5 * 255;
    return [r, g, b];
  };
  convert.rgb.hex = function(args2) {
    const integer = ((Math.round(args2[0]) & 255) << 16) + ((Math.round(args2[1]) & 255) << 8) + (Math.round(args2[2]) & 255);
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.hex.rgb = function(args2) {
    const match = args2.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match) {
      return [0, 0, 0];
    }
    let colorString = match[0];
    if (match[0].length === 3) {
      colorString = colorString.split("").map((char) => {
        return char + char;
      }).join("");
    }
    const integer = parseInt(colorString, 16);
    const r = integer >> 16 & 255;
    const g = integer >> 8 & 255;
    const b = integer & 255;
    return [r, g, b];
  };
  convert.rgb.hcg = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const max = Math.max(Math.max(r, g), b);
    const min = Math.min(Math.min(r, g), b);
    const chroma = max - min;
    let grayscale;
    let hue;
    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max === r) {
      hue = (g - b) / chroma % 6;
    } else if (max === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert.hsl.hcg = function(hsl) {
    const s2 = hsl[1] / 100;
    const l = hsl[2] / 100;
    const c = l < 0.5 ? 2 * s2 * l : 2 * s2 * (1 - l);
    let f = 0;
    if (c < 1) {
      f = (l - 0.5 * c) / (1 - c);
    }
    return [hsl[0], c * 100, f * 100];
  };
  convert.hsv.hcg = function(hsv) {
    const s2 = hsv[1] / 100;
    const v = hsv[2] / 100;
    const c = s2 * v;
    let f = 0;
    if (c < 1) {
      f = (v - c) / (1 - c);
    }
    return [hsv[0], c * 100, f * 100];
  };
  convert.hcg.rgb = function(hcg) {
    const h2 = hcg[0] / 360;
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    if (c === 0) {
      return [g * 255, g * 255, g * 255];
    }
    const pure = [0, 0, 0];
    const hi = h2 % 1 * 6;
    const v = hi % 1;
    const w2 = 1 - v;
    let mg = 0;
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w2;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w2;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w2;
    }
    mg = (1 - c) * g;
    return [
      (c * pure[0] + mg) * 255,
      (c * pure[1] + mg) * 255,
      (c * pure[2] + mg) * 255
    ];
  };
  convert.hcg.hsv = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    let f = 0;
    if (v > 0) {
      f = c / v;
    }
    return [hcg[0], f * 100, v * 100];
  };
  convert.hcg.hsl = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const l = g * (1 - c) + 0.5 * c;
    let s2 = 0;
    if (l > 0 && l < 0.5) {
      s2 = c / (2 * l);
    } else if (l >= 0.5 && l < 1) {
      s2 = c / (2 * (1 - l));
    }
    return [hcg[0], s2 * 100, l * 100];
  };
  convert.hcg.hwb = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };
  convert.hwb.hcg = function(hwb) {
    const w2 = hwb[1] / 100;
    const b = hwb[2] / 100;
    const v = 1 - b;
    const c = v - w2;
    let g = 0;
    if (c < 1) {
      g = (v - c) / (1 - c);
    }
    return [hwb[0], c * 100, g * 100];
  };
  convert.apple.rgb = function(apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert.rgb.apple = function(rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert.gray.rgb = function(args2) {
    return [args2[0] / 100 * 255, args2[0] / 100 * 255, args2[0] / 100 * 255];
  };
  convert.gray.hsl = function(args2) {
    return [0, 0, args2[0]];
  };
  convert.gray.hsv = convert.gray.hsl;
  convert.gray.hwb = function(gray) {
    return [0, 100, gray[0]];
  };
  convert.gray.cmyk = function(gray) {
    return [0, 0, 0, gray[0]];
  };
  convert.gray.lab = function(gray) {
    return [gray[0], 0, 0];
  };
  convert.gray.hex = function(gray) {
    const val = Math.round(gray[0] / 100 * 255) & 255;
    const integer = (val << 16) + (val << 8) + val;
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.rgb.gray = function(rgb) {
    const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
});

// ../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js
var require_route = __commonJS((exports2, module2) => {
  var conversions = require_conversions();
  function buildGraph() {
    const graph = {};
    const models = Object.keys(conversions);
    for (let len = models.length, i = 0; i < len; i++) {
      graph[models[i]] = {
        distance: -1,
        parent: null
      };
    }
    return graph;
  }
  function deriveBFS(fromModel) {
    const graph = buildGraph();
    const queue = [fromModel];
    graph[fromModel].distance = 0;
    while (queue.length) {
      const current = queue.pop();
      const adjacents = Object.keys(conversions[current]);
      for (let len = adjacents.length, i = 0; i < len; i++) {
        const adjacent = adjacents[i];
        const node = graph[adjacent];
        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  }
  function link5(from, to) {
    return function(args2) {
      return to(from(args2));
    };
  }
  function wrapConversion(toModel, graph) {
    const path10 = [graph[toModel].parent, toModel];
    let fn = conversions[graph[toModel].parent][toModel];
    let cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path10.unshift(graph[cur].parent);
      fn = link5(conversions[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path10;
    return fn;
  }
  module2.exports = function(fromModel) {
    const graph = deriveBFS(fromModel);
    const conversion = {};
    const models = Object.keys(graph);
    for (let len = models.length, i = 0; i < len; i++) {
      const toModel = models[i];
      const node = graph[toModel];
      if (node.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  };
});

// ../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js
var require_color_convert = __commonJS((exports2, module2) => {
  var conversions = require_conversions();
  var route = require_route();
  var convert = {};
  var models = Object.keys(conversions);
  function wrapRaw(fn) {
    const wrappedFn = function(...args2) {
      const arg0 = args2[0];
      if (arg0 === void 0 || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args2 = arg0;
      }
      return fn(args2);
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  function wrapRounded(fn) {
    const wrappedFn = function(...args2) {
      const arg0 = args2[0];
      if (arg0 === void 0 || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args2 = arg0;
      }
      const result = fn(args2);
      if (typeof result === "object") {
        for (let len = result.length, i = 0; i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }
      return result;
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  models.forEach((fromModel) => {
    convert[fromModel] = {};
    Object.defineProperty(convert[fromModel], "channels", {value: conversions[fromModel].channels});
    Object.defineProperty(convert[fromModel], "labels", {value: conversions[fromModel].labels});
    const routes = route(fromModel);
    const routeModels = Object.keys(routes);
    routeModels.forEach((toModel) => {
      const fn = routes[toModel];
      convert[fromModel][toModel] = wrapRounded(fn);
      convert[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  module2.exports = convert;
});

// ../../node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS((exports2, module2) => {
  "use strict";
  var wrapAnsi16 = (fn, offset) => (...args2) => {
    const code = fn(...args2);
    return `[${code + offset}m`;
  };
  var wrapAnsi256 = (fn, offset) => (...args2) => {
    const code = fn(...args2);
    return `[${38 + offset};5;${code}m`;
  };
  var wrapAnsi16m = (fn, offset) => (...args2) => {
    const rgb = fn(...args2);
    return `[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
  };
  var ansi2ansi = (n) => n;
  var rgb2rgb = (r, g, b) => [r, g, b];
  var setLazyProperty = (object, property, get) => {
    Object.defineProperty(object, property, {
      get: () => {
        const value = get();
        Object.defineProperty(object, property, {
          value,
          enumerable: true,
          configurable: true
        });
        return value;
      },
      enumerable: true,
      configurable: true
    });
  };
  var colorConvert;
  var makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
    if (colorConvert === void 0) {
      colorConvert = require_color_convert();
    }
    const offset = isBackground ? 10 : 0;
    const styles = {};
    for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
      const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
      if (sourceSpace === targetSpace) {
        styles[name] = wrap(identity, offset);
      } else if (typeof suite === "object") {
        styles[name] = wrap(suite[targetSpace], offset);
      }
    }
    return styles;
  };
  function assembleStyles() {
    const codes = new Map();
    const styles = {
      modifier: {
        reset: [0, 0],
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        blackBright: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    styles.color.gray = styles.color.blackBright;
    styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
    styles.color.grey = styles.color.blackBright;
    styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
    for (const [groupName, group] of Object.entries(styles)) {
      for (const [styleName, style] of Object.entries(group)) {
        styles[styleName] = {
          open: `[${style[0]}m`,
          close: `[${style[1]}m`
        };
        group[styleName] = styles[styleName];
        codes.set(style[0], style[1]);
      }
      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false
      });
    }
    Object.defineProperty(styles, "codes", {
      value: codes,
      enumerable: false
    });
    styles.color.close = "[39m";
    styles.bgColor.close = "[49m";
    setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
    setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
    setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
    setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
    setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
    setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
    return styles;
  }
  Object.defineProperty(module2, "exports", {
    enumerable: true,
    get: assembleStyles
  });
});

// ../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
});

// ../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports2, module2) => {
  "use strict";
  var os3 = require("os");
  var tty = require("tty");
  var hasFlag = require_has_flag();
  var {env: env2} = process;
  var forceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
    forceColor = 0;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env2) {
    if (env2.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env2.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env2.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env2.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === void 0) {
      return 0;
    }
    const min = forceColor || 0;
    if (env2.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os3.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env2) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env2) || env2.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env2) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env2.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env2) {
      const version = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env2.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env2.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env2) {
      return 1;
    }
    return min;
  }
  function getSupportLevel(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
  }
  module2.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };
});

// ../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/util.js
var require_util = __commonJS((exports2, module2) => {
  "use strict";
  var stringReplaceAll = (string, substring, replacer) => {
    let index = string.indexOf(substring);
    if (index === -1) {
      return string;
    }
    const substringLength = substring.length;
    let endIndex = 0;
    let returnValue = "";
    do {
      returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
      endIndex = index + substringLength;
      index = string.indexOf(substring, endIndex);
    } while (index !== -1);
    returnValue += string.substr(endIndex);
    return returnValue;
  };
  var stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
    let endIndex = 0;
    let returnValue = "";
    do {
      const gotCR = string[index - 1] === "\r";
      returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
      endIndex = index + 1;
      index = string.indexOf("\n", endIndex);
    } while (index !== -1);
    returnValue += string.substr(endIndex);
    return returnValue;
  };
  module2.exports = {
    stringReplaceAll,
    stringEncaseCRLFWithFirstIndex
  };
});

// ../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/templates.js
var require_templates = __commonJS((exports2, module2) => {
  "use strict";
  var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
  var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
  var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
  var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
  var ESCAPES = new Map([
    ["n", "\n"],
    ["r", "\r"],
    ["t", "	"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", ""],
    ["a", "\x07"]
  ]);
  function unescape2(c) {
    const u = c[0] === "u";
    const bracket = c[1] === "{";
    if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
      return String.fromCharCode(parseInt(c.slice(1), 16));
    }
    if (u && bracket) {
      return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
    }
    return ESCAPES.get(c) || c;
  }
  function parseArguments(name, arguments_) {
    const results = [];
    const chunks = arguments_.trim().split(/\s*,\s*/g);
    let matches;
    for (const chunk of chunks) {
      const number = Number(chunk);
      if (!Number.isNaN(number)) {
        results.push(number);
      } else if (matches = chunk.match(STRING_REGEX)) {
        results.push(matches[2].replace(ESCAPE_REGEX, (m2, escape2, character) => escape2 ? unescape2(escape2) : character));
      } else {
        throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
      }
    }
    return results;
  }
  function parseStyle(style) {
    STYLE_REGEX.lastIndex = 0;
    const results = [];
    let matches;
    while ((matches = STYLE_REGEX.exec(style)) !== null) {
      const name = matches[1];
      if (matches[2]) {
        const args2 = parseArguments(name, matches[2]);
        results.push([name].concat(args2));
      } else {
        results.push([name]);
      }
    }
    return results;
  }
  function buildStyle(chalk14, styles) {
    const enabled = {};
    for (const layer of styles) {
      for (const style of layer.styles) {
        enabled[style[0]] = layer.inverse ? null : style.slice(1);
      }
    }
    let current = chalk14;
    for (const [styleName, styles2] of Object.entries(enabled)) {
      if (!Array.isArray(styles2)) {
        continue;
      }
      if (!(styleName in current)) {
        throw new Error(`Unknown Chalk style: ${styleName}`);
      }
      current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
    }
    return current;
  }
  module2.exports = (chalk14, temporary) => {
    const styles = [];
    const chunks = [];
    let chunk = [];
    temporary.replace(TEMPLATE_REGEX, (m2, escapeCharacter, inverse, style, close2, character) => {
      if (escapeCharacter) {
        chunk.push(unescape2(escapeCharacter));
      } else if (style) {
        const string = chunk.join("");
        chunk = [];
        chunks.push(styles.length === 0 ? string : buildStyle(chalk14, styles)(string));
        styles.push({inverse, styles: parseStyle(style)});
      } else if (close2) {
        if (styles.length === 0) {
          throw new Error("Found extraneous } in Chalk template literal");
        }
        chunks.push(buildStyle(chalk14, styles)(chunk.join("")));
        chunk = [];
        styles.pop();
      } else {
        chunk.push(character);
      }
    });
    chunks.push(chunk.join(""));
    if (styles.length > 0) {
      const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(errMessage);
    }
    return chunks.join("");
  };
});

// ../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/index.js
var require_source = __commonJS((exports2, module2) => {
  "use strict";
  var ansiStyles = require_ansi_styles();
  var {stdout: stdoutColor, stderr: stderrColor} = require_supports_color();
  var {
    stringReplaceAll,
    stringEncaseCRLFWithFirstIndex
  } = require_util();
  var {isArray} = Array;
  var levelMapping = [
    "ansi",
    "ansi",
    "ansi256",
    "ansi16m"
  ];
  var styles = Object.create(null);
  var applyOptions = (object, options = {}) => {
    if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
      throw new Error("The `level` option should be an integer from 0 to 3");
    }
    const colorLevel = stdoutColor ? stdoutColor.level : 0;
    object.level = options.level === void 0 ? colorLevel : options.level;
  };
  var ChalkClass = class {
    constructor(options) {
      return chalkFactory(options);
    }
  };
  var chalkFactory = (options) => {
    const chalk15 = {};
    applyOptions(chalk15, options);
    chalk15.template = (...arguments_) => chalkTag(chalk15.template, ...arguments_);
    Object.setPrototypeOf(chalk15, Chalk.prototype);
    Object.setPrototypeOf(chalk15.template, chalk15);
    chalk15.template.constructor = () => {
      throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
    };
    chalk15.template.Instance = ChalkClass;
    return chalk15.template;
  };
  function Chalk(options) {
    return chalkFactory(options);
  }
  for (const [styleName, style] of Object.entries(ansiStyles)) {
    styles[styleName] = {
      get() {
        const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
        Object.defineProperty(this, styleName, {value: builder});
        return builder;
      }
    };
  }
  styles.visible = {
    get() {
      const builder = createBuilder(this, this._styler, true);
      Object.defineProperty(this, "visible", {value: builder});
      return builder;
    }
  };
  var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
  for (const model of usedModels) {
    styles[model] = {
      get() {
        const {level} = this;
        return function(...arguments_) {
          const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
          return createBuilder(this, styler, this._isEmpty);
        };
      }
    };
  }
  for (const model of usedModels) {
    const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
    styles[bgModel] = {
      get() {
        const {level} = this;
        return function(...arguments_) {
          const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
          return createBuilder(this, styler, this._isEmpty);
        };
      }
    };
  }
  var proto = Object.defineProperties(() => {
  }, {
    ...styles,
    level: {
      enumerable: true,
      get() {
        return this._generator.level;
      },
      set(level) {
        this._generator.level = level;
      }
    }
  });
  var createStyler = (open3, close2, parent) => {
    let openAll;
    let closeAll;
    if (parent === void 0) {
      openAll = open3;
      closeAll = close2;
    } else {
      openAll = parent.openAll + open3;
      closeAll = close2 + parent.closeAll;
    }
    return {
      open: open3,
      close: close2,
      openAll,
      closeAll,
      parent
    };
  };
  var createBuilder = (self2, _styler, _isEmpty) => {
    const builder = (...arguments_) => {
      if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
        return applyStyle(builder, chalkTag(builder, ...arguments_));
      }
      return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
    };
    Object.setPrototypeOf(builder, proto);
    builder._generator = self2;
    builder._styler = _styler;
    builder._isEmpty = _isEmpty;
    return builder;
  };
  var applyStyle = (self2, string) => {
    if (self2.level <= 0 || !string) {
      return self2._isEmpty ? "" : string;
    }
    let styler = self2._styler;
    if (styler === void 0) {
      return string;
    }
    const {openAll, closeAll} = styler;
    if (string.indexOf("") !== -1) {
      while (styler !== void 0) {
        string = stringReplaceAll(string, styler.close, styler.open);
        styler = styler.parent;
      }
    }
    const lfIndex = string.indexOf("\n");
    if (lfIndex !== -1) {
      string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
    }
    return openAll + string + closeAll;
  };
  var template;
  var chalkTag = (chalk15, ...strings) => {
    const [firstString] = strings;
    if (!isArray(firstString) || !isArray(firstString.raw)) {
      return strings.join(" ");
    }
    const arguments_ = strings.slice(1);
    const parts = [firstString.raw[0]];
    for (let i = 1; i < firstString.length; i++) {
      parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i]));
    }
    if (template === void 0) {
      template = require_templates();
    }
    return template(chalk15, parts.join(""));
  };
  Object.defineProperties(Chalk.prototype, styles);
  var chalk14 = Chalk();
  chalk14.supportsColor = stdoutColor;
  chalk14.stderr = Chalk({level: stderrColor ? stderrColor.level : 0});
  chalk14.stderr.supportsColor = stderrColor;
  module2.exports = chalk14;
});

// ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js
var require_windows = __commonJS((exports2, module2) => {
  module2.exports = isexe;
  isexe.sync = sync2;
  var fs9 = require("fs");
  function checkPathExt(path10, options) {
    var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
    if (!pathext) {
      return true;
    }
    pathext = pathext.split(";");
    if (pathext.indexOf("") !== -1) {
      return true;
    }
    for (var i = 0; i < pathext.length; i++) {
      var p = pathext[i].toLowerCase();
      if (p && path10.substr(-p.length).toLowerCase() === p) {
        return true;
      }
    }
    return false;
  }
  function checkStat(stat, path10, options) {
    if (!stat.isSymbolicLink() && !stat.isFile()) {
      return false;
    }
    return checkPathExt(path10, options);
  }
  function isexe(path10, options, cb) {
    fs9.stat(path10, function(er, stat) {
      cb(er, er ? false : checkStat(stat, path10, options));
    });
  }
  function sync2(path10, options) {
    return checkStat(fs9.statSync(path10), path10, options);
  }
});

// ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js
var require_mode = __commonJS((exports2, module2) => {
  module2.exports = isexe;
  isexe.sync = sync2;
  var fs9 = require("fs");
  function isexe(path10, options, cb) {
    fs9.stat(path10, function(er, stat) {
      cb(er, er ? false : checkStat(stat, options));
    });
  }
  function sync2(path10, options) {
    return checkStat(fs9.statSync(path10), options);
  }
  function checkStat(stat, options) {
    return stat.isFile() && checkMode(stat, options);
  }
  function checkMode(stat, options) {
    var mod = stat.mode;
    var uid = stat.uid;
    var gid = stat.gid;
    var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
    var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
    var u = parseInt("100", 8);
    var g = parseInt("010", 8);
    var o = parseInt("001", 8);
    var ug = u | g;
    var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
    return ret;
  }
});

// ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js
var require_isexe = __commonJS((exports2, module2) => {
  var fs9 = require("fs");
  var core;
  if (process.platform === "win32" || global.TESTING_WINDOWS) {
    core = require_windows();
  } else {
    core = require_mode();
  }
  module2.exports = isexe;
  isexe.sync = sync2;
  function isexe(path10, options, cb) {
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    if (!cb) {
      if (typeof Promise !== "function") {
        throw new TypeError("callback not provided");
      }
      return new Promise(function(resolve, reject) {
        isexe(path10, options || {}, function(er, is) {
          if (er) {
            reject(er);
          } else {
            resolve(is);
          }
        });
      });
    }
    core(path10, options || {}, function(er, is) {
      if (er) {
        if (er.code === "EACCES" || options && options.ignoreErrors) {
          er = null;
          is = false;
        }
      }
      cb(er, is);
    });
  }
  function sync2(path10, options) {
    try {
      return core.sync(path10, options || {});
    } catch (er) {
      if (options && options.ignoreErrors || er.code === "EACCES") {
        return false;
      } else {
        throw er;
      }
    }
  }
});

// ../../node_modules/.pnpm/which@2.0.2/node_modules/which/which.js
var require_which = __commonJS((exports2, module2) => {
  var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
  var path10 = require("path");
  var COLON = isWindows ? ";" : ":";
  var isexe = require_isexe();
  var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), {code: "ENOENT"});
  var getPathInfo = (cmd, opt) => {
    const colon = opt.colon || COLON;
    const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
      ...isWindows ? [process.cwd()] : [],
      ...(opt.path || process.env.PATH || "").split(colon)
    ];
    const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
    const pathExt = isWindows ? pathExtExe.split(colon) : [""];
    if (isWindows) {
      if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
        pathExt.unshift("");
    }
    return {
      pathEnv,
      pathExt,
      pathExtExe
    };
  };
  var which = (cmd, opt, cb) => {
    if (typeof opt === "function") {
      cb = opt;
      opt = {};
    }
    if (!opt)
      opt = {};
    const {pathEnv, pathExt, pathExtExe} = getPathInfo(cmd, opt);
    const found = [];
    const step = (i) => new Promise((resolve, reject) => {
      if (i === pathEnv.length)
        return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
      const ppRaw = pathEnv[i];
      const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
      const pCmd = path10.join(pathPart, cmd);
      const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      resolve(subStep(p, i, 0));
    });
    const subStep = (p, i, ii) => new Promise((resolve, reject) => {
      if (ii === pathExt.length)
        return resolve(step(i + 1));
      const ext = pathExt[ii];
      isexe(p + ext, {pathExt: pathExtExe}, (er, is) => {
        if (!er && is) {
          if (opt.all)
            found.push(p + ext);
          else
            return resolve(p + ext);
        }
        return resolve(subStep(p, i, ii + 1));
      });
    });
    return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
  };
  var whichSync = (cmd, opt) => {
    opt = opt || {};
    const {pathEnv, pathExt, pathExtExe} = getPathInfo(cmd, opt);
    const found = [];
    for (let i = 0; i < pathEnv.length; i++) {
      const ppRaw = pathEnv[i];
      const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
      const pCmd = path10.join(pathPart, cmd);
      const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      for (let j = 0; j < pathExt.length; j++) {
        const cur = p + pathExt[j];
        try {
          const is = isexe.sync(cur, {pathExt: pathExtExe});
          if (is) {
            if (opt.all)
              found.push(cur);
            else
              return cur;
          }
        } catch (ex) {
        }
      }
    }
    if (opt.all && found.length)
      return found;
    if (opt.nothrow)
      return null;
    throw getNotFoundError(cmd);
  };
  module2.exports = which;
  which.sync = whichSync;
});

// ../../node_modules/.pnpm/path-key@3.1.1/node_modules/path-key/index.js
var require_path_key = __commonJS((exports2, module2) => {
  "use strict";
  var pathKey = (options = {}) => {
    const environment = options.env || process.env;
    const platform = options.platform || process.platform;
    if (platform !== "win32") {
      return "PATH";
    }
    return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
  };
  module2.exports = pathKey;
  module2.exports.default = pathKey;
});

// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand = __commonJS((exports2, module2) => {
  "use strict";
  var path10 = require("path");
  var which = require_which();
  var getPathKey = require_path_key();
  function resolveCommandAttempt(parsed, withoutPathExt) {
    const env2 = parsed.options.env || process.env;
    const cwd = process.cwd();
    const hasCustomCwd = parsed.options.cwd != null;
    const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
    if (shouldSwitchCwd) {
      try {
        process.chdir(parsed.options.cwd);
      } catch (err) {
      }
    }
    let resolved;
    try {
      resolved = which.sync(parsed.command, {
        path: env2[getPathKey({env: env2})],
        pathExt: withoutPathExt ? path10.delimiter : void 0
      });
    } catch (e) {
    } finally {
      if (shouldSwitchCwd) {
        process.chdir(cwd);
      }
    }
    if (resolved) {
      resolved = path10.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
    }
    return resolved;
  }
  function resolveCommand(parsed) {
    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
  }
  module2.exports = resolveCommand;
});

// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/escape.js
var require_escape = __commonJS((exports2, module2) => {
  "use strict";
  var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
  function escapeCommand(arg10) {
    arg10 = arg10.replace(metaCharsRegExp, "^$1");
    return arg10;
  }
  function escapeArgument(arg10, doubleEscapeMetaChars) {
    arg10 = `${arg10}`;
    arg10 = arg10.replace(/(\\*)"/g, '$1$1\\"');
    arg10 = arg10.replace(/(\\*)$/, "$1$1");
    arg10 = `"${arg10}"`;
    arg10 = arg10.replace(metaCharsRegExp, "^$1");
    if (doubleEscapeMetaChars) {
      arg10 = arg10.replace(metaCharsRegExp, "^$1");
    }
    return arg10;
  }
  module2.exports.command = escapeCommand;
  module2.exports.argument = escapeArgument;
});

// ../../node_modules/.pnpm/shebang-regex@3.0.0/node_modules/shebang-regex/index.js
var require_shebang_regex = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = /^#!(.*)/;
});

// ../../node_modules/.pnpm/shebang-command@2.0.0/node_modules/shebang-command/index.js
var require_shebang_command = __commonJS((exports2, module2) => {
  "use strict";
  var shebangRegex = require_shebang_regex();
  module2.exports = (string = "") => {
    const match = string.match(shebangRegex);
    if (!match) {
      return null;
    }
    const [path10, argument] = match[0].replace(/#! ?/, "").split(" ");
    const binary = path10.split("/").pop();
    if (binary === "env") {
      return argument;
    }
    return argument ? `${binary} ${argument}` : binary;
  };
});

// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang = __commonJS((exports2, module2) => {
  "use strict";
  var fs9 = require("fs");
  var shebangCommand = require_shebang_command();
  function readShebang(command) {
    const size = 150;
    const buffer = Buffer.alloc(size);
    let fd;
    try {
      fd = fs9.openSync(command, "r");
      fs9.readSync(fd, buffer, 0, size, 0);
      fs9.closeSync(fd);
    } catch (e) {
    }
    return shebangCommand(buffer.toString());
  }
  module2.exports = readShebang;
});

// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/parse.js
var require_parse = __commonJS((exports2, module2) => {
  "use strict";
  var path10 = require("path");
  var resolveCommand = require_resolveCommand();
  var escape2 = require_escape();
  var readShebang = require_readShebang();
  var isWin = process.platform === "win32";
  var isExecutableRegExp = /\.(?:com|exe)$/i;
  var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
  function detectShebang(parsed) {
    parsed.file = resolveCommand(parsed);
    const shebang = parsed.file && readShebang(parsed.file);
    if (shebang) {
      parsed.args.unshift(parsed.file);
      parsed.command = shebang;
      return resolveCommand(parsed);
    }
    return parsed.file;
  }
  function parseNonShell(parsed) {
    if (!isWin) {
      return parsed;
    }
    const commandFile = detectShebang(parsed);
    const needsShell = !isExecutableRegExp.test(commandFile);
    if (parsed.options.forceShell || needsShell) {
      const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
      parsed.command = path10.normalize(parsed.command);
      parsed.command = escape2.command(parsed.command);
      parsed.args = parsed.args.map((arg10) => escape2.argument(arg10, needsDoubleEscapeMetaChars));
      const shellCommand = [parsed.command].concat(parsed.args).join(" ");
      parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
      parsed.command = process.env.comspec || "cmd.exe";
      parsed.options.windowsVerbatimArguments = true;
    }
    return parsed;
  }
  function parse2(command, args2, options) {
    if (args2 && !Array.isArray(args2)) {
      options = args2;
      args2 = null;
    }
    args2 = args2 ? args2.slice(0) : [];
    options = Object.assign({}, options);
    const parsed = {
      command,
      args: args2,
      options,
      file: void 0,
      original: {
        command,
        args: args2
      }
    };
    return options.shell ? parsed : parseNonShell(parsed);
  }
  module2.exports = parse2;
});

// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/enoent.js
var require_enoent = __commonJS((exports2, module2) => {
  "use strict";
  var isWin = process.platform === "win32";
  function notFoundError(original, syscall) {
    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
      code: "ENOENT",
      errno: "ENOENT",
      syscall: `${syscall} ${original.command}`,
      path: original.command,
      spawnargs: original.args
    });
  }
  function hookChildProcess(cp, parsed) {
    if (!isWin) {
      return;
    }
    const originalEmit = cp.emit;
    cp.emit = function(name, arg1) {
      if (name === "exit") {
        const err = verifyENOENT(arg1, parsed, "spawn");
        if (err) {
          return originalEmit.call(cp, "error", err);
        }
      }
      return originalEmit.apply(cp, arguments);
    };
  }
  function verifyENOENT(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
      return notFoundError(parsed.original, "spawn");
    }
    return null;
  }
  function verifyENOENTSync(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
      return notFoundError(parsed.original, "spawnSync");
    }
    return null;
  }
  module2.exports = {
    hookChildProcess,
    verifyENOENT,
    verifyENOENTSync,
    notFoundError
  };
});

// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/index.js
var require_cross_spawn = __commonJS((exports2, module2) => {
  "use strict";
  var cp = require("child_process");
  var parse2 = require_parse();
  var enoent = require_enoent();
  function spawn2(command, args2, options) {
    const parsed = parse2(command, args2, options);
    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
    enoent.hookChildProcess(spawned, parsed);
    return spawned;
  }
  function spawnSync(command, args2, options) {
    const parsed = parse2(command, args2, options);
    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
    return result;
  }
  module2.exports = spawn2;
  module2.exports.spawn = spawn2;
  module2.exports.sync = spawnSync;
  module2.exports._parse = parse2;
  module2.exports._enoent = enoent;
});

// ../../node_modules/.pnpm/strip-final-newline@2.0.0/node_modules/strip-final-newline/index.js
var require_strip_final_newline = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (input) => {
    const LF = typeof input === "string" ? "\n" : "\n".charCodeAt();
    const CR = typeof input === "string" ? "\r" : "\r".charCodeAt();
    if (input[input.length - 1] === LF) {
      input = input.slice(0, input.length - 1);
    }
    if (input[input.length - 1] === CR) {
      input = input.slice(0, input.length - 1);
    }
    return input;
  };
});

// ../../node_modules/.pnpm/npm-run-path@4.0.1/node_modules/npm-run-path/index.js
var require_npm_run_path = __commonJS((exports2, module2) => {
  "use strict";
  var path10 = require("path");
  var pathKey = require_path_key();
  var npmRunPath = (options) => {
    options = {
      cwd: process.cwd(),
      path: process.env[pathKey()],
      execPath: process.execPath,
      ...options
    };
    let previous;
    let cwdPath = path10.resolve(options.cwd);
    const result = [];
    while (previous !== cwdPath) {
      result.push(path10.join(cwdPath, "node_modules/.bin"));
      previous = cwdPath;
      cwdPath = path10.resolve(cwdPath, "..");
    }
    const execPathDir = path10.resolve(options.cwd, options.execPath, "..");
    result.push(execPathDir);
    return result.concat(options.path).join(path10.delimiter);
  };
  module2.exports = npmRunPath;
  module2.exports.default = npmRunPath;
  module2.exports.env = (options) => {
    options = {
      env: process.env,
      ...options
    };
    const env2 = {...options.env};
    const path11 = pathKey({env: env2});
    options.path = env2[path11];
    env2[path11] = module2.exports(options);
    return env2;
  };
});

// ../../node_modules/.pnpm/mimic-fn@2.1.0/node_modules/mimic-fn/index.js
var require_mimic_fn = __commonJS((exports2, module2) => {
  "use strict";
  var mimicFn = (to, from) => {
    for (const prop of Reflect.ownKeys(from)) {
      Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
    }
    return to;
  };
  module2.exports = mimicFn;
  module2.exports.default = mimicFn;
});

// ../../node_modules/.pnpm/onetime@5.1.2/node_modules/onetime/index.js
var require_onetime = __commonJS((exports2, module2) => {
  "use strict";
  var mimicFn = require_mimic_fn();
  var calledFunctions = new WeakMap();
  var onetime = (function_, options = {}) => {
    if (typeof function_ !== "function") {
      throw new TypeError("Expected a function");
    }
    let returnValue;
    let callCount = 0;
    const functionName = function_.displayName || function_.name || "<anonymous>";
    const onetime2 = function(...arguments_) {
      calledFunctions.set(onetime2, ++callCount);
      if (callCount === 1) {
        returnValue = function_.apply(this, arguments_);
        function_ = null;
      } else if (options.throw === true) {
        throw new Error(`Function \`${functionName}\` can only be called once`);
      }
      return returnValue;
    };
    mimicFn(onetime2, function_);
    calledFunctions.set(onetime2, callCount);
    return onetime2;
  };
  module2.exports = onetime;
  module2.exports.default = onetime;
  module2.exports.callCount = (function_) => {
    if (!calledFunctions.has(function_)) {
      throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
    }
    return calledFunctions.get(function_);
  };
});

// ../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/core.js
var require_core = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.SIGNALS = void 0;
  var SIGNALS = [
    {
      name: "SIGHUP",
      number: 1,
      action: "terminate",
      description: "Terminal closed",
      standard: "posix"
    },
    {
      name: "SIGINT",
      number: 2,
      action: "terminate",
      description: "User interruption with CTRL-C",
      standard: "ansi"
    },
    {
      name: "SIGQUIT",
      number: 3,
      action: "core",
      description: "User interruption with CTRL-\\",
      standard: "posix"
    },
    {
      name: "SIGILL",
      number: 4,
      action: "core",
      description: "Invalid machine instruction",
      standard: "ansi"
    },
    {
      name: "SIGTRAP",
      number: 5,
      action: "core",
      description: "Debugger breakpoint",
      standard: "posix"
    },
    {
      name: "SIGABRT",
      number: 6,
      action: "core",
      description: "Aborted",
      standard: "ansi"
    },
    {
      name: "SIGIOT",
      number: 6,
      action: "core",
      description: "Aborted",
      standard: "bsd"
    },
    {
      name: "SIGBUS",
      number: 7,
      action: "core",
      description: "Bus error due to misaligned, non-existing address or paging error",
      standard: "bsd"
    },
    {
      name: "SIGEMT",
      number: 7,
      action: "terminate",
      description: "Command should be emulated but is not implemented",
      standard: "other"
    },
    {
      name: "SIGFPE",
      number: 8,
      action: "core",
      description: "Floating point arithmetic error",
      standard: "ansi"
    },
    {
      name: "SIGKILL",
      number: 9,
      action: "terminate",
      description: "Forced termination",
      standard: "posix",
      forced: true
    },
    {
      name: "SIGUSR1",
      number: 10,
      action: "terminate",
      description: "Application-specific signal",
      standard: "posix"
    },
    {
      name: "SIGSEGV",
      number: 11,
      action: "core",
      description: "Segmentation fault",
      standard: "ansi"
    },
    {
      name: "SIGUSR2",
      number: 12,
      action: "terminate",
      description: "Application-specific signal",
      standard: "posix"
    },
    {
      name: "SIGPIPE",
      number: 13,
      action: "terminate",
      description: "Broken pipe or socket",
      standard: "posix"
    },
    {
      name: "SIGALRM",
      number: 14,
      action: "terminate",
      description: "Timeout or timer",
      standard: "posix"
    },
    {
      name: "SIGTERM",
      number: 15,
      action: "terminate",
      description: "Termination",
      standard: "ansi"
    },
    {
      name: "SIGSTKFLT",
      number: 16,
      action: "terminate",
      description: "Stack is empty or overflowed",
      standard: "other"
    },
    {
      name: "SIGCHLD",
      number: 17,
      action: "ignore",
      description: "Child process terminated, paused or unpaused",
      standard: "posix"
    },
    {
      name: "SIGCLD",
      number: 17,
      action: "ignore",
      description: "Child process terminated, paused or unpaused",
      standard: "other"
    },
    {
      name: "SIGCONT",
      number: 18,
      action: "unpause",
      description: "Unpaused",
      standard: "posix",
      forced: true
    },
    {
      name: "SIGSTOP",
      number: 19,
      action: "pause",
      description: "Paused",
      standard: "posix",
      forced: true
    },
    {
      name: "SIGTSTP",
      number: 20,
      action: "pause",
      description: 'Paused using CTRL-Z or "suspend"',
      standard: "posix"
    },
    {
      name: "SIGTTIN",
      number: 21,
      action: "pause",
      description: "Background process cannot read terminal input",
      standard: "posix"
    },
    {
      name: "SIGBREAK",
      number: 21,
      action: "terminate",
      description: "User interruption with CTRL-BREAK",
      standard: "other"
    },
    {
      name: "SIGTTOU",
      number: 22,
      action: "pause",
      description: "Background process cannot write to terminal output",
      standard: "posix"
    },
    {
      name: "SIGURG",
      number: 23,
      action: "ignore",
      description: "Socket received out-of-band data",
      standard: "bsd"
    },
    {
      name: "SIGXCPU",
      number: 24,
      action: "core",
      description: "Process timed out",
      standard: "bsd"
    },
    {
      name: "SIGXFSZ",
      number: 25,
      action: "core",
      description: "File too big",
      standard: "bsd"
    },
    {
      name: "SIGVTALRM",
      number: 26,
      action: "terminate",
      description: "Timeout or timer",
      standard: "bsd"
    },
    {
      name: "SIGPROF",
      number: 27,
      action: "terminate",
      description: "Timeout or timer",
      standard: "bsd"
    },
    {
      name: "SIGWINCH",
      number: 28,
      action: "ignore",
      description: "Terminal window size changed",
      standard: "bsd"
    },
    {
      name: "SIGIO",
      number: 29,
      action: "terminate",
      description: "I/O is available",
      standard: "other"
    },
    {
      name: "SIGPOLL",
      number: 29,
      action: "terminate",
      description: "Watched event",
      standard: "other"
    },
    {
      name: "SIGINFO",
      number: 29,
      action: "ignore",
      description: "Request for process information",
      standard: "other"
    },
    {
      name: "SIGPWR",
      number: 30,
      action: "terminate",
      description: "Device running out of power",
      standard: "systemv"
    },
    {
      name: "SIGSYS",
      number: 31,
      action: "core",
      description: "Invalid system call",
      standard: "other"
    },
    {
      name: "SIGUNUSED",
      number: 31,
      action: "terminate",
      description: "Invalid system call",
      standard: "other"
    }
  ];
  exports2.SIGNALS = SIGNALS;
});

// ../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/realtime.js
var require_realtime = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.SIGRTMAX = exports2.getRealtimeSignals = void 0;
  var getRealtimeSignals = function() {
    const length = SIGRTMAX - SIGRTMIN + 1;
    return Array.from({length}, getRealtimeSignal);
  };
  exports2.getRealtimeSignals = getRealtimeSignals;
  var getRealtimeSignal = function(value, index) {
    return {
      name: `SIGRT${index + 1}`,
      number: SIGRTMIN + index,
      action: "terminate",
      description: "Application-specific signal (realtime)",
      standard: "posix"
    };
  };
  var SIGRTMIN = 34;
  var SIGRTMAX = 64;
  exports2.SIGRTMAX = SIGRTMAX;
});

// ../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/signals.js
var require_signals = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getSignals = void 0;
  var _os = require("os");
  var _core = require_core();
  var _realtime = require_realtime();
  var getSignals = function() {
    const realtimeSignals = (0, _realtime.getRealtimeSignals)();
    const signals = [..._core.SIGNALS, ...realtimeSignals].map(normalizeSignal);
    return signals;
  };
  exports2.getSignals = getSignals;
  var normalizeSignal = function({
    name,
    number: defaultNumber,
    description,
    action,
    forced = false,
    standard
  }) {
    const {
      signals: {[name]: constantSignal}
    } = _os.constants;
    const supported = constantSignal !== void 0;
    const number = supported ? constantSignal : defaultNumber;
    return {name, number, description, supported, action, forced, standard};
  };
});

// ../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/main.js
var require_main = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.signalsByNumber = exports2.signalsByName = void 0;
  var _os = require("os");
  var _signals = require_signals();
  var _realtime = require_realtime();
  var getSignalsByName = function() {
    const signals = (0, _signals.getSignals)();
    return signals.reduce(getSignalByName, {});
  };
  var getSignalByName = function(signalByNameMemo, {name, number, description, supported, action, forced, standard}) {
    return {
      ...signalByNameMemo,
      [name]: {name, number, description, supported, action, forced, standard}
    };
  };
  var signalsByName = getSignalsByName();
  exports2.signalsByName = signalsByName;
  var getSignalsByNumber = function() {
    const signals = (0, _signals.getSignals)();
    const length = _realtime.SIGRTMAX + 1;
    const signalsA = Array.from({length}, (value, number) => getSignalByNumber(number, signals));
    return Object.assign({}, ...signalsA);
  };
  var getSignalByNumber = function(number, signals) {
    const signal = findSignalByNumber(number, signals);
    if (signal === void 0) {
      return {};
    }
    const {name, description, supported, action, forced, standard} = signal;
    return {
      [number]: {
        name,
        number,
        description,
        supported,
        action,
        forced,
        standard
      }
    };
  };
  var findSignalByNumber = function(number, signals) {
    const signal = signals.find(({name}) => _os.constants.signals[name] === number);
    if (signal !== void 0) {
      return signal;
    }
    return signals.find((signalA) => signalA.number === number);
  };
  var signalsByNumber = getSignalsByNumber();
  exports2.signalsByNumber = signalsByNumber;
});

// ../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/error.js
var require_error = __commonJS((exports2, module2) => {
  "use strict";
  var {signalsByName} = require_main();
  var getErrorPrefix = ({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled}) => {
    if (timedOut) {
      return `timed out after ${timeout} milliseconds`;
    }
    if (isCanceled) {
      return "was canceled";
    }
    if (errorCode !== void 0) {
      return `failed with ${errorCode}`;
    }
    if (signal !== void 0) {
      return `was killed with ${signal} (${signalDescription})`;
    }
    if (exitCode !== void 0) {
      return `failed with exit code ${exitCode}`;
    }
    return "failed";
  };
  var makeError = ({
    stdout,
    stderr,
    all,
    error,
    signal,
    exitCode,
    command,
    escapedCommand,
    timedOut,
    isCanceled,
    killed,
    parsed: {options: {timeout}}
  }) => {
    exitCode = exitCode === null ? void 0 : exitCode;
    signal = signal === null ? void 0 : signal;
    const signalDescription = signal === void 0 ? void 0 : signalsByName[signal].description;
    const errorCode = error && error.code;
    const prefix = getErrorPrefix({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled});
    const execaMessage = `Command ${prefix}: ${command}`;
    const isError7 = Object.prototype.toString.call(error) === "[object Error]";
    const shortMessage = isError7 ? `${execaMessage}
${error.message}` : execaMessage;
    const message = [shortMessage, stderr, stdout].filter(Boolean).join("\n");
    if (isError7) {
      error.originalMessage = error.message;
      error.message = message;
    } else {
      error = new Error(message);
    }
    error.shortMessage = shortMessage;
    error.command = command;
    error.escapedCommand = escapedCommand;
    error.exitCode = exitCode;
    error.signal = signal;
    error.signalDescription = signalDescription;
    error.stdout = stdout;
    error.stderr = stderr;
    if (all !== void 0) {
      error.all = all;
    }
    if ("bufferedData" in error) {
      delete error.bufferedData;
    }
    error.failed = true;
    error.timedOut = Boolean(timedOut);
    error.isCanceled = isCanceled;
    error.killed = killed && !timedOut;
    return error;
  };
  module2.exports = makeError;
});

// ../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/stdio.js
var require_stdio = __commonJS((exports2, module2) => {
  "use strict";
  var aliases = ["stdin", "stdout", "stderr"];
  var hasAlias = (options) => aliases.some((alias) => options[alias] !== void 0);
  var normalizeStdio = (options) => {
    if (!options) {
      return;
    }
    const {stdio} = options;
    if (stdio === void 0) {
      return aliases.map((alias) => options[alias]);
    }
    if (hasAlias(options)) {
      throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${aliases.map((alias) => `\`${alias}\``).join(", ")}`);
    }
    if (typeof stdio === "string") {
      return stdio;
    }
    if (!Array.isArray(stdio)) {
      throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
    }
    const length = Math.max(stdio.length, aliases.length);
    return Array.from({length}, (value, index) => stdio[index]);
  };
  module2.exports = normalizeStdio;
  module2.exports.node = (options) => {
    const stdio = normalizeStdio(options);
    if (stdio === "ipc") {
      return "ipc";
    }
    if (stdio === void 0 || typeof stdio === "string") {
      return [stdio, stdio, stdio, "ipc"];
    }
    if (stdio.includes("ipc")) {
      return stdio;
    }
    return [...stdio, "ipc"];
  };
});

// ../../node_modules/.pnpm/signal-exit@3.0.3/node_modules/signal-exit/signals.js
var require_signals2 = __commonJS((exports2, module2) => {
  module2.exports = [
    "SIGABRT",
    "SIGALRM",
    "SIGHUP",
    "SIGINT",
    "SIGTERM"
  ];
  if (process.platform !== "win32") {
    module2.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
  }
  if (process.platform === "linux") {
    module2.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");
  }
});

// ../../node_modules/.pnpm/signal-exit@3.0.3/node_modules/signal-exit/index.js
var require_signal_exit = __commonJS((exports2, module2) => {
  var assert = require("assert");
  var signals = require_signals2();
  var isWin = /^win/i.test(process.platform);
  var EE = require("events");
  if (typeof EE !== "function") {
    EE = EE.EventEmitter;
  }
  var emitter;
  if (process.__signal_exit_emitter__) {
    emitter = process.__signal_exit_emitter__;
  } else {
    emitter = process.__signal_exit_emitter__ = new EE();
    emitter.count = 0;
    emitter.emitted = {};
  }
  if (!emitter.infinite) {
    emitter.setMaxListeners(Infinity);
    emitter.infinite = true;
  }
  module2.exports = function(cb, opts) {
    assert.equal(typeof cb, "function", "a callback must be provided for exit handler");
    if (loaded === false) {
      load2();
    }
    var ev = "exit";
    if (opts && opts.alwaysLast) {
      ev = "afterexit";
    }
    var remove = function() {
      emitter.removeListener(ev, cb);
      if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
        unload();
      }
    };
    emitter.on(ev, cb);
    return remove;
  };
  module2.exports.unload = unload;
  function unload() {
    if (!loaded) {
      return;
    }
    loaded = false;
    signals.forEach(function(sig) {
      try {
        process.removeListener(sig, sigListeners[sig]);
      } catch (er) {
      }
    });
    process.emit = originalProcessEmit;
    process.reallyExit = originalProcessReallyExit;
    emitter.count -= 1;
  }
  function emit(event, code, signal) {
    if (emitter.emitted[event]) {
      return;
    }
    emitter.emitted[event] = true;
    emitter.emit(event, code, signal);
  }
  var sigListeners = {};
  signals.forEach(function(sig) {
    sigListeners[sig] = function listener() {
      var listeners = process.listeners(sig);
      if (listeners.length === emitter.count) {
        unload();
        emit("exit", null, sig);
        emit("afterexit", null, sig);
        if (isWin && sig === "SIGHUP") {
          sig = "SIGINT";
        }
        process.kill(process.pid, sig);
      }
    };
  });
  module2.exports.signals = function() {
    return signals;
  };
  module2.exports.load = load2;
  var loaded = false;
  function load2() {
    if (loaded) {
      return;
    }
    loaded = true;
    emitter.count += 1;
    signals = signals.filter(function(sig) {
      try {
        process.on(sig, sigListeners[sig]);
        return true;
      } catch (er) {
        return false;
      }
    });
    process.emit = processEmit;
    process.reallyExit = processReallyExit;
  }
  var originalProcessReallyExit = process.reallyExit;
  function processReallyExit(code) {
    process.exitCode = code || 0;
    emit("exit", process.exitCode, null);
    emit("afterexit", process.exitCode, null);
    originalProcessReallyExit.call(process, process.exitCode);
  }
  var originalProcessEmit = process.emit;
  function processEmit(ev, arg10) {
    if (ev === "exit") {
      if (arg10 !== void 0) {
        process.exitCode = arg10;
      }
      var ret = originalProcessEmit.apply(this, arguments);
      emit("exit", process.exitCode, null);
      emit("afterexit", process.exitCode, null);
      return ret;
    } else {
      return originalProcessEmit.apply(this, arguments);
    }
  }
});

// ../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/kill.js
var require_kill = __commonJS((exports2, module2) => {
  "use strict";
  var os3 = require("os");
  var onExit = require_signal_exit();
  var DEFAULT_FORCE_KILL_TIMEOUT = 1e3 * 5;
  var spawnedKill = (kill, signal = "SIGTERM", options = {}) => {
    const killResult = kill(signal);
    setKillTimeout(kill, signal, options, killResult);
    return killResult;
  };
  var setKillTimeout = (kill, signal, options, killResult) => {
    if (!shouldForceKill(signal, options, killResult)) {
      return;
    }
    const timeout = getForceKillAfterTimeout(options);
    const t = setTimeout(() => {
      kill("SIGKILL");
    }, timeout);
    if (t.unref) {
      t.unref();
    }
  };
  var shouldForceKill = (signal, {forceKillAfterTimeout}, killResult) => {
    return isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
  };
  var isSigterm = (signal) => {
    return signal === os3.constants.signals.SIGTERM || typeof signal === "string" && signal.toUpperCase() === "SIGTERM";
  };
  var getForceKillAfterTimeout = ({forceKillAfterTimeout = true}) => {
    if (forceKillAfterTimeout === true) {
      return DEFAULT_FORCE_KILL_TIMEOUT;
    }
    if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {
      throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
    }
    return forceKillAfterTimeout;
  };
  var spawnedCancel = (spawned, context) => {
    const killResult = spawned.kill();
    if (killResult) {
      context.isCanceled = true;
    }
  };
  var timeoutKill = (spawned, signal, reject) => {
    spawned.kill(signal);
    reject(Object.assign(new Error("Timed out"), {timedOut: true, signal}));
  };
  var setupTimeout = (spawned, {timeout, killSignal = "SIGTERM"}, spawnedPromise) => {
    if (timeout === 0 || timeout === void 0) {
      return spawnedPromise;
    }
    let timeoutId;
    const timeoutPromise = new Promise((resolve, reject) => {
      timeoutId = setTimeout(() => {
        timeoutKill(spawned, killSignal, reject);
      }, timeout);
    });
    const safeSpawnedPromise = spawnedPromise.finally(() => {
      clearTimeout(timeoutId);
    });
    return Promise.race([timeoutPromise, safeSpawnedPromise]);
  };
  var validateTimeout = ({timeout}) => {
    if (timeout !== void 0 && (!Number.isFinite(timeout) || timeout < 0)) {
      throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
    }
  };
  var setExitHandler = async (spawned, {cleanup: cleanup2, detached}, timedPromise) => {
    if (!cleanup2 || detached) {
      return timedPromise;
    }
    const removeExitHandler = onExit(() => {
      spawned.kill();
    });
    return timedPromise.finally(() => {
      removeExitHandler();
    });
  };
  module2.exports = {
    spawnedKill,
    spawnedCancel,
    setupTimeout,
    validateTimeout,
    setExitHandler
  };
});

// ../../node_modules/.pnpm/is-stream@2.0.1/node_modules/is-stream/index.js
var require_is_stream = __commonJS((exports2, module2) => {
  "use strict";
  var isStream = (stream) => stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
  isStream.writable = (stream) => isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
  isStream.readable = (stream) => isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
  isStream.duplex = (stream) => isStream.writable(stream) && isStream.readable(stream);
  isStream.transform = (stream) => isStream.duplex(stream) && typeof stream._transform === "function";
  module2.exports = isStream;
});

// ../../node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/buffer-stream.js
var require_buffer_stream = __commonJS((exports2, module2) => {
  "use strict";
  var {PassThrough: PassThroughStream} = require("stream");
  module2.exports = (options) => {
    options = {...options};
    const {array} = options;
    let {encoding} = options;
    const isBuffer = encoding === "buffer";
    let objectMode = false;
    if (array) {
      objectMode = !(encoding || isBuffer);
    } else {
      encoding = encoding || "utf8";
    }
    if (isBuffer) {
      encoding = null;
    }
    const stream = new PassThroughStream({objectMode});
    if (encoding) {
      stream.setEncoding(encoding);
    }
    let length = 0;
    const chunks = [];
    stream.on("data", (chunk) => {
      chunks.push(chunk);
      if (objectMode) {
        length = chunks.length;
      } else {
        length += chunk.length;
      }
    });
    stream.getBufferedValue = () => {
      if (array) {
        return chunks;
      }
      return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
    };
    stream.getBufferedLength = () => length;
    return stream;
  };
});

// ../../node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/index.js
var require_get_stream = __commonJS((exports2, module2) => {
  "use strict";
  var {constants: BufferConstants} = require("buffer");
  var stream = require("stream");
  var {promisify: promisify4} = require("util");
  var bufferStream = require_buffer_stream();
  var streamPipelinePromisified = promisify4(stream.pipeline);
  var MaxBufferError = class extends Error {
    constructor() {
      super("maxBuffer exceeded");
      this.name = "MaxBufferError";
    }
  };
  async function getStream(inputStream, options) {
    if (!inputStream) {
      throw new Error("Expected a stream");
    }
    options = {
      maxBuffer: Infinity,
      ...options
    };
    const {maxBuffer} = options;
    const stream2 = bufferStream(options);
    await new Promise((resolve, reject) => {
      const rejectPromise = (error) => {
        if (error && stream2.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
          error.bufferedData = stream2.getBufferedValue();
        }
        reject(error);
      };
      (async () => {
        try {
          await streamPipelinePromisified(inputStream, stream2);
          resolve();
        } catch (error) {
          rejectPromise(error);
        }
      })();
      stream2.on("data", () => {
        if (stream2.getBufferedLength() > maxBuffer) {
          rejectPromise(new MaxBufferError());
        }
      });
    });
    return stream2.getBufferedValue();
  }
  module2.exports = getStream;
  module2.exports.buffer = (stream2, options) => getStream(stream2, {...options, encoding: "buffer"});
  module2.exports.array = (stream2, options) => getStream(stream2, {...options, array: true});
  module2.exports.MaxBufferError = MaxBufferError;
});

// ../../node_modules/.pnpm/merge-stream@2.0.0/node_modules/merge-stream/index.js
var require_merge_stream = __commonJS((exports2, module2) => {
  "use strict";
  var {PassThrough} = require("stream");
  module2.exports = function() {
    var sources = [];
    var output = new PassThrough({objectMode: true});
    output.setMaxListeners(0);
    output.add = add;
    output.isEmpty = isEmpty;
    output.on("unpipe", remove);
    Array.prototype.slice.call(arguments).forEach(add);
    return output;
    function add(source) {
      if (Array.isArray(source)) {
        source.forEach(add);
        return this;
      }
      sources.push(source);
      source.once("end", remove.bind(null, source));
      source.once("error", output.emit.bind(output, "error"));
      source.pipe(output, {end: false});
      return this;
    }
    function isEmpty() {
      return sources.length == 0;
    }
    function remove(source) {
      sources = sources.filter(function(it) {
        return it !== source;
      });
      if (!sources.length && output.readable) {
        output.end();
      }
    }
  };
});

// ../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/stream.js
var require_stream = __commonJS((exports2, module2) => {
  "use strict";
  var isStream = require_is_stream();
  var getStream = require_get_stream();
  var mergeStream = require_merge_stream();
  var handleInput = (spawned, input) => {
    if (input === void 0 || spawned.stdin === void 0) {
      return;
    }
    if (isStream(input)) {
      input.pipe(spawned.stdin);
    } else {
      spawned.stdin.end(input);
    }
  };
  var makeAllStream = (spawned, {all}) => {
    if (!all || !spawned.stdout && !spawned.stderr) {
      return;
    }
    const mixed = mergeStream();
    if (spawned.stdout) {
      mixed.add(spawned.stdout);
    }
    if (spawned.stderr) {
      mixed.add(spawned.stderr);
    }
    return mixed;
  };
  var getBufferedData = async (stream, streamPromise) => {
    if (!stream) {
      return;
    }
    stream.destroy();
    try {
      return await streamPromise;
    } catch (error) {
      return error.bufferedData;
    }
  };
  var getStreamPromise = (stream, {encoding, buffer, maxBuffer}) => {
    if (!stream || !buffer) {
      return;
    }
    if (encoding) {
      return getStream(stream, {encoding, maxBuffer});
    }
    return getStream.buffer(stream, {maxBuffer});
  };
  var getSpawnedResult = async ({stdout, stderr, all}, {encoding, buffer, maxBuffer}, processDone) => {
    const stdoutPromise = getStreamPromise(stdout, {encoding, buffer, maxBuffer});
    const stderrPromise = getStreamPromise(stderr, {encoding, buffer, maxBuffer});
    const allPromise = getStreamPromise(all, {encoding, buffer, maxBuffer: maxBuffer * 2});
    try {
      return await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);
    } catch (error) {
      return Promise.all([
        {error, signal: error.signal, timedOut: error.timedOut},
        getBufferedData(stdout, stdoutPromise),
        getBufferedData(stderr, stderrPromise),
        getBufferedData(all, allPromise)
      ]);
    }
  };
  var validateInputSync = ({input}) => {
    if (isStream(input)) {
      throw new TypeError("The `input` option cannot be a stream in sync mode");
    }
  };
  module2.exports = {
    handleInput,
    makeAllStream,
    getSpawnedResult,
    validateInputSync
  };
});

// ../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/promise.js
var require_promise = __commonJS((exports2, module2) => {
  "use strict";
  var nativePromisePrototype = (async () => {
  })().constructor.prototype;
  var descriptors = ["then", "catch", "finally"].map((property) => [
    property,
    Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
  ]);
  var mergePromise = (spawned, promise) => {
    for (const [property, descriptor] of descriptors) {
      const value = typeof promise === "function" ? (...args2) => Reflect.apply(descriptor.value, promise(), args2) : descriptor.value.bind(promise);
      Reflect.defineProperty(spawned, property, {...descriptor, value});
    }
    return spawned;
  };
  var getSpawnedPromise = (spawned) => {
    return new Promise((resolve, reject) => {
      spawned.on("exit", (exitCode, signal) => {
        resolve({exitCode, signal});
      });
      spawned.on("error", (error) => {
        reject(error);
      });
      if (spawned.stdin) {
        spawned.stdin.on("error", (error) => {
          reject(error);
        });
      }
    });
  };
  module2.exports = {
    mergePromise,
    getSpawnedPromise
  };
});

// ../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/command.js
var require_command = __commonJS((exports2, module2) => {
  "use strict";
  var normalizeArgs = (file, args2 = []) => {
    if (!Array.isArray(args2)) {
      return [file];
    }
    return [file, ...args2];
  };
  var NO_ESCAPE_REGEXP = /^[\w.-]+$/;
  var DOUBLE_QUOTES_REGEXP = /"/g;
  var escapeArg = (arg10) => {
    if (typeof arg10 !== "string" || NO_ESCAPE_REGEXP.test(arg10)) {
      return arg10;
    }
    return `"${arg10.replace(DOUBLE_QUOTES_REGEXP, '\\"')}"`;
  };
  var joinCommand = (file, args2) => {
    return normalizeArgs(file, args2).join(" ");
  };
  var getEscapedCommand = (file, args2) => {
    return normalizeArgs(file, args2).map((arg10) => escapeArg(arg10)).join(" ");
  };
  var SPACES_REGEXP = / +/g;
  var parseCommand = (command) => {
    const tokens = [];
    for (const token of command.trim().split(SPACES_REGEXP)) {
      const previousToken = tokens[tokens.length - 1];
      if (previousToken && previousToken.endsWith("\\")) {
        tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
      } else {
        tokens.push(token);
      }
    }
    return tokens;
  };
  module2.exports = {
    joinCommand,
    getEscapedCommand,
    parseCommand
  };
});

// ../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/index.js
var require_execa = __commonJS((exports2, module2) => {
  "use strict";
  var path10 = require("path");
  var childProcess = require("child_process");
  var crossSpawn = require_cross_spawn();
  var stripFinalNewline = require_strip_final_newline();
  var npmRunPath = require_npm_run_path();
  var onetime = require_onetime();
  var makeError = require_error();
  var normalizeStdio = require_stdio();
  var {spawnedKill, spawnedCancel, setupTimeout, validateTimeout, setExitHandler} = require_kill();
  var {handleInput, getSpawnedResult, makeAllStream, validateInputSync} = require_stream();
  var {mergePromise, getSpawnedPromise} = require_promise();
  var {joinCommand, parseCommand, getEscapedCommand} = require_command();
  var DEFAULT_MAX_BUFFER = 1e3 * 1e3 * 100;
  var getEnv = ({env: envOption, extendEnv, preferLocal, localDir, execPath}) => {
    const env2 = extendEnv ? {...process.env, ...envOption} : envOption;
    if (preferLocal) {
      return npmRunPath.env({env: env2, cwd: localDir, execPath});
    }
    return env2;
  };
  var handleArguments = (file, args2, options = {}) => {
    const parsed = crossSpawn._parse(file, args2, options);
    file = parsed.command;
    args2 = parsed.args;
    options = parsed.options;
    options = {
      maxBuffer: DEFAULT_MAX_BUFFER,
      buffer: true,
      stripFinalNewline: true,
      extendEnv: true,
      preferLocal: false,
      localDir: options.cwd || process.cwd(),
      execPath: process.execPath,
      encoding: "utf8",
      reject: true,
      cleanup: true,
      all: false,
      windowsHide: true,
      ...options
    };
    options.env = getEnv(options);
    options.stdio = normalizeStdio(options);
    if (process.platform === "win32" && path10.basename(file, ".exe") === "cmd") {
      args2.unshift("/q");
    }
    return {file, args: args2, options, parsed};
  };
  var handleOutput = (options, value, error) => {
    if (typeof value !== "string" && !Buffer.isBuffer(value)) {
      return error === void 0 ? void 0 : "";
    }
    if (options.stripFinalNewline) {
      return stripFinalNewline(value);
    }
    return value;
  };
  var execa = (file, args2, options) => {
    const parsed = handleArguments(file, args2, options);
    const command = joinCommand(file, args2);
    const escapedCommand = getEscapedCommand(file, args2);
    validateTimeout(parsed.options);
    let spawned;
    try {
      spawned = childProcess.spawn(parsed.file, parsed.args, parsed.options);
    } catch (error) {
      const dummySpawned = new childProcess.ChildProcess();
      const errorPromise = Promise.reject(makeError({
        error,
        stdout: "",
        stderr: "",
        all: "",
        command,
        escapedCommand,
        parsed,
        timedOut: false,
        isCanceled: false,
        killed: false
      }));
      return mergePromise(dummySpawned, errorPromise);
    }
    const spawnedPromise = getSpawnedPromise(spawned);
    const timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);
    const processDone = setExitHandler(spawned, parsed.options, timedPromise);
    const context = {isCanceled: false};
    spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));
    spawned.cancel = spawnedCancel.bind(null, spawned, context);
    const handlePromise = async () => {
      const [{error, exitCode, signal, timedOut}, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone);
      const stdout = handleOutput(parsed.options, stdoutResult);
      const stderr = handleOutput(parsed.options, stderrResult);
      const all = handleOutput(parsed.options, allResult);
      if (error || exitCode !== 0 || signal !== null) {
        const returnedError = makeError({
          error,
          exitCode,
          signal,
          stdout,
          stderr,
          all,
          command,
          escapedCommand,
          parsed,
          timedOut,
          isCanceled: context.isCanceled,
          killed: spawned.killed
        });
        if (!parsed.options.reject) {
          return returnedError;
        }
        throw returnedError;
      }
      return {
        command,
        escapedCommand,
        exitCode: 0,
        stdout,
        stderr,
        all,
        failed: false,
        timedOut: false,
        isCanceled: false,
        killed: false
      };
    };
    const handlePromiseOnce = onetime(handlePromise);
    handleInput(spawned, parsed.options.input);
    spawned.all = makeAllStream(spawned, parsed.options);
    return mergePromise(spawned, handlePromiseOnce);
  };
  module2.exports = execa;
  module2.exports.sync = (file, args2, options) => {
    const parsed = handleArguments(file, args2, options);
    const command = joinCommand(file, args2);
    const escapedCommand = getEscapedCommand(file, args2);
    validateInputSync(parsed.options);
    let result;
    try {
      result = childProcess.spawnSync(parsed.file, parsed.args, parsed.options);
    } catch (error) {
      throw makeError({
        error,
        stdout: "",
        stderr: "",
        all: "",
        command,
        escapedCommand,
        parsed,
        timedOut: false,
        isCanceled: false,
        killed: false
      });
    }
    const stdout = handleOutput(parsed.options, result.stdout, result.error);
    const stderr = handleOutput(parsed.options, result.stderr, result.error);
    if (result.error || result.status !== 0 || result.signal !== null) {
      const error = makeError({
        stdout,
        stderr,
        error: result.error,
        signal: result.signal,
        exitCode: result.status,
        command,
        escapedCommand,
        parsed,
        timedOut: result.error && result.error.code === "ETIMEDOUT",
        isCanceled: false,
        killed: result.signal !== null
      });
      if (!parsed.options.reject) {
        return error;
      }
      throw error;
    }
    return {
      command,
      escapedCommand,
      exitCode: 0,
      stdout,
      stderr,
      failed: false,
      timedOut: false,
      isCanceled: false,
      killed: false
    };
  };
  module2.exports.command = (command, options) => {
    const [file, ...args2] = parseCommand(command);
    return execa(file, args2, options);
  };
  module2.exports.commandSync = (command, options) => {
    const [file, ...args2] = parseCommand(command);
    return execa.sync(file, args2, options);
  };
  module2.exports.node = (scriptPath, args2, options = {}) => {
    if (args2 && !Array.isArray(args2) && typeof args2 === "object") {
      options = args2;
      args2 = [];
    }
    const stdio = normalizeStdio.node(options);
    const defaultExecArgv = process.execArgv.filter((arg10) => !arg10.startsWith("--inspect"));
    const {
      nodePath = process.execPath,
      nodeOptions = defaultExecArgv
    } = options;
    return execa(nodePath, [
      ...nodeOptions,
      scriptPath,
      ...Array.isArray(args2) ? args2 : []
    ], {
      ...options,
      stdin: void 0,
      stdout: void 0,
      stderr: void 0,
      stdio,
      shell: false
    });
  };
});

// ../../node_modules/.pnpm/p-try@2.2.0/node_modules/p-try/index.js
var require_p_try = __commonJS((exports2, module2) => {
  "use strict";
  var pTry = (fn, ...arguments_) => new Promise((resolve) => {
    resolve(fn(...arguments_));
  });
  module2.exports = pTry;
  module2.exports.default = pTry;
});

// ../../node_modules/.pnpm/p-limit@2.3.0/node_modules/p-limit/index.js
var require_p_limit = __commonJS((exports2, module2) => {
  "use strict";
  var pTry = require_p_try();
  var pLimit = (concurrency) => {
    if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
      return Promise.reject(new TypeError("Expected `concurrency` to be a number from 1 and up"));
    }
    const queue = [];
    let activeCount = 0;
    const next = () => {
      activeCount--;
      if (queue.length > 0) {
        queue.shift()();
      }
    };
    const run = (fn, resolve, ...args2) => {
      activeCount++;
      const result = pTry(fn, ...args2);
      resolve(result);
      result.then(next, next);
    };
    const enqueue = (fn, resolve, ...args2) => {
      if (activeCount < concurrency) {
        run(fn, resolve, ...args2);
      } else {
        queue.push(run.bind(null, fn, resolve, ...args2));
      }
    };
    const generator = (fn, ...args2) => new Promise((resolve) => enqueue(fn, resolve, ...args2));
    Object.defineProperties(generator, {
      activeCount: {
        get: () => activeCount
      },
      pendingCount: {
        get: () => queue.length
      },
      clearQueue: {
        value: () => {
          queue.length = 0;
        }
      }
    });
    return generator;
  };
  module2.exports = pLimit;
  module2.exports.default = pLimit;
});

// ../../node_modules/.pnpm/p-locate@4.1.0/node_modules/p-locate/index.js
var require_p_locate = __commonJS((exports2, module2) => {
  "use strict";
  var pLimit = require_p_limit();
  var EndError = class extends Error {
    constructor(value) {
      super();
      this.value = value;
    }
  };
  var testElement = async (element, tester) => tester(await element);
  var finder = async (element) => {
    const values = await Promise.all(element);
    if (values[1] === true) {
      throw new EndError(values[0]);
    }
    return false;
  };
  var pLocate = async (iterable, tester, options) => {
    options = {
      concurrency: Infinity,
      preserveOrder: true,
      ...options
    };
    const limit = pLimit(options.concurrency);
    const items = [...iterable].map((element) => [element, limit(testElement, element, tester)]);
    const checkLimit = pLimit(options.preserveOrder ? 1 : Infinity);
    try {
      await Promise.all(items.map((element) => checkLimit(finder, element)));
    } catch (error) {
      if (error instanceof EndError) {
        return error.value;
      }
      throw error;
    }
  };
  module2.exports = pLocate;
  module2.exports.default = pLocate;
});

// ../../node_modules/.pnpm/locate-path@5.0.0/node_modules/locate-path/index.js
var require_locate_path = __commonJS((exports2, module2) => {
  "use strict";
  var path10 = require("path");
  var fs9 = require("fs");
  var {promisify: promisify4} = require("util");
  var pLocate = require_p_locate();
  var fsStat = promisify4(fs9.stat);
  var fsLStat = promisify4(fs9.lstat);
  var typeMappings = {
    directory: "isDirectory",
    file: "isFile"
  };
  function checkType({type}) {
    if (type in typeMappings) {
      return;
    }
    throw new Error(`Invalid type specified: ${type}`);
  }
  var matchType = (type, stat) => type === void 0 || stat[typeMappings[type]]();
  module2.exports = async (paths, options) => {
    options = {
      cwd: process.cwd(),
      type: "file",
      allowSymlinks: true,
      ...options
    };
    checkType(options);
    const statFn = options.allowSymlinks ? fsStat : fsLStat;
    return pLocate(paths, async (path_) => {
      try {
        const stat = await statFn(path10.resolve(options.cwd, path_));
        return matchType(options.type, stat);
      } catch (_2) {
        return false;
      }
    }, options);
  };
  module2.exports.sync = (paths, options) => {
    options = {
      cwd: process.cwd(),
      allowSymlinks: true,
      type: "file",
      ...options
    };
    checkType(options);
    const statFn = options.allowSymlinks ? fs9.statSync : fs9.lstatSync;
    for (const path_ of paths) {
      try {
        const stat = statFn(path10.resolve(options.cwd, path_));
        if (matchType(options.type, stat)) {
          return path_;
        }
      } catch (_2) {
      }
    }
  };
});

// ../../node_modules/.pnpm/path-exists@4.0.0/node_modules/path-exists/index.js
var require_path_exists = __commonJS((exports2, module2) => {
  "use strict";
  var fs9 = require("fs");
  var {promisify: promisify4} = require("util");
  var pAccess = promisify4(fs9.access);
  module2.exports = async (path10) => {
    try {
      await pAccess(path10);
      return true;
    } catch (_2) {
      return false;
    }
  };
  module2.exports.sync = (path10) => {
    try {
      fs9.accessSync(path10);
      return true;
    } catch (_2) {
      return false;
    }
  };
});

// ../../node_modules/.pnpm/find-up@4.1.0/node_modules/find-up/index.js
var require_find_up = __commonJS((exports2, module2) => {
  "use strict";
  var path10 = require("path");
  var locatePath = require_locate_path();
  var pathExists = require_path_exists();
  var stop = Symbol("findUp.stop");
  module2.exports = async (name, options = {}) => {
    let directory = path10.resolve(options.cwd || "");
    const {root} = path10.parse(directory);
    const paths = [].concat(name);
    const runMatcher = async (locateOptions) => {
      if (typeof name !== "function") {
        return locatePath(paths, locateOptions);
      }
      const foundPath = await name(locateOptions.cwd);
      if (typeof foundPath === "string") {
        return locatePath([foundPath], locateOptions);
      }
      return foundPath;
    };
    while (true) {
      const foundPath = await runMatcher({...options, cwd: directory});
      if (foundPath === stop) {
        return;
      }
      if (foundPath) {
        return path10.resolve(directory, foundPath);
      }
      if (directory === root) {
        return;
      }
      directory = path10.dirname(directory);
    }
  };
  module2.exports.sync = (name, options = {}) => {
    let directory = path10.resolve(options.cwd || "");
    const {root} = path10.parse(directory);
    const paths = [].concat(name);
    const runMatcher = (locateOptions) => {
      if (typeof name !== "function") {
        return locatePath.sync(paths, locateOptions);
      }
      const foundPath = name(locateOptions.cwd);
      if (typeof foundPath === "string") {
        return locatePath.sync([foundPath], locateOptions);
      }
      return foundPath;
    };
    while (true) {
      const foundPath = runMatcher({...options, cwd: directory});
      if (foundPath === stop) {
        return;
      }
      if (foundPath) {
        return path10.resolve(directory, foundPath);
      }
      if (directory === root) {
        return;
      }
      directory = path10.dirname(directory);
    }
  };
  module2.exports.exists = pathExists;
  module2.exports.sync.exists = pathExists.sync;
  module2.exports.stop = stop;
});

// ../../node_modules/.pnpm/is-arrayish@0.2.1/node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function isArrayish(obj) {
    if (!obj) {
      return false;
    }
    return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && obj.splice instanceof Function;
  };
});

// ../../node_modules/.pnpm/error-ex@1.3.2/node_modules/error-ex/index.js
var require_error_ex = __commonJS((exports2, module2) => {
  "use strict";
  var util2 = require("util");
  var isArrayish = require_is_arrayish();
  var errorEx = function errorEx2(name, properties) {
    if (!name || name.constructor !== String) {
      properties = name || {};
      name = Error.name;
    }
    var errorExError = function ErrorEXError(message) {
      if (!this) {
        return new ErrorEXError(message);
      }
      message = message instanceof Error ? message.message : message || this.message;
      Error.call(this, message);
      Error.captureStackTrace(this, errorExError);
      this.name = name;
      Object.defineProperty(this, "message", {
        configurable: true,
        enumerable: false,
        get: function() {
          var newMessage = message.split(/\r?\n/g);
          for (var key in properties) {
            if (!properties.hasOwnProperty(key)) {
              continue;
            }
            var modifier = properties[key];
            if ("message" in modifier) {
              newMessage = modifier.message(this[key], newMessage) || newMessage;
              if (!isArrayish(newMessage)) {
                newMessage = [newMessage];
              }
            }
          }
          return newMessage.join("\n");
        },
        set: function(v) {
          message = v;
        }
      });
      var overwrittenStack = null;
      var stackDescriptor = Object.getOwnPropertyDescriptor(this, "stack");
      var stackGetter = stackDescriptor.get;
      var stackValue = stackDescriptor.value;
      delete stackDescriptor.value;
      delete stackDescriptor.writable;
      stackDescriptor.set = function(newstack) {
        overwrittenStack = newstack;
      };
      stackDescriptor.get = function() {
        var stack = (overwrittenStack || (stackGetter ? stackGetter.call(this) : stackValue)).split(/\r?\n+/g);
        if (!overwrittenStack) {
          stack[0] = this.name + ": " + this.message;
        }
        var lineCount = 1;
        for (var key in properties) {
          if (!properties.hasOwnProperty(key)) {
            continue;
          }
          var modifier = properties[key];
          if ("line" in modifier) {
            var line = modifier.line(this[key]);
            if (line) {
              stack.splice(lineCount++, 0, "    " + line);
            }
          }
          if ("stack" in modifier) {
            modifier.stack(this[key], stack);
          }
        }
        return stack.join("\n");
      };
      Object.defineProperty(this, "stack", stackDescriptor);
    };
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(errorExError.prototype, Error.prototype);
      Object.setPrototypeOf(errorExError, Error);
    } else {
      util2.inherits(errorExError, Error);
    }
    return errorExError;
  };
  errorEx.append = function(str, def) {
    return {
      message: function(v, message) {
        v = v || def;
        if (v) {
          message[0] += " " + str.replace("%s", v.toString());
        }
        return message;
      }
    };
  };
  errorEx.line = function(str, def) {
    return {
      line: function(v) {
        v = v || def;
        if (v) {
          return str.replace("%s", v.toString());
        }
        return null;
      }
    };
  };
  module2.exports = errorEx;
});

// ../../node_modules/.pnpm/json-parse-even-better-errors@2.3.1/node_modules/json-parse-even-better-errors/index.js
var require_json_parse_even_better_errors = __commonJS((exports2, module2) => {
  "use strict";
  var hexify = (char) => {
    const h2 = char.charCodeAt(0).toString(16).toUpperCase();
    return "0x" + (h2.length % 2 ? "0" : "") + h2;
  };
  var parseError = (e, txt, context) => {
    if (!txt) {
      return {
        message: e.message + " while parsing empty string",
        position: 0
      };
    }
    const badToken = e.message.match(/^Unexpected token (.) .*position\s+(\d+)/i);
    const errIdx = badToken ? +badToken[2] : e.message.match(/^Unexpected end of JSON.*/i) ? txt.length - 1 : null;
    const msg = badToken ? e.message.replace(/^Unexpected token ./, `Unexpected token ${JSON.stringify(badToken[1])} (${hexify(badToken[1])})`) : e.message;
    if (errIdx !== null && errIdx !== void 0) {
      const start = errIdx <= context ? 0 : errIdx - context;
      const end = errIdx + context >= txt.length ? txt.length : errIdx + context;
      const slice = (start === 0 ? "" : "...") + txt.slice(start, end) + (end === txt.length ? "" : "...");
      const near = txt === slice ? "" : "near ";
      return {
        message: msg + ` while parsing ${near}${JSON.stringify(slice)}`,
        position: errIdx
      };
    } else {
      return {
        message: msg + ` while parsing '${txt.slice(0, context * 2)}'`,
        position: 0
      };
    }
  };
  var JSONParseError = class extends SyntaxError {
    constructor(er, txt, context, caller) {
      context = context || 20;
      const metadata = parseError(er, txt, context);
      super(metadata.message);
      Object.assign(this, metadata);
      this.code = "EJSONPARSE";
      this.systemError = er;
      Error.captureStackTrace(this, caller || this.constructor);
    }
    get name() {
      return this.constructor.name;
    }
    set name(n) {
    }
    get [Symbol.toStringTag]() {
      return this.constructor.name;
    }
  };
  var kIndent = Symbol.for("indent");
  var kNewline = Symbol.for("newline");
  var formatRE = /^\s*[{\[]((?:\r?\n)+)([\s\t]*)/;
  var emptyRE = /^(?:\{\}|\[\])((?:\r?\n)+)?$/;
  var parseJson = (txt, reviver, context) => {
    const parseText = stripBOM(txt);
    context = context || 20;
    try {
      const [, newline = "\n", indent = "  "] = parseText.match(emptyRE) || parseText.match(formatRE) || [, "", ""];
      const result = JSON.parse(parseText, reviver);
      if (result && typeof result === "object") {
        result[kNewline] = newline;
        result[kIndent] = indent;
      }
      return result;
    } catch (e) {
      if (typeof txt !== "string" && !Buffer.isBuffer(txt)) {
        const isEmptyArray = Array.isArray(txt) && txt.length === 0;
        throw Object.assign(new TypeError(`Cannot parse ${isEmptyArray ? "an empty array" : String(txt)}`), {
          code: "EJSONPARSE",
          systemError: e
        });
      }
      throw new JSONParseError(e, parseText, context, parseJson);
    }
  };
  var stripBOM = (txt) => String(txt).replace(/^\uFEFF/, "");
  module2.exports = parseJson;
  parseJson.JSONParseError = JSONParseError;
  parseJson.noExceptions = (txt, reviver) => {
    try {
      return JSON.parse(stripBOM(txt), reviver);
    } catch (e) {
    }
  };
});

// ../../node_modules/.pnpm/lines-and-columns@1.1.6/node_modules/lines-and-columns/dist/index.js
var require_dist = __commonJS((exports2) => {
  "use strict";
  var LF = "\n";
  var CR = "\r";
  var LinesAndColumns = function() {
    function LinesAndColumns2(string) {
      this.string = string;
      var offsets = [0];
      for (var offset = 0; offset < string.length; ) {
        switch (string[offset]) {
          case LF:
            offset += LF.length;
            offsets.push(offset);
            break;
          case CR:
            offset += CR.length;
            if (string[offset] === LF) {
              offset += LF.length;
            }
            offsets.push(offset);
            break;
          default:
            offset++;
            break;
        }
      }
      this.offsets = offsets;
    }
    LinesAndColumns2.prototype.locationForIndex = function(index) {
      if (index < 0 || index > this.string.length) {
        return null;
      }
      var line = 0;
      var offsets = this.offsets;
      while (offsets[line + 1] <= index) {
        line++;
      }
      var column = index - offsets[line];
      return {line, column};
    };
    LinesAndColumns2.prototype.indexForLocation = function(location) {
      var line = location.line, column = location.column;
      if (line < 0 || line >= this.offsets.length) {
        return null;
      }
      if (column < 0 || column > this.lengthOfLine(line)) {
        return null;
      }
      return this.offsets[line] + column;
    };
    LinesAndColumns2.prototype.lengthOfLine = function(line) {
      var offset = this.offsets[line];
      var nextOffset = line === this.offsets.length - 1 ? this.string.length : this.offsets[line + 1];
      return nextOffset - offset;
    };
    return LinesAndColumns2;
  }();
  exports2.__esModule = true;
  exports2["default"] = LinesAndColumns;
});

// ../../node_modules/.pnpm/js-tokens@4.0.0/node_modules/js-tokens/index.js
var require_js_tokens = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
  exports2.matchToToken = function(match) {
    var token = {type: "invalid", value: match[0], closed: void 0};
    if (match[1])
      token.type = "string", token.closed = !!(match[3] || match[4]);
    else if (match[5])
      token.type = "comment";
    else if (match[6])
      token.type = "comment", token.closed = !!match[7];
    else if (match[8])
      token.type = "regex";
    else if (match[9])
      token.type = "number";
    else if (match[10])
      token.type = "name";
    else if (match[11])
      token.type = "punctuator";
    else if (match[12])
      token.type = "whitespace";
    return token;
  };
});

// ../../node_modules/.pnpm/@babel+helper-validator-identifier@7.14.8/node_modules/@babel/helper-validator-identifier/lib/identifier.js
var require_identifier = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.isIdentifierStart = isIdentifierStart;
  exports2.isIdentifierChar = isIdentifierChar;
  exports2.isIdentifierName = isIdentifierName;
  var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
  var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
  var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
  var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function isInAstralSet(code, set) {
    let pos = 65536;
    for (let i = 0, length = set.length; i < length; i += 2) {
      pos += set[i];
      if (pos > code)
        return false;
      pos += set[i + 1];
      if (pos >= code)
        return true;
    }
    return false;
  }
  function isIdentifierStart(code) {
    if (code < 65)
      return code === 36;
    if (code <= 90)
      return true;
    if (code < 97)
      return code === 95;
    if (code <= 122)
      return true;
    if (code <= 65535) {
      return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
    }
    return isInAstralSet(code, astralIdentifierStartCodes);
  }
  function isIdentifierChar(code) {
    if (code < 48)
      return code === 36;
    if (code < 58)
      return true;
    if (code < 65)
      return false;
    if (code <= 90)
      return true;
    if (code < 97)
      return code === 95;
    if (code <= 122)
      return true;
    if (code <= 65535) {
      return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
    }
    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
  }
  function isIdentifierName(name) {
    let isFirst = true;
    for (let i = 0; i < name.length; i++) {
      let cp = name.charCodeAt(i);
      if ((cp & 64512) === 55296 && i + 1 < name.length) {
        const trail = name.charCodeAt(++i);
        if ((trail & 64512) === 56320) {
          cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
        }
      }
      if (isFirst) {
        isFirst = false;
        if (!isIdentifierStart(cp)) {
          return false;
        }
      } else if (!isIdentifierChar(cp)) {
        return false;
      }
    }
    return !isFirst;
  }
});

// ../../node_modules/.pnpm/@babel+helper-validator-identifier@7.14.8/node_modules/@babel/helper-validator-identifier/lib/keyword.js
var require_keyword = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.isReservedWord = isReservedWord;
  exports2.isStrictReservedWord = isStrictReservedWord;
  exports2.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
  exports2.isStrictBindReservedWord = isStrictBindReservedWord;
  exports2.isKeyword = isKeyword;
  var reservedWords = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  };
  var keywords = new Set(reservedWords.keyword);
  var reservedWordsStrictSet = new Set(reservedWords.strict);
  var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
  function isReservedWord(word, inModule) {
    return inModule && word === "await" || word === "enum";
  }
  function isStrictReservedWord(word, inModule) {
    return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
  }
  function isStrictBindOnlyReservedWord(word) {
    return reservedWordsStrictBindSet.has(word);
  }
  function isStrictBindReservedWord(word, inModule) {
    return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
  }
  function isKeyword(word) {
    return keywords.has(word);
  }
});

// ../../node_modules/.pnpm/@babel+helper-validator-identifier@7.14.8/node_modules/@babel/helper-validator-identifier/lib/index.js
var require_lib = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  Object.defineProperty(exports2, "isIdentifierName", {
    enumerable: true,
    get: function() {
      return _identifier.isIdentifierName;
    }
  });
  Object.defineProperty(exports2, "isIdentifierChar", {
    enumerable: true,
    get: function() {
      return _identifier.isIdentifierChar;
    }
  });
  Object.defineProperty(exports2, "isIdentifierStart", {
    enumerable: true,
    get: function() {
      return _identifier.isIdentifierStart;
    }
  });
  Object.defineProperty(exports2, "isReservedWord", {
    enumerable: true,
    get: function() {
      return _keyword.isReservedWord;
    }
  });
  Object.defineProperty(exports2, "isStrictBindOnlyReservedWord", {
    enumerable: true,
    get: function() {
      return _keyword.isStrictBindOnlyReservedWord;
    }
  });
  Object.defineProperty(exports2, "isStrictBindReservedWord", {
    enumerable: true,
    get: function() {
      return _keyword.isStrictBindReservedWord;
    }
  });
  Object.defineProperty(exports2, "isStrictReservedWord", {
    enumerable: true,
    get: function() {
      return _keyword.isStrictReservedWord;
    }
  });
  Object.defineProperty(exports2, "isKeyword", {
    enumerable: true,
    get: function() {
      return _keyword.isKeyword;
    }
  });
  var _identifier = require_identifier();
  var _keyword = require_keyword();
});

// ../../node_modules/.pnpm/escape-string-regexp@1.0.5/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS((exports2, module2) => {
  "use strict";
  var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
  module2.exports = function(str) {
    if (typeof str !== "string") {
      throw new TypeError("Expected a string");
    }
    return str.replace(matchOperatorsRe, "\\$&");
  };
});

// ../../node_modules/.pnpm/color-name@1.1.3/node_modules/color-name/index.js
var require_color_name2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
});

// ../../node_modules/.pnpm/color-convert@1.9.3/node_modules/color-convert/conversions.js
var require_conversions2 = __commonJS((exports2, module2) => {
  var cssKeywords = require_color_name2();
  var reverseKeywords = {};
  for (var key in cssKeywords) {
    if (cssKeywords.hasOwnProperty(key)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
  }
  var convert = module2.exports = {
    rgb: {channels: 3, labels: "rgb"},
    hsl: {channels: 3, labels: "hsl"},
    hsv: {channels: 3, labels: "hsv"},
    hwb: {channels: 3, labels: "hwb"},
    cmyk: {channels: 4, labels: "cmyk"},
    xyz: {channels: 3, labels: "xyz"},
    lab: {channels: 3, labels: "lab"},
    lch: {channels: 3, labels: "lch"},
    hex: {channels: 1, labels: ["hex"]},
    keyword: {channels: 1, labels: ["keyword"]},
    ansi16: {channels: 1, labels: ["ansi16"]},
    ansi256: {channels: 1, labels: ["ansi256"]},
    hcg: {channels: 3, labels: ["h", "c", "g"]},
    apple: {channels: 3, labels: ["r16", "g16", "b16"]},
    gray: {channels: 1, labels: ["gray"]}
  };
  for (var model in convert) {
    if (convert.hasOwnProperty(model)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      channels = convert[model].channels;
      labels = convert[model].labels;
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", {value: channels});
      Object.defineProperty(convert[model], "labels", {value: labels});
    }
  }
  var channels;
  var labels;
  convert.rgb.hsl = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var delta = max - min;
    var h2;
    var s2;
    var l;
    if (max === min) {
      h2 = 0;
    } else if (r === max) {
      h2 = (g - b) / delta;
    } else if (g === max) {
      h2 = 2 + (b - r) / delta;
    } else if (b === max) {
      h2 = 4 + (r - g) / delta;
    }
    h2 = Math.min(h2 * 60, 360);
    if (h2 < 0) {
      h2 += 360;
    }
    l = (min + max) / 2;
    if (max === min) {
      s2 = 0;
    } else if (l <= 0.5) {
      s2 = delta / (max + min);
    } else {
      s2 = delta / (2 - max - min);
    }
    return [h2, s2 * 100, l * 100];
  };
  convert.rgb.hsv = function(rgb) {
    var rdif;
    var gdif;
    var bdif;
    var h2;
    var s2;
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var v = Math.max(r, g, b);
    var diff = v - Math.min(r, g, b);
    var diffc = function(c) {
      return (v - c) / 6 / diff + 1 / 2;
    };
    if (diff === 0) {
      h2 = s2 = 0;
    } else {
      s2 = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);
      if (r === v) {
        h2 = bdif - gdif;
      } else if (g === v) {
        h2 = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h2 = 2 / 3 + gdif - rdif;
      }
      if (h2 < 0) {
        h2 += 1;
      } else if (h2 > 1) {
        h2 -= 1;
      }
    }
    return [
      h2 * 360,
      s2 * 100,
      v * 100
    ];
  };
  convert.rgb.hwb = function(rgb) {
    var r = rgb[0];
    var g = rgb[1];
    var b = rgb[2];
    var h2 = convert.rgb.hsl(rgb)[0];
    var w2 = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h2, w2 * 100, b * 100];
  };
  convert.rgb.cmyk = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var c;
    var m2;
    var y2;
    var k;
    k = Math.min(1 - r, 1 - g, 1 - b);
    c = (1 - r - k) / (1 - k) || 0;
    m2 = (1 - g - k) / (1 - k) || 0;
    y2 = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m2 * 100, y2 * 100, k * 100];
  };
  function comparativeDistance(x, y2) {
    return Math.pow(x[0] - y2[0], 2) + Math.pow(x[1] - y2[1], 2) + Math.pow(x[2] - y2[2], 2);
  }
  convert.rgb.keyword = function(rgb) {
    var reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    var currentClosestDistance = Infinity;
    var currentClosestKeyword;
    for (var keyword in cssKeywords) {
      if (cssKeywords.hasOwnProperty(keyword)) {
        var value = cssKeywords[keyword];
        var distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
    }
    return currentClosestKeyword;
  };
  convert.keyword.rgb = function(keyword) {
    return cssKeywords[keyword];
  };
  convert.rgb.xyz = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
    g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
    b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
    var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    var y2 = r * 0.2126 + g * 0.7152 + b * 0.0722;
    var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y2 * 100, z * 100];
  };
  convert.rgb.lab = function(rgb) {
    var xyz = convert.rgb.xyz(rgb);
    var x = xyz[0];
    var y2 = xyz[1];
    var z = xyz[2];
    var l;
    var a;
    var b;
    x /= 95.047;
    y2 /= 100;
    z /= 108.883;
    x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y2 = y2 > 8856e-6 ? Math.pow(y2, 1 / 3) : 7.787 * y2 + 16 / 116;
    z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
    l = 116 * y2 - 16;
    a = 500 * (x - y2);
    b = 200 * (y2 - z);
    return [l, a, b];
  };
  convert.hsl.rgb = function(hsl) {
    var h2 = hsl[0] / 360;
    var s2 = hsl[1] / 100;
    var l = hsl[2] / 100;
    var t1;
    var t2;
    var t3;
    var rgb;
    var val;
    if (s2 === 0) {
      val = l * 255;
      return [val, val, val];
    }
    if (l < 0.5) {
      t2 = l * (1 + s2);
    } else {
      t2 = l + s2 - l * s2;
    }
    t1 = 2 * l - t2;
    rgb = [0, 0, 0];
    for (var i = 0; i < 3; i++) {
      t3 = h2 + 1 / 3 * -(i - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }
      rgb[i] = val * 255;
    }
    return rgb;
  };
  convert.hsl.hsv = function(hsl) {
    var h2 = hsl[0];
    var s2 = hsl[1] / 100;
    var l = hsl[2] / 100;
    var smin = s2;
    var lmin = Math.max(l, 0.01);
    var sv;
    var v;
    l *= 2;
    s2 *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    v = (l + s2) / 2;
    sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s2 / (l + s2);
    return [h2, sv * 100, v * 100];
  };
  convert.hsv.rgb = function(hsv) {
    var h2 = hsv[0] / 60;
    var s2 = hsv[1] / 100;
    var v = hsv[2] / 100;
    var hi = Math.floor(h2) % 6;
    var f = h2 - Math.floor(h2);
    var p = 255 * v * (1 - s2);
    var q = 255 * v * (1 - s2 * f);
    var t = 255 * v * (1 - s2 * (1 - f));
    v *= 255;
    switch (hi) {
      case 0:
        return [v, t, p];
      case 1:
        return [q, v, p];
      case 2:
        return [p, v, t];
      case 3:
        return [p, q, v];
      case 4:
        return [t, p, v];
      case 5:
        return [v, p, q];
    }
  };
  convert.hsv.hsl = function(hsv) {
    var h2 = hsv[0];
    var s2 = hsv[1] / 100;
    var v = hsv[2] / 100;
    var vmin = Math.max(v, 0.01);
    var lmin;
    var sl;
    var l;
    l = (2 - s2) * v;
    lmin = (2 - s2) * vmin;
    sl = s2 * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h2, sl * 100, l * 100];
  };
  convert.hwb.rgb = function(hwb) {
    var h2 = hwb[0] / 360;
    var wh = hwb[1] / 100;
    var bl = hwb[2] / 100;
    var ratio = wh + bl;
    var i;
    var v;
    var f;
    var n;
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    i = Math.floor(6 * h2);
    v = 1 - bl;
    f = 6 * h2 - i;
    if ((i & 1) !== 0) {
      f = 1 - f;
    }
    n = wh + f * (v - wh);
    var r;
    var g;
    var b;
    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;
      case 1:
        r = n;
        g = v;
        b = wh;
        break;
      case 2:
        r = wh;
        g = v;
        b = n;
        break;
      case 3:
        r = wh;
        g = n;
        b = v;
        break;
      case 4:
        r = n;
        g = wh;
        b = v;
        break;
      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }
    return [r * 255, g * 255, b * 255];
  };
  convert.cmyk.rgb = function(cmyk) {
    var c = cmyk[0] / 100;
    var m2 = cmyk[1] / 100;
    var y2 = cmyk[2] / 100;
    var k = cmyk[3] / 100;
    var r;
    var g;
    var b;
    r = 1 - Math.min(1, c * (1 - k) + k);
    g = 1 - Math.min(1, m2 * (1 - k) + k);
    b = 1 - Math.min(1, y2 * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.rgb = function(xyz) {
    var x = xyz[0] / 100;
    var y2 = xyz[1] / 100;
    var z = xyz[2] / 100;
    var r;
    var g;
    var b;
    r = x * 3.2406 + y2 * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y2 * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y2 * -0.204 + z * 1.057;
    r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
    g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
    b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.lab = function(xyz) {
    var x = xyz[0];
    var y2 = xyz[1];
    var z = xyz[2];
    var l;
    var a;
    var b;
    x /= 95.047;
    y2 /= 100;
    z /= 108.883;
    x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y2 = y2 > 8856e-6 ? Math.pow(y2, 1 / 3) : 7.787 * y2 + 16 / 116;
    z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
    l = 116 * y2 - 16;
    a = 500 * (x - y2);
    b = 200 * (y2 - z);
    return [l, a, b];
  };
  convert.lab.xyz = function(lab) {
    var l = lab[0];
    var a = lab[1];
    var b = lab[2];
    var x;
    var y2;
    var z;
    y2 = (l + 16) / 116;
    x = a / 500 + y2;
    z = y2 - b / 200;
    var y22 = Math.pow(y2, 3);
    var x2 = Math.pow(x, 3);
    var z2 = Math.pow(z, 3);
    y2 = y22 > 8856e-6 ? y22 : (y2 - 16 / 116) / 7.787;
    x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y2 *= 100;
    z *= 108.883;
    return [x, y2, z];
  };
  convert.lab.lch = function(lab) {
    var l = lab[0];
    var a = lab[1];
    var b = lab[2];
    var hr;
    var h2;
    var c;
    hr = Math.atan2(b, a);
    h2 = hr * 360 / 2 / Math.PI;
    if (h2 < 0) {
      h2 += 360;
    }
    c = Math.sqrt(a * a + b * b);
    return [l, c, h2];
  };
  convert.lch.lab = function(lch) {
    var l = lch[0];
    var c = lch[1];
    var h2 = lch[2];
    var a;
    var b;
    var hr;
    hr = h2 / 360 * 2 * Math.PI;
    a = c * Math.cos(hr);
    b = c * Math.sin(hr);
    return [l, a, b];
  };
  convert.rgb.ansi16 = function(args2) {
    var r = args2[0];
    var g = args2[1];
    var b = args2[2];
    var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args2)[2];
    value = Math.round(value / 50);
    if (value === 0) {
      return 30;
    }
    var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value === 2) {
      ansi += 60;
    }
    return ansi;
  };
  convert.hsv.ansi16 = function(args2) {
    return convert.rgb.ansi16(convert.hsv.rgb(args2), args2[2]);
  };
  convert.rgb.ansi256 = function(args2) {
    var r = args2[0];
    var g = args2[1];
    var b = args2[2];
    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }
      if (r > 248) {
        return 231;
      }
      return Math.round((r - 8) / 247 * 24) + 232;
    }
    var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };
  convert.ansi16.rgb = function(args2) {
    var color = args2 % 10;
    if (color === 0 || color === 7) {
      if (args2 > 50) {
        color += 3.5;
      }
      color = color / 10.5 * 255;
      return [color, color, color];
    }
    var mult = (~~(args2 > 50) + 1) * 0.5;
    var r = (color & 1) * mult * 255;
    var g = (color >> 1 & 1) * mult * 255;
    var b = (color >> 2 & 1) * mult * 255;
    return [r, g, b];
  };
  convert.ansi256.rgb = function(args2) {
    if (args2 >= 232) {
      var c = (args2 - 232) * 10 + 8;
      return [c, c, c];
    }
    args2 -= 16;
    var rem;
    var r = Math.floor(args2 / 36) / 5 * 255;
    var g = Math.floor((rem = args2 % 36) / 6) / 5 * 255;
    var b = rem % 6 / 5 * 255;
    return [r, g, b];
  };
  convert.rgb.hex = function(args2) {
    var integer = ((Math.round(args2[0]) & 255) << 16) + ((Math.round(args2[1]) & 255) << 8) + (Math.round(args2[2]) & 255);
    var string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.hex.rgb = function(args2) {
    var match = args2.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match) {
      return [0, 0, 0];
    }
    var colorString = match[0];
    if (match[0].length === 3) {
      colorString = colorString.split("").map(function(char) {
        return char + char;
      }).join("");
    }
    var integer = parseInt(colorString, 16);
    var r = integer >> 16 & 255;
    var g = integer >> 8 & 255;
    var b = integer & 255;
    return [r, g, b];
  };
  convert.rgb.hcg = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var max = Math.max(Math.max(r, g), b);
    var min = Math.min(Math.min(r, g), b);
    var chroma = max - min;
    var grayscale;
    var hue;
    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max === r) {
      hue = (g - b) / chroma % 6;
    } else if (max === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma + 4;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert.hsl.hcg = function(hsl) {
    var s2 = hsl[1] / 100;
    var l = hsl[2] / 100;
    var c = 1;
    var f = 0;
    if (l < 0.5) {
      c = 2 * s2 * l;
    } else {
      c = 2 * s2 * (1 - l);
    }
    if (c < 1) {
      f = (l - 0.5 * c) / (1 - c);
    }
    return [hsl[0], c * 100, f * 100];
  };
  convert.hsv.hcg = function(hsv) {
    var s2 = hsv[1] / 100;
    var v = hsv[2] / 100;
    var c = s2 * v;
    var f = 0;
    if (c < 1) {
      f = (v - c) / (1 - c);
    }
    return [hsv[0], c * 100, f * 100];
  };
  convert.hcg.rgb = function(hcg) {
    var h2 = hcg[0] / 360;
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    if (c === 0) {
      return [g * 255, g * 255, g * 255];
    }
    var pure = [0, 0, 0];
    var hi = h2 % 1 * 6;
    var v = hi % 1;
    var w2 = 1 - v;
    var mg = 0;
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w2;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w2;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w2;
    }
    mg = (1 - c) * g;
    return [
      (c * pure[0] + mg) * 255,
      (c * pure[1] + mg) * 255,
      (c * pure[2] + mg) * 255
    ];
  };
  convert.hcg.hsv = function(hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var v = c + g * (1 - c);
    var f = 0;
    if (v > 0) {
      f = c / v;
    }
    return [hcg[0], f * 100, v * 100];
  };
  convert.hcg.hsl = function(hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var l = g * (1 - c) + 0.5 * c;
    var s2 = 0;
    if (l > 0 && l < 0.5) {
      s2 = c / (2 * l);
    } else if (l >= 0.5 && l < 1) {
      s2 = c / (2 * (1 - l));
    }
    return [hcg[0], s2 * 100, l * 100];
  };
  convert.hcg.hwb = function(hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var v = c + g * (1 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };
  convert.hwb.hcg = function(hwb) {
    var w2 = hwb[1] / 100;
    var b = hwb[2] / 100;
    var v = 1 - b;
    var c = v - w2;
    var g = 0;
    if (c < 1) {
      g = (v - c) / (1 - c);
    }
    return [hwb[0], c * 100, g * 100];
  };
  convert.apple.rgb = function(apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert.rgb.apple = function(rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert.gray.rgb = function(args2) {
    return [args2[0] / 100 * 255, args2[0] / 100 * 255, args2[0] / 100 * 255];
  };
  convert.gray.hsl = convert.gray.hsv = function(args2) {
    return [0, 0, args2[0]];
  };
  convert.gray.hwb = function(gray) {
    return [0, 100, gray[0]];
  };
  convert.gray.cmyk = function(gray) {
    return [0, 0, 0, gray[0]];
  };
  convert.gray.lab = function(gray) {
    return [gray[0], 0, 0];
  };
  convert.gray.hex = function(gray) {
    var val = Math.round(gray[0] / 100 * 255) & 255;
    var integer = (val << 16) + (val << 8) + val;
    var string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.rgb.gray = function(rgb) {
    var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
});

// ../../node_modules/.pnpm/color-convert@1.9.3/node_modules/color-convert/route.js
var require_route2 = __commonJS((exports2, module2) => {
  var conversions = require_conversions2();
  function buildGraph() {
    var graph = {};
    var models = Object.keys(conversions);
    for (var len = models.length, i = 0; i < len; i++) {
      graph[models[i]] = {
        distance: -1,
        parent: null
      };
    }
    return graph;
  }
  function deriveBFS(fromModel) {
    var graph = buildGraph();
    var queue = [fromModel];
    graph[fromModel].distance = 0;
    while (queue.length) {
      var current = queue.pop();
      var adjacents = Object.keys(conversions[current]);
      for (var len = adjacents.length, i = 0; i < len; i++) {
        var adjacent = adjacents[i];
        var node = graph[adjacent];
        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  }
  function link5(from, to) {
    return function(args2) {
      return to(from(args2));
    };
  }
  function wrapConversion(toModel, graph) {
    var path10 = [graph[toModel].parent, toModel];
    var fn = conversions[graph[toModel].parent][toModel];
    var cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path10.unshift(graph[cur].parent);
      fn = link5(conversions[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path10;
    return fn;
  }
  module2.exports = function(fromModel) {
    var graph = deriveBFS(fromModel);
    var conversion = {};
    var models = Object.keys(graph);
    for (var len = models.length, i = 0; i < len; i++) {
      var toModel = models[i];
      var node = graph[toModel];
      if (node.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  };
});

// ../../node_modules/.pnpm/color-convert@1.9.3/node_modules/color-convert/index.js
var require_color_convert2 = __commonJS((exports2, module2) => {
  var conversions = require_conversions2();
  var route = require_route2();
  var convert = {};
  var models = Object.keys(conversions);
  function wrapRaw(fn) {
    var wrappedFn = function(args2) {
      if (args2 === void 0 || args2 === null) {
        return args2;
      }
      if (arguments.length > 1) {
        args2 = Array.prototype.slice.call(arguments);
      }
      return fn(args2);
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  function wrapRounded(fn) {
    var wrappedFn = function(args2) {
      if (args2 === void 0 || args2 === null) {
        return args2;
      }
      if (arguments.length > 1) {
        args2 = Array.prototype.slice.call(arguments);
      }
      var result = fn(args2);
      if (typeof result === "object") {
        for (var len = result.length, i = 0; i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }
      return result;
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  models.forEach(function(fromModel) {
    convert[fromModel] = {};
    Object.defineProperty(convert[fromModel], "channels", {value: conversions[fromModel].channels});
    Object.defineProperty(convert[fromModel], "labels", {value: conversions[fromModel].labels});
    var routes = route(fromModel);
    var routeModels = Object.keys(routes);
    routeModels.forEach(function(toModel) {
      var fn = routes[toModel];
      convert[fromModel][toModel] = wrapRounded(fn);
      convert[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  module2.exports = convert;
});

// ../../node_modules/.pnpm/ansi-styles@3.2.1/node_modules/ansi-styles/index.js
var require_ansi_styles2 = __commonJS((exports2, module2) => {
  "use strict";
  var colorConvert = require_color_convert2();
  var wrapAnsi16 = (fn, offset) => function() {
    const code = fn.apply(colorConvert, arguments);
    return `[${code + offset}m`;
  };
  var wrapAnsi256 = (fn, offset) => function() {
    const code = fn.apply(colorConvert, arguments);
    return `[${38 + offset};5;${code}m`;
  };
  var wrapAnsi16m = (fn, offset) => function() {
    const rgb = fn.apply(colorConvert, arguments);
    return `[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
  };
  function assembleStyles() {
    const codes = new Map();
    const styles = {
      modifier: {
        reset: [0, 0],
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        gray: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    styles.color.grey = styles.color.gray;
    for (const groupName of Object.keys(styles)) {
      const group = styles[groupName];
      for (const styleName of Object.keys(group)) {
        const style = group[styleName];
        styles[styleName] = {
          open: `[${style[0]}m`,
          close: `[${style[1]}m`
        };
        group[styleName] = styles[styleName];
        codes.set(style[0], style[1]);
      }
      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false
      });
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
    }
    const ansi2ansi = (n) => n;
    const rgb2rgb = (r, g, b) => [r, g, b];
    styles.color.close = "[39m";
    styles.bgColor.close = "[49m";
    styles.color.ansi = {
      ansi: wrapAnsi16(ansi2ansi, 0)
    };
    styles.color.ansi256 = {
      ansi256: wrapAnsi256(ansi2ansi, 0)
    };
    styles.color.ansi16m = {
      rgb: wrapAnsi16m(rgb2rgb, 0)
    };
    styles.bgColor.ansi = {
      ansi: wrapAnsi16(ansi2ansi, 10)
    };
    styles.bgColor.ansi256 = {
      ansi256: wrapAnsi256(ansi2ansi, 10)
    };
    styles.bgColor.ansi16m = {
      rgb: wrapAnsi16m(rgb2rgb, 10)
    };
    for (let key of Object.keys(colorConvert)) {
      if (typeof colorConvert[key] !== "object") {
        continue;
      }
      const suite = colorConvert[key];
      if (key === "ansi16") {
        key = "ansi";
      }
      if ("ansi16" in suite) {
        styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
        styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
      }
      if ("ansi256" in suite) {
        styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
        styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
      }
      if ("rgb" in suite) {
        styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
        styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
      }
    }
    return styles;
  }
  Object.defineProperty(module2, "exports", {
    enumerable: true,
    get: assembleStyles
  });
});

// ../../node_modules/.pnpm/has-flag@3.0.0/node_modules/has-flag/index.js
var require_has_flag2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (flag, argv) => {
    argv = argv || process.argv;
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const pos = argv.indexOf(prefix + flag);
    const terminatorPos = argv.indexOf("--");
    return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
  };
});

// ../../node_modules/.pnpm/supports-color@5.5.0/node_modules/supports-color/index.js
var require_supports_color2 = __commonJS((exports2, module2) => {
  "use strict";
  var os3 = require("os");
  var hasFlag = require_has_flag2();
  var env2 = process.env;
  var forceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
    forceColor = false;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = true;
  }
  if ("FORCE_COLOR" in env2) {
    forceColor = env2.FORCE_COLOR.length === 0 || parseInt(env2.FORCE_COLOR, 10) !== 0;
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(stream) {
    if (forceColor === false) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (stream && !stream.isTTY && forceColor !== true) {
      return 0;
    }
    const min = forceColor ? 1 : 0;
    if (process.platform === "win32") {
      const osRelease = os3.release().split(".");
      if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env2) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env2) || env2.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env2) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env2.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env2) {
      const version = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env2.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env2.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env2) {
      return 1;
    }
    if (env2.TERM === "dumb") {
      return min;
    }
    return min;
  }
  function getSupportLevel(stream) {
    const level = supportsColor(stream);
    return translateLevel(level);
  }
  module2.exports = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel(process.stdout),
    stderr: getSupportLevel(process.stderr)
  };
});

// ../../node_modules/.pnpm/chalk@2.4.2/node_modules/chalk/templates.js
var require_templates2 = __commonJS((exports2, module2) => {
  "use strict";
  var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
  var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
  var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
  var ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
  var ESCAPES = new Map([
    ["n", "\n"],
    ["r", "\r"],
    ["t", "	"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", ""],
    ["a", "\x07"]
  ]);
  function unescape2(c) {
    if (c[0] === "u" && c.length === 5 || c[0] === "x" && c.length === 3) {
      return String.fromCharCode(parseInt(c.slice(1), 16));
    }
    return ESCAPES.get(c) || c;
  }
  function parseArguments(name, args2) {
    const results = [];
    const chunks = args2.trim().split(/\s*,\s*/g);
    let matches;
    for (const chunk of chunks) {
      if (!isNaN(chunk)) {
        results.push(Number(chunk));
      } else if (matches = chunk.match(STRING_REGEX)) {
        results.push(matches[2].replace(ESCAPE_REGEX, (m2, escape2, chr) => escape2 ? unescape2(escape2) : chr));
      } else {
        throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
      }
    }
    return results;
  }
  function parseStyle(style) {
    STYLE_REGEX.lastIndex = 0;
    const results = [];
    let matches;
    while ((matches = STYLE_REGEX.exec(style)) !== null) {
      const name = matches[1];
      if (matches[2]) {
        const args2 = parseArguments(name, matches[2]);
        results.push([name].concat(args2));
      } else {
        results.push([name]);
      }
    }
    return results;
  }
  function buildStyle(chalk14, styles) {
    const enabled = {};
    for (const layer of styles) {
      for (const style of layer.styles) {
        enabled[style[0]] = layer.inverse ? null : style.slice(1);
      }
    }
    let current = chalk14;
    for (const styleName of Object.keys(enabled)) {
      if (Array.isArray(enabled[styleName])) {
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        if (enabled[styleName].length > 0) {
          current = current[styleName].apply(current, enabled[styleName]);
        } else {
          current = current[styleName];
        }
      }
    }
    return current;
  }
  module2.exports = (chalk14, tmp) => {
    const styles = [];
    const chunks = [];
    let chunk = [];
    tmp.replace(TEMPLATE_REGEX, (m2, escapeChar, inverse, style, close2, chr) => {
      if (escapeChar) {
        chunk.push(unescape2(escapeChar));
      } else if (style) {
        const str = chunk.join("");
        chunk = [];
        chunks.push(styles.length === 0 ? str : buildStyle(chalk14, styles)(str));
        styles.push({inverse, styles: parseStyle(style)});
      } else if (close2) {
        if (styles.length === 0) {
          throw new Error("Found extraneous } in Chalk template literal");
        }
        chunks.push(buildStyle(chalk14, styles)(chunk.join("")));
        chunk = [];
        styles.pop();
      } else {
        chunk.push(chr);
      }
    });
    chunks.push(chunk.join(""));
    if (styles.length > 0) {
      const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(errMsg);
    }
    return chunks.join("");
  };
});

// ../../node_modules/.pnpm/chalk@2.4.2/node_modules/chalk/index.js
var require_chalk = __commonJS((exports2, module2) => {
  "use strict";
  var escapeStringRegexp = require_escape_string_regexp();
  var ansiStyles = require_ansi_styles2();
  var stdoutColor = require_supports_color2().stdout;
  var template = require_templates2();
  var isSimpleWindowsTerm = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm");
  var levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];
  var skipModels = new Set(["gray"]);
  var styles = Object.create(null);
  function applyOptions(obj, options) {
    options = options || {};
    const scLevel = stdoutColor ? stdoutColor.level : 0;
    obj.level = options.level === void 0 ? scLevel : options.level;
    obj.enabled = "enabled" in options ? options.enabled : obj.level > 0;
  }
  function Chalk(options) {
    if (!this || !(this instanceof Chalk) || this.template) {
      const chalk14 = {};
      applyOptions(chalk14, options);
      chalk14.template = function() {
        const args2 = [].slice.call(arguments);
        return chalkTag.apply(null, [chalk14.template].concat(args2));
      };
      Object.setPrototypeOf(chalk14, Chalk.prototype);
      Object.setPrototypeOf(chalk14.template, chalk14);
      chalk14.template.constructor = Chalk;
      return chalk14.template;
    }
    applyOptions(this, options);
  }
  if (isSimpleWindowsTerm) {
    ansiStyles.blue.open = "[94m";
  }
  for (const key of Object.keys(ansiStyles)) {
    ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
    styles[key] = {
      get() {
        const codes = ansiStyles[key];
        return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
      }
    };
  }
  styles.visible = {
    get() {
      return build.call(this, this._styles || [], true, "visible");
    }
  };
  ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), "g");
  for (const model of Object.keys(ansiStyles.color.ansi)) {
    if (skipModels.has(model)) {
      continue;
    }
    styles[model] = {
      get() {
        const level = this.level;
        return function() {
          const open3 = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
          const codes = {
            open: open3,
            close: ansiStyles.color.close,
            closeRe: ansiStyles.color.closeRe
          };
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
        };
      }
    };
  }
  ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), "g");
  for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
    if (skipModels.has(model)) {
      continue;
    }
    const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
    styles[bgModel] = {
      get() {
        const level = this.level;
        return function() {
          const open3 = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
          const codes = {
            open: open3,
            close: ansiStyles.bgColor.close,
            closeRe: ansiStyles.bgColor.closeRe
          };
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
        };
      }
    };
  }
  var proto = Object.defineProperties(() => {
  }, styles);
  function build(_styles, _empty, key) {
    const builder = function() {
      return applyStyle.apply(builder, arguments);
    };
    builder._styles = _styles;
    builder._empty = _empty;
    const self2 = this;
    Object.defineProperty(builder, "level", {
      enumerable: true,
      get() {
        return self2.level;
      },
      set(level) {
        self2.level = level;
      }
    });
    Object.defineProperty(builder, "enabled", {
      enumerable: true,
      get() {
        return self2.enabled;
      },
      set(enabled) {
        self2.enabled = enabled;
      }
    });
    builder.hasGrey = this.hasGrey || key === "gray" || key === "grey";
    builder.__proto__ = proto;
    return builder;
  }
  function applyStyle() {
    const args2 = arguments;
    const argsLen = args2.length;
    let str = String(arguments[0]);
    if (argsLen === 0) {
      return "";
    }
    if (argsLen > 1) {
      for (let a = 1; a < argsLen; a++) {
        str += " " + args2[a];
      }
    }
    if (!this.enabled || this.level <= 0 || !str) {
      return this._empty ? "" : str;
    }
    const originalDim = ansiStyles.dim.open;
    if (isSimpleWindowsTerm && this.hasGrey) {
      ansiStyles.dim.open = "";
    }
    for (const code of this._styles.slice().reverse()) {
      str = code.open + str.replace(code.closeRe, code.open) + code.close;
      str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
    }
    ansiStyles.dim.open = originalDim;
    return str;
  }
  function chalkTag(chalk14, strings) {
    if (!Array.isArray(strings)) {
      return [].slice.call(arguments, 1).join(" ");
    }
    const args2 = [].slice.call(arguments, 2);
    const parts = [strings.raw[0]];
    for (let i = 1; i < strings.length; i++) {
      parts.push(String(args2[i - 1]).replace(/[{}\\]/g, "\\$&"));
      parts.push(String(strings.raw[i]));
    }
    return template(chalk14, parts.join(""));
  }
  Object.defineProperties(Chalk.prototype, styles);
  module2.exports = Chalk();
  module2.exports.supportsColor = stdoutColor;
  module2.exports.default = module2.exports;
});

// ../../node_modules/.pnpm/@babel+highlight@7.14.5/node_modules/@babel/highlight/lib/index.js
var require_lib2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.shouldHighlight = shouldHighlight;
  exports2.getChalk = getChalk;
  exports2.default = highlight;
  var _jsTokens = require_js_tokens();
  var _helperValidatorIdentifier = require_lib();
  var _chalk = require_chalk();
  var sometimesKeywords = new Set(["as", "async", "from", "get", "of", "set"]);
  function getDefs(chalk14) {
    return {
      keyword: chalk14.cyan,
      capitalized: chalk14.yellow,
      jsxIdentifier: chalk14.yellow,
      punctuator: chalk14.yellow,
      number: chalk14.magenta,
      string: chalk14.green,
      regex: chalk14.magenta,
      comment: chalk14.grey,
      invalid: chalk14.white.bgRed.bold
    };
  }
  var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
  var BRACKET = /^[()[\]{}]$/;
  var tokenize;
  {
    const JSX_TAG = /^[a-z][\w-]*$/i;
    const getTokenType = function(token, offset, text) {
      if (token.type === "name") {
        if ((0, _helperValidatorIdentifier.isKeyword)(token.value) || (0, _helperValidatorIdentifier.isStrictReservedWord)(token.value, true) || sometimesKeywords.has(token.value)) {
          return "keyword";
        }
        if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.substr(offset - 2, 2) == "</")) {
          return "jsxIdentifier";
        }
        if (token.value[0] !== token.value[0].toLowerCase()) {
          return "capitalized";
        }
      }
      if (token.type === "punctuator" && BRACKET.test(token.value)) {
        return "bracket";
      }
      if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
        return "punctuator";
      }
      return token.type;
    };
    tokenize = function* (text) {
      let match;
      while (match = _jsTokens.default.exec(text)) {
        const token = _jsTokens.matchToToken(match);
        yield {
          type: getTokenType(token, match.index, text),
          value: token.value
        };
      }
    };
  }
  function highlightTokens(defs, text) {
    let highlighted = "";
    for (const {
      type,
      value
    } of tokenize(text)) {
      const colorize = defs[type];
      if (colorize) {
        highlighted += value.split(NEWLINE).map((str) => colorize(str)).join("\n");
      } else {
        highlighted += value;
      }
    }
    return highlighted;
  }
  function shouldHighlight(options) {
    return !!_chalk.supportsColor || options.forceColor;
  }
  function getChalk(options) {
    return options.forceColor ? new _chalk.constructor({
      enabled: true,
      level: 1
    }) : _chalk;
  }
  function highlight(code, options = {}) {
    if (shouldHighlight(options)) {
      const chalk14 = getChalk(options);
      const defs = getDefs(chalk14);
      return highlightTokens(defs, code);
    } else {
      return code;
    }
  }
});

// ../../node_modules/.pnpm/@babel+code-frame@7.14.5/node_modules/@babel/code-frame/lib/index.js
var require_lib3 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.codeFrameColumns = codeFrameColumns;
  exports2.default = _default2;
  var _highlight = require_lib2();
  var deprecationWarningShown = false;
  function getDefs(chalk14) {
    return {
      gutter: chalk14.grey,
      marker: chalk14.red.bold,
      message: chalk14.red.bold
    };
  }
  var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
  function getMarkerLines(loc, source, opts) {
    const startLoc = Object.assign({
      column: 0,
      line: -1
    }, loc.start);
    const endLoc = Object.assign({}, startLoc, loc.end);
    const {
      linesAbove = 2,
      linesBelow = 3
    } = opts || {};
    const startLine = startLoc.line;
    const startColumn = startLoc.column;
    const endLine = endLoc.line;
    const endColumn = endLoc.column;
    let start = Math.max(startLine - (linesAbove + 1), 0);
    let end = Math.min(source.length, endLine + linesBelow);
    if (startLine === -1) {
      start = 0;
    }
    if (endLine === -1) {
      end = source.length;
    }
    const lineDiff = endLine - startLine;
    const markerLines = {};
    if (lineDiff) {
      for (let i = 0; i <= lineDiff; i++) {
        const lineNumber = i + startLine;
        if (!startColumn) {
          markerLines[lineNumber] = true;
        } else if (i === 0) {
          const sourceLength = source[lineNumber - 1].length;
          markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
        } else if (i === lineDiff) {
          markerLines[lineNumber] = [0, endColumn];
        } else {
          const sourceLength = source[lineNumber - i].length;
          markerLines[lineNumber] = [0, sourceLength];
        }
      }
    } else {
      if (startColumn === endColumn) {
        if (startColumn) {
          markerLines[startLine] = [startColumn, 0];
        } else {
          markerLines[startLine] = true;
        }
      } else {
        markerLines[startLine] = [startColumn, endColumn - startColumn];
      }
    }
    return {
      start,
      end,
      markerLines
    };
  }
  function codeFrameColumns(rawLines, loc, opts = {}) {
    const highlighted = (opts.highlightCode || opts.forceColor) && (0, _highlight.shouldHighlight)(opts);
    const chalk14 = (0, _highlight.getChalk)(opts);
    const defs = getDefs(chalk14);
    const maybeHighlight = (chalkFn, string) => {
      return highlighted ? chalkFn(string) : string;
    };
    const lines = rawLines.split(NEWLINE);
    const {
      start,
      end,
      markerLines
    } = getMarkerLines(loc, lines, opts);
    const hasColumns = loc.start && typeof loc.start.column === "number";
    const numberMaxWidth = String(end).length;
    const highlightedLines = highlighted ? (0, _highlight.default)(rawLines, opts) : rawLines;
    let frame = highlightedLines.split(NEWLINE).slice(start, end).map((line, index) => {
      const number = start + 1 + index;
      const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
      const gutter = ` ${paddedNumber} |`;
      const hasMarker = markerLines[number];
      const lastMarkerLine = !markerLines[number + 1];
      if (hasMarker) {
        let markerLine = "";
        if (Array.isArray(hasMarker)) {
          const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
          const numberOfMarkers = hasMarker[1] || 1;
          markerLine = ["\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), " ", markerSpacing, maybeHighlight(defs.marker, "^").repeat(numberOfMarkers)].join("");
          if (lastMarkerLine && opts.message) {
            markerLine += " " + maybeHighlight(defs.message, opts.message);
          }
        }
        return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line.length > 0 ? ` ${line}` : "", markerLine].join("");
      } else {
        return ` ${maybeHighlight(defs.gutter, gutter)}${line.length > 0 ? ` ${line}` : ""}`;
      }
    }).join("\n");
    if (opts.message && !hasColumns) {
      frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}
${frame}`;
    }
    if (highlighted) {
      return chalk14.reset(frame);
    } else {
      return frame;
    }
  }
  function _default2(rawLines, lineNumber, colNumber, opts = {}) {
    if (!deprecationWarningShown) {
      deprecationWarningShown = true;
      const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      if (process.emitWarning) {
        process.emitWarning(message, "DeprecationWarning");
      } else {
        const deprecationError = new Error(message);
        deprecationError.name = "DeprecationWarning";
        console.warn(new Error(message));
      }
    }
    colNumber = Math.max(colNumber, 0);
    const location = {
      start: {
        column: colNumber,
        line: lineNumber
      }
    };
    return codeFrameColumns(rawLines, location, opts);
  }
});

// ../../node_modules/.pnpm/parse-json@5.2.0/node_modules/parse-json/index.js
var require_parse_json = __commonJS((exports2, module2) => {
  "use strict";
  var errorEx = require_error_ex();
  var fallback = require_json_parse_even_better_errors();
  var {default: LinesAndColumns} = require_dist();
  var {codeFrameColumns} = require_lib3();
  var JSONError = errorEx("JSONError", {
    fileName: errorEx.append("in %s"),
    codeFrame: errorEx.append("\n\n%s\n")
  });
  var parseJson = (string, reviver, filename) => {
    if (typeof reviver === "string") {
      filename = reviver;
      reviver = null;
    }
    try {
      try {
        return JSON.parse(string, reviver);
      } catch (error) {
        fallback(string, reviver);
        throw error;
      }
    } catch (error) {
      error.message = error.message.replace(/\n/g, "");
      const indexMatch = error.message.match(/in JSON at position (\d+) while parsing/);
      const jsonError = new JSONError(error);
      if (filename) {
        jsonError.fileName = filename;
      }
      if (indexMatch && indexMatch.length > 0) {
        const lines = new LinesAndColumns(string);
        const index = Number(indexMatch[1]);
        const location = lines.locationForIndex(index);
        const codeFrame = codeFrameColumns(string, {start: {line: location.line + 1, column: location.column + 1}}, {highlightCode: true});
        jsonError.codeFrame = codeFrame;
      }
      throw jsonError;
    }
  };
  parseJson.JSONError = JSONError;
  module2.exports = parseJson;
});

// ../../node_modules/.pnpm/semver@5.7.1/node_modules/semver/semver.js
var require_semver = __commonJS((exports2, module2) => {
  exports2 = module2.exports = SemVer;
  var debug3;
  if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
    debug3 = function() {
      var args2 = Array.prototype.slice.call(arguments, 0);
      args2.unshift("SEMVER");
      console.log.apply(console, args2);
    };
  } else {
    debug3 = function() {
    };
  }
  exports2.SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var re = exports2.re = [];
  var src = exports2.src = [];
  var R = 0;
  var NUMERICIDENTIFIER = R++;
  src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
  var NUMERICIDENTIFIERLOOSE = R++;
  src[NUMERICIDENTIFIERLOOSE] = "[0-9]+";
  var NONNUMERICIDENTIFIER = R++;
  src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
  var MAINVERSION = R++;
  src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
  var MAINVERSIONLOOSE = R++;
  src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
  var PRERELEASEIDENTIFIER = R++;
  src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
  var PRERELEASEIDENTIFIERLOOSE = R++;
  src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
  var PRERELEASE = R++;
  src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
  var PRERELEASELOOSE = R++;
  src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
  var BUILDIDENTIFIER = R++;
  src[BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
  var BUILD = R++;
  src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
  var FULL = R++;
  var FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
  src[FULL] = "^" + FULLPLAIN + "$";
  var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?";
  var LOOSE = R++;
  src[LOOSE] = "^" + LOOSEPLAIN + "$";
  var GTLT = R++;
  src[GTLT] = "((?:<|>)?=?)";
  var XRANGEIDENTIFIERLOOSE = R++;
  src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
  var XRANGEIDENTIFIER = R++;
  src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
  var XRANGEPLAIN = R++;
  src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
  var XRANGEPLAINLOOSE = R++;
  src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
  var XRANGE = R++;
  src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
  var XRANGELOOSE = R++;
  src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
  var COERCE = R++;
  src[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
  var LONETILDE = R++;
  src[LONETILDE] = "(?:~>?)";
  var TILDETRIM = R++;
  src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
  re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
  var tildeTrimReplace = "$1~";
  var TILDE = R++;
  src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
  var TILDELOOSE = R++;
  src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
  var LONECARET = R++;
  src[LONECARET] = "(?:\\^)";
  var CARETTRIM = R++;
  src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
  re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
  var caretTrimReplace = "$1^";
  var CARET = R++;
  src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
  var CARETLOOSE = R++;
  src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
  var COMPARATORLOOSE = R++;
  src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
  var COMPARATOR = R++;
  src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
  var COMPARATORTRIM = R++;
  src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")";
  re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
  var comparatorTrimReplace = "$1$2$3";
  var HYPHENRANGE = R++;
  src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
  var HYPHENRANGELOOSE = R++;
  src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
  var STAR = R++;
  src[STAR] = "(<|>)?=?\\s*\\*";
  for (var i = 0; i < R; i++) {
    debug3(i, src[i]);
    if (!re[i]) {
      re[i] = new RegExp(src[i]);
    }
  }
  exports2.parse = parse2;
  function parse2(version, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version !== "string") {
      return null;
    }
    if (version.length > MAX_LENGTH) {
      return null;
    }
    var r = options.loose ? re[LOOSE] : re[FULL];
    if (!r.test(version)) {
      return null;
    }
    try {
      return new SemVer(version, options);
    } catch (er) {
      return null;
    }
  }
  exports2.valid = valid;
  function valid(version, options) {
    var v = parse2(version, options);
    return v ? v.version : null;
  }
  exports2.clean = clean;
  function clean(version, options) {
    var s2 = parse2(version.trim().replace(/^[=v]+/, ""), options);
    return s2 ? s2.version : null;
  }
  exports2.SemVer = SemVer;
  function SemVer(version, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      if (version.loose === options.loose) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== "string") {
      throw new TypeError("Invalid Version: " + version);
    }
    if (version.length > MAX_LENGTH) {
      throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
    }
    if (!(this instanceof SemVer)) {
      return new SemVer(version, options);
    }
    debug3("SemVer", version, options);
    this.options = options;
    this.loose = !!options.loose;
    var m2 = version.trim().match(options.loose ? re[LOOSE] : re[FULL]);
    if (!m2) {
      throw new TypeError("Invalid Version: " + version);
    }
    this.raw = version;
    this.major = +m2[1];
    this.minor = +m2[2];
    this.patch = +m2[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m2[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m2[4].split(".").map(function(id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id;
      });
    }
    this.build = m2[5] ? m2[5].split(".") : [];
    this.format();
  }
  SemVer.prototype.format = function() {
    this.version = this.major + "." + this.minor + "." + this.patch;
    if (this.prerelease.length) {
      this.version += "-" + this.prerelease.join(".");
    }
    return this.version;
  };
  SemVer.prototype.toString = function() {
    return this.version;
  };
  SemVer.prototype.compare = function(other) {
    debug3("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return this.compareMain(other) || this.comparePre(other);
  };
  SemVer.prototype.compareMain = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  };
  SemVer.prototype.comparePre = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    var i2 = 0;
    do {
      var a = this.prerelease[i2];
      var b = other.prerelease[i2];
      debug3("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  };
  SemVer.prototype.inc = function(release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier);
        this.inc("pre", identifier);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier);
        }
        this.inc("pre", identifier);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          var i2 = this.prerelease.length;
          while (--i2 >= 0) {
            if (typeof this.prerelease[i2] === "number") {
              this.prerelease[i2]++;
              i2 = -2;
            }
          }
          if (i2 === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error("invalid increment argument: " + release);
    }
    this.format();
    this.raw = this.version;
    return this;
  };
  exports2.inc = inc;
  function inc(version, release, loose, identifier) {
    if (typeof loose === "string") {
      identifier = loose;
      loose = void 0;
    }
    try {
      return new SemVer(version, loose).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  }
  exports2.diff = diff;
  function diff(version1, version2) {
    if (eq(version1, version2)) {
      return null;
    } else {
      var v1 = parse2(version1);
      var v2 = parse2(version2);
      var prefix = "";
      if (v1.prerelease.length || v2.prerelease.length) {
        prefix = "pre";
        var defaultResult = "prerelease";
      }
      for (var key in v1) {
        if (key === "major" || key === "minor" || key === "patch") {
          if (v1[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }
      return defaultResult;
    }
  }
  exports2.compareIdentifiers = compareIdentifiers;
  var numeric = /^[0-9]+$/;
  function compareIdentifiers(a, b) {
    var anum = numeric.test(a);
    var bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  }
  exports2.rcompareIdentifiers = rcompareIdentifiers;
  function rcompareIdentifiers(a, b) {
    return compareIdentifiers(b, a);
  }
  exports2.major = major;
  function major(a, loose) {
    return new SemVer(a, loose).major;
  }
  exports2.minor = minor;
  function minor(a, loose) {
    return new SemVer(a, loose).minor;
  }
  exports2.patch = patch;
  function patch(a, loose) {
    return new SemVer(a, loose).patch;
  }
  exports2.compare = compare;
  function compare(a, b, loose) {
    return new SemVer(a, loose).compare(new SemVer(b, loose));
  }
  exports2.compareLoose = compareLoose;
  function compareLoose(a, b) {
    return compare(a, b, true);
  }
  exports2.rcompare = rcompare;
  function rcompare(a, b, loose) {
    return compare(b, a, loose);
  }
  exports2.sort = sort;
  function sort(list, loose) {
    return list.sort(function(a, b) {
      return exports2.compare(a, b, loose);
    });
  }
  exports2.rsort = rsort;
  function rsort(list, loose) {
    return list.sort(function(a, b) {
      return exports2.rcompare(a, b, loose);
    });
  }
  exports2.gt = gt;
  function gt(a, b, loose) {
    return compare(a, b, loose) > 0;
  }
  exports2.lt = lt;
  function lt(a, b, loose) {
    return compare(a, b, loose) < 0;
  }
  exports2.eq = eq;
  function eq(a, b, loose) {
    return compare(a, b, loose) === 0;
  }
  exports2.neq = neq;
  function neq(a, b, loose) {
    return compare(a, b, loose) !== 0;
  }
  exports2.gte = gte;
  function gte(a, b, loose) {
    return compare(a, b, loose) >= 0;
  }
  exports2.lte = lte;
  function lte(a, b, loose) {
    return compare(a, b, loose) <= 0;
  }
  exports2.cmp = cmp;
  function cmp(a, op, b, loose) {
    switch (op) {
      case "===":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a === b;
      case "!==":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError("Invalid operator: " + op);
    }
  }
  exports2.Comparator = Comparator;
  function Comparator(comp, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }
    if (!(this instanceof Comparator)) {
      return new Comparator(comp, options);
    }
    debug3("comparator", comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);
    if (this.semver === ANY) {
      this.value = "";
    } else {
      this.value = this.operator + this.semver.version;
    }
    debug3("comp", this);
  }
  var ANY = {};
  Comparator.prototype.parse = function(comp) {
    var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
    var m2 = comp.match(r);
    if (!m2) {
      throw new TypeError("Invalid comparator: " + comp);
    }
    this.operator = m2[1];
    if (this.operator === "=") {
      this.operator = "";
    }
    if (!m2[2]) {
      this.semver = ANY;
    } else {
      this.semver = new SemVer(m2[2], this.options.loose);
    }
  };
  Comparator.prototype.toString = function() {
    return this.value;
  };
  Comparator.prototype.test = function(version) {
    debug3("Comparator.test", version, this.options.loose);
    if (this.semver === ANY) {
      return true;
    }
    if (typeof version === "string") {
      version = new SemVer(version, this.options);
    }
    return cmp(version, this.operator, this.semver, this.options);
  };
  Comparator.prototype.intersects = function(comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError("a Comparator is required");
    }
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    var rangeTmp;
    if (this.operator === "") {
      rangeTmp = new Range(comp.value, options);
      return satisfies(this.value, rangeTmp, options);
    } else if (comp.operator === "") {
      rangeTmp = new Range(this.value, options);
      return satisfies(comp.semver, rangeTmp, options);
    }
    var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
    var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
    var sameSemVer = this.semver.version === comp.semver.version;
    var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
    var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
    var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  };
  exports2.Range = Range;
  function Range(range, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (range instanceof Range) {
      if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
        return range;
      } else {
        return new Range(range.raw, options);
      }
    }
    if (range instanceof Comparator) {
      return new Range(range.value, options);
    }
    if (!(this instanceof Range)) {
      return new Range(range, options);
    }
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    this.raw = range;
    this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
      return this.parseRange(range2.trim());
    }, this).filter(function(c) {
      return c.length;
    });
    if (!this.set.length) {
      throw new TypeError("Invalid SemVer Range: " + range);
    }
    this.format();
  }
  Range.prototype.format = function() {
    this.range = this.set.map(function(comps) {
      return comps.join(" ").trim();
    }).join("||").trim();
    return this.range;
  };
  Range.prototype.toString = function() {
    return this.range;
  };
  Range.prototype.parseRange = function(range) {
    var loose = this.options.loose;
    range = range.trim();
    var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
    range = range.replace(hr, hyphenReplace);
    debug3("hyphen replace", range);
    range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
    debug3("comparator trim", range, re[COMPARATORTRIM]);
    range = range.replace(re[TILDETRIM], tildeTrimReplace);
    range = range.replace(re[CARETTRIM], caretTrimReplace);
    range = range.split(/\s+/).join(" ");
    var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
    var set = range.split(" ").map(function(comp) {
      return parseComparator(comp, this.options);
    }, this).join(" ").split(/\s+/);
    if (this.options.loose) {
      set = set.filter(function(comp) {
        return !!comp.match(compRe);
      });
    }
    set = set.map(function(comp) {
      return new Comparator(comp, this.options);
    }, this);
    return set;
  };
  Range.prototype.intersects = function(range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError("a Range is required");
    }
    return this.set.some(function(thisComparators) {
      return thisComparators.every(function(thisComparator) {
        return range.set.some(function(rangeComparators) {
          return rangeComparators.every(function(rangeComparator) {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  };
  exports2.toComparators = toComparators;
  function toComparators(range, options) {
    return new Range(range, options).set.map(function(comp) {
      return comp.map(function(c) {
        return c.value;
      }).join(" ").trim().split(" ");
    });
  }
  function parseComparator(comp, options) {
    debug3("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug3("caret", comp);
    comp = replaceTildes(comp, options);
    debug3("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug3("xrange", comp);
    comp = replaceStars(comp, options);
    debug3("stars", comp);
    return comp;
  }
  function isX(id) {
    return !id || id.toLowerCase() === "x" || id === "*";
  }
  function replaceTildes(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceTilde(comp2, options);
    }).join(" ");
  }
  function replaceTilde(comp, options) {
    var r = options.loose ? re[TILDELOOSE] : re[TILDE];
    return comp.replace(r, function(_2, M, m2, p, pr) {
      debug3("tilde", comp, _2, M, m2, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m2)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        ret = ">=" + M + "." + m2 + ".0 <" + M + "." + (+m2 + 1) + ".0";
      } else if (pr) {
        debug3("replaceTilde pr", pr);
        ret = ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + M + "." + (+m2 + 1) + ".0";
      } else {
        ret = ">=" + M + "." + m2 + "." + p + " <" + M + "." + (+m2 + 1) + ".0";
      }
      debug3("tilde return", ret);
      return ret;
    });
  }
  function replaceCarets(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceCaret(comp2, options);
    }).join(" ");
  }
  function replaceCaret(comp, options) {
    debug3("caret", comp, options);
    var r = options.loose ? re[CARETLOOSE] : re[CARET];
    return comp.replace(r, function(_2, M, m2, p, pr) {
      debug3("caret", comp, _2, M, m2, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m2)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        if (M === "0") {
          ret = ">=" + M + "." + m2 + ".0 <" + M + "." + (+m2 + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m2 + ".0 <" + (+M + 1) + ".0.0";
        }
      } else if (pr) {
        debug3("replaceCaret pr", pr);
        if (M === "0") {
          if (m2 === "0") {
            ret = ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + M + "." + m2 + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + M + "." + (+m2 + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
        }
      } else {
        debug3("no pr");
        if (M === "0") {
          if (m2 === "0") {
            ret = ">=" + M + "." + m2 + "." + p + " <" + M + "." + m2 + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m2 + "." + p + " <" + M + "." + (+m2 + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m2 + "." + p + " <" + (+M + 1) + ".0.0";
        }
      }
      debug3("caret return", ret);
      return ret;
    });
  }
  function replaceXRanges(comp, options) {
    debug3("replaceXRanges", comp, options);
    return comp.split(/\s+/).map(function(comp2) {
      return replaceXRange(comp2, options);
    }).join(" ");
  }
  function replaceXRange(comp, options) {
    comp = comp.trim();
    var r = options.loose ? re[XRANGELOOSE] : re[XRANGE];
    return comp.replace(r, function(ret, gtlt, M, m2, p, pr) {
      debug3("xRange", comp, ret, gtlt, M, m2, p, pr);
      var xM = isX(M);
      var xm = xM || isX(m2);
      var xp = xm || isX(p);
      var anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m2 = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m2 = 0;
            p = 0;
          } else {
            m2 = +m2 + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m2 = +m2 + 1;
          }
        }
        ret = gtlt + M + "." + m2 + "." + p;
      } else if (xm) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (xp) {
        ret = ">=" + M + "." + m2 + ".0 <" + M + "." + (+m2 + 1) + ".0";
      }
      debug3("xRange return", ret);
      return ret;
    });
  }
  function replaceStars(comp, options) {
    debug3("replaceStars", comp, options);
    return comp.trim().replace(re[STAR], "");
  }
  function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = ">=" + fM + ".0.0";
    } else if (isX(fp)) {
      from = ">=" + fM + "." + fm + ".0";
    } else {
      from = ">=" + from;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = "<" + (+tM + 1) + ".0.0";
    } else if (isX(tp)) {
      to = "<" + tM + "." + (+tm + 1) + ".0";
    } else if (tpr) {
      to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
    } else {
      to = "<=" + to;
    }
    return (from + " " + to).trim();
  }
  Range.prototype.test = function(version) {
    if (!version) {
      return false;
    }
    if (typeof version === "string") {
      version = new SemVer(version, this.options);
    }
    for (var i2 = 0; i2 < this.set.length; i2++) {
      if (testSet(this.set[i2], version, this.options)) {
        return true;
      }
    }
    return false;
  };
  function testSet(set, version, options) {
    for (var i2 = 0; i2 < set.length; i2++) {
      if (!set[i2].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (i2 = 0; i2 < set.length; i2++) {
        debug3(set[i2].semver);
        if (set[i2].semver === ANY) {
          continue;
        }
        if (set[i2].semver.prerelease.length > 0) {
          var allowed = set[i2].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  }
  exports2.satisfies = satisfies;
  function satisfies(version, range, options) {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version);
  }
  exports2.maxSatisfying = maxSatisfying;
  function maxSatisfying(versions, range, options) {
    var max = null;
    var maxSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  }
  exports2.minSatisfying = minSatisfying;
  function minSatisfying(versions, range, options) {
    var min = null;
    var minSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  }
  exports2.minVersion = minVersion;
  function minVersion(range, loose) {
    range = new Range(range, loose);
    var minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (var i2 = 0; i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      comparators.forEach(function(comparator) {
        var compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!minver || gt(minver, compver)) {
              minver = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + comparator.operator);
        }
      });
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  }
  exports2.validRange = validRange;
  function validRange(range, options) {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  }
  exports2.ltr = ltr;
  function ltr(version, range, options) {
    return outside(version, range, "<", options);
  }
  exports2.gtr = gtr;
  function gtr(version, range, options) {
    return outside(version, range, ">", options);
  }
  exports2.outside = outside;
  function outside(version, range, hilo, options) {
    version = new SemVer(version, options);
    range = new Range(range, options);
    var gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) {
      return false;
    }
    for (var i2 = 0; i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      var high = null;
      var low = null;
      comparators.forEach(function(comparator) {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }
    return true;
  }
  exports2.prerelease = prerelease;
  function prerelease(version, options) {
    var parsed = parse2(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  }
  exports2.intersects = intersects;
  function intersects(r1, r2, options) {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2);
  }
  exports2.coerce = coerce;
  function coerce(version) {
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version !== "string") {
      return null;
    }
    var match = version.match(re[COERCE]);
    if (match == null) {
      return null;
    }
    return parse2(match[1] + "." + (match[2] || "0") + "." + (match[3] || "0"));
  }
});

// ../../node_modules/.pnpm/spdx-license-ids@3.0.9/node_modules/spdx-license-ids/index.json
var require_spdx_license_ids = __commonJS((exports2, module2) => {
  module2.exports = [
    "0BSD",
    "AAL",
    "ADSL",
    "AFL-1.1",
    "AFL-1.2",
    "AFL-2.0",
    "AFL-2.1",
    "AFL-3.0",
    "AGPL-1.0-only",
    "AGPL-1.0-or-later",
    "AGPL-3.0-only",
    "AGPL-3.0-or-later",
    "AMDPLPA",
    "AML",
    "AMPAS",
    "ANTLR-PD",
    "ANTLR-PD-fallback",
    "APAFML",
    "APL-1.0",
    "APSL-1.0",
    "APSL-1.1",
    "APSL-1.2",
    "APSL-2.0",
    "Abstyles",
    "Adobe-2006",
    "Adobe-Glyph",
    "Afmparse",
    "Aladdin",
    "Apache-1.0",
    "Apache-1.1",
    "Apache-2.0",
    "Artistic-1.0",
    "Artistic-1.0-Perl",
    "Artistic-1.0-cl8",
    "Artistic-2.0",
    "BSD-1-Clause",
    "BSD-2-Clause",
    "BSD-2-Clause-Patent",
    "BSD-2-Clause-Views",
    "BSD-3-Clause",
    "BSD-3-Clause-Attribution",
    "BSD-3-Clause-Clear",
    "BSD-3-Clause-LBNL",
    "BSD-3-Clause-Modification",
    "BSD-3-Clause-No-Military-License",
    "BSD-3-Clause-No-Nuclear-License",
    "BSD-3-Clause-No-Nuclear-License-2014",
    "BSD-3-Clause-No-Nuclear-Warranty",
    "BSD-3-Clause-Open-MPI",
    "BSD-4-Clause",
    "BSD-4-Clause-Shortened",
    "BSD-4-Clause-UC",
    "BSD-Protection",
    "BSD-Source-Code",
    "BSL-1.0",
    "BUSL-1.1",
    "Bahyph",
    "Barr",
    "Beerware",
    "BitTorrent-1.0",
    "BitTorrent-1.1",
    "BlueOak-1.0.0",
    "Borceux",
    "C-UDA-1.0",
    "CAL-1.0",
    "CAL-1.0-Combined-Work-Exception",
    "CATOSL-1.1",
    "CC-BY-1.0",
    "CC-BY-2.0",
    "CC-BY-2.5",
    "CC-BY-3.0",
    "CC-BY-3.0-AT",
    "CC-BY-3.0-US",
    "CC-BY-4.0",
    "CC-BY-NC-1.0",
    "CC-BY-NC-2.0",
    "CC-BY-NC-2.5",
    "CC-BY-NC-3.0",
    "CC-BY-NC-4.0",
    "CC-BY-NC-ND-1.0",
    "CC-BY-NC-ND-2.0",
    "CC-BY-NC-ND-2.5",
    "CC-BY-NC-ND-3.0",
    "CC-BY-NC-ND-3.0-IGO",
    "CC-BY-NC-ND-4.0",
    "CC-BY-NC-SA-1.0",
    "CC-BY-NC-SA-2.0",
    "CC-BY-NC-SA-2.5",
    "CC-BY-NC-SA-3.0",
    "CC-BY-NC-SA-4.0",
    "CC-BY-ND-1.0",
    "CC-BY-ND-2.0",
    "CC-BY-ND-2.5",
    "CC-BY-ND-3.0",
    "CC-BY-ND-4.0",
    "CC-BY-SA-1.0",
    "CC-BY-SA-2.0",
    "CC-BY-SA-2.0-UK",
    "CC-BY-SA-2.1-JP",
    "CC-BY-SA-2.5",
    "CC-BY-SA-3.0",
    "CC-BY-SA-3.0-AT",
    "CC-BY-SA-4.0",
    "CC-PDDC",
    "CC0-1.0",
    "CDDL-1.0",
    "CDDL-1.1",
    "CDL-1.0",
    "CDLA-Permissive-1.0",
    "CDLA-Sharing-1.0",
    "CECILL-1.0",
    "CECILL-1.1",
    "CECILL-2.0",
    "CECILL-2.1",
    "CECILL-B",
    "CECILL-C",
    "CERN-OHL-1.1",
    "CERN-OHL-1.2",
    "CERN-OHL-P-2.0",
    "CERN-OHL-S-2.0",
    "CERN-OHL-W-2.0",
    "CNRI-Jython",
    "CNRI-Python",
    "CNRI-Python-GPL-Compatible",
    "CPAL-1.0",
    "CPL-1.0",
    "CPOL-1.02",
    "CUA-OPL-1.0",
    "Caldera",
    "ClArtistic",
    "Condor-1.1",
    "Crossword",
    "CrystalStacker",
    "Cube",
    "D-FSL-1.0",
    "DOC",
    "DRL-1.0",
    "DSDP",
    "Dotseqn",
    "ECL-1.0",
    "ECL-2.0",
    "EFL-1.0",
    "EFL-2.0",
    "EPICS",
    "EPL-1.0",
    "EPL-2.0",
    "EUDatagrid",
    "EUPL-1.0",
    "EUPL-1.1",
    "EUPL-1.2",
    "Entessa",
    "ErlPL-1.1",
    "Eurosym",
    "FSFAP",
    "FSFUL",
    "FSFULLR",
    "FTL",
    "Fair",
    "Frameworx-1.0",
    "FreeBSD-DOC",
    "FreeImage",
    "GD",
    "GFDL-1.1-invariants-only",
    "GFDL-1.1-invariants-or-later",
    "GFDL-1.1-no-invariants-only",
    "GFDL-1.1-no-invariants-or-later",
    "GFDL-1.1-only",
    "GFDL-1.1-or-later",
    "GFDL-1.2-invariants-only",
    "GFDL-1.2-invariants-or-later",
    "GFDL-1.2-no-invariants-only",
    "GFDL-1.2-no-invariants-or-later",
    "GFDL-1.2-only",
    "GFDL-1.2-or-later",
    "GFDL-1.3-invariants-only",
    "GFDL-1.3-invariants-or-later",
    "GFDL-1.3-no-invariants-only",
    "GFDL-1.3-no-invariants-or-later",
    "GFDL-1.3-only",
    "GFDL-1.3-or-later",
    "GL2PS",
    "GLWTPL",
    "GPL-1.0-only",
    "GPL-1.0-or-later",
    "GPL-2.0-only",
    "GPL-2.0-or-later",
    "GPL-3.0-only",
    "GPL-3.0-or-later",
    "Giftware",
    "Glide",
    "Glulxe",
    "HPND",
    "HPND-sell-variant",
    "HTMLTIDY",
    "HaskellReport",
    "Hippocratic-2.1",
    "IBM-pibs",
    "ICU",
    "IJG",
    "IPA",
    "IPL-1.0",
    "ISC",
    "ImageMagick",
    "Imlib2",
    "Info-ZIP",
    "Intel",
    "Intel-ACPI",
    "Interbase-1.0",
    "JPNIC",
    "JSON",
    "JasPer-2.0",
    "LAL-1.2",
    "LAL-1.3",
    "LGPL-2.0-only",
    "LGPL-2.0-or-later",
    "LGPL-2.1-only",
    "LGPL-2.1-or-later",
    "LGPL-3.0-only",
    "LGPL-3.0-or-later",
    "LGPLLR",
    "LPL-1.0",
    "LPL-1.02",
    "LPPL-1.0",
    "LPPL-1.1",
    "LPPL-1.2",
    "LPPL-1.3a",
    "LPPL-1.3c",
    "Latex2e",
    "Leptonica",
    "LiLiQ-P-1.1",
    "LiLiQ-R-1.1",
    "LiLiQ-Rplus-1.1",
    "Libpng",
    "Linux-OpenIB",
    "MIT",
    "MIT-0",
    "MIT-CMU",
    "MIT-Modern-Variant",
    "MIT-advertising",
    "MIT-enna",
    "MIT-feh",
    "MIT-open-group",
    "MITNFA",
    "MPL-1.0",
    "MPL-1.1",
    "MPL-2.0",
    "MPL-2.0-no-copyleft-exception",
    "MS-PL",
    "MS-RL",
    "MTLL",
    "MakeIndex",
    "MirOS",
    "Motosoto",
    "MulanPSL-1.0",
    "MulanPSL-2.0",
    "Multics",
    "Mup",
    "NAIST-2003",
    "NASA-1.3",
    "NBPL-1.0",
    "NCGL-UK-2.0",
    "NCSA",
    "NGPL",
    "NIST-PD",
    "NIST-PD-fallback",
    "NLOD-1.0",
    "NLPL",
    "NOSL",
    "NPL-1.0",
    "NPL-1.1",
    "NPOSL-3.0",
    "NRL",
    "NTP",
    "NTP-0",
    "Naumen",
    "Net-SNMP",
    "NetCDF",
    "Newsletr",
    "Nokia",
    "Noweb",
    "O-UDA-1.0",
    "OCCT-PL",
    "OCLC-2.0",
    "ODC-By-1.0",
    "ODbL-1.0",
    "OFL-1.0",
    "OFL-1.0-RFN",
    "OFL-1.0-no-RFN",
    "OFL-1.1",
    "OFL-1.1-RFN",
    "OFL-1.1-no-RFN",
    "OGC-1.0",
    "OGDL-Taiwan-1.0",
    "OGL-Canada-2.0",
    "OGL-UK-1.0",
    "OGL-UK-2.0",
    "OGL-UK-3.0",
    "OGTSL",
    "OLDAP-1.1",
    "OLDAP-1.2",
    "OLDAP-1.3",
    "OLDAP-1.4",
    "OLDAP-2.0",
    "OLDAP-2.0.1",
    "OLDAP-2.1",
    "OLDAP-2.2",
    "OLDAP-2.2.1",
    "OLDAP-2.2.2",
    "OLDAP-2.3",
    "OLDAP-2.4",
    "OLDAP-2.5",
    "OLDAP-2.6",
    "OLDAP-2.7",
    "OLDAP-2.8",
    "OML",
    "OPL-1.0",
    "OSET-PL-2.1",
    "OSL-1.0",
    "OSL-1.1",
    "OSL-2.0",
    "OSL-2.1",
    "OSL-3.0",
    "OpenSSL",
    "PDDL-1.0",
    "PHP-3.0",
    "PHP-3.01",
    "PSF-2.0",
    "Parity-6.0.0",
    "Parity-7.0.0",
    "Plexus",
    "PolyForm-Noncommercial-1.0.0",
    "PolyForm-Small-Business-1.0.0",
    "PostgreSQL",
    "Python-2.0",
    "QPL-1.0",
    "Qhull",
    "RHeCos-1.1",
    "RPL-1.1",
    "RPL-1.5",
    "RPSL-1.0",
    "RSA-MD",
    "RSCPL",
    "Rdisc",
    "Ruby",
    "SAX-PD",
    "SCEA",
    "SGI-B-1.0",
    "SGI-B-1.1",
    "SGI-B-2.0",
    "SHL-0.5",
    "SHL-0.51",
    "SISSL",
    "SISSL-1.2",
    "SMLNJ",
    "SMPPL",
    "SNIA",
    "SPL-1.0",
    "SSH-OpenSSH",
    "SSH-short",
    "SSPL-1.0",
    "SWL",
    "Saxpath",
    "Sendmail",
    "Sendmail-8.23",
    "SimPL-2.0",
    "Sleepycat",
    "Spencer-86",
    "Spencer-94",
    "Spencer-99",
    "SugarCRM-1.1.3",
    "TAPR-OHL-1.0",
    "TCL",
    "TCP-wrappers",
    "TMate",
    "TORQUE-1.1",
    "TOSL",
    "TU-Berlin-1.0",
    "TU-Berlin-2.0",
    "UCL-1.0",
    "UPL-1.0",
    "Unicode-DFS-2015",
    "Unicode-DFS-2016",
    "Unicode-TOU",
    "Unlicense",
    "VOSTROM",
    "VSL-1.0",
    "Vim",
    "W3C",
    "W3C-19980720",
    "W3C-20150513",
    "WTFPL",
    "Watcom-1.0",
    "Wsuipa",
    "X11",
    "XFree86-1.1",
    "XSkat",
    "Xerox",
    "Xnet",
    "YPL-1.0",
    "YPL-1.1",
    "ZPL-1.1",
    "ZPL-2.0",
    "ZPL-2.1",
    "Zed",
    "Zend-2.0",
    "Zimbra-1.3",
    "Zimbra-1.4",
    "Zlib",
    "blessing",
    "bzip2-1.0.5",
    "bzip2-1.0.6",
    "copyleft-next-0.3.0",
    "copyleft-next-0.3.1",
    "curl",
    "diffmark",
    "dvipdfm",
    "eGenix",
    "etalab-2.0",
    "gSOAP-1.3b",
    "gnuplot",
    "iMatix",
    "libpng-2.0",
    "libselinux-1.0",
    "libtiff",
    "mpich2",
    "psfrag",
    "psutils",
    "xinetd",
    "xpp",
    "zlib-acknowledgement"
  ];
});

// ../../node_modules/.pnpm/spdx-license-ids@3.0.9/node_modules/spdx-license-ids/deprecated.json
var require_deprecated = __commonJS((exports2, module2) => {
  module2.exports = [
    "AGPL-1.0",
    "AGPL-3.0",
    "BSD-2-Clause-FreeBSD",
    "BSD-2-Clause-NetBSD",
    "GFDL-1.1",
    "GFDL-1.2",
    "GFDL-1.3",
    "GPL-1.0",
    "GPL-2.0",
    "GPL-2.0-with-GCC-exception",
    "GPL-2.0-with-autoconf-exception",
    "GPL-2.0-with-bison-exception",
    "GPL-2.0-with-classpath-exception",
    "GPL-2.0-with-font-exception",
    "GPL-3.0",
    "GPL-3.0-with-GCC-exception",
    "GPL-3.0-with-autoconf-exception",
    "LGPL-2.0",
    "LGPL-2.1",
    "LGPL-3.0",
    "Nunit",
    "StandardML-NJ",
    "eCos-2.0",
    "wxWindows"
  ];
});

// ../../node_modules/.pnpm/spdx-exceptions@2.3.0/node_modules/spdx-exceptions/index.json
var require_spdx_exceptions = __commonJS((exports2, module2) => {
  module2.exports = [
    "389-exception",
    "Autoconf-exception-2.0",
    "Autoconf-exception-3.0",
    "Bison-exception-2.2",
    "Bootloader-exception",
    "Classpath-exception-2.0",
    "CLISP-exception-2.0",
    "DigiRule-FOSS-exception",
    "eCos-exception-2.0",
    "Fawkes-Runtime-exception",
    "FLTK-exception",
    "Font-exception-2.0",
    "freertos-exception-2.0",
    "GCC-exception-2.0",
    "GCC-exception-3.1",
    "gnu-javamail-exception",
    "GPL-3.0-linking-exception",
    "GPL-3.0-linking-source-exception",
    "GPL-CC-1.0",
    "i2p-gpl-java-exception",
    "Libtool-exception",
    "Linux-syscall-note",
    "LLVM-exception",
    "LZMA-exception",
    "mif-exception",
    "Nokia-Qt-exception-1.1",
    "OCaml-LGPL-linking-exception",
    "OCCT-exception-1.0",
    "OpenJDK-assembly-exception-1.0",
    "openvpn-openssl-exception",
    "PS-or-PDF-font-exception-20170817",
    "Qt-GPL-exception-1.0",
    "Qt-LGPL-exception-1.1",
    "Qwt-exception-1.0",
    "Swift-exception",
    "u-boot-exception-2.0",
    "Universal-FOSS-exception-1.0",
    "WxWindows-exception-3.1"
  ];
});

// ../../node_modules/.pnpm/spdx-expression-parse@3.0.1/node_modules/spdx-expression-parse/scan.js
var require_scan = __commonJS((exports2, module2) => {
  "use strict";
  var licenses = [].concat(require_spdx_license_ids()).concat(require_deprecated());
  var exceptions = require_spdx_exceptions();
  module2.exports = function(source) {
    var index = 0;
    function hasMore() {
      return index < source.length;
    }
    function read(value) {
      if (value instanceof RegExp) {
        var chars = source.slice(index);
        var match = chars.match(value);
        if (match) {
          index += match[0].length;
          return match[0];
        }
      } else {
        if (source.indexOf(value, index) === index) {
          index += value.length;
          return value;
        }
      }
    }
    function skipWhitespace() {
      read(/[ ]*/);
    }
    function operator() {
      var string;
      var possibilities = ["WITH", "AND", "OR", "(", ")", ":", "+"];
      for (var i = 0; i < possibilities.length; i++) {
        string = read(possibilities[i]);
        if (string) {
          break;
        }
      }
      if (string === "+" && index > 1 && source[index - 2] === " ") {
        throw new Error("Space before `+`");
      }
      return string && {
        type: "OPERATOR",
        string
      };
    }
    function idstring() {
      return read(/[A-Za-z0-9-.]+/);
    }
    function expectIdstring() {
      var string = idstring();
      if (!string) {
        throw new Error("Expected idstring at offset " + index);
      }
      return string;
    }
    function documentRef() {
      if (read("DocumentRef-")) {
        var string = expectIdstring();
        return {type: "DOCUMENTREF", string};
      }
    }
    function licenseRef() {
      if (read("LicenseRef-")) {
        var string = expectIdstring();
        return {type: "LICENSEREF", string};
      }
    }
    function identifier() {
      var begin = index;
      var string = idstring();
      if (licenses.indexOf(string) !== -1) {
        return {
          type: "LICENSE",
          string
        };
      } else if (exceptions.indexOf(string) !== -1) {
        return {
          type: "EXCEPTION",
          string
        };
      }
      index = begin;
    }
    function parseToken() {
      return operator() || documentRef() || licenseRef() || identifier();
    }
    var tokens = [];
    while (hasMore()) {
      skipWhitespace();
      if (!hasMore()) {
        break;
      }
      var token = parseToken();
      if (!token) {
        throw new Error("Unexpected `" + source[index] + "` at offset " + index);
      }
      tokens.push(token);
    }
    return tokens;
  };
});

// ../../node_modules/.pnpm/spdx-expression-parse@3.0.1/node_modules/spdx-expression-parse/parse.js
var require_parse2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(tokens) {
    var index = 0;
    function hasMore() {
      return index < tokens.length;
    }
    function token() {
      return hasMore() ? tokens[index] : null;
    }
    function next() {
      if (!hasMore()) {
        throw new Error();
      }
      index++;
    }
    function parseOperator(operator) {
      var t = token();
      if (t && t.type === "OPERATOR" && operator === t.string) {
        next();
        return t.string;
      }
    }
    function parseWith() {
      if (parseOperator("WITH")) {
        var t = token();
        if (t && t.type === "EXCEPTION") {
          next();
          return t.string;
        }
        throw new Error("Expected exception after `WITH`");
      }
    }
    function parseLicenseRef() {
      var begin = index;
      var string = "";
      var t = token();
      if (t.type === "DOCUMENTREF") {
        next();
        string += "DocumentRef-" + t.string + ":";
        if (!parseOperator(":")) {
          throw new Error("Expected `:` after `DocumentRef-...`");
        }
      }
      t = token();
      if (t.type === "LICENSEREF") {
        next();
        string += "LicenseRef-" + t.string;
        return {license: string};
      }
      index = begin;
    }
    function parseLicense() {
      var t = token();
      if (t && t.type === "LICENSE") {
        next();
        var node2 = {license: t.string};
        if (parseOperator("+")) {
          node2.plus = true;
        }
        var exception = parseWith();
        if (exception) {
          node2.exception = exception;
        }
        return node2;
      }
    }
    function parseParenthesizedExpression() {
      var left = parseOperator("(");
      if (!left) {
        return;
      }
      var expr = parseExpression();
      if (!parseOperator(")")) {
        throw new Error("Expected `)`");
      }
      return expr;
    }
    function parseAtom() {
      return parseParenthesizedExpression() || parseLicenseRef() || parseLicense();
    }
    function makeBinaryOpParser(operator, nextParser) {
      return function parseBinaryOp() {
        var left = nextParser();
        if (!left) {
          return;
        }
        if (!parseOperator(operator)) {
          return left;
        }
        var right = parseBinaryOp();
        if (!right) {
          throw new Error("Expected expression");
        }
        return {
          left,
          conjunction: operator.toLowerCase(),
          right
        };
      };
    }
    var parseAnd = makeBinaryOpParser("AND", parseAtom);
    var parseExpression = makeBinaryOpParser("OR", parseAnd);
    var node = parseExpression();
    if (!node || hasMore()) {
      throw new Error("Syntax error");
    }
    return node;
  };
});

// ../../node_modules/.pnpm/spdx-expression-parse@3.0.1/node_modules/spdx-expression-parse/index.js
var require_spdx_expression_parse = __commonJS((exports2, module2) => {
  "use strict";
  var scan = require_scan();
  var parse2 = require_parse2();
  module2.exports = function(source) {
    return parse2(scan(source));
  };
});

// ../../node_modules/.pnpm/spdx-correct@3.1.1/node_modules/spdx-correct/index.js
var require_spdx_correct = __commonJS((exports2, module2) => {
  var parse2 = require_spdx_expression_parse();
  var spdxLicenseIds = require_spdx_license_ids();
  function valid(string) {
    try {
      parse2(string);
      return true;
    } catch (error) {
      return false;
    }
  }
  var transpositions = [
    ["APGL", "AGPL"],
    ["Gpl", "GPL"],
    ["GLP", "GPL"],
    ["APL", "Apache"],
    ["ISD", "ISC"],
    ["GLP", "GPL"],
    ["IST", "ISC"],
    ["Claude", "Clause"],
    [" or later", "+"],
    [" International", ""],
    ["GNU", "GPL"],
    ["GUN", "GPL"],
    ["+", ""],
    ["GNU GPL", "GPL"],
    ["GNU/GPL", "GPL"],
    ["GNU GLP", "GPL"],
    ["GNU General Public License", "GPL"],
    ["Gnu public license", "GPL"],
    ["GNU Public License", "GPL"],
    ["GNU GENERAL PUBLIC LICENSE", "GPL"],
    ["MTI", "MIT"],
    ["Mozilla Public License", "MPL"],
    ["Universal Permissive License", "UPL"],
    ["WTH", "WTF"],
    ["-License", ""]
  ];
  var TRANSPOSED = 0;
  var CORRECT = 1;
  var transforms = [
    function(argument) {
      return argument.toUpperCase();
    },
    function(argument) {
      return argument.trim();
    },
    function(argument) {
      return argument.replace(/\./g, "");
    },
    function(argument) {
      return argument.replace(/\s+/g, "");
    },
    function(argument) {
      return argument.replace(/\s+/g, "-");
    },
    function(argument) {
      return argument.replace("v", "-");
    },
    function(argument) {
      return argument.replace(/,?\s*(\d)/, "-$1");
    },
    function(argument) {
      return argument.replace(/,?\s*(\d)/, "-$1.0");
    },
    function(argument) {
      return argument.replace(/,?\s*(V\.|v\.|V|v|Version|version)\s*(\d)/, "-$2");
    },
    function(argument) {
      return argument.replace(/,?\s*(V\.|v\.|V|v|Version|version)\s*(\d)/, "-$2.0");
    },
    function(argument) {
      return argument[0].toUpperCase() + argument.slice(1);
    },
    function(argument) {
      return argument.replace("/", "-");
    },
    function(argument) {
      return argument.replace(/\s*V\s*(\d)/, "-$1").replace(/(\d)$/, "$1.0");
    },
    function(argument) {
      if (argument.indexOf("3.0") !== -1) {
        return argument + "-or-later";
      } else {
        return argument + "-only";
      }
    },
    function(argument) {
      return argument + "only";
    },
    function(argument) {
      return argument.replace(/(\d)$/, "-$1.0");
    },
    function(argument) {
      return argument.replace(/(-| )?(\d)$/, "-$2-Clause");
    },
    function(argument) {
      return argument.replace(/(-| )clause(-| )(\d)/, "-$3-Clause");
    },
    function(argument) {
      return argument.replace(/\b(Modified|New|Revised)(-| )?BSD((-| )License)?/i, "BSD-3-Clause");
    },
    function(argument) {
      return argument.replace(/\bSimplified(-| )?BSD((-| )License)?/i, "BSD-2-Clause");
    },
    function(argument) {
      return argument.replace(/\b(Free|Net)(-| )?BSD((-| )License)?/i, "BSD-2-Clause-$1BSD");
    },
    function(argument) {
      return argument.replace(/\bClear(-| )?BSD((-| )License)?/i, "BSD-3-Clause-Clear");
    },
    function(argument) {
      return argument.replace(/\b(Old|Original)(-| )?BSD((-| )License)?/i, "BSD-4-Clause");
    },
    function(argument) {
      return "CC-" + argument;
    },
    function(argument) {
      return "CC-" + argument + "-4.0";
    },
    function(argument) {
      return argument.replace("Attribution", "BY").replace("NonCommercial", "NC").replace("NoDerivatives", "ND").replace(/ (\d)/, "-$1").replace(/ ?International/, "");
    },
    function(argument) {
      return "CC-" + argument.replace("Attribution", "BY").replace("NonCommercial", "NC").replace("NoDerivatives", "ND").replace(/ (\d)/, "-$1").replace(/ ?International/, "") + "-4.0";
    }
  ];
  var licensesWithVersions = spdxLicenseIds.map(function(id) {
    var match = /^(.*)-\d+\.\d+$/.exec(id);
    return match ? [match[0], match[1]] : [id, null];
  }).reduce(function(objectMap, item) {
    var key = item[1];
    objectMap[key] = objectMap[key] || [];
    objectMap[key].push(item[0]);
    return objectMap;
  }, {});
  var licensesWithOneVersion = Object.keys(licensesWithVersions).map(function makeEntries(key) {
    return [key, licensesWithVersions[key]];
  }).filter(function identifySoleVersions(item) {
    return item[1].length === 1 && item[0] !== null && item[0] !== "APL";
  }).map(function createLastResorts(item) {
    return [item[0], item[1][0]];
  });
  licensesWithVersions = void 0;
  var lastResorts = [
    ["UNLI", "Unlicense"],
    ["WTF", "WTFPL"],
    ["2 CLAUSE", "BSD-2-Clause"],
    ["2-CLAUSE", "BSD-2-Clause"],
    ["3 CLAUSE", "BSD-3-Clause"],
    ["3-CLAUSE", "BSD-3-Clause"],
    ["AFFERO", "AGPL-3.0-or-later"],
    ["AGPL", "AGPL-3.0-or-later"],
    ["APACHE", "Apache-2.0"],
    ["ARTISTIC", "Artistic-2.0"],
    ["Affero", "AGPL-3.0-or-later"],
    ["BEER", "Beerware"],
    ["BOOST", "BSL-1.0"],
    ["BSD", "BSD-2-Clause"],
    ["CDDL", "CDDL-1.1"],
    ["ECLIPSE", "EPL-1.0"],
    ["FUCK", "WTFPL"],
    ["GNU", "GPL-3.0-or-later"],
    ["LGPL", "LGPL-3.0-or-later"],
    ["GPLV1", "GPL-1.0-only"],
    ["GPL-1", "GPL-1.0-only"],
    ["GPLV2", "GPL-2.0-only"],
    ["GPL-2", "GPL-2.0-only"],
    ["GPL", "GPL-3.0-or-later"],
    ["MIT +NO-FALSE-ATTRIBS", "MITNFA"],
    ["MIT", "MIT"],
    ["MPL", "MPL-2.0"],
    ["X11", "X11"],
    ["ZLIB", "Zlib"]
  ].concat(licensesWithOneVersion);
  var SUBSTRING = 0;
  var IDENTIFIER = 1;
  var validTransformation = function(identifier) {
    for (var i = 0; i < transforms.length; i++) {
      var transformed = transforms[i](identifier).trim();
      if (transformed !== identifier && valid(transformed)) {
        return transformed;
      }
    }
    return null;
  };
  var validLastResort = function(identifier) {
    var upperCased = identifier.toUpperCase();
    for (var i = 0; i < lastResorts.length; i++) {
      var lastResort = lastResorts[i];
      if (upperCased.indexOf(lastResort[SUBSTRING]) > -1) {
        return lastResort[IDENTIFIER];
      }
    }
    return null;
  };
  var anyCorrection = function(identifier, check3) {
    for (var i = 0; i < transpositions.length; i++) {
      var transposition = transpositions[i];
      var transposed = transposition[TRANSPOSED];
      if (identifier.indexOf(transposed) > -1) {
        var corrected = identifier.replace(transposed, transposition[CORRECT]);
        var checked = check3(corrected);
        if (checked !== null) {
          return checked;
        }
      }
    }
    return null;
  };
  module2.exports = function(identifier, options) {
    options = options || {};
    var upgrade = options.upgrade === void 0 ? true : !!options.upgrade;
    function postprocess(value) {
      return upgrade ? upgradeGPLs(value) : value;
    }
    var validArugment = typeof identifier === "string" && identifier.trim().length !== 0;
    if (!validArugment) {
      throw Error("Invalid argument. Expected non-empty string.");
    }
    identifier = identifier.trim();
    if (valid(identifier)) {
      return postprocess(identifier);
    }
    var noPlus = identifier.replace(/\+$/, "").trim();
    if (valid(noPlus)) {
      return postprocess(noPlus);
    }
    var transformed = validTransformation(identifier);
    if (transformed !== null) {
      return postprocess(transformed);
    }
    transformed = anyCorrection(identifier, function(argument) {
      if (valid(argument)) {
        return argument;
      }
      return validTransformation(argument);
    });
    if (transformed !== null) {
      return postprocess(transformed);
    }
    transformed = validLastResort(identifier);
    if (transformed !== null) {
      return postprocess(transformed);
    }
    transformed = anyCorrection(identifier, validLastResort);
    if (transformed !== null) {
      return postprocess(transformed);
    }
    return null;
  };
  function upgradeGPLs(value) {
    if ([
      "GPL-1.0",
      "LGPL-1.0",
      "AGPL-1.0",
      "GPL-2.0",
      "LGPL-2.0",
      "AGPL-2.0",
      "LGPL-2.1"
    ].indexOf(value) !== -1) {
      return value + "-only";
    } else if ([
      "GPL-1.0+",
      "GPL-2.0+",
      "GPL-3.0+",
      "LGPL-2.0+",
      "LGPL-2.1+",
      "LGPL-3.0+",
      "AGPL-1.0+",
      "AGPL-3.0+"
    ].indexOf(value) !== -1) {
      return value.replace(/\+$/, "-or-later");
    } else if (["GPL-3.0", "LGPL-3.0", "AGPL-3.0"].indexOf(value) !== -1) {
      return value + "-or-later";
    } else {
      return value;
    }
  }
});

// ../../node_modules/.pnpm/validate-npm-package-license@3.0.4/node_modules/validate-npm-package-license/index.js
var require_validate_npm_package_license = __commonJS((exports2, module2) => {
  var parse2 = require_spdx_expression_parse();
  var correct = require_spdx_correct();
  var genericWarning = 'license should be a valid SPDX license expression (without "LicenseRef"), "UNLICENSED", or "SEE LICENSE IN <filename>"';
  var fileReferenceRE = /^SEE LICEN[CS]E IN (.+)$/;
  function startsWith(prefix, string) {
    return string.slice(0, prefix.length) === prefix;
  }
  function usesLicenseRef(ast) {
    if (ast.hasOwnProperty("license")) {
      var license = ast.license;
      return startsWith("LicenseRef", license) || startsWith("DocumentRef", license);
    } else {
      return usesLicenseRef(ast.left) || usesLicenseRef(ast.right);
    }
  }
  module2.exports = function(argument) {
    var ast;
    try {
      ast = parse2(argument);
    } catch (e) {
      var match;
      if (argument === "UNLICENSED" || argument === "UNLICENCED") {
        return {
          validForOldPackages: true,
          validForNewPackages: true,
          unlicensed: true
        };
      } else if (match = fileReferenceRE.exec(argument)) {
        return {
          validForOldPackages: true,
          validForNewPackages: true,
          inFile: match[1]
        };
      } else {
        var result = {
          validForOldPackages: false,
          validForNewPackages: false,
          warnings: [genericWarning]
        };
        if (argument.trim().length !== 0) {
          var corrected = correct(argument);
          if (corrected) {
            result.warnings.push('license is similar to the valid expression "' + corrected + '"');
          }
        }
        return result;
      }
    }
    if (usesLicenseRef(ast)) {
      return {
        validForNewPackages: false,
        validForOldPackages: false,
        spdx: true,
        warnings: [genericWarning]
      };
    } else {
      return {
        validForNewPackages: true,
        validForOldPackages: true,
        spdx: true
      };
    }
  };
});

// ../../node_modules/.pnpm/hosted-git-info@2.8.9/node_modules/hosted-git-info/git-host-info.js
var require_git_host_info = __commonJS((exports2, module2) => {
  "use strict";
  var gitHosts = module2.exports = {
    github: {
      protocols: ["git", "http", "git+ssh", "git+https", "ssh", "https"],
      domain: "github.com",
      treepath: "tree",
      filetemplate: "https://{auth@}raw.githubusercontent.com/{user}/{project}/{committish}/{path}",
      bugstemplate: "https://{domain}/{user}/{project}/issues",
      gittemplate: "git://{auth@}{domain}/{user}/{project}.git{#committish}",
      tarballtemplate: "https://codeload.{domain}/{user}/{project}/tar.gz/{committish}"
    },
    bitbucket: {
      protocols: ["git+ssh", "git+https", "ssh", "https"],
      domain: "bitbucket.org",
      treepath: "src",
      tarballtemplate: "https://{domain}/{user}/{project}/get/{committish}.tar.gz"
    },
    gitlab: {
      protocols: ["git+ssh", "git+https", "ssh", "https"],
      domain: "gitlab.com",
      treepath: "tree",
      bugstemplate: "https://{domain}/{user}/{project}/issues",
      httpstemplate: "git+https://{auth@}{domain}/{user}/{projectPath}.git{#committish}",
      tarballtemplate: "https://{domain}/{user}/{project}/repository/archive.tar.gz?ref={committish}",
      pathmatch: /^[/]([^/]+)[/]((?!.*(\/-\/|\/repository\/archive\.tar\.gz\?=.*|\/repository\/[^/]+\/archive.tar.gz$)).*?)(?:[.]git|[/])?$/
    },
    gist: {
      protocols: ["git", "git+ssh", "git+https", "ssh", "https"],
      domain: "gist.github.com",
      pathmatch: /^[/](?:([^/]+)[/])?([a-z0-9]{32,})(?:[.]git)?$/,
      filetemplate: "https://gist.githubusercontent.com/{user}/{project}/raw{/committish}/{path}",
      bugstemplate: "https://{domain}/{project}",
      gittemplate: "git://{domain}/{project}.git{#committish}",
      sshtemplate: "git@{domain}:/{project}.git{#committish}",
      sshurltemplate: "git+ssh://git@{domain}/{project}.git{#committish}",
      browsetemplate: "https://{domain}/{project}{/committish}",
      browsefiletemplate: "https://{domain}/{project}{/committish}{#path}",
      docstemplate: "https://{domain}/{project}{/committish}",
      httpstemplate: "git+https://{domain}/{project}.git{#committish}",
      shortcuttemplate: "{type}:{project}{#committish}",
      pathtemplate: "{project}{#committish}",
      tarballtemplate: "https://codeload.github.com/gist/{project}/tar.gz/{committish}",
      hashformat: function(fragment) {
        return "file-" + formatHashFragment(fragment);
      }
    }
  };
  var gitHostDefaults = {
    sshtemplate: "git@{domain}:{user}/{project}.git{#committish}",
    sshurltemplate: "git+ssh://git@{domain}/{user}/{project}.git{#committish}",
    browsetemplate: "https://{domain}/{user}/{project}{/tree/committish}",
    browsefiletemplate: "https://{domain}/{user}/{project}/{treepath}/{committish}/{path}{#fragment}",
    docstemplate: "https://{domain}/{user}/{project}{/tree/committish}#readme",
    httpstemplate: "git+https://{auth@}{domain}/{user}/{project}.git{#committish}",
    filetemplate: "https://{domain}/{user}/{project}/raw/{committish}/{path}",
    shortcuttemplate: "{type}:{user}/{project}{#committish}",
    pathtemplate: "{user}/{project}{#committish}",
    pathmatch: /^[/]([^/]+)[/]([^/]+?)(?:[.]git|[/])?$/,
    hashformat: formatHashFragment
  };
  Object.keys(gitHosts).forEach(function(name) {
    Object.keys(gitHostDefaults).forEach(function(key) {
      if (gitHosts[name][key])
        return;
      gitHosts[name][key] = gitHostDefaults[key];
    });
    gitHosts[name].protocols_re = RegExp("^(" + gitHosts[name].protocols.map(function(protocol) {
      return protocol.replace(/([\\+*{}()[\]$^|])/g, "\\$1");
    }).join("|") + "):$");
  });
  function formatHashFragment(fragment) {
    return fragment.toLowerCase().replace(/^\W+|\/|\W+$/g, "").replace(/\W+/g, "-");
  }
});

// ../../node_modules/.pnpm/hosted-git-info@2.8.9/node_modules/hosted-git-info/git-host.js
var require_git_host = __commonJS((exports2, module2) => {
  "use strict";
  var gitHosts = require_git_host_info();
  var extend = Object.assign || function _extend(target, source) {
    if (source === null || typeof source !== "object")
      return target;
    var keys = Object.keys(source);
    var i = keys.length;
    while (i--) {
      target[keys[i]] = source[keys[i]];
    }
    return target;
  };
  module2.exports = GitHost;
  function GitHost(type, user, auth, project, committish, defaultRepresentation, opts) {
    var gitHostInfo = this;
    gitHostInfo.type = type;
    Object.keys(gitHosts[type]).forEach(function(key) {
      gitHostInfo[key] = gitHosts[type][key];
    });
    gitHostInfo.user = user;
    gitHostInfo.auth = auth;
    gitHostInfo.project = project;
    gitHostInfo.committish = committish;
    gitHostInfo.default = defaultRepresentation;
    gitHostInfo.opts = opts || {};
  }
  GitHost.prototype.hash = function() {
    return this.committish ? "#" + this.committish : "";
  };
  GitHost.prototype._fill = function(template, opts) {
    if (!template)
      return;
    var vars = extend({}, opts);
    vars.path = vars.path ? vars.path.replace(/^[/]+/g, "") : "";
    opts = extend(extend({}, this.opts), opts);
    var self2 = this;
    Object.keys(this).forEach(function(key) {
      if (self2[key] != null && vars[key] == null)
        vars[key] = self2[key];
    });
    var rawAuth = vars.auth;
    var rawcommittish = vars.committish;
    var rawFragment = vars.fragment;
    var rawPath = vars.path;
    var rawProject = vars.project;
    Object.keys(vars).forEach(function(key) {
      var value = vars[key];
      if ((key === "path" || key === "project") && typeof value === "string") {
        vars[key] = value.split("/").map(function(pathComponent) {
          return encodeURIComponent(pathComponent);
        }).join("/");
      } else {
        vars[key] = encodeURIComponent(value);
      }
    });
    vars["auth@"] = rawAuth ? rawAuth + "@" : "";
    vars["#fragment"] = rawFragment ? "#" + this.hashformat(rawFragment) : "";
    vars.fragment = vars.fragment ? vars.fragment : "";
    vars["#path"] = rawPath ? "#" + this.hashformat(rawPath) : "";
    vars["/path"] = vars.path ? "/" + vars.path : "";
    vars.projectPath = rawProject.split("/").map(encodeURIComponent).join("/");
    if (opts.noCommittish) {
      vars["#committish"] = "";
      vars["/tree/committish"] = "";
      vars["/committish"] = "";
      vars.committish = "";
    } else {
      vars["#committish"] = rawcommittish ? "#" + rawcommittish : "";
      vars["/tree/committish"] = vars.committish ? "/" + vars.treepath + "/" + vars.committish : "";
      vars["/committish"] = vars.committish ? "/" + vars.committish : "";
      vars.committish = vars.committish || "master";
    }
    var res = template;
    Object.keys(vars).forEach(function(key) {
      res = res.replace(new RegExp("[{]" + key + "[}]", "g"), vars[key]);
    });
    if (opts.noGitPlus) {
      return res.replace(/^git[+]/, "");
    } else {
      return res;
    }
  };
  GitHost.prototype.ssh = function(opts) {
    return this._fill(this.sshtemplate, opts);
  };
  GitHost.prototype.sshurl = function(opts) {
    return this._fill(this.sshurltemplate, opts);
  };
  GitHost.prototype.browse = function(P, F, opts) {
    if (typeof P === "string") {
      if (typeof F !== "string") {
        opts = F;
        F = null;
      }
      return this._fill(this.browsefiletemplate, extend({
        fragment: F,
        path: P
      }, opts));
    } else {
      return this._fill(this.browsetemplate, P);
    }
  };
  GitHost.prototype.docs = function(opts) {
    return this._fill(this.docstemplate, opts);
  };
  GitHost.prototype.bugs = function(opts) {
    return this._fill(this.bugstemplate, opts);
  };
  GitHost.prototype.https = function(opts) {
    return this._fill(this.httpstemplate, opts);
  };
  GitHost.prototype.git = function(opts) {
    return this._fill(this.gittemplate, opts);
  };
  GitHost.prototype.shortcut = function(opts) {
    return this._fill(this.shortcuttemplate, opts);
  };
  GitHost.prototype.path = function(opts) {
    return this._fill(this.pathtemplate, opts);
  };
  GitHost.prototype.tarball = function(opts_) {
    var opts = extend({}, opts_, {noCommittish: false});
    return this._fill(this.tarballtemplate, opts);
  };
  GitHost.prototype.file = function(P, opts) {
    return this._fill(this.filetemplate, extend({path: P}, opts));
  };
  GitHost.prototype.getDefaultRepresentation = function() {
    return this.default;
  };
  GitHost.prototype.toString = function(opts) {
    if (this.default && typeof this[this.default] === "function")
      return this[this.default](opts);
    return this.sshurl(opts);
  };
});

// ../../node_modules/.pnpm/hosted-git-info@2.8.9/node_modules/hosted-git-info/index.js
var require_hosted_git_info = __commonJS((exports2, module2) => {
  "use strict";
  var url = require("url");
  var gitHosts = require_git_host_info();
  var GitHost = module2.exports = require_git_host();
  var protocolToRepresentationMap = {
    "git+ssh:": "sshurl",
    "git+https:": "https",
    "ssh:": "sshurl",
    "git:": "git"
  };
  function protocolToRepresentation(protocol) {
    return protocolToRepresentationMap[protocol] || protocol.slice(0, -1);
  }
  var authProtocols = {
    "git:": true,
    "https:": true,
    "git+https:": true,
    "http:": true,
    "git+http:": true
  };
  var cache = {};
  module2.exports.fromUrl = function(giturl, opts) {
    if (typeof giturl !== "string")
      return;
    var key = giturl + JSON.stringify(opts || {});
    if (!(key in cache)) {
      cache[key] = fromUrl(giturl, opts);
    }
    return cache[key];
  };
  function fromUrl(giturl, opts) {
    if (giturl == null || giturl === "")
      return;
    var url2 = fixupUnqualifiedGist(isGitHubShorthand(giturl) ? "github:" + giturl : giturl);
    var parsed = parseGitUrl(url2);
    var shortcutMatch = url2.match(/^([^:]+):(?:[^@]+@)?(?:([^/]*)\/)?([^#]+)/);
    var matches = Object.keys(gitHosts).map(function(gitHostName) {
      try {
        var gitHostInfo = gitHosts[gitHostName];
        var auth = null;
        if (parsed.auth && authProtocols[parsed.protocol]) {
          auth = parsed.auth;
        }
        var committish = parsed.hash ? decodeURIComponent(parsed.hash.substr(1)) : null;
        var user = null;
        var project = null;
        var defaultRepresentation = null;
        if (shortcutMatch && shortcutMatch[1] === gitHostName) {
          user = shortcutMatch[2] && decodeURIComponent(shortcutMatch[2]);
          project = decodeURIComponent(shortcutMatch[3].replace(/\.git$/, ""));
          defaultRepresentation = "shortcut";
        } else {
          if (parsed.host && parsed.host !== gitHostInfo.domain && parsed.host.replace(/^www[.]/, "") !== gitHostInfo.domain)
            return;
          if (!gitHostInfo.protocols_re.test(parsed.protocol))
            return;
          if (!parsed.path)
            return;
          var pathmatch = gitHostInfo.pathmatch;
          var matched = parsed.path.match(pathmatch);
          if (!matched)
            return;
          if (matched[1] !== null && matched[1] !== void 0) {
            user = decodeURIComponent(matched[1].replace(/^:/, ""));
          }
          project = decodeURIComponent(matched[2]);
          defaultRepresentation = protocolToRepresentation(parsed.protocol);
        }
        return new GitHost(gitHostName, user, auth, project, committish, defaultRepresentation, opts);
      } catch (ex) {
        if (ex instanceof URIError) {
        } else
          throw ex;
      }
    }).filter(function(gitHostInfo) {
      return gitHostInfo;
    });
    if (matches.length !== 1)
      return;
    return matches[0];
  }
  function isGitHubShorthand(arg10) {
    return /^[^:@%/\s.-][^:@%/\s]*[/][^:@\s/%]+(?:#.*)?$/.test(arg10);
  }
  function fixupUnqualifiedGist(giturl) {
    var parsed = url.parse(giturl);
    if (parsed.protocol === "gist:" && parsed.host && !parsed.path) {
      return parsed.protocol + "/" + parsed.host;
    } else {
      return giturl;
    }
  }
  function parseGitUrl(giturl) {
    var matched = giturl.match(/^([^@]+)@([^:/]+):[/]?((?:[^/]+[/])?[^/]+?)(?:[.]git)?(#.*)?$/);
    if (!matched) {
      var legacy = url.parse(giturl);
      if (legacy.auth && typeof url.URL === "function") {
        var authmatch = giturl.match(/[^@]+@[^:/]+/);
        if (authmatch) {
          var whatwg = new url.URL(authmatch[0]);
          legacy.auth = whatwg.username || "";
          if (whatwg.password)
            legacy.auth += ":" + whatwg.password;
        }
      }
      return legacy;
    }
    return {
      protocol: "git+ssh:",
      slashes: true,
      auth: matched[1],
      host: matched[2],
      port: null,
      hostname: matched[2],
      hash: matched[4],
      search: null,
      query: null,
      pathname: "/" + matched[3],
      path: "/" + matched[3],
      href: "git+ssh://" + matched[1] + "@" + matched[2] + "/" + matched[3] + (matched[4] || "")
    };
  }
});

// ../../node_modules/.pnpm/resolve@1.20.0/node_modules/resolve/lib/caller.js
var require_caller = __commonJS((exports2, module2) => {
  module2.exports = function() {
    var origPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = function(_2, stack2) {
      return stack2;
    };
    var stack = new Error().stack;
    Error.prepareStackTrace = origPrepareStackTrace;
    return stack[2].getFileName();
  };
});

// ../../node_modules/.pnpm/path-parse@1.0.7/node_modules/path-parse/index.js
var require_path_parse = __commonJS((exports2, module2) => {
  "use strict";
  var isWindows = process.platform === "win32";
  var splitWindowsRe = /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/;
  var win32 = {};
  function win32SplitPath(filename) {
    return splitWindowsRe.exec(filename).slice(1);
  }
  win32.parse = function(pathString) {
    if (typeof pathString !== "string") {
      throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
    }
    var allParts = win32SplitPath(pathString);
    if (!allParts || allParts.length !== 5) {
      throw new TypeError("Invalid path '" + pathString + "'");
    }
    return {
      root: allParts[1],
      dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
      base: allParts[2],
      ext: allParts[4],
      name: allParts[3]
    };
  };
  var splitPathRe = /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;
  var posix = {};
  function posixSplitPath(filename) {
    return splitPathRe.exec(filename).slice(1);
  }
  posix.parse = function(pathString) {
    if (typeof pathString !== "string") {
      throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
    }
    var allParts = posixSplitPath(pathString);
    if (!allParts || allParts.length !== 5) {
      throw new TypeError("Invalid path '" + pathString + "'");
    }
    return {
      root: allParts[1],
      dir: allParts[0].slice(0, -1),
      base: allParts[2],
      ext: allParts[4],
      name: allParts[3]
    };
  };
  if (isWindows)
    module2.exports = win32.parse;
  else
    module2.exports = posix.parse;
  module2.exports.posix = posix.parse;
  module2.exports.win32 = win32.parse;
});

// ../../node_modules/.pnpm/resolve@1.20.0/node_modules/resolve/lib/node-modules-paths.js
var require_node_modules_paths = __commonJS((exports2, module2) => {
  var path10 = require("path");
  var parse2 = path10.parse || require_path_parse();
  var getNodeModulesDirs = function getNodeModulesDirs2(absoluteStart, modules) {
    var prefix = "/";
    if (/^([A-Za-z]:)/.test(absoluteStart)) {
      prefix = "";
    } else if (/^\\\\/.test(absoluteStart)) {
      prefix = "\\\\";
    }
    var paths = [absoluteStart];
    var parsed = parse2(absoluteStart);
    while (parsed.dir !== paths[paths.length - 1]) {
      paths.push(parsed.dir);
      parsed = parse2(parsed.dir);
    }
    return paths.reduce(function(dirs, aPath) {
      return dirs.concat(modules.map(function(moduleDir) {
        return path10.resolve(prefix, aPath, moduleDir);
      }));
    }, []);
  };
  module2.exports = function nodeModulesPaths(start, opts, request) {
    var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ["node_modules"];
    if (opts && typeof opts.paths === "function") {
      return opts.paths(request, start, function() {
        return getNodeModulesDirs(start, modules);
      }, opts);
    }
    var dirs = getNodeModulesDirs(start, modules);
    return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
  };
});

// ../../node_modules/.pnpm/resolve@1.20.0/node_modules/resolve/lib/normalize-options.js
var require_normalize_options = __commonJS((exports2, module2) => {
  module2.exports = function(x, opts) {
    return opts || {};
  };
});

// ../../node_modules/.pnpm/function-bind@1.1.1/node_modules/function-bind/implementation.js
var require_implementation = __commonJS((exports2, module2) => {
  "use strict";
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var slice = Array.prototype.slice;
  var toStr = Object.prototype.toString;
  var funcType = "[object Function]";
  module2.exports = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.call(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args2 = slice.call(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(this, args2.concat(slice.call(arguments)));
        if (Object(result) === result) {
          return result;
        }
        return this;
      } else {
        return target.apply(that, args2.concat(slice.call(arguments)));
      }
    };
    var boundLength = Math.max(0, target.length - args2.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
      boundArgs.push("$" + i);
    }
    bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
});

// ../../node_modules/.pnpm/function-bind@1.1.1/node_modules/function-bind/index.js
var require_function_bind = __commonJS((exports2, module2) => {
  "use strict";
  var implementation = require_implementation();
  module2.exports = Function.prototype.bind || implementation;
});

// ../../node_modules/.pnpm/has@1.0.3/node_modules/has/src/index.js
var require_src = __commonJS((exports2, module2) => {
  "use strict";
  var bind = require_function_bind();
  module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
});

// ../../node_modules/.pnpm/is-core-module@2.5.0/node_modules/is-core-module/core.json
var require_core2 = __commonJS((exports2, module2) => {
  module2.exports = {
    assert: true,
    "node:assert": ">= 16",
    "assert/strict": ">= 15",
    "node:assert/strict": ">= 16",
    async_hooks: ">= 8",
    "node:async_hooks": ">= 16",
    buffer_ieee754: "< 0.9.7",
    buffer: true,
    "node:buffer": ">= 16",
    child_process: true,
    "node:child_process": ">= 16",
    cluster: true,
    "node:cluster": ">= 16",
    console: true,
    "node:console": ">= 16",
    constants: true,
    "node:constants": ">= 16",
    crypto: true,
    "node:crypto": ">= 16",
    _debug_agent: ">= 1 && < 8",
    _debugger: "< 8",
    dgram: true,
    "node:dgram": ">= 16",
    diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
    "node:diagnostics_channel": ">= 16",
    dns: true,
    "node:dns": ">= 16",
    "dns/promises": ">= 15",
    "node:dns/promises": ">= 16",
    domain: ">= 0.7.12",
    "node:domain": ">= 16",
    events: true,
    "node:events": ">= 16",
    freelist: "< 6",
    fs: true,
    "node:fs": ">= 16",
    "fs/promises": [">= 10 && < 10.1", ">= 14"],
    "node:fs/promises": ">= 16",
    _http_agent: ">= 0.11.1",
    "node:_http_agent": ">= 16",
    _http_client: ">= 0.11.1",
    "node:_http_client": ">= 16",
    _http_common: ">= 0.11.1",
    "node:_http_common": ">= 16",
    _http_incoming: ">= 0.11.1",
    "node:_http_incoming": ">= 16",
    _http_outgoing: ">= 0.11.1",
    "node:_http_outgoing": ">= 16",
    _http_server: ">= 0.11.1",
    "node:_http_server": ">= 16",
    http: true,
    "node:http": ">= 16",
    http2: ">= 8.8",
    "node:http2": ">= 16",
    https: true,
    "node:https": ">= 16",
    inspector: ">= 8",
    "node:inspector": ">= 16",
    _linklist: "< 8",
    module: true,
    "node:module": ">= 16",
    net: true,
    "node:net": ">= 16",
    "node-inspect/lib/_inspect": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
    os: true,
    "node:os": ">= 16",
    path: true,
    "node:path": ">= 16",
    "path/posix": ">= 15.3",
    "node:path/posix": ">= 16",
    "path/win32": ">= 15.3",
    "node:path/win32": ">= 16",
    perf_hooks: ">= 8.5",
    "node:perf_hooks": ">= 16",
    process: ">= 1",
    "node:process": ">= 16",
    punycode: true,
    "node:punycode": ">= 16",
    querystring: true,
    "node:querystring": ">= 16",
    readline: true,
    "node:readline": ">= 16",
    repl: true,
    "node:repl": ">= 16",
    smalloc: ">= 0.11.5 && < 3",
    _stream_duplex: ">= 0.9.4",
    "node:_stream_duplex": ">= 16",
    _stream_transform: ">= 0.9.4",
    "node:_stream_transform": ">= 16",
    _stream_wrap: ">= 1.4.1",
    "node:_stream_wrap": ">= 16",
    _stream_passthrough: ">= 0.9.4",
    "node:_stream_passthrough": ">= 16",
    _stream_readable: ">= 0.9.4",
    "node:_stream_readable": ">= 16",
    _stream_writable: ">= 0.9.4",
    "node:_stream_writable": ">= 16",
    stream: true,
    "node:stream": ">= 16",
    "stream/promises": ">= 15",
    "node:stream/promises": ">= 16",
    "stream/web": ">= 16.5",
    "node:stream/web": ">= 16.5",
    string_decoder: true,
    "node:string_decoder": ">= 16",
    sys: [">= 0.6 && < 0.7", ">= 0.8"],
    "node:sys": ">= 16",
    timers: true,
    "node:timers": ">= 16",
    "timers/promises": ">= 15",
    "node:timers/promises": ">= 16",
    _tls_common: ">= 0.11.13",
    "node:_tls_common": ">= 16",
    _tls_legacy: ">= 0.11.3 && < 10",
    _tls_wrap: ">= 0.11.3",
    "node:_tls_wrap": ">= 16",
    tls: true,
    "node:tls": ">= 16",
    trace_events: ">= 10",
    "node:trace_events": ">= 16",
    tty: true,
    "node:tty": ">= 16",
    url: true,
    "node:url": ">= 16",
    util: true,
    "node:util": ">= 16",
    "util/types": ">= 15.3",
    "node:util/types": ">= 16",
    "v8/tools/arguments": ">= 10 && < 12",
    "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    v8: ">= 1",
    "node:v8": ">= 16",
    vm: true,
    "node:vm": ">= 16",
    wasi: ">= 13.4 && < 13.5",
    worker_threads: ">= 11.7",
    "node:worker_threads": ">= 16",
    zlib: true,
    "node:zlib": ">= 16"
  };
});

// ../../node_modules/.pnpm/is-core-module@2.5.0/node_modules/is-core-module/index.js
var require_is_core_module = __commonJS((exports2, module2) => {
  "use strict";
  var has = require_src();
  function specifierIncluded(current, specifier) {
    var nodeParts = current.split(".");
    var parts = specifier.split(" ");
    var op = parts.length > 1 ? parts[0] : "=";
    var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
    for (var i = 0; i < 3; ++i) {
      var cur = parseInt(nodeParts[i] || 0, 10);
      var ver = parseInt(versionParts[i] || 0, 10);
      if (cur === ver) {
        continue;
      }
      if (op === "<") {
        return cur < ver;
      }
      if (op === ">=") {
        return cur >= ver;
      }
      return false;
    }
    return op === ">=";
  }
  function matchesRange(current, range) {
    var specifiers = range.split(/ ?&& ?/);
    if (specifiers.length === 0) {
      return false;
    }
    for (var i = 0; i < specifiers.length; ++i) {
      if (!specifierIncluded(current, specifiers[i])) {
        return false;
      }
    }
    return true;
  }
  function versionIncluded(nodeVersion, specifierValue) {
    if (typeof specifierValue === "boolean") {
      return specifierValue;
    }
    var current = typeof nodeVersion === "undefined" ? process.versions && process.versions.node && process.versions.node : nodeVersion;
    if (typeof current !== "string") {
      throw new TypeError(typeof nodeVersion === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");
    }
    if (specifierValue && typeof specifierValue === "object") {
      for (var i = 0; i < specifierValue.length; ++i) {
        if (matchesRange(current, specifierValue[i])) {
          return true;
        }
      }
      return false;
    }
    return matchesRange(current, specifierValue);
  }
  var data = require_core2();
  module2.exports = function isCore(x, nodeVersion) {
    return has(data, x) && versionIncluded(nodeVersion, data[x]);
  };
});

// ../../node_modules/.pnpm/resolve@1.20.0/node_modules/resolve/lib/async.js
var require_async = __commonJS((exports2, module2) => {
  var fs9 = require("fs");
  var path10 = require("path");
  var caller = require_caller();
  var nodeModulesPaths = require_node_modules_paths();
  var normalizeOptions = require_normalize_options();
  var isCore = require_is_core_module();
  var realpathFS = fs9.realpath && typeof fs9.realpath.native === "function" ? fs9.realpath.native : fs9.realpath;
  var defaultIsFile = function isFile(file, cb) {
    fs9.stat(file, function(err, stat) {
      if (!err) {
        return cb(null, stat.isFile() || stat.isFIFO());
      }
      if (err.code === "ENOENT" || err.code === "ENOTDIR")
        return cb(null, false);
      return cb(err);
    });
  };
  var defaultIsDir = function isDirectory(dir, cb) {
    fs9.stat(dir, function(err, stat) {
      if (!err) {
        return cb(null, stat.isDirectory());
      }
      if (err.code === "ENOENT" || err.code === "ENOTDIR")
        return cb(null, false);
      return cb(err);
    });
  };
  var defaultRealpath = function realpath(x, cb) {
    realpathFS(x, function(realpathErr, realPath) {
      if (realpathErr && realpathErr.code !== "ENOENT")
        cb(realpathErr);
      else
        cb(null, realpathErr ? x : realPath);
    });
  };
  var maybeRealpath = function maybeRealpath2(realpath, x, opts, cb) {
    if (opts && opts.preserveSymlinks === false) {
      realpath(x, cb);
    } else {
      cb(null, x);
    }
  };
  var defaultReadPackage = function defaultReadPackage2(readFile3, pkgfile, cb) {
    readFile3(pkgfile, function(readFileErr, body) {
      if (readFileErr)
        cb(readFileErr);
      else {
        try {
          var pkg2 = JSON.parse(body);
          cb(null, pkg2);
        } catch (jsonErr) {
          cb(null);
        }
      }
    });
  };
  var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0; i < dirs.length; i++) {
      dirs[i] = path10.join(dirs[i], x);
    }
    return dirs;
  };
  module2.exports = function resolve(x, options, callback) {
    var cb = callback;
    var opts = options;
    if (typeof options === "function") {
      cb = opts;
      opts = {};
    }
    if (typeof x !== "string") {
      var err = new TypeError("Path must be a string.");
      return process.nextTick(function() {
        cb(err);
      });
    }
    opts = normalizeOptions(x, opts);
    var isFile = opts.isFile || defaultIsFile;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var readFile3 = opts.readFile || fs9.readFile;
    var realpath = opts.realpath || defaultRealpath;
    var readPackage = opts.readPackage || defaultReadPackage;
    if (opts.readFile && opts.readPackage) {
      var conflictErr = new TypeError("`readFile` and `readPackage` are mutually exclusive.");
      return process.nextTick(function() {
        cb(conflictErr);
      });
    }
    var packageIterator = opts.packageIterator;
    var extensions = opts.extensions || [".js"];
    var includeCoreModules = opts.includeCoreModules !== false;
    var basedir = opts.basedir || path10.dirname(caller());
    var parent = opts.filename || basedir;
    opts.paths = opts.paths || [];
    var absoluteStart = path10.resolve(basedir);
    maybeRealpath(realpath, absoluteStart, opts, function(err2, realStart) {
      if (err2)
        cb(err2);
      else
        init(realStart);
    });
    var res;
    function init(basedir2) {
      if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
        res = path10.resolve(basedir2, x);
        if (x === "." || x === ".." || x.slice(-1) === "/")
          res += "/";
        if (/\/$/.test(x) && res === basedir2) {
          loadAsDirectory(res, opts.package, onfile);
        } else
          loadAsFile(res, opts.package, onfile);
      } else if (includeCoreModules && isCore(x)) {
        return cb(null, x);
      } else
        loadNodeModules(x, basedir2, function(err2, n, pkg2) {
          if (err2)
            cb(err2);
          else if (n) {
            return maybeRealpath(realpath, n, opts, function(err3, realN) {
              if (err3) {
                cb(err3);
              } else {
                cb(null, realN, pkg2);
              }
            });
          } else {
            var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
            moduleError.code = "MODULE_NOT_FOUND";
            cb(moduleError);
          }
        });
    }
    function onfile(err2, m2, pkg2) {
      if (err2)
        cb(err2);
      else if (m2)
        cb(null, m2, pkg2);
      else
        loadAsDirectory(res, function(err3, d2, pkg3) {
          if (err3)
            cb(err3);
          else if (d2) {
            maybeRealpath(realpath, d2, opts, function(err4, realD) {
              if (err4) {
                cb(err4);
              } else {
                cb(null, realD, pkg3);
              }
            });
          } else {
            var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
            moduleError.code = "MODULE_NOT_FOUND";
            cb(moduleError);
          }
        });
    }
    function loadAsFile(x2, thePackage, callback2) {
      var loadAsFilePackage = thePackage;
      var cb2 = callback2;
      if (typeof loadAsFilePackage === "function") {
        cb2 = loadAsFilePackage;
        loadAsFilePackage = void 0;
      }
      var exts = [""].concat(extensions);
      load2(exts, x2, loadAsFilePackage);
      function load2(exts2, x3, loadPackage) {
        if (exts2.length === 0)
          return cb2(null, void 0, loadPackage);
        var file = x3 + exts2[0];
        var pkg2 = loadPackage;
        if (pkg2)
          onpkg(null, pkg2);
        else
          loadpkg(path10.dirname(file), onpkg);
        function onpkg(err2, pkg_, dir) {
          pkg2 = pkg_;
          if (err2)
            return cb2(err2);
          if (dir && pkg2 && opts.pathFilter) {
            var rfile = path10.relative(dir, file);
            var rel = rfile.slice(0, rfile.length - exts2[0].length);
            var r = opts.pathFilter(pkg2, x3, rel);
            if (r)
              return load2([""].concat(extensions.slice()), path10.resolve(dir, r), pkg2);
          }
          isFile(file, onex);
        }
        function onex(err2, ex) {
          if (err2)
            return cb2(err2);
          if (ex)
            return cb2(null, file, pkg2);
          load2(exts2.slice(1), x3, pkg2);
        }
      }
    }
    function loadpkg(dir, cb2) {
      if (dir === "" || dir === "/")
        return cb2(null);
      if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
        return cb2(null);
      }
      if (/[/\\]node_modules[/\\]*$/.test(dir))
        return cb2(null);
      maybeRealpath(realpath, dir, opts, function(unwrapErr, pkgdir) {
        if (unwrapErr)
          return loadpkg(path10.dirname(dir), cb2);
        var pkgfile = path10.join(pkgdir, "package.json");
        isFile(pkgfile, function(err2, ex) {
          if (!ex)
            return loadpkg(path10.dirname(dir), cb2);
          readPackage(readFile3, pkgfile, function(err3, pkgParam) {
            if (err3)
              cb2(err3);
            var pkg2 = pkgParam;
            if (pkg2 && opts.packageFilter) {
              pkg2 = opts.packageFilter(pkg2, pkgfile);
            }
            cb2(null, pkg2, dir);
          });
        });
      });
    }
    function loadAsDirectory(x2, loadAsDirectoryPackage, callback2) {
      var cb2 = callback2;
      var fpkg = loadAsDirectoryPackage;
      if (typeof fpkg === "function") {
        cb2 = fpkg;
        fpkg = opts.package;
      }
      maybeRealpath(realpath, x2, opts, function(unwrapErr, pkgdir) {
        if (unwrapErr)
          return cb2(unwrapErr);
        var pkgfile = path10.join(pkgdir, "package.json");
        isFile(pkgfile, function(err2, ex) {
          if (err2)
            return cb2(err2);
          if (!ex)
            return loadAsFile(path10.join(x2, "index"), fpkg, cb2);
          readPackage(readFile3, pkgfile, function(err3, pkgParam) {
            if (err3)
              return cb2(err3);
            var pkg2 = pkgParam;
            if (pkg2 && opts.packageFilter) {
              pkg2 = opts.packageFilter(pkg2, pkgfile);
            }
            if (pkg2 && pkg2.main) {
              if (typeof pkg2.main !== "string") {
                var mainError = new TypeError("package \u201C" + pkg2.name + "\u201D `main` must be a string");
                mainError.code = "INVALID_PACKAGE_MAIN";
                return cb2(mainError);
              }
              if (pkg2.main === "." || pkg2.main === "./") {
                pkg2.main = "index";
              }
              loadAsFile(path10.resolve(x2, pkg2.main), pkg2, function(err4, m2, pkg3) {
                if (err4)
                  return cb2(err4);
                if (m2)
                  return cb2(null, m2, pkg3);
                if (!pkg3)
                  return loadAsFile(path10.join(x2, "index"), pkg3, cb2);
                var dir = path10.resolve(x2, pkg3.main);
                loadAsDirectory(dir, pkg3, function(err5, n, pkg4) {
                  if (err5)
                    return cb2(err5);
                  if (n)
                    return cb2(null, n, pkg4);
                  loadAsFile(path10.join(x2, "index"), pkg4, cb2);
                });
              });
              return;
            }
            loadAsFile(path10.join(x2, "/index"), pkg2, cb2);
          });
        });
      });
    }
    function processDirs(cb2, dirs) {
      if (dirs.length === 0)
        return cb2(null, void 0);
      var dir = dirs[0];
      isDirectory(path10.dirname(dir), isdir);
      function isdir(err2, isdir2) {
        if (err2)
          return cb2(err2);
        if (!isdir2)
          return processDirs(cb2, dirs.slice(1));
        loadAsFile(dir, opts.package, onfile2);
      }
      function onfile2(err2, m2, pkg2) {
        if (err2)
          return cb2(err2);
        if (m2)
          return cb2(null, m2, pkg2);
        loadAsDirectory(dir, opts.package, ondir);
      }
      function ondir(err2, n, pkg2) {
        if (err2)
          return cb2(err2);
        if (n)
          return cb2(null, n, pkg2);
        processDirs(cb2, dirs.slice(1));
      }
    }
    function loadNodeModules(x2, start, cb2) {
      var thunk = function() {
        return getPackageCandidates(x2, start, opts);
      };
      processDirs(cb2, packageIterator ? packageIterator(x2, start, thunk, opts) : thunk());
    }
  };
});

// ../../node_modules/.pnpm/resolve@1.20.0/node_modules/resolve/lib/core.json
var require_core3 = __commonJS((exports2, module2) => {
  module2.exports = {
    assert: true,
    "assert/strict": ">= 15",
    async_hooks: ">= 8",
    buffer_ieee754: "< 0.9.7",
    buffer: true,
    child_process: true,
    cluster: true,
    console: true,
    constants: true,
    crypto: true,
    _debug_agent: ">= 1 && < 8",
    _debugger: "< 8",
    dgram: true,
    diagnostics_channel: ">= 15.1",
    dns: true,
    "dns/promises": ">= 15",
    domain: ">= 0.7.12",
    events: true,
    freelist: "< 6",
    fs: true,
    "fs/promises": [">= 10 && < 10.1", ">= 14"],
    _http_agent: ">= 0.11.1",
    _http_client: ">= 0.11.1",
    _http_common: ">= 0.11.1",
    _http_incoming: ">= 0.11.1",
    _http_outgoing: ">= 0.11.1",
    _http_server: ">= 0.11.1",
    http: true,
    http2: ">= 8.8",
    https: true,
    inspector: ">= 8.0.0",
    _linklist: "< 8",
    module: true,
    net: true,
    "node-inspect/lib/_inspect": ">= 7.6.0 && < 12",
    "node-inspect/lib/internal/inspect_client": ">= 7.6.0 && < 12",
    "node-inspect/lib/internal/inspect_repl": ">= 7.6.0 && < 12",
    os: true,
    path: true,
    "path/posix": ">= 15.3",
    "path/win32": ">= 15.3",
    perf_hooks: ">= 8.5",
    process: ">= 1",
    punycode: true,
    querystring: true,
    readline: true,
    repl: true,
    smalloc: ">= 0.11.5 && < 3",
    _stream_duplex: ">= 0.9.4",
    _stream_transform: ">= 0.9.4",
    _stream_wrap: ">= 1.4.1",
    _stream_passthrough: ">= 0.9.4",
    _stream_readable: ">= 0.9.4",
    _stream_writable: ">= 0.9.4",
    stream: true,
    "stream/promises": ">= 15",
    string_decoder: true,
    sys: [">= 0.6 && < 0.7", ">= 0.8"],
    timers: true,
    "timers/promises": ">= 15",
    _tls_common: ">= 0.11.13",
    _tls_legacy: ">= 0.11.3 && < 10",
    _tls_wrap: ">= 0.11.3",
    tls: true,
    trace_events: ">= 10",
    tty: true,
    url: true,
    util: true,
    "util/types": ">= 15.3",
    "v8/tools/arguments": ">= 10 && < 12",
    "v8/tools/codemap": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    "v8/tools/consarray": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    "v8/tools/csvparser": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    "v8/tools/logreader": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    "v8/tools/profile_view": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    "v8/tools/splaytree": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    v8: ">= 1",
    vm: true,
    wasi: ">= 13.4 && < 13.5",
    worker_threads: ">= 11.7",
    zlib: true
  };
});

// ../../node_modules/.pnpm/resolve@1.20.0/node_modules/resolve/lib/core.js
var require_core4 = __commonJS((exports2, module2) => {
  var current = process.versions && process.versions.node && process.versions.node.split(".") || [];
  function specifierIncluded(specifier) {
    var parts = specifier.split(" ");
    var op = parts.length > 1 ? parts[0] : "=";
    var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
    for (var i = 0; i < 3; ++i) {
      var cur = parseInt(current[i] || 0, 10);
      var ver = parseInt(versionParts[i] || 0, 10);
      if (cur === ver) {
        continue;
      }
      if (op === "<") {
        return cur < ver;
      } else if (op === ">=") {
        return cur >= ver;
      } else {
        return false;
      }
    }
    return op === ">=";
  }
  function matchesRange(range) {
    var specifiers = range.split(/ ?&& ?/);
    if (specifiers.length === 0) {
      return false;
    }
    for (var i = 0; i < specifiers.length; ++i) {
      if (!specifierIncluded(specifiers[i])) {
        return false;
      }
    }
    return true;
  }
  function versionIncluded(specifierValue) {
    if (typeof specifierValue === "boolean") {
      return specifierValue;
    }
    if (specifierValue && typeof specifierValue === "object") {
      for (var i = 0; i < specifierValue.length; ++i) {
        if (matchesRange(specifierValue[i])) {
          return true;
        }
      }
      return false;
    }
    return matchesRange(specifierValue);
  }
  var data = require_core3();
  var core = {};
  for (var mod in data) {
    if (Object.prototype.hasOwnProperty.call(data, mod)) {
      core[mod] = versionIncluded(data[mod]);
    }
  }
  module2.exports = core;
});

// ../../node_modules/.pnpm/resolve@1.20.0/node_modules/resolve/lib/is-core.js
var require_is_core = __commonJS((exports2, module2) => {
  var isCoreModule = require_is_core_module();
  module2.exports = function isCore(x) {
    return isCoreModule(x);
  };
});

// ../../node_modules/.pnpm/resolve@1.20.0/node_modules/resolve/lib/sync.js
var require_sync = __commonJS((exports2, module2) => {
  var isCore = require_is_core_module();
  var fs9 = require("fs");
  var path10 = require("path");
  var caller = require_caller();
  var nodeModulesPaths = require_node_modules_paths();
  var normalizeOptions = require_normalize_options();
  var realpathFS = fs9.realpathSync && typeof fs9.realpathSync.native === "function" ? fs9.realpathSync.native : fs9.realpathSync;
  var defaultIsFile = function isFile(file) {
    try {
      var stat = fs9.statSync(file);
    } catch (e) {
      if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
        return false;
      throw e;
    }
    return stat.isFile() || stat.isFIFO();
  };
  var defaultIsDir = function isDirectory(dir) {
    try {
      var stat = fs9.statSync(dir);
    } catch (e) {
      if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
        return false;
      throw e;
    }
    return stat.isDirectory();
  };
  var defaultRealpathSync = function realpathSync(x) {
    try {
      return realpathFS(x);
    } catch (realpathErr) {
      if (realpathErr.code !== "ENOENT") {
        throw realpathErr;
      }
    }
    return x;
  };
  var maybeRealpathSync = function maybeRealpathSync2(realpathSync, x, opts) {
    if (opts && opts.preserveSymlinks === false) {
      return realpathSync(x);
    }
    return x;
  };
  var defaultReadPackageSync = function defaultReadPackageSync2(readFileSync, pkgfile) {
    var body = readFileSync(pkgfile);
    try {
      var pkg2 = JSON.parse(body);
      return pkg2;
    } catch (jsonErr) {
    }
  };
  var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0; i < dirs.length; i++) {
      dirs[i] = path10.join(dirs[i], x);
    }
    return dirs;
  };
  module2.exports = function resolveSync(x, options) {
    if (typeof x !== "string") {
      throw new TypeError("Path must be a string.");
    }
    var opts = normalizeOptions(x, options);
    var isFile = opts.isFile || defaultIsFile;
    var readFileSync = opts.readFileSync || fs9.readFileSync;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var realpathSync = opts.realpathSync || defaultRealpathSync;
    var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
    if (opts.readFileSync && opts.readPackageSync) {
      throw new TypeError("`readFileSync` and `readPackageSync` are mutually exclusive.");
    }
    var packageIterator = opts.packageIterator;
    var extensions = opts.extensions || [".js"];
    var includeCoreModules = opts.includeCoreModules !== false;
    var basedir = opts.basedir || path10.dirname(caller());
    var parent = opts.filename || basedir;
    opts.paths = opts.paths || [];
    var absoluteStart = maybeRealpathSync(realpathSync, path10.resolve(basedir), opts);
    if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
      var res = path10.resolve(absoluteStart, x);
      if (x === "." || x === ".." || x.slice(-1) === "/")
        res += "/";
      var m2 = loadAsFileSync(res) || loadAsDirectorySync(res);
      if (m2)
        return maybeRealpathSync(realpathSync, m2, opts);
    } else if (includeCoreModules && isCore(x)) {
      return x;
    } else {
      var n = loadNodeModulesSync(x, absoluteStart);
      if (n)
        return maybeRealpathSync(realpathSync, n, opts);
    }
    var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
    err.code = "MODULE_NOT_FOUND";
    throw err;
    function loadAsFileSync(x2) {
      var pkg2 = loadpkg(path10.dirname(x2));
      if (pkg2 && pkg2.dir && pkg2.pkg && opts.pathFilter) {
        var rfile = path10.relative(pkg2.dir, x2);
        var r = opts.pathFilter(pkg2.pkg, x2, rfile);
        if (r) {
          x2 = path10.resolve(pkg2.dir, r);
        }
      }
      if (isFile(x2)) {
        return x2;
      }
      for (var i = 0; i < extensions.length; i++) {
        var file = x2 + extensions[i];
        if (isFile(file)) {
          return file;
        }
      }
    }
    function loadpkg(dir) {
      if (dir === "" || dir === "/")
        return;
      if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
        return;
      }
      if (/[/\\]node_modules[/\\]*$/.test(dir))
        return;
      var pkgfile = path10.join(maybeRealpathSync(realpathSync, dir, opts), "package.json");
      if (!isFile(pkgfile)) {
        return loadpkg(path10.dirname(dir));
      }
      var pkg2 = readPackageSync(readFileSync, pkgfile);
      if (pkg2 && opts.packageFilter) {
        pkg2 = opts.packageFilter(pkg2, dir);
      }
      return {pkg: pkg2, dir};
    }
    function loadAsDirectorySync(x2) {
      var pkgfile = path10.join(maybeRealpathSync(realpathSync, x2, opts), "/package.json");
      if (isFile(pkgfile)) {
        try {
          var pkg2 = readPackageSync(readFileSync, pkgfile);
        } catch (e) {
        }
        if (pkg2 && opts.packageFilter) {
          pkg2 = opts.packageFilter(pkg2, x2);
        }
        if (pkg2 && pkg2.main) {
          if (typeof pkg2.main !== "string") {
            var mainError = new TypeError("package \u201C" + pkg2.name + "\u201D `main` must be a string");
            mainError.code = "INVALID_PACKAGE_MAIN";
            throw mainError;
          }
          if (pkg2.main === "." || pkg2.main === "./") {
            pkg2.main = "index";
          }
          try {
            var m3 = loadAsFileSync(path10.resolve(x2, pkg2.main));
            if (m3)
              return m3;
            var n2 = loadAsDirectorySync(path10.resolve(x2, pkg2.main));
            if (n2)
              return n2;
          } catch (e) {
          }
        }
      }
      return loadAsFileSync(path10.join(x2, "/index"));
    }
    function loadNodeModulesSync(x2, start) {
      var thunk = function() {
        return getPackageCandidates(x2, start, opts);
      };
      var dirs = packageIterator ? packageIterator(x2, start, thunk, opts) : thunk();
      for (var i = 0; i < dirs.length; i++) {
        var dir = dirs[i];
        if (isDirectory(path10.dirname(dir))) {
          var m3 = loadAsFileSync(dir);
          if (m3)
            return m3;
          var n2 = loadAsDirectorySync(dir);
          if (n2)
            return n2;
        }
      }
    }
  };
});

// ../../node_modules/.pnpm/resolve@1.20.0/node_modules/resolve/index.js
var require_resolve = __commonJS((exports2, module2) => {
  var async = require_async();
  async.core = require_core4();
  async.isCore = require_is_core();
  async.sync = require_sync();
  module2.exports = async;
});

// ../../node_modules/.pnpm/normalize-package-data@2.5.0/node_modules/normalize-package-data/lib/extract_description.js
var require_extract_description = __commonJS((exports2, module2) => {
  module2.exports = extractDescription;
  function extractDescription(d2) {
    if (!d2)
      return;
    if (d2 === "ERROR: No README data found!")
      return;
    d2 = d2.trim().split("\n");
    for (var s2 = 0; d2[s2] && d2[s2].trim().match(/^(#|$)/); s2++)
      ;
    var l = d2.length;
    for (var e = s2 + 1; e < l && d2[e].trim(); e++)
      ;
    return d2.slice(s2, e).join(" ").trim();
  }
});

// ../../node_modules/.pnpm/normalize-package-data@2.5.0/node_modules/normalize-package-data/lib/typos.json
var require_typos = __commonJS((exports2, module2) => {
  module2.exports = {
    topLevel: {
      dependancies: "dependencies",
      dependecies: "dependencies",
      depdenencies: "dependencies",
      devEependencies: "devDependencies",
      depends: "dependencies",
      "dev-dependencies": "devDependencies",
      devDependences: "devDependencies",
      devDepenencies: "devDependencies",
      devdependencies: "devDependencies",
      repostitory: "repository",
      repo: "repository",
      prefereGlobal: "preferGlobal",
      hompage: "homepage",
      hampage: "homepage",
      autohr: "author",
      autor: "author",
      contributers: "contributors",
      publicationConfig: "publishConfig",
      script: "scripts"
    },
    bugs: {web: "url", name: "url"},
    script: {server: "start", tests: "test"}
  };
});

// ../../node_modules/.pnpm/normalize-package-data@2.5.0/node_modules/normalize-package-data/lib/fixer.js
var require_fixer = __commonJS((exports2, module2) => {
  var semver2 = require_semver();
  var validateLicense = require_validate_npm_package_license();
  var hostedGitInfo = require_hosted_git_info();
  var isBuiltinModule = require_resolve().isCore;
  var depTypes = ["dependencies", "devDependencies", "optionalDependencies"];
  var extractDescription = require_extract_description();
  var url = require("url");
  var typos = require_typos();
  var fixer = module2.exports = {
    warn: function() {
    },
    fixRepositoryField: function(data) {
      if (data.repositories) {
        this.warn("repositories");
        data.repository = data.repositories[0];
      }
      if (!data.repository)
        return this.warn("missingRepository");
      if (typeof data.repository === "string") {
        data.repository = {
          type: "git",
          url: data.repository
        };
      }
      var r = data.repository.url || "";
      if (r) {
        var hosted = hostedGitInfo.fromUrl(r);
        if (hosted) {
          r = data.repository.url = hosted.getDefaultRepresentation() == "shortcut" ? hosted.https() : hosted.toString();
        }
      }
      if (r.match(/github.com\/[^\/]+\/[^\/]+\.git\.git$/)) {
        this.warn("brokenGitUrl", r);
      }
    },
    fixTypos: function(data) {
      Object.keys(typos.topLevel).forEach(function(d2) {
        if (data.hasOwnProperty(d2)) {
          this.warn("typo", d2, typos.topLevel[d2]);
        }
      }, this);
    },
    fixScriptsField: function(data) {
      if (!data.scripts)
        return;
      if (typeof data.scripts !== "object") {
        this.warn("nonObjectScripts");
        delete data.scripts;
        return;
      }
      Object.keys(data.scripts).forEach(function(k) {
        if (typeof data.scripts[k] !== "string") {
          this.warn("nonStringScript");
          delete data.scripts[k];
        } else if (typos.script[k] && !data.scripts[typos.script[k]]) {
          this.warn("typo", k, typos.script[k], "scripts");
        }
      }, this);
    },
    fixFilesField: function(data) {
      var files = data.files;
      if (files && !Array.isArray(files)) {
        this.warn("nonArrayFiles");
        delete data.files;
      } else if (data.files) {
        data.files = data.files.filter(function(file) {
          if (!file || typeof file !== "string") {
            this.warn("invalidFilename", file);
            return false;
          } else {
            return true;
          }
        }, this);
      }
    },
    fixBinField: function(data) {
      if (!data.bin)
        return;
      if (typeof data.bin === "string") {
        var b = {};
        var match;
        if (match = data.name.match(/^@[^/]+[/](.*)$/)) {
          b[match[1]] = data.bin;
        } else {
          b[data.name] = data.bin;
        }
        data.bin = b;
      }
    },
    fixManField: function(data) {
      if (!data.man)
        return;
      if (typeof data.man === "string") {
        data.man = [data.man];
      }
    },
    fixBundleDependenciesField: function(data) {
      var bdd = "bundledDependencies";
      var bd = "bundleDependencies";
      if (data[bdd] && !data[bd]) {
        data[bd] = data[bdd];
        delete data[bdd];
      }
      if (data[bd] && !Array.isArray(data[bd])) {
        this.warn("nonArrayBundleDependencies");
        delete data[bd];
      } else if (data[bd]) {
        data[bd] = data[bd].filter(function(bd2) {
          if (!bd2 || typeof bd2 !== "string") {
            this.warn("nonStringBundleDependency", bd2);
            return false;
          } else {
            if (!data.dependencies) {
              data.dependencies = {};
            }
            if (!data.dependencies.hasOwnProperty(bd2)) {
              this.warn("nonDependencyBundleDependency", bd2);
              data.dependencies[bd2] = "*";
            }
            return true;
          }
        }, this);
      }
    },
    fixDependencies: function(data, strict) {
      var loose = !strict;
      objectifyDeps(data, this.warn);
      addOptionalDepsToDeps(data, this.warn);
      this.fixBundleDependenciesField(data);
      ["dependencies", "devDependencies"].forEach(function(deps) {
        if (!(deps in data))
          return;
        if (!data[deps] || typeof data[deps] !== "object") {
          this.warn("nonObjectDependencies", deps);
          delete data[deps];
          return;
        }
        Object.keys(data[deps]).forEach(function(d2) {
          var r = data[deps][d2];
          if (typeof r !== "string") {
            this.warn("nonStringDependency", d2, JSON.stringify(r));
            delete data[deps][d2];
          }
          var hosted = hostedGitInfo.fromUrl(data[deps][d2]);
          if (hosted)
            data[deps][d2] = hosted.toString();
        }, this);
      }, this);
    },
    fixModulesField: function(data) {
      if (data.modules) {
        this.warn("deprecatedModules");
        delete data.modules;
      }
    },
    fixKeywordsField: function(data) {
      if (typeof data.keywords === "string") {
        data.keywords = data.keywords.split(/,\s+/);
      }
      if (data.keywords && !Array.isArray(data.keywords)) {
        delete data.keywords;
        this.warn("nonArrayKeywords");
      } else if (data.keywords) {
        data.keywords = data.keywords.filter(function(kw) {
          if (typeof kw !== "string" || !kw) {
            this.warn("nonStringKeyword");
            return false;
          } else {
            return true;
          }
        }, this);
      }
    },
    fixVersionField: function(data, strict) {
      var loose = !strict;
      if (!data.version) {
        data.version = "";
        return true;
      }
      if (!semver2.valid(data.version, loose)) {
        throw new Error('Invalid version: "' + data.version + '"');
      }
      data.version = semver2.clean(data.version, loose);
      return true;
    },
    fixPeople: function(data) {
      modifyPeople(data, unParsePerson);
      modifyPeople(data, parsePerson);
    },
    fixNameField: function(data, options) {
      if (typeof options === "boolean")
        options = {strict: options};
      else if (typeof options === "undefined")
        options = {};
      var strict = options.strict;
      if (!data.name && !strict) {
        data.name = "";
        return;
      }
      if (typeof data.name !== "string") {
        throw new Error("name field must be a string.");
      }
      if (!strict)
        data.name = data.name.trim();
      ensureValidName(data.name, strict, options.allowLegacyCase);
      if (isBuiltinModule(data.name))
        this.warn("conflictingName", data.name);
    },
    fixDescriptionField: function(data) {
      if (data.description && typeof data.description !== "string") {
        this.warn("nonStringDescription");
        delete data.description;
      }
      if (data.readme && !data.description)
        data.description = extractDescription(data.readme);
      if (data.description === void 0)
        delete data.description;
      if (!data.description)
        this.warn("missingDescription");
    },
    fixReadmeField: function(data) {
      if (!data.readme) {
        this.warn("missingReadme");
        data.readme = "ERROR: No README data found!";
      }
    },
    fixBugsField: function(data) {
      if (!data.bugs && data.repository && data.repository.url) {
        var hosted = hostedGitInfo.fromUrl(data.repository.url);
        if (hosted && hosted.bugs()) {
          data.bugs = {url: hosted.bugs()};
        }
      } else if (data.bugs) {
        var emailRe = /^.+@.*\..+$/;
        if (typeof data.bugs == "string") {
          if (emailRe.test(data.bugs))
            data.bugs = {email: data.bugs};
          else if (url.parse(data.bugs).protocol)
            data.bugs = {url: data.bugs};
          else
            this.warn("nonEmailUrlBugsString");
        } else {
          bugsTypos(data.bugs, this.warn);
          var oldBugs = data.bugs;
          data.bugs = {};
          if (oldBugs.url) {
            if (typeof oldBugs.url == "string" && url.parse(oldBugs.url).protocol)
              data.bugs.url = oldBugs.url;
            else
              this.warn("nonUrlBugsUrlField");
          }
          if (oldBugs.email) {
            if (typeof oldBugs.email == "string" && emailRe.test(oldBugs.email))
              data.bugs.email = oldBugs.email;
            else
              this.warn("nonEmailBugsEmailField");
          }
        }
        if (!data.bugs.email && !data.bugs.url) {
          delete data.bugs;
          this.warn("emptyNormalizedBugs");
        }
      }
    },
    fixHomepageField: function(data) {
      if (!data.homepage && data.repository && data.repository.url) {
        var hosted = hostedGitInfo.fromUrl(data.repository.url);
        if (hosted && hosted.docs())
          data.homepage = hosted.docs();
      }
      if (!data.homepage)
        return;
      if (typeof data.homepage !== "string") {
        this.warn("nonUrlHomepage");
        return delete data.homepage;
      }
      if (!url.parse(data.homepage).protocol) {
        data.homepage = "http://" + data.homepage;
      }
    },
    fixLicenseField: function(data) {
      if (!data.license) {
        return this.warn("missingLicense");
      } else {
        if (typeof data.license !== "string" || data.license.length < 1 || data.license.trim() === "") {
          this.warn("invalidLicense");
        } else {
          if (!validateLicense(data.license).validForNewPackages)
            this.warn("invalidLicense");
        }
      }
    }
  };
  function isValidScopedPackageName(spec) {
    if (spec.charAt(0) !== "@")
      return false;
    var rest = spec.slice(1).split("/");
    if (rest.length !== 2)
      return false;
    return rest[0] && rest[1] && rest[0] === encodeURIComponent(rest[0]) && rest[1] === encodeURIComponent(rest[1]);
  }
  function isCorrectlyEncodedName(spec) {
    return !spec.match(/[\/@\s\+%:]/) && spec === encodeURIComponent(spec);
  }
  function ensureValidName(name, strict, allowLegacyCase) {
    if (name.charAt(0) === "." || !(isValidScopedPackageName(name) || isCorrectlyEncodedName(name)) || strict && !allowLegacyCase && name !== name.toLowerCase() || name.toLowerCase() === "node_modules" || name.toLowerCase() === "favicon.ico") {
      throw new Error("Invalid name: " + JSON.stringify(name));
    }
  }
  function modifyPeople(data, fn) {
    if (data.author)
      data.author = fn(data.author);
    ["maintainers", "contributors"].forEach(function(set) {
      if (!Array.isArray(data[set]))
        return;
      data[set] = data[set].map(fn);
    });
    return data;
  }
  function unParsePerson(person) {
    if (typeof person === "string")
      return person;
    var name = person.name || "";
    var u = person.url || person.web;
    var url2 = u ? " (" + u + ")" : "";
    var e = person.email || person.mail;
    var email = e ? " <" + e + ">" : "";
    return name + email + url2;
  }
  function parsePerson(person) {
    if (typeof person !== "string")
      return person;
    var name = person.match(/^([^\(<]+)/);
    var url2 = person.match(/\(([^\)]+)\)/);
    var email = person.match(/<([^>]+)>/);
    var obj = {};
    if (name && name[0].trim())
      obj.name = name[0].trim();
    if (email)
      obj.email = email[1];
    if (url2)
      obj.url = url2[1];
    return obj;
  }
  function addOptionalDepsToDeps(data, warn) {
    var o = data.optionalDependencies;
    if (!o)
      return;
    var d2 = data.dependencies || {};
    Object.keys(o).forEach(function(k) {
      d2[k] = o[k];
    });
    data.dependencies = d2;
  }
  function depObjectify(deps, type, warn) {
    if (!deps)
      return {};
    if (typeof deps === "string") {
      deps = deps.trim().split(/[\n\r\s\t ,]+/);
    }
    if (!Array.isArray(deps))
      return deps;
    warn("deprecatedArrayDependencies", type);
    var o = {};
    deps.filter(function(d2) {
      return typeof d2 === "string";
    }).forEach(function(d2) {
      d2 = d2.trim().split(/(:?[@\s><=])/);
      var dn = d2.shift();
      var dv = d2.join("");
      dv = dv.trim();
      dv = dv.replace(/^@/, "");
      o[dn] = dv;
    });
    return o;
  }
  function objectifyDeps(data, warn) {
    depTypes.forEach(function(type) {
      if (!data[type])
        return;
      data[type] = depObjectify(data[type], type, warn);
    });
  }
  function bugsTypos(bugs, warn) {
    if (!bugs)
      return;
    Object.keys(bugs).forEach(function(k) {
      if (typos.bugs[k]) {
        warn("typo", k, typos.bugs[k], "bugs");
        bugs[typos.bugs[k]] = bugs[k];
        delete bugs[k];
      }
    });
  }
});

// ../../node_modules/.pnpm/normalize-package-data@2.5.0/node_modules/normalize-package-data/lib/warning_messages.json
var require_warning_messages = __commonJS((exports2, module2) => {
  module2.exports = {
    repositories: "'repositories' (plural) Not supported. Please pick one as the 'repository' field",
    missingRepository: "No repository field.",
    brokenGitUrl: "Probably broken git url: %s",
    nonObjectScripts: "scripts must be an object",
    nonStringScript: "script values must be string commands",
    nonArrayFiles: "Invalid 'files' member",
    invalidFilename: "Invalid filename in 'files' list: %s",
    nonArrayBundleDependencies: "Invalid 'bundleDependencies' list. Must be array of package names",
    nonStringBundleDependency: "Invalid bundleDependencies member: %s",
    nonDependencyBundleDependency: "Non-dependency in bundleDependencies: %s",
    nonObjectDependencies: "%s field must be an object",
    nonStringDependency: "Invalid dependency: %s %s",
    deprecatedArrayDependencies: "specifying %s as array is deprecated",
    deprecatedModules: "modules field is deprecated",
    nonArrayKeywords: "keywords should be an array of strings",
    nonStringKeyword: "keywords should be an array of strings",
    conflictingName: "%s is also the name of a node core module.",
    nonStringDescription: "'description' field should be a string",
    missingDescription: "No description",
    missingReadme: "No README data",
    missingLicense: "No license field.",
    nonEmailUrlBugsString: "Bug string field must be url, email, or {email,url}",
    nonUrlBugsUrlField: "bugs.url field must be a string url. Deleted.",
    nonEmailBugsEmailField: "bugs.email field must be a string email. Deleted.",
    emptyNormalizedBugs: "Normalized value of bugs field is an empty object. Deleted.",
    nonUrlHomepage: "homepage field must be a string url. Deleted.",
    invalidLicense: "license should be a valid SPDX license expression",
    typo: "%s should probably be %s."
  };
});

// ../../node_modules/.pnpm/normalize-package-data@2.5.0/node_modules/normalize-package-data/lib/make_warning.js
var require_make_warning = __commonJS((exports2, module2) => {
  var util2 = require("util");
  var messages = require_warning_messages();
  module2.exports = function() {
    var args2 = Array.prototype.slice.call(arguments, 0);
    var warningName = args2.shift();
    if (warningName == "typo") {
      return makeTypoWarning.apply(null, args2);
    } else {
      var msgTemplate = messages[warningName] ? messages[warningName] : warningName + ": '%s'";
      args2.unshift(msgTemplate);
      return util2.format.apply(null, args2);
    }
  };
  function makeTypoWarning(providedName, probableName, field) {
    if (field) {
      providedName = field + "['" + providedName + "']";
      probableName = field + "['" + probableName + "']";
    }
    return util2.format(messages.typo, providedName, probableName);
  }
});

// ../../node_modules/.pnpm/normalize-package-data@2.5.0/node_modules/normalize-package-data/lib/normalize.js
var require_normalize = __commonJS((exports2, module2) => {
  module2.exports = normalize;
  var fixer = require_fixer();
  normalize.fixer = fixer;
  var makeWarning = require_make_warning();
  var fieldsToFix = [
    "name",
    "version",
    "description",
    "repository",
    "modules",
    "scripts",
    "files",
    "bin",
    "man",
    "bugs",
    "keywords",
    "readme",
    "homepage",
    "license"
  ];
  var otherThingsToFix = ["dependencies", "people", "typos"];
  var thingsToFix = fieldsToFix.map(function(fieldName) {
    return ucFirst(fieldName) + "Field";
  });
  thingsToFix = thingsToFix.concat(otherThingsToFix);
  function normalize(data, warn, strict) {
    if (warn === true)
      warn = null, strict = true;
    if (!strict)
      strict = false;
    if (!warn || data.private)
      warn = function(msg) {
      };
    if (data.scripts && data.scripts.install === "node-gyp rebuild" && !data.scripts.preinstall) {
      data.gypfile = true;
    }
    fixer.warn = function() {
      warn(makeWarning.apply(null, arguments));
    };
    thingsToFix.forEach(function(thingName) {
      fixer["fix" + ucFirst(thingName)](data, strict);
    });
    data._id = data.name + "@" + data.version;
  }
  function ucFirst(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
  }
});

// ../../node_modules/.pnpm/read-pkg@5.2.0/node_modules/read-pkg/index.js
var require_read_pkg = __commonJS((exports2, module2) => {
  "use strict";
  var {promisify: promisify4} = require("util");
  var fs9 = require("fs");
  var path10 = require("path");
  var parseJson = require_parse_json();
  var readFileAsync2 = promisify4(fs9.readFile);
  module2.exports = async (options) => {
    options = {
      cwd: process.cwd(),
      normalize: true,
      ...options
    };
    const filePath = path10.resolve(options.cwd, "package.json");
    const json = parseJson(await readFileAsync2(filePath, "utf8"));
    if (options.normalize) {
      require_normalize()(json);
    }
    return json;
  };
  module2.exports.sync = (options) => {
    options = {
      cwd: process.cwd(),
      normalize: true,
      ...options
    };
    const filePath = path10.resolve(options.cwd, "package.json");
    const json = parseJson(fs9.readFileSync(filePath, "utf8"));
    if (options.normalize) {
      require_normalize()(json);
    }
    return json;
  };
});

// ../../node_modules/.pnpm/read-pkg-up@7.0.1/node_modules/read-pkg-up/index.js
var require_read_pkg_up = __commonJS((exports2, module2) => {
  "use strict";
  var path10 = require("path");
  var findUp = require_find_up();
  var readPkg = require_read_pkg();
  module2.exports = async (options) => {
    const filePath = await findUp("package.json", options);
    if (!filePath) {
      return;
    }
    return {
      packageJson: await readPkg({...options, cwd: path10.dirname(filePath)}),
      path: filePath
    };
  };
  module2.exports.sync = (options) => {
    const filePath = findUp.sync("package.json", options);
    if (!filePath) {
      return;
    }
    return {
      packageJson: readPkg.sync({...options, cwd: path10.dirname(filePath)}),
      path: filePath
    };
  };
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/cli/getSchema.js
var require_getSchema = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    getRelativeSchemaPath: () => getRelativeSchemaPath2,
    getSchema: () => getSchema4,
    getSchemaDir: () => getSchemaDir2,
    getSchemaDirSync: () => getSchemaDirSync2,
    getSchemaPath: () => getSchemaPath7,
    getSchemaPathFromPackageJson: () => getSchemaPathFromPackageJson2,
    getSchemaPathFromPackageJsonSync: () => getSchemaPathFromPackageJsonSync2,
    getSchemaPathInternal: () => getSchemaPathInternal,
    getSchemaPathSync: () => getSchemaPathSync2,
    getSchemaPathSyncInternal: () => getSchemaPathSyncInternal,
    getSchemaSync: () => getSchemaSync2
  });
  var import_chalk14 = __toModule3(require_source());
  var import_execa2 = __toModule3(require_execa());
  var import_fs9 = __toModule3(require("fs"));
  var import_path10 = __toModule3(require("path"));
  var import_read_pkg_up = __toModule3(require_read_pkg_up());
  var import_util6 = __toModule3(require("util"));
  var exists2 = (0, import_util6.promisify)(import_fs9.default.exists);
  var readFile3 = (0, import_util6.promisify)(import_fs9.default.readFile);
  async function getSchemaPath7(schemaPathFromArgs, opts = {
    cwd: process.cwd()
  }) {
    return getSchemaPathInternal(schemaPathFromArgs, {
      cwd: opts.cwd
    });
  }
  async function getSchemaPathInternal(schemaPathFromArgs, opts = {
    cwd: process.cwd()
  }) {
    var _a, _b;
    if (schemaPathFromArgs) {
      const customSchemaPath = await getAbsoluteSchemaPath(import_path10.default.resolve(schemaPathFromArgs));
      if (!customSchemaPath) {
        throw new Error(`Provided --schema at ${schemaPathFromArgs} doesn't exist.`);
      }
      return customSchemaPath;
    }
    const schemaPath = (_b = (_a = await getSchemaPathFromPackageJson2(opts.cwd)) != null ? _a : await getRelativeSchemaPath2(opts.cwd)) != null ? _b : await resolveYarnSchema(opts.cwd);
    if (schemaPath) {
      return schemaPath;
    }
    return null;
  }
  async function getSchemaPathFromPackageJson2(cwd) {
    var _a, _b;
    const pkgJson = await (0, import_read_pkg_up.default)({cwd});
    const schemaPathFromPkgJson = (_b = (_a = pkgJson == null ? void 0 : pkgJson.packageJson) == null ? void 0 : _a.prisma) == null ? void 0 : _b.schema;
    if (!schemaPathFromPkgJson || !pkgJson) {
      return null;
    }
    if (typeof schemaPathFromPkgJson !== "string") {
      throw new Error(`Provided schema path \`${schemaPathFromPkgJson}\` from \`${import_path10.default.relative(cwd, pkgJson.path)}\` must be of type string`);
    }
    const absoluteSchemaPath = import_path10.default.isAbsolute(schemaPathFromPkgJson) ? schemaPathFromPkgJson : import_path10.default.resolve(import_path10.default.dirname(pkgJson.path), schemaPathFromPkgJson);
    if (await exists2(absoluteSchemaPath) === false) {
      throw new Error(`Provided schema path \`${import_path10.default.relative(cwd, absoluteSchemaPath)}\` from \`${import_path10.default.relative(cwd, pkgJson.path)}\` doesn't exist.`);
    }
    return absoluteSchemaPath;
  }
  async function resolveYarnSchema(cwd) {
    var _a, _b, _c;
    if ((_a = process.env.npm_config_user_agent) == null ? void 0 : _a.includes("yarn")) {
      try {
        const {stdout: version} = await import_execa2.default.command("yarn --version", {
          cwd
        });
        if (version.startsWith("2")) {
          return null;
        }
        const {stdout} = await import_execa2.default.command("yarn workspaces info --json", {
          cwd
        });
        const json = getJson(stdout);
        const workspaces = Object.values(json);
        const workspaceRootDir = await findWorkspaceRoot(cwd);
        if (!workspaceRootDir) {
          return null;
        }
        for (const workspace of workspaces) {
          const workspacePath = import_path10.default.join(workspaceRootDir, workspace.location);
          const workspaceSchemaPath = (_b = getSchemaPathFromPackageJsonSync2(workspacePath)) != null ? _b : getRelativeSchemaPathSync(workspacePath);
          if (workspaceSchemaPath) {
            return workspaceSchemaPath;
          }
        }
        const workspaceSchemaPathFromRoot = (_c = getSchemaPathFromPackageJsonSync2(workspaceRootDir)) != null ? _c : getRelativeSchemaPathSync(workspaceRootDir);
        if (workspaceSchemaPathFromRoot) {
          return workspaceSchemaPathFromRoot;
        }
      } catch (e) {
        return null;
      }
    }
    return null;
  }
  function resolveYarnSchemaSync(cwd) {
    var _a, _b, _c;
    if ((_a = process.env.npm_config_user_agent) == null ? void 0 : _a.includes("yarn")) {
      try {
        const {stdout: version} = import_execa2.default.commandSync("yarn --version", {
          cwd
        });
        if (version.startsWith("2")) {
          return null;
        }
        const {stdout} = import_execa2.default.commandSync("yarn workspaces info --json", {
          cwd
        });
        const json = getJson(stdout);
        const workspaces = Object.values(json);
        const workspaceRootDir = findWorkspaceRootSync(cwd);
        if (!workspaceRootDir) {
          return null;
        }
        for (const workspace of workspaces) {
          const workspacePath = import_path10.default.join(workspaceRootDir, workspace.location);
          const workspaceSchemaPath = (_b = getSchemaPathFromPackageJsonSync2(workspacePath)) != null ? _b : getRelativeSchemaPathSync(workspacePath);
          if (workspaceSchemaPath) {
            return workspaceSchemaPath;
          }
        }
        const workspaceSchemaPathFromRoot = (_c = getSchemaPathFromPackageJsonSync2(workspaceRootDir)) != null ? _c : getRelativeSchemaPathSync(workspaceRootDir);
        if (workspaceSchemaPathFromRoot) {
          return workspaceSchemaPathFromRoot;
        }
      } catch (e) {
        return null;
      }
    }
    return null;
  }
  async function getAbsoluteSchemaPath(schemaPath) {
    if (await exists2(schemaPath)) {
      return schemaPath;
    }
    return null;
  }
  async function getRelativeSchemaPath2(cwd) {
    let schemaPath = import_path10.default.join(cwd, "schema.prisma");
    if (await exists2(schemaPath)) {
      return schemaPath;
    }
    schemaPath = import_path10.default.join(cwd, `prisma/schema.prisma`);
    if (await exists2(schemaPath)) {
      return schemaPath;
    }
    return null;
  }
  async function getSchemaDir2(schemaPathFromArgs) {
    if (schemaPathFromArgs) {
      return import_path10.default.resolve(import_path10.default.dirname(schemaPathFromArgs));
    }
    const schemaPath = await getSchemaPath7(schemaPathFromArgs);
    if (!schemaPath) {
      return null;
    }
    return import_path10.default.dirname(schemaPath);
  }
  async function getSchema4(schemaPathFromArgs) {
    const schemaPath = await getSchemaPath7(schemaPathFromArgs);
    if (!schemaPath) {
      throw new Error(`Could not find a ${import_chalk14.default.bold("schema.prisma")} file that is required for this command.
You can either provide it with ${import_chalk14.default.greenBright("--schema")}, set it as \`prisma.schema\` in your package.json or put it into the default location ${import_chalk14.default.greenBright("./prisma/schema.prisma")} https://pris.ly/d/prisma-schema-location`);
    }
    return readFile3(schemaPath, "utf-8");
  }
  function getSchemaPathSync2(schemaPathFromArgs) {
    return getSchemaPathSyncInternal(schemaPathFromArgs, {
      cwd: process.cwd()
    });
  }
  function getSchemaPathSyncInternal(schemaPathFromArgs, opts = {
    cwd: process.cwd()
  }) {
    var _a, _b;
    if (schemaPathFromArgs) {
      const customSchemaPath = getAbsoluteSchemaPathSync(import_path10.default.resolve(schemaPathFromArgs));
      if (!customSchemaPath) {
        throw new Error(`Provided --schema at ${schemaPathFromArgs} doesn't exist.`);
      }
      return customSchemaPath;
    }
    const schemaPath = (_b = (_a = getSchemaPathFromPackageJsonSync2(opts.cwd)) != null ? _a : getRelativeSchemaPathSync(opts.cwd)) != null ? _b : resolveYarnSchemaSync(opts.cwd);
    if (schemaPath) {
      return schemaPath;
    }
    return null;
  }
  function getSchemaPathFromPackageJsonSync2(cwd) {
    var _a, _b;
    const pkgJson = import_read_pkg_up.default.sync({cwd});
    const schemaPathFromPkgJson = (_b = (_a = pkgJson == null ? void 0 : pkgJson.packageJson) == null ? void 0 : _a.prisma) == null ? void 0 : _b.schema;
    if (!schemaPathFromPkgJson || !pkgJson) {
      return null;
    }
    if (typeof schemaPathFromPkgJson !== "string") {
      throw new Error(`Provided schema path \`${schemaPathFromPkgJson}\` from \`${import_path10.default.relative(cwd, pkgJson.path)}\` must be of type string`);
    }
    const absoluteSchemaPath = import_path10.default.isAbsolute(schemaPathFromPkgJson) ? schemaPathFromPkgJson : import_path10.default.resolve(import_path10.default.dirname(pkgJson.path), schemaPathFromPkgJson);
    if (import_fs9.default.existsSync(absoluteSchemaPath) === false) {
      throw new Error(`Provided schema path \`${import_path10.default.relative(cwd, absoluteSchemaPath)}\` from \`${import_path10.default.relative(cwd, pkgJson.path)}\` doesn't exist.`);
    }
    return absoluteSchemaPath;
  }
  function getAbsoluteSchemaPathSync(schemaPath) {
    if (import_fs9.default.existsSync(schemaPath)) {
      return schemaPath;
    }
    return null;
  }
  function getRelativeSchemaPathSync(cwd) {
    let schemaPath = import_path10.default.join(cwd, "schema.prisma");
    if (import_fs9.default.existsSync(schemaPath)) {
      return schemaPath;
    }
    schemaPath = import_path10.default.join(cwd, `prisma/schema.prisma`);
    if (import_fs9.default.existsSync(schemaPath)) {
      return schemaPath;
    }
    return null;
  }
  function getSchemaDirSync2(schemaPathFromArgs) {
    if (schemaPathFromArgs) {
      return import_path10.default.resolve(import_path10.default.dirname(schemaPathFromArgs));
    }
    const schemaPath = getSchemaPathSync2(schemaPathFromArgs);
    if (schemaPath) {
      return import_path10.default.dirname(schemaPath);
    }
    return null;
  }
  function getSchemaSync2(schemaPathFromArgs) {
    const schemaPath = getSchemaPathSync2(schemaPathFromArgs);
    if (!schemaPath) {
      throw new Error(`Could not find a ${import_chalk14.default.bold("schema.prisma")} file that is required for this command.
You can either provide it with ${import_chalk14.default.greenBright("--schema")}, set it as \`prisma.schema\` in your package.json or put it into the default location ${import_chalk14.default.greenBright("./prisma/schema.prisma")} https://pris.ly/d/prisma-schema-location`);
    }
    return import_fs9.default.readFileSync(schemaPath, "utf-8");
  }
  function getJson(stdout) {
    const firstCurly = stdout.indexOf("{");
    const lastCurly = stdout.lastIndexOf("}");
    const sliced = stdout.slice(firstCurly, lastCurly + 1);
    return JSON.parse(sliced);
  }
  function isPkgJsonWorkspaceRoot(pkgJson) {
    const workspaces = pkgJson.workspaces;
    if (!workspaces) {
      return false;
    }
    return Array.isArray(workspaces) || workspaces.packages !== void 0;
  }
  async function isNearestPkgJsonWorkspaceRoot(cwd) {
    const pkgJson = await (0, import_read_pkg_up.default)({cwd});
    if (!pkgJson) {
      return null;
    }
    return {
      isRoot: isPkgJsonWorkspaceRoot(pkgJson.packageJson),
      path: pkgJson.path
    };
  }
  function isNearestPkgJsonWorkspaceRootSync(cwd) {
    const pkgJson = import_read_pkg_up.default.sync({cwd});
    if (!pkgJson) {
      return null;
    }
    return {
      isRoot: isPkgJsonWorkspaceRoot(pkgJson.packageJson),
      path: pkgJson.path
    };
  }
  async function findWorkspaceRoot(cwd) {
    let pkgJson = await isNearestPkgJsonWorkspaceRoot(cwd);
    if (!pkgJson) {
      return null;
    }
    if (pkgJson.isRoot === true) {
      return import_path10.default.dirname(pkgJson.path);
    }
    const pkgJsonParentDir = import_path10.default.dirname(import_path10.default.dirname(pkgJson.path));
    pkgJson = await isNearestPkgJsonWorkspaceRoot(pkgJsonParentDir);
    if (!pkgJson || pkgJson.isRoot === false) {
      return null;
    }
    return import_path10.default.dirname(pkgJson.path);
  }
  function findWorkspaceRootSync(cwd) {
    let pkgJson = isNearestPkgJsonWorkspaceRootSync(cwd);
    if (!pkgJson) {
      return null;
    }
    if (pkgJson.isRoot === true) {
      return import_path10.default.dirname(pkgJson.path);
    }
    const pkgJsonParentDir = import_path10.default.dirname(import_path10.default.dirname(pkgJson.path));
    pkgJson = isNearestPkgJsonWorkspaceRootSync(pkgJsonParentDir);
    if (!pkgJson || pkgJson.isRoot === false) {
      return null;
    }
    return import_path10.default.dirname(pkgJson.path);
  }
});

// ../../node_modules/.pnpm/min-indent@1.0.1/node_modules/min-indent/index.js
var require_min_indent = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (string) => {
    const match = string.match(/^[ \t]*(?=\S)/gm);
    if (!match) {
      return 0;
    }
    return match.reduce((r, a) => Math.min(r, a.length), Infinity);
  };
});

// ../../node_modules/.pnpm/strip-indent@3.0.0/node_modules/strip-indent/index.js
var require_strip_indent = __commonJS((exports2, module2) => {
  "use strict";
  var minIndent = require_min_indent();
  module2.exports = (string) => {
    const indent = minIndent(string);
    if (indent === 0) {
      return string;
    }
    const regex = new RegExp(`^[ \\t]{${indent}}`, "gm");
    return string.replace(regex, "");
  };
});

// ../../node_modules/.pnpm/arg@5.0.1/node_modules/arg/index.js
var require_arg = __commonJS((exports2, module2) => {
  var flagSymbol = Symbol("arg flag");
  var ArgError = class extends Error {
    constructor(msg, code) {
      super(msg);
      this.name = "ArgError";
      this.code = code;
      Object.setPrototypeOf(this, ArgError.prototype);
    }
  };
  function arg10(opts, {
    argv = process.argv.slice(2),
    permissive = false,
    stopAtPositional = false
  } = {}) {
    if (!opts) {
      throw new ArgError("argument specification object is required", "ARG_CONFIG_NO_SPEC");
    }
    const result = {_: []};
    const aliases = {};
    const handlers = {};
    for (const key of Object.keys(opts)) {
      if (!key) {
        throw new ArgError("argument key cannot be an empty string", "ARG_CONFIG_EMPTY_KEY");
      }
      if (key[0] !== "-") {
        throw new ArgError(`argument key must start with '-' but found: '${key}'`, "ARG_CONFIG_NONOPT_KEY");
      }
      if (key.length === 1) {
        throw new ArgError(`argument key must have a name; singular '-' keys are not allowed: ${key}`, "ARG_CONFIG_NONAME_KEY");
      }
      if (typeof opts[key] === "string") {
        aliases[key] = opts[key];
        continue;
      }
      let type = opts[key];
      let isFlag = false;
      if (Array.isArray(type) && type.length === 1 && typeof type[0] === "function") {
        const [fn] = type;
        type = (value, name, prev = []) => {
          prev.push(fn(value, name, prev[prev.length - 1]));
          return prev;
        };
        isFlag = fn === Boolean || fn[flagSymbol] === true;
      } else if (typeof type === "function") {
        isFlag = type === Boolean || type[flagSymbol] === true;
      } else {
        throw new ArgError(`type missing or not a function or valid array type: ${key}`, "ARG_CONFIG_VAD_TYPE");
      }
      if (key[1] !== "-" && key.length > 2) {
        throw new ArgError(`short argument keys (with a single hyphen) must have only one character: ${key}`, "ARG_CONFIG_SHORTOPT_TOOLONG");
      }
      handlers[key] = [type, isFlag];
    }
    for (let i = 0, len = argv.length; i < len; i++) {
      const wholeArg = argv[i];
      if (stopAtPositional && result._.length > 0) {
        result._ = result._.concat(argv.slice(i));
        break;
      }
      if (wholeArg === "--") {
        result._ = result._.concat(argv.slice(i + 1));
        break;
      }
      if (wholeArg.length > 1 && wholeArg[0] === "-") {
        const separatedArguments = wholeArg[1] === "-" || wholeArg.length === 2 ? [wholeArg] : wholeArg.slice(1).split("").map((a) => `-${a}`);
        for (let j = 0; j < separatedArguments.length; j++) {
          const arg11 = separatedArguments[j];
          const [originalArgName, argStr] = arg11[1] === "-" ? arg11.split(/=(.*)/, 2) : [arg11, void 0];
          let argName = originalArgName;
          while (argName in aliases) {
            argName = aliases[argName];
          }
          if (!(argName in handlers)) {
            if (permissive) {
              result._.push(arg11);
              continue;
            } else {
              throw new ArgError(`unknown or unexpected option: ${originalArgName}`, "ARG_UNKNOWN_OPTION");
            }
          }
          const [type, isFlag] = handlers[argName];
          if (!isFlag && j + 1 < separatedArguments.length) {
            throw new ArgError(`option requires argument (but was followed by another short argument): ${originalArgName}`, "ARG_MISSING_REQUIRED_SHORTARG");
          }
          if (isFlag) {
            result[argName] = type(true, argName, result[argName]);
          } else if (argStr === void 0) {
            if (argv.length < i + 2 || argv[i + 1].length > 1 && argv[i + 1][0] === "-" && !(argv[i + 1].match(/^-?\d*(\.(?=\d))?\d*$/) && (type === Number || typeof BigInt !== "undefined" && type === BigInt))) {
              const extended = originalArgName === argName ? "" : ` (alias for ${argName})`;
              throw new ArgError(`option requires argument: ${originalArgName}${extended}`, "ARG_MISSING_REQUIRED_LONGARG");
            }
            result[argName] = type(argv[i + 1], argName, result[argName]);
            ++i;
          } else {
            result[argName] = type(argStr, argName, result[argName]);
          }
        }
      } else {
        result._.push(wholeArg);
      }
    }
    return result;
  }
  arg10.flag = (fn) => {
    fn[flagSymbol] = true;
    return fn;
  };
  arg10.COUNT = arg10.flag((v, name, existingCount) => (existingCount || 0) + 1);
  arg10.ArgError = ArgError;
  module2.exports = arg10;
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/cli/utils.js
var require_utils = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    arg: () => arg10,
    format: () => format10,
    isError: () => isError7
  });
  var import_strip_indent = __toModule3(require_strip_indent());
  var import_arg = __toModule3(require_arg());
  function format10(input = "") {
    return (0, import_strip_indent.default)(input).trimRight() + "\n";
  }
  function arg10(argv, spec, stopAtPositional = true, permissive = false) {
    try {
      return (0, import_arg.default)(spec, {argv, stopAtPositional, permissive});
    } catch (err) {
      return err;
    }
  }
  function isError7(result) {
    return result instanceof Error;
  }
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/cli/hashes.js
var require_hashes = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    getCLIPathHash: () => getCLIPathHash4,
    getProjectHash: () => getProjectHash4
  });
  var import_getSchema = __toModule3(require_getSchema());
  var import_utils = __toModule3(require_utils());
  var import_crypto = __toModule3(require("crypto"));
  async function getProjectHash4() {
    const args2 = (0, import_utils.arg)(process.argv.slice(3), {"--schema": String});
    let projectPath = await (0, import_getSchema.getSchemaPath)(args2["--schema"]);
    projectPath = projectPath || process.cwd();
    return import_crypto.default.createHash("sha256").update(projectPath).digest("hex").substring(0, 8);
  }
  function getCLIPathHash4() {
    const cliPath = process.argv[1];
    return import_crypto.default.createHash("sha256").update(cliPath).digest("hex").substring(0, 8);
  }
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/cli/Help.js
var require_Help = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    HelpError: () => HelpError10,
    unknownCommand: () => unknownCommand3
  });
  var import_chalk14 = __toModule3(require_source());
  function unknownCommand3(helpTemplate, cmd) {
    return new HelpError10(`
${import_chalk14.default.bold.red(`!`)} Unknown command "${cmd}"
${helpTemplate}`);
  }
  var HelpError10 = class extends Error {
    constructor(msg) {
      super(msg);
      Object.setPrototypeOf(this, HelpError10.prototype);
    }
  };
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/cli/types.js
var require_types = __commonJS((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  __markAsModule3(exports2);
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/convertCredentials.js
var require_convertCredentials = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    credentialsToUri: () => credentialsToUri2,
    protocolToConnectorType: () => protocolToConnectorType2,
    uriToCredentials: () => uriToCredentials2
  });
  var NodeURL = __toModule3(require("url"));
  var import_path10 = __toModule3(require("path"));
  function credentialsToUri2(credentials) {
    const type = databaseTypeToProtocol(credentials.type);
    if (credentials.type === "mongodb") {
      return credentials.uri;
    }
    const url = new NodeURL.URL(type + "//");
    if (credentials.host) {
      url.hostname = credentials.host;
    }
    if (credentials.type === "postgresql") {
      if (credentials.database) {
        url.pathname = "/" + credentials.database;
      }
      if (credentials.schema) {
        url.searchParams.set("schema", credentials.schema);
      }
      if (credentials.socket) {
        url.host = credentials.socket;
      }
    } else if (credentials.type === "mysql") {
      url.pathname = "/" + (credentials.database || credentials.schema || "");
      if (credentials.socket) {
        url.searchParams.set("socket", credentials.socket);
      }
    }
    if (credentials.ssl) {
      url.searchParams.set("sslmode", "prefer");
    }
    if (credentials.user) {
      url.username = credentials.user;
    }
    if (credentials.password) {
      url.password = credentials.password;
    }
    if (credentials.port) {
      url.port = String(credentials.port);
    }
    url.host = `${url.hostname}${url.port ? `:${url.port}` : ""}`;
    if (credentials.extraFields) {
      for (const [key, value] of Object.entries(credentials.extraFields)) {
        url.searchParams.set(key, value);
      }
    }
    if (url.pathname === "/") {
      url.pathname = "";
    }
    if (credentials.type === "sqlite") {
      return credentials.uri;
    }
    return url.toString();
  }
  function uriToCredentials2(connectionString) {
    let uri;
    try {
      uri = new NodeURL.URL(connectionString);
    } catch (e) {
      throw new Error("Invalid data source URL, see https://www.prisma.io/docs/reference/database-reference/connection-urls");
    }
    const type = protocolToConnectorType2(uri.protocol);
    const exists2 = (str) => str && str.length > 0;
    if (type === "mongodb") {
      return {
        type,
        uri: connectionString
      };
    }
    const extraFields = {};
    const schema = uri.searchParams.get("schema");
    const socket = uri.searchParams.get("socket");
    for (const [name, value] of uri.searchParams) {
      if (!["schema", "socket"].includes(name)) {
        extraFields[name] = value;
      }
    }
    let database = void 0;
    let defaultSchema3 = void 0;
    if (type === "sqlite" && uri.pathname) {
      if (uri.pathname.startsWith("file:")) {
        database = uri.pathname.slice(5);
      }
      if (uri.pathname.startsWith("sqlite:")) {
        database = uri.pathname.slice(7);
      } else {
        database = import_path10.default.basename(uri.pathname);
      }
    } else if (uri.pathname.length > 1) {
      database = uri.pathname.slice(1);
      if (type === "postgresql" && !database) {
        database = "postgres";
      }
    }
    if (type === "postgresql" && !schema) {
      defaultSchema3 = "public";
    }
    return {
      type,
      host: exists2(uri.hostname) ? uri.hostname : void 0,
      user: exists2(uri.username) ? uri.username : void 0,
      port: exists2(uri.port) ? Number(uri.port) : void 0,
      password: exists2(uri.password) ? uri.password : void 0,
      database,
      schema: schema || defaultSchema3,
      uri: connectionString,
      ssl: Boolean(uri.searchParams.get("sslmode")),
      socket: socket || void 0,
      extraFields
    };
  }
  function databaseTypeToProtocol(databaseType) {
    switch (databaseType) {
      case "postgresql":
        return "postgresql:";
      case "mysql":
        return "mysql:";
      case "mongodb":
        return "mongodb:";
      case "sqlite":
        return "sqlite:";
      case "sqlserver":
        return "sqlserver:";
    }
  }
  function protocolToConnectorType2(protocol) {
    switch (protocol) {
      case "postgresql:":
      case "postgres:":
        return "postgresql";
      case "mongodb:":
        return "mongodb";
      case "mysql:":
        return "mysql";
      case "file:":
      case "sqlite:":
        return "sqlite";
      case "sqlserver:":
      case "jdbc:sqlserver:":
        return "sqlserver";
    }
    throw new Error(`Unknown database type ${protocol}`);
  }
});

// ../../node_modules/.pnpm/is-fullwidth-code-point@3.0.0/node_modules/is-fullwidth-code-point/index.js
var require_is_fullwidth_code_point = __commonJS((exports2, module2) => {
  "use strict";
  var isFullwidthCodePoint = (codePoint) => {
    if (Number.isNaN(codePoint)) {
      return false;
    }
    if (codePoint >= 4352 && (codePoint <= 4447 || codePoint === 9001 || codePoint === 9002 || 11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || 12880 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65131 || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 262141)) {
      return true;
    }
    return false;
  };
  module2.exports = isFullwidthCodePoint;
  module2.exports.default = isFullwidthCodePoint;
});

// ../../node_modules/.pnpm/astral-regex@2.0.0/node_modules/astral-regex/index.js
var require_astral_regex = __commonJS((exports2, module2) => {
  "use strict";
  var regex = "[\uD800-\uDBFF][\uDC00-\uDFFF]";
  var astralRegex = (options) => options && options.exact ? new RegExp(`^${regex}$`) : new RegExp(regex, "g");
  module2.exports = astralRegex;
});

// ../../node_modules/.pnpm/slice-ansi@3.0.0/node_modules/slice-ansi/index.js
var require_slice_ansi = __commonJS((exports2, module2) => {
  "use strict";
  var isFullwidthCodePoint = require_is_fullwidth_code_point();
  var astralRegex = require_astral_regex();
  var ansiStyles = require_ansi_styles();
  var ESCAPES = [
    "",
    "\x9B"
  ];
  var wrapAnsi = (code) => `${ESCAPES[0]}[${code}m`;
  var checkAnsi = (ansiCodes, isEscapes, endAnsiCode) => {
    let output = [];
    ansiCodes = [...ansiCodes];
    for (let ansiCode of ansiCodes) {
      const ansiCodeOrigin = ansiCode;
      if (ansiCode.match(";")) {
        ansiCode = ansiCode.split(";")[0][0] + "0";
      }
      const item = ansiStyles.codes.get(parseInt(ansiCode, 10));
      if (item) {
        const indexEscape = ansiCodes.indexOf(item.toString());
        if (indexEscape >= 0) {
          ansiCodes.splice(indexEscape, 1);
        } else {
          output.push(wrapAnsi(isEscapes ? item : ansiCodeOrigin));
        }
      } else if (isEscapes) {
        output.push(wrapAnsi(0));
        break;
      } else {
        output.push(wrapAnsi(ansiCodeOrigin));
      }
    }
    if (isEscapes) {
      output = output.filter((element, index) => output.indexOf(element) === index);
      if (endAnsiCode !== void 0) {
        const fistEscapeCode = wrapAnsi(ansiStyles.codes.get(parseInt(endAnsiCode, 10)));
        output = output.reduce((current, next) => next === fistEscapeCode ? [next, ...current] : [...current, next], []);
      }
    }
    return output.join("");
  };
  module2.exports = (string, begin, end) => {
    const characters = [...string.normalize()];
    const ansiCodes = [];
    end = typeof end === "number" ? end : characters.length;
    let isInsideEscape = false;
    let ansiCode;
    let visible = 0;
    let output = "";
    for (const [index, character] of characters.entries()) {
      let leftEscape = false;
      if (ESCAPES.includes(character)) {
        const code = /\d[^m]*/.exec(string.slice(index, index + 18));
        ansiCode = code && code.length > 0 ? code[0] : void 0;
        if (visible < end) {
          isInsideEscape = true;
          if (ansiCode !== void 0) {
            ansiCodes.push(ansiCode);
          }
        }
      } else if (isInsideEscape && character === "m") {
        isInsideEscape = false;
        leftEscape = true;
      }
      if (!isInsideEscape && !leftEscape) {
        ++visible;
      }
      if (!astralRegex({exact: true}).test(character) && isFullwidthCodePoint(character.codePointAt())) {
        ++visible;
      }
      if (visible > begin && visible <= end) {
        output += character;
      } else if (visible === begin && !isInsideEscape && ansiCode !== void 0) {
        output = checkAnsi(ansiCodes);
      } else if (visible >= end) {
        output += checkAnsi(ansiCodes, true, ansiCode);
        break;
      }
    }
    return output;
  };
});

// ../../node_modules/.pnpm/ansi-regex@5.0.0/node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = ({onlyFirst = false} = {}) => {
    const pattern = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(pattern, onlyFirst ? void 0 : "g");
  };
});

// ../../node_modules/.pnpm/strip-ansi@6.0.0/node_modules/strip-ansi/index.js
var require_strip_ansi = __commonJS((exports2, module2) => {
  "use strict";
  var ansiRegex = require_ansi_regex();
  module2.exports = (string) => typeof string === "string" ? string.replace(ansiRegex(), "") : string;
});

// ../../node_modules/.pnpm/emoji-regex@8.0.0/node_modules/emoji-regex/index.js
var require_emoji_regex = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function() {
    return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
  };
});

// ../../node_modules/.pnpm/string-width@4.2.2/node_modules/string-width/index.js
var require_string_width = __commonJS((exports2, module2) => {
  "use strict";
  var stripAnsi = require_strip_ansi();
  var isFullwidthCodePoint = require_is_fullwidth_code_point();
  var emojiRegex = require_emoji_regex();
  var stringWidth = (string) => {
    if (typeof string !== "string" || string.length === 0) {
      return 0;
    }
    string = stripAnsi(string);
    if (string.length === 0) {
      return 0;
    }
    string = string.replace(emojiRegex(), "  ");
    let width = 0;
    for (let i = 0; i < string.length; i++) {
      const code = string.codePointAt(i);
      if (code <= 31 || code >= 127 && code <= 159) {
        continue;
      }
      if (code >= 768 && code <= 879) {
        continue;
      }
      if (code > 65535) {
        i++;
      }
      width += isFullwidthCodePoint(code) ? 2 : 1;
    }
    return width;
  };
  module2.exports = stringWidth;
  module2.exports.default = stringWidth;
});

// ../../node_modules/.pnpm/cli-truncate@2.1.0/node_modules/cli-truncate/index.js
var require_cli_truncate = __commonJS((exports2, module2) => {
  "use strict";
  var sliceAnsi = require_slice_ansi();
  var stringWidth = require_string_width();
  function getIndexOfNearestSpace(string, index, shouldSearchRight) {
    if (string.charAt(index) === " ") {
      return index;
    }
    for (let i = 1; i <= 3; i++) {
      if (shouldSearchRight) {
        if (string.charAt(index + i) === " ") {
          return index + i;
        }
      } else if (string.charAt(index - i) === " ") {
        return index - i;
      }
    }
    return index;
  }
  module2.exports = (text, columns, options) => {
    options = {
      position: "end",
      preferTruncationOnSpace: false,
      ...options
    };
    const {position, space, preferTruncationOnSpace} = options;
    let ellipsis = "\u2026";
    let ellipsisWidth = 1;
    if (typeof text !== "string") {
      throw new TypeError(`Expected \`input\` to be a string, got ${typeof text}`);
    }
    if (typeof columns !== "number") {
      throw new TypeError(`Expected \`columns\` to be a number, got ${typeof columns}`);
    }
    if (columns < 1) {
      return "";
    }
    if (columns === 1) {
      return ellipsis;
    }
    const length = stringWidth(text);
    if (length <= columns) {
      return text;
    }
    if (position === "start") {
      if (preferTruncationOnSpace) {
        const nearestSpace = getIndexOfNearestSpace(text, length - columns + 1, true);
        return ellipsis + sliceAnsi(text, nearestSpace, length).trim();
      }
      if (space === true) {
        ellipsis += " ";
        ellipsisWidth = 2;
      }
      return ellipsis + sliceAnsi(text, length - columns + ellipsisWidth, length);
    }
    if (position === "middle") {
      if (space === true) {
        ellipsis = " " + ellipsis + " ";
        ellipsisWidth = 3;
      }
      const half = Math.floor(columns / 2);
      if (preferTruncationOnSpace) {
        const spaceNearFirstBreakPoint = getIndexOfNearestSpace(text, half);
        const spaceNearSecondBreakPoint = getIndexOfNearestSpace(text, length - (columns - half) + 1, true);
        return sliceAnsi(text, 0, spaceNearFirstBreakPoint) + ellipsis + sliceAnsi(text, spaceNearSecondBreakPoint, length).trim();
      }
      return sliceAnsi(text, 0, half) + ellipsis + sliceAnsi(text, length - (columns - half) + ellipsisWidth, length);
    }
    if (position === "end") {
      if (preferTruncationOnSpace) {
        const nearestSpace = getIndexOfNearestSpace(text, columns - 1);
        return sliceAnsi(text, 0, nearestSpace) + ellipsis;
      }
      if (space === true) {
        ellipsis = " " + ellipsis;
        ellipsisWidth = 2;
      }
      return sliceAnsi(text, 0, columns - ellipsisWidth) + ellipsis;
    }
    throw new Error(`Expected \`options.position\` to be either \`start\`, \`middle\` or \`end\`, got ${position}`);
  };
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/drawBox.js
var require_drawBox = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    drawBox: () => drawBox3
  });
  var import_chalk14 = __toModule3(require_source());
  var import_cli_truncate = __toModule3(require_cli_truncate());
  var import_string_width = __toModule3(require_string_width());
  var chars = {
    topLeft: "\u250C",
    topRight: "\u2510",
    bottomRight: "\u2518",
    bottomLeft: "\u2514",
    vertical: "\u2502",
    horizontal: "\u2500"
  };
  function maxLineLength(str) {
    return str.split("\n").reduce((max, curr) => Math.max(max, (0, import_string_width.default)(curr)), 0) + 2;
  }
  function drawBox3({
    title,
    width,
    height,
    str,
    horizontalPadding
  }) {
    horizontalPadding = horizontalPadding || 0;
    width = width || maxLineLength(str) + horizontalPadding * 2;
    const topLine = title ? import_chalk14.default.grey(chars.topLeft + chars.horizontal) + " " + import_chalk14.default.reset.bold(title) + " " + import_chalk14.default.grey(chars.horizontal.repeat(width - title.length - 2 - 3) + chars.topRight) + import_chalk14.default.reset() : import_chalk14.default.grey(chars.topLeft + chars.horizontal) + import_chalk14.default.grey(chars.horizontal.repeat(width - 3) + chars.topRight);
    const bottomLine = chars.bottomLeft + chars.horizontal.repeat(width - 2) + chars.bottomRight;
    const lines = str.split("\n");
    if (lines.length < height) {
      lines.push(...new Array(height - lines.length).fill(""));
    }
    const mappedLines = lines.slice(-height).map((l) => {
      const lineWidth = Math.min((0, import_string_width.default)(l), width);
      const paddingRight = Math.max(width - lineWidth - 2, 0);
      return `${import_chalk14.default.grey(chars.vertical)}${" ".repeat(horizontalPadding)}${import_chalk14.default.reset((0, import_cli_truncate.default)(l, width - 2))}${" ".repeat(paddingRight - horizontalPadding)}${import_chalk14.default.grey(chars.vertical)}`;
    }).join("\n");
    return import_chalk14.default.grey(topLine + "\n" + mappedLines + "\n" + bottomLine);
  }
});

// ../../node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js
var require_ms = __commonJS((exports2, module2) => {
  var s2 = 1e3;
  var m2 = s2 * 60;
  var h2 = m2 * 60;
  var d2 = h2 * 24;
  var w2 = d2 * 7;
  var y2 = d2 * 365.25;
  module2.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse2(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong2(val) : fmtShort2(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y2;
      case "weeks":
      case "week":
      case "w":
        return n * w2;
      case "days":
      case "day":
      case "d":
        return n * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort2(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return Math.round(ms2 / d2) + "d";
    }
    if (msAbs >= h2) {
      return Math.round(ms2 / h2) + "h";
    }
    if (msAbs >= m2) {
      return Math.round(ms2 / m2) + "m";
    }
    if (msAbs >= s2) {
      return Math.round(ms2 / s2) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong2(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return plural2(ms2, msAbs, d2, "day");
    }
    if (msAbs >= h2) {
      return plural2(ms2, msAbs, h2, "hour");
    }
    if (msAbs >= m2) {
      return plural2(ms2, msAbs, m2, "minute");
    }
    if (msAbs >= s2) {
      return plural2(ms2, msAbs, s2, "second");
    }
    return ms2 + " ms";
  }
  function plural2(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
});

// ../../node_modules/.pnpm/debug@4.3.2/node_modules/debug/src/common.js
var require_common = __commonJS((exports2, module2) => {
  function setup(env2) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env2).forEach((key) => {
      createDebug[key] = env2[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug3(...args2) {
        if (!debug3.enabled) {
          return;
        }
        const self2 = debug3;
        const curr = Number(new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args2[0] = createDebug.coerce(args2[0]);
        if (typeof args2[0] !== "string") {
          args2.unshift("%O");
        }
        let index = 0;
        args2[0] = args2[0].replace(/%([a-zA-Z%])/g, (match, format10) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format10];
          if (typeof formatter === "function") {
            const val = args2[index];
            match = formatter.call(self2, val);
            args2.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args2);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args2);
      }
      debug3.namespace = namespace;
      debug3.useColors = createDebug.useColors();
      debug3.color = createDebug.selectColor(namespace);
      debug3.extend = extend;
      debug3.destroy = createDebug.destroy;
      Object.defineProperty(debug3, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug3);
      }
      return debug3;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module2.exports = setup;
});

// ../../node_modules/.pnpm/debug@4.3.2/node_modules/debug/src/browser.js
var require_browser = __commonJS((exports2, module2) => {
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load2;
  exports2.useColors = useColors;
  exports2.storage = localstorage();
  exports2.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports2.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args2) {
    args2[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args2[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args2.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args2[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args2.splice(lastC, 0, c);
  }
  exports2.log = console.debug || console.log || (() => {
  });
  function save(namespaces) {
    try {
      if (namespaces) {
        exports2.storage.setItem("debug", namespaces);
      } else {
        exports2.storage.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load2() {
    let r;
    try {
      r = exports2.storage.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  module2.exports = require_common()(exports2);
  var {formatters} = module2.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// ../../node_modules/.pnpm/debug@4.3.2/node_modules/debug/src/node.js
var require_node = __commonJS((exports2, module2) => {
  var tty = require("tty");
  var util2 = require("util");
  exports2.init = init;
  exports2.log = log2;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load2;
  exports2.useColors = useColors;
  exports2.destroy = util2.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports2.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports2.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {
  }
  exports2.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_2, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args2) {
    const {namespace: name, useColors: useColors2} = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} [0m`;
      args2[0] = prefix + args2[0].split("\n").join("\n" + prefix);
      args2.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
    } else {
      args2[0] = getDate() + name + " " + args2[0];
    }
  }
  function getDate() {
    if (exports2.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log2(...args2) {
    return process.stderr.write(util2.format(...args2) + "\n");
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load2() {
    return process.env.DEBUG;
  }
  function init(debug3) {
    debug3.inspectOpts = {};
    const keys = Object.keys(exports2.inspectOpts);
    for (let i = 0; i < keys.length; i++) {
      debug3.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
    }
  }
  module2.exports = require_common()(exports2);
  var {formatters} = module2.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v, this.inspectOpts);
  };
});

// ../../node_modules/.pnpm/debug@4.3.2/node_modules/debug/src/index.js
var require_src2 = __commonJS((exports2, module2) => {
  if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
    module2.exports = require_browser();
  } else {
    module2.exports = require_node();
  }
});

// ../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js
var require_ms2 = __commonJS((exports2, module2) => {
  var s2 = 1e3;
  var m2 = s2 * 60;
  var h2 = m2 * 60;
  var d2 = h2 * 24;
  var w2 = d2 * 7;
  var y2 = d2 * 365.25;
  module2.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse2(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong2(val) : fmtShort2(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y2;
      case "weeks":
      case "week":
      case "w":
        return n * w2;
      case "days":
      case "day":
      case "d":
        return n * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort2(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return Math.round(ms2 / d2) + "d";
    }
    if (msAbs >= h2) {
      return Math.round(ms2 / h2) + "h";
    }
    if (msAbs >= m2) {
      return Math.round(ms2 / m2) + "m";
    }
    if (msAbs >= s2) {
      return Math.round(ms2 / s2) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong2(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return plural2(ms2, msAbs, d2, "day");
    }
    if (msAbs >= h2) {
      return plural2(ms2, msAbs, h2, "hour");
    }
    if (msAbs >= m2) {
      return plural2(ms2, msAbs, m2, "minute");
    }
    if (msAbs >= s2) {
      return plural2(ms2, msAbs, s2, "second");
    }
    return ms2 + " ms";
  }
  function plural2(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
});

// ../../node_modules/.pnpm/@prisma+debug@2.30.2/node_modules/@prisma/debug/dist/common.js
var require_common2 = __commonJS((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    setup: () => setup
  });
  function setup(env2) {
    const createDebug = (namespace, logger5) => {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      const debug3 = (...args2) => {
        const self2 = debug3;
        const curr = Number(new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args2[0] = createDebug.coerce(args2[0]);
        if (typeof args2[0] !== "string") {
          args2.unshift("%O");
        }
        let index = 0;
        args2[0] = args2[0].replace(/%([a-zA-Z%])/g, (match, format10) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format10];
          if (typeof formatter === "function") {
            const val = args2[index];
            match = formatter.call(self2, val);
            args2.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args2);
        if (logger5 && typeof logger5 === "function") {
          logger5.apply(self2, args2);
        }
        if (debug3.enabled) {
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args2);
        }
      };
      debug3.namespace = namespace;
      debug3.useColors = createDebug.useColors();
      debug3.color = createDebug.selectColor(namespace);
      debug3.extend = extend;
      debug3.destroy = createDebug.destroy;
      Object.defineProperty(debug3, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug3);
      }
      return debug3;
    };
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms2();
    createDebug.destroy = destroy;
    Object.keys(env2).forEach((key) => {
      createDebug[key] = env2[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
});

// ../../node_modules/.pnpm/@prisma+debug@2.30.2/node_modules/@prisma/debug/dist/node.js
var require_node2 = __commonJS((exports2, module2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    default: () => node_default
  });
  var import_common = __toModule3(require_common2());
  var tty = require("tty");
  var util2 = require("util");
  exports2.init = init;
  exports2.log = log2;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load2;
  exports2.useColors = useColors;
  exports2.destroy = util2.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports2.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports2.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {
  }
  exports2.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_2, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args2) {
    const {namespace: name, useColors: useColors2} = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} [0m`;
      args2[0] = prefix + args2[0].split("\n").join("\n" + prefix);
      args2.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
    } else {
      args2[0] = getDate() + name + " " + args2[0];
    }
  }
  function getDate() {
    if (exports2.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log2(...args2) {
    return process.stderr.write(util2.format(...args2) + "\n");
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load2() {
    return process.env.DEBUG;
  }
  function init(debug3) {
    debug3.inspectOpts = {};
    const keys = Object.keys(exports2.inspectOpts);
    for (let i = 0; i < keys.length; i++) {
      debug3.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
    }
  }
  var mod = (0, import_common.setup)(exports2);
  module2.exports = mod;
  var node_default = mod;
  var {formatters} = mod;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v, this.inspectOpts);
  };
});

// ../../node_modules/.pnpm/@prisma+debug@2.30.2/node_modules/@prisma/debug/dist/index.js
var require_dist2 = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    Debug: () => Debug2,
    default: () => Debug2,
    getLogs: () => getLogs
  });
  var import_debug3 = __toModule3(require_src2());
  var import_node = __toModule3(require_node2());
  var cache = [];
  var MAX_LOGS = 100;
  function Debug2(namespace) {
    const debug3 = (0, import_node.default)(namespace, (...args2) => {
      cache.push(args2);
      if (cache.length > MAX_LOGS) {
        cache.shift();
      }
    });
    return debug3;
  }
  Debug2.enable = (namespace) => {
    import_node.default.enable(namespace);
  };
  Debug2.enabled = (namespace) => import_node.default.enabled(namespace);
  function getLogs(numChars = 7500) {
    const output = cache.map((c) => c.map((item) => {
      if (typeof item === "string") {
        return item;
      }
      return JSON.stringify(item);
    }).join("  ")).join("\n");
    if (output.length < numChars) {
      return output;
    }
    return output.slice(-numChars);
  }
});

// ../../node_modules/.pnpm/@prisma+debug@2.30.0/node_modules/@prisma/debug/dist/common.js
var require_common3 = __commonJS((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    setup: () => setup
  });
  function setup(env2) {
    const createDebug = (namespace, logger5) => {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      const debug3 = (...args2) => {
        const self2 = debug3;
        const curr = Number(new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args2[0] = createDebug.coerce(args2[0]);
        if (typeof args2[0] !== "string") {
          args2.unshift("%O");
        }
        let index = 0;
        args2[0] = args2[0].replace(/%([a-zA-Z%])/g, (match, format10) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format10];
          if (typeof formatter === "function") {
            const val = args2[index];
            match = formatter.call(self2, val);
            args2.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args2);
        if (logger5 && typeof logger5 === "function") {
          logger5.apply(self2, args2);
        }
        if (debug3.enabled) {
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args2);
        }
      };
      debug3.namespace = namespace;
      debug3.useColors = createDebug.useColors();
      debug3.color = createDebug.selectColor(namespace);
      debug3.extend = extend;
      debug3.destroy = createDebug.destroy;
      Object.defineProperty(debug3, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug3);
      }
      return debug3;
    };
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms2();
    createDebug.destroy = destroy;
    Object.keys(env2).forEach((key) => {
      createDebug[key] = env2[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
});

// ../../node_modules/.pnpm/@prisma+debug@2.30.0/node_modules/@prisma/debug/dist/node.js
var require_node3 = __commonJS((exports2, module2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    default: () => node_default
  });
  var import_common = __toModule3(require_common3());
  var tty = require("tty");
  var util2 = require("util");
  exports2.init = init;
  exports2.log = log2;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load2;
  exports2.useColors = useColors;
  exports2.destroy = util2.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports2.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports2.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {
  }
  exports2.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_2, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args2) {
    const {namespace: name, useColors: useColors2} = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} [0m`;
      args2[0] = prefix + args2[0].split("\n").join("\n" + prefix);
      args2.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
    } else {
      args2[0] = getDate() + name + " " + args2[0];
    }
  }
  function getDate() {
    if (exports2.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log2(...args2) {
    return process.stderr.write(util2.format(...args2) + "\n");
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load2() {
    return process.env.DEBUG;
  }
  function init(debug3) {
    debug3.inspectOpts = {};
    const keys = Object.keys(exports2.inspectOpts);
    for (let i = 0; i < keys.length; i++) {
      debug3.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
    }
  }
  var mod = (0, import_common.setup)(exports2);
  module2.exports = mod;
  var node_default = mod;
  var {formatters} = mod;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v, this.inspectOpts);
  };
});

// ../../node_modules/.pnpm/@prisma+debug@2.30.0/node_modules/@prisma/debug/dist/index.js
var require_dist3 = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    Debug: () => Debug2,
    default: () => Debug2,
    getLogs: () => getLogs
  });
  var import_debug3 = __toModule3(require_src2());
  var import_node = __toModule3(require_node3());
  var cache = [];
  var MAX_LOGS = 100;
  function Debug2(namespace) {
    const debug3 = (0, import_node.default)(namespace, (...args2) => {
      cache.push(args2);
      if (cache.length > MAX_LOGS) {
        cache.shift();
      }
    });
    return debug3;
  }
  Debug2.enable = (namespace) => {
    import_node.default.enable(namespace);
  };
  Debug2.enabled = (namespace) => import_node.default.enabled(namespace);
  function getLogs(numChars = 7500) {
    const output = cache.map((c) => c.map((item) => {
      if (typeof item === "string") {
        return item;
      }
      return JSON.stringify(item);
    }).join("  ")).join("\n");
    if (output.length < numChars) {
      return output;
    }
    return output.slice(-numChars);
  }
});

// ../../node_modules/.pnpm/@prisma+get-platform@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/get-platform/dist/getNodeAPIName.js
var require_getNodeAPIName = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getNodeAPIName = void 0;
  var NODE_API_QUERY_ENGINE_URL_BASE = "libquery_engine";
  function getNodeAPIName2(platform, type) {
    const isUrl = type === "url";
    if (platform.includes("windows")) {
      return isUrl ? `query_engine.dll.node` : `query_engine-${platform}.dll.node`;
    } else if (platform.includes("linux") || platform.includes("debian") || platform.includes("rhel")) {
      return isUrl ? `${NODE_API_QUERY_ENGINE_URL_BASE}.so.node` : `${NODE_API_QUERY_ENGINE_URL_BASE}-${platform}.so.node`;
    } else if (platform.includes("darwin")) {
      return isUrl ? `${NODE_API_QUERY_ENGINE_URL_BASE}.dylib.node` : `${NODE_API_QUERY_ENGINE_URL_BASE}-${platform}.dylib.node`;
    } else {
      throw new Error(`Node API is currently not supported on your platform: ${platform}`);
    }
  }
  exports2.getNodeAPIName = getNodeAPIName2;
});

// ../../node_modules/.pnpm/@prisma+get-platform@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/get-platform/dist/getPlatform.js
var require_getPlatform = __commonJS((exports2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getPlatform = exports2.getOpenSSLVersion = exports2.parseOpenSSLVersion = exports2.resolveDistro = exports2.parseDistro = exports2.getos = void 0;
  var child_process_1 = require("child_process");
  var fs_12 = __importDefault2(require("fs"));
  var os_1 = __importDefault2(require("os"));
  var util_12 = require("util");
  var readFile3 = util_12.promisify(fs_12.default.readFile);
  var exists2 = util_12.promisify(fs_12.default.exists);
  async function getos() {
    const platform = os_1.default.platform();
    const arch = process.arch;
    if (platform === "freebsd") {
      const version = await gracefulExec(`freebsd-version`);
      if (version && version.trim().length > 0) {
        const regex = /^(\d+)\.?/;
        const match = regex.exec(version);
        if (match) {
          return {
            platform: "freebsd",
            distro: `freebsd${match[1]}`,
            arch
          };
        }
      }
    }
    if (platform !== "linux") {
      return {
        platform,
        arch
      };
    }
    return {
      platform: "linux",
      libssl: await getOpenSSLVersion(),
      distro: await resolveDistro(),
      arch
    };
  }
  exports2.getos = getos;
  function parseDistro(input) {
    const idRegex = /^ID="?([^"\n]*)"?$/im;
    const idLikeRegex = /^ID_LIKE="?([^"\n]*)"?$/im;
    const idMatch = idRegex.exec(input);
    const id = idMatch && idMatch[1] && idMatch[1].toLowerCase() || "";
    const idLikeMatch = idLikeRegex.exec(input);
    const idLike = idLikeMatch && idLikeMatch[1] && idLikeMatch[1].toLowerCase() || "";
    if (id === "raspbian") {
      return "arm";
    }
    if (id === "nixos") {
      return "nixos";
    }
    if (idLike.includes("centos") || idLike.includes("fedora") || idLike.includes("rhel") || id === "fedora") {
      return "rhel";
    }
    if (idLike.includes("debian") || idLike.includes("ubuntu") || id === "debian") {
      return "debian";
    }
    return;
  }
  exports2.parseDistro = parseDistro;
  async function resolveDistro() {
    const osReleaseFile = "/etc/os-release";
    const alpineReleaseFile = "/etc/alpine-release";
    if (await exists2(alpineReleaseFile)) {
      return "musl";
    } else if (await exists2(osReleaseFile)) {
      return parseDistro(await readFile3(osReleaseFile, "utf-8"));
    } else {
      return;
    }
  }
  exports2.resolveDistro = resolveDistro;
  function parseOpenSSLVersion(input) {
    const match = /^OpenSSL\s(\d+\.\d+)\.\d+/.exec(input);
    if (match) {
      return match[1] + ".x";
    }
    return;
  }
  exports2.parseOpenSSLVersion = parseOpenSSLVersion;
  async function getOpenSSLVersion() {
    const [version, ls] = await Promise.all([
      gracefulExec(`openssl version -v`),
      gracefulExec(`
      ls -l /lib64 | grep ssl;
      ls -l /usr/lib64 | grep ssl;
    `)
    ]);
    if (version) {
      const v = parseOpenSSLVersion(version);
      if (v) {
        return v;
      }
    }
    if (ls) {
      const match = /libssl\.so\.(\d+\.\d+)\.\d+/.exec(ls);
      if (match) {
        return match[1] + ".x";
      }
    }
    return void 0;
  }
  exports2.getOpenSSLVersion = getOpenSSLVersion;
  async function gracefulExec(cmd) {
    return new Promise((resolve) => {
      try {
        child_process_1.exec(cmd, (err, stdout) => {
          resolve(String(stdout));
        });
      } catch (e) {
        resolve(void 0);
        return void 0;
      }
    });
  }
  async function getPlatform3() {
    const {platform, libssl, distro, arch} = await getos();
    if (platform === "darwin" && arch === "arm64") {
      return "darwin-arm64";
    }
    if (platform === "darwin") {
      return "darwin";
    }
    if (platform === "win32") {
      return "windows";
    }
    if (platform === "freebsd") {
      return distro;
    }
    if (platform === "openbsd") {
      return "openbsd";
    }
    if (platform === "netbsd") {
      return "netbsd";
    }
    if (platform === "linux" && arch === "arm64") {
      return `linux-arm-openssl-${libssl}`;
    }
    if (platform === "linux" && distro === "nixos") {
      return "linux-nixos";
    }
    if (platform === "linux" && distro === "musl") {
      return "linux-musl";
    }
    if (platform === "linux" && distro && libssl) {
      return distro + "-openssl-" + libssl;
    }
    if (libssl) {
      return "debian-openssl-" + libssl;
    }
    if (distro) {
      return distro + "-openssl-1.1.x";
    }
    return "debian-openssl-1.1.x";
  }
  exports2.getPlatform = getPlatform3;
});

// ../../node_modules/.pnpm/@prisma+get-platform@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/get-platform/dist/isNodeAPISupported.js
var require_isNodeAPISupported = __commonJS((exports2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.isNodeAPISupported = void 0;
  var fs_12 = __importDefault2(require("fs"));
  var _1 = require_dist4();
  async function isNodeAPISupported() {
    const customLibraryPath = process.env.PRISMA_QUERY_ENGINE_LIBRARY;
    const customLibraryExists = customLibraryPath && fs_12.default.existsSync(customLibraryPath);
    const os3 = await _1.getos();
    if (!customLibraryExists && (os3.arch === "x32" || os3.arch === "ia32")) {
      throw new Error(`Node-API is currently not supported for 32bit Node. Please remove \`nApi\` from the "previewFeatures" attribute in the "generator" block of the "schema.prisma", or remove the "PRISMA_FORCE_NAPI" environment variable.`);
    }
  }
  exports2.isNodeAPISupported = isNodeAPISupported;
});

// ../../node_modules/.pnpm/@prisma+get-platform@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/get-platform/dist/platforms.js
var require_platforms = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.platforms = void 0;
  exports2.platforms = [
    "darwin",
    "darwin-arm64",
    "debian-openssl-1.0.x",
    "debian-openssl-1.1.x",
    "rhel-openssl-1.0.x",
    "rhel-openssl-1.1.x",
    "linux-arm-openssl-1.1.x",
    "linux-arm-openssl-1.0.x",
    "linux-musl",
    "linux-nixos",
    "windows",
    "freebsd11",
    "freebsd12",
    "openbsd",
    "netbsd",
    "arm"
  ];
});

// ../../node_modules/.pnpm/@prisma+get-platform@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/get-platform/dist/index.js
var require_dist4 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.platforms = exports2.isNodeAPISupported = exports2.getPlatform = exports2.getos = exports2.getNodeAPIName = void 0;
  var getNodeAPIName_1 = require_getNodeAPIName();
  Object.defineProperty(exports2, "getNodeAPIName", {enumerable: true, get: function() {
    return getNodeAPIName_1.getNodeAPIName;
  }});
  var getPlatform_1 = require_getPlatform();
  Object.defineProperty(exports2, "getos", {enumerable: true, get: function() {
    return getPlatform_1.getos;
  }});
  Object.defineProperty(exports2, "getPlatform", {enumerable: true, get: function() {
    return getPlatform_1.getPlatform;
  }});
  var isNodeAPISupported_1 = require_isNodeAPISupported();
  Object.defineProperty(exports2, "isNodeAPISupported", {enumerable: true, get: function() {
    return isNodeAPISupported_1.isNodeAPISupported;
  }});
  var platforms_1 = require_platforms();
  Object.defineProperty(exports2, "platforms", {enumerable: true, get: function() {
    return platforms_1.platforms;
  }});
});

// ../../node_modules/.pnpm/semver@6.3.0/node_modules/semver/semver.js
var require_semver2 = __commonJS((exports2, module2) => {
  exports2 = module2.exports = SemVer;
  var debug3;
  if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
    debug3 = function() {
      var args2 = Array.prototype.slice.call(arguments, 0);
      args2.unshift("SEMVER");
      console.log.apply(console, args2);
    };
  } else {
    debug3 = function() {
    };
  }
  exports2.SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var re = exports2.re = [];
  var src = exports2.src = [];
  var t = exports2.tokens = {};
  var R = 0;
  function tok(n) {
    t[n] = R++;
  }
  tok("NUMERICIDENTIFIER");
  src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
  tok("NUMERICIDENTIFIERLOOSE");
  src[t.NUMERICIDENTIFIERLOOSE] = "[0-9]+";
  tok("NONNUMERICIDENTIFIER");
  src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
  tok("MAINVERSION");
  src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")";
  tok("MAINVERSIONLOOSE");
  src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")";
  tok("PRERELEASEIDENTIFIER");
  src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
  tok("PRERELEASEIDENTIFIERLOOSE");
  src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
  tok("PRERELEASE");
  src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))";
  tok("PRERELEASELOOSE");
  src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))";
  tok("BUILDIDENTIFIER");
  src[t.BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
  tok("BUILD");
  src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))";
  tok("FULL");
  tok("FULLPLAIN");
  src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?";
  src[t.FULL] = "^" + src[t.FULLPLAIN] + "$";
  tok("LOOSEPLAIN");
  src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?";
  tok("LOOSE");
  src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$";
  tok("GTLT");
  src[t.GTLT] = "((?:<|>)?=?)";
  tok("XRANGEIDENTIFIERLOOSE");
  src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
  tok("XRANGEIDENTIFIER");
  src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*";
  tok("XRANGEPLAIN");
  src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?)?)?";
  tok("XRANGEPLAINLOOSE");
  src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?)?)?";
  tok("XRANGE");
  src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$";
  tok("XRANGELOOSE");
  src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$";
  tok("COERCE");
  src[t.COERCE] = "(^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
  tok("COERCERTL");
  re[t.COERCERTL] = new RegExp(src[t.COERCE], "g");
  tok("LONETILDE");
  src[t.LONETILDE] = "(?:~>?)";
  tok("TILDETRIM");
  src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+";
  re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
  var tildeTrimReplace = "$1~";
  tok("TILDE");
  src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$";
  tok("TILDELOOSE");
  src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$";
  tok("LONECARET");
  src[t.LONECARET] = "(?:\\^)";
  tok("CARETTRIM");
  src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+";
  re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
  var caretTrimReplace = "$1^";
  tok("CARET");
  src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$";
  tok("CARETLOOSE");
  src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$";
  tok("COMPARATORLOOSE");
  src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$";
  tok("COMPARATOR");
  src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$";
  tok("COMPARATORTRIM");
  src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")";
  re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
  var comparatorTrimReplace = "$1$2$3";
  tok("HYPHENRANGE");
  src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")\\s+-\\s+(" + src[t.XRANGEPLAIN] + ")\\s*$";
  tok("HYPHENRANGELOOSE");
  src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[t.XRANGEPLAINLOOSE] + ")\\s*$";
  tok("STAR");
  src[t.STAR] = "(<|>)?=?\\s*\\*";
  for (var i = 0; i < R; i++) {
    debug3(i, src[i]);
    if (!re[i]) {
      re[i] = new RegExp(src[i]);
    }
  }
  exports2.parse = parse2;
  function parse2(version, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version !== "string") {
      return null;
    }
    if (version.length > MAX_LENGTH) {
      return null;
    }
    var r = options.loose ? re[t.LOOSE] : re[t.FULL];
    if (!r.test(version)) {
      return null;
    }
    try {
      return new SemVer(version, options);
    } catch (er) {
      return null;
    }
  }
  exports2.valid = valid;
  function valid(version, options) {
    var v = parse2(version, options);
    return v ? v.version : null;
  }
  exports2.clean = clean;
  function clean(version, options) {
    var s2 = parse2(version.trim().replace(/^[=v]+/, ""), options);
    return s2 ? s2.version : null;
  }
  exports2.SemVer = SemVer;
  function SemVer(version, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      if (version.loose === options.loose) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== "string") {
      throw new TypeError("Invalid Version: " + version);
    }
    if (version.length > MAX_LENGTH) {
      throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
    }
    if (!(this instanceof SemVer)) {
      return new SemVer(version, options);
    }
    debug3("SemVer", version, options);
    this.options = options;
    this.loose = !!options.loose;
    var m2 = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
    if (!m2) {
      throw new TypeError("Invalid Version: " + version);
    }
    this.raw = version;
    this.major = +m2[1];
    this.minor = +m2[2];
    this.patch = +m2[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m2[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m2[4].split(".").map(function(id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id;
      });
    }
    this.build = m2[5] ? m2[5].split(".") : [];
    this.format();
  }
  SemVer.prototype.format = function() {
    this.version = this.major + "." + this.minor + "." + this.patch;
    if (this.prerelease.length) {
      this.version += "-" + this.prerelease.join(".");
    }
    return this.version;
  };
  SemVer.prototype.toString = function() {
    return this.version;
  };
  SemVer.prototype.compare = function(other) {
    debug3("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return this.compareMain(other) || this.comparePre(other);
  };
  SemVer.prototype.compareMain = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  };
  SemVer.prototype.comparePre = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    var i2 = 0;
    do {
      var a = this.prerelease[i2];
      var b = other.prerelease[i2];
      debug3("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  };
  SemVer.prototype.compareBuild = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    var i2 = 0;
    do {
      var a = this.build[i2];
      var b = other.build[i2];
      debug3("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  };
  SemVer.prototype.inc = function(release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier);
        this.inc("pre", identifier);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier);
        }
        this.inc("pre", identifier);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          var i2 = this.prerelease.length;
          while (--i2 >= 0) {
            if (typeof this.prerelease[i2] === "number") {
              this.prerelease[i2]++;
              i2 = -2;
            }
          }
          if (i2 === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error("invalid increment argument: " + release);
    }
    this.format();
    this.raw = this.version;
    return this;
  };
  exports2.inc = inc;
  function inc(version, release, loose, identifier) {
    if (typeof loose === "string") {
      identifier = loose;
      loose = void 0;
    }
    try {
      return new SemVer(version, loose).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  }
  exports2.diff = diff;
  function diff(version1, version2) {
    if (eq(version1, version2)) {
      return null;
    } else {
      var v1 = parse2(version1);
      var v2 = parse2(version2);
      var prefix = "";
      if (v1.prerelease.length || v2.prerelease.length) {
        prefix = "pre";
        var defaultResult = "prerelease";
      }
      for (var key in v1) {
        if (key === "major" || key === "minor" || key === "patch") {
          if (v1[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }
      return defaultResult;
    }
  }
  exports2.compareIdentifiers = compareIdentifiers;
  var numeric = /^[0-9]+$/;
  function compareIdentifiers(a, b) {
    var anum = numeric.test(a);
    var bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  }
  exports2.rcompareIdentifiers = rcompareIdentifiers;
  function rcompareIdentifiers(a, b) {
    return compareIdentifiers(b, a);
  }
  exports2.major = major;
  function major(a, loose) {
    return new SemVer(a, loose).major;
  }
  exports2.minor = minor;
  function minor(a, loose) {
    return new SemVer(a, loose).minor;
  }
  exports2.patch = patch;
  function patch(a, loose) {
    return new SemVer(a, loose).patch;
  }
  exports2.compare = compare;
  function compare(a, b, loose) {
    return new SemVer(a, loose).compare(new SemVer(b, loose));
  }
  exports2.compareLoose = compareLoose;
  function compareLoose(a, b) {
    return compare(a, b, true);
  }
  exports2.compareBuild = compareBuild;
  function compareBuild(a, b, loose) {
    var versionA = new SemVer(a, loose);
    var versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  }
  exports2.rcompare = rcompare;
  function rcompare(a, b, loose) {
    return compare(b, a, loose);
  }
  exports2.sort = sort;
  function sort(list, loose) {
    return list.sort(function(a, b) {
      return exports2.compareBuild(a, b, loose);
    });
  }
  exports2.rsort = rsort;
  function rsort(list, loose) {
    return list.sort(function(a, b) {
      return exports2.compareBuild(b, a, loose);
    });
  }
  exports2.gt = gt;
  function gt(a, b, loose) {
    return compare(a, b, loose) > 0;
  }
  exports2.lt = lt;
  function lt(a, b, loose) {
    return compare(a, b, loose) < 0;
  }
  exports2.eq = eq;
  function eq(a, b, loose) {
    return compare(a, b, loose) === 0;
  }
  exports2.neq = neq;
  function neq(a, b, loose) {
    return compare(a, b, loose) !== 0;
  }
  exports2.gte = gte;
  function gte(a, b, loose) {
    return compare(a, b, loose) >= 0;
  }
  exports2.lte = lte;
  function lte(a, b, loose) {
    return compare(a, b, loose) <= 0;
  }
  exports2.cmp = cmp;
  function cmp(a, op, b, loose) {
    switch (op) {
      case "===":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a === b;
      case "!==":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError("Invalid operator: " + op);
    }
  }
  exports2.Comparator = Comparator;
  function Comparator(comp, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }
    if (!(this instanceof Comparator)) {
      return new Comparator(comp, options);
    }
    debug3("comparator", comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);
    if (this.semver === ANY) {
      this.value = "";
    } else {
      this.value = this.operator + this.semver.version;
    }
    debug3("comp", this);
  }
  var ANY = {};
  Comparator.prototype.parse = function(comp) {
    var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
    var m2 = comp.match(r);
    if (!m2) {
      throw new TypeError("Invalid comparator: " + comp);
    }
    this.operator = m2[1] !== void 0 ? m2[1] : "";
    if (this.operator === "=") {
      this.operator = "";
    }
    if (!m2[2]) {
      this.semver = ANY;
    } else {
      this.semver = new SemVer(m2[2], this.options.loose);
    }
  };
  Comparator.prototype.toString = function() {
    return this.value;
  };
  Comparator.prototype.test = function(version) {
    debug3("Comparator.test", version, this.options.loose);
    if (this.semver === ANY || version === ANY) {
      return true;
    }
    if (typeof version === "string") {
      try {
        version = new SemVer(version, this.options);
      } catch (er) {
        return false;
      }
    }
    return cmp(version, this.operator, this.semver, this.options);
  };
  Comparator.prototype.intersects = function(comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError("a Comparator is required");
    }
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    var rangeTmp;
    if (this.operator === "") {
      if (this.value === "") {
        return true;
      }
      rangeTmp = new Range(comp.value, options);
      return satisfies(this.value, rangeTmp, options);
    } else if (comp.operator === "") {
      if (comp.value === "") {
        return true;
      }
      rangeTmp = new Range(this.value, options);
      return satisfies(comp.semver, rangeTmp, options);
    }
    var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
    var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
    var sameSemVer = this.semver.version === comp.semver.version;
    var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
    var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
    var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  };
  exports2.Range = Range;
  function Range(range, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (range instanceof Range) {
      if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
        return range;
      } else {
        return new Range(range.raw, options);
      }
    }
    if (range instanceof Comparator) {
      return new Range(range.value, options);
    }
    if (!(this instanceof Range)) {
      return new Range(range, options);
    }
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    this.raw = range;
    this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
      return this.parseRange(range2.trim());
    }, this).filter(function(c) {
      return c.length;
    });
    if (!this.set.length) {
      throw new TypeError("Invalid SemVer Range: " + range);
    }
    this.format();
  }
  Range.prototype.format = function() {
    this.range = this.set.map(function(comps) {
      return comps.join(" ").trim();
    }).join("||").trim();
    return this.range;
  };
  Range.prototype.toString = function() {
    return this.range;
  };
  Range.prototype.parseRange = function(range) {
    var loose = this.options.loose;
    range = range.trim();
    var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
    range = range.replace(hr, hyphenReplace);
    debug3("hyphen replace", range);
    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
    debug3("comparator trim", range, re[t.COMPARATORTRIM]);
    range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
    range = range.replace(re[t.CARETTRIM], caretTrimReplace);
    range = range.split(/\s+/).join(" ");
    var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
    var set = range.split(" ").map(function(comp) {
      return parseComparator(comp, this.options);
    }, this).join(" ").split(/\s+/);
    if (this.options.loose) {
      set = set.filter(function(comp) {
        return !!comp.match(compRe);
      });
    }
    set = set.map(function(comp) {
      return new Comparator(comp, this.options);
    }, this);
    return set;
  };
  Range.prototype.intersects = function(range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError("a Range is required");
    }
    return this.set.some(function(thisComparators) {
      return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
        return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
          return rangeComparators.every(function(rangeComparator) {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  };
  function isSatisfiable(comparators, options) {
    var result = true;
    var remainingComparators = comparators.slice();
    var testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every(function(otherComparator) {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  }
  exports2.toComparators = toComparators;
  function toComparators(range, options) {
    return new Range(range, options).set.map(function(comp) {
      return comp.map(function(c) {
        return c.value;
      }).join(" ").trim().split(" ");
    });
  }
  function parseComparator(comp, options) {
    debug3("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug3("caret", comp);
    comp = replaceTildes(comp, options);
    debug3("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug3("xrange", comp);
    comp = replaceStars(comp, options);
    debug3("stars", comp);
    return comp;
  }
  function isX(id) {
    return !id || id.toLowerCase() === "x" || id === "*";
  }
  function replaceTildes(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceTilde(comp2, options);
    }).join(" ");
  }
  function replaceTilde(comp, options) {
    var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, function(_2, M, m2, p, pr) {
      debug3("tilde", comp, _2, M, m2, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m2)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        ret = ">=" + M + "." + m2 + ".0 <" + M + "." + (+m2 + 1) + ".0";
      } else if (pr) {
        debug3("replaceTilde pr", pr);
        ret = ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + M + "." + (+m2 + 1) + ".0";
      } else {
        ret = ">=" + M + "." + m2 + "." + p + " <" + M + "." + (+m2 + 1) + ".0";
      }
      debug3("tilde return", ret);
      return ret;
    });
  }
  function replaceCarets(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceCaret(comp2, options);
    }).join(" ");
  }
  function replaceCaret(comp, options) {
    debug3("caret", comp, options);
    var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
    return comp.replace(r, function(_2, M, m2, p, pr) {
      debug3("caret", comp, _2, M, m2, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m2)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        if (M === "0") {
          ret = ">=" + M + "." + m2 + ".0 <" + M + "." + (+m2 + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m2 + ".0 <" + (+M + 1) + ".0.0";
        }
      } else if (pr) {
        debug3("replaceCaret pr", pr);
        if (M === "0") {
          if (m2 === "0") {
            ret = ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + M + "." + m2 + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + M + "." + (+m2 + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
        }
      } else {
        debug3("no pr");
        if (M === "0") {
          if (m2 === "0") {
            ret = ">=" + M + "." + m2 + "." + p + " <" + M + "." + m2 + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m2 + "." + p + " <" + M + "." + (+m2 + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m2 + "." + p + " <" + (+M + 1) + ".0.0";
        }
      }
      debug3("caret return", ret);
      return ret;
    });
  }
  function replaceXRanges(comp, options) {
    debug3("replaceXRanges", comp, options);
    return comp.split(/\s+/).map(function(comp2) {
      return replaceXRange(comp2, options);
    }).join(" ");
  }
  function replaceXRange(comp, options) {
    comp = comp.trim();
    var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, function(ret, gtlt, M, m2, p, pr) {
      debug3("xRange", comp, ret, gtlt, M, m2, p, pr);
      var xM = isX(M);
      var xm = xM || isX(m2);
      var xp = xm || isX(p);
      var anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m2 = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m2 = 0;
            p = 0;
          } else {
            m2 = +m2 + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m2 = +m2 + 1;
          }
        }
        ret = gtlt + M + "." + m2 + "." + p + pr;
      } else if (xm) {
        ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr;
      } else if (xp) {
        ret = ">=" + M + "." + m2 + ".0" + pr + " <" + M + "." + (+m2 + 1) + ".0" + pr;
      }
      debug3("xRange return", ret);
      return ret;
    });
  }
  function replaceStars(comp, options) {
    debug3("replaceStars", comp, options);
    return comp.trim().replace(re[t.STAR], "");
  }
  function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = ">=" + fM + ".0.0";
    } else if (isX(fp)) {
      from = ">=" + fM + "." + fm + ".0";
    } else {
      from = ">=" + from;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = "<" + (+tM + 1) + ".0.0";
    } else if (isX(tp)) {
      to = "<" + tM + "." + (+tm + 1) + ".0";
    } else if (tpr) {
      to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
    } else {
      to = "<=" + to;
    }
    return (from + " " + to).trim();
  }
  Range.prototype.test = function(version) {
    if (!version) {
      return false;
    }
    if (typeof version === "string") {
      try {
        version = new SemVer(version, this.options);
      } catch (er) {
        return false;
      }
    }
    for (var i2 = 0; i2 < this.set.length; i2++) {
      if (testSet(this.set[i2], version, this.options)) {
        return true;
      }
    }
    return false;
  };
  function testSet(set, version, options) {
    for (var i2 = 0; i2 < set.length; i2++) {
      if (!set[i2].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (i2 = 0; i2 < set.length; i2++) {
        debug3(set[i2].semver);
        if (set[i2].semver === ANY) {
          continue;
        }
        if (set[i2].semver.prerelease.length > 0) {
          var allowed = set[i2].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  }
  exports2.satisfies = satisfies;
  function satisfies(version, range, options) {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version);
  }
  exports2.maxSatisfying = maxSatisfying;
  function maxSatisfying(versions, range, options) {
    var max = null;
    var maxSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  }
  exports2.minSatisfying = minSatisfying;
  function minSatisfying(versions, range, options) {
    var min = null;
    var minSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  }
  exports2.minVersion = minVersion;
  function minVersion(range, loose) {
    range = new Range(range, loose);
    var minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (var i2 = 0; i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      comparators.forEach(function(comparator) {
        var compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!minver || gt(minver, compver)) {
              minver = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + comparator.operator);
        }
      });
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  }
  exports2.validRange = validRange;
  function validRange(range, options) {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  }
  exports2.ltr = ltr;
  function ltr(version, range, options) {
    return outside(version, range, "<", options);
  }
  exports2.gtr = gtr;
  function gtr(version, range, options) {
    return outside(version, range, ">", options);
  }
  exports2.outside = outside;
  function outside(version, range, hilo, options) {
    version = new SemVer(version, options);
    range = new Range(range, options);
    var gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) {
      return false;
    }
    for (var i2 = 0; i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      var high = null;
      var low = null;
      comparators.forEach(function(comparator) {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }
    return true;
  }
  exports2.prerelease = prerelease;
  function prerelease(version, options) {
    var parsed = parse2(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  }
  exports2.intersects = intersects;
  function intersects(r1, r2, options) {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2);
  }
  exports2.coerce = coerce;
  function coerce(version, options) {
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version === "number") {
      version = String(version);
    }
    if (typeof version !== "string") {
      return null;
    }
    options = options || {};
    var match = null;
    if (!options.rtl) {
      match = version.match(re[t.COERCE]);
    } else {
      var next;
      while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
      }
      re[t.COERCERTL].lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    return parse2(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options);
  }
});

// ../../node_modules/.pnpm/make-dir@3.1.0/node_modules/make-dir/index.js
var require_make_dir = __commonJS((exports2, module2) => {
  "use strict";
  var fs9 = require("fs");
  var path10 = require("path");
  var {promisify: promisify4} = require("util");
  var semver2 = require_semver2();
  var useNativeRecursiveOption2 = semver2.satisfies(process.version, ">=10.12.0");
  var checkPath2 = (pth) => {
    if (process.platform === "win32") {
      const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path10.parse(pth).root, ""));
      if (pathHasInvalidWinCharacters) {
        const error = new Error(`Path contains invalid characters: ${pth}`);
        error.code = "EINVAL";
        throw error;
      }
    }
  };
  var processOptions2 = (options) => {
    const defaults = {
      mode: 511,
      fs: fs9
    };
    return {
      ...defaults,
      ...options
    };
  };
  var permissionError2 = (pth) => {
    const error = new Error(`operation not permitted, mkdir '${pth}'`);
    error.code = "EPERM";
    error.errno = -4048;
    error.path = pth;
    error.syscall = "mkdir";
    return error;
  };
  var makeDir2 = async (input, options) => {
    checkPath2(input);
    options = processOptions2(options);
    const mkdir2 = promisify4(options.fs.mkdir);
    const stat = promisify4(options.fs.stat);
    if (useNativeRecursiveOption2 && options.fs.mkdir === fs9.mkdir) {
      const pth = path10.resolve(input);
      await mkdir2(pth, {
        mode: options.mode,
        recursive: true
      });
      return pth;
    }
    const make = async (pth) => {
      try {
        await mkdir2(pth, options.mode);
        return pth;
      } catch (error) {
        if (error.code === "EPERM") {
          throw error;
        }
        if (error.code === "ENOENT") {
          if (path10.dirname(pth) === pth) {
            throw permissionError2(pth);
          }
          if (error.message.includes("null bytes")) {
            throw error;
          }
          await make(path10.dirname(pth));
          return make(pth);
        }
        try {
          const stats = await stat(pth);
          if (!stats.isDirectory()) {
            throw new Error("The path is not a directory");
          }
        } catch (_2) {
          throw error;
        }
        return pth;
      }
    };
    return make(path10.resolve(input));
  };
  module2.exports = makeDir2;
  module2.exports.sync = (input, options) => {
    checkPath2(input);
    options = processOptions2(options);
    if (useNativeRecursiveOption2 && options.fs.mkdirSync === fs9.mkdirSync) {
      const pth = path10.resolve(input);
      fs9.mkdirSync(pth, {
        mode: options.mode,
        recursive: true
      });
      return pth;
    }
    const make = (pth) => {
      try {
        options.fs.mkdirSync(pth, options.mode);
      } catch (error) {
        if (error.code === "EPERM") {
          throw error;
        }
        if (error.code === "ENOENT") {
          if (path10.dirname(pth) === pth) {
            throw permissionError2(pth);
          }
          if (error.message.includes("null bytes")) {
            throw error;
          }
          make(path10.dirname(pth));
          return make(pth);
        }
        try {
          if (!options.fs.statSync(pth).isDirectory()) {
            throw new Error("The path is not a directory");
          }
        } catch (_2) {
          throw error;
        }
      }
      return pth;
    };
    return make(path10.resolve(input));
  };
});

// ../../node_modules/.pnpm/p-map@2.1.0/node_modules/p-map/index.js
var require_p_map = __commonJS((exports2, module2) => {
  "use strict";
  var pMap = (iterable, mapper, options) => new Promise((resolve, reject) => {
    options = Object.assign({
      concurrency: Infinity
    }, options);
    if (typeof mapper !== "function") {
      throw new TypeError("Mapper function is required");
    }
    const {concurrency} = options;
    if (!(typeof concurrency === "number" && concurrency >= 1)) {
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${concurrency}\` (${typeof concurrency})`);
    }
    const ret = [];
    const iterator = iterable[Symbol.iterator]();
    let isRejected = false;
    let isIterableDone = false;
    let resolvingCount = 0;
    let currentIndex = 0;
    const next = () => {
      if (isRejected) {
        return;
      }
      const nextItem = iterator.next();
      const i = currentIndex;
      currentIndex++;
      if (nextItem.done) {
        isIterableDone = true;
        if (resolvingCount === 0) {
          resolve(ret);
        }
        return;
      }
      resolvingCount++;
      Promise.resolve(nextItem.value).then((element) => mapper(element, i)).then((value) => {
        ret[i] = value;
        resolvingCount--;
        next();
      }, (error) => {
        isRejected = true;
        reject(error);
      });
    };
    for (let i = 0; i < concurrency; i++) {
      next();
      if (isIterableDone) {
        break;
      }
    }
  });
  module2.exports = pMap;
  module2.exports.default = pMap;
});

// ../../node_modules/.pnpm/p-filter@2.1.0/node_modules/p-filter/index.js
var require_p_filter = __commonJS((exports2, module2) => {
  "use strict";
  var pMap = require_p_map();
  var pFilter = async (iterable, filterer, options) => {
    const values = await pMap(iterable, (element, index) => Promise.all([filterer(element, index), element]), options);
    return values.filter((value) => Boolean(value[0])).map((value) => value[1]);
  };
  module2.exports = pFilter;
  module2.exports.default = pFilter;
});

// ../../node_modules/.pnpm/temp-dir@2.0.0/node_modules/temp-dir/index.js
var require_temp_dir = __commonJS((exports2, module2) => {
  "use strict";
  var fs9 = require("fs");
  var os3 = require("os");
  var tempDirectorySymbol = Symbol.for("__RESOLVED_TEMP_DIRECTORY__");
  if (!global[tempDirectorySymbol]) {
    Object.defineProperty(global, tempDirectorySymbol, {
      value: fs9.realpathSync(os3.tmpdir())
    });
  }
  module2.exports = global[tempDirectorySymbol];
});

// ../../node_modules/.pnpm/@prisma+fetch-engine@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/fetch-engine/dist/chmod.js
var require_chmod = __commonJS((exports2) => {
  "use strict";
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, {enumerable: true, get: function() {
      return m2[k];
    }});
  } : function(o, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m2[k];
  });
  var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {enumerable: true, value: v});
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  var fs9 = __importStar(require("fs"));
  function default_1(file) {
    const s2 = fs9.statSync(file);
    const newMode = s2.mode | 64 | 8 | 1;
    if (s2.mode === newMode)
      return;
    const base8 = newMode.toString(8).slice(-3);
    fs9.chmodSync(file, base8);
  }
  exports2.default = default_1;
});

// ../../node_modules/.pnpm/commondir@1.0.1/node_modules/commondir/index.js
var require_commondir = __commonJS((exports2, module2) => {
  var path10 = require("path");
  module2.exports = function(basedir, relfiles) {
    if (relfiles) {
      var files = relfiles.map(function(r) {
        return path10.resolve(basedir, r);
      });
    } else {
      var files = basedir;
    }
    var res = files.slice(1).reduce(function(ps, file) {
      if (!file.match(/^([A-Za-z]:)?\/|\\/)) {
        throw new Error("relative path without a basedir");
      }
      var xs = file.split(/\/+|\\+/);
      for (var i = 0; ps[i] === xs[i] && i < Math.min(ps.length, xs.length); i++)
        ;
      return ps.slice(0, i);
    }, files[0].split(/\/+|\\+/));
    return res.length > 1 ? res.join("/") : "/";
  };
});

// ../../node_modules/.pnpm/pkg-dir@4.2.0/node_modules/pkg-dir/index.js
var require_pkg_dir = __commonJS((exports2, module2) => {
  "use strict";
  var path10 = require("path");
  var findUp = require_find_up();
  var pkgDir = async (cwd) => {
    const filePath = await findUp("package.json", {cwd});
    return filePath && path10.dirname(filePath);
  };
  module2.exports = pkgDir;
  module2.exports.default = pkgDir;
  module2.exports.sync = (cwd) => {
    const filePath = findUp.sync("package.json", {cwd});
    return filePath && path10.dirname(filePath);
  };
});

// ../../node_modules/.pnpm/find-cache-dir@3.3.1/node_modules/find-cache-dir/index.js
var require_find_cache_dir = __commonJS((exports2, module2) => {
  "use strict";
  var path10 = require("path");
  var fs9 = require("fs");
  var commonDir = require_commondir();
  var pkgDir = require_pkg_dir();
  var makeDir2 = require_make_dir();
  var {env: env2, cwd} = process;
  var isWritable = (path11) => {
    try {
      fs9.accessSync(path11, fs9.constants.W_OK);
      return true;
    } catch (_2) {
      return false;
    }
  };
  function useDirectory(directory, options) {
    if (options.create) {
      makeDir2.sync(directory);
    }
    if (options.thunk) {
      return (...arguments_) => path10.join(directory, ...arguments_);
    }
    return directory;
  }
  function getNodeModuleDirectory(directory) {
    const nodeModules = path10.join(directory, "node_modules");
    if (!isWritable(nodeModules) && (fs9.existsSync(nodeModules) || !isWritable(path10.join(directory)))) {
      return;
    }
    return nodeModules;
  }
  module2.exports = (options = {}) => {
    if (env2.CACHE_DIR && !["true", "false", "1", "0"].includes(env2.CACHE_DIR)) {
      return useDirectory(path10.join(env2.CACHE_DIR, "find-cache-dir"), options);
    }
    let {cwd: directory = cwd()} = options;
    if (options.files) {
      directory = commonDir(directory, options.files);
    }
    directory = pkgDir.sync(directory);
    if (!directory) {
      return;
    }
    const nodeModules = getNodeModuleDirectory(directory);
    if (!nodeModules) {
      return void 0;
    }
    return useDirectory(path10.join(directory, "node_modules", ".cache", options.name), options);
  };
});

// ../../node_modules/.pnpm/@prisma+fetch-engine@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/fetch-engine/dist/util.js
var require_util2 = __commonJS((exports2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getDownloadUrl = exports2.getCacheDir = exports2.getRootCacheDir = void 0;
  var debug_12 = __importDefault2(require_dist3());
  var get_platform_12 = require_dist4();
  var find_cache_dir_1 = __importDefault2(require_find_cache_dir());
  var fs_12 = __importDefault2(require("fs"));
  var make_dir_12 = __importDefault2(require_make_dir());
  var os_1 = __importDefault2(require("os"));
  var path_12 = __importDefault2(require("path"));
  var download_1 = require_download();
  var debug3 = debug_12.default("prisma:cache-dir");
  async function getRootCacheDir() {
    if (os_1.default.platform() === "win32") {
      const cacheDir = find_cache_dir_1.default({name: "prisma", create: true});
      if (cacheDir) {
        return cacheDir;
      }
      if (process.env.APPDATA) {
        return path_12.default.join(process.env.APPDATA, "Prisma");
      }
    }
    if (process.env.AWS_LAMBDA_FUNCTION_VERSION) {
      try {
        await make_dir_12.default(`/tmp/prisma-download`);
        return `/tmp/prisma-download`;
      } catch (e) {
        return null;
      }
    }
    return path_12.default.join(os_1.default.homedir(), ".cache/prisma");
  }
  exports2.getRootCacheDir = getRootCacheDir;
  async function getCacheDir(channel2, version, platform) {
    const rootCacheDir = await getRootCacheDir();
    if (!rootCacheDir) {
      return null;
    }
    const cacheDir = path_12.default.join(rootCacheDir, channel2, version, platform);
    try {
      if (!fs_12.default.existsSync(cacheDir)) {
        await make_dir_12.default(cacheDir);
      }
    } catch (e) {
      debug3("The following error is being caught and just there for debugging:");
      debug3(e);
      return null;
    }
    return cacheDir;
  }
  exports2.getCacheDir = getCacheDir;
  function getDownloadUrl(channel2, version, platform, binaryName, extension = ".gz") {
    const baseUrl = process.env.PRISMA_BINARIES_MIRROR || "https://binaries.prisma.sh";
    const finalExtension = platform === "windows" && download_1.BinaryType.libqueryEngine !== binaryName ? `.exe${extension}` : extension;
    if (binaryName === download_1.BinaryType.libqueryEngine) {
      binaryName = get_platform_12.getNodeAPIName(platform, "url");
    }
    return `${baseUrl}/${channel2}/${version}/${platform}/${binaryName}${finalExtension}`;
  }
  exports2.getDownloadUrl = getDownloadUrl;
});

// ../../node_modules/.pnpm/fs.realpath@1.0.0/node_modules/fs.realpath/old.js
var require_old = __commonJS((exports2) => {
  var pathModule = require("path");
  var isWindows = process.platform === "win32";
  var fs9 = require("fs");
  var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
  function rethrow() {
    var callback;
    if (DEBUG) {
      var backtrace = new Error();
      callback = debugCallback;
    } else
      callback = missingCallback;
    return callback;
    function debugCallback(err) {
      if (err) {
        backtrace.message = err.message;
        err = backtrace;
        missingCallback(err);
      }
    }
    function missingCallback(err) {
      if (err) {
        if (process.throwDeprecation)
          throw err;
        else if (!process.noDeprecation) {
          var msg = "fs: missing callback " + (err.stack || err.message);
          if (process.traceDeprecation)
            console.trace(msg);
          else
            console.error(msg);
        }
      }
    }
  }
  function maybeCallback(cb) {
    return typeof cb === "function" ? cb : rethrow();
  }
  var normalize = pathModule.normalize;
  if (isWindows) {
    nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
  } else {
    nextPartRe = /(.*?)(?:[\/]+|$)/g;
  }
  var nextPartRe;
  if (isWindows) {
    splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
  } else {
    splitRootRe = /^[\/]*/;
  }
  var splitRootRe;
  exports2.realpathSync = function realpathSync(p, cache) {
    p = pathModule.resolve(p);
    if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
      return cache[p];
    }
    var original = p, seenLinks = {}, knownHard = {};
    var pos;
    var current;
    var base;
    var previous;
    start();
    function start() {
      var m2 = splitRootRe.exec(p);
      pos = m2[0].length;
      current = m2[0];
      base = m2[0];
      previous = "";
      if (isWindows && !knownHard[base]) {
        fs9.lstatSync(base);
        knownHard[base] = true;
      }
    }
    while (pos < p.length) {
      nextPartRe.lastIndex = pos;
      var result = nextPartRe.exec(p);
      previous = current;
      current += result[0];
      base = previous + result[1];
      pos = nextPartRe.lastIndex;
      if (knownHard[base] || cache && cache[base] === base) {
        continue;
      }
      var resolvedLink;
      if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
        resolvedLink = cache[base];
      } else {
        var stat = fs9.lstatSync(base);
        if (!stat.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache)
            cache[base] = base;
          continue;
        }
        var linkTarget = null;
        if (!isWindows) {
          var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            linkTarget = seenLinks[id];
          }
        }
        if (linkTarget === null) {
          fs9.statSync(base);
          linkTarget = fs9.readlinkSync(base);
        }
        resolvedLink = pathModule.resolve(previous, linkTarget);
        if (cache)
          cache[base] = resolvedLink;
        if (!isWindows)
          seenLinks[id] = linkTarget;
      }
      p = pathModule.resolve(resolvedLink, p.slice(pos));
      start();
    }
    if (cache)
      cache[original] = p;
    return p;
  };
  exports2.realpath = function realpath(p, cache, cb) {
    if (typeof cb !== "function") {
      cb = maybeCallback(cache);
      cache = null;
    }
    p = pathModule.resolve(p);
    if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
      return process.nextTick(cb.bind(null, null, cache[p]));
    }
    var original = p, seenLinks = {}, knownHard = {};
    var pos;
    var current;
    var base;
    var previous;
    start();
    function start() {
      var m2 = splitRootRe.exec(p);
      pos = m2[0].length;
      current = m2[0];
      base = m2[0];
      previous = "";
      if (isWindows && !knownHard[base]) {
        fs9.lstat(base, function(err) {
          if (err)
            return cb(err);
          knownHard[base] = true;
          LOOP();
        });
      } else {
        process.nextTick(LOOP);
      }
    }
    function LOOP() {
      if (pos >= p.length) {
        if (cache)
          cache[original] = p;
        return cb(null, p);
      }
      nextPartRe.lastIndex = pos;
      var result = nextPartRe.exec(p);
      previous = current;
      current += result[0];
      base = previous + result[1];
      pos = nextPartRe.lastIndex;
      if (knownHard[base] || cache && cache[base] === base) {
        return process.nextTick(LOOP);
      }
      if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
        return gotResolvedLink(cache[base]);
      }
      return fs9.lstat(base, gotStat);
    }
    function gotStat(err, stat) {
      if (err)
        return cb(err);
      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache)
          cache[base] = base;
        return process.nextTick(LOOP);
      }
      if (!isWindows) {
        var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
        if (seenLinks.hasOwnProperty(id)) {
          return gotTarget(null, seenLinks[id], base);
        }
      }
      fs9.stat(base, function(err2) {
        if (err2)
          return cb(err2);
        fs9.readlink(base, function(err3, target) {
          if (!isWindows)
            seenLinks[id] = target;
          gotTarget(err3, target);
        });
      });
    }
    function gotTarget(err, target, base2) {
      if (err)
        return cb(err);
      var resolvedLink = pathModule.resolve(previous, target);
      if (cache)
        cache[base2] = resolvedLink;
      gotResolvedLink(resolvedLink);
    }
    function gotResolvedLink(resolvedLink) {
      p = pathModule.resolve(resolvedLink, p.slice(pos));
      start();
    }
  };
});

// ../../node_modules/.pnpm/fs.realpath@1.0.0/node_modules/fs.realpath/index.js
var require_fs = __commonJS((exports2, module2) => {
  module2.exports = realpath;
  realpath.realpath = realpath;
  realpath.sync = realpathSync;
  realpath.realpathSync = realpathSync;
  realpath.monkeypatch = monkeypatch;
  realpath.unmonkeypatch = unmonkeypatch;
  var fs9 = require("fs");
  var origRealpath = fs9.realpath;
  var origRealpathSync = fs9.realpathSync;
  var version = process.version;
  var ok = /^v[0-5]\./.test(version);
  var old = require_old();
  function newError(er) {
    return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
  }
  function realpath(p, cache, cb) {
    if (ok) {
      return origRealpath(p, cache, cb);
    }
    if (typeof cache === "function") {
      cb = cache;
      cache = null;
    }
    origRealpath(p, cache, function(er, result) {
      if (newError(er)) {
        old.realpath(p, cache, cb);
      } else {
        cb(er, result);
      }
    });
  }
  function realpathSync(p, cache) {
    if (ok) {
      return origRealpathSync(p, cache);
    }
    try {
      return origRealpathSync(p, cache);
    } catch (er) {
      if (newError(er)) {
        return old.realpathSync(p, cache);
      } else {
        throw er;
      }
    }
  }
  function monkeypatch() {
    fs9.realpath = realpath;
    fs9.realpathSync = realpathSync;
  }
  function unmonkeypatch() {
    fs9.realpath = origRealpath;
    fs9.realpathSync = origRealpathSync;
  }
});

// ../../node_modules/.pnpm/concat-map@0.0.1/node_modules/concat-map/index.js
var require_concat_map = __commonJS((exports2, module2) => {
  module2.exports = function(xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
      var x = fn(xs[i], i);
      if (isArray(x))
        res.push.apply(res, x);
      else
        res.push(x);
    }
    return res;
  };
  var isArray = Array.isArray || function(xs) {
    return Object.prototype.toString.call(xs) === "[object Array]";
  };
});

// ../../node_modules/.pnpm/balanced-match@1.0.0/node_modules/balanced-match/index.js
var require_balanced_match = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = balanced;
  function balanced(a, b, str) {
    if (a instanceof RegExp)
      a = maybeMatch(a, str);
    if (b instanceof RegExp)
      b = maybeMatch(b, str);
    var r = range(a, b, str);
    return r && {
      start: r[0],
      end: r[1],
      pre: str.slice(0, r[0]),
      body: str.slice(r[0] + a.length, r[1]),
      post: str.slice(r[1] + b.length)
    };
  }
  function maybeMatch(reg, str) {
    var m2 = str.match(reg);
    return m2 ? m2[0] : null;
  }
  balanced.range = range;
  function range(a, b, str) {
    var begs, beg, left, right, result;
    var ai = str.indexOf(a);
    var bi = str.indexOf(b, ai + 1);
    var i = ai;
    if (ai >= 0 && bi > 0) {
      begs = [];
      left = str.length;
      while (i >= 0 && !result) {
        if (i == ai) {
          begs.push(i);
          ai = str.indexOf(a, i + 1);
        } else if (begs.length == 1) {
          result = [begs.pop(), bi];
        } else {
          beg = begs.pop();
          if (beg < left) {
            left = beg;
            right = bi;
          }
          bi = str.indexOf(b, i + 1);
        }
        i = ai < bi && ai >= 0 ? ai : bi;
      }
      if (begs.length) {
        result = [left, right];
      }
    }
    return result;
  }
});

// ../../node_modules/.pnpm/brace-expansion@1.1.11/node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS((exports2, module2) => {
  var concatMap = require_concat_map();
  var balanced = require_balanced_match();
  module2.exports = expandTop;
  var escSlash = "\0SLASH" + Math.random() + "\0";
  var escOpen = "\0OPEN" + Math.random() + "\0";
  var escClose = "\0CLOSE" + Math.random() + "\0";
  var escComma = "\0COMMA" + Math.random() + "\0";
  var escPeriod = "\0PERIOD" + Math.random() + "\0";
  function numeric(str) {
    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
  }
  function escapeBraces(str) {
    return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  }
  function unescapeBraces(str) {
    return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  }
  function parseCommaParts(str) {
    if (!str)
      return [""];
    var parts = [];
    var m2 = balanced("{", "}", str);
    if (!m2)
      return str.split(",");
    var pre = m2.pre;
    var body = m2.body;
    var post = m2.post;
    var p = pre.split(",");
    p[p.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    if (post.length) {
      p[p.length - 1] += postParts.shift();
      p.push.apply(p, postParts);
    }
    parts.push.apply(parts, p);
    return parts;
  }
  function expandTop(str) {
    if (!str)
      return [];
    if (str.substr(0, 2) === "{}") {
      str = "\\{\\}" + str.substr(2);
    }
    return expand(escapeBraces(str), true).map(unescapeBraces);
  }
  function embrace(str) {
    return "{" + str + "}";
  }
  function isPadded(el) {
    return /^-?0\d/.test(el);
  }
  function lte(i, y2) {
    return i <= y2;
  }
  function gte(i, y2) {
    return i >= y2;
  }
  function expand(str, isTop) {
    var expansions = [];
    var m2 = balanced("{", "}", str);
    if (!m2 || /\$$/.test(m2.pre))
      return [str];
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m2.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m2.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m2.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m2.post.match(/,.*\}/)) {
        str = m2.pre + "{" + m2.body + escClose + m2.post;
        return expand(str);
      }
      return [str];
    }
    var n;
    if (isSequence) {
      n = m2.body.split(/\.\./);
    } else {
      n = parseCommaParts(m2.body);
      if (n.length === 1) {
        n = expand(n[0], false).map(embrace);
        if (n.length === 1) {
          var post = m2.post.length ? expand(m2.post, false) : [""];
          return post.map(function(p) {
            return m2.pre + n[0] + p;
          });
        }
      }
    }
    var pre = m2.pre;
    var post = m2.post.length ? expand(m2.post, false) : [""];
    var N;
    if (isSequence) {
      var x = numeric(n[0]);
      var y2 = numeric(n[1]);
      var width = Math.max(n[0].length, n[1].length);
      var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
      var test = lte;
      var reverse = y2 < x;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      var pad = n.some(isPadded);
      N = [];
      for (var i = x; test(i, y2); i += incr) {
        var c;
        if (isAlphaSequence) {
          c = String.fromCharCode(i);
          if (c === "\\")
            c = "";
        } else {
          c = String(i);
          if (pad) {
            var need = width - c.length;
            if (need > 0) {
              var z = new Array(need + 1).join("0");
              if (i < 0)
                c = "-" + z + c.slice(1);
              else
                c = z + c;
            }
          }
        }
        N.push(c);
      }
    } else {
      N = concatMap(n, function(el) {
        return expand(el, false);
      });
    }
    for (var j = 0; j < N.length; j++) {
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion)
          expansions.push(expansion);
      }
    }
    return expansions;
  }
});

// ../../node_modules/.pnpm/minimatch@3.0.4/node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS((exports2, module2) => {
  module2.exports = minimatch;
  minimatch.Minimatch = Minimatch;
  var path10 = {sep: "/"};
  try {
    path10 = require("path");
  } catch (er) {
  }
  var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
  var expand = require_brace_expansion();
  var plTypes = {
    "!": {open: "(?:(?!(?:", close: "))[^/]*?)"},
    "?": {open: "(?:", close: ")?"},
    "+": {open: "(?:", close: ")+"},
    "*": {open: "(?:", close: ")*"},
    "@": {open: "(?:", close: ")"}
  };
  var qmark = "[^/]";
  var star = qmark + "*?";
  var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
  var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
  var reSpecials = charSet("().*{}+?[]^$\\!");
  function charSet(s2) {
    return s2.split("").reduce(function(set, c) {
      set[c] = true;
      return set;
    }, {});
  }
  var slashSplit = /\/+/;
  minimatch.filter = filter;
  function filter(pattern, options) {
    options = options || {};
    return function(p, i, list) {
      return minimatch(p, pattern, options);
    };
  }
  function ext(a, b) {
    a = a || {};
    b = b || {};
    var t = {};
    Object.keys(b).forEach(function(k) {
      t[k] = b[k];
    });
    Object.keys(a).forEach(function(k) {
      t[k] = a[k];
    });
    return t;
  }
  minimatch.defaults = function(def) {
    if (!def || !Object.keys(def).length)
      return minimatch;
    var orig = minimatch;
    var m2 = function minimatch2(p, pattern, options) {
      return orig.minimatch(p, pattern, ext(def, options));
    };
    m2.Minimatch = function Minimatch2(pattern, options) {
      return new orig.Minimatch(pattern, ext(def, options));
    };
    return m2;
  };
  Minimatch.defaults = function(def) {
    if (!def || !Object.keys(def).length)
      return Minimatch;
    return minimatch.defaults(def).Minimatch;
  };
  function minimatch(p, pattern, options) {
    if (typeof pattern !== "string") {
      throw new TypeError("glob pattern string required");
    }
    if (!options)
      options = {};
    if (!options.nocomment && pattern.charAt(0) === "#") {
      return false;
    }
    if (pattern.trim() === "")
      return p === "";
    return new Minimatch(pattern, options).match(p);
  }
  function Minimatch(pattern, options) {
    if (!(this instanceof Minimatch)) {
      return new Minimatch(pattern, options);
    }
    if (typeof pattern !== "string") {
      throw new TypeError("glob pattern string required");
    }
    if (!options)
      options = {};
    pattern = pattern.trim();
    if (path10.sep !== "/") {
      pattern = pattern.split(path10.sep).join("/");
    }
    this.options = options;
    this.set = [];
    this.pattern = pattern;
    this.regexp = null;
    this.negate = false;
    this.comment = false;
    this.empty = false;
    this.make();
  }
  Minimatch.prototype.debug = function() {
  };
  Minimatch.prototype.make = make;
  function make() {
    if (this._made)
      return;
    var pattern = this.pattern;
    var options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    var set = this.globSet = this.braceExpand();
    if (options.debug)
      this.debug = console.error;
    this.debug(this.pattern, set);
    set = this.globParts = set.map(function(s2) {
      return s2.split(slashSplit);
    });
    this.debug(this.pattern, set);
    set = set.map(function(s2, si, set2) {
      return s2.map(this.parse, this);
    }, this);
    this.debug(this.pattern, set);
    set = set.filter(function(s2) {
      return s2.indexOf(false) === -1;
    });
    this.debug(this.pattern, set);
    this.set = set;
  }
  Minimatch.prototype.parseNegate = parseNegate;
  function parseNegate() {
    var pattern = this.pattern;
    var negate = false;
    var options = this.options;
    var negateOffset = 0;
    if (options.nonegate)
      return;
    for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.substr(negateOffset);
    this.negate = negate;
  }
  minimatch.braceExpand = function(pattern, options) {
    return braceExpand(pattern, options);
  };
  Minimatch.prototype.braceExpand = braceExpand;
  function braceExpand(pattern, options) {
    if (!options) {
      if (this instanceof Minimatch) {
        options = this.options;
      } else {
        options = {};
      }
    }
    pattern = typeof pattern === "undefined" ? this.pattern : pattern;
    if (typeof pattern === "undefined") {
      throw new TypeError("undefined pattern");
    }
    if (options.nobrace || !pattern.match(/\{.*\}/)) {
      return [pattern];
    }
    return expand(pattern);
  }
  Minimatch.prototype.parse = parse2;
  var SUBPARSE = {};
  function parse2(pattern, isSub) {
    if (pattern.length > 1024 * 64) {
      throw new TypeError("pattern is too long");
    }
    var options = this.options;
    if (!options.noglobstar && pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    var re = "";
    var hasMagic = !!options.nocase;
    var escaping = false;
    var patternListStack = [];
    var negativeLists = [];
    var stateChar;
    var inClass = false;
    var reClassStart = -1;
    var classStart = -1;
    var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
    var self2 = this;
    function clearStateChar() {
      if (stateChar) {
        switch (stateChar) {
          case "*":
            re += star;
            hasMagic = true;
            break;
          case "?":
            re += qmark;
            hasMagic = true;
            break;
          default:
            re += "\\" + stateChar;
            break;
        }
        self2.debug("clearStateChar %j %j", stateChar, re);
        stateChar = false;
      }
    }
    for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
      this.debug("%s	%s %s %j", pattern, i, re, c);
      if (escaping && reSpecials[c]) {
        re += "\\" + c;
        escaping = false;
        continue;
      }
      switch (c) {
        case "/":
          return false;
        case "\\":
          clearStateChar();
          escaping = true;
          continue;
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
          if (inClass) {
            this.debug("  in class");
            if (c === "!" && i === classStart + 1)
              c = "^";
            re += c;
            continue;
          }
          self2.debug("call clearStateChar %j", stateChar);
          clearStateChar();
          stateChar = c;
          if (options.noext)
            clearStateChar();
          continue;
        case "(":
          if (inClass) {
            re += "(";
            continue;
          }
          if (!stateChar) {
            re += "\\(";
            continue;
          }
          patternListStack.push({
            type: stateChar,
            start: i - 1,
            reStart: re.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close
          });
          re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
          this.debug("plType %j %j", stateChar, re);
          stateChar = false;
          continue;
        case ")":
          if (inClass || !patternListStack.length) {
            re += "\\)";
            continue;
          }
          clearStateChar();
          hasMagic = true;
          var pl = patternListStack.pop();
          re += pl.close;
          if (pl.type === "!") {
            negativeLists.push(pl);
          }
          pl.reEnd = re.length;
          continue;
        case "|":
          if (inClass || !patternListStack.length || escaping) {
            re += "\\|";
            escaping = false;
            continue;
          }
          clearStateChar();
          re += "|";
          continue;
        case "[":
          clearStateChar();
          if (inClass) {
            re += "\\" + c;
            continue;
          }
          inClass = true;
          classStart = i;
          reClassStart = re.length;
          re += c;
          continue;
        case "]":
          if (i === classStart + 1 || !inClass) {
            re += "\\" + c;
            escaping = false;
            continue;
          }
          if (inClass) {
            var cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + cs + "]");
            } catch (er) {
              var sp = this.parse(cs, SUBPARSE);
              re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
              hasMagic = hasMagic || sp[1];
              inClass = false;
              continue;
            }
          }
          hasMagic = true;
          inClass = false;
          re += c;
          continue;
        default:
          clearStateChar();
          if (escaping) {
            escaping = false;
          } else if (reSpecials[c] && !(c === "^" && inClass)) {
            re += "\\";
          }
          re += c;
      }
    }
    if (inClass) {
      cs = pattern.substr(classStart + 1);
      sp = this.parse(cs, SUBPARSE);
      re = re.substr(0, reClassStart) + "\\[" + sp[0];
      hasMagic = hasMagic || sp[1];
    }
    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
      var tail = re.slice(pl.reStart + pl.open.length);
      this.debug("setting tail", re, pl);
      tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_2, $1, $2) {
        if (!$2) {
          $2 = "\\";
        }
        return $1 + $1 + $2 + "|";
      });
      this.debug("tail=%j\n   %s", tail, tail, pl, re);
      var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
      hasMagic = true;
      re = re.slice(0, pl.reStart) + t + "\\(" + tail;
    }
    clearStateChar();
    if (escaping) {
      re += "\\\\";
    }
    var addPatternStart = false;
    switch (re.charAt(0)) {
      case ".":
      case "[":
      case "(":
        addPatternStart = true;
    }
    for (var n = negativeLists.length - 1; n > -1; n--) {
      var nl = negativeLists[n];
      var nlBefore = re.slice(0, nl.reStart);
      var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
      var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
      var nlAfter = re.slice(nl.reEnd);
      nlLast += nlAfter;
      var openParensBefore = nlBefore.split("(").length - 1;
      var cleanAfter = nlAfter;
      for (i = 0; i < openParensBefore; i++) {
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
      }
      nlAfter = cleanAfter;
      var dollar = "";
      if (nlAfter === "" && isSub !== SUBPARSE) {
        dollar = "$";
      }
      var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
      re = newRe;
    }
    if (re !== "" && hasMagic) {
      re = "(?=.)" + re;
    }
    if (addPatternStart) {
      re = patternStart + re;
    }
    if (isSub === SUBPARSE) {
      return [re, hasMagic];
    }
    if (!hasMagic) {
      return globUnescape(pattern);
    }
    var flags = options.nocase ? "i" : "";
    try {
      var regExp = new RegExp("^" + re + "$", flags);
    } catch (er) {
      return new RegExp("$.");
    }
    regExp._glob = pattern;
    regExp._src = re;
    return regExp;
  }
  minimatch.makeRe = function(pattern, options) {
    return new Minimatch(pattern, options || {}).makeRe();
  };
  Minimatch.prototype.makeRe = makeRe;
  function makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    var set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    var options = this.options;
    var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
    var flags = options.nocase ? "i" : "";
    var re = set.map(function(pattern) {
      return pattern.map(function(p) {
        return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
      }).join("\\/");
    }).join("|");
    re = "^(?:" + re + ")$";
    if (this.negate)
      re = "^(?!" + re + ").*$";
    try {
      this.regexp = new RegExp(re, flags);
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  minimatch.match = function(list, pattern, options) {
    options = options || {};
    var mm = new Minimatch(pattern, options);
    list = list.filter(function(f) {
      return mm.match(f);
    });
    if (mm.options.nonull && !list.length) {
      list.push(pattern);
    }
    return list;
  };
  Minimatch.prototype.match = match;
  function match(f, partial) {
    this.debug("match", f, this.pattern);
    if (this.comment)
      return false;
    if (this.empty)
      return f === "";
    if (f === "/" && partial)
      return true;
    var options = this.options;
    if (path10.sep !== "/") {
      f = f.split(path10.sep).join("/");
    }
    f = f.split(slashSplit);
    this.debug(this.pattern, "split", f);
    var set = this.set;
    this.debug(this.pattern, "set", set);
    var filename;
    var i;
    for (i = f.length - 1; i >= 0; i--) {
      filename = f[i];
      if (filename)
        break;
    }
    for (i = 0; i < set.length; i++) {
      var pattern = set[i];
      var file = f;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      var hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options.flipNegate)
          return true;
        return !this.negate;
      }
    }
    if (options.flipNegate)
      return false;
    return this.negate;
  }
  Minimatch.prototype.matchOne = function(file, pattern, partial) {
    var options = this.options;
    this.debug("matchOne", {this: this, file, pattern});
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi];
      var f = file[fi];
      this.debug(pattern, p, f);
      if (p === false)
        return false;
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
          if (fr === fl)
            return true;
        }
        return false;
      }
      var hit;
      if (typeof p === "string") {
        if (options.nocase) {
          hit = f.toLowerCase() === p.toLowerCase();
        } else {
          hit = f === p;
        }
        this.debug("string match", p, f, hit);
      } else {
        hit = f.match(p);
        this.debug("pattern match", p, f, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      var emptyFileEnd = fi === fl - 1 && file[fi] === "";
      return emptyFileEnd;
    }
    throw new Error("wtf?");
  };
  function globUnescape(s2) {
    return s2.replace(/\\(.)/g, "$1");
  }
  function regExpEscape(s2) {
    return s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  }
});

// ../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS((exports2, module2) => {
  if (typeof Object.create === "function") {
    module2.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module2.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});

// ../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js
var require_inherits = __commonJS((exports2, module2) => {
  try {
    util2 = require("util");
    if (typeof util2.inherits !== "function")
      throw "";
    module2.exports = util2.inherits;
  } catch (e) {
    module2.exports = require_inherits_browser();
  }
  var util2;
});

// ../../node_modules/.pnpm/path-is-absolute@1.0.1/node_modules/path-is-absolute/index.js
var require_path_is_absolute = __commonJS((exports2, module2) => {
  "use strict";
  function posix(path10) {
    return path10.charAt(0) === "/";
  }
  function win32(path10) {
    var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
    var result = splitDeviceRe.exec(path10);
    var device = result[1] || "";
    var isUnc = Boolean(device && device.charAt(1) !== ":");
    return Boolean(result[2] || isUnc);
  }
  module2.exports = process.platform === "win32" ? win32 : posix;
  module2.exports.posix = posix;
  module2.exports.win32 = win32;
});

// ../../node_modules/.pnpm/glob@7.1.7/node_modules/glob/common.js
var require_common4 = __commonJS((exports2) => {
  exports2.setopts = setopts;
  exports2.ownProp = ownProp;
  exports2.makeAbs = makeAbs;
  exports2.finish = finish;
  exports2.mark = mark;
  exports2.isIgnored = isIgnored;
  exports2.childrenIgnored = childrenIgnored;
  function ownProp(obj, field) {
    return Object.prototype.hasOwnProperty.call(obj, field);
  }
  var path10 = require("path");
  var minimatch = require_minimatch();
  var isAbsolute = require_path_is_absolute();
  var Minimatch = minimatch.Minimatch;
  function alphasort(a, b) {
    return a.localeCompare(b, "en");
  }
  function setupIgnores(self2, options) {
    self2.ignore = options.ignore || [];
    if (!Array.isArray(self2.ignore))
      self2.ignore = [self2.ignore];
    if (self2.ignore.length) {
      self2.ignore = self2.ignore.map(ignoreMap);
    }
  }
  function ignoreMap(pattern) {
    var gmatcher = null;
    if (pattern.slice(-3) === "/**") {
      var gpattern = pattern.replace(/(\/\*\*)+$/, "");
      gmatcher = new Minimatch(gpattern, {dot: true});
    }
    return {
      matcher: new Minimatch(pattern, {dot: true}),
      gmatcher
    };
  }
  function setopts(self2, pattern, options) {
    if (!options)
      options = {};
    if (options.matchBase && pattern.indexOf("/") === -1) {
      if (options.noglobstar) {
        throw new Error("base matching requires globstar");
      }
      pattern = "**/" + pattern;
    }
    self2.silent = !!options.silent;
    self2.pattern = pattern;
    self2.strict = options.strict !== false;
    self2.realpath = !!options.realpath;
    self2.realpathCache = options.realpathCache || Object.create(null);
    self2.follow = !!options.follow;
    self2.dot = !!options.dot;
    self2.mark = !!options.mark;
    self2.nodir = !!options.nodir;
    if (self2.nodir)
      self2.mark = true;
    self2.sync = !!options.sync;
    self2.nounique = !!options.nounique;
    self2.nonull = !!options.nonull;
    self2.nosort = !!options.nosort;
    self2.nocase = !!options.nocase;
    self2.stat = !!options.stat;
    self2.noprocess = !!options.noprocess;
    self2.absolute = !!options.absolute;
    self2.maxLength = options.maxLength || Infinity;
    self2.cache = options.cache || Object.create(null);
    self2.statCache = options.statCache || Object.create(null);
    self2.symlinks = options.symlinks || Object.create(null);
    setupIgnores(self2, options);
    self2.changedCwd = false;
    var cwd = process.cwd();
    if (!ownProp(options, "cwd"))
      self2.cwd = cwd;
    else {
      self2.cwd = path10.resolve(options.cwd);
      self2.changedCwd = self2.cwd !== cwd;
    }
    self2.root = options.root || path10.resolve(self2.cwd, "/");
    self2.root = path10.resolve(self2.root);
    if (process.platform === "win32")
      self2.root = self2.root.replace(/\\/g, "/");
    self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
    if (process.platform === "win32")
      self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
    self2.nomount = !!options.nomount;
    options.nonegate = true;
    options.nocomment = true;
    self2.minimatch = new Minimatch(pattern, options);
    self2.options = self2.minimatch.options;
  }
  function finish(self2) {
    var nou = self2.nounique;
    var all = nou ? [] : Object.create(null);
    for (var i = 0, l = self2.matches.length; i < l; i++) {
      var matches = self2.matches[i];
      if (!matches || Object.keys(matches).length === 0) {
        if (self2.nonull) {
          var literal = self2.minimatch.globSet[i];
          if (nou)
            all.push(literal);
          else
            all[literal] = true;
        }
      } else {
        var m2 = Object.keys(matches);
        if (nou)
          all.push.apply(all, m2);
        else
          m2.forEach(function(m3) {
            all[m3] = true;
          });
      }
    }
    if (!nou)
      all = Object.keys(all);
    if (!self2.nosort)
      all = all.sort(alphasort);
    if (self2.mark) {
      for (var i = 0; i < all.length; i++) {
        all[i] = self2._mark(all[i]);
      }
      if (self2.nodir) {
        all = all.filter(function(e) {
          var notDir = !/\/$/.test(e);
          var c = self2.cache[e] || self2.cache[makeAbs(self2, e)];
          if (notDir && c)
            notDir = c !== "DIR" && !Array.isArray(c);
          return notDir;
        });
      }
    }
    if (self2.ignore.length)
      all = all.filter(function(m3) {
        return !isIgnored(self2, m3);
      });
    self2.found = all;
  }
  function mark(self2, p) {
    var abs = makeAbs(self2, p);
    var c = self2.cache[abs];
    var m2 = p;
    if (c) {
      var isDir = c === "DIR" || Array.isArray(c);
      var slash = p.slice(-1) === "/";
      if (isDir && !slash)
        m2 += "/";
      else if (!isDir && slash)
        m2 = m2.slice(0, -1);
      if (m2 !== p) {
        var mabs = makeAbs(self2, m2);
        self2.statCache[mabs] = self2.statCache[abs];
        self2.cache[mabs] = self2.cache[abs];
      }
    }
    return m2;
  }
  function makeAbs(self2, f) {
    var abs = f;
    if (f.charAt(0) === "/") {
      abs = path10.join(self2.root, f);
    } else if (isAbsolute(f) || f === "") {
      abs = f;
    } else if (self2.changedCwd) {
      abs = path10.resolve(self2.cwd, f);
    } else {
      abs = path10.resolve(f);
    }
    if (process.platform === "win32")
      abs = abs.replace(/\\/g, "/");
    return abs;
  }
  function isIgnored(self2, path11) {
    if (!self2.ignore.length)
      return false;
    return self2.ignore.some(function(item) {
      return item.matcher.match(path11) || !!(item.gmatcher && item.gmatcher.match(path11));
    });
  }
  function childrenIgnored(self2, path11) {
    if (!self2.ignore.length)
      return false;
    return self2.ignore.some(function(item) {
      return !!(item.gmatcher && item.gmatcher.match(path11));
    });
  }
});

// ../../node_modules/.pnpm/glob@7.1.7/node_modules/glob/sync.js
var require_sync2 = __commonJS((exports2, module2) => {
  module2.exports = globSync;
  globSync.GlobSync = GlobSync;
  var fs9 = require("fs");
  var rp = require_fs();
  var minimatch = require_minimatch();
  var Minimatch = minimatch.Minimatch;
  var Glob = require_glob().Glob;
  var util2 = require("util");
  var path10 = require("path");
  var assert = require("assert");
  var isAbsolute = require_path_is_absolute();
  var common = require_common4();
  var setopts = common.setopts;
  var ownProp = common.ownProp;
  var childrenIgnored = common.childrenIgnored;
  var isIgnored = common.isIgnored;
  function globSync(pattern, options) {
    if (typeof options === "function" || arguments.length === 3)
      throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
    return new GlobSync(pattern, options).found;
  }
  function GlobSync(pattern, options) {
    if (!pattern)
      throw new Error("must provide pattern");
    if (typeof options === "function" || arguments.length === 3)
      throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
    if (!(this instanceof GlobSync))
      return new GlobSync(pattern, options);
    setopts(this, pattern, options);
    if (this.noprocess)
      return this;
    var n = this.minimatch.set.length;
    this.matches = new Array(n);
    for (var i = 0; i < n; i++) {
      this._process(this.minimatch.set[i], i, false);
    }
    this._finish();
  }
  GlobSync.prototype._finish = function() {
    assert(this instanceof GlobSync);
    if (this.realpath) {
      var self2 = this;
      this.matches.forEach(function(matchset, index) {
        var set = self2.matches[index] = Object.create(null);
        for (var p in matchset) {
          try {
            p = self2._makeAbs(p);
            var real = rp.realpathSync(p, self2.realpathCache);
            set[real] = true;
          } catch (er) {
            if (er.syscall === "stat")
              set[self2._makeAbs(p)] = true;
            else
              throw er;
          }
        }
      });
    }
    common.finish(this);
  };
  GlobSync.prototype._process = function(pattern, index, inGlobStar) {
    assert(this instanceof GlobSync);
    var n = 0;
    while (typeof pattern[n] === "string") {
      n++;
    }
    var prefix;
    switch (n) {
      case pattern.length:
        this._processSimple(pattern.join("/"), index);
        return;
      case 0:
        prefix = null;
        break;
      default:
        prefix = pattern.slice(0, n).join("/");
        break;
    }
    var remain = pattern.slice(n);
    var read;
    if (prefix === null)
      read = ".";
    else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
      if (!prefix || !isAbsolute(prefix))
        prefix = "/" + prefix;
      read = prefix;
    } else
      read = prefix;
    var abs = this._makeAbs(read);
    if (childrenIgnored(this, read))
      return;
    var isGlobStar = remain[0] === minimatch.GLOBSTAR;
    if (isGlobStar)
      this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
    else
      this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
  };
  GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    if (!entries)
      return;
    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === ".";
    var matchedEntries = [];
    for (var i = 0; i < entries.length; i++) {
      var e = entries[i];
      if (e.charAt(0) !== "." || dotOk) {
        var m2;
        if (negate && !prefix) {
          m2 = !e.match(pn);
        } else {
          m2 = e.match(pn);
        }
        if (m2)
          matchedEntries.push(e);
      }
    }
    var len = matchedEntries.length;
    if (len === 0)
      return;
    if (remain.length === 1 && !this.mark && !this.stat) {
      if (!this.matches[index])
        this.matches[index] = Object.create(null);
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        if (prefix) {
          if (prefix.slice(-1) !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        if (e.charAt(0) === "/" && !this.nomount) {
          e = path10.join(this.root, e);
        }
        this._emitMatch(index, e);
      }
      return;
    }
    remain.shift();
    for (var i = 0; i < len; i++) {
      var e = matchedEntries[i];
      var newPattern;
      if (prefix)
        newPattern = [prefix, e];
      else
        newPattern = [e];
      this._process(newPattern.concat(remain), index, inGlobStar);
    }
  };
  GlobSync.prototype._emitMatch = function(index, e) {
    if (isIgnored(this, e))
      return;
    var abs = this._makeAbs(e);
    if (this.mark)
      e = this._mark(e);
    if (this.absolute) {
      e = abs;
    }
    if (this.matches[index][e])
      return;
    if (this.nodir) {
      var c = this.cache[abs];
      if (c === "DIR" || Array.isArray(c))
        return;
    }
    this.matches[index][e] = true;
    if (this.stat)
      this._stat(e);
  };
  GlobSync.prototype._readdirInGlobStar = function(abs) {
    if (this.follow)
      return this._readdir(abs, false);
    var entries;
    var lstat;
    var stat;
    try {
      lstat = fs9.lstatSync(abs);
    } catch (er) {
      if (er.code === "ENOENT") {
        return null;
      }
    }
    var isSym = lstat && lstat.isSymbolicLink();
    this.symlinks[abs] = isSym;
    if (!isSym && lstat && !lstat.isDirectory())
      this.cache[abs] = "FILE";
    else
      entries = this._readdir(abs, false);
    return entries;
  };
  GlobSync.prototype._readdir = function(abs, inGlobStar) {
    var entries;
    if (inGlobStar && !ownProp(this.symlinks, abs))
      return this._readdirInGlobStar(abs);
    if (ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (!c || c === "FILE")
        return null;
      if (Array.isArray(c))
        return c;
    }
    try {
      return this._readdirEntries(abs, fs9.readdirSync(abs));
    } catch (er) {
      this._readdirError(abs, er);
      return null;
    }
  };
  GlobSync.prototype._readdirEntries = function(abs, entries) {
    if (!this.mark && !this.stat) {
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (abs === "/")
          e = abs + e;
        else
          e = abs + "/" + e;
        this.cache[e] = true;
      }
    }
    this.cache[abs] = entries;
    return entries;
  };
  GlobSync.prototype._readdirError = function(f, er) {
    switch (er.code) {
      case "ENOTSUP":
      case "ENOTDIR":
        var abs = this._makeAbs(f);
        this.cache[abs] = "FILE";
        if (abs === this.cwdAbs) {
          var error = new Error(er.code + " invalid cwd " + this.cwd);
          error.path = this.cwd;
          error.code = er.code;
          throw error;
        }
        break;
      case "ENOENT":
      case "ELOOP":
      case "ENAMETOOLONG":
      case "UNKNOWN":
        this.cache[this._makeAbs(f)] = false;
        break;
      default:
        this.cache[this._makeAbs(f)] = false;
        if (this.strict)
          throw er;
        if (!this.silent)
          console.error("glob error", er);
        break;
    }
  };
  GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    if (!entries)
      return;
    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix ? [prefix] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar);
    this._process(noGlobStar, index, false);
    var len = entries.length;
    var isSym = this.symlinks[abs];
    if (isSym && inGlobStar)
      return;
    for (var i = 0; i < len; i++) {
      var e = entries[i];
      if (e.charAt(0) === "." && !this.dot)
        continue;
      var instead = gspref.concat(entries[i], remainWithoutGlobStar);
      this._process(instead, index, true);
      var below = gspref.concat(entries[i], remain);
      this._process(below, index, true);
    }
  };
  GlobSync.prototype._processSimple = function(prefix, index) {
    var exists2 = this._stat(prefix);
    if (!this.matches[index])
      this.matches[index] = Object.create(null);
    if (!exists2)
      return;
    if (prefix && isAbsolute(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix);
      if (prefix.charAt(0) === "/") {
        prefix = path10.join(this.root, prefix);
      } else {
        prefix = path10.resolve(this.root, prefix);
        if (trail)
          prefix += "/";
      }
    }
    if (process.platform === "win32")
      prefix = prefix.replace(/\\/g, "/");
    this._emitMatch(index, prefix);
  };
  GlobSync.prototype._stat = function(f) {
    var abs = this._makeAbs(f);
    var needDir = f.slice(-1) === "/";
    if (f.length > this.maxLength)
      return false;
    if (!this.stat && ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (Array.isArray(c))
        c = "DIR";
      if (!needDir || c === "DIR")
        return c;
      if (needDir && c === "FILE")
        return false;
    }
    var exists2;
    var stat = this.statCache[abs];
    if (!stat) {
      var lstat;
      try {
        lstat = fs9.lstatSync(abs);
      } catch (er) {
        if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
          this.statCache[abs] = false;
          return false;
        }
      }
      if (lstat && lstat.isSymbolicLink()) {
        try {
          stat = fs9.statSync(abs);
        } catch (er) {
          stat = lstat;
        }
      } else {
        stat = lstat;
      }
    }
    this.statCache[abs] = stat;
    var c = true;
    if (stat)
      c = stat.isDirectory() ? "DIR" : "FILE";
    this.cache[abs] = this.cache[abs] || c;
    if (needDir && c === "FILE")
      return false;
    return c;
  };
  GlobSync.prototype._mark = function(p) {
    return common.mark(this, p);
  };
  GlobSync.prototype._makeAbs = function(f) {
    return common.makeAbs(this, f);
  };
});

// ../../node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS((exports2, module2) => {
  module2.exports = wrappy;
  function wrappy(fn, cb) {
    if (fn && cb)
      return wrappy(fn)(cb);
    if (typeof fn !== "function")
      throw new TypeError("need wrapper function");
    Object.keys(fn).forEach(function(k) {
      wrapper[k] = fn[k];
    });
    return wrapper;
    function wrapper() {
      var args2 = new Array(arguments.length);
      for (var i = 0; i < args2.length; i++) {
        args2[i] = arguments[i];
      }
      var ret = fn.apply(this, args2);
      var cb2 = args2[args2.length - 1];
      if (typeof ret === "function" && ret !== cb2) {
        Object.keys(cb2).forEach(function(k) {
          ret[k] = cb2[k];
        });
      }
      return ret;
    }
  }
});

// ../../node_modules/.pnpm/once@1.4.0/node_modules/once/once.js
var require_once = __commonJS((exports2, module2) => {
  var wrappy = require_wrappy();
  module2.exports = wrappy(once);
  module2.exports.strict = wrappy(onceStrict);
  once.proto = once(function() {
    Object.defineProperty(Function.prototype, "once", {
      value: function() {
        return once(this);
      },
      configurable: true
    });
    Object.defineProperty(Function.prototype, "onceStrict", {
      value: function() {
        return onceStrict(this);
      },
      configurable: true
    });
  });
  function once(fn) {
    var f = function() {
      if (f.called)
        return f.value;
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    f.called = false;
    return f;
  }
  function onceStrict(fn) {
    var f = function() {
      if (f.called)
        throw new Error(f.onceError);
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    var name = fn.name || "Function wrapped with `once`";
    f.onceError = name + " shouldn't be called more than once";
    f.called = false;
    return f;
  }
});

// ../../node_modules/.pnpm/inflight@1.0.6/node_modules/inflight/inflight.js
var require_inflight = __commonJS((exports2, module2) => {
  var wrappy = require_wrappy();
  var reqs = Object.create(null);
  var once = require_once();
  module2.exports = wrappy(inflight);
  function inflight(key, cb) {
    if (reqs[key]) {
      reqs[key].push(cb);
      return null;
    } else {
      reqs[key] = [cb];
      return makeres(key);
    }
  }
  function makeres(key) {
    return once(function RES() {
      var cbs = reqs[key];
      var len = cbs.length;
      var args2 = slice(arguments);
      try {
        for (var i = 0; i < len; i++) {
          cbs[i].apply(null, args2);
        }
      } finally {
        if (cbs.length > len) {
          cbs.splice(0, len);
          process.nextTick(function() {
            RES.apply(null, args2);
          });
        } else {
          delete reqs[key];
        }
      }
    });
  }
  function slice(args2) {
    var length = args2.length;
    var array = [];
    for (var i = 0; i < length; i++)
      array[i] = args2[i];
    return array;
  }
});

// ../../node_modules/.pnpm/glob@7.1.7/node_modules/glob/glob.js
var require_glob = __commonJS((exports2, module2) => {
  module2.exports = glob;
  var fs9 = require("fs");
  var rp = require_fs();
  var minimatch = require_minimatch();
  var Minimatch = minimatch.Minimatch;
  var inherits = require_inherits();
  var EE = require("events").EventEmitter;
  var path10 = require("path");
  var assert = require("assert");
  var isAbsolute = require_path_is_absolute();
  var globSync = require_sync2();
  var common = require_common4();
  var setopts = common.setopts;
  var ownProp = common.ownProp;
  var inflight = require_inflight();
  var util2 = require("util");
  var childrenIgnored = common.childrenIgnored;
  var isIgnored = common.isIgnored;
  var once = require_once();
  function glob(pattern, options, cb) {
    if (typeof options === "function")
      cb = options, options = {};
    if (!options)
      options = {};
    if (options.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return globSync(pattern, options);
    }
    return new Glob(pattern, options, cb);
  }
  glob.sync = globSync;
  var GlobSync = glob.GlobSync = globSync.GlobSync;
  glob.glob = glob;
  function extend(origin, add) {
    if (add === null || typeof add !== "object") {
      return origin;
    }
    var keys = Object.keys(add);
    var i = keys.length;
    while (i--) {
      origin[keys[i]] = add[keys[i]];
    }
    return origin;
  }
  glob.hasMagic = function(pattern, options_) {
    var options = extend({}, options_);
    options.noprocess = true;
    var g = new Glob(pattern, options);
    var set = g.minimatch.set;
    if (!pattern)
      return false;
    if (set.length > 1)
      return true;
    for (var j = 0; j < set[0].length; j++) {
      if (typeof set[0][j] !== "string")
        return true;
    }
    return false;
  };
  glob.Glob = Glob;
  inherits(Glob, EE);
  function Glob(pattern, options, cb) {
    if (typeof options === "function") {
      cb = options;
      options = null;
    }
    if (options && options.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return new GlobSync(pattern, options);
    }
    if (!(this instanceof Glob))
      return new Glob(pattern, options, cb);
    setopts(this, pattern, options);
    this._didRealPath = false;
    var n = this.minimatch.set.length;
    this.matches = new Array(n);
    if (typeof cb === "function") {
      cb = once(cb);
      this.on("error", cb);
      this.on("end", function(matches) {
        cb(null, matches);
      });
    }
    var self2 = this;
    this._processing = 0;
    this._emitQueue = [];
    this._processQueue = [];
    this.paused = false;
    if (this.noprocess)
      return this;
    if (n === 0)
      return done();
    var sync2 = true;
    for (var i = 0; i < n; i++) {
      this._process(this.minimatch.set[i], i, false, done);
    }
    sync2 = false;
    function done() {
      --self2._processing;
      if (self2._processing <= 0) {
        if (sync2) {
          process.nextTick(function() {
            self2._finish();
          });
        } else {
          self2._finish();
        }
      }
    }
  }
  Glob.prototype._finish = function() {
    assert(this instanceof Glob);
    if (this.aborted)
      return;
    if (this.realpath && !this._didRealpath)
      return this._realpath();
    common.finish(this);
    this.emit("end", this.found);
  };
  Glob.prototype._realpath = function() {
    if (this._didRealpath)
      return;
    this._didRealpath = true;
    var n = this.matches.length;
    if (n === 0)
      return this._finish();
    var self2 = this;
    for (var i = 0; i < this.matches.length; i++)
      this._realpathSet(i, next);
    function next() {
      if (--n === 0)
        self2._finish();
    }
  };
  Glob.prototype._realpathSet = function(index, cb) {
    var matchset = this.matches[index];
    if (!matchset)
      return cb();
    var found = Object.keys(matchset);
    var self2 = this;
    var n = found.length;
    if (n === 0)
      return cb();
    var set = this.matches[index] = Object.create(null);
    found.forEach(function(p, i) {
      p = self2._makeAbs(p);
      rp.realpath(p, self2.realpathCache, function(er, real) {
        if (!er)
          set[real] = true;
        else if (er.syscall === "stat")
          set[p] = true;
        else
          self2.emit("error", er);
        if (--n === 0) {
          self2.matches[index] = set;
          cb();
        }
      });
    });
  };
  Glob.prototype._mark = function(p) {
    return common.mark(this, p);
  };
  Glob.prototype._makeAbs = function(f) {
    return common.makeAbs(this, f);
  };
  Glob.prototype.abort = function() {
    this.aborted = true;
    this.emit("abort");
  };
  Glob.prototype.pause = function() {
    if (!this.paused) {
      this.paused = true;
      this.emit("pause");
    }
  };
  Glob.prototype.resume = function() {
    if (this.paused) {
      this.emit("resume");
      this.paused = false;
      if (this._emitQueue.length) {
        var eq = this._emitQueue.slice(0);
        this._emitQueue.length = 0;
        for (var i = 0; i < eq.length; i++) {
          var e = eq[i];
          this._emitMatch(e[0], e[1]);
        }
      }
      if (this._processQueue.length) {
        var pq = this._processQueue.slice(0);
        this._processQueue.length = 0;
        for (var i = 0; i < pq.length; i++) {
          var p = pq[i];
          this._processing--;
          this._process(p[0], p[1], p[2], p[3]);
        }
      }
    }
  };
  Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
    assert(this instanceof Glob);
    assert(typeof cb === "function");
    if (this.aborted)
      return;
    this._processing++;
    if (this.paused) {
      this._processQueue.push([pattern, index, inGlobStar, cb]);
      return;
    }
    var n = 0;
    while (typeof pattern[n] === "string") {
      n++;
    }
    var prefix;
    switch (n) {
      case pattern.length:
        this._processSimple(pattern.join("/"), index, cb);
        return;
      case 0:
        prefix = null;
        break;
      default:
        prefix = pattern.slice(0, n).join("/");
        break;
    }
    var remain = pattern.slice(n);
    var read;
    if (prefix === null)
      read = ".";
    else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
      if (!prefix || !isAbsolute(prefix))
        prefix = "/" + prefix;
      read = prefix;
    } else
      read = prefix;
    var abs = this._makeAbs(read);
    if (childrenIgnored(this, read))
      return cb();
    var isGlobStar = remain[0] === minimatch.GLOBSTAR;
    if (isGlobStar)
      this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
    else
      this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
  };
  Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
    var self2 = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
      return self2._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
    });
  };
  Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === ".";
    var matchedEntries = [];
    for (var i = 0; i < entries.length; i++) {
      var e = entries[i];
      if (e.charAt(0) !== "." || dotOk) {
        var m2;
        if (negate && !prefix) {
          m2 = !e.match(pn);
        } else {
          m2 = e.match(pn);
        }
        if (m2)
          matchedEntries.push(e);
      }
    }
    var len = matchedEntries.length;
    if (len === 0)
      return cb();
    if (remain.length === 1 && !this.mark && !this.stat) {
      if (!this.matches[index])
        this.matches[index] = Object.create(null);
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        if (e.charAt(0) === "/" && !this.nomount) {
          e = path10.join(this.root, e);
        }
        this._emitMatch(index, e);
      }
      return cb();
    }
    remain.shift();
    for (var i = 0; i < len; i++) {
      var e = matchedEntries[i];
      var newPattern;
      if (prefix) {
        if (prefix !== "/")
          e = prefix + "/" + e;
        else
          e = prefix + e;
      }
      this._process([e].concat(remain), index, inGlobStar, cb);
    }
    cb();
  };
  Glob.prototype._emitMatch = function(index, e) {
    if (this.aborted)
      return;
    if (isIgnored(this, e))
      return;
    if (this.paused) {
      this._emitQueue.push([index, e]);
      return;
    }
    var abs = isAbsolute(e) ? e : this._makeAbs(e);
    if (this.mark)
      e = this._mark(e);
    if (this.absolute)
      e = abs;
    if (this.matches[index][e])
      return;
    if (this.nodir) {
      var c = this.cache[abs];
      if (c === "DIR" || Array.isArray(c))
        return;
    }
    this.matches[index][e] = true;
    var st = this.statCache[abs];
    if (st)
      this.emit("stat", e, st);
    this.emit("match", e);
  };
  Glob.prototype._readdirInGlobStar = function(abs, cb) {
    if (this.aborted)
      return;
    if (this.follow)
      return this._readdir(abs, false, cb);
    var lstatkey = "lstat\0" + abs;
    var self2 = this;
    var lstatcb = inflight(lstatkey, lstatcb_);
    if (lstatcb)
      fs9.lstat(abs, lstatcb);
    function lstatcb_(er, lstat) {
      if (er && er.code === "ENOENT")
        return cb();
      var isSym = lstat && lstat.isSymbolicLink();
      self2.symlinks[abs] = isSym;
      if (!isSym && lstat && !lstat.isDirectory()) {
        self2.cache[abs] = "FILE";
        cb();
      } else
        self2._readdir(abs, false, cb);
    }
  };
  Glob.prototype._readdir = function(abs, inGlobStar, cb) {
    if (this.aborted)
      return;
    cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
    if (!cb)
      return;
    if (inGlobStar && !ownProp(this.symlinks, abs))
      return this._readdirInGlobStar(abs, cb);
    if (ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (!c || c === "FILE")
        return cb();
      if (Array.isArray(c))
        return cb(null, c);
    }
    var self2 = this;
    fs9.readdir(abs, readdirCb(this, abs, cb));
  };
  function readdirCb(self2, abs, cb) {
    return function(er, entries) {
      if (er)
        self2._readdirError(abs, er, cb);
      else
        self2._readdirEntries(abs, entries, cb);
    };
  }
  Glob.prototype._readdirEntries = function(abs, entries, cb) {
    if (this.aborted)
      return;
    if (!this.mark && !this.stat) {
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (abs === "/")
          e = abs + e;
        else
          e = abs + "/" + e;
        this.cache[e] = true;
      }
    }
    this.cache[abs] = entries;
    return cb(null, entries);
  };
  Glob.prototype._readdirError = function(f, er, cb) {
    if (this.aborted)
      return;
    switch (er.code) {
      case "ENOTSUP":
      case "ENOTDIR":
        var abs = this._makeAbs(f);
        this.cache[abs] = "FILE";
        if (abs === this.cwdAbs) {
          var error = new Error(er.code + " invalid cwd " + this.cwd);
          error.path = this.cwd;
          error.code = er.code;
          this.emit("error", error);
          this.abort();
        }
        break;
      case "ENOENT":
      case "ELOOP":
      case "ENAMETOOLONG":
      case "UNKNOWN":
        this.cache[this._makeAbs(f)] = false;
        break;
      default:
        this.cache[this._makeAbs(f)] = false;
        if (this.strict) {
          this.emit("error", er);
          this.abort();
        }
        if (!this.silent)
          console.error("glob error", er);
        break;
    }
    return cb();
  };
  Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
    var self2 = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
      self2._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
    });
  };
  Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix ? [prefix] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar);
    this._process(noGlobStar, index, false, cb);
    var isSym = this.symlinks[abs];
    var len = entries.length;
    if (isSym && inGlobStar)
      return cb();
    for (var i = 0; i < len; i++) {
      var e = entries[i];
      if (e.charAt(0) === "." && !this.dot)
        continue;
      var instead = gspref.concat(entries[i], remainWithoutGlobStar);
      this._process(instead, index, true, cb);
      var below = gspref.concat(entries[i], remain);
      this._process(below, index, true, cb);
    }
    cb();
  };
  Glob.prototype._processSimple = function(prefix, index, cb) {
    var self2 = this;
    this._stat(prefix, function(er, exists2) {
      self2._processSimple2(prefix, index, er, exists2, cb);
    });
  };
  Glob.prototype._processSimple2 = function(prefix, index, er, exists2, cb) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null);
    if (!exists2)
      return cb();
    if (prefix && isAbsolute(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix);
      if (prefix.charAt(0) === "/") {
        prefix = path10.join(this.root, prefix);
      } else {
        prefix = path10.resolve(this.root, prefix);
        if (trail)
          prefix += "/";
      }
    }
    if (process.platform === "win32")
      prefix = prefix.replace(/\\/g, "/");
    this._emitMatch(index, prefix);
    cb();
  };
  Glob.prototype._stat = function(f, cb) {
    var abs = this._makeAbs(f);
    var needDir = f.slice(-1) === "/";
    if (f.length > this.maxLength)
      return cb();
    if (!this.stat && ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (Array.isArray(c))
        c = "DIR";
      if (!needDir || c === "DIR")
        return cb(null, c);
      if (needDir && c === "FILE")
        return cb();
    }
    var exists2;
    var stat = this.statCache[abs];
    if (stat !== void 0) {
      if (stat === false)
        return cb(null, stat);
      else {
        var type = stat.isDirectory() ? "DIR" : "FILE";
        if (needDir && type === "FILE")
          return cb();
        else
          return cb(null, type, stat);
      }
    }
    var self2 = this;
    var statcb = inflight("stat\0" + abs, lstatcb_);
    if (statcb)
      fs9.lstat(abs, statcb);
    function lstatcb_(er, lstat) {
      if (lstat && lstat.isSymbolicLink()) {
        return fs9.stat(abs, function(er2, stat2) {
          if (er2)
            self2._stat2(f, abs, null, lstat, cb);
          else
            self2._stat2(f, abs, er2, stat2, cb);
        });
      } else {
        self2._stat2(f, abs, er, lstat, cb);
      }
    }
  };
  Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
    if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
      this.statCache[abs] = false;
      return cb();
    }
    var needDir = f.slice(-1) === "/";
    this.statCache[abs] = stat;
    if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
      return cb(null, false, stat);
    var c = true;
    if (stat)
      c = stat.isDirectory() ? "DIR" : "FILE";
    this.cache[abs] = this.cache[abs] || c;
    if (needDir && c === "FILE")
      return cb();
    return cb(null, c, stat);
  };
});

// ../../node_modules/.pnpm/rimraf@3.0.2/node_modules/rimraf/rimraf.js
var require_rimraf = __commonJS((exports2, module2) => {
  var assert = require("assert");
  var path10 = require("path");
  var fs9 = require("fs");
  var glob = void 0;
  try {
    glob = require_glob();
  } catch (_err) {
  }
  var defaultGlobOpts = {
    nosort: true,
    silent: true
  };
  var timeout = 0;
  var isWindows = process.platform === "win32";
  var defaults = (options) => {
    const methods = [
      "unlink",
      "chmod",
      "stat",
      "lstat",
      "rmdir",
      "readdir"
    ];
    methods.forEach((m2) => {
      options[m2] = options[m2] || fs9[m2];
      m2 = m2 + "Sync";
      options[m2] = options[m2] || fs9[m2];
    });
    options.maxBusyTries = options.maxBusyTries || 3;
    options.emfileWait = options.emfileWait || 1e3;
    if (options.glob === false) {
      options.disableGlob = true;
    }
    if (options.disableGlob !== true && glob === void 0) {
      throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");
    }
    options.disableGlob = options.disableGlob || false;
    options.glob = options.glob || defaultGlobOpts;
  };
  var rimraf = (p, options, cb) => {
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    assert(p, "rimraf: missing path");
    assert.equal(typeof p, "string", "rimraf: path should be a string");
    assert.equal(typeof cb, "function", "rimraf: callback function required");
    assert(options, "rimraf: invalid options argument provided");
    assert.equal(typeof options, "object", "rimraf: options should be object");
    defaults(options);
    let busyTries = 0;
    let errState = null;
    let n = 0;
    const next = (er) => {
      errState = errState || er;
      if (--n === 0)
        cb(errState);
    };
    const afterGlob = (er, results) => {
      if (er)
        return cb(er);
      n = results.length;
      if (n === 0)
        return cb();
      results.forEach((p2) => {
        const CB = (er2) => {
          if (er2) {
            if ((er2.code === "EBUSY" || er2.code === "ENOTEMPTY" || er2.code === "EPERM") && busyTries < options.maxBusyTries) {
              busyTries++;
              return setTimeout(() => rimraf_(p2, options, CB), busyTries * 100);
            }
            if (er2.code === "EMFILE" && timeout < options.emfileWait) {
              return setTimeout(() => rimraf_(p2, options, CB), timeout++);
            }
            if (er2.code === "ENOENT")
              er2 = null;
          }
          timeout = 0;
          next(er2);
        };
        rimraf_(p2, options, CB);
      });
    };
    if (options.disableGlob || !glob.hasMagic(p))
      return afterGlob(null, [p]);
    options.lstat(p, (er, stat) => {
      if (!er)
        return afterGlob(null, [p]);
      glob(p, options.glob, afterGlob);
    });
  };
  var rimraf_ = (p, options, cb) => {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.lstat(p, (er, st) => {
      if (er && er.code === "ENOENT")
        return cb(null);
      if (er && er.code === "EPERM" && isWindows)
        fixWinEPERM(p, options, er, cb);
      if (st && st.isDirectory())
        return rmdir(p, options, er, cb);
      options.unlink(p, (er2) => {
        if (er2) {
          if (er2.code === "ENOENT")
            return cb(null);
          if (er2.code === "EPERM")
            return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
          if (er2.code === "EISDIR")
            return rmdir(p, options, er2, cb);
        }
        return cb(er2);
      });
    });
  };
  var fixWinEPERM = (p, options, er, cb) => {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.chmod(p, 438, (er2) => {
      if (er2)
        cb(er2.code === "ENOENT" ? null : er);
      else
        options.stat(p, (er3, stats) => {
          if (er3)
            cb(er3.code === "ENOENT" ? null : er);
          else if (stats.isDirectory())
            rmdir(p, options, er, cb);
          else
            options.unlink(p, cb);
        });
    });
  };
  var fixWinEPERMSync = (p, options, er) => {
    assert(p);
    assert(options);
    try {
      options.chmodSync(p, 438);
    } catch (er2) {
      if (er2.code === "ENOENT")
        return;
      else
        throw er;
    }
    let stats;
    try {
      stats = options.statSync(p);
    } catch (er3) {
      if (er3.code === "ENOENT")
        return;
      else
        throw er;
    }
    if (stats.isDirectory())
      rmdirSync(p, options, er);
    else
      options.unlinkSync(p);
  };
  var rmdir = (p, options, originalEr, cb) => {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.rmdir(p, (er) => {
      if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
        rmkids(p, options, cb);
      else if (er && er.code === "ENOTDIR")
        cb(originalEr);
      else
        cb(er);
    });
  };
  var rmkids = (p, options, cb) => {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.readdir(p, (er, files) => {
      if (er)
        return cb(er);
      let n = files.length;
      if (n === 0)
        return options.rmdir(p, cb);
      let errState;
      files.forEach((f) => {
        rimraf(path10.join(p, f), options, (er2) => {
          if (errState)
            return;
          if (er2)
            return cb(errState = er2);
          if (--n === 0)
            options.rmdir(p, cb);
        });
      });
    });
  };
  var rimrafSync = (p, options) => {
    options = options || {};
    defaults(options);
    assert(p, "rimraf: missing path");
    assert.equal(typeof p, "string", "rimraf: path should be a string");
    assert(options, "rimraf: missing options");
    assert.equal(typeof options, "object", "rimraf: options should be object");
    let results;
    if (options.disableGlob || !glob.hasMagic(p)) {
      results = [p];
    } else {
      try {
        options.lstatSync(p);
        results = [p];
      } catch (er) {
        results = glob.sync(p, options.glob);
      }
    }
    if (!results.length)
      return;
    for (let i = 0; i < results.length; i++) {
      const p2 = results[i];
      let st;
      try {
        st = options.lstatSync(p2);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "EPERM" && isWindows)
          fixWinEPERMSync(p2, options, er);
      }
      try {
        if (st && st.isDirectory())
          rmdirSync(p2, options, null);
        else
          options.unlinkSync(p2);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "EPERM")
          return isWindows ? fixWinEPERMSync(p2, options, er) : rmdirSync(p2, options, er);
        if (er.code !== "EISDIR")
          throw er;
        rmdirSync(p2, options, er);
      }
    }
  };
  var rmdirSync = (p, options, originalEr) => {
    assert(p);
    assert(options);
    try {
      options.rmdirSync(p);
    } catch (er) {
      if (er.code === "ENOENT")
        return;
      if (er.code === "ENOTDIR")
        throw originalEr;
      if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
        rmkidsSync(p, options);
    }
  };
  var rmkidsSync = (p, options) => {
    assert(p);
    assert(options);
    options.readdirSync(p).forEach((f) => rimrafSync(path10.join(p, f), options));
    const retries = isWindows ? 100 : 1;
    let i = 0;
    do {
      let threw = true;
      try {
        const ret = options.rmdirSync(p, options);
        threw = false;
        return ret;
      } finally {
        if (++i < retries && threw)
          continue;
      }
    } while (true);
  };
  module2.exports = rimraf;
  rimraf.sync = rimrafSync;
});

// ../../node_modules/.pnpm/indent-string@4.0.0/node_modules/indent-string/index.js
var require_indent_string = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (string, count = 1, options) => {
    options = {
      indent: " ",
      includeEmptyLines: false,
      ...options
    };
    if (typeof string !== "string") {
      throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof string}\``);
    }
    if (typeof count !== "number") {
      throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof count}\``);
    }
    if (typeof options.indent !== "string") {
      throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof options.indent}\``);
    }
    if (count === 0) {
      return string;
    }
    const regex = options.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
    return string.replace(regex, options.indent.repeat(count));
  };
});

// ../../node_modules/.pnpm/clean-stack@2.2.0/node_modules/clean-stack/index.js
var require_clean_stack = __commonJS((exports2, module2) => {
  "use strict";
  var os3 = require("os");
  var extractPathRegex = /\s+at.*(?:\(|\s)(.*)\)?/;
  var pathRegex = /^(?:(?:(?:node|(?:internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)\.js:\d+:\d+)|native)/;
  var homeDir = typeof os3.homedir === "undefined" ? "" : os3.homedir();
  module2.exports = (stack, options) => {
    options = Object.assign({pretty: false}, options);
    return stack.replace(/\\/g, "/").split("\n").filter((line) => {
      const pathMatches = line.match(extractPathRegex);
      if (pathMatches === null || !pathMatches[1]) {
        return true;
      }
      const match = pathMatches[1];
      if (match.includes(".app/Contents/Resources/electron.asar") || match.includes(".app/Contents/Resources/default_app.asar")) {
        return false;
      }
      return !pathRegex.test(match);
    }).filter((line) => line.trim() !== "").map((line) => {
      if (options.pretty) {
        return line.replace(extractPathRegex, (m2, p1) => m2.replace(p1, p1.replace(homeDir, "~")));
      }
      return line;
    }).join("\n");
  };
});

// ../../node_modules/.pnpm/aggregate-error@3.1.0/node_modules/aggregate-error/index.js
var require_aggregate_error = __commonJS((exports2, module2) => {
  "use strict";
  var indentString = require_indent_string();
  var cleanStack = require_clean_stack();
  var cleanInternalStack = (stack) => stack.replace(/\s+at .*aggregate-error\/index.js:\d+:\d+\)?/g, "");
  var AggregateError = class extends Error {
    constructor(errors) {
      if (!Array.isArray(errors)) {
        throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
      }
      errors = [...errors].map((error) => {
        if (error instanceof Error) {
          return error;
        }
        if (error !== null && typeof error === "object") {
          return Object.assign(new Error(error.message), error);
        }
        return new Error(error);
      });
      let message = errors.map((error) => {
        return typeof error.stack === "string" ? cleanInternalStack(cleanStack(error.stack)) : String(error);
      }).join("\n");
      message = "\n" + indentString(message, 4);
      super(message);
      this.name = "AggregateError";
      Object.defineProperty(this, "_errors", {value: errors});
    }
    *[Symbol.iterator]() {
      for (const error of this._errors) {
        yield error;
      }
    }
  };
  module2.exports = AggregateError;
});

// ../../node_modules/.pnpm/p-map@4.0.0/node_modules/p-map/index.js
var require_p_map2 = __commonJS((exports2, module2) => {
  "use strict";
  var AggregateError = require_aggregate_error();
  module2.exports = async (iterable, mapper, {
    concurrency = Infinity,
    stopOnError = true
  } = {}) => {
    return new Promise((resolve, reject) => {
      if (typeof mapper !== "function") {
        throw new TypeError("Mapper function is required");
      }
      if (!((Number.isSafeInteger(concurrency) || concurrency === Infinity) && concurrency >= 1)) {
        throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${concurrency}\` (${typeof concurrency})`);
      }
      const result = [];
      const errors = [];
      const iterator = iterable[Symbol.iterator]();
      let isRejected = false;
      let isIterableDone = false;
      let resolvingCount = 0;
      let currentIndex = 0;
      const next = () => {
        if (isRejected) {
          return;
        }
        const nextItem = iterator.next();
        const index = currentIndex;
        currentIndex++;
        if (nextItem.done) {
          isIterableDone = true;
          if (resolvingCount === 0) {
            if (!stopOnError && errors.length !== 0) {
              reject(new AggregateError(errors));
            } else {
              resolve(result);
            }
          }
          return;
        }
        resolvingCount++;
        (async () => {
          try {
            const element = await nextItem.value;
            result[index] = await mapper(element, index);
            resolvingCount--;
            next();
          } catch (error) {
            if (stopOnError) {
              isRejected = true;
              reject(error);
            } else {
              errors.push(error);
              resolvingCount--;
              next();
            }
          }
        })();
      };
      for (let i = 0; i < concurrency; i++) {
        next();
        if (isIterableDone) {
          break;
        }
      }
    });
  };
});

// ../../node_modules/.pnpm/@prisma+fetch-engine@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/fetch-engine/dist/cleanupCache.js
var require_cleanupCache = __commonJS((exports2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.cleanupCache = void 0;
  var fs_12 = __importDefault2(require("fs"));
  var path_12 = __importDefault2(require("path"));
  var util_12 = require_util2();
  var rimraf_1 = __importDefault2(require_rimraf());
  var util_22 = require("util");
  var p_map_1 = __importDefault2(require_p_map2());
  var debug_12 = __importDefault2(require_dist3());
  var debug3 = debug_12.default("cleanupCache");
  var del = util_22.promisify(rimraf_1.default);
  var readdir2 = util_22.promisify(fs_12.default.readdir);
  var stat = util_22.promisify(fs_12.default.stat);
  async function cleanupCache(n = 5) {
    try {
      const rootCacheDir = await util_12.getRootCacheDir();
      if (!rootCacheDir) {
        debug3("no rootCacheDir found");
        return;
      }
      const channel2 = "master";
      const cacheDir = path_12.default.join(rootCacheDir, channel2);
      const dirs = await readdir2(cacheDir);
      const dirsWithMeta = await Promise.all(dirs.map(async (dirName) => {
        const dir = path_12.default.join(cacheDir, dirName);
        const statResult = await stat(dir);
        return {
          dir,
          created: statResult.birthtime
        };
      }));
      dirsWithMeta.sort((a, b) => a.created < b.created ? 1 : -1);
      const dirsToRemove = dirsWithMeta.slice(n);
      await p_map_1.default(dirsToRemove, (dir) => del(dir.dir), {concurrency: 20});
    } catch (e) {
    }
  }
  exports2.cleanupCache = cleanupCache;
});

// ../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS((exports2, module2) => {
  function RetryOperation(timeouts, options) {
    if (typeof options === "boolean") {
      options = {forever: options};
    }
    this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
    this._timeouts = timeouts;
    this._options = options || {};
    this._maxRetryTime = options && options.maxRetryTime || Infinity;
    this._fn = null;
    this._errors = [];
    this._attempts = 1;
    this._operationTimeout = null;
    this._operationTimeoutCb = null;
    this._timeout = null;
    this._operationStart = null;
    this._timer = null;
    if (this._options.forever) {
      this._cachedTimeouts = this._timeouts.slice(0);
    }
  }
  module2.exports = RetryOperation;
  RetryOperation.prototype.reset = function() {
    this._attempts = 1;
    this._timeouts = this._originalTimeouts.slice(0);
  };
  RetryOperation.prototype.stop = function() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
    if (this._timer) {
      clearTimeout(this._timer);
    }
    this._timeouts = [];
    this._cachedTimeouts = null;
  };
  RetryOperation.prototype.retry = function(err) {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
    if (!err) {
      return false;
    }
    var currentTime = new Date().getTime();
    if (err && currentTime - this._operationStart >= this._maxRetryTime) {
      this._errors.push(err);
      this._errors.unshift(new Error("RetryOperation timeout occurred"));
      return false;
    }
    this._errors.push(err);
    var timeout = this._timeouts.shift();
    if (timeout === void 0) {
      if (this._cachedTimeouts) {
        this._errors.splice(0, this._errors.length - 1);
        timeout = this._cachedTimeouts.slice(-1);
      } else {
        return false;
      }
    }
    var self2 = this;
    this._timer = setTimeout(function() {
      self2._attempts++;
      if (self2._operationTimeoutCb) {
        self2._timeout = setTimeout(function() {
          self2._operationTimeoutCb(self2._attempts);
        }, self2._operationTimeout);
        if (self2._options.unref) {
          self2._timeout.unref();
        }
      }
      self2._fn(self2._attempts);
    }, timeout);
    if (this._options.unref) {
      this._timer.unref();
    }
    return true;
  };
  RetryOperation.prototype.attempt = function(fn, timeoutOps) {
    this._fn = fn;
    if (timeoutOps) {
      if (timeoutOps.timeout) {
        this._operationTimeout = timeoutOps.timeout;
      }
      if (timeoutOps.cb) {
        this._operationTimeoutCb = timeoutOps.cb;
      }
    }
    var self2 = this;
    if (this._operationTimeoutCb) {
      this._timeout = setTimeout(function() {
        self2._operationTimeoutCb();
      }, self2._operationTimeout);
    }
    this._operationStart = new Date().getTime();
    this._fn(this._attempts);
  };
  RetryOperation.prototype.try = function(fn) {
    console.log("Using RetryOperation.try() is deprecated");
    this.attempt(fn);
  };
  RetryOperation.prototype.start = function(fn) {
    console.log("Using RetryOperation.start() is deprecated");
    this.attempt(fn);
  };
  RetryOperation.prototype.start = RetryOperation.prototype.try;
  RetryOperation.prototype.errors = function() {
    return this._errors;
  };
  RetryOperation.prototype.attempts = function() {
    return this._attempts;
  };
  RetryOperation.prototype.mainError = function() {
    if (this._errors.length === 0) {
      return null;
    }
    var counts = {};
    var mainError = null;
    var mainErrorCount = 0;
    for (var i = 0; i < this._errors.length; i++) {
      var error = this._errors[i];
      var message = error.message;
      var count = (counts[message] || 0) + 1;
      counts[message] = count;
      if (count >= mainErrorCount) {
        mainError = error;
        mainErrorCount = count;
      }
    }
    return mainError;
  };
});

// ../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry.js
var require_retry = __commonJS((exports2) => {
  var RetryOperation = require_retry_operation();
  exports2.operation = function(options) {
    var timeouts = exports2.timeouts(options);
    return new RetryOperation(timeouts, {
      forever: options && (options.forever || options.retries === Infinity),
      unref: options && options.unref,
      maxRetryTime: options && options.maxRetryTime
    });
  };
  exports2.timeouts = function(options) {
    if (options instanceof Array) {
      return [].concat(options);
    }
    var opts = {
      retries: 10,
      factor: 2,
      minTimeout: 1 * 1e3,
      maxTimeout: Infinity,
      randomize: false
    };
    for (var key in options) {
      opts[key] = options[key];
    }
    if (opts.minTimeout > opts.maxTimeout) {
      throw new Error("minTimeout is greater than maxTimeout");
    }
    var timeouts = [];
    for (var i = 0; i < opts.retries; i++) {
      timeouts.push(this.createTimeout(i, opts));
    }
    if (options && options.forever && !timeouts.length) {
      timeouts.push(this.createTimeout(i, opts));
    }
    timeouts.sort(function(a, b) {
      return a - b;
    });
    return timeouts;
  };
  exports2.createTimeout = function(attempt, opts) {
    var random = opts.randomize ? Math.random() + 1 : 1;
    var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
    timeout = Math.min(timeout, opts.maxTimeout);
    return timeout;
  };
  exports2.wrap = function(obj, options, methods) {
    if (options instanceof Array) {
      methods = options;
      options = null;
    }
    if (!methods) {
      methods = [];
      for (var key in obj) {
        if (typeof obj[key] === "function") {
          methods.push(key);
        }
      }
    }
    for (var i = 0; i < methods.length; i++) {
      var method = methods[i];
      var original = obj[method];
      obj[method] = function retryWrapper(original2) {
        var op = exports2.operation(options);
        var args2 = Array.prototype.slice.call(arguments, 1);
        var callback = args2.pop();
        args2.push(function(err) {
          if (op.retry(err)) {
            return;
          }
          if (err) {
            arguments[0] = op.mainError();
          }
          callback.apply(this, arguments);
        });
        op.attempt(function() {
          original2.apply(obj, args2);
        });
      }.bind(obj, original);
      obj[method].options = options;
    }
  };
});

// ../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/index.js
var require_retry2 = __commonJS((exports2, module2) => {
  module2.exports = require_retry();
});

// ../../node_modules/.pnpm/p-retry@4.6.1/node_modules/p-retry/index.js
var require_p_retry = __commonJS((exports2, module2) => {
  "use strict";
  var retry = require_retry2();
  var networkErrorMsgs = [
    "Failed to fetch",
    "NetworkError when attempting to fetch resource.",
    "The Internet connection appears to be offline.",
    "Network request failed"
  ];
  var AbortError = class extends Error {
    constructor(message) {
      super();
      if (message instanceof Error) {
        this.originalError = message;
        ({message} = message);
      } else {
        this.originalError = new Error(message);
        this.originalError.stack = this.stack;
      }
      this.name = "AbortError";
      this.message = message;
    }
  };
  var decorateErrorWithCounts = (error, attemptNumber, options) => {
    const retriesLeft = options.retries - (attemptNumber - 1);
    error.attemptNumber = attemptNumber;
    error.retriesLeft = retriesLeft;
    return error;
  };
  var isNetworkError = (errorMessage) => networkErrorMsgs.includes(errorMessage);
  var pRetry = (input, options) => new Promise((resolve, reject) => {
    options = {
      onFailedAttempt: () => {
      },
      retries: 10,
      ...options
    };
    const operation = retry.operation(options);
    operation.attempt(async (attemptNumber) => {
      try {
        resolve(await input(attemptNumber));
      } catch (error) {
        if (!(error instanceof Error)) {
          reject(new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`));
          return;
        }
        if (error instanceof AbortError) {
          operation.stop();
          reject(error.originalError);
        } else if (error instanceof TypeError && !isNetworkError(error.message)) {
          operation.stop();
          reject(error);
        } else {
          decorateErrorWithCounts(error, attemptNumber, options);
          try {
            await options.onFailedAttempt(error);
          } catch (error2) {
            reject(error2);
            return;
          }
          if (!operation.retry(error)) {
            reject(operation.mainError());
          }
        }
      }
    });
  });
  module2.exports = pRetry;
  module2.exports.default = pRetry;
  module2.exports.AbortError = AbortError;
});

// ../../node_modules/.pnpm/node-fetch@2.6.1/node_modules/node-fetch/lib/index.mjs
var require_lib4 = __commonJS((exports2) => {
  __markAsModule2(exports2);
  __export2(exports2, {
    FetchError: () => FetchError,
    Headers: () => Headers2,
    Request: () => Request2,
    Response: () => Response2,
    default: () => lib_default
  });
  var import_stream = __toModule2(require("stream"));
  var import_http = __toModule2(require("http"));
  var import_url2 = __toModule2(require("url"));
  var import_https = __toModule2(require("https"));
  var import_zlib = __toModule2(require("zlib"));
  var Readable = import_stream.default.Readable;
  var BUFFER = Symbol("buffer");
  var TYPE = Symbol("type");
  var Blob = class {
    constructor() {
      this[TYPE] = "";
      const blobParts = arguments[0];
      const options = arguments[1];
      const buffers = [];
      let size = 0;
      if (blobParts) {
        const a = blobParts;
        const length = Number(a.length);
        for (let i = 0; i < length; i++) {
          const element = a[i];
          let buffer;
          if (element instanceof Buffer) {
            buffer = element;
          } else if (ArrayBuffer.isView(element)) {
            buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
          } else if (element instanceof ArrayBuffer) {
            buffer = Buffer.from(element);
          } else if (element instanceof Blob) {
            buffer = element[BUFFER];
          } else {
            buffer = Buffer.from(typeof element === "string" ? element : String(element));
          }
          size += buffer.length;
          buffers.push(buffer);
        }
      }
      this[BUFFER] = Buffer.concat(buffers);
      let type = options && options.type !== void 0 && String(options.type).toLowerCase();
      if (type && !/[^\u0020-\u007E]/.test(type)) {
        this[TYPE] = type;
      }
    }
    get size() {
      return this[BUFFER].length;
    }
    get type() {
      return this[TYPE];
    }
    text() {
      return Promise.resolve(this[BUFFER].toString());
    }
    arrayBuffer() {
      const buf = this[BUFFER];
      const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
      return Promise.resolve(ab);
    }
    stream() {
      const readable = new Readable();
      readable._read = function() {
      };
      readable.push(this[BUFFER]);
      readable.push(null);
      return readable;
    }
    toString() {
      return "[object Blob]";
    }
    slice() {
      const size = this.size;
      const start = arguments[0];
      const end = arguments[1];
      let relativeStart, relativeEnd;
      if (start === void 0) {
        relativeStart = 0;
      } else if (start < 0) {
        relativeStart = Math.max(size + start, 0);
      } else {
        relativeStart = Math.min(start, size);
      }
      if (end === void 0) {
        relativeEnd = size;
      } else if (end < 0) {
        relativeEnd = Math.max(size + end, 0);
      } else {
        relativeEnd = Math.min(end, size);
      }
      const span = Math.max(relativeEnd - relativeStart, 0);
      const buffer = this[BUFFER];
      const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
      const blob = new Blob([], {type: arguments[2]});
      blob[BUFFER] = slicedBuffer;
      return blob;
    }
  };
  Object.defineProperties(Blob.prototype, {
    size: {enumerable: true},
    type: {enumerable: true},
    slice: {enumerable: true}
  });
  Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
    value: "Blob",
    writable: false,
    enumerable: false,
    configurable: true
  });
  function FetchError(message, type, systemError) {
    Error.call(this, message);
    this.message = message;
    this.type = type;
    if (systemError) {
      this.code = this.errno = systemError.code;
    }
    Error.captureStackTrace(this, this.constructor);
  }
  FetchError.prototype = Object.create(Error.prototype);
  FetchError.prototype.constructor = FetchError;
  FetchError.prototype.name = "FetchError";
  var convert;
  try {
    convert = require("encoding").convert;
  } catch (e) {
  }
  var INTERNALS = Symbol("Body internals");
  var PassThrough = import_stream.default.PassThrough;
  function Body(body) {
    var _this = this;
    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
    let size = _ref$size === void 0 ? 0 : _ref$size;
    var _ref$timeout = _ref.timeout;
    let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
    if (body == null) {
      body = null;
    } else if (isURLSearchParams(body)) {
      body = Buffer.from(body.toString());
    } else if (isBlob(body))
      ;
    else if (Buffer.isBuffer(body))
      ;
    else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      body = Buffer.from(body);
    } else if (ArrayBuffer.isView(body)) {
      body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
    } else if (body instanceof import_stream.default)
      ;
    else {
      body = Buffer.from(String(body));
    }
    this[INTERNALS] = {
      body,
      disturbed: false,
      error: null
    };
    this.size = size;
    this.timeout = timeout;
    if (body instanceof import_stream.default) {
      body.on("error", function(err) {
        const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
        _this[INTERNALS].error = error;
      });
    }
  }
  Body.prototype = {
    get body() {
      return this[INTERNALS].body;
    },
    get bodyUsed() {
      return this[INTERNALS].disturbed;
    },
    arrayBuffer() {
      return consumeBody.call(this).then(function(buf) {
        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
      });
    },
    blob() {
      let ct = this.headers && this.headers.get("content-type") || "";
      return consumeBody.call(this).then(function(buf) {
        return Object.assign(new Blob([], {
          type: ct.toLowerCase()
        }), {
          [BUFFER]: buf
        });
      });
    },
    json() {
      var _this2 = this;
      return consumeBody.call(this).then(function(buffer) {
        try {
          return JSON.parse(buffer.toString());
        } catch (err) {
          return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
        }
      });
    },
    text() {
      return consumeBody.call(this).then(function(buffer) {
        return buffer.toString();
      });
    },
    buffer() {
      return consumeBody.call(this);
    },
    textConverted() {
      var _this3 = this;
      return consumeBody.call(this).then(function(buffer) {
        return convertBody(buffer, _this3.headers);
      });
    }
  };
  Object.defineProperties(Body.prototype, {
    body: {enumerable: true},
    bodyUsed: {enumerable: true},
    arrayBuffer: {enumerable: true},
    blob: {enumerable: true},
    json: {enumerable: true},
    text: {enumerable: true}
  });
  Body.mixIn = function(proto) {
    for (const name of Object.getOwnPropertyNames(Body.prototype)) {
      if (!(name in proto)) {
        const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
        Object.defineProperty(proto, name, desc);
      }
    }
  };
  function consumeBody() {
    var _this4 = this;
    if (this[INTERNALS].disturbed) {
      return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
    }
    this[INTERNALS].disturbed = true;
    if (this[INTERNALS].error) {
      return Body.Promise.reject(this[INTERNALS].error);
    }
    let body = this.body;
    if (body === null) {
      return Body.Promise.resolve(Buffer.alloc(0));
    }
    if (isBlob(body)) {
      body = body.stream();
    }
    if (Buffer.isBuffer(body)) {
      return Body.Promise.resolve(body);
    }
    if (!(body instanceof import_stream.default)) {
      return Body.Promise.resolve(Buffer.alloc(0));
    }
    let accum = [];
    let accumBytes = 0;
    let abort = false;
    return new Body.Promise(function(resolve, reject) {
      let resTimeout;
      if (_this4.timeout) {
        resTimeout = setTimeout(function() {
          abort = true;
          reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
        }, _this4.timeout);
      }
      body.on("error", function(err) {
        if (err.name === "AbortError") {
          abort = true;
          reject(err);
        } else {
          reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
        }
      });
      body.on("data", function(chunk) {
        if (abort || chunk === null) {
          return;
        }
        if (_this4.size && accumBytes + chunk.length > _this4.size) {
          abort = true;
          reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
          return;
        }
        accumBytes += chunk.length;
        accum.push(chunk);
      });
      body.on("end", function() {
        if (abort) {
          return;
        }
        clearTimeout(resTimeout);
        try {
          resolve(Buffer.concat(accum, accumBytes));
        } catch (err) {
          reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
        }
      });
    });
  }
  function convertBody(buffer, headers) {
    if (typeof convert !== "function") {
      throw new Error("The package `encoding` must be installed to use the textConverted() function");
    }
    const ct = headers.get("content-type");
    let charset = "utf-8";
    let res, str;
    if (ct) {
      res = /charset=([^;]*)/i.exec(ct);
    }
    str = buffer.slice(0, 1024).toString();
    if (!res && str) {
      res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
    }
    if (!res && str) {
      res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
      if (!res) {
        res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
        if (res) {
          res.pop();
        }
      }
      if (res) {
        res = /charset=(.*)/i.exec(res.pop());
      }
    }
    if (!res && str) {
      res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
    }
    if (res) {
      charset = res.pop();
      if (charset === "gb2312" || charset === "gbk") {
        charset = "gb18030";
      }
    }
    return convert(buffer, "UTF-8", charset).toString();
  }
  function isURLSearchParams(obj) {
    if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
      return false;
    }
    return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
  }
  function isBlob(obj) {
    return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
  }
  function clone(instance) {
    let p1, p2;
    let body = instance.body;
    if (instance.bodyUsed) {
      throw new Error("cannot clone body after it is used");
    }
    if (body instanceof import_stream.default && typeof body.getBoundary !== "function") {
      p1 = new PassThrough();
      p2 = new PassThrough();
      body.pipe(p1);
      body.pipe(p2);
      instance[INTERNALS].body = p1;
      body = p2;
    }
    return body;
  }
  function extractContentType(body) {
    if (body === null) {
      return null;
    } else if (typeof body === "string") {
      return "text/plain;charset=UTF-8";
    } else if (isURLSearchParams(body)) {
      return "application/x-www-form-urlencoded;charset=UTF-8";
    } else if (isBlob(body)) {
      return body.type || null;
    } else if (Buffer.isBuffer(body)) {
      return null;
    } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      return null;
    } else if (ArrayBuffer.isView(body)) {
      return null;
    } else if (typeof body.getBoundary === "function") {
      return `multipart/form-data;boundary=${body.getBoundary()}`;
    } else if (body instanceof import_stream.default) {
      return null;
    } else {
      return "text/plain;charset=UTF-8";
    }
  }
  function getTotalBytes(instance) {
    const body = instance.body;
    if (body === null) {
      return 0;
    } else if (isBlob(body)) {
      return body.size;
    } else if (Buffer.isBuffer(body)) {
      return body.length;
    } else if (body && typeof body.getLengthSync === "function") {
      if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || body.hasKnownLength && body.hasKnownLength()) {
        return body.getLengthSync();
      }
      return null;
    } else {
      return null;
    }
  }
  function writeToStream(dest, instance) {
    const body = instance.body;
    if (body === null) {
      dest.end();
    } else if (isBlob(body)) {
      body.stream().pipe(dest);
    } else if (Buffer.isBuffer(body)) {
      dest.write(body);
      dest.end();
    } else {
      body.pipe(dest);
    }
  }
  Body.Promise = global.Promise;
  var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
  var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
  function validateName(name) {
    name = `${name}`;
    if (invalidTokenRegex.test(name) || name === "") {
      throw new TypeError(`${name} is not a legal HTTP header name`);
    }
  }
  function validateValue(value) {
    value = `${value}`;
    if (invalidHeaderCharRegex.test(value)) {
      throw new TypeError(`${value} is not a legal HTTP header value`);
    }
  }
  function find(map, name) {
    name = name.toLowerCase();
    for (const key in map) {
      if (key.toLowerCase() === name) {
        return key;
      }
    }
    return void 0;
  }
  var MAP = Symbol("map");
  var Headers2 = class {
    constructor() {
      let init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
      this[MAP] = Object.create(null);
      if (init instanceof Headers2) {
        const rawHeaders = init.raw();
        const headerNames = Object.keys(rawHeaders);
        for (const headerName of headerNames) {
          for (const value of rawHeaders[headerName]) {
            this.append(headerName, value);
          }
        }
        return;
      }
      if (init == null)
        ;
      else if (typeof init === "object") {
        const method = init[Symbol.iterator];
        if (method != null) {
          if (typeof method !== "function") {
            throw new TypeError("Header pairs must be iterable");
          }
          const pairs = [];
          for (const pair of init) {
            if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
              throw new TypeError("Each header pair must be iterable");
            }
            pairs.push(Array.from(pair));
          }
          for (const pair of pairs) {
            if (pair.length !== 2) {
              throw new TypeError("Each header pair must be a name/value tuple");
            }
            this.append(pair[0], pair[1]);
          }
        } else {
          for (const key of Object.keys(init)) {
            const value = init[key];
            this.append(key, value);
          }
        }
      } else {
        throw new TypeError("Provided initializer must be an object");
      }
    }
    get(name) {
      name = `${name}`;
      validateName(name);
      const key = find(this[MAP], name);
      if (key === void 0) {
        return null;
      }
      return this[MAP][key].join(", ");
    }
    forEach(callback) {
      let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
      let pairs = getHeaders(this);
      let i = 0;
      while (i < pairs.length) {
        var _pairs$i = pairs[i];
        const name = _pairs$i[0], value = _pairs$i[1];
        callback.call(thisArg, value, name, this);
        pairs = getHeaders(this);
        i++;
      }
    }
    set(name, value) {
      name = `${name}`;
      value = `${value}`;
      validateName(name);
      validateValue(value);
      const key = find(this[MAP], name);
      this[MAP][key !== void 0 ? key : name] = [value];
    }
    append(name, value) {
      name = `${name}`;
      value = `${value}`;
      validateName(name);
      validateValue(value);
      const key = find(this[MAP], name);
      if (key !== void 0) {
        this[MAP][key].push(value);
      } else {
        this[MAP][name] = [value];
      }
    }
    has(name) {
      name = `${name}`;
      validateName(name);
      return find(this[MAP], name) !== void 0;
    }
    delete(name) {
      name = `${name}`;
      validateName(name);
      const key = find(this[MAP], name);
      if (key !== void 0) {
        delete this[MAP][key];
      }
    }
    raw() {
      return this[MAP];
    }
    keys() {
      return createHeadersIterator(this, "key");
    }
    values() {
      return createHeadersIterator(this, "value");
    }
    [Symbol.iterator]() {
      return createHeadersIterator(this, "key+value");
    }
  };
  Headers2.prototype.entries = Headers2.prototype[Symbol.iterator];
  Object.defineProperty(Headers2.prototype, Symbol.toStringTag, {
    value: "Headers",
    writable: false,
    enumerable: false,
    configurable: true
  });
  Object.defineProperties(Headers2.prototype, {
    get: {enumerable: true},
    forEach: {enumerable: true},
    set: {enumerable: true},
    append: {enumerable: true},
    has: {enumerable: true},
    delete: {enumerable: true},
    keys: {enumerable: true},
    values: {enumerable: true},
    entries: {enumerable: true}
  });
  function getHeaders(headers) {
    let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
    const keys = Object.keys(headers[MAP]).sort();
    return keys.map(kind === "key" ? function(k) {
      return k.toLowerCase();
    } : kind === "value" ? function(k) {
      return headers[MAP][k].join(", ");
    } : function(k) {
      return [k.toLowerCase(), headers[MAP][k].join(", ")];
    });
  }
  var INTERNAL = Symbol("internal");
  function createHeadersIterator(target, kind) {
    const iterator = Object.create(HeadersIteratorPrototype);
    iterator[INTERNAL] = {
      target,
      kind,
      index: 0
    };
    return iterator;
  }
  var HeadersIteratorPrototype = Object.setPrototypeOf({
    next() {
      if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
        throw new TypeError("Value of `this` is not a HeadersIterator");
      }
      var _INTERNAL = this[INTERNAL];
      const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
      const values = getHeaders(target, kind);
      const len = values.length;
      if (index >= len) {
        return {
          value: void 0,
          done: true
        };
      }
      this[INTERNAL].index = index + 1;
      return {
        value: values[index],
        done: false
      };
    }
  }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
  Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
    value: "HeadersIterator",
    writable: false,
    enumerable: false,
    configurable: true
  });
  function exportNodeCompatibleHeaders(headers) {
    const obj = Object.assign({__proto__: null}, headers[MAP]);
    const hostHeaderKey = find(headers[MAP], "Host");
    if (hostHeaderKey !== void 0) {
      obj[hostHeaderKey] = obj[hostHeaderKey][0];
    }
    return obj;
  }
  function createHeadersLenient(obj) {
    const headers = new Headers2();
    for (const name of Object.keys(obj)) {
      if (invalidTokenRegex.test(name)) {
        continue;
      }
      if (Array.isArray(obj[name])) {
        for (const val of obj[name]) {
          if (invalidHeaderCharRegex.test(val)) {
            continue;
          }
          if (headers[MAP][name] === void 0) {
            headers[MAP][name] = [val];
          } else {
            headers[MAP][name].push(val);
          }
        }
      } else if (!invalidHeaderCharRegex.test(obj[name])) {
        headers[MAP][name] = [obj[name]];
      }
    }
    return headers;
  }
  var INTERNALS$1 = Symbol("Response internals");
  var STATUS_CODES = import_http.default.STATUS_CODES;
  var Response2 = class {
    constructor() {
      let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      Body.call(this, body, opts);
      const status = opts.status || 200;
      const headers = new Headers2(opts.headers);
      if (body != null && !headers.has("Content-Type")) {
        const contentType = extractContentType(body);
        if (contentType) {
          headers.append("Content-Type", contentType);
        }
      }
      this[INTERNALS$1] = {
        url: opts.url,
        status,
        statusText: opts.statusText || STATUS_CODES[status],
        headers,
        counter: opts.counter
      };
    }
    get url() {
      return this[INTERNALS$1].url || "";
    }
    get status() {
      return this[INTERNALS$1].status;
    }
    get ok() {
      return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
    }
    get redirected() {
      return this[INTERNALS$1].counter > 0;
    }
    get statusText() {
      return this[INTERNALS$1].statusText;
    }
    get headers() {
      return this[INTERNALS$1].headers;
    }
    clone() {
      return new Response2(clone(this), {
        url: this.url,
        status: this.status,
        statusText: this.statusText,
        headers: this.headers,
        ok: this.ok,
        redirected: this.redirected
      });
    }
  };
  Body.mixIn(Response2.prototype);
  Object.defineProperties(Response2.prototype, {
    url: {enumerable: true},
    status: {enumerable: true},
    ok: {enumerable: true},
    redirected: {enumerable: true},
    statusText: {enumerable: true},
    headers: {enumerable: true},
    clone: {enumerable: true}
  });
  Object.defineProperty(Response2.prototype, Symbol.toStringTag, {
    value: "Response",
    writable: false,
    enumerable: false,
    configurable: true
  });
  var INTERNALS$2 = Symbol("Request internals");
  var parse_url = import_url2.default.parse;
  var format_url = import_url2.default.format;
  var streamDestructionSupported = "destroy" in import_stream.default.Readable.prototype;
  function isRequest(input) {
    return typeof input === "object" && typeof input[INTERNALS$2] === "object";
  }
  function isAbortSignal(signal) {
    const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
    return !!(proto && proto.constructor.name === "AbortSignal");
  }
  var Request2 = class {
    constructor(input) {
      let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      let parsedURL;
      if (!isRequest(input)) {
        if (input && input.href) {
          parsedURL = parse_url(input.href);
        } else {
          parsedURL = parse_url(`${input}`);
        }
        input = {};
      } else {
        parsedURL = parse_url(input.url);
      }
      let method = init.method || input.method || "GET";
      method = method.toUpperCase();
      if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
        throw new TypeError("Request with GET/HEAD method cannot have body");
      }
      let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
      Body.call(this, inputBody, {
        timeout: init.timeout || input.timeout || 0,
        size: init.size || input.size || 0
      });
      const headers = new Headers2(init.headers || input.headers || {});
      if (inputBody != null && !headers.has("Content-Type")) {
        const contentType = extractContentType(inputBody);
        if (contentType) {
          headers.append("Content-Type", contentType);
        }
      }
      let signal = isRequest(input) ? input.signal : null;
      if ("signal" in init)
        signal = init.signal;
      if (signal != null && !isAbortSignal(signal)) {
        throw new TypeError("Expected signal to be an instanceof AbortSignal");
      }
      this[INTERNALS$2] = {
        method,
        redirect: init.redirect || input.redirect || "follow",
        headers,
        parsedURL,
        signal
      };
      this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20;
      this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : true;
      this.counter = init.counter || input.counter || 0;
      this.agent = init.agent || input.agent;
    }
    get method() {
      return this[INTERNALS$2].method;
    }
    get url() {
      return format_url(this[INTERNALS$2].parsedURL);
    }
    get headers() {
      return this[INTERNALS$2].headers;
    }
    get redirect() {
      return this[INTERNALS$2].redirect;
    }
    get signal() {
      return this[INTERNALS$2].signal;
    }
    clone() {
      return new Request2(this);
    }
  };
  Body.mixIn(Request2.prototype);
  Object.defineProperty(Request2.prototype, Symbol.toStringTag, {
    value: "Request",
    writable: false,
    enumerable: false,
    configurable: true
  });
  Object.defineProperties(Request2.prototype, {
    method: {enumerable: true},
    url: {enumerable: true},
    headers: {enumerable: true},
    redirect: {enumerable: true},
    clone: {enumerable: true},
    signal: {enumerable: true}
  });
  function getNodeRequestOptions(request) {
    const parsedURL = request[INTERNALS$2].parsedURL;
    const headers = new Headers2(request[INTERNALS$2].headers);
    if (!headers.has("Accept")) {
      headers.set("Accept", "*/*");
    }
    if (!parsedURL.protocol || !parsedURL.hostname) {
      throw new TypeError("Only absolute URLs are supported");
    }
    if (!/^https?:$/.test(parsedURL.protocol)) {
      throw new TypeError("Only HTTP(S) protocols are supported");
    }
    if (request.signal && request.body instanceof import_stream.default.Readable && !streamDestructionSupported) {
      throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
    }
    let contentLengthValue = null;
    if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
      contentLengthValue = "0";
    }
    if (request.body != null) {
      const totalBytes = getTotalBytes(request);
      if (typeof totalBytes === "number") {
        contentLengthValue = String(totalBytes);
      }
    }
    if (contentLengthValue) {
      headers.set("Content-Length", contentLengthValue);
    }
    if (!headers.has("User-Agent")) {
      headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
    }
    if (request.compress && !headers.has("Accept-Encoding")) {
      headers.set("Accept-Encoding", "gzip,deflate");
    }
    let agent = request.agent;
    if (typeof agent === "function") {
      agent = agent(parsedURL);
    }
    if (!headers.has("Connection") && !agent) {
      headers.set("Connection", "close");
    }
    return Object.assign({}, parsedURL, {
      method: request.method,
      headers: exportNodeCompatibleHeaders(headers),
      agent
    });
  }
  function AbortError(message) {
    Error.call(this, message);
    this.type = "aborted";
    this.message = message;
    Error.captureStackTrace(this, this.constructor);
  }
  AbortError.prototype = Object.create(Error.prototype);
  AbortError.prototype.constructor = AbortError;
  AbortError.prototype.name = "AbortError";
  var PassThrough$1 = import_stream.default.PassThrough;
  var resolve_url = import_url2.default.resolve;
  function fetch(url, opts) {
    if (!fetch.Promise) {
      throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
    }
    Body.Promise = fetch.Promise;
    return new fetch.Promise(function(resolve, reject) {
      const request = new Request2(url, opts);
      const options = getNodeRequestOptions(request);
      const send = (options.protocol === "https:" ? import_https.default : import_http.default).request;
      const signal = request.signal;
      let response = null;
      const abort = function abort2() {
        let error = new AbortError("The user aborted a request.");
        reject(error);
        if (request.body && request.body instanceof import_stream.default.Readable) {
          request.body.destroy(error);
        }
        if (!response || !response.body)
          return;
        response.body.emit("error", error);
      };
      if (signal && signal.aborted) {
        abort();
        return;
      }
      const abortAndFinalize = function abortAndFinalize2() {
        abort();
        finalize();
      };
      const req = send(options);
      let reqTimeout;
      if (signal) {
        signal.addEventListener("abort", abortAndFinalize);
      }
      function finalize() {
        req.abort();
        if (signal)
          signal.removeEventListener("abort", abortAndFinalize);
        clearTimeout(reqTimeout);
      }
      if (request.timeout) {
        req.once("socket", function(socket) {
          reqTimeout = setTimeout(function() {
            reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
            finalize();
          }, request.timeout);
        });
      }
      req.on("error", function(err) {
        reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
        finalize();
      });
      req.on("response", function(res) {
        clearTimeout(reqTimeout);
        const headers = createHeadersLenient(res.headers);
        if (fetch.isRedirect(res.statusCode)) {
          const location = headers.get("Location");
          const locationURL = location === null ? null : resolve_url(request.url, location);
          switch (request.redirect) {
            case "error":
              reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
              finalize();
              return;
            case "manual":
              if (locationURL !== null) {
                try {
                  headers.set("Location", locationURL);
                } catch (err) {
                  reject(err);
                }
              }
              break;
            case "follow":
              if (locationURL === null) {
                break;
              }
              if (request.counter >= request.follow) {
                reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                finalize();
                return;
              }
              const requestOpts = {
                headers: new Headers2(request.headers),
                follow: request.follow,
                counter: request.counter + 1,
                agent: request.agent,
                compress: request.compress,
                method: request.method,
                body: request.body,
                signal: request.signal,
                timeout: request.timeout,
                size: request.size
              };
              if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                finalize();
                return;
              }
              if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                requestOpts.method = "GET";
                requestOpts.body = void 0;
                requestOpts.headers.delete("content-length");
              }
              resolve(fetch(new Request2(locationURL, requestOpts)));
              finalize();
              return;
          }
        }
        res.once("end", function() {
          if (signal)
            signal.removeEventListener("abort", abortAndFinalize);
        });
        let body = res.pipe(new PassThrough$1());
        const response_options = {
          url: request.url,
          status: res.statusCode,
          statusText: res.statusMessage,
          headers,
          size: request.size,
          timeout: request.timeout,
          counter: request.counter
        };
        const codings = headers.get("Content-Encoding");
        if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
          response = new Response2(body, response_options);
          resolve(response);
          return;
        }
        const zlibOptions = {
          flush: import_zlib.default.Z_SYNC_FLUSH,
          finishFlush: import_zlib.default.Z_SYNC_FLUSH
        };
        if (codings == "gzip" || codings == "x-gzip") {
          body = body.pipe(import_zlib.default.createGunzip(zlibOptions));
          response = new Response2(body, response_options);
          resolve(response);
          return;
        }
        if (codings == "deflate" || codings == "x-deflate") {
          const raw = res.pipe(new PassThrough$1());
          raw.once("data", function(chunk) {
            if ((chunk[0] & 15) === 8) {
              body = body.pipe(import_zlib.default.createInflate());
            } else {
              body = body.pipe(import_zlib.default.createInflateRaw());
            }
            response = new Response2(body, response_options);
            resolve(response);
          });
          return;
        }
        if (codings == "br" && typeof import_zlib.default.createBrotliDecompress === "function") {
          body = body.pipe(import_zlib.default.createBrotliDecompress());
          response = new Response2(body, response_options);
          resolve(response);
          return;
        }
        response = new Response2(body, response_options);
        resolve(response);
      });
      writeToStream(req, request);
    });
  }
  fetch.isRedirect = function(code) {
    return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
  };
  fetch.Promise = global.Promise;
  var lib_default = fetch;
});

// ../../node_modules/.pnpm/agent-base@6.0.2/node_modules/agent-base/dist/src/promisify.js
var require_promisify = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  function promisify4(fn) {
    return function(req, opts) {
      return new Promise((resolve, reject) => {
        fn.call(this, req, opts, (err, rtn) => {
          if (err) {
            reject(err);
          } else {
            resolve(rtn);
          }
        });
      });
    };
  }
  exports2.default = promisify4;
});

// ../../node_modules/.pnpm/agent-base@6.0.2/node_modules/agent-base/dist/src/index.js
var require_src3 = __commonJS((exports2, module2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  var events_1 = require("events");
  var debug_12 = __importDefault2(require_src2());
  var promisify_1 = __importDefault2(require_promisify());
  var debug3 = debug_12.default("agent-base");
  function isAgent(v) {
    return Boolean(v) && typeof v.addRequest === "function";
  }
  function isSecureEndpoint() {
    const {stack} = new Error();
    if (typeof stack !== "string")
      return false;
    return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
  }
  function createAgent(callback, opts) {
    return new createAgent.Agent(callback, opts);
  }
  (function(createAgent2) {
    class Agent extends events_1.EventEmitter {
      constructor(callback, _opts) {
        super();
        let opts = _opts;
        if (typeof callback === "function") {
          this.callback = callback;
        } else if (callback) {
          opts = callback;
        }
        this.timeout = null;
        if (opts && typeof opts.timeout === "number") {
          this.timeout = opts.timeout;
        }
        this.maxFreeSockets = 1;
        this.maxSockets = 1;
        this.maxTotalSockets = Infinity;
        this.sockets = {};
        this.freeSockets = {};
        this.requests = {};
        this.options = {};
      }
      get defaultPort() {
        if (typeof this.explicitDefaultPort === "number") {
          return this.explicitDefaultPort;
        }
        return isSecureEndpoint() ? 443 : 80;
      }
      set defaultPort(v) {
        this.explicitDefaultPort = v;
      }
      get protocol() {
        if (typeof this.explicitProtocol === "string") {
          return this.explicitProtocol;
        }
        return isSecureEndpoint() ? "https:" : "http:";
      }
      set protocol(v) {
        this.explicitProtocol = v;
      }
      callback(req, opts, fn) {
        throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
      }
      addRequest(req, _opts) {
        const opts = Object.assign({}, _opts);
        if (typeof opts.secureEndpoint !== "boolean") {
          opts.secureEndpoint = isSecureEndpoint();
        }
        if (opts.host == null) {
          opts.host = "localhost";
        }
        if (opts.port == null) {
          opts.port = opts.secureEndpoint ? 443 : 80;
        }
        if (opts.protocol == null) {
          opts.protocol = opts.secureEndpoint ? "https:" : "http:";
        }
        if (opts.host && opts.path) {
          delete opts.path;
        }
        delete opts.agent;
        delete opts.hostname;
        delete opts._defaultAgent;
        delete opts.defaultPort;
        delete opts.createConnection;
        req._last = true;
        req.shouldKeepAlive = false;
        let timedOut = false;
        let timeoutId = null;
        const timeoutMs = opts.timeout || this.timeout;
        const onerror = (err) => {
          if (req._hadError)
            return;
          req.emit("error", err);
          req._hadError = true;
        };
        const ontimeout = () => {
          timeoutId = null;
          timedOut = true;
          const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
          err.code = "ETIMEOUT";
          onerror(err);
        };
        const callbackError = (err) => {
          if (timedOut)
            return;
          if (timeoutId !== null) {
            clearTimeout(timeoutId);
            timeoutId = null;
          }
          onerror(err);
        };
        const onsocket = (socket) => {
          if (timedOut)
            return;
          if (timeoutId != null) {
            clearTimeout(timeoutId);
            timeoutId = null;
          }
          if (isAgent(socket)) {
            debug3("Callback returned another Agent instance %o", socket.constructor.name);
            socket.addRequest(req, opts);
            return;
          }
          if (socket) {
            socket.once("free", () => {
              this.freeSocket(socket, opts);
            });
            req.onSocket(socket);
            return;
          }
          const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
          onerror(err);
        };
        if (typeof this.callback !== "function") {
          onerror(new Error("`callback` is not defined"));
          return;
        }
        if (!this.promisifiedCallback) {
          if (this.callback.length >= 3) {
            debug3("Converting legacy callback function to promise");
            this.promisifiedCallback = promisify_1.default(this.callback);
          } else {
            this.promisifiedCallback = this.callback;
          }
        }
        if (typeof timeoutMs === "number" && timeoutMs > 0) {
          timeoutId = setTimeout(ontimeout, timeoutMs);
        }
        if ("port" in opts && typeof opts.port !== "number") {
          opts.port = Number(opts.port);
        }
        try {
          debug3("Resolving socket for %o request: %o", opts.protocol, `${req.method} ${req.path}`);
          Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
        } catch (err) {
          Promise.reject(err).catch(callbackError);
        }
      }
      freeSocket(socket, opts) {
        debug3("Freeing socket %o %o", socket.constructor.name, opts);
        socket.destroy();
      }
      destroy() {
        debug3("Destroying agent %o", this.constructor.name);
      }
    }
    createAgent2.Agent = Agent;
    createAgent2.prototype = createAgent2.Agent.prototype;
  })(createAgent || (createAgent = {}));
  module2.exports = createAgent;
});

// ../../node_modules/.pnpm/https-proxy-agent@5.0.0/node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS((exports2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  var debug_12 = __importDefault2(require_src2());
  var debug3 = debug_12.default("https-proxy-agent:parse-proxy-response");
  function parseProxyResponse(socket) {
    return new Promise((resolve, reject) => {
      let buffersLength = 0;
      const buffers = [];
      function read() {
        const b = socket.read();
        if (b)
          ondata(b);
        else
          socket.once("readable", read);
      }
      function cleanup2() {
        socket.removeListener("end", onend);
        socket.removeListener("error", onerror);
        socket.removeListener("close", onclose);
        socket.removeListener("readable", read);
      }
      function onclose(err) {
        debug3("onclose had error %o", err);
      }
      function onend() {
        debug3("onend");
      }
      function onerror(err) {
        cleanup2();
        debug3("onerror %o", err);
        reject(err);
      }
      function ondata(b) {
        buffers.push(b);
        buffersLength += b.length;
        const buffered = Buffer.concat(buffers, buffersLength);
        const endOfHeaders = buffered.indexOf("\r\n\r\n");
        if (endOfHeaders === -1) {
          debug3("have not received end of HTTP headers yet...");
          read();
          return;
        }
        const firstLine = buffered.toString("ascii", 0, buffered.indexOf("\r\n"));
        const statusCode = +firstLine.split(" ")[1];
        debug3("got proxy server response: %o", firstLine);
        resolve({
          statusCode,
          buffered
        });
      }
      socket.on("error", onerror);
      socket.on("close", onclose);
      socket.on("end", onend);
      read();
    });
  }
  exports2.default = parseProxyResponse;
});

// ../../node_modules/.pnpm/https-proxy-agent@5.0.0/node_modules/https-proxy-agent/dist/agent.js
var require_agent = __commonJS((exports2) => {
  "use strict";
  var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  var net_1 = __importDefault2(require("net"));
  var tls_1 = __importDefault2(require("tls"));
  var url_1 = __importDefault2(require("url"));
  var assert_1 = __importDefault2(require("assert"));
  var debug_12 = __importDefault2(require_src2());
  var agent_base_1 = require_src3();
  var parse_proxy_response_1 = __importDefault2(require_parse_proxy_response());
  var debug3 = debug_12.default("https-proxy-agent:agent");
  var HttpsProxyAgent = class extends agent_base_1.Agent {
    constructor(_opts) {
      let opts;
      if (typeof _opts === "string") {
        opts = url_1.default.parse(_opts);
      } else {
        opts = _opts;
      }
      if (!opts) {
        throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
      }
      debug3("creating new HttpsProxyAgent instance: %o", opts);
      super(opts);
      const proxy = Object.assign({}, opts);
      this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
      proxy.host = proxy.hostname || proxy.host;
      if (typeof proxy.port === "string") {
        proxy.port = parseInt(proxy.port, 10);
      }
      if (!proxy.port && proxy.host) {
        proxy.port = this.secureProxy ? 443 : 80;
      }
      if (this.secureProxy && !("ALPNProtocols" in proxy)) {
        proxy.ALPNProtocols = ["http 1.1"];
      }
      if (proxy.host && proxy.path) {
        delete proxy.path;
        delete proxy.pathname;
      }
      this.proxy = proxy;
    }
    callback(req, opts) {
      return __awaiter(this, void 0, void 0, function* () {
        const {proxy, secureProxy} = this;
        let socket;
        if (secureProxy) {
          debug3("Creating `tls.Socket`: %o", proxy);
          socket = tls_1.default.connect(proxy);
        } else {
          debug3("Creating `net.Socket`: %o", proxy);
          socket = net_1.default.connect(proxy);
        }
        const headers = Object.assign({}, proxy.headers);
        const hostname = `${opts.host}:${opts.port}`;
        let payload = `CONNECT ${hostname} HTTP/1.1\r
`;
        if (proxy.auth) {
          headers["Proxy-Authorization"] = `Basic ${Buffer.from(proxy.auth).toString("base64")}`;
        }
        let {host, port, secureEndpoint} = opts;
        if (!isDefaultPort(port, secureEndpoint)) {
          host += `:${port}`;
        }
        headers.Host = host;
        headers.Connection = "close";
        for (const name of Object.keys(headers)) {
          payload += `${name}: ${headers[name]}\r
`;
        }
        const proxyResponsePromise = parse_proxy_response_1.default(socket);
        socket.write(`${payload}\r
`);
        const {statusCode, buffered} = yield proxyResponsePromise;
        if (statusCode === 200) {
          req.once("socket", resume);
          if (opts.secureEndpoint) {
            const servername = opts.servername || opts.host;
            if (!servername) {
              throw new Error('Could not determine "servername"');
            }
            debug3("Upgrading socket connection to TLS");
            return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, "host", "hostname", "path", "port")), {
              socket,
              servername
            }));
          }
          return socket;
        }
        socket.destroy();
        const fakeSocket = new net_1.default.Socket();
        fakeSocket.readable = true;
        req.once("socket", (s2) => {
          debug3("replaying proxy buffer for failed request");
          assert_1.default(s2.listenerCount("data") > 0);
          s2.push(buffered);
          s2.push(null);
        });
        return fakeSocket;
      });
    }
  };
  exports2.default = HttpsProxyAgent;
  function resume(socket) {
    socket.resume();
  }
  function isDefaultPort(port, secure) {
    return Boolean(!secure && port === 80 || secure && port === 443);
  }
  function isHTTPS(protocol) {
    return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
  }
  function omit(obj, ...keys) {
    const ret = {};
    let key;
    for (key in obj) {
      if (!keys.includes(key)) {
        ret[key] = obj[key];
      }
    }
    return ret;
  }
});

// ../../node_modules/.pnpm/https-proxy-agent@5.0.0/node_modules/https-proxy-agent/dist/index.js
var require_dist5 = __commonJS((exports2, module2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  var agent_1 = __importDefault2(require_agent());
  function createHttpsProxyAgent(opts) {
    return new agent_1.default(opts);
  }
  (function(createHttpsProxyAgent2) {
    createHttpsProxyAgent2.HttpsProxyAgent = agent_1.default;
    createHttpsProxyAgent2.prototype = agent_1.default.prototype;
  })(createHttpsProxyAgent || (createHttpsProxyAgent = {}));
  module2.exports = createHttpsProxyAgent;
});

// ../../node_modules/.pnpm/@tootallnate+once@1.1.2/node_modules/@tootallnate/once/dist/index.js
var require_dist6 = __commonJS((exports2, module2) => {
  "use strict";
  function noop() {
  }
  function once(emitter, name) {
    const o = once.spread(emitter, name);
    const r = o.then((args2) => args2[0]);
    r.cancel = o.cancel;
    return r;
  }
  (function(once2) {
    function spread(emitter, name) {
      let c = null;
      const p = new Promise((resolve, reject) => {
        function cancel() {
          emitter.removeListener(name, onEvent);
          emitter.removeListener("error", onError);
          p.cancel = noop;
        }
        function onEvent(...args2) {
          cancel();
          resolve(args2);
        }
        function onError(err) {
          cancel();
          reject(err);
        }
        c = cancel;
        emitter.on(name, onEvent);
        emitter.on("error", onError);
      });
      if (!c) {
        throw new TypeError("Could not get `cancel()` function");
      }
      p.cancel = c;
      return p;
    }
    once2.spread = spread;
  })(once || (once = {}));
  module2.exports = once;
});

// ../../node_modules/.pnpm/http-proxy-agent@4.0.1/node_modules/http-proxy-agent/dist/agent.js
var require_agent2 = __commonJS((exports2) => {
  "use strict";
  var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  var net_1 = __importDefault2(require("net"));
  var tls_1 = __importDefault2(require("tls"));
  var url_1 = __importDefault2(require("url"));
  var debug_12 = __importDefault2(require_src2());
  var once_1 = __importDefault2(require_dist6());
  var agent_base_1 = require_src3();
  var debug3 = debug_12.default("http-proxy-agent");
  function isHTTPS(protocol) {
    return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
  }
  var HttpProxyAgent = class extends agent_base_1.Agent {
    constructor(_opts) {
      let opts;
      if (typeof _opts === "string") {
        opts = url_1.default.parse(_opts);
      } else {
        opts = _opts;
      }
      if (!opts) {
        throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
      }
      debug3("Creating new HttpProxyAgent instance: %o", opts);
      super(opts);
      const proxy = Object.assign({}, opts);
      this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
      proxy.host = proxy.hostname || proxy.host;
      if (typeof proxy.port === "string") {
        proxy.port = parseInt(proxy.port, 10);
      }
      if (!proxy.port && proxy.host) {
        proxy.port = this.secureProxy ? 443 : 80;
      }
      if (proxy.host && proxy.path) {
        delete proxy.path;
        delete proxy.pathname;
      }
      this.proxy = proxy;
    }
    callback(req, opts) {
      return __awaiter(this, void 0, void 0, function* () {
        const {proxy, secureProxy} = this;
        const parsed = url_1.default.parse(req.path);
        if (!parsed.protocol) {
          parsed.protocol = "http:";
        }
        if (!parsed.hostname) {
          parsed.hostname = opts.hostname || opts.host || null;
        }
        if (parsed.port == null && typeof opts.port) {
          parsed.port = String(opts.port);
        }
        if (parsed.port === "80") {
          delete parsed.port;
        }
        req.path = url_1.default.format(parsed);
        if (proxy.auth) {
          req.setHeader("Proxy-Authorization", `Basic ${Buffer.from(proxy.auth).toString("base64")}`);
        }
        let socket;
        if (secureProxy) {
          debug3("Creating `tls.Socket`: %o", proxy);
          socket = tls_1.default.connect(proxy);
        } else {
          debug3("Creating `net.Socket`: %o", proxy);
          socket = net_1.default.connect(proxy);
        }
        if (req._header) {
          let first;
          let endOfHeaders;
          debug3("Regenerating stored HTTP header string for request");
          req._header = null;
          req._implicitHeader();
          if (req.output && req.output.length > 0) {
            debug3("Patching connection write() output buffer with updated header");
            first = req.output[0];
            endOfHeaders = first.indexOf("\r\n\r\n") + 4;
            req.output[0] = req._header + first.substring(endOfHeaders);
            debug3("Output buffer: %o", req.output);
          } else if (req.outputData && req.outputData.length > 0) {
            debug3("Patching connection write() output buffer with updated header");
            first = req.outputData[0].data;
            endOfHeaders = first.indexOf("\r\n\r\n") + 4;
            req.outputData[0].data = req._header + first.substring(endOfHeaders);
            debug3("Output buffer: %o", req.outputData[0].data);
          }
        }
        yield once_1.default(socket, "connect");
        return socket;
      });
    }
  };
  exports2.default = HttpProxyAgent;
});

// ../../node_modules/.pnpm/http-proxy-agent@4.0.1/node_modules/http-proxy-agent/dist/index.js
var require_dist7 = __commonJS((exports2, module2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  var agent_1 = __importDefault2(require_agent2());
  function createHttpProxyAgent(opts) {
    return new agent_1.default(opts);
  }
  (function(createHttpProxyAgent2) {
    createHttpProxyAgent2.HttpProxyAgent = agent_1.default;
    createHttpProxyAgent2.prototype = agent_1.default.prototype;
  })(createHttpProxyAgent || (createHttpProxyAgent = {}));
  module2.exports = createHttpProxyAgent;
});

// ../../node_modules/.pnpm/@prisma+fetch-engine@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/fetch-engine/dist/getProxyAgent.js
var require_getProxyAgent = __commonJS((exports2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getProxyAgent = void 0;
  var https_proxy_agent_1 = __importDefault2(require_dist5());
  var http_proxy_agent_1 = __importDefault2(require_dist7());
  var url_1 = __importDefault2(require("url"));
  function formatHostname(hostname) {
    return hostname.replace(/^\.*/, ".").toLowerCase();
  }
  function parseNoProxyZone(zone) {
    zone = zone.trim().toLowerCase();
    const zoneParts = zone.split(":", 2);
    const zoneHost = formatHostname(zoneParts[0]);
    const zonePort = zoneParts[1];
    const hasPort = zone.includes(":");
    return {hostname: zoneHost, port: zonePort, hasPort};
  }
  function uriInNoProxy(uri, noProxy) {
    const port = uri.port || (uri.protocol === "https:" ? "443" : "80");
    const hostname = formatHostname(uri.hostname);
    const noProxyList = noProxy.split(",");
    return noProxyList.map(parseNoProxyZone).some(function(noProxyZone) {
      const isMatchedAt = hostname.indexOf(noProxyZone.hostname);
      const hostnameMatched = isMatchedAt > -1 && isMatchedAt === hostname.length - noProxyZone.hostname.length;
      if (noProxyZone.hasPort) {
        return port === noProxyZone.port && hostnameMatched;
      }
      return hostnameMatched;
    });
  }
  function getProxyFromURI(uri) {
    const noProxy = process.env.NO_PROXY || process.env.no_proxy || "";
    if (noProxy === "*") {
      return null;
    }
    if (noProxy !== "" && uriInNoProxy(uri, noProxy)) {
      return null;
    }
    if (uri.protocol === "http:") {
      return process.env.HTTP_PROXY || process.env.http_proxy || null;
    }
    if (uri.protocol === "https:") {
      return process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy || null;
    }
    return null;
  }
  function getProxyAgent(url) {
    const uri = url_1.default.parse(url);
    const proxy = getProxyFromURI(uri);
    if (!proxy) {
      return void 0;
    }
    if (uri.protocol === "http:") {
      return http_proxy_agent_1.default(proxy);
    }
    if (uri.protocol === "https:") {
      return https_proxy_agent_1.default(proxy);
    }
    return void 0;
  }
  exports2.getProxyAgent = getProxyAgent;
});

// ../../node_modules/.pnpm/crypto-random-string@2.0.0/node_modules/crypto-random-string/index.js
var require_crypto_random_string = __commonJS((exports2, module2) => {
  "use strict";
  var crypto2 = require("crypto");
  module2.exports = (length) => {
    if (!Number.isFinite(length)) {
      throw new TypeError("Expected a finite number");
    }
    return crypto2.randomBytes(Math.ceil(length / 2)).toString("hex").slice(0, length);
  };
});

// ../../node_modules/.pnpm/unique-string@2.0.0/node_modules/unique-string/index.js
var require_unique_string = __commonJS((exports2, module2) => {
  "use strict";
  var cryptoRandomString = require_crypto_random_string();
  module2.exports = () => cryptoRandomString(32);
});

// ../../node_modules/.pnpm/array-union@2.1.0/node_modules/array-union/index.js
var require_array_union = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (...arguments_) => {
    return [...new Set([].concat(...arguments_))];
  };
});

// ../../node_modules/.pnpm/merge2@1.4.1/node_modules/merge2/index.js
var require_merge2 = __commonJS((exports2, module2) => {
  "use strict";
  var Stream = require("stream");
  var PassThrough = Stream.PassThrough;
  var slice = Array.prototype.slice;
  module2.exports = merge2;
  function merge2() {
    const streamsQueue = [];
    const args2 = slice.call(arguments);
    let merging = false;
    let options = args2[args2.length - 1];
    if (options && !Array.isArray(options) && options.pipe == null) {
      args2.pop();
    } else {
      options = {};
    }
    const doEnd = options.end !== false;
    const doPipeError = options.pipeError === true;
    if (options.objectMode == null) {
      options.objectMode = true;
    }
    if (options.highWaterMark == null) {
      options.highWaterMark = 64 * 1024;
    }
    const mergedStream = PassThrough(options);
    function addStream() {
      for (let i = 0, len = arguments.length; i < len; i++) {
        streamsQueue.push(pauseStreams(arguments[i], options));
      }
      mergeStream();
      return this;
    }
    function mergeStream() {
      if (merging) {
        return;
      }
      merging = true;
      let streams = streamsQueue.shift();
      if (!streams) {
        process.nextTick(endStream);
        return;
      }
      if (!Array.isArray(streams)) {
        streams = [streams];
      }
      let pipesCount = streams.length + 1;
      function next() {
        if (--pipesCount > 0) {
          return;
        }
        merging = false;
        mergeStream();
      }
      function pipe(stream) {
        function onend() {
          stream.removeListener("merge2UnpipeEnd", onend);
          stream.removeListener("end", onend);
          if (doPipeError) {
            stream.removeListener("error", onerror);
          }
          next();
        }
        function onerror(err) {
          mergedStream.emit("error", err);
        }
        if (stream._readableState.endEmitted) {
          return next();
        }
        stream.on("merge2UnpipeEnd", onend);
        stream.on("end", onend);
        if (doPipeError) {
          stream.on("error", onerror);
        }
        stream.pipe(mergedStream, {end: false});
        stream.resume();
      }
      for (let i = 0; i < streams.length; i++) {
        pipe(streams[i]);
      }
      next();
    }
    function endStream() {
      merging = false;
      mergedStream.emit("queueDrain");
      if (doEnd) {
        mergedStream.end();
      }
    }
    mergedStream.setMaxListeners(0);
    mergedStream.add = addStream;
    mergedStream.on("unpipe", function(stream) {
      stream.emit("merge2UnpipeEnd");
    });
    if (args2.length) {
      addStream.apply(null, args2);
    }
    return mergedStream;
  }
  function pauseStreams(streams, options) {
    if (!Array.isArray(streams)) {
      if (!streams._readableState && streams.pipe) {
        streams = streams.pipe(PassThrough(options));
      }
      if (!streams._readableState || !streams.pause || !streams.pipe) {
        throw new Error("Only readable stream can be merged.");
      }
      streams.pause();
    } else {
      for (let i = 0, len = streams.length; i < len; i++) {
        streams[i] = pauseStreams(streams[i], options);
      }
    }
    return streams;
  }
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/utils/array.js
var require_array = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.splitWhen = exports2.flatten = void 0;
  function flatten(items) {
    return items.reduce((collection, item) => [].concat(collection, item), []);
  }
  exports2.flatten = flatten;
  function splitWhen(items, predicate) {
    const result = [[]];
    let groupIndex = 0;
    for (const item of items) {
      if (predicate(item)) {
        groupIndex++;
        result[groupIndex] = [];
      } else {
        result[groupIndex].push(item);
      }
    }
    return result;
  }
  exports2.splitWhen = splitWhen;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/utils/errno.js
var require_errno = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.isEnoentCodeError = void 0;
  function isEnoentCodeError(error) {
    return error.code === "ENOENT";
  }
  exports2.isEnoentCodeError = isEnoentCodeError;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/utils/fs.js
var require_fs2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.createDirentFromStats = void 0;
  var DirentFromStats = class {
    constructor(name, stats) {
      this.name = name;
      this.isBlockDevice = stats.isBlockDevice.bind(stats);
      this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
      this.isDirectory = stats.isDirectory.bind(stats);
      this.isFIFO = stats.isFIFO.bind(stats);
      this.isFile = stats.isFile.bind(stats);
      this.isSocket = stats.isSocket.bind(stats);
      this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
    }
  };
  function createDirentFromStats(name, stats) {
    return new DirentFromStats(name, stats);
  }
  exports2.createDirentFromStats = createDirentFromStats;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/utils/path.js
var require_path = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.removeLeadingDotSegment = exports2.escape = exports2.makeAbsolute = exports2.unixify = void 0;
  var path10 = require("path");
  var LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;
  var UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g;
  function unixify(filepath) {
    return filepath.replace(/\\/g, "/");
  }
  exports2.unixify = unixify;
  function makeAbsolute(cwd, filepath) {
    return path10.resolve(cwd, filepath);
  }
  exports2.makeAbsolute = makeAbsolute;
  function escape2(pattern) {
    return pattern.replace(UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
  }
  exports2.escape = escape2;
  function removeLeadingDotSegment(entry) {
    if (entry.charAt(0) === ".") {
      const secondCharactery = entry.charAt(1);
      if (secondCharactery === "/" || secondCharactery === "\\") {
        return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
      }
    }
    return entry;
  }
  exports2.removeLeadingDotSegment = removeLeadingDotSegment;
});

// ../../node_modules/.pnpm/is-extglob@2.1.1/node_modules/is-extglob/index.js
var require_is_extglob = __commonJS((exports2, module2) => {
  /*!
   * is-extglob <https://github.com/jonschlinkert/is-extglob>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  module2.exports = function isExtglob(str) {
    if (typeof str !== "string" || str === "") {
      return false;
    }
    var match;
    while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
      if (match[2])
        return true;
      str = str.slice(match.index + match[0].length);
    }
    return false;
  };
});

// ../../node_modules/.pnpm/is-glob@4.0.1/node_modules/is-glob/index.js
var require_is_glob = __commonJS((exports2, module2) => {
  /*!
   * is-glob <https://github.com/jonschlinkert/is-glob>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  var isExtglob = require_is_extglob();
  var chars = {"{": "}", "(": ")", "[": "]"};
  var strictRegex = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
  var relaxedRegex = /\\(.)|(^!|[*?{}()[\]]|\(\?)/;
  module2.exports = function isGlob(str, options) {
    if (typeof str !== "string" || str === "") {
      return false;
    }
    if (isExtglob(str)) {
      return true;
    }
    var regex = strictRegex;
    var match;
    if (options && options.strict === false) {
      regex = relaxedRegex;
    }
    while (match = regex.exec(str)) {
      if (match[2])
        return true;
      var idx = match.index + match[0].length;
      var open3 = match[1];
      var close2 = open3 ? chars[open3] : null;
      if (open3 && close2) {
        var n = str.indexOf(close2, idx);
        if (n !== -1) {
          idx = n + 1;
        }
      }
      str = str.slice(idx);
    }
    return false;
  };
});

// ../../node_modules/.pnpm/glob-parent@5.1.2/node_modules/glob-parent/index.js
var require_glob_parent = __commonJS((exports2, module2) => {
  "use strict";
  var isGlob = require_is_glob();
  var pathPosixDirname = require("path").posix.dirname;
  var isWin32 = require("os").platform() === "win32";
  var slash = "/";
  var backslash = /\\/g;
  var enclosure = /[\{\[].*[\}\]]$/;
  var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
  var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
  module2.exports = function globParent(str, opts) {
    var options = Object.assign({flipBackslashes: true}, opts);
    if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
      str = str.replace(backslash, slash);
    }
    if (enclosure.test(str)) {
      str += slash;
    }
    str += "a";
    do {
      str = pathPosixDirname(str);
    } while (isGlob(str) || globby.test(str));
    return str.replace(escaped, "$1");
  };
});

// ../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/utils.js
var require_utils2 = __commonJS((exports2) => {
  "use strict";
  exports2.isInteger = (num) => {
    if (typeof num === "number") {
      return Number.isInteger(num);
    }
    if (typeof num === "string" && num.trim() !== "") {
      return Number.isInteger(Number(num));
    }
    return false;
  };
  exports2.find = (node, type) => node.nodes.find((node2) => node2.type === type);
  exports2.exceedsLimit = (min, max, step = 1, limit) => {
    if (limit === false)
      return false;
    if (!exports2.isInteger(min) || !exports2.isInteger(max))
      return false;
    return (Number(max) - Number(min)) / Number(step) >= limit;
  };
  exports2.escapeNode = (block, n = 0, type) => {
    let node = block.nodes[n];
    if (!node)
      return;
    if (type && node.type === type || node.type === "open" || node.type === "close") {
      if (node.escaped !== true) {
        node.value = "\\" + node.value;
        node.escaped = true;
      }
    }
  };
  exports2.encloseBrace = (node) => {
    if (node.type !== "brace")
      return false;
    if (node.commas >> 0 + node.ranges >> 0 === 0) {
      node.invalid = true;
      return true;
    }
    return false;
  };
  exports2.isInvalidBrace = (block) => {
    if (block.type !== "brace")
      return false;
    if (block.invalid === true || block.dollar)
      return true;
    if (block.commas >> 0 + block.ranges >> 0 === 0) {
      block.invalid = true;
      return true;
    }
    if (block.open !== true || block.close !== true) {
      block.invalid = true;
      return true;
    }
    return false;
  };
  exports2.isOpenOrClose = (node) => {
    if (node.type === "open" || node.type === "close") {
      return true;
    }
    return node.open === true || node.close === true;
  };
  exports2.reduce = (nodes) => nodes.reduce((acc, node) => {
    if (node.type === "text")
      acc.push(node.value);
    if (node.type === "range")
      node.type = "text";
    return acc;
  }, []);
  exports2.flatten = (...args2) => {
    const result = [];
    const flat = (arr) => {
      for (let i = 0; i < arr.length; i++) {
        let ele = arr[i];
        Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
      }
      return result;
    };
    flat(args2);
    return result;
  };
});

// ../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/stringify.js
var require_stringify = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils2();
  module2.exports = (ast, options = {}) => {
    let stringify2 = (node, parent = {}) => {
      let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
      let invalidNode = node.invalid === true && options.escapeInvalid === true;
      let output = "";
      if (node.value) {
        if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
          return "\\" + node.value;
        }
        return node.value;
      }
      if (node.value) {
        return node.value;
      }
      if (node.nodes) {
        for (let child of node.nodes) {
          output += stringify2(child);
        }
      }
      return output;
    };
    return stringify2(ast);
  };
});

// ../../node_modules/.pnpm/is-number@7.0.0/node_modules/is-number/index.js
var require_is_number = __commonJS((exports2, module2) => {
  /*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  module2.exports = function(num) {
    if (typeof num === "number") {
      return num - num === 0;
    }
    if (typeof num === "string" && num.trim() !== "") {
      return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
    }
    return false;
  };
});

// ../../node_modules/.pnpm/to-regex-range@5.0.1/node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS((exports2, module2) => {
  /*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  var isNumber = require_is_number();
  var toRegexRange = (min, max, options) => {
    if (isNumber(min) === false) {
      throw new TypeError("toRegexRange: expected the first argument to be a number");
    }
    if (max === void 0 || min === max) {
      return String(min);
    }
    if (isNumber(max) === false) {
      throw new TypeError("toRegexRange: expected the second argument to be a number.");
    }
    let opts = {relaxZeros: true, ...options};
    if (typeof opts.strictZeros === "boolean") {
      opts.relaxZeros = opts.strictZeros === false;
    }
    let relax = String(opts.relaxZeros);
    let shorthand = String(opts.shorthand);
    let capture = String(opts.capture);
    let wrap = String(opts.wrap);
    let cacheKey = min + ":" + max + "=" + relax + shorthand + capture + wrap;
    if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
      return toRegexRange.cache[cacheKey].result;
    }
    let a = Math.min(min, max);
    let b = Math.max(min, max);
    if (Math.abs(a - b) === 1) {
      let result = min + "|" + max;
      if (opts.capture) {
        return `(${result})`;
      }
      if (opts.wrap === false) {
        return result;
      }
      return `(?:${result})`;
    }
    let isPadded = hasPadding(min) || hasPadding(max);
    let state = {min, max, a, b};
    let positives = [];
    let negatives = [];
    if (isPadded) {
      state.isPadded = isPadded;
      state.maxLen = String(state.max).length;
    }
    if (a < 0) {
      let newMin = b < 0 ? Math.abs(b) : 1;
      negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
      a = state.a = 0;
    }
    if (b >= 0) {
      positives = splitToPatterns(a, b, state, opts);
    }
    state.negatives = negatives;
    state.positives = positives;
    state.result = collatePatterns(negatives, positives, opts);
    if (opts.capture === true) {
      state.result = `(${state.result})`;
    } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
      state.result = `(?:${state.result})`;
    }
    toRegexRange.cache[cacheKey] = state;
    return state.result;
  };
  function collatePatterns(neg, pos, options) {
    let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
    let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
    let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
    let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
    return subpatterns.join("|");
  }
  function splitToRanges(min, max) {
    let nines = 1;
    let zeros = 1;
    let stop = countNines(min, nines);
    let stops = new Set([max]);
    while (min <= stop && stop <= max) {
      stops.add(stop);
      nines += 1;
      stop = countNines(min, nines);
    }
    stop = countZeros(max + 1, zeros) - 1;
    while (min < stop && stop <= max) {
      stops.add(stop);
      zeros += 1;
      stop = countZeros(max + 1, zeros) - 1;
    }
    stops = [...stops];
    stops.sort(compare);
    return stops;
  }
  function rangeToPattern(start, stop, options) {
    if (start === stop) {
      return {pattern: start, count: [], digits: 0};
    }
    let zipped = zip(start, stop);
    let digits = zipped.length;
    let pattern = "";
    let count = 0;
    for (let i = 0; i < digits; i++) {
      let [startDigit, stopDigit] = zipped[i];
      if (startDigit === stopDigit) {
        pattern += startDigit;
      } else if (startDigit !== "0" || stopDigit !== "9") {
        pattern += toCharacterClass(startDigit, stopDigit, options);
      } else {
        count++;
      }
    }
    if (count) {
      pattern += options.shorthand === true ? "\\d" : "[0-9]";
    }
    return {pattern, count: [count], digits};
  }
  function splitToPatterns(min, max, tok, options) {
    let ranges = splitToRanges(min, max);
    let tokens = [];
    let start = min;
    let prev;
    for (let i = 0; i < ranges.length; i++) {
      let max2 = ranges[i];
      let obj = rangeToPattern(String(start), String(max2), options);
      let zeros = "";
      if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
        if (prev.count.length > 1) {
          prev.count.pop();
        }
        prev.count.push(obj.count[0]);
        prev.string = prev.pattern + toQuantifier(prev.count);
        start = max2 + 1;
        continue;
      }
      if (tok.isPadded) {
        zeros = padZeros(max2, tok, options);
      }
      obj.string = zeros + obj.pattern + toQuantifier(obj.count);
      tokens.push(obj);
      start = max2 + 1;
      prev = obj;
    }
    return tokens;
  }
  function filterPatterns(arr, comparison, prefix, intersection, options) {
    let result = [];
    for (let ele of arr) {
      let {string} = ele;
      if (!intersection && !contains(comparison, "string", string)) {
        result.push(prefix + string);
      }
      if (intersection && contains(comparison, "string", string)) {
        result.push(prefix + string);
      }
    }
    return result;
  }
  function zip(a, b) {
    let arr = [];
    for (let i = 0; i < a.length; i++)
      arr.push([a[i], b[i]]);
    return arr;
  }
  function compare(a, b) {
    return a > b ? 1 : b > a ? -1 : 0;
  }
  function contains(arr, key, val) {
    return arr.some((ele) => ele[key] === val);
  }
  function countNines(min, len) {
    return Number(String(min).slice(0, -len) + "9".repeat(len));
  }
  function countZeros(integer, zeros) {
    return integer - integer % Math.pow(10, zeros);
  }
  function toQuantifier(digits) {
    let [start = 0, stop = ""] = digits;
    if (stop || start > 1) {
      return `{${start + (stop ? "," + stop : "")}}`;
    }
    return "";
  }
  function toCharacterClass(a, b, options) {
    return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
  }
  function hasPadding(str) {
    return /^-?(0+)\d/.test(str);
  }
  function padZeros(value, tok, options) {
    if (!tok.isPadded) {
      return value;
    }
    let diff = Math.abs(tok.maxLen - String(value).length);
    let relax = options.relaxZeros !== false;
    switch (diff) {
      case 0:
        return "";
      case 1:
        return relax ? "0?" : "0";
      case 2:
        return relax ? "0{0,2}" : "00";
      default: {
        return relax ? `0{0,${diff}}` : `0{${diff}}`;
      }
    }
  }
  toRegexRange.cache = {};
  toRegexRange.clearCache = () => toRegexRange.cache = {};
  module2.exports = toRegexRange;
});

// ../../node_modules/.pnpm/fill-range@7.0.1/node_modules/fill-range/index.js
var require_fill_range = __commonJS((exports2, module2) => {
  /*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  "use strict";
  var util2 = require("util");
  var toRegexRange = require_to_regex_range();
  var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
  var transform = (toNumber) => {
    return (value) => toNumber === true ? Number(value) : String(value);
  };
  var isValidValue = (value) => {
    return typeof value === "number" || typeof value === "string" && value !== "";
  };
  var isNumber = (num) => Number.isInteger(+num);
  var zeros = (input) => {
    let value = `${input}`;
    let index = -1;
    if (value[0] === "-")
      value = value.slice(1);
    if (value === "0")
      return false;
    while (value[++index] === "0")
      ;
    return index > 0;
  };
  var stringify2 = (start, end, options) => {
    if (typeof start === "string" || typeof end === "string") {
      return true;
    }
    return options.stringify === true;
  };
  var pad = (input, maxLength, toNumber) => {
    if (maxLength > 0) {
      let dash = input[0] === "-" ? "-" : "";
      if (dash)
        input = input.slice(1);
      input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
    }
    if (toNumber === false) {
      return String(input);
    }
    return input;
  };
  var toMaxLen = (input, maxLength) => {
    let negative = input[0] === "-" ? "-" : "";
    if (negative) {
      input = input.slice(1);
      maxLength--;
    }
    while (input.length < maxLength)
      input = "0" + input;
    return negative ? "-" + input : input;
  };
  var toSequence = (parts, options) => {
    parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
    parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
    let prefix = options.capture ? "" : "?:";
    let positives = "";
    let negatives = "";
    let result;
    if (parts.positives.length) {
      positives = parts.positives.join("|");
    }
    if (parts.negatives.length) {
      negatives = `-(${prefix}${parts.negatives.join("|")})`;
    }
    if (positives && negatives) {
      result = `${positives}|${negatives}`;
    } else {
      result = positives || negatives;
    }
    if (options.wrap) {
      return `(${prefix}${result})`;
    }
    return result;
  };
  var toRange = (a, b, isNumbers, options) => {
    if (isNumbers) {
      return toRegexRange(a, b, {wrap: false, ...options});
    }
    let start = String.fromCharCode(a);
    if (a === b)
      return start;
    let stop = String.fromCharCode(b);
    return `[${start}-${stop}]`;
  };
  var toRegex = (start, end, options) => {
    if (Array.isArray(start)) {
      let wrap = options.wrap === true;
      let prefix = options.capture ? "" : "?:";
      return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
    }
    return toRegexRange(start, end, options);
  };
  var rangeError = (...args2) => {
    return new RangeError("Invalid range arguments: " + util2.inspect(...args2));
  };
  var invalidRange = (start, end, options) => {
    if (options.strictRanges === true)
      throw rangeError([start, end]);
    return [];
  };
  var invalidStep = (step, options) => {
    if (options.strictRanges === true) {
      throw new TypeError(`Expected step "${step}" to be a number`);
    }
    return [];
  };
  var fillNumbers = (start, end, step = 1, options = {}) => {
    let a = Number(start);
    let b = Number(end);
    if (!Number.isInteger(a) || !Number.isInteger(b)) {
      if (options.strictRanges === true)
        throw rangeError([start, end]);
      return [];
    }
    if (a === 0)
      a = 0;
    if (b === 0)
      b = 0;
    let descending = a > b;
    let startString = String(start);
    let endString = String(end);
    let stepString = String(step);
    step = Math.max(Math.abs(step), 1);
    let padded = zeros(startString) || zeros(endString) || zeros(stepString);
    let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
    let toNumber = padded === false && stringify2(start, end, options) === false;
    let format10 = options.transform || transform(toNumber);
    if (options.toRegex && step === 1) {
      return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
    }
    let parts = {negatives: [], positives: []};
    let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
    let range = [];
    let index = 0;
    while (descending ? a >= b : a <= b) {
      if (options.toRegex === true && step > 1) {
        push(a);
      } else {
        range.push(pad(format10(a, index), maxLen, toNumber));
      }
      a = descending ? a - step : a + step;
      index++;
    }
    if (options.toRegex === true) {
      return step > 1 ? toSequence(parts, options) : toRegex(range, null, {wrap: false, ...options});
    }
    return range;
  };
  var fillLetters = (start, end, step = 1, options = {}) => {
    if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
      return invalidRange(start, end, options);
    }
    let format10 = options.transform || ((val) => String.fromCharCode(val));
    let a = `${start}`.charCodeAt(0);
    let b = `${end}`.charCodeAt(0);
    let descending = a > b;
    let min = Math.min(a, b);
    let max = Math.max(a, b);
    if (options.toRegex && step === 1) {
      return toRange(min, max, false, options);
    }
    let range = [];
    let index = 0;
    while (descending ? a >= b : a <= b) {
      range.push(format10(a, index));
      a = descending ? a - step : a + step;
      index++;
    }
    if (options.toRegex === true) {
      return toRegex(range, null, {wrap: false, options});
    }
    return range;
  };
  var fill = (start, end, step, options = {}) => {
    if (end == null && isValidValue(start)) {
      return [start];
    }
    if (!isValidValue(start) || !isValidValue(end)) {
      return invalidRange(start, end, options);
    }
    if (typeof step === "function") {
      return fill(start, end, 1, {transform: step});
    }
    if (isObject(step)) {
      return fill(start, end, 0, step);
    }
    let opts = {...options};
    if (opts.capture === true)
      opts.wrap = true;
    step = step || opts.step || 1;
    if (!isNumber(step)) {
      if (step != null && !isObject(step))
        return invalidStep(step, opts);
      return fill(start, end, 1, step);
    }
    if (isNumber(start) && isNumber(end)) {
      return fillNumbers(start, end, step, opts);
    }
    return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
  };
  module2.exports = fill;
});

// ../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/compile.js
var require_compile = __commonJS((exports2, module2) => {
  "use strict";
  var fill = require_fill_range();
  var utils = require_utils2();
  var compile = (ast, options = {}) => {
    let walk = (node, parent = {}) => {
      let invalidBlock = utils.isInvalidBrace(parent);
      let invalidNode = node.invalid === true && options.escapeInvalid === true;
      let invalid = invalidBlock === true || invalidNode === true;
      let prefix = options.escapeInvalid === true ? "\\" : "";
      let output = "";
      if (node.isOpen === true) {
        return prefix + node.value;
      }
      if (node.isClose === true) {
        return prefix + node.value;
      }
      if (node.type === "open") {
        return invalid ? prefix + node.value : "(";
      }
      if (node.type === "close") {
        return invalid ? prefix + node.value : ")";
      }
      if (node.type === "comma") {
        return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
      }
      if (node.value) {
        return node.value;
      }
      if (node.nodes && node.ranges > 0) {
        let args2 = utils.reduce(node.nodes);
        let range = fill(...args2, {...options, wrap: false, toRegex: true});
        if (range.length !== 0) {
          return args2.length > 1 && range.length > 1 ? `(${range})` : range;
        }
      }
      if (node.nodes) {
        for (let child of node.nodes) {
          output += walk(child, node);
        }
      }
      return output;
    };
    return walk(ast);
  };
  module2.exports = compile;
});

// ../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/expand.js
var require_expand = __commonJS((exports2, module2) => {
  "use strict";
  var fill = require_fill_range();
  var stringify2 = require_stringify();
  var utils = require_utils2();
  var append = (queue = "", stash = "", enclose = false) => {
    let result = [];
    queue = [].concat(queue);
    stash = [].concat(stash);
    if (!stash.length)
      return queue;
    if (!queue.length) {
      return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
    }
    for (let item of queue) {
      if (Array.isArray(item)) {
        for (let value of item) {
          result.push(append(value, stash, enclose));
        }
      } else {
        for (let ele of stash) {
          if (enclose === true && typeof ele === "string")
            ele = `{${ele}}`;
          result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
        }
      }
    }
    return utils.flatten(result);
  };
  var expand = (ast, options = {}) => {
    let rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
    let walk = (node, parent = {}) => {
      node.queue = [];
      let p = parent;
      let q = parent.queue;
      while (p.type !== "brace" && p.type !== "root" && p.parent) {
        p = p.parent;
        q = p.queue;
      }
      if (node.invalid || node.dollar) {
        q.push(append(q.pop(), stringify2(node, options)));
        return;
      }
      if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
        q.push(append(q.pop(), ["{}"]));
        return;
      }
      if (node.nodes && node.ranges > 0) {
        let args2 = utils.reduce(node.nodes);
        if (utils.exceedsLimit(...args2, options.step, rangeLimit)) {
          throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
        }
        let range = fill(...args2, options);
        if (range.length === 0) {
          range = stringify2(node, options);
        }
        q.push(append(q.pop(), range));
        node.nodes = [];
        return;
      }
      let enclose = utils.encloseBrace(node);
      let queue = node.queue;
      let block = node;
      while (block.type !== "brace" && block.type !== "root" && block.parent) {
        block = block.parent;
        queue = block.queue;
      }
      for (let i = 0; i < node.nodes.length; i++) {
        let child = node.nodes[i];
        if (child.type === "comma" && node.type === "brace") {
          if (i === 1)
            queue.push("");
          queue.push("");
          continue;
        }
        if (child.type === "close") {
          q.push(append(q.pop(), queue, enclose));
          continue;
        }
        if (child.value && child.type !== "open") {
          queue.push(append(queue.pop(), child.value));
          continue;
        }
        if (child.nodes) {
          walk(child, node);
        }
      }
      return queue;
    };
    return utils.flatten(walk(ast));
  };
  module2.exports = expand;
});

// ../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/constants.js
var require_constants = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    MAX_LENGTH: 1024 * 64,
    CHAR_0: "0",
    CHAR_9: "9",
    CHAR_UPPERCASE_A: "A",
    CHAR_LOWERCASE_A: "a",
    CHAR_UPPERCASE_Z: "Z",
    CHAR_LOWERCASE_Z: "z",
    CHAR_LEFT_PARENTHESES: "(",
    CHAR_RIGHT_PARENTHESES: ")",
    CHAR_ASTERISK: "*",
    CHAR_AMPERSAND: "&",
    CHAR_AT: "@",
    CHAR_BACKSLASH: "\\",
    CHAR_BACKTICK: "`",
    CHAR_CARRIAGE_RETURN: "\r",
    CHAR_CIRCUMFLEX_ACCENT: "^",
    CHAR_COLON: ":",
    CHAR_COMMA: ",",
    CHAR_DOLLAR: "$",
    CHAR_DOT: ".",
    CHAR_DOUBLE_QUOTE: '"',
    CHAR_EQUAL: "=",
    CHAR_EXCLAMATION_MARK: "!",
    CHAR_FORM_FEED: "\f",
    CHAR_FORWARD_SLASH: "/",
    CHAR_HASH: "#",
    CHAR_HYPHEN_MINUS: "-",
    CHAR_LEFT_ANGLE_BRACKET: "<",
    CHAR_LEFT_CURLY_BRACE: "{",
    CHAR_LEFT_SQUARE_BRACKET: "[",
    CHAR_LINE_FEED: "\n",
    CHAR_NO_BREAK_SPACE: "\xA0",
    CHAR_PERCENT: "%",
    CHAR_PLUS: "+",
    CHAR_QUESTION_MARK: "?",
    CHAR_RIGHT_ANGLE_BRACKET: ">",
    CHAR_RIGHT_CURLY_BRACE: "}",
    CHAR_RIGHT_SQUARE_BRACKET: "]",
    CHAR_SEMICOLON: ";",
    CHAR_SINGLE_QUOTE: "'",
    CHAR_SPACE: " ",
    CHAR_TAB: "	",
    CHAR_UNDERSCORE: "_",
    CHAR_VERTICAL_LINE: "|",
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
  };
});

// ../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/parse.js
var require_parse3 = __commonJS((exports2, module2) => {
  "use strict";
  var stringify2 = require_stringify();
  var {
    MAX_LENGTH,
    CHAR_BACKSLASH,
    CHAR_BACKTICK,
    CHAR_COMMA,
    CHAR_DOT,
    CHAR_LEFT_PARENTHESES,
    CHAR_RIGHT_PARENTHESES,
    CHAR_LEFT_CURLY_BRACE,
    CHAR_RIGHT_CURLY_BRACE,
    CHAR_LEFT_SQUARE_BRACKET,
    CHAR_RIGHT_SQUARE_BRACKET,
    CHAR_DOUBLE_QUOTE,
    CHAR_SINGLE_QUOTE,
    CHAR_NO_BREAK_SPACE,
    CHAR_ZERO_WIDTH_NOBREAK_SPACE
  } = require_constants();
  var parse2 = (input, options = {}) => {
    if (typeof input !== "string") {
      throw new TypeError("Expected a string");
    }
    let opts = options || {};
    let max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    if (input.length > max) {
      throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
    }
    let ast = {type: "root", input, nodes: []};
    let stack = [ast];
    let block = ast;
    let prev = ast;
    let brackets = 0;
    let length = input.length;
    let index = 0;
    let depth = 0;
    let value;
    let memo = {};
    const advance = () => input[index++];
    const push = (node) => {
      if (node.type === "text" && prev.type === "dot") {
        prev.type = "text";
      }
      if (prev && prev.type === "text" && node.type === "text") {
        prev.value += node.value;
        return;
      }
      block.nodes.push(node);
      node.parent = block;
      node.prev = prev;
      prev = node;
      return node;
    };
    push({type: "bos"});
    while (index < length) {
      block = stack[stack.length - 1];
      value = advance();
      if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
        continue;
      }
      if (value === CHAR_BACKSLASH) {
        push({type: "text", value: (options.keepEscaping ? value : "") + advance()});
        continue;
      }
      if (value === CHAR_RIGHT_SQUARE_BRACKET) {
        push({type: "text", value: "\\" + value});
        continue;
      }
      if (value === CHAR_LEFT_SQUARE_BRACKET) {
        brackets++;
        let closed = true;
        let next;
        while (index < length && (next = advance())) {
          value += next;
          if (next === CHAR_LEFT_SQUARE_BRACKET) {
            brackets++;
            continue;
          }
          if (next === CHAR_BACKSLASH) {
            value += advance();
            continue;
          }
          if (next === CHAR_RIGHT_SQUARE_BRACKET) {
            brackets--;
            if (brackets === 0) {
              break;
            }
          }
        }
        push({type: "text", value});
        continue;
      }
      if (value === CHAR_LEFT_PARENTHESES) {
        block = push({type: "paren", nodes: []});
        stack.push(block);
        push({type: "text", value});
        continue;
      }
      if (value === CHAR_RIGHT_PARENTHESES) {
        if (block.type !== "paren") {
          push({type: "text", value});
          continue;
        }
        block = stack.pop();
        push({type: "text", value});
        block = stack[stack.length - 1];
        continue;
      }
      if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
        let open3 = value;
        let next;
        if (options.keepQuotes !== true) {
          value = "";
        }
        while (index < length && (next = advance())) {
          if (next === CHAR_BACKSLASH) {
            value += next + advance();
            continue;
          }
          if (next === open3) {
            if (options.keepQuotes === true)
              value += next;
            break;
          }
          value += next;
        }
        push({type: "text", value});
        continue;
      }
      if (value === CHAR_LEFT_CURLY_BRACE) {
        depth++;
        let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
        let brace = {
          type: "brace",
          open: true,
          close: false,
          dollar,
          depth,
          commas: 0,
          ranges: 0,
          nodes: []
        };
        block = push(brace);
        stack.push(block);
        push({type: "open", value});
        continue;
      }
      if (value === CHAR_RIGHT_CURLY_BRACE) {
        if (block.type !== "brace") {
          push({type: "text", value});
          continue;
        }
        let type = "close";
        block = stack.pop();
        block.close = true;
        push({type, value});
        depth--;
        block = stack[stack.length - 1];
        continue;
      }
      if (value === CHAR_COMMA && depth > 0) {
        if (block.ranges > 0) {
          block.ranges = 0;
          let open3 = block.nodes.shift();
          block.nodes = [open3, {type: "text", value: stringify2(block)}];
        }
        push({type: "comma", value});
        block.commas++;
        continue;
      }
      if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
        let siblings = block.nodes;
        if (depth === 0 || siblings.length === 0) {
          push({type: "text", value});
          continue;
        }
        if (prev.type === "dot") {
          block.range = [];
          prev.value += value;
          prev.type = "range";
          if (block.nodes.length !== 3 && block.nodes.length !== 5) {
            block.invalid = true;
            block.ranges = 0;
            prev.type = "text";
            continue;
          }
          block.ranges++;
          block.args = [];
          continue;
        }
        if (prev.type === "range") {
          siblings.pop();
          let before = siblings[siblings.length - 1];
          before.value += prev.value + value;
          prev = before;
          block.ranges--;
          continue;
        }
        push({type: "dot", value});
        continue;
      }
      push({type: "text", value});
    }
    do {
      block = stack.pop();
      if (block.type !== "root") {
        block.nodes.forEach((node) => {
          if (!node.nodes) {
            if (node.type === "open")
              node.isOpen = true;
            if (node.type === "close")
              node.isClose = true;
            if (!node.nodes)
              node.type = "text";
            node.invalid = true;
          }
        });
        let parent = stack[stack.length - 1];
        let index2 = parent.nodes.indexOf(block);
        parent.nodes.splice(index2, 1, ...block.nodes);
      }
    } while (stack.length > 0);
    push({type: "eos"});
    return ast;
  };
  module2.exports = parse2;
});

// ../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/index.js
var require_braces = __commonJS((exports2, module2) => {
  "use strict";
  var stringify2 = require_stringify();
  var compile = require_compile();
  var expand = require_expand();
  var parse2 = require_parse3();
  var braces = (input, options = {}) => {
    let output = [];
    if (Array.isArray(input)) {
      for (let pattern of input) {
        let result = braces.create(pattern, options);
        if (Array.isArray(result)) {
          output.push(...result);
        } else {
          output.push(result);
        }
      }
    } else {
      output = [].concat(braces.create(input, options));
    }
    if (options && options.expand === true && options.nodupes === true) {
      output = [...new Set(output)];
    }
    return output;
  };
  braces.parse = (input, options = {}) => parse2(input, options);
  braces.stringify = (input, options = {}) => {
    if (typeof input === "string") {
      return stringify2(braces.parse(input, options), options);
    }
    return stringify2(input, options);
  };
  braces.compile = (input, options = {}) => {
    if (typeof input === "string") {
      input = braces.parse(input, options);
    }
    return compile(input, options);
  };
  braces.expand = (input, options = {}) => {
    if (typeof input === "string") {
      input = braces.parse(input, options);
    }
    let result = expand(input, options);
    if (options.noempty === true) {
      result = result.filter(Boolean);
    }
    if (options.nodupes === true) {
      result = [...new Set(result)];
    }
    return result;
  };
  braces.create = (input, options = {}) => {
    if (input === "" || input.length < 3) {
      return [input];
    }
    return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
  };
  module2.exports = braces;
});

// ../../node_modules/.pnpm/picomatch@2.3.0/node_modules/picomatch/lib/constants.js
var require_constants2 = __commonJS((exports2, module2) => {
  "use strict";
  var path10 = require("path");
  var WIN_SLASH = "\\\\/";
  var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
  var DOT_LITERAL = "\\.";
  var PLUS_LITERAL = "\\+";
  var QMARK_LITERAL = "\\?";
  var SLASH_LITERAL = "\\/";
  var ONE_CHAR = "(?=.)";
  var QMARK = "[^/]";
  var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
  var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
  var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
  var NO_DOT = `(?!${DOT_LITERAL})`;
  var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
  var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
  var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
  var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
  var STAR = `${QMARK}*?`;
  var POSIX_CHARS = {
    DOT_LITERAL,
    PLUS_LITERAL,
    QMARK_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    QMARK,
    END_ANCHOR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOTS,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR
  };
  var WINDOWS_CHARS = {
    ...POSIX_CHARS,
    SLASH_LITERAL: `[${WIN_SLASH}]`,
    QMARK: WIN_NO_SLASH,
    STAR: `${WIN_NO_SLASH}*?`,
    DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
    NO_DOT: `(?!${DOT_LITERAL})`,
    NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
    NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
    NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
    QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
    START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
    END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
  };
  var POSIX_REGEX_SOURCE = {
    alnum: "a-zA-Z0-9",
    alpha: "a-zA-Z",
    ascii: "\\x00-\\x7F",
    blank: " \\t",
    cntrl: "\\x00-\\x1F\\x7F",
    digit: "0-9",
    graph: "\\x21-\\x7E",
    lower: "a-z",
    print: "\\x20-\\x7E ",
    punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
    space: " \\t\\r\\n\\v\\f",
    upper: "A-Z",
    word: "A-Za-z0-9_",
    xdigit: "A-Fa-f0-9"
  };
  module2.exports = {
    MAX_LENGTH: 1024 * 64,
    POSIX_REGEX_SOURCE,
    REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
    REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
    REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
    REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
    REPLACEMENTS: {
      "***": "*",
      "**/**": "**",
      "**/**/**": "**"
    },
    CHAR_0: 48,
    CHAR_9: 57,
    CHAR_UPPERCASE_A: 65,
    CHAR_LOWERCASE_A: 97,
    CHAR_UPPERCASE_Z: 90,
    CHAR_LOWERCASE_Z: 122,
    CHAR_LEFT_PARENTHESES: 40,
    CHAR_RIGHT_PARENTHESES: 41,
    CHAR_ASTERISK: 42,
    CHAR_AMPERSAND: 38,
    CHAR_AT: 64,
    CHAR_BACKWARD_SLASH: 92,
    CHAR_CARRIAGE_RETURN: 13,
    CHAR_CIRCUMFLEX_ACCENT: 94,
    CHAR_COLON: 58,
    CHAR_COMMA: 44,
    CHAR_DOT: 46,
    CHAR_DOUBLE_QUOTE: 34,
    CHAR_EQUAL: 61,
    CHAR_EXCLAMATION_MARK: 33,
    CHAR_FORM_FEED: 12,
    CHAR_FORWARD_SLASH: 47,
    CHAR_GRAVE_ACCENT: 96,
    CHAR_HASH: 35,
    CHAR_HYPHEN_MINUS: 45,
    CHAR_LEFT_ANGLE_BRACKET: 60,
    CHAR_LEFT_CURLY_BRACE: 123,
    CHAR_LEFT_SQUARE_BRACKET: 91,
    CHAR_LINE_FEED: 10,
    CHAR_NO_BREAK_SPACE: 160,
    CHAR_PERCENT: 37,
    CHAR_PLUS: 43,
    CHAR_QUESTION_MARK: 63,
    CHAR_RIGHT_ANGLE_BRACKET: 62,
    CHAR_RIGHT_CURLY_BRACE: 125,
    CHAR_RIGHT_SQUARE_BRACKET: 93,
    CHAR_SEMICOLON: 59,
    CHAR_SINGLE_QUOTE: 39,
    CHAR_SPACE: 32,
    CHAR_TAB: 9,
    CHAR_UNDERSCORE: 95,
    CHAR_VERTICAL_LINE: 124,
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
    SEP: path10.sep,
    extglobChars(chars) {
      return {
        "!": {type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})`},
        "?": {type: "qmark", open: "(?:", close: ")?"},
        "+": {type: "plus", open: "(?:", close: ")+"},
        "*": {type: "star", open: "(?:", close: ")*"},
        "@": {type: "at", open: "(?:", close: ")"}
      };
    },
    globChars(win32) {
      return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
    }
  };
});

// ../../node_modules/.pnpm/picomatch@2.3.0/node_modules/picomatch/lib/utils.js
var require_utils3 = __commonJS((exports2) => {
  "use strict";
  var path10 = require("path");
  var win32 = process.platform === "win32";
  var {
    REGEX_BACKSLASH,
    REGEX_REMOVE_BACKSLASH,
    REGEX_SPECIAL_CHARS,
    REGEX_SPECIAL_CHARS_GLOBAL
  } = require_constants2();
  exports2.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
  exports2.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
  exports2.isRegexChar = (str) => str.length === 1 && exports2.hasRegexChars(str);
  exports2.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
  exports2.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
  exports2.removeBackslashes = (str) => {
    return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
      return match === "\\" ? "" : match;
    });
  };
  exports2.supportsLookbehinds = () => {
    const segs = process.version.slice(1).split(".").map(Number);
    if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
      return true;
    }
    return false;
  };
  exports2.isWindows = (options) => {
    if (options && typeof options.windows === "boolean") {
      return options.windows;
    }
    return win32 === true || path10.sep === "\\";
  };
  exports2.escapeLast = (input, char, lastIdx) => {
    const idx = input.lastIndexOf(char, lastIdx);
    if (idx === -1)
      return input;
    if (input[idx - 1] === "\\")
      return exports2.escapeLast(input, char, idx - 1);
    return `${input.slice(0, idx)}\\${input.slice(idx)}`;
  };
  exports2.removePrefix = (input, state = {}) => {
    let output = input;
    if (output.startsWith("./")) {
      output = output.slice(2);
      state.prefix = "./";
    }
    return output;
  };
  exports2.wrapOutput = (input, state = {}, options = {}) => {
    const prepend = options.contains ? "" : "^";
    const append = options.contains ? "" : "$";
    let output = `${prepend}(?:${input})${append}`;
    if (state.negated === true) {
      output = `(?:^(?!${output}).*$)`;
    }
    return output;
  };
});

// ../../node_modules/.pnpm/picomatch@2.3.0/node_modules/picomatch/lib/scan.js
var require_scan2 = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils3();
  var {
    CHAR_ASTERISK,
    CHAR_AT,
    CHAR_BACKWARD_SLASH,
    CHAR_COMMA,
    CHAR_DOT,
    CHAR_EXCLAMATION_MARK,
    CHAR_FORWARD_SLASH,
    CHAR_LEFT_CURLY_BRACE,
    CHAR_LEFT_PARENTHESES,
    CHAR_LEFT_SQUARE_BRACKET,
    CHAR_PLUS,
    CHAR_QUESTION_MARK,
    CHAR_RIGHT_CURLY_BRACE,
    CHAR_RIGHT_PARENTHESES,
    CHAR_RIGHT_SQUARE_BRACKET
  } = require_constants2();
  var isPathSeparator = (code) => {
    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
  };
  var depth = (token) => {
    if (token.isPrefix !== true) {
      token.depth = token.isGlobstar ? Infinity : 1;
    }
  };
  var scan = (input, options) => {
    const opts = options || {};
    const length = input.length - 1;
    const scanToEnd = opts.parts === true || opts.scanToEnd === true;
    const slashes = [];
    const tokens = [];
    const parts = [];
    let str = input;
    let index = -1;
    let start = 0;
    let lastIndex = 0;
    let isBrace = false;
    let isBracket = false;
    let isGlob = false;
    let isExtglob = false;
    let isGlobstar = false;
    let braceEscaped = false;
    let backslashes = false;
    let negated = false;
    let negatedExtglob = false;
    let finished = false;
    let braces = 0;
    let prev;
    let code;
    let token = {value: "", depth: 0, isGlob: false};
    const eos = () => index >= length;
    const peek = () => str.charCodeAt(index + 1);
    const advance = () => {
      prev = code;
      return str.charCodeAt(++index);
    };
    while (index < length) {
      code = advance();
      let next;
      if (code === CHAR_BACKWARD_SLASH) {
        backslashes = token.backslashes = true;
        code = advance();
        if (code === CHAR_LEFT_CURLY_BRACE) {
          braceEscaped = true;
        }
        continue;
      }
      if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
        braces++;
        while (eos() !== true && (code = advance())) {
          if (code === CHAR_BACKWARD_SLASH) {
            backslashes = token.backslashes = true;
            advance();
            continue;
          }
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braces++;
            continue;
          }
          if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
            isBrace = token.isBrace = true;
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (braceEscaped !== true && code === CHAR_COMMA) {
            isBrace = token.isBrace = true;
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (code === CHAR_RIGHT_CURLY_BRACE) {
            braces--;
            if (braces === 0) {
              braceEscaped = false;
              isBrace = token.isBrace = true;
              finished = true;
              break;
            }
          }
        }
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
      if (code === CHAR_FORWARD_SLASH) {
        slashes.push(index);
        tokens.push(token);
        token = {value: "", depth: 0, isGlob: false};
        if (finished === true)
          continue;
        if (prev === CHAR_DOT && index === start + 1) {
          start += 2;
          continue;
        }
        lastIndex = index + 1;
        continue;
      }
      if (opts.noext !== true) {
        const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
        if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          isExtglob = token.isExtglob = true;
          finished = true;
          if (code === CHAR_EXCLAMATION_MARK && index === start) {
            negatedExtglob = true;
          }
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_BACKWARD_SLASH) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                isGlob = token.isGlob = true;
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
      }
      if (code === CHAR_ASTERISK) {
        if (prev === CHAR_ASTERISK)
          isGlobstar = token.isGlobstar = true;
        isGlob = token.isGlob = true;
        finished = true;
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
      if (code === CHAR_QUESTION_MARK) {
        isGlob = token.isGlob = true;
        finished = true;
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
      if (code === CHAR_LEFT_SQUARE_BRACKET) {
        while (eos() !== true && (next = advance())) {
          if (next === CHAR_BACKWARD_SLASH) {
            backslashes = token.backslashes = true;
            advance();
            continue;
          }
          if (next === CHAR_RIGHT_SQUARE_BRACKET) {
            isBracket = token.isBracket = true;
            isGlob = token.isGlob = true;
            finished = true;
            break;
          }
        }
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
      if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
        negated = token.negated = true;
        start++;
        continue;
      }
      if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
        isGlob = token.isGlob = true;
        if (scanToEnd === true) {
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_LEFT_PARENTHESES) {
              backslashes = token.backslashes = true;
              code = advance();
              continue;
            }
            if (code === CHAR_RIGHT_PARENTHESES) {
              finished = true;
              break;
            }
          }
          continue;
        }
        break;
      }
      if (isGlob === true) {
        finished = true;
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
    }
    if (opts.noext === true) {
      isExtglob = false;
      isGlob = false;
    }
    let base = str;
    let prefix = "";
    let glob = "";
    if (start > 0) {
      prefix = str.slice(0, start);
      str = str.slice(start);
      lastIndex -= start;
    }
    if (base && isGlob === true && lastIndex > 0) {
      base = str.slice(0, lastIndex);
      glob = str.slice(lastIndex);
    } else if (isGlob === true) {
      base = "";
      glob = str;
    } else {
      base = str;
    }
    if (base && base !== "" && base !== "/" && base !== str) {
      if (isPathSeparator(base.charCodeAt(base.length - 1))) {
        base = base.slice(0, -1);
      }
    }
    if (opts.unescape === true) {
      if (glob)
        glob = utils.removeBackslashes(glob);
      if (base && backslashes === true) {
        base = utils.removeBackslashes(base);
      }
    }
    const state = {
      prefix,
      input,
      start,
      base,
      glob,
      isBrace,
      isBracket,
      isGlob,
      isExtglob,
      isGlobstar,
      negated,
      negatedExtglob
    };
    if (opts.tokens === true) {
      state.maxDepth = 0;
      if (!isPathSeparator(code)) {
        tokens.push(token);
      }
      state.tokens = tokens;
    }
    if (opts.parts === true || opts.tokens === true) {
      let prevIndex;
      for (let idx = 0; idx < slashes.length; idx++) {
        const n = prevIndex ? prevIndex + 1 : start;
        const i = slashes[idx];
        const value = input.slice(n, i);
        if (opts.tokens) {
          if (idx === 0 && start !== 0) {
            tokens[idx].isPrefix = true;
            tokens[idx].value = prefix;
          } else {
            tokens[idx].value = value;
          }
          depth(tokens[idx]);
          state.maxDepth += tokens[idx].depth;
        }
        if (idx !== 0 || value !== "") {
          parts.push(value);
        }
        prevIndex = i;
      }
      if (prevIndex && prevIndex + 1 < input.length) {
        const value = input.slice(prevIndex + 1);
        parts.push(value);
        if (opts.tokens) {
          tokens[tokens.length - 1].value = value;
          depth(tokens[tokens.length - 1]);
          state.maxDepth += tokens[tokens.length - 1].depth;
        }
      }
      state.slashes = slashes;
      state.parts = parts;
    }
    return state;
  };
  module2.exports = scan;
});

// ../../node_modules/.pnpm/picomatch@2.3.0/node_modules/picomatch/lib/parse.js
var require_parse4 = __commonJS((exports2, module2) => {
  "use strict";
  var constants = require_constants2();
  var utils = require_utils3();
  var {
    MAX_LENGTH,
    POSIX_REGEX_SOURCE,
    REGEX_NON_SPECIAL_CHARS,
    REGEX_SPECIAL_CHARS_BACKREF,
    REPLACEMENTS
  } = constants;
  var expandRange = (args2, options) => {
    if (typeof options.expandRange === "function") {
      return options.expandRange(...args2, options);
    }
    args2.sort();
    const value = `[${args2.join("-")}]`;
    try {
      new RegExp(value);
    } catch (ex) {
      return args2.map((v) => utils.escapeRegex(v)).join("..");
    }
    return value;
  };
  var syntaxError = (type, char) => {
    return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
  };
  var parse2 = (input, options) => {
    if (typeof input !== "string") {
      throw new TypeError("Expected a string");
    }
    input = REPLACEMENTS[input] || input;
    const opts = {...options};
    const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    let len = input.length;
    if (len > max) {
      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
    }
    const bos = {type: "bos", value: "", output: opts.prepend || ""};
    const tokens = [bos];
    const capture = opts.capture ? "" : "?:";
    const win32 = utils.isWindows(options);
    const PLATFORM_CHARS = constants.globChars(win32);
    const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
    const {
      DOT_LITERAL,
      PLUS_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    } = PLATFORM_CHARS;
    const globstar = (opts2) => {
      return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };
    const nodot = opts.dot ? "" : NO_DOT;
    const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
    let star = opts.bash === true ? globstar(opts) : STAR;
    if (opts.capture) {
      star = `(${star})`;
    }
    if (typeof opts.noext === "boolean") {
      opts.noextglob = opts.noext;
    }
    const state = {
      input,
      index: -1,
      start: 0,
      dot: opts.dot === true,
      consumed: "",
      output: "",
      prefix: "",
      backtrack: false,
      negated: false,
      brackets: 0,
      braces: 0,
      parens: 0,
      quotes: 0,
      globstar: false,
      tokens
    };
    input = utils.removePrefix(input, state);
    len = input.length;
    const extglobs = [];
    const braces = [];
    const stack = [];
    let prev = bos;
    let value;
    const eos = () => state.index === len - 1;
    const peek = state.peek = (n = 1) => input[state.index + n];
    const advance = state.advance = () => input[++state.index] || "";
    const remaining = () => input.slice(state.index + 1);
    const consume = (value2 = "", num = 0) => {
      state.consumed += value2;
      state.index += num;
    };
    const append = (token) => {
      state.output += token.output != null ? token.output : token.value;
      consume(token.value);
    };
    const negate = () => {
      let count = 1;
      while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
        advance();
        state.start++;
        count++;
      }
      if (count % 2 === 0) {
        return false;
      }
      state.negated = true;
      state.start++;
      return true;
    };
    const increment = (type) => {
      state[type]++;
      stack.push(type);
    };
    const decrement = (type) => {
      state[type]--;
      stack.pop();
    };
    const push = (tok) => {
      if (prev.type === "globstar") {
        const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
        const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
        if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "star";
          prev.value = "*";
          prev.output = star;
          state.output += prev.output;
        }
      }
      if (extglobs.length && tok.type !== "paren") {
        extglobs[extglobs.length - 1].inner += tok.value;
      }
      if (tok.value || tok.output)
        append(tok);
      if (prev && prev.type === "text" && tok.type === "text") {
        prev.value += tok.value;
        prev.output = (prev.output || "") + tok.value;
        return;
      }
      tok.prev = prev;
      tokens.push(tok);
      prev = tok;
    };
    const extglobOpen = (type, value2) => {
      const token = {...EXTGLOB_CHARS[value2], conditions: 1, inner: ""};
      token.prev = prev;
      token.parens = state.parens;
      token.output = state.output;
      const output = (opts.capture ? "(" : "") + token.open;
      increment("parens");
      push({type, value: value2, output: state.output ? "" : ONE_CHAR});
      push({type: "paren", extglob: true, value: advance(), output});
      extglobs.push(token);
    };
    const extglobClose = (token) => {
      let output = token.close + (opts.capture ? ")" : "");
      let rest;
      if (token.type === "negate") {
        let extglobStar = star;
        if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
          extglobStar = globstar(opts);
        }
        if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
          output = token.close = `)$))${extglobStar}`;
        }
        if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
          output = token.close = `)${rest})${extglobStar})`;
        }
        if (token.prev.type === "bos") {
          state.negatedExtglob = true;
        }
      }
      push({type: "paren", extglob: true, value, output});
      decrement("parens");
    };
    if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
      let backslashes = false;
      let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m2, esc, chars, first, rest, index) => {
        if (first === "\\") {
          backslashes = true;
          return m2;
        }
        if (first === "?") {
          if (esc) {
            return esc + first + (rest ? QMARK.repeat(rest.length) : "");
          }
          if (index === 0) {
            return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
          }
          return QMARK.repeat(chars.length);
        }
        if (first === ".") {
          return DOT_LITERAL.repeat(chars.length);
        }
        if (first === "*") {
          if (esc) {
            return esc + first + (rest ? star : "");
          }
          return star;
        }
        return esc ? m2 : `\\${m2}`;
      });
      if (backslashes === true) {
        if (opts.unescape === true) {
          output = output.replace(/\\/g, "");
        } else {
          output = output.replace(/\\+/g, (m2) => {
            return m2.length % 2 === 0 ? "\\\\" : m2 ? "\\" : "";
          });
        }
      }
      if (output === input && opts.contains === true) {
        state.output = input;
        return state;
      }
      state.output = utils.wrapOutput(output, state, options);
      return state;
    }
    while (!eos()) {
      value = advance();
      if (value === "\0") {
        continue;
      }
      if (value === "\\") {
        const next = peek();
        if (next === "/" && opts.bash !== true) {
          continue;
        }
        if (next === "." || next === ";") {
          continue;
        }
        if (!next) {
          value += "\\";
          push({type: "text", value});
          continue;
        }
        const match = /^\\+/.exec(remaining());
        let slashes = 0;
        if (match && match[0].length > 2) {
          slashes = match[0].length;
          state.index += slashes;
          if (slashes % 2 !== 0) {
            value += "\\";
          }
        }
        if (opts.unescape === true) {
          value = advance();
        } else {
          value += advance();
        }
        if (state.brackets === 0) {
          push({type: "text", value});
          continue;
        }
      }
      if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
        if (opts.posix !== false && value === ":") {
          const inner = prev.value.slice(1);
          if (inner.includes("[")) {
            prev.posix = true;
            if (inner.includes(":")) {
              const idx = prev.value.lastIndexOf("[");
              const pre = prev.value.slice(0, idx);
              const rest2 = prev.value.slice(idx + 2);
              const posix = POSIX_REGEX_SOURCE[rest2];
              if (posix) {
                prev.value = pre + posix;
                state.backtrack = true;
                advance();
                if (!bos.output && tokens.indexOf(prev) === 1) {
                  bos.output = ONE_CHAR;
                }
                continue;
              }
            }
          }
        }
        if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
          value = `\\${value}`;
        }
        if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
          value = `\\${value}`;
        }
        if (opts.posix === true && value === "!" && prev.value === "[") {
          value = "^";
        }
        prev.value += value;
        append({value});
        continue;
      }
      if (state.quotes === 1 && value !== '"') {
        value = utils.escapeRegex(value);
        prev.value += value;
        append({value});
        continue;
      }
      if (value === '"') {
        state.quotes = state.quotes === 1 ? 0 : 1;
        if (opts.keepQuotes === true) {
          push({type: "text", value});
        }
        continue;
      }
      if (value === "(") {
        increment("parens");
        push({type: "paren", value});
        continue;
      }
      if (value === ")") {
        if (state.parens === 0 && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError("opening", "("));
        }
        const extglob = extglobs[extglobs.length - 1];
        if (extglob && state.parens === extglob.parens + 1) {
          extglobClose(extglobs.pop());
          continue;
        }
        push({type: "paren", value, output: state.parens ? ")" : "\\)"});
        decrement("parens");
        continue;
      }
      if (value === "[") {
        if (opts.nobracket === true || !remaining().includes("]")) {
          if (opts.nobracket !== true && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("closing", "]"));
          }
          value = `\\${value}`;
        } else {
          increment("brackets");
        }
        push({type: "bracket", value});
        continue;
      }
      if (value === "]") {
        if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
          push({type: "text", value, output: `\\${value}`});
          continue;
        }
        if (state.brackets === 0) {
          if (opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "["));
          }
          push({type: "text", value, output: `\\${value}`});
          continue;
        }
        decrement("brackets");
        const prevValue = prev.value.slice(1);
        if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
          value = `/${value}`;
        }
        prev.value += value;
        append({value});
        if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
          continue;
        }
        const escaped = utils.escapeRegex(prev.value);
        state.output = state.output.slice(0, -prev.value.length);
        if (opts.literalBrackets === true) {
          state.output += escaped;
          prev.value = escaped;
          continue;
        }
        prev.value = `(${capture}${escaped}|${prev.value})`;
        state.output += prev.value;
        continue;
      }
      if (value === "{" && opts.nobrace !== true) {
        increment("braces");
        const open3 = {
          type: "brace",
          value,
          output: "(",
          outputIndex: state.output.length,
          tokensIndex: state.tokens.length
        };
        braces.push(open3);
        push(open3);
        continue;
      }
      if (value === "}") {
        const brace = braces[braces.length - 1];
        if (opts.nobrace === true || !brace) {
          push({type: "text", value, output: value});
          continue;
        }
        let output = ")";
        if (brace.dots === true) {
          const arr = tokens.slice();
          const range = [];
          for (let i = arr.length - 1; i >= 0; i--) {
            tokens.pop();
            if (arr[i].type === "brace") {
              break;
            }
            if (arr[i].type !== "dots") {
              range.unshift(arr[i].value);
            }
          }
          output = expandRange(range, opts);
          state.backtrack = true;
        }
        if (brace.comma !== true && brace.dots !== true) {
          const out = state.output.slice(0, brace.outputIndex);
          const toks = state.tokens.slice(brace.tokensIndex);
          brace.value = brace.output = "\\{";
          value = output = "\\}";
          state.output = out;
          for (const t of toks) {
            state.output += t.output || t.value;
          }
        }
        push({type: "brace", value, output});
        decrement("braces");
        braces.pop();
        continue;
      }
      if (value === "|") {
        if (extglobs.length > 0) {
          extglobs[extglobs.length - 1].conditions++;
        }
        push({type: "text", value});
        continue;
      }
      if (value === ",") {
        let output = value;
        const brace = braces[braces.length - 1];
        if (brace && stack[stack.length - 1] === "braces") {
          brace.comma = true;
          output = "|";
        }
        push({type: "comma", value, output});
        continue;
      }
      if (value === "/") {
        if (prev.type === "dot" && state.index === state.start + 1) {
          state.start = state.index + 1;
          state.consumed = "";
          state.output = "";
          tokens.pop();
          prev = bos;
          continue;
        }
        push({type: "slash", value, output: SLASH_LITERAL});
        continue;
      }
      if (value === ".") {
        if (state.braces > 0 && prev.type === "dot") {
          if (prev.value === ".")
            prev.output = DOT_LITERAL;
          const brace = braces[braces.length - 1];
          prev.type = "dots";
          prev.output += value;
          prev.value += value;
          brace.dots = true;
          continue;
        }
        if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
          push({type: "text", value, output: DOT_LITERAL});
          continue;
        }
        push({type: "dot", value, output: DOT_LITERAL});
        continue;
      }
      if (value === "?") {
        const isGroup = prev && prev.value === "(";
        if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
          extglobOpen("qmark", value);
          continue;
        }
        if (prev && prev.type === "paren") {
          const next = peek();
          let output = value;
          if (next === "<" && !utils.supportsLookbehinds()) {
            throw new Error("Node.js v10 or higher is required for regex lookbehinds");
          }
          if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
            output = `\\${value}`;
          }
          push({type: "text", value, output});
          continue;
        }
        if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
          push({type: "qmark", value, output: QMARK_NO_DOT});
          continue;
        }
        push({type: "qmark", value, output: QMARK});
        continue;
      }
      if (value === "!") {
        if (opts.noextglob !== true && peek() === "(") {
          if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
            extglobOpen("negate", value);
            continue;
          }
        }
        if (opts.nonegate !== true && state.index === 0) {
          negate();
          continue;
        }
      }
      if (value === "+") {
        if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
          extglobOpen("plus", value);
          continue;
        }
        if (prev && prev.value === "(" || opts.regex === false) {
          push({type: "plus", value, output: PLUS_LITERAL});
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
          push({type: "plus", value});
          continue;
        }
        push({type: "plus", value: PLUS_LITERAL});
        continue;
      }
      if (value === "@") {
        if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
          push({type: "at", extglob: true, value, output: ""});
          continue;
        }
        push({type: "text", value});
        continue;
      }
      if (value !== "*") {
        if (value === "$" || value === "^") {
          value = `\\${value}`;
        }
        const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
        if (match) {
          value += match[0];
          state.index += match[0].length;
        }
        push({type: "text", value});
        continue;
      }
      if (prev && (prev.type === "globstar" || prev.star === true)) {
        prev.type = "star";
        prev.star = true;
        prev.value += value;
        prev.output = star;
        state.backtrack = true;
        state.globstar = true;
        consume(value);
        continue;
      }
      let rest = remaining();
      if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
        extglobOpen("star", value);
        continue;
      }
      if (prev.type === "star") {
        if (opts.noglobstar === true) {
          consume(value);
          continue;
        }
        const prior = prev.prev;
        const before = prior.prev;
        const isStart = prior.type === "slash" || prior.type === "bos";
        const afterStar = before && (before.type === "star" || before.type === "globstar");
        if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
          push({type: "star", value, output: ""});
          continue;
        }
        const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
        const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
        if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
          push({type: "star", value, output: ""});
          continue;
        }
        while (rest.slice(0, 3) === "/**") {
          const after = input[state.index + 4];
          if (after && after !== "/") {
            break;
          }
          rest = rest.slice(3);
          consume("/**", 3);
        }
        if (prior.type === "bos" && eos()) {
          prev.type = "globstar";
          prev.value += value;
          prev.output = globstar(opts);
          state.output = prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
          state.output = state.output.slice(0, -(prior.output + prev.output).length);
          prior.output = `(?:${prior.output}`;
          prev.type = "globstar";
          prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
          prev.value += value;
          state.globstar = true;
          state.output += prior.output + prev.output;
          consume(value);
          continue;
        }
        if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
          const end = rest[1] !== void 0 ? "|$" : "";
          state.output = state.output.slice(0, -(prior.output + prev.output).length);
          prior.output = `(?:${prior.output}`;
          prev.type = "globstar";
          prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
          prev.value += value;
          state.output += prior.output + prev.output;
          state.globstar = true;
          consume(value + advance());
          push({type: "slash", value: "/", output: ""});
          continue;
        }
        if (prior.type === "bos" && rest[0] === "/") {
          prev.type = "globstar";
          prev.value += value;
          prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
          state.output = prev.output;
          state.globstar = true;
          consume(value + advance());
          push({type: "slash", value: "/", output: ""});
          continue;
        }
        state.output = state.output.slice(0, -prev.output.length);
        prev.type = "globstar";
        prev.output = globstar(opts);
        prev.value += value;
        state.output += prev.output;
        state.globstar = true;
        consume(value);
        continue;
      }
      const token = {type: "star", value, output: star};
      if (opts.bash === true) {
        token.output = ".*?";
        if (prev.type === "bos" || prev.type === "slash") {
          token.output = nodot + token.output;
        }
        push(token);
        continue;
      }
      if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
        token.output = value;
        push(token);
        continue;
      }
      if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
        if (prev.type === "dot") {
          state.output += NO_DOT_SLASH;
          prev.output += NO_DOT_SLASH;
        } else if (opts.dot === true) {
          state.output += NO_DOTS_SLASH;
          prev.output += NO_DOTS_SLASH;
        } else {
          state.output += nodot;
          prev.output += nodot;
        }
        if (peek() !== "*") {
          state.output += ONE_CHAR;
          prev.output += ONE_CHAR;
        }
      }
      push(token);
    }
    while (state.brackets > 0) {
      if (opts.strictBrackets === true)
        throw new SyntaxError(syntaxError("closing", "]"));
      state.output = utils.escapeLast(state.output, "[");
      decrement("brackets");
    }
    while (state.parens > 0) {
      if (opts.strictBrackets === true)
        throw new SyntaxError(syntaxError("closing", ")"));
      state.output = utils.escapeLast(state.output, "(");
      decrement("parens");
    }
    while (state.braces > 0) {
      if (opts.strictBrackets === true)
        throw new SyntaxError(syntaxError("closing", "}"));
      state.output = utils.escapeLast(state.output, "{");
      decrement("braces");
    }
    if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
      push({type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?`});
    }
    if (state.backtrack === true) {
      state.output = "";
      for (const token of state.tokens) {
        state.output += token.output != null ? token.output : token.value;
        if (token.suffix) {
          state.output += token.suffix;
        }
      }
    }
    return state;
  };
  parse2.fastpaths = (input, options) => {
    const opts = {...options};
    const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    const len = input.length;
    if (len > max) {
      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
    }
    input = REPLACEMENTS[input] || input;
    const win32 = utils.isWindows(options);
    const {
      DOT_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOTS_SLASH,
      STAR,
      START_ANCHOR
    } = constants.globChars(win32);
    const nodot = opts.dot ? NO_DOTS : NO_DOT;
    const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
    const capture = opts.capture ? "" : "?:";
    const state = {negated: false, prefix: ""};
    let star = opts.bash === true ? ".*?" : STAR;
    if (opts.capture) {
      star = `(${star})`;
    }
    const globstar = (opts2) => {
      if (opts2.noglobstar === true)
        return star;
      return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };
    const create = (str) => {
      switch (str) {
        case "*":
          return `${nodot}${ONE_CHAR}${star}`;
        case ".*":
          return `${DOT_LITERAL}${ONE_CHAR}${star}`;
        case "*.*":
          return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
        case "*/*":
          return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
        case "**":
          return nodot + globstar(opts);
        case "**/*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
        case "**/*.*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
        case "**/.*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
        default: {
          const match = /^(.*?)\.(\w+)$/.exec(str);
          if (!match)
            return;
          const source2 = create(match[1]);
          if (!source2)
            return;
          return source2 + DOT_LITERAL + match[2];
        }
      }
    };
    const output = utils.removePrefix(input, state);
    let source = create(output);
    if (source && opts.strictSlashes !== true) {
      source += `${SLASH_LITERAL}?`;
    }
    return source;
  };
  module2.exports = parse2;
});

// ../../node_modules/.pnpm/picomatch@2.3.0/node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS((exports2, module2) => {
  "use strict";
  var path10 = require("path");
  var scan = require_scan2();
  var parse2 = require_parse4();
  var utils = require_utils3();
  var constants = require_constants2();
  var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
  var picomatch = (glob, options, returnState = false) => {
    if (Array.isArray(glob)) {
      const fns = glob.map((input) => picomatch(input, options, returnState));
      const arrayMatcher = (str) => {
        for (const isMatch of fns) {
          const state2 = isMatch(str);
          if (state2)
            return state2;
        }
        return false;
      };
      return arrayMatcher;
    }
    const isState = isObject(glob) && glob.tokens && glob.input;
    if (glob === "" || typeof glob !== "string" && !isState) {
      throw new TypeError("Expected pattern to be a non-empty string");
    }
    const opts = options || {};
    const posix = utils.isWindows(options);
    const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
    const state = regex.state;
    delete regex.state;
    let isIgnored = () => false;
    if (opts.ignore) {
      const ignoreOpts = {...options, ignore: null, onMatch: null, onResult: null};
      isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
    }
    const matcher = (input, returnObject = false) => {
      const {isMatch, match, output} = picomatch.test(input, regex, options, {glob, posix});
      const result = {glob, state, regex, posix, input, output, match, isMatch};
      if (typeof opts.onResult === "function") {
        opts.onResult(result);
      }
      if (isMatch === false) {
        result.isMatch = false;
        return returnObject ? result : false;
      }
      if (isIgnored(input)) {
        if (typeof opts.onIgnore === "function") {
          opts.onIgnore(result);
        }
        result.isMatch = false;
        return returnObject ? result : false;
      }
      if (typeof opts.onMatch === "function") {
        opts.onMatch(result);
      }
      return returnObject ? result : true;
    };
    if (returnState) {
      matcher.state = state;
    }
    return matcher;
  };
  picomatch.test = (input, regex, options, {glob, posix} = {}) => {
    if (typeof input !== "string") {
      throw new TypeError("Expected input to be a string");
    }
    if (input === "") {
      return {isMatch: false, output: ""};
    }
    const opts = options || {};
    const format10 = opts.format || (posix ? utils.toPosixSlashes : null);
    let match = input === glob;
    let output = match && format10 ? format10(input) : input;
    if (match === false) {
      output = format10 ? format10(input) : input;
      match = output === glob;
    }
    if (match === false || opts.capture === true) {
      if (opts.matchBase === true || opts.basename === true) {
        match = picomatch.matchBase(input, regex, options, posix);
      } else {
        match = regex.exec(output);
      }
    }
    return {isMatch: Boolean(match), match, output};
  };
  picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
    const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
    return regex.test(path10.basename(input));
  };
  picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
  picomatch.parse = (pattern, options) => {
    if (Array.isArray(pattern))
      return pattern.map((p) => picomatch.parse(p, options));
    return parse2(pattern, {...options, fastpaths: false});
  };
  picomatch.scan = (input, options) => scan(input, options);
  picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
    if (returnOutput === true) {
      return state.output;
    }
    const opts = options || {};
    const prepend = opts.contains ? "" : "^";
    const append = opts.contains ? "" : "$";
    let source = `${prepend}(?:${state.output})${append}`;
    if (state && state.negated === true) {
      source = `^(?!${source}).*$`;
    }
    const regex = picomatch.toRegex(source, options);
    if (returnState === true) {
      regex.state = state;
    }
    return regex;
  };
  picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
    if (!input || typeof input !== "string") {
      throw new TypeError("Expected a non-empty string");
    }
    let parsed = {negated: false, fastpaths: true};
    if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
      parsed.output = parse2.fastpaths(input, options);
    }
    if (!parsed.output) {
      parsed = parse2(input, options);
    }
    return picomatch.compileRe(parsed, options, returnOutput, returnState);
  };
  picomatch.toRegex = (source, options) => {
    try {
      const opts = options || {};
      return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
    } catch (err) {
      if (options && options.debug === true)
        throw err;
      return /$^/;
    }
  };
  picomatch.constants = constants;
  module2.exports = picomatch;
});

// ../../node_modules/.pnpm/picomatch@2.3.0/node_modules/picomatch/index.js
var require_picomatch2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = require_picomatch();
});

// ../../node_modules/.pnpm/micromatch@4.0.4/node_modules/micromatch/index.js
var require_micromatch = __commonJS((exports2, module2) => {
  "use strict";
  var util2 = require("util");
  var braces = require_braces();
  var picomatch = require_picomatch2();
  var utils = require_utils3();
  var isEmptyString = (val) => val === "" || val === "./";
  var micromatch = (list, patterns, options) => {
    patterns = [].concat(patterns);
    list = [].concat(list);
    let omit = new Set();
    let keep = new Set();
    let items = new Set();
    let negatives = 0;
    let onResult = (state) => {
      items.add(state.output);
      if (options && options.onResult) {
        options.onResult(state);
      }
    };
    for (let i = 0; i < patterns.length; i++) {
      let isMatch = picomatch(String(patterns[i]), {...options, onResult}, true);
      let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
      if (negated)
        negatives++;
      for (let item of list) {
        let matched = isMatch(item, true);
        let match = negated ? !matched.isMatch : matched.isMatch;
        if (!match)
          continue;
        if (negated) {
          omit.add(matched.output);
        } else {
          omit.delete(matched.output);
          keep.add(matched.output);
        }
      }
    }
    let result = negatives === patterns.length ? [...items] : [...keep];
    let matches = result.filter((item) => !omit.has(item));
    if (options && matches.length === 0) {
      if (options.failglob === true) {
        throw new Error(`No matches found for "${patterns.join(", ")}"`);
      }
      if (options.nonull === true || options.nullglob === true) {
        return options.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
      }
    }
    return matches;
  };
  micromatch.match = micromatch;
  micromatch.matcher = (pattern, options) => picomatch(pattern, options);
  micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
  micromatch.any = micromatch.isMatch;
  micromatch.not = (list, patterns, options = {}) => {
    patterns = [].concat(patterns).map(String);
    let result = new Set();
    let items = [];
    let onResult = (state) => {
      if (options.onResult)
        options.onResult(state);
      items.push(state.output);
    };
    let matches = micromatch(list, patterns, {...options, onResult});
    for (let item of items) {
      if (!matches.includes(item)) {
        result.add(item);
      }
    }
    return [...result];
  };
  micromatch.contains = (str, pattern, options) => {
    if (typeof str !== "string") {
      throw new TypeError(`Expected a string: "${util2.inspect(str)}"`);
    }
    if (Array.isArray(pattern)) {
      return pattern.some((p) => micromatch.contains(str, p, options));
    }
    if (typeof pattern === "string") {
      if (isEmptyString(str) || isEmptyString(pattern)) {
        return false;
      }
      if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern)) {
        return true;
      }
    }
    return micromatch.isMatch(str, pattern, {...options, contains: true});
  };
  micromatch.matchKeys = (obj, patterns, options) => {
    if (!utils.isObject(obj)) {
      throw new TypeError("Expected the first argument to be an object");
    }
    let keys = micromatch(Object.keys(obj), patterns, options);
    let res = {};
    for (let key of keys)
      res[key] = obj[key];
    return res;
  };
  micromatch.some = (list, patterns, options) => {
    let items = [].concat(list);
    for (let pattern of [].concat(patterns)) {
      let isMatch = picomatch(String(pattern), options);
      if (items.some((item) => isMatch(item))) {
        return true;
      }
    }
    return false;
  };
  micromatch.every = (list, patterns, options) => {
    let items = [].concat(list);
    for (let pattern of [].concat(patterns)) {
      let isMatch = picomatch(String(pattern), options);
      if (!items.every((item) => isMatch(item))) {
        return false;
      }
    }
    return true;
  };
  micromatch.all = (str, patterns, options) => {
    if (typeof str !== "string") {
      throw new TypeError(`Expected a string: "${util2.inspect(str)}"`);
    }
    return [].concat(patterns).every((p) => picomatch(p, options)(str));
  };
  micromatch.capture = (glob, input, options) => {
    let posix = utils.isWindows(options);
    let regex = picomatch.makeRe(String(glob), {...options, capture: true});
    let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);
    if (match) {
      return match.slice(1).map((v) => v === void 0 ? "" : v);
    }
  };
  micromatch.makeRe = (...args2) => picomatch.makeRe(...args2);
  micromatch.scan = (...args2) => picomatch.scan(...args2);
  micromatch.parse = (patterns, options) => {
    let res = [];
    for (let pattern of [].concat(patterns || [])) {
      for (let str of braces(String(pattern), options)) {
        res.push(picomatch.parse(str, options));
      }
    }
    return res;
  };
  micromatch.braces = (pattern, options) => {
    if (typeof pattern !== "string")
      throw new TypeError("Expected a string");
    if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
      return [pattern];
    }
    return braces(pattern, options);
  };
  micromatch.braceExpand = (pattern, options) => {
    if (typeof pattern !== "string")
      throw new TypeError("Expected a string");
    return micromatch.braces(pattern, {...options, expand: true});
  };
  module2.exports = micromatch;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/utils/pattern.js
var require_pattern = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.matchAny = exports2.convertPatternsToRe = exports2.makeRe = exports2.getPatternParts = exports2.expandBraceExpansion = exports2.expandPatternsWithBraceExpansion = exports2.isAffectDepthOfReadingPattern = exports2.endsWithSlashGlobStar = exports2.hasGlobStar = exports2.getBaseDirectory = exports2.getPositivePatterns = exports2.getNegativePatterns = exports2.isPositivePattern = exports2.isNegativePattern = exports2.convertToNegativePattern = exports2.convertToPositivePattern = exports2.isDynamicPattern = exports2.isStaticPattern = void 0;
  var path10 = require("path");
  var globParent = require_glob_parent();
  var micromatch = require_micromatch();
  var picomatch = require_picomatch2();
  var GLOBSTAR = "**";
  var ESCAPE_SYMBOL = "\\";
  var COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
  var REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[.*]/;
  var REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\(.*\|.*\)/;
  var GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\(.*\)/;
  var BRACE_EXPANSIONS_SYMBOLS_RE = /{.*(?:,|\.\.).*}/;
  function isStaticPattern(pattern, options = {}) {
    return !isDynamicPattern(pattern, options);
  }
  exports2.isStaticPattern = isStaticPattern;
  function isDynamicPattern(pattern, options = {}) {
    if (pattern === "") {
      return false;
    }
    if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
      return true;
    }
    if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
      return true;
    }
    if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
      return true;
    }
    if (options.braceExpansion !== false && BRACE_EXPANSIONS_SYMBOLS_RE.test(pattern)) {
      return true;
    }
    return false;
  }
  exports2.isDynamicPattern = isDynamicPattern;
  function convertToPositivePattern(pattern) {
    return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
  }
  exports2.convertToPositivePattern = convertToPositivePattern;
  function convertToNegativePattern(pattern) {
    return "!" + pattern;
  }
  exports2.convertToNegativePattern = convertToNegativePattern;
  function isNegativePattern(pattern) {
    return pattern.startsWith("!") && pattern[1] !== "(";
  }
  exports2.isNegativePattern = isNegativePattern;
  function isPositivePattern(pattern) {
    return !isNegativePattern(pattern);
  }
  exports2.isPositivePattern = isPositivePattern;
  function getNegativePatterns(patterns) {
    return patterns.filter(isNegativePattern);
  }
  exports2.getNegativePatterns = getNegativePatterns;
  function getPositivePatterns(patterns) {
    return patterns.filter(isPositivePattern);
  }
  exports2.getPositivePatterns = getPositivePatterns;
  function getBaseDirectory(pattern) {
    return globParent(pattern, {flipBackslashes: false});
  }
  exports2.getBaseDirectory = getBaseDirectory;
  function hasGlobStar(pattern) {
    return pattern.includes(GLOBSTAR);
  }
  exports2.hasGlobStar = hasGlobStar;
  function endsWithSlashGlobStar(pattern) {
    return pattern.endsWith("/" + GLOBSTAR);
  }
  exports2.endsWithSlashGlobStar = endsWithSlashGlobStar;
  function isAffectDepthOfReadingPattern(pattern) {
    const basename = path10.basename(pattern);
    return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
  }
  exports2.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
  function expandPatternsWithBraceExpansion(patterns) {
    return patterns.reduce((collection, pattern) => {
      return collection.concat(expandBraceExpansion(pattern));
    }, []);
  }
  exports2.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
  function expandBraceExpansion(pattern) {
    return micromatch.braces(pattern, {
      expand: true,
      nodupes: true
    });
  }
  exports2.expandBraceExpansion = expandBraceExpansion;
  function getPatternParts(pattern, options) {
    let {parts} = picomatch.scan(pattern, Object.assign(Object.assign({}, options), {parts: true}));
    if (parts.length === 0) {
      parts = [pattern];
    }
    if (parts[0].startsWith("/")) {
      parts[0] = parts[0].slice(1);
      parts.unshift("");
    }
    return parts;
  }
  exports2.getPatternParts = getPatternParts;
  function makeRe(pattern, options) {
    return micromatch.makeRe(pattern, options);
  }
  exports2.makeRe = makeRe;
  function convertPatternsToRe(patterns, options) {
    return patterns.map((pattern) => makeRe(pattern, options));
  }
  exports2.convertPatternsToRe = convertPatternsToRe;
  function matchAny(entry, patternsRe) {
    return patternsRe.some((patternRe) => patternRe.test(entry));
  }
  exports2.matchAny = matchAny;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/utils/stream.js
var require_stream2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.merge = void 0;
  var merge2 = require_merge2();
  function merge(streams) {
    const mergedStream = merge2(streams);
    streams.forEach((stream) => {
      stream.once("error", (error) => mergedStream.emit("error", error));
    });
    mergedStream.once("close", () => propagateCloseEventToSources(streams));
    mergedStream.once("end", () => propagateCloseEventToSources(streams));
    return mergedStream;
  }
  exports2.merge = merge;
  function propagateCloseEventToSources(streams) {
    streams.forEach((stream) => stream.emit("close"));
  }
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/utils/string.js
var require_string = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.isEmpty = exports2.isString = void 0;
  function isString(input) {
    return typeof input === "string";
  }
  exports2.isString = isString;
  function isEmpty(input) {
    return input === "";
  }
  exports2.isEmpty = isEmpty;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/utils/index.js
var require_utils4 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.string = exports2.stream = exports2.pattern = exports2.path = exports2.fs = exports2.errno = exports2.array = void 0;
  var array = require_array();
  exports2.array = array;
  var errno = require_errno();
  exports2.errno = errno;
  var fs9 = require_fs2();
  exports2.fs = fs9;
  var path10 = require_path();
  exports2.path = path10;
  var pattern = require_pattern();
  exports2.pattern = pattern;
  var stream = require_stream2();
  exports2.stream = stream;
  var string = require_string();
  exports2.string = string;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/managers/tasks.js
var require_tasks = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.convertPatternGroupToTask = exports2.convertPatternGroupsToTasks = exports2.groupPatternsByBaseDirectory = exports2.getNegativePatternsAsPositive = exports2.getPositivePatterns = exports2.convertPatternsToTasks = exports2.generate = void 0;
  var utils = require_utils4();
  function generate(patterns, settings) {
    const positivePatterns = getPositivePatterns(patterns);
    const negativePatterns = getNegativePatternsAsPositive(patterns, settings.ignore);
    const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));
    const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));
    const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, false);
    const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, true);
    return staticTasks.concat(dynamicTasks);
  }
  exports2.generate = generate;
  function convertPatternsToTasks(positive, negative, dynamic) {
    const positivePatternsGroup = groupPatternsByBaseDirectory(positive);
    if ("." in positivePatternsGroup) {
      const task = convertPatternGroupToTask(".", positive, negative, dynamic);
      return [task];
    }
    return convertPatternGroupsToTasks(positivePatternsGroup, negative, dynamic);
  }
  exports2.convertPatternsToTasks = convertPatternsToTasks;
  function getPositivePatterns(patterns) {
    return utils.pattern.getPositivePatterns(patterns);
  }
  exports2.getPositivePatterns = getPositivePatterns;
  function getNegativePatternsAsPositive(patterns, ignore) {
    const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);
    const positive = negative.map(utils.pattern.convertToPositivePattern);
    return positive;
  }
  exports2.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
  function groupPatternsByBaseDirectory(patterns) {
    const group = {};
    return patterns.reduce((collection, pattern) => {
      const base = utils.pattern.getBaseDirectory(pattern);
      if (base in collection) {
        collection[base].push(pattern);
      } else {
        collection[base] = [pattern];
      }
      return collection;
    }, group);
  }
  exports2.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
  function convertPatternGroupsToTasks(positive, negative, dynamic) {
    return Object.keys(positive).map((base) => {
      return convertPatternGroupToTask(base, positive[base], negative, dynamic);
    });
  }
  exports2.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
  function convertPatternGroupToTask(base, positive, negative, dynamic) {
    return {
      dynamic,
      positive,
      negative,
      base,
      patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))
    };
  }
  exports2.convertPatternGroupToTask = convertPatternGroupToTask;
});

// ../../node_modules/.pnpm/@nodelib+fs.stat@2.0.4/node_modules/@nodelib/fs.stat/out/providers/async.js
var require_async2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.read = void 0;
  function read(path10, settings, callback) {
    settings.fs.lstat(path10, (lstatError, lstat) => {
      if (lstatError !== null) {
        return callFailureCallback(callback, lstatError);
      }
      if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
        return callSuccessCallback(callback, lstat);
      }
      settings.fs.stat(path10, (statError, stat) => {
        if (statError !== null) {
          if (settings.throwErrorOnBrokenSymbolicLink) {
            return callFailureCallback(callback, statError);
          }
          return callSuccessCallback(callback, lstat);
        }
        if (settings.markSymbolicLink) {
          stat.isSymbolicLink = () => true;
        }
        callSuccessCallback(callback, stat);
      });
    });
  }
  exports2.read = read;
  function callFailureCallback(callback, error) {
    callback(error);
  }
  function callSuccessCallback(callback, result) {
    callback(null, result);
  }
});

// ../../node_modules/.pnpm/@nodelib+fs.stat@2.0.4/node_modules/@nodelib/fs.stat/out/providers/sync.js
var require_sync3 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.read = void 0;
  function read(path10, settings) {
    const lstat = settings.fs.lstatSync(path10);
    if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
      return lstat;
    }
    try {
      const stat = settings.fs.statSync(path10);
      if (settings.markSymbolicLink) {
        stat.isSymbolicLink = () => true;
      }
      return stat;
    } catch (error) {
      if (!settings.throwErrorOnBrokenSymbolicLink) {
        return lstat;
      }
      throw error;
    }
  }
  exports2.read = read;
});

// ../../node_modules/.pnpm/@nodelib+fs.stat@2.0.4/node_modules/@nodelib/fs.stat/out/adapters/fs.js
var require_fs3 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
  var fs9 = require("fs");
  exports2.FILE_SYSTEM_ADAPTER = {
    lstat: fs9.lstat,
    stat: fs9.stat,
    lstatSync: fs9.lstatSync,
    statSync: fs9.statSync
  };
  function createFileSystemAdapter(fsMethods) {
    if (fsMethods === void 0) {
      return exports2.FILE_SYSTEM_ADAPTER;
    }
    return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
  }
  exports2.createFileSystemAdapter = createFileSystemAdapter;
});

// ../../node_modules/.pnpm/@nodelib+fs.stat@2.0.4/node_modules/@nodelib/fs.stat/out/settings.js
var require_settings = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var fs9 = require_fs3();
  var Settings = class {
    constructor(_options = {}) {
      this._options = _options;
      this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
      this.fs = fs9.createFileSystemAdapter(this._options.fs);
      this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
      this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
    }
    _getValue(option, value) {
      return option !== null && option !== void 0 ? option : value;
    }
  };
  exports2.default = Settings;
});

// ../../node_modules/.pnpm/@nodelib+fs.stat@2.0.4/node_modules/@nodelib/fs.stat/out/index.js
var require_out = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.statSync = exports2.stat = exports2.Settings = void 0;
  var async = require_async2();
  var sync2 = require_sync3();
  var settings_1 = require_settings();
  exports2.Settings = settings_1.default;
  function stat(path10, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === "function") {
      return async.read(path10, getSettings(), optionsOrSettingsOrCallback);
    }
    async.read(path10, getSettings(optionsOrSettingsOrCallback), callback);
  }
  exports2.stat = stat;
  function statSync(path10, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    return sync2.read(path10, settings);
  }
  exports2.statSync = statSync;
  function getSettings(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1.default) {
      return settingsOrOptions;
    }
    return new settings_1.default(settingsOrOptions);
  }
});

// ../../node_modules/.pnpm/queue-microtask@1.2.2/node_modules/queue-microtask/index.js
var require_queue_microtask = __commonJS((exports2, module2) => {
  /*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var promise;
  module2.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(globalThis) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
    throw err;
  }, 0));
});

// ../../node_modules/.pnpm/run-parallel@1.2.0/node_modules/run-parallel/index.js
var require_run_parallel = __commonJS((exports2, module2) => {
  /*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  module2.exports = runParallel;
  var queueMicrotask2 = require_queue_microtask();
  function runParallel(tasks, cb) {
    let results, pending, keys;
    let isSync = true;
    if (Array.isArray(tasks)) {
      results = [];
      pending = tasks.length;
    } else {
      keys = Object.keys(tasks);
      results = {};
      pending = keys.length;
    }
    function done(err) {
      function end() {
        if (cb)
          cb(err, results);
        cb = null;
      }
      if (isSync)
        queueMicrotask2(end);
      else
        end();
    }
    function each(i, err, result) {
      results[i] = result;
      if (--pending === 0 || err) {
        done(err);
      }
    }
    if (!pending) {
      done(null);
    } else if (keys) {
      keys.forEach(function(key) {
        tasks[key](function(err, result) {
          each(key, err, result);
        });
      });
    } else {
      tasks.forEach(function(task, i) {
        task(function(err, result) {
          each(i, err, result);
        });
      });
    }
    isSync = false;
  }
});

// ../../node_modules/.pnpm/@nodelib+fs.scandir@2.1.4/node_modules/@nodelib/fs.scandir/out/constants.js
var require_constants3 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
  var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
  var MAJOR_VERSION = parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
  var MINOR_VERSION = parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
  var SUPPORTED_MAJOR_VERSION = 10;
  var SUPPORTED_MINOR_VERSION = 10;
  var IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
  var IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
  exports2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
});

// ../../node_modules/.pnpm/@nodelib+fs.scandir@2.1.4/node_modules/@nodelib/fs.scandir/out/utils/fs.js
var require_fs4 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.createDirentFromStats = void 0;
  var DirentFromStats = class {
    constructor(name, stats) {
      this.name = name;
      this.isBlockDevice = stats.isBlockDevice.bind(stats);
      this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
      this.isDirectory = stats.isDirectory.bind(stats);
      this.isFIFO = stats.isFIFO.bind(stats);
      this.isFile = stats.isFile.bind(stats);
      this.isSocket = stats.isSocket.bind(stats);
      this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
    }
  };
  function createDirentFromStats(name, stats) {
    return new DirentFromStats(name, stats);
  }
  exports2.createDirentFromStats = createDirentFromStats;
});

// ../../node_modules/.pnpm/@nodelib+fs.scandir@2.1.4/node_modules/@nodelib/fs.scandir/out/utils/index.js
var require_utils5 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.fs = void 0;
  var fs9 = require_fs4();
  exports2.fs = fs9;
});

// ../../node_modules/.pnpm/@nodelib+fs.scandir@2.1.4/node_modules/@nodelib/fs.scandir/out/providers/common.js
var require_common5 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.joinPathSegments = void 0;
  function joinPathSegments(a, b, separator) {
    if (a.endsWith(separator)) {
      return a + b;
    }
    return a + separator + b;
  }
  exports2.joinPathSegments = joinPathSegments;
});

// ../../node_modules/.pnpm/@nodelib+fs.scandir@2.1.4/node_modules/@nodelib/fs.scandir/out/providers/async.js
var require_async3 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.readdir = exports2.readdirWithFileTypes = exports2.read = void 0;
  var fsStat = require_out();
  var rpl = require_run_parallel();
  var constants_1 = require_constants3();
  var utils = require_utils5();
  var common = require_common5();
  function read(directory, settings, callback) {
    if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
      return readdirWithFileTypes(directory, settings, callback);
    }
    return readdir2(directory, settings, callback);
  }
  exports2.read = read;
  function readdirWithFileTypes(directory, settings, callback) {
    settings.fs.readdir(directory, {withFileTypes: true}, (readdirError, dirents) => {
      if (readdirError !== null) {
        return callFailureCallback(callback, readdirError);
      }
      const entries = dirents.map((dirent) => ({
        dirent,
        name: dirent.name,
        path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
      }));
      if (!settings.followSymbolicLinks) {
        return callSuccessCallback(callback, entries);
      }
      const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));
      rpl(tasks, (rplError, rplEntries) => {
        if (rplError !== null) {
          return callFailureCallback(callback, rplError);
        }
        callSuccessCallback(callback, rplEntries);
      });
    });
  }
  exports2.readdirWithFileTypes = readdirWithFileTypes;
  function makeRplTaskEntry(entry, settings) {
    return (done) => {
      if (!entry.dirent.isSymbolicLink()) {
        return done(null, entry);
      }
      settings.fs.stat(entry.path, (statError, stats) => {
        if (statError !== null) {
          if (settings.throwErrorOnBrokenSymbolicLink) {
            return done(statError);
          }
          return done(null, entry);
        }
        entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
        return done(null, entry);
      });
    };
  }
  function readdir2(directory, settings, callback) {
    settings.fs.readdir(directory, (readdirError, names) => {
      if (readdirError !== null) {
        return callFailureCallback(callback, readdirError);
      }
      const filepaths = names.map((name) => common.joinPathSegments(directory, name, settings.pathSegmentSeparator));
      const tasks = filepaths.map((filepath) => {
        return (done) => fsStat.stat(filepath, settings.fsStatSettings, done);
      });
      rpl(tasks, (rplError, results) => {
        if (rplError !== null) {
          return callFailureCallback(callback, rplError);
        }
        const entries = [];
        names.forEach((name, index) => {
          const stats = results[index];
          const entry = {
            name,
            path: filepaths[index],
            dirent: utils.fs.createDirentFromStats(name, stats)
          };
          if (settings.stats) {
            entry.stats = stats;
          }
          entries.push(entry);
        });
        callSuccessCallback(callback, entries);
      });
    });
  }
  exports2.readdir = readdir2;
  function callFailureCallback(callback, error) {
    callback(error);
  }
  function callSuccessCallback(callback, result) {
    callback(null, result);
  }
});

// ../../node_modules/.pnpm/@nodelib+fs.scandir@2.1.4/node_modules/@nodelib/fs.scandir/out/providers/sync.js
var require_sync4 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.readdir = exports2.readdirWithFileTypes = exports2.read = void 0;
  var fsStat = require_out();
  var constants_1 = require_constants3();
  var utils = require_utils5();
  var common = require_common5();
  function read(directory, settings) {
    if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
      return readdirWithFileTypes(directory, settings);
    }
    return readdir2(directory, settings);
  }
  exports2.read = read;
  function readdirWithFileTypes(directory, settings) {
    const dirents = settings.fs.readdirSync(directory, {withFileTypes: true});
    return dirents.map((dirent) => {
      const entry = {
        dirent,
        name: dirent.name,
        path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
      };
      if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
        try {
          const stats = settings.fs.statSync(entry.path);
          entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
        } catch (error) {
          if (settings.throwErrorOnBrokenSymbolicLink) {
            throw error;
          }
        }
      }
      return entry;
    });
  }
  exports2.readdirWithFileTypes = readdirWithFileTypes;
  function readdir2(directory, settings) {
    const names = settings.fs.readdirSync(directory);
    return names.map((name) => {
      const entryPath = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
      const stats = fsStat.statSync(entryPath, settings.fsStatSettings);
      const entry = {
        name,
        path: entryPath,
        dirent: utils.fs.createDirentFromStats(name, stats)
      };
      if (settings.stats) {
        entry.stats = stats;
      }
      return entry;
    });
  }
  exports2.readdir = readdir2;
});

// ../../node_modules/.pnpm/@nodelib+fs.scandir@2.1.4/node_modules/@nodelib/fs.scandir/out/adapters/fs.js
var require_fs5 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
  var fs9 = require("fs");
  exports2.FILE_SYSTEM_ADAPTER = {
    lstat: fs9.lstat,
    stat: fs9.stat,
    lstatSync: fs9.lstatSync,
    statSync: fs9.statSync,
    readdir: fs9.readdir,
    readdirSync: fs9.readdirSync
  };
  function createFileSystemAdapter(fsMethods) {
    if (fsMethods === void 0) {
      return exports2.FILE_SYSTEM_ADAPTER;
    }
    return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
  }
  exports2.createFileSystemAdapter = createFileSystemAdapter;
});

// ../../node_modules/.pnpm/@nodelib+fs.scandir@2.1.4/node_modules/@nodelib/fs.scandir/out/settings.js
var require_settings2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var path10 = require("path");
  var fsStat = require_out();
  var fs9 = require_fs5();
  var Settings = class {
    constructor(_options = {}) {
      this._options = _options;
      this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
      this.fs = fs9.createFileSystemAdapter(this._options.fs);
      this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path10.sep);
      this.stats = this._getValue(this._options.stats, false);
      this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
      this.fsStatSettings = new fsStat.Settings({
        followSymbolicLink: this.followSymbolicLinks,
        fs: this.fs,
        throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
      });
    }
    _getValue(option, value) {
      return option !== null && option !== void 0 ? option : value;
    }
  };
  exports2.default = Settings;
});

// ../../node_modules/.pnpm/@nodelib+fs.scandir@2.1.4/node_modules/@nodelib/fs.scandir/out/index.js
var require_out2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Settings = exports2.scandirSync = exports2.scandir = void 0;
  var async = require_async3();
  var sync2 = require_sync4();
  var settings_1 = require_settings2();
  exports2.Settings = settings_1.default;
  function scandir(path10, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === "function") {
      return async.read(path10, getSettings(), optionsOrSettingsOrCallback);
    }
    async.read(path10, getSettings(optionsOrSettingsOrCallback), callback);
  }
  exports2.scandir = scandir;
  function scandirSync(path10, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    return sync2.read(path10, settings);
  }
  exports2.scandirSync = scandirSync;
  function getSettings(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1.default) {
      return settingsOrOptions;
    }
    return new settings_1.default(settingsOrOptions);
  }
});

// ../../node_modules/.pnpm/reusify@1.0.4/node_modules/reusify/reusify.js
var require_reusify = __commonJS((exports2, module2) => {
  "use strict";
  function reusify(Constructor) {
    var head = new Constructor();
    var tail = head;
    function get() {
      var current = head;
      if (current.next) {
        head = current.next;
      } else {
        head = new Constructor();
        tail = head;
      }
      current.next = null;
      return current;
    }
    function release(obj) {
      tail.next = obj;
      tail = obj;
    }
    return {
      get,
      release
    };
  }
  module2.exports = reusify;
});

// ../../node_modules/.pnpm/fastq@1.11.0/node_modules/fastq/queue.js
var require_queue = __commonJS((exports2, module2) => {
  "use strict";
  var reusify = require_reusify();
  function fastqueue(context, worker, concurrency) {
    if (typeof context === "function") {
      concurrency = worker;
      worker = context;
      context = null;
    }
    if (concurrency < 1) {
      throw new Error("fastqueue concurrency must be greater than 1");
    }
    var cache = reusify(Task);
    var queueHead = null;
    var queueTail = null;
    var _running = 0;
    var errorHandler = null;
    var self2 = {
      push,
      drain: noop,
      saturated: noop,
      pause,
      paused: false,
      concurrency,
      running,
      resume,
      idle,
      length,
      getQueue,
      unshift,
      empty: noop,
      kill,
      killAndDrain,
      error
    };
    return self2;
    function running() {
      return _running;
    }
    function pause() {
      self2.paused = true;
    }
    function length() {
      var current = queueHead;
      var counter2 = 0;
      while (current) {
        current = current.next;
        counter2++;
      }
      return counter2;
    }
    function getQueue() {
      var current = queueHead;
      var tasks = [];
      while (current) {
        tasks.push(current.value);
        current = current.next;
      }
      return tasks;
    }
    function resume() {
      if (!self2.paused)
        return;
      self2.paused = false;
      for (var i = 0; i < self2.concurrency; i++) {
        _running++;
        release();
      }
    }
    function idle() {
      return _running === 0 && self2.length() === 0;
    }
    function push(value, done) {
      var current = cache.get();
      current.context = context;
      current.release = release;
      current.value = value;
      current.callback = done || noop;
      current.errorHandler = errorHandler;
      if (_running === self2.concurrency || self2.paused) {
        if (queueTail) {
          queueTail.next = current;
          queueTail = current;
        } else {
          queueHead = current;
          queueTail = current;
          self2.saturated();
        }
      } else {
        _running++;
        worker.call(context, current.value, current.worked);
      }
    }
    function unshift(value, done) {
      var current = cache.get();
      current.context = context;
      current.release = release;
      current.value = value;
      current.callback = done || noop;
      if (_running === self2.concurrency || self2.paused) {
        if (queueHead) {
          current.next = queueHead;
          queueHead = current;
        } else {
          queueHead = current;
          queueTail = current;
          self2.saturated();
        }
      } else {
        _running++;
        worker.call(context, current.value, current.worked);
      }
    }
    function release(holder) {
      if (holder) {
        cache.release(holder);
      }
      var next = queueHead;
      if (next) {
        if (!self2.paused) {
          if (queueTail === queueHead) {
            queueTail = null;
          }
          queueHead = next.next;
          next.next = null;
          worker.call(context, next.value, next.worked);
          if (queueTail === null) {
            self2.empty();
          }
        } else {
          _running--;
        }
      } else if (--_running === 0) {
        self2.drain();
      }
    }
    function kill() {
      queueHead = null;
      queueTail = null;
      self2.drain = noop;
    }
    function killAndDrain() {
      queueHead = null;
      queueTail = null;
      self2.drain();
      self2.drain = noop;
    }
    function error(handler) {
      errorHandler = handler;
    }
  }
  function noop() {
  }
  function Task() {
    this.value = null;
    this.callback = noop;
    this.next = null;
    this.release = noop;
    this.context = null;
    this.errorHandler = null;
    var self2 = this;
    this.worked = function worked(err, result) {
      var callback = self2.callback;
      var errorHandler = self2.errorHandler;
      var val = self2.value;
      self2.value = null;
      self2.callback = noop;
      if (self2.errorHandler) {
        errorHandler(err, val);
      }
      callback.call(self2.context, err, result);
      self2.release(self2);
    };
  }
  function queueAsPromised(context, worker, concurrency) {
    if (typeof context === "function") {
      concurrency = worker;
      worker = context;
      context = null;
    }
    function asyncWrapper(arg10, cb) {
      worker.call(this, arg10).then(function(res) {
        cb(null, res);
      }, cb);
    }
    var queue = fastqueue(context, asyncWrapper, concurrency);
    var pushCb = queue.push;
    var unshiftCb = queue.unshift;
    queue.push = push;
    queue.unshift = unshift;
    return queue;
    function push(value) {
      return new Promise(function(resolve, reject) {
        pushCb(value, function(err, result) {
          if (err) {
            reject(err);
            return;
          }
          resolve(result);
        });
      });
    }
    function unshift(value) {
      return new Promise(function(resolve, reject) {
        unshiftCb(value, function(err, result) {
          if (err) {
            reject(err);
            return;
          }
          resolve(result);
        });
      });
    }
  }
  module2.exports = fastqueue;
  module2.exports.promise = queueAsPromised;
});

// ../../node_modules/.pnpm/@nodelib+fs.walk@1.2.6/node_modules/@nodelib/fs.walk/out/readers/common.js
var require_common6 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.joinPathSegments = exports2.replacePathSegmentSeparator = exports2.isAppliedFilter = exports2.isFatalError = void 0;
  function isFatalError(settings, error) {
    if (settings.errorFilter === null) {
      return true;
    }
    return !settings.errorFilter(error);
  }
  exports2.isFatalError = isFatalError;
  function isAppliedFilter(filter, value) {
    return filter === null || filter(value);
  }
  exports2.isAppliedFilter = isAppliedFilter;
  function replacePathSegmentSeparator(filepath, separator) {
    return filepath.split(/[/\\]/).join(separator);
  }
  exports2.replacePathSegmentSeparator = replacePathSegmentSeparator;
  function joinPathSegments(a, b, separator) {
    if (a === "") {
      return b;
    }
    if (a.endsWith(separator)) {
      return a + b;
    }
    return a + separator + b;
  }
  exports2.joinPathSegments = joinPathSegments;
});

// ../../node_modules/.pnpm/@nodelib+fs.walk@1.2.6/node_modules/@nodelib/fs.walk/out/readers/reader.js
var require_reader = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var common = require_common6();
  var Reader = class {
    constructor(_root, _settings) {
      this._root = _root;
      this._settings = _settings;
      this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
    }
  };
  exports2.default = Reader;
});

// ../../node_modules/.pnpm/@nodelib+fs.walk@1.2.6/node_modules/@nodelib/fs.walk/out/readers/async.js
var require_async4 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var events_1 = require("events");
  var fsScandir = require_out2();
  var fastq = require_queue();
  var common = require_common6();
  var reader_1 = require_reader();
  var AsyncReader = class extends reader_1.default {
    constructor(_root, _settings) {
      super(_root, _settings);
      this._settings = _settings;
      this._scandir = fsScandir.scandir;
      this._emitter = new events_1.EventEmitter();
      this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
      this._isFatalError = false;
      this._isDestroyed = false;
      this._queue.drain = () => {
        if (!this._isFatalError) {
          this._emitter.emit("end");
        }
      };
    }
    read() {
      this._isFatalError = false;
      this._isDestroyed = false;
      setImmediate(() => {
        this._pushToQueue(this._root, this._settings.basePath);
      });
      return this._emitter;
    }
    get isDestroyed() {
      return this._isDestroyed;
    }
    destroy() {
      if (this._isDestroyed) {
        throw new Error("The reader is already destroyed");
      }
      this._isDestroyed = true;
      this._queue.killAndDrain();
    }
    onEntry(callback) {
      this._emitter.on("entry", callback);
    }
    onError(callback) {
      this._emitter.once("error", callback);
    }
    onEnd(callback) {
      this._emitter.once("end", callback);
    }
    _pushToQueue(directory, base) {
      const queueItem = {directory, base};
      this._queue.push(queueItem, (error) => {
        if (error !== null) {
          this._handleError(error);
        }
      });
    }
    _worker(item, done) {
      this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {
        if (error !== null) {
          return done(error, void 0);
        }
        for (const entry of entries) {
          this._handleEntry(entry, item.base);
        }
        done(null, void 0);
      });
    }
    _handleError(error) {
      if (this._isDestroyed || !common.isFatalError(this._settings, error)) {
        return;
      }
      this._isFatalError = true;
      this._isDestroyed = true;
      this._emitter.emit("error", error);
    }
    _handleEntry(entry, base) {
      if (this._isDestroyed || this._isFatalError) {
        return;
      }
      const fullpath = entry.path;
      if (base !== void 0) {
        entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
      }
      if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
        this._emitEntry(entry);
      }
      if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
        this._pushToQueue(fullpath, entry.path);
      }
    }
    _emitEntry(entry) {
      this._emitter.emit("entry", entry);
    }
  };
  exports2.default = AsyncReader;
});

// ../../node_modules/.pnpm/@nodelib+fs.walk@1.2.6/node_modules/@nodelib/fs.walk/out/providers/async.js
var require_async5 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var async_1 = require_async4();
  var AsyncProvider = class {
    constructor(_root, _settings) {
      this._root = _root;
      this._settings = _settings;
      this._reader = new async_1.default(this._root, this._settings);
      this._storage = new Set();
    }
    read(callback) {
      this._reader.onError((error) => {
        callFailureCallback(callback, error);
      });
      this._reader.onEntry((entry) => {
        this._storage.add(entry);
      });
      this._reader.onEnd(() => {
        callSuccessCallback(callback, [...this._storage]);
      });
      this._reader.read();
    }
  };
  exports2.default = AsyncProvider;
  function callFailureCallback(callback, error) {
    callback(error);
  }
  function callSuccessCallback(callback, entries) {
    callback(null, entries);
  }
});

// ../../node_modules/.pnpm/@nodelib+fs.walk@1.2.6/node_modules/@nodelib/fs.walk/out/providers/stream.js
var require_stream3 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var stream_1 = require("stream");
  var async_1 = require_async4();
  var StreamProvider = class {
    constructor(_root, _settings) {
      this._root = _root;
      this._settings = _settings;
      this._reader = new async_1.default(this._root, this._settings);
      this._stream = new stream_1.Readable({
        objectMode: true,
        read: () => {
        },
        destroy: () => {
          if (!this._reader.isDestroyed) {
            this._reader.destroy();
          }
        }
      });
    }
    read() {
      this._reader.onError((error) => {
        this._stream.emit("error", error);
      });
      this._reader.onEntry((entry) => {
        this._stream.push(entry);
      });
      this._reader.onEnd(() => {
        this._stream.push(null);
      });
      this._reader.read();
      return this._stream;
    }
  };
  exports2.default = StreamProvider;
});

// ../../node_modules/.pnpm/@nodelib+fs.walk@1.2.6/node_modules/@nodelib/fs.walk/out/readers/sync.js
var require_sync5 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var fsScandir = require_out2();
  var common = require_common6();
  var reader_1 = require_reader();
  var SyncReader = class extends reader_1.default {
    constructor() {
      super(...arguments);
      this._scandir = fsScandir.scandirSync;
      this._storage = new Set();
      this._queue = new Set();
    }
    read() {
      this._pushToQueue(this._root, this._settings.basePath);
      this._handleQueue();
      return [...this._storage];
    }
    _pushToQueue(directory, base) {
      this._queue.add({directory, base});
    }
    _handleQueue() {
      for (const item of this._queue.values()) {
        this._handleDirectory(item.directory, item.base);
      }
    }
    _handleDirectory(directory, base) {
      try {
        const entries = this._scandir(directory, this._settings.fsScandirSettings);
        for (const entry of entries) {
          this._handleEntry(entry, base);
        }
      } catch (error) {
        this._handleError(error);
      }
    }
    _handleError(error) {
      if (!common.isFatalError(this._settings, error)) {
        return;
      }
      throw error;
    }
    _handleEntry(entry, base) {
      const fullpath = entry.path;
      if (base !== void 0) {
        entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
      }
      if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
        this._pushToStorage(entry);
      }
      if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
        this._pushToQueue(fullpath, entry.path);
      }
    }
    _pushToStorage(entry) {
      this._storage.add(entry);
    }
  };
  exports2.default = SyncReader;
});

// ../../node_modules/.pnpm/@nodelib+fs.walk@1.2.6/node_modules/@nodelib/fs.walk/out/providers/sync.js
var require_sync6 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var sync_1 = require_sync5();
  var SyncProvider = class {
    constructor(_root, _settings) {
      this._root = _root;
      this._settings = _settings;
      this._reader = new sync_1.default(this._root, this._settings);
    }
    read() {
      return this._reader.read();
    }
  };
  exports2.default = SyncProvider;
});

// ../../node_modules/.pnpm/@nodelib+fs.walk@1.2.6/node_modules/@nodelib/fs.walk/out/settings.js
var require_settings3 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var path10 = require("path");
  var fsScandir = require_out2();
  var Settings = class {
    constructor(_options = {}) {
      this._options = _options;
      this.basePath = this._getValue(this._options.basePath, void 0);
      this.concurrency = this._getValue(this._options.concurrency, Infinity);
      this.deepFilter = this._getValue(this._options.deepFilter, null);
      this.entryFilter = this._getValue(this._options.entryFilter, null);
      this.errorFilter = this._getValue(this._options.errorFilter, null);
      this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path10.sep);
      this.fsScandirSettings = new fsScandir.Settings({
        followSymbolicLinks: this._options.followSymbolicLinks,
        fs: this._options.fs,
        pathSegmentSeparator: this._options.pathSegmentSeparator,
        stats: this._options.stats,
        throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
      });
    }
    _getValue(option, value) {
      return option !== null && option !== void 0 ? option : value;
    }
  };
  exports2.default = Settings;
});

// ../../node_modules/.pnpm/@nodelib+fs.walk@1.2.6/node_modules/@nodelib/fs.walk/out/index.js
var require_out3 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Settings = exports2.walkStream = exports2.walkSync = exports2.walk = void 0;
  var async_1 = require_async5();
  var stream_1 = require_stream3();
  var sync_1 = require_sync6();
  var settings_1 = require_settings3();
  exports2.Settings = settings_1.default;
  function walk(directory, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === "function") {
      return new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
    }
    new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
  }
  exports2.walk = walk;
  function walkSync(directory, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    const provider = new sync_1.default(directory, settings);
    return provider.read();
  }
  exports2.walkSync = walkSync;
  function walkStream(directory, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    const provider = new stream_1.default(directory, settings);
    return provider.read();
  }
  exports2.walkStream = walkStream;
  function getSettings(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1.default) {
      return settingsOrOptions;
    }
    return new settings_1.default(settingsOrOptions);
  }
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/readers/reader.js
var require_reader2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var path10 = require("path");
  var fsStat = require_out();
  var utils = require_utils4();
  var Reader = class {
    constructor(_settings) {
      this._settings = _settings;
      this._fsStatSettings = new fsStat.Settings({
        followSymbolicLink: this._settings.followSymbolicLinks,
        fs: this._settings.fs,
        throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
      });
    }
    _getFullEntryPath(filepath) {
      return path10.resolve(this._settings.cwd, filepath);
    }
    _makeEntry(stats, pattern) {
      const entry = {
        name: pattern,
        path: pattern,
        dirent: utils.fs.createDirentFromStats(pattern, stats)
      };
      if (this._settings.stats) {
        entry.stats = stats;
      }
      return entry;
    }
    _isFatalError(error) {
      return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
    }
  };
  exports2.default = Reader;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/readers/stream.js
var require_stream4 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var stream_1 = require("stream");
  var fsStat = require_out();
  var fsWalk = require_out3();
  var reader_1 = require_reader2();
  var ReaderStream = class extends reader_1.default {
    constructor() {
      super(...arguments);
      this._walkStream = fsWalk.walkStream;
      this._stat = fsStat.stat;
    }
    dynamic(root, options) {
      return this._walkStream(root, options);
    }
    static(patterns, options) {
      const filepaths = patterns.map(this._getFullEntryPath, this);
      const stream = new stream_1.PassThrough({objectMode: true});
      stream._write = (index, _enc, done) => {
        return this._getEntry(filepaths[index], patterns[index], options).then((entry) => {
          if (entry !== null && options.entryFilter(entry)) {
            stream.push(entry);
          }
          if (index === filepaths.length - 1) {
            stream.end();
          }
          done();
        }).catch(done);
      };
      for (let i = 0; i < filepaths.length; i++) {
        stream.write(i);
      }
      return stream;
    }
    _getEntry(filepath, pattern, options) {
      return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern)).catch((error) => {
        if (options.errorFilter(error)) {
          return null;
        }
        throw error;
      });
    }
    _getStat(filepath) {
      return new Promise((resolve, reject) => {
        this._stat(filepath, this._fsStatSettings, (error, stats) => {
          return error === null ? resolve(stats) : reject(error);
        });
      });
    }
  };
  exports2.default = ReaderStream;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/providers/matchers/matcher.js
var require_matcher = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var utils = require_utils4();
  var Matcher = class {
    constructor(_patterns, _settings, _micromatchOptions) {
      this._patterns = _patterns;
      this._settings = _settings;
      this._micromatchOptions = _micromatchOptions;
      this._storage = [];
      this._fillStorage();
    }
    _fillStorage() {
      const patterns = utils.pattern.expandPatternsWithBraceExpansion(this._patterns);
      for (const pattern of patterns) {
        const segments = this._getPatternSegments(pattern);
        const sections = this._splitSegmentsIntoSections(segments);
        this._storage.push({
          complete: sections.length <= 1,
          pattern,
          segments,
          sections
        });
      }
    }
    _getPatternSegments(pattern) {
      const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);
      return parts.map((part) => {
        const dynamic = utils.pattern.isDynamicPattern(part, this._settings);
        if (!dynamic) {
          return {
            dynamic: false,
            pattern: part
          };
        }
        return {
          dynamic: true,
          pattern: part,
          patternRe: utils.pattern.makeRe(part, this._micromatchOptions)
        };
      });
    }
    _splitSegmentsIntoSections(segments) {
      return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));
    }
  };
  exports2.default = Matcher;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/providers/matchers/partial.js
var require_partial = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var matcher_1 = require_matcher();
  var PartialMatcher = class extends matcher_1.default {
    match(filepath) {
      const parts = filepath.split("/");
      const levels = parts.length;
      const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);
      for (const pattern of patterns) {
        const section = pattern.sections[0];
        if (!pattern.complete && levels > section.length) {
          return true;
        }
        const match = parts.every((part, index) => {
          const segment = pattern.segments[index];
          if (segment.dynamic && segment.patternRe.test(part)) {
            return true;
          }
          if (!segment.dynamic && segment.pattern === part) {
            return true;
          }
          return false;
        });
        if (match) {
          return true;
        }
      }
      return false;
    }
  };
  exports2.default = PartialMatcher;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/providers/filters/deep.js
var require_deep = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var utils = require_utils4();
  var partial_1 = require_partial();
  var DeepFilter = class {
    constructor(_settings, _micromatchOptions) {
      this._settings = _settings;
      this._micromatchOptions = _micromatchOptions;
    }
    getFilter(basePath2, positive, negative) {
      const matcher = this._getMatcher(positive);
      const negativeRe = this._getNegativePatternsRe(negative);
      return (entry) => this._filter(basePath2, entry, matcher, negativeRe);
    }
    _getMatcher(patterns) {
      return new partial_1.default(patterns, this._settings, this._micromatchOptions);
    }
    _getNegativePatternsRe(patterns) {
      const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);
      return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
    }
    _filter(basePath2, entry, matcher, negativeRe) {
      if (this._isSkippedByDeep(basePath2, entry.path)) {
        return false;
      }
      if (this._isSkippedSymbolicLink(entry)) {
        return false;
      }
      const filepath = utils.path.removeLeadingDotSegment(entry.path);
      if (this._isSkippedByPositivePatterns(filepath, matcher)) {
        return false;
      }
      return this._isSkippedByNegativePatterns(filepath, negativeRe);
    }
    _isSkippedByDeep(basePath2, entryPath) {
      if (this._settings.deep === Infinity) {
        return false;
      }
      return this._getEntryLevel(basePath2, entryPath) >= this._settings.deep;
    }
    _getEntryLevel(basePath2, entryPath) {
      const entryPathDepth = entryPath.split("/").length;
      if (basePath2 === "") {
        return entryPathDepth;
      }
      const basePathDepth = basePath2.split("/").length;
      return entryPathDepth - basePathDepth;
    }
    _isSkippedSymbolicLink(entry) {
      return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
    }
    _isSkippedByPositivePatterns(entryPath, matcher) {
      return !this._settings.baseNameMatch && !matcher.match(entryPath);
    }
    _isSkippedByNegativePatterns(entryPath, patternsRe) {
      return !utils.pattern.matchAny(entryPath, patternsRe);
    }
  };
  exports2.default = DeepFilter;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/providers/filters/entry.js
var require_entry = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var utils = require_utils4();
  var EntryFilter = class {
    constructor(_settings, _micromatchOptions) {
      this._settings = _settings;
      this._micromatchOptions = _micromatchOptions;
      this.index = new Map();
    }
    getFilter(positive, negative) {
      const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);
      const negativeRe = utils.pattern.convertPatternsToRe(negative, this._micromatchOptions);
      return (entry) => this._filter(entry, positiveRe, negativeRe);
    }
    _filter(entry, positiveRe, negativeRe) {
      if (this._settings.unique && this._isDuplicateEntry(entry)) {
        return false;
      }
      if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
        return false;
      }
      if (this._isSkippedByAbsoluteNegativePatterns(entry.path, negativeRe)) {
        return false;
      }
      const filepath = this._settings.baseNameMatch ? entry.name : entry.path;
      const isMatched = this._isMatchToPatterns(filepath, positiveRe) && !this._isMatchToPatterns(entry.path, negativeRe);
      if (this._settings.unique && isMatched) {
        this._createIndexRecord(entry);
      }
      return isMatched;
    }
    _isDuplicateEntry(entry) {
      return this.index.has(entry.path);
    }
    _createIndexRecord(entry) {
      this.index.set(entry.path, void 0);
    }
    _onlyFileFilter(entry) {
      return this._settings.onlyFiles && !entry.dirent.isFile();
    }
    _onlyDirectoryFilter(entry) {
      return this._settings.onlyDirectories && !entry.dirent.isDirectory();
    }
    _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
      if (!this._settings.absolute) {
        return false;
      }
      const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);
      return utils.pattern.matchAny(fullpath, patternsRe);
    }
    _isMatchToPatterns(entryPath, patternsRe) {
      const filepath = utils.path.removeLeadingDotSegment(entryPath);
      return utils.pattern.matchAny(filepath, patternsRe);
    }
  };
  exports2.default = EntryFilter;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/providers/filters/error.js
var require_error2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var utils = require_utils4();
  var ErrorFilter = class {
    constructor(_settings) {
      this._settings = _settings;
    }
    getFilter() {
      return (error) => this._isNonFatalError(error);
    }
    _isNonFatalError(error) {
      return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
    }
  };
  exports2.default = ErrorFilter;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/providers/transformers/entry.js
var require_entry2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var utils = require_utils4();
  var EntryTransformer = class {
    constructor(_settings) {
      this._settings = _settings;
    }
    getTransformer() {
      return (entry) => this._transform(entry);
    }
    _transform(entry) {
      let filepath = entry.path;
      if (this._settings.absolute) {
        filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);
        filepath = utils.path.unixify(filepath);
      }
      if (this._settings.markDirectories && entry.dirent.isDirectory()) {
        filepath += "/";
      }
      if (!this._settings.objectMode) {
        return filepath;
      }
      return Object.assign(Object.assign({}, entry), {path: filepath});
    }
  };
  exports2.default = EntryTransformer;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/providers/provider.js
var require_provider = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var path10 = require("path");
  var deep_1 = require_deep();
  var entry_1 = require_entry();
  var error_1 = require_error2();
  var entry_2 = require_entry2();
  var Provider = class {
    constructor(_settings) {
      this._settings = _settings;
      this.errorFilter = new error_1.default(this._settings);
      this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
      this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
      this.entryTransformer = new entry_2.default(this._settings);
    }
    _getRootDirectory(task) {
      return path10.resolve(this._settings.cwd, task.base);
    }
    _getReaderOptions(task) {
      const basePath2 = task.base === "." ? "" : task.base;
      return {
        basePath: basePath2,
        pathSegmentSeparator: "/",
        concurrency: this._settings.concurrency,
        deepFilter: this.deepFilter.getFilter(basePath2, task.positive, task.negative),
        entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
        errorFilter: this.errorFilter.getFilter(),
        followSymbolicLinks: this._settings.followSymbolicLinks,
        fs: this._settings.fs,
        stats: this._settings.stats,
        throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
        transform: this.entryTransformer.getTransformer()
      };
    }
    _getMicromatchOptions() {
      return {
        dot: this._settings.dot,
        matchBase: this._settings.baseNameMatch,
        nobrace: !this._settings.braceExpansion,
        nocase: !this._settings.caseSensitiveMatch,
        noext: !this._settings.extglob,
        noglobstar: !this._settings.globstar,
        posix: true,
        strictSlashes: false
      };
    }
  };
  exports2.default = Provider;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/providers/async.js
var require_async6 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var stream_1 = require_stream4();
  var provider_1 = require_provider();
  var ProviderAsync = class extends provider_1.default {
    constructor() {
      super(...arguments);
      this._reader = new stream_1.default(this._settings);
    }
    read(task) {
      const root = this._getRootDirectory(task);
      const options = this._getReaderOptions(task);
      const entries = [];
      return new Promise((resolve, reject) => {
        const stream = this.api(root, task, options);
        stream.once("error", reject);
        stream.on("data", (entry) => entries.push(options.transform(entry)));
        stream.once("end", () => resolve(entries));
      });
    }
    api(root, task, options) {
      if (task.dynamic) {
        return this._reader.dynamic(root, options);
      }
      return this._reader.static(task.patterns, options);
    }
  };
  exports2.default = ProviderAsync;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/providers/stream.js
var require_stream5 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var stream_1 = require("stream");
  var stream_2 = require_stream4();
  var provider_1 = require_provider();
  var ProviderStream = class extends provider_1.default {
    constructor() {
      super(...arguments);
      this._reader = new stream_2.default(this._settings);
    }
    read(task) {
      const root = this._getRootDirectory(task);
      const options = this._getReaderOptions(task);
      const source = this.api(root, task, options);
      const destination = new stream_1.Readable({objectMode: true, read: () => {
      }});
      source.once("error", (error) => destination.emit("error", error)).on("data", (entry) => destination.emit("data", options.transform(entry))).once("end", () => destination.emit("end"));
      destination.once("close", () => source.destroy());
      return destination;
    }
    api(root, task, options) {
      if (task.dynamic) {
        return this._reader.dynamic(root, options);
      }
      return this._reader.static(task.patterns, options);
    }
  };
  exports2.default = ProviderStream;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/readers/sync.js
var require_sync7 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var fsStat = require_out();
  var fsWalk = require_out3();
  var reader_1 = require_reader2();
  var ReaderSync = class extends reader_1.default {
    constructor() {
      super(...arguments);
      this._walkSync = fsWalk.walkSync;
      this._statSync = fsStat.statSync;
    }
    dynamic(root, options) {
      return this._walkSync(root, options);
    }
    static(patterns, options) {
      const entries = [];
      for (const pattern of patterns) {
        const filepath = this._getFullEntryPath(pattern);
        const entry = this._getEntry(filepath, pattern, options);
        if (entry === null || !options.entryFilter(entry)) {
          continue;
        }
        entries.push(entry);
      }
      return entries;
    }
    _getEntry(filepath, pattern, options) {
      try {
        const stats = this._getStat(filepath);
        return this._makeEntry(stats, pattern);
      } catch (error) {
        if (options.errorFilter(error)) {
          return null;
        }
        throw error;
      }
    }
    _getStat(filepath) {
      return this._statSync(filepath, this._fsStatSettings);
    }
  };
  exports2.default = ReaderSync;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/providers/sync.js
var require_sync8 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var sync_1 = require_sync7();
  var provider_1 = require_provider();
  var ProviderSync = class extends provider_1.default {
    constructor() {
      super(...arguments);
      this._reader = new sync_1.default(this._settings);
    }
    read(task) {
      const root = this._getRootDirectory(task);
      const options = this._getReaderOptions(task);
      const entries = this.api(root, task, options);
      return entries.map(options.transform);
    }
    api(root, task, options) {
      if (task.dynamic) {
        return this._reader.dynamic(root, options);
      }
      return this._reader.static(task.patterns, options);
    }
  };
  exports2.default = ProviderSync;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/settings.js
var require_settings4 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
  var fs9 = require("fs");
  var os3 = require("os");
  var CPU_COUNT = Math.max(os3.cpus().length, 1);
  exports2.DEFAULT_FILE_SYSTEM_ADAPTER = {
    lstat: fs9.lstat,
    lstatSync: fs9.lstatSync,
    stat: fs9.stat,
    statSync: fs9.statSync,
    readdir: fs9.readdir,
    readdirSync: fs9.readdirSync
  };
  var Settings = class {
    constructor(_options = {}) {
      this._options = _options;
      this.absolute = this._getValue(this._options.absolute, false);
      this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
      this.braceExpansion = this._getValue(this._options.braceExpansion, true);
      this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
      this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
      this.cwd = this._getValue(this._options.cwd, process.cwd());
      this.deep = this._getValue(this._options.deep, Infinity);
      this.dot = this._getValue(this._options.dot, false);
      this.extglob = this._getValue(this._options.extglob, true);
      this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
      this.fs = this._getFileSystemMethods(this._options.fs);
      this.globstar = this._getValue(this._options.globstar, true);
      this.ignore = this._getValue(this._options.ignore, []);
      this.markDirectories = this._getValue(this._options.markDirectories, false);
      this.objectMode = this._getValue(this._options.objectMode, false);
      this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
      this.onlyFiles = this._getValue(this._options.onlyFiles, true);
      this.stats = this._getValue(this._options.stats, false);
      this.suppressErrors = this._getValue(this._options.suppressErrors, false);
      this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
      this.unique = this._getValue(this._options.unique, true);
      if (this.onlyDirectories) {
        this.onlyFiles = false;
      }
      if (this.stats) {
        this.objectMode = true;
      }
    }
    _getValue(option, value) {
      return option === void 0 ? value : option;
    }
    _getFileSystemMethods(methods = {}) {
      return Object.assign(Object.assign({}, exports2.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
    }
  };
  exports2.default = Settings;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/index.js
var require_out4 = __commonJS((exports2, module2) => {
  "use strict";
  var taskManager = require_tasks();
  var async_1 = require_async6();
  var stream_1 = require_stream5();
  var sync_1 = require_sync8();
  var settings_1 = require_settings4();
  var utils = require_utils4();
  async function FastGlob(source, options) {
    assertPatternsInput(source);
    const works = getWorks(source, async_1.default, options);
    const result = await Promise.all(works);
    return utils.array.flatten(result);
  }
  (function(FastGlob2) {
    function sync2(source, options) {
      assertPatternsInput(source);
      const works = getWorks(source, sync_1.default, options);
      return utils.array.flatten(works);
    }
    FastGlob2.sync = sync2;
    function stream(source, options) {
      assertPatternsInput(source);
      const works = getWorks(source, stream_1.default, options);
      return utils.stream.merge(works);
    }
    FastGlob2.stream = stream;
    function generateTasks(source, options) {
      assertPatternsInput(source);
      const patterns = [].concat(source);
      const settings = new settings_1.default(options);
      return taskManager.generate(patterns, settings);
    }
    FastGlob2.generateTasks = generateTasks;
    function isDynamicPattern(source, options) {
      assertPatternsInput(source);
      const settings = new settings_1.default(options);
      return utils.pattern.isDynamicPattern(source, settings);
    }
    FastGlob2.isDynamicPattern = isDynamicPattern;
    function escapePath(source) {
      assertPatternsInput(source);
      return utils.path.escape(source);
    }
    FastGlob2.escapePath = escapePath;
  })(FastGlob || (FastGlob = {}));
  function getWorks(source, _Provider, options) {
    const patterns = [].concat(source);
    const settings = new settings_1.default(options);
    const tasks = taskManager.generate(patterns, settings);
    const provider = new _Provider(settings);
    return tasks.map(provider.read, provider);
  }
  function assertPatternsInput(input) {
    const source = [].concat(input);
    const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));
    if (!isValidSource) {
      throw new TypeError("Patterns must be a string (non empty) or an array of strings");
    }
  }
  module2.exports = FastGlob;
});

// ../../node_modules/.pnpm/path-type@4.0.0/node_modules/path-type/index.js
var require_path_type = __commonJS((exports2) => {
  "use strict";
  var {promisify: promisify4} = require("util");
  var fs9 = require("fs");
  async function isType(fsStatType, statsMethodName, filePath) {
    if (typeof filePath !== "string") {
      throw new TypeError(`Expected a string, got ${typeof filePath}`);
    }
    try {
      const stats = await promisify4(fs9[fsStatType])(filePath);
      return stats[statsMethodName]();
    } catch (error) {
      if (error.code === "ENOENT") {
        return false;
      }
      throw error;
    }
  }
  function isTypeSync(fsStatType, statsMethodName, filePath) {
    if (typeof filePath !== "string") {
      throw new TypeError(`Expected a string, got ${typeof filePath}`);
    }
    try {
      return fs9[fsStatType](filePath)[statsMethodName]();
    } catch (error) {
      if (error.code === "ENOENT") {
        return false;
      }
      throw error;
    }
  }
  exports2.isFile = isType.bind(null, "stat", "isFile");
  exports2.isDirectory = isType.bind(null, "stat", "isDirectory");
  exports2.isSymlink = isType.bind(null, "lstat", "isSymbolicLink");
  exports2.isFileSync = isTypeSync.bind(null, "statSync", "isFile");
  exports2.isDirectorySync = isTypeSync.bind(null, "statSync", "isDirectory");
  exports2.isSymlinkSync = isTypeSync.bind(null, "lstatSync", "isSymbolicLink");
});

// ../../node_modules/.pnpm/dir-glob@3.0.1/node_modules/dir-glob/index.js
var require_dir_glob = __commonJS((exports2, module2) => {
  "use strict";
  var path10 = require("path");
  var pathType = require_path_type();
  var getExtensions = (extensions) => extensions.length > 1 ? `{${extensions.join(",")}}` : extensions[0];
  var getPath = (filepath, cwd) => {
    const pth = filepath[0] === "!" ? filepath.slice(1) : filepath;
    return path10.isAbsolute(pth) ? pth : path10.join(cwd, pth);
  };
  var addExtensions = (file, extensions) => {
    if (path10.extname(file)) {
      return `**/${file}`;
    }
    return `**/${file}.${getExtensions(extensions)}`;
  };
  var getGlob = (directory, options) => {
    if (options.files && !Array.isArray(options.files)) {
      throw new TypeError(`Expected \`files\` to be of type \`Array\` but received type \`${typeof options.files}\``);
    }
    if (options.extensions && !Array.isArray(options.extensions)) {
      throw new TypeError(`Expected \`extensions\` to be of type \`Array\` but received type \`${typeof options.extensions}\``);
    }
    if (options.files && options.extensions) {
      return options.files.map((x) => path10.posix.join(directory, addExtensions(x, options.extensions)));
    }
    if (options.files) {
      return options.files.map((x) => path10.posix.join(directory, `**/${x}`));
    }
    if (options.extensions) {
      return [path10.posix.join(directory, `**/*.${getExtensions(options.extensions)}`)];
    }
    return [path10.posix.join(directory, "**")];
  };
  module2.exports = async (input, options) => {
    options = {
      cwd: process.cwd(),
      ...options
    };
    if (typeof options.cwd !== "string") {
      throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
    }
    const globs = await Promise.all([].concat(input).map(async (x) => {
      const isDirectory = await pathType.isDirectory(getPath(x, options.cwd));
      return isDirectory ? getGlob(x, options) : x;
    }));
    return [].concat.apply([], globs);
  };
  module2.exports.sync = (input, options) => {
    options = {
      cwd: process.cwd(),
      ...options
    };
    if (typeof options.cwd !== "string") {
      throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
    }
    const globs = [].concat(input).map((x) => pathType.isDirectorySync(getPath(x, options.cwd)) ? getGlob(x, options) : x);
    return [].concat.apply([], globs);
  };
});

// ../../node_modules/.pnpm/ignore@5.1.8/node_modules/ignore/index.js
var require_ignore = __commonJS((exports2, module2) => {
  function makeArray(subject) {
    return Array.isArray(subject) ? subject : [subject];
  }
  var EMPTY = "";
  var SPACE = " ";
  var ESCAPE = "\\";
  var REGEX_TEST_BLANK_LINE = /^\s+$/;
  var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
  var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
  var REGEX_SPLITALL_CRLF = /\r?\n/g;
  var REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
  var SLASH = "/";
  var KEY_IGNORE = typeof Symbol !== "undefined" ? Symbol.for("node-ignore") : "node-ignore";
  var define2 = (object, key, value) => Object.defineProperty(object, key, {value});
  var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
  var sanitizeRange = (range) => range.replace(REGEX_REGEXP_RANGE, (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY);
  var cleanRangeBackSlash = (slashes) => {
    const {length} = slashes;
    return slashes.slice(0, length - length % 2);
  };
  var REPLACERS = [
    [
      /\\?\s+$/,
      (match) => match.indexOf("\\") === 0 ? SPACE : EMPTY
    ],
    [
      /\\\s/g,
      () => SPACE
    ],
    [
      /[\\$.|*+(){^]/g,
      (match) => `\\${match}`
    ],
    [
      /(?!\\)\?/g,
      () => "[^/]"
    ],
    [
      /^\//,
      () => "^"
    ],
    [
      /\//g,
      () => "\\/"
    ],
    [
      /^\^*\\\*\\\*\\\//,
      () => "^(?:.*\\/)?"
    ],
    [
      /^(?=[^^])/,
      function startingReplacer() {
        return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
      }
    ],
    [
      /\\\/\\\*\\\*(?=\\\/|$)/g,
      (_2, index, str) => index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
    ],
    [
      /(^|[^\\]+)\\\*(?=.+)/g,
      (_2, p1) => `${p1}[^\\/]*`
    ],
    [
      /\\\\\\(?=[$.|*+(){^])/g,
      () => ESCAPE
    ],
    [
      /\\\\/g,
      () => ESCAPE
    ],
    [
      /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
      (match, leadEscape, range, endEscape, close2) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close2}` : close2 === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"
    ],
    [
      /(?:[^*])$/,
      (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
    ],
    [
      /(\^|\\\/)?\\\*$/,
      (_2, p1) => {
        const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
        return `${prefix}(?=$|\\/$)`;
      }
    ]
  ];
  var regexCache = Object.create(null);
  var makeRegex = (pattern, negative, ignorecase) => {
    const r = regexCache[pattern];
    if (r) {
      return r;
    }
    const source = REPLACERS.reduce((prev, current) => prev.replace(current[0], current[1].bind(pattern)), pattern);
    return regexCache[pattern] = ignorecase ? new RegExp(source, "i") : new RegExp(source);
  };
  var isString = (subject) => typeof subject === "string";
  var checkPattern = (pattern) => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && pattern.indexOf("#") !== 0;
  var splitPattern = (pattern) => pattern.split(REGEX_SPLITALL_CRLF);
  var IgnoreRule = class {
    constructor(origin, pattern, negative, regex) {
      this.origin = origin;
      this.pattern = pattern;
      this.negative = negative;
      this.regex = regex;
    }
  };
  var createRule = (pattern, ignorecase) => {
    const origin = pattern;
    let negative = false;
    if (pattern.indexOf("!") === 0) {
      negative = true;
      pattern = pattern.substr(1);
    }
    pattern = pattern.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
    const regex = makeRegex(pattern, negative, ignorecase);
    return new IgnoreRule(origin, pattern, negative, regex);
  };
  var throwError = (message, Ctor) => {
    throw new Ctor(message);
  };
  var checkPath2 = (path10, originalPath, doThrow) => {
    if (!isString(path10)) {
      return doThrow(`path must be a string, but got \`${originalPath}\``, TypeError);
    }
    if (!path10) {
      return doThrow(`path must not be empty`, TypeError);
    }
    if (checkPath2.isNotRelative(path10)) {
      const r = "`path.relative()`d";
      return doThrow(`path should be a ${r} string, but got "${originalPath}"`, RangeError);
    }
    return true;
  };
  var isNotRelative = (path10) => REGEX_TEST_INVALID_PATH.test(path10);
  checkPath2.isNotRelative = isNotRelative;
  checkPath2.convert = (p) => p;
  var Ignore = class {
    constructor({
      ignorecase = true
    } = {}) {
      this._rules = [];
      this._ignorecase = ignorecase;
      define2(this, KEY_IGNORE, true);
      this._initCache();
    }
    _initCache() {
      this._ignoreCache = Object.create(null);
      this._testCache = Object.create(null);
    }
    _addPattern(pattern) {
      if (pattern && pattern[KEY_IGNORE]) {
        this._rules = this._rules.concat(pattern._rules);
        this._added = true;
        return;
      }
      if (checkPattern(pattern)) {
        const rule = createRule(pattern, this._ignorecase);
        this._added = true;
        this._rules.push(rule);
      }
    }
    add(pattern) {
      this._added = false;
      makeArray(isString(pattern) ? splitPattern(pattern) : pattern).forEach(this._addPattern, this);
      if (this._added) {
        this._initCache();
      }
      return this;
    }
    addPattern(pattern) {
      return this.add(pattern);
    }
    _testOne(path10, checkUnignored) {
      let ignored = false;
      let unignored = false;
      this._rules.forEach((rule) => {
        const {negative} = rule;
        if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
          return;
        }
        const matched = rule.regex.test(path10);
        if (matched) {
          ignored = !negative;
          unignored = negative;
        }
      });
      return {
        ignored,
        unignored
      };
    }
    _test(originalPath, cache, checkUnignored, slices) {
      const path10 = originalPath && checkPath2.convert(originalPath);
      checkPath2(path10, originalPath, throwError);
      return this._t(path10, cache, checkUnignored, slices);
    }
    _t(path10, cache, checkUnignored, slices) {
      if (path10 in cache) {
        return cache[path10];
      }
      if (!slices) {
        slices = path10.split(SLASH);
      }
      slices.pop();
      if (!slices.length) {
        return cache[path10] = this._testOne(path10, checkUnignored);
      }
      const parent = this._t(slices.join(SLASH) + SLASH, cache, checkUnignored, slices);
      return cache[path10] = parent.ignored ? parent : this._testOne(path10, checkUnignored);
    }
    ignores(path10) {
      return this._test(path10, this._ignoreCache, false).ignored;
    }
    createFilter() {
      return (path10) => !this.ignores(path10);
    }
    filter(paths) {
      return makeArray(paths).filter(this.createFilter());
    }
    test(path10) {
      return this._test(path10, this._testCache, true);
    }
  };
  var factory = (options) => new Ignore(options);
  var returnFalse = () => false;
  var isPathValid = (path10) => checkPath2(path10 && checkPath2.convert(path10), path10, returnFalse);
  factory.isPathValid = isPathValid;
  factory.default = factory;
  module2.exports = factory;
  if (typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")) {
    const makePosix = (str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/");
    checkPath2.convert = makePosix;
    const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
    checkPath2.isNotRelative = (path10) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path10) || isNotRelative(path10);
  }
});

// ../../node_modules/.pnpm/slash@3.0.0/node_modules/slash/index.js
var require_slash = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (path10) => {
    const isExtendedLengthPath = /^\\\\\?\\/.test(path10);
    const hasNonAscii = /[^\u0000-\u0080]+/.test(path10);
    if (isExtendedLengthPath || hasNonAscii) {
      return path10;
    }
    return path10.replace(/\\/g, "/");
  };
});

// ../../node_modules/.pnpm/globby@11.0.4/node_modules/globby/gitignore.js
var require_gitignore = __commonJS((exports2, module2) => {
  "use strict";
  var {promisify: promisify4} = require("util");
  var fs9 = require("fs");
  var path10 = require("path");
  var fastGlob = require_out4();
  var gitIgnore = require_ignore();
  var slash = require_slash();
  var DEFAULT_IGNORE = [
    "**/node_modules/**",
    "**/flow-typed/**",
    "**/coverage/**",
    "**/.git"
  ];
  var readFileP = promisify4(fs9.readFile);
  var mapGitIgnorePatternTo = (base) => (ignore) => {
    if (ignore.startsWith("!")) {
      return "!" + path10.posix.join(base, ignore.slice(1));
    }
    return path10.posix.join(base, ignore);
  };
  var parseGitIgnore = (content, options) => {
    const base = slash(path10.relative(options.cwd, path10.dirname(options.fileName)));
    return content.split(/\r?\n/).filter(Boolean).filter((line) => !line.startsWith("#")).map(mapGitIgnorePatternTo(base));
  };
  var reduceIgnore = (files) => {
    const ignores = gitIgnore();
    for (const file of files) {
      ignores.add(parseGitIgnore(file.content, {
        cwd: file.cwd,
        fileName: file.filePath
      }));
    }
    return ignores;
  };
  var ensureAbsolutePathForCwd = (cwd, p) => {
    cwd = slash(cwd);
    if (path10.isAbsolute(p)) {
      if (slash(p).startsWith(cwd)) {
        return p;
      }
      throw new Error(`Path ${p} is not in cwd ${cwd}`);
    }
    return path10.join(cwd, p);
  };
  var getIsIgnoredPredecate = (ignores, cwd) => {
    return (p) => ignores.ignores(slash(path10.relative(cwd, ensureAbsolutePathForCwd(cwd, p.path || p))));
  };
  var getFile = async (file, cwd) => {
    const filePath = path10.join(cwd, file);
    const content = await readFileP(filePath, "utf8");
    return {
      cwd,
      filePath,
      content
    };
  };
  var getFileSync = (file, cwd) => {
    const filePath = path10.join(cwd, file);
    const content = fs9.readFileSync(filePath, "utf8");
    return {
      cwd,
      filePath,
      content
    };
  };
  var normalizeOptions = ({
    ignore = [],
    cwd = slash(process.cwd())
  } = {}) => {
    return {ignore, cwd};
  };
  module2.exports = async (options) => {
    options = normalizeOptions(options);
    const paths = await fastGlob("**/.gitignore", {
      ignore: DEFAULT_IGNORE.concat(options.ignore),
      cwd: options.cwd
    });
    const files = await Promise.all(paths.map((file) => getFile(file, options.cwd)));
    const ignores = reduceIgnore(files);
    return getIsIgnoredPredecate(ignores, options.cwd);
  };
  module2.exports.sync = (options) => {
    options = normalizeOptions(options);
    const paths = fastGlob.sync("**/.gitignore", {
      ignore: DEFAULT_IGNORE.concat(options.ignore),
      cwd: options.cwd
    });
    const files = paths.map((file) => getFileSync(file, options.cwd));
    const ignores = reduceIgnore(files);
    return getIsIgnoredPredecate(ignores, options.cwd);
  };
});

// ../../node_modules/.pnpm/globby@11.0.4/node_modules/globby/stream-utils.js
var require_stream_utils = __commonJS((exports2, module2) => {
  "use strict";
  var {Transform} = require("stream");
  var ObjectTransform = class extends Transform {
    constructor() {
      super({
        objectMode: true
      });
    }
  };
  var FilterStream = class extends ObjectTransform {
    constructor(filter) {
      super();
      this._filter = filter;
    }
    _transform(data, encoding, callback) {
      if (this._filter(data)) {
        this.push(data);
      }
      callback();
    }
  };
  var UniqueStream = class extends ObjectTransform {
    constructor() {
      super();
      this._pushed = new Set();
    }
    _transform(data, encoding, callback) {
      if (!this._pushed.has(data)) {
        this.push(data);
        this._pushed.add(data);
      }
      callback();
    }
  };
  module2.exports = {
    FilterStream,
    UniqueStream
  };
});

// ../../node_modules/.pnpm/globby@11.0.4/node_modules/globby/index.js
var require_globby = __commonJS((exports2, module2) => {
  "use strict";
  var fs9 = require("fs");
  var arrayUnion = require_array_union();
  var merge2 = require_merge2();
  var fastGlob = require_out4();
  var dirGlob = require_dir_glob();
  var gitignore = require_gitignore();
  var {FilterStream, UniqueStream} = require_stream_utils();
  var DEFAULT_FILTER = () => false;
  var isNegative = (pattern) => pattern[0] === "!";
  var assertPatternsInput = (patterns) => {
    if (!patterns.every((pattern) => typeof pattern === "string")) {
      throw new TypeError("Patterns must be a string or an array of strings");
    }
  };
  var checkCwdOption = (options = {}) => {
    if (!options.cwd) {
      return;
    }
    let stat;
    try {
      stat = fs9.statSync(options.cwd);
    } catch (e) {
      return;
    }
    if (!stat.isDirectory()) {
      throw new Error("The `cwd` option must be a path to a directory");
    }
  };
  var getPathString = (p) => p.stats instanceof fs9.Stats ? p.path : p;
  var generateGlobTasks = (patterns, taskOptions) => {
    patterns = arrayUnion([].concat(patterns));
    assertPatternsInput(patterns);
    checkCwdOption(taskOptions);
    const globTasks = [];
    taskOptions = {
      ignore: [],
      expandDirectories: true,
      ...taskOptions
    };
    for (const [index, pattern] of patterns.entries()) {
      if (isNegative(pattern)) {
        continue;
      }
      const ignore = patterns.slice(index).filter((pattern2) => isNegative(pattern2)).map((pattern2) => pattern2.slice(1));
      const options = {
        ...taskOptions,
        ignore: taskOptions.ignore.concat(ignore)
      };
      globTasks.push({pattern, options});
    }
    return globTasks;
  };
  var globDirs = (task, fn) => {
    let options = {};
    if (task.options.cwd) {
      options.cwd = task.options.cwd;
    }
    if (Array.isArray(task.options.expandDirectories)) {
      options = {
        ...options,
        files: task.options.expandDirectories
      };
    } else if (typeof task.options.expandDirectories === "object") {
      options = {
        ...options,
        ...task.options.expandDirectories
      };
    }
    return fn(task.pattern, options);
  };
  var getPattern = (task, fn) => task.options.expandDirectories ? globDirs(task, fn) : [task.pattern];
  var getFilterSync = (options) => {
    return options && options.gitignore ? gitignore.sync({cwd: options.cwd, ignore: options.ignore}) : DEFAULT_FILTER;
  };
  var globToTask = (task) => (glob) => {
    const {options} = task;
    if (options.ignore && Array.isArray(options.ignore) && options.expandDirectories) {
      options.ignore = dirGlob.sync(options.ignore);
    }
    return {
      pattern: glob,
      options
    };
  };
  module2.exports = async (patterns, options) => {
    const globTasks = generateGlobTasks(patterns, options);
    const getFilter = async () => {
      return options && options.gitignore ? gitignore({cwd: options.cwd, ignore: options.ignore}) : DEFAULT_FILTER;
    };
    const getTasks = async () => {
      const tasks2 = await Promise.all(globTasks.map(async (task) => {
        const globs = await getPattern(task, dirGlob);
        return Promise.all(globs.map(globToTask(task)));
      }));
      return arrayUnion(...tasks2);
    };
    const [filter, tasks] = await Promise.all([getFilter(), getTasks()]);
    const paths = await Promise.all(tasks.map((task) => fastGlob(task.pattern, task.options)));
    return arrayUnion(...paths).filter((path_) => !filter(getPathString(path_)));
  };
  module2.exports.sync = (patterns, options) => {
    const globTasks = generateGlobTasks(patterns, options);
    const tasks = [];
    for (const task of globTasks) {
      const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));
      tasks.push(...newTask);
    }
    const filter = getFilterSync(options);
    let matches = [];
    for (const task of tasks) {
      matches = arrayUnion(matches, fastGlob.sync(task.pattern, task.options));
    }
    return matches.filter((path_) => !filter(path_));
  };
  module2.exports.stream = (patterns, options) => {
    const globTasks = generateGlobTasks(patterns, options);
    const tasks = [];
    for (const task of globTasks) {
      const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));
      tasks.push(...newTask);
    }
    const filter = getFilterSync(options);
    const filterStream = new FilterStream((p) => !filter(p));
    const uniqueStream = new UniqueStream();
    return merge2(tasks.map((task) => fastGlob.stream(task.pattern, task.options))).pipe(filterStream).pipe(uniqueStream);
  };
  module2.exports.generateGlobTasks = generateGlobTasks;
  module2.exports.hasMagic = (patterns, options) => [].concat(patterns).some((pattern) => fastGlob.isDynamicPattern(pattern, options));
  module2.exports.gitignore = gitignore;
});

// ../../node_modules/.pnpm/graceful-fs@4.2.6/node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS((exports2, module2) => {
  var constants = require("constants");
  var origCwd = process.cwd;
  var cwd = null;
  var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
  process.cwd = function() {
    if (!cwd)
      cwd = origCwd.call(process);
    return cwd;
  };
  try {
    process.cwd();
  } catch (er) {
  }
  if (typeof process.chdir === "function") {
    chdir = process.chdir;
    process.chdir = function(d2) {
      cwd = null;
      chdir.call(process, d2);
    };
    if (Object.setPrototypeOf)
      Object.setPrototypeOf(process.chdir, chdir);
  }
  var chdir;
  module2.exports = patch;
  function patch(fs9) {
    if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
      patchLchmod(fs9);
    }
    if (!fs9.lutimes) {
      patchLutimes(fs9);
    }
    fs9.chown = chownFix(fs9.chown);
    fs9.fchown = chownFix(fs9.fchown);
    fs9.lchown = chownFix(fs9.lchown);
    fs9.chmod = chmodFix(fs9.chmod);
    fs9.fchmod = chmodFix(fs9.fchmod);
    fs9.lchmod = chmodFix(fs9.lchmod);
    fs9.chownSync = chownFixSync(fs9.chownSync);
    fs9.fchownSync = chownFixSync(fs9.fchownSync);
    fs9.lchownSync = chownFixSync(fs9.lchownSync);
    fs9.chmodSync = chmodFixSync(fs9.chmodSync);
    fs9.fchmodSync = chmodFixSync(fs9.fchmodSync);
    fs9.lchmodSync = chmodFixSync(fs9.lchmodSync);
    fs9.stat = statFix(fs9.stat);
    fs9.fstat = statFix(fs9.fstat);
    fs9.lstat = statFix(fs9.lstat);
    fs9.statSync = statFixSync(fs9.statSync);
    fs9.fstatSync = statFixSync(fs9.fstatSync);
    fs9.lstatSync = statFixSync(fs9.lstatSync);
    if (!fs9.lchmod) {
      fs9.lchmod = function(path10, mode, cb) {
        if (cb)
          process.nextTick(cb);
      };
      fs9.lchmodSync = function() {
      };
    }
    if (!fs9.lchown) {
      fs9.lchown = function(path10, uid, gid, cb) {
        if (cb)
          process.nextTick(cb);
      };
      fs9.lchownSync = function() {
      };
    }
    if (platform === "win32") {
      fs9.rename = function(fs$rename) {
        return function(from, to, cb) {
          var start = Date.now();
          var backoff = 0;
          fs$rename(from, to, function CB(er) {
            if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
              setTimeout(function() {
                fs9.stat(to, function(stater, st) {
                  if (stater && stater.code === "ENOENT")
                    fs$rename(from, to, CB);
                  else
                    cb(er);
                });
              }, backoff);
              if (backoff < 100)
                backoff += 10;
              return;
            }
            if (cb)
              cb(er);
          });
        };
      }(fs9.rename);
    }
    fs9.read = function(fs$read) {
      function read(fd, buffer, offset, length, position, callback_) {
        var callback;
        if (callback_ && typeof callback_ === "function") {
          var eagCounter = 0;
          callback = function(er, _2, __) {
            if (er && er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              return fs$read.call(fs9, fd, buffer, offset, length, position, callback);
            }
            callback_.apply(this, arguments);
          };
        }
        return fs$read.call(fs9, fd, buffer, offset, length, position, callback);
      }
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(read, fs$read);
      return read;
    }(fs9.read);
    fs9.readSync = function(fs$readSync) {
      return function(fd, buffer, offset, length, position) {
        var eagCounter = 0;
        while (true) {
          try {
            return fs$readSync.call(fs9, fd, buffer, offset, length, position);
          } catch (er) {
            if (er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              continue;
            }
            throw er;
          }
        }
      };
    }(fs9.readSync);
    function patchLchmod(fs10) {
      fs10.lchmod = function(path10, mode, callback) {
        fs10.open(path10, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
          if (err) {
            if (callback)
              callback(err);
            return;
          }
          fs10.fchmod(fd, mode, function(err2) {
            fs10.close(fd, function(err22) {
              if (callback)
                callback(err2 || err22);
            });
          });
        });
      };
      fs10.lchmodSync = function(path10, mode) {
        var fd = fs10.openSync(path10, constants.O_WRONLY | constants.O_SYMLINK, mode);
        var threw = true;
        var ret;
        try {
          ret = fs10.fchmodSync(fd, mode);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs10.closeSync(fd);
            } catch (er) {
            }
          } else {
            fs10.closeSync(fd);
          }
        }
        return ret;
      };
    }
    function patchLutimes(fs10) {
      if (constants.hasOwnProperty("O_SYMLINK")) {
        fs10.lutimes = function(path10, at, mt, cb) {
          fs10.open(path10, constants.O_SYMLINK, function(er, fd) {
            if (er) {
              if (cb)
                cb(er);
              return;
            }
            fs10.futimes(fd, at, mt, function(er2) {
              fs10.close(fd, function(er22) {
                if (cb)
                  cb(er2 || er22);
              });
            });
          });
        };
        fs10.lutimesSync = function(path10, at, mt) {
          var fd = fs10.openSync(path10, constants.O_SYMLINK);
          var ret;
          var threw = true;
          try {
            ret = fs10.futimesSync(fd, at, mt);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs10.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs10.closeSync(fd);
            }
          }
          return ret;
        };
      } else {
        fs10.lutimes = function(_a, _b, _c, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs10.lutimesSync = function() {
        };
      }
    }
    function chmodFix(orig) {
      if (!orig)
        return orig;
      return function(target, mode, cb) {
        return orig.call(fs9, target, mode, function(er) {
          if (chownErOk(er))
            er = null;
          if (cb)
            cb.apply(this, arguments);
        });
      };
    }
    function chmodFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, mode) {
        try {
          return orig.call(fs9, target, mode);
        } catch (er) {
          if (!chownErOk(er))
            throw er;
        }
      };
    }
    function chownFix(orig) {
      if (!orig)
        return orig;
      return function(target, uid, gid, cb) {
        return orig.call(fs9, target, uid, gid, function(er) {
          if (chownErOk(er))
            er = null;
          if (cb)
            cb.apply(this, arguments);
        });
      };
    }
    function chownFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, uid, gid) {
        try {
          return orig.call(fs9, target, uid, gid);
        } catch (er) {
          if (!chownErOk(er))
            throw er;
        }
      };
    }
    function statFix(orig) {
      if (!orig)
        return orig;
      return function(target, options, cb) {
        if (typeof options === "function") {
          cb = options;
          options = null;
        }
        function callback(er, stats) {
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          if (cb)
            cb.apply(this, arguments);
        }
        return options ? orig.call(fs9, target, options, callback) : orig.call(fs9, target, callback);
      };
    }
    function statFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, options) {
        var stats = options ? orig.call(fs9, target, options) : orig.call(fs9, target);
        if (stats.uid < 0)
          stats.uid += 4294967296;
        if (stats.gid < 0)
          stats.gid += 4294967296;
        return stats;
      };
    }
    function chownErOk(er) {
      if (!er)
        return true;
      if (er.code === "ENOSYS")
        return true;
      var nonroot = !process.getuid || process.getuid() !== 0;
      if (nonroot) {
        if (er.code === "EINVAL" || er.code === "EPERM")
          return true;
      }
      return false;
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.6/node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS((exports2, module2) => {
  var Stream = require("stream").Stream;
  module2.exports = legacy;
  function legacy(fs9) {
    return {
      ReadStream,
      WriteStream
    };
    function ReadStream(path10, options) {
      if (!(this instanceof ReadStream))
        return new ReadStream(path10, options);
      Stream.call(this);
      var self2 = this;
      this.path = path10;
      this.fd = null;
      this.readable = true;
      this.paused = false;
      this.flags = "r";
      this.mode = 438;
      this.bufferSize = 64 * 1024;
      options = options || {};
      var keys = Object.keys(options);
      for (var index = 0, length = keys.length; index < length; index++) {
        var key = keys[index];
        this[key] = options[key];
      }
      if (this.encoding)
        this.setEncoding(this.encoding);
      if (this.start !== void 0) {
        if (typeof this.start !== "number") {
          throw TypeError("start must be a Number");
        }
        if (this.end === void 0) {
          this.end = Infinity;
        } else if (typeof this.end !== "number") {
          throw TypeError("end must be a Number");
        }
        if (this.start > this.end) {
          throw new Error("start must be <= end");
        }
        this.pos = this.start;
      }
      if (this.fd !== null) {
        process.nextTick(function() {
          self2._read();
        });
        return;
      }
      fs9.open(this.path, this.flags, this.mode, function(err, fd) {
        if (err) {
          self2.emit("error", err);
          self2.readable = false;
          return;
        }
        self2.fd = fd;
        self2.emit("open", fd);
        self2._read();
      });
    }
    function WriteStream(path10, options) {
      if (!(this instanceof WriteStream))
        return new WriteStream(path10, options);
      Stream.call(this);
      this.path = path10;
      this.fd = null;
      this.writable = true;
      this.flags = "w";
      this.encoding = "binary";
      this.mode = 438;
      this.bytesWritten = 0;
      options = options || {};
      var keys = Object.keys(options);
      for (var index = 0, length = keys.length; index < length; index++) {
        var key = keys[index];
        this[key] = options[key];
      }
      if (this.start !== void 0) {
        if (typeof this.start !== "number") {
          throw TypeError("start must be a Number");
        }
        if (this.start < 0) {
          throw new Error("start must be >= zero");
        }
        this.pos = this.start;
      }
      this.busy = false;
      this._queue = [];
      if (this.fd === null) {
        this._open = fs9.open;
        this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
        this.flush();
      }
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.6/node_modules/graceful-fs/clone.js
var require_clone = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = clone;
  var getPrototypeOf = Object.getPrototypeOf || function(obj) {
    return obj.__proto__;
  };
  function clone(obj) {
    if (obj === null || typeof obj !== "object")
      return obj;
    if (obj instanceof Object)
      var copy = {__proto__: getPrototypeOf(obj)};
    else
      var copy = Object.create(null);
    Object.getOwnPropertyNames(obj).forEach(function(key) {
      Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
    });
    return copy;
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.6/node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS((exports2, module2) => {
  var fs9 = require("fs");
  var polyfills = require_polyfills();
  var legacy = require_legacy_streams();
  var clone = require_clone();
  var util2 = require("util");
  var gracefulQueue;
  var previousSymbol;
  if (typeof Symbol === "function" && typeof Symbol.for === "function") {
    gracefulQueue = Symbol.for("graceful-fs.queue");
    previousSymbol = Symbol.for("graceful-fs.previous");
  } else {
    gracefulQueue = "___graceful-fs.queue";
    previousSymbol = "___graceful-fs.previous";
  }
  function noop() {
  }
  function publishQueue(context, queue2) {
    Object.defineProperty(context, gracefulQueue, {
      get: function() {
        return queue2;
      }
    });
  }
  var debug3 = noop;
  if (util2.debuglog)
    debug3 = util2.debuglog("gfs4");
  else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
    debug3 = function() {
      var m2 = util2.format.apply(util2, arguments);
      m2 = "GFS4: " + m2.split(/\n/).join("\nGFS4: ");
      console.error(m2);
    };
  if (!fs9[gracefulQueue]) {
    queue = global[gracefulQueue] || [];
    publishQueue(fs9, queue);
    fs9.close = function(fs$close) {
      function close2(fd, cb) {
        return fs$close.call(fs9, fd, function(err) {
          if (!err) {
            retry();
          }
          if (typeof cb === "function")
            cb.apply(this, arguments);
        });
      }
      Object.defineProperty(close2, previousSymbol, {
        value: fs$close
      });
      return close2;
    }(fs9.close);
    fs9.closeSync = function(fs$closeSync) {
      function closeSync(fd) {
        fs$closeSync.apply(fs9, arguments);
        retry();
      }
      Object.defineProperty(closeSync, previousSymbol, {
        value: fs$closeSync
      });
      return closeSync;
    }(fs9.closeSync);
    if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
      process.on("exit", function() {
        debug3(fs9[gracefulQueue]);
        require("assert").equal(fs9[gracefulQueue].length, 0);
      });
    }
  }
  var queue;
  if (!global[gracefulQueue]) {
    publishQueue(global, fs9[gracefulQueue]);
  }
  module2.exports = patch(clone(fs9));
  if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs9.__patched) {
    module2.exports = patch(fs9);
    fs9.__patched = true;
  }
  function patch(fs10) {
    polyfills(fs10);
    fs10.gracefulify = patch;
    fs10.createReadStream = createReadStream;
    fs10.createWriteStream = createWriteStream;
    var fs$readFile = fs10.readFile;
    fs10.readFile = readFile3;
    function readFile3(path10, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$readFile(path10, options, cb);
      function go$readFile(path11, options2, cb2) {
        return fs$readFile(path11, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$readFile, [path11, options2, cb2]]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
            retry();
          }
        });
      }
    }
    var fs$writeFile = fs10.writeFile;
    fs10.writeFile = writeFile2;
    function writeFile2(path10, data, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$writeFile(path10, data, options, cb);
      function go$writeFile(path11, data2, options2, cb2) {
        return fs$writeFile(path11, data2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$writeFile, [path11, data2, options2, cb2]]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
            retry();
          }
        });
      }
    }
    var fs$appendFile = fs10.appendFile;
    if (fs$appendFile)
      fs10.appendFile = appendFile;
    function appendFile(path10, data, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$appendFile(path10, data, options, cb);
      function go$appendFile(path11, data2, options2, cb2) {
        return fs$appendFile(path11, data2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$appendFile, [path11, data2, options2, cb2]]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
            retry();
          }
        });
      }
    }
    var fs$copyFile = fs10.copyFile;
    if (fs$copyFile)
      fs10.copyFile = copyFile2;
    function copyFile2(src, dest, flags, cb) {
      if (typeof flags === "function") {
        cb = flags;
        flags = 0;
      }
      return fs$copyFile(src, dest, flags, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([fs$copyFile, [src, dest, flags, cb]]);
        else {
          if (typeof cb === "function")
            cb.apply(this, arguments);
          retry();
        }
      });
    }
    var fs$readdir = fs10.readdir;
    fs10.readdir = readdir2;
    function readdir2(path10, options, cb) {
      var args2 = [path10];
      if (typeof options !== "function") {
        args2.push(options);
      } else {
        cb = options;
      }
      args2.push(go$readdir$cb);
      return go$readdir(args2);
      function go$readdir$cb(err, files) {
        if (files && files.sort)
          files.sort();
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$readdir, [args2]]);
        else {
          if (typeof cb === "function")
            cb.apply(this, arguments);
          retry();
        }
      }
    }
    function go$readdir(args2) {
      return fs$readdir.apply(fs10, args2);
    }
    if (process.version.substr(0, 4) === "v0.8") {
      var legStreams = legacy(fs10);
      ReadStream = legStreams.ReadStream;
      WriteStream = legStreams.WriteStream;
    }
    var fs$ReadStream = fs10.ReadStream;
    if (fs$ReadStream) {
      ReadStream.prototype = Object.create(fs$ReadStream.prototype);
      ReadStream.prototype.open = ReadStream$open;
    }
    var fs$WriteStream = fs10.WriteStream;
    if (fs$WriteStream) {
      WriteStream.prototype = Object.create(fs$WriteStream.prototype);
      WriteStream.prototype.open = WriteStream$open;
    }
    Object.defineProperty(fs10, "ReadStream", {
      get: function() {
        return ReadStream;
      },
      set: function(val) {
        ReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(fs10, "WriteStream", {
      get: function() {
        return WriteStream;
      },
      set: function(val) {
        WriteStream = val;
      },
      enumerable: true,
      configurable: true
    });
    var FileReadStream = ReadStream;
    Object.defineProperty(fs10, "FileReadStream", {
      get: function() {
        return FileReadStream;
      },
      set: function(val) {
        FileReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    var FileWriteStream = WriteStream;
    Object.defineProperty(fs10, "FileWriteStream", {
      get: function() {
        return FileWriteStream;
      },
      set: function(val) {
        FileWriteStream = val;
      },
      enumerable: true,
      configurable: true
    });
    function ReadStream(path10, options) {
      if (this instanceof ReadStream)
        return fs$ReadStream.apply(this, arguments), this;
      else
        return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
    }
    function ReadStream$open() {
      var that = this;
      open3(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          if (that.autoClose)
            that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
          that.read();
        }
      });
    }
    function WriteStream(path10, options) {
      if (this instanceof WriteStream)
        return fs$WriteStream.apply(this, arguments), this;
      else
        return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
    }
    function WriteStream$open() {
      var that = this;
      open3(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
        }
      });
    }
    function createReadStream(path10, options) {
      return new fs10.ReadStream(path10, options);
    }
    function createWriteStream(path10, options) {
      return new fs10.WriteStream(path10, options);
    }
    var fs$open = fs10.open;
    fs10.open = open3;
    function open3(path10, flags, mode, cb) {
      if (typeof mode === "function")
        cb = mode, mode = null;
      return go$open(path10, flags, mode, cb);
      function go$open(path11, flags2, mode2, cb2) {
        return fs$open(path11, flags2, mode2, function(err, fd) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$open, [path11, flags2, mode2, cb2]]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
            retry();
          }
        });
      }
    }
    return fs10;
  }
  function enqueue(elem) {
    debug3("ENQUEUE", elem[0].name, elem[1]);
    fs9[gracefulQueue].push(elem);
  }
  function retry() {
    var elem = fs9[gracefulQueue].shift();
    if (elem) {
      debug3("RETRY", elem[0].name, elem[1]);
      elem[0].apply(null, elem[1]);
    }
  }
});

// ../../node_modules/.pnpm/is-path-cwd@2.2.0/node_modules/is-path-cwd/index.js
var require_is_path_cwd = __commonJS((exports2, module2) => {
  "use strict";
  var path10 = require("path");
  module2.exports = (path_) => {
    let cwd = process.cwd();
    path_ = path10.resolve(path_);
    if (process.platform === "win32") {
      cwd = cwd.toLowerCase();
      path_ = path_.toLowerCase();
    }
    return path_ === cwd;
  };
});

// ../../node_modules/.pnpm/is-path-inside@3.0.3/node_modules/is-path-inside/index.js
var require_is_path_inside = __commonJS((exports2, module2) => {
  "use strict";
  var path10 = require("path");
  module2.exports = (childPath2, parentPath) => {
    const relation = path10.relative(parentPath, childPath2);
    return Boolean(relation && relation !== ".." && !relation.startsWith(`..${path10.sep}`) && relation !== path10.resolve(childPath2));
  };
});

// ../../node_modules/.pnpm/del@6.0.0/node_modules/del/index.js
var require_del = __commonJS((exports2, module2) => {
  "use strict";
  var {promisify: promisify4} = require("util");
  var path10 = require("path");
  var globby = require_globby();
  var isGlob = require_is_glob();
  var slash = require_slash();
  var gracefulFs = require_graceful_fs();
  var isPathCwd = require_is_path_cwd();
  var isPathInside = require_is_path_inside();
  var rimraf = require_rimraf();
  var pMap = require_p_map2();
  var rimrafP = promisify4(rimraf);
  var rimrafOptions = {
    glob: false,
    unlink: gracefulFs.unlink,
    unlinkSync: gracefulFs.unlinkSync,
    chmod: gracefulFs.chmod,
    chmodSync: gracefulFs.chmodSync,
    stat: gracefulFs.stat,
    statSync: gracefulFs.statSync,
    lstat: gracefulFs.lstat,
    lstatSync: gracefulFs.lstatSync,
    rmdir: gracefulFs.rmdir,
    rmdirSync: gracefulFs.rmdirSync,
    readdir: gracefulFs.readdir,
    readdirSync: gracefulFs.readdirSync
  };
  function safeCheck(file, cwd) {
    if (isPathCwd(file)) {
      throw new Error("Cannot delete the current working directory. Can be overridden with the `force` option.");
    }
    if (!isPathInside(file, cwd)) {
      throw new Error("Cannot delete files/directories outside the current working directory. Can be overridden with the `force` option.");
    }
  }
  function normalizePatterns(patterns) {
    patterns = Array.isArray(patterns) ? patterns : [patterns];
    patterns = patterns.map((pattern) => {
      if (process.platform === "win32" && isGlob(pattern) === false) {
        return slash(pattern);
      }
      return pattern;
    });
    return patterns;
  }
  module2.exports = async (patterns, {force, dryRun, cwd = process.cwd(), ...options} = {}) => {
    options = {
      expandDirectories: false,
      onlyFiles: false,
      followSymbolicLinks: false,
      cwd,
      ...options
    };
    patterns = normalizePatterns(patterns);
    const files = (await globby(patterns, options)).sort((a, b) => b.localeCompare(a));
    const mapper = async (file) => {
      file = path10.resolve(cwd, file);
      if (!force) {
        safeCheck(file, cwd);
      }
      if (!dryRun) {
        await rimrafP(file, rimrafOptions);
      }
      return file;
    };
    const removedFiles = await pMap(files, mapper, options);
    removedFiles.sort((a, b) => a.localeCompare(b));
    return removedFiles;
  };
  module2.exports.sync = (patterns, {force, dryRun, cwd = process.cwd(), ...options} = {}) => {
    options = {
      expandDirectories: false,
      onlyFiles: false,
      followSymbolicLinks: false,
      cwd,
      ...options
    };
    patterns = normalizePatterns(patterns);
    const files = globby.sync(patterns, options).sort((a, b) => b.localeCompare(a));
    const removedFiles = files.map((file) => {
      file = path10.resolve(cwd, file);
      if (!force) {
        safeCheck(file, cwd);
      }
      if (!dryRun) {
        rimraf.sync(file, rimrafOptions);
      }
      return file;
    });
    removedFiles.sort((a, b) => a.localeCompare(b));
    return removedFiles;
  };
});

// ../../node_modules/.pnpm/tempy@1.0.1/node_modules/tempy/index.js
var require_tempy = __commonJS((exports2, module2) => {
  "use strict";
  var fs9 = require("fs");
  var path10 = require("path");
  var uniqueString = require_unique_string();
  var tempDir = require_temp_dir();
  var isStream = require_is_stream();
  var del = require_del();
  var stream = require("stream");
  var {promisify: promisify4} = require("util");
  var pipeline = promisify4(stream.pipeline);
  var {writeFile: writeFile2} = fs9.promises;
  var getPath = (prefix = "") => path10.join(tempDir, prefix + uniqueString());
  var writeStream = async (filePath, data) => pipeline(data, fs9.createWriteStream(filePath));
  var createTask = (tempyFunction, {extraArguments = 0} = {}) => async (...arguments_) => {
    const [callback, options] = arguments_.slice(extraArguments);
    const result = await tempyFunction(...arguments_.slice(0, extraArguments), options);
    try {
      return await callback(result);
    } finally {
      await del(result, {force: true});
    }
  };
  module2.exports.file = (options) => {
    options = {
      ...options
    };
    if (options.name) {
      if (options.extension !== void 0 && options.extension !== null) {
        throw new Error("The `name` and `extension` options are mutually exclusive");
      }
      return path10.join(module2.exports.directory(), options.name);
    }
    return getPath() + (options.extension === void 0 || options.extension === null ? "" : "." + options.extension.replace(/^\./, ""));
  };
  module2.exports.file.task = createTask(module2.exports.file);
  module2.exports.directory = ({prefix = ""} = {}) => {
    const directory = getPath(prefix);
    fs9.mkdirSync(directory);
    return directory;
  };
  module2.exports.directory.task = createTask(module2.exports.directory);
  module2.exports.write = async (data, options) => {
    const filename = module2.exports.file(options);
    const write2 = isStream(data) ? writeStream : writeFile2;
    await write2(filename, data);
    return filename;
  };
  module2.exports.write.task = createTask(module2.exports.write, {extraArguments: 1});
  module2.exports.writeSync = (data, options) => {
    const filename = module2.exports.file(options);
    fs9.writeFileSync(filename, data);
    return filename;
  };
  Object.defineProperty(module2.exports, "root", {
    get() {
      return tempDir;
    }
  });
});

// ../../node_modules/.pnpm/hasha@5.2.2/node_modules/hasha/index.js
var require_hasha = __commonJS((exports2, module2) => {
  "use strict";
  var fs9 = require("fs");
  var path10 = require("path");
  var crypto2 = require("crypto");
  var isStream = require_is_stream();
  var {Worker} = (() => {
    try {
      return require("worker_threads");
    } catch (_2) {
      return {};
    }
  })();
  var worker;
  var taskIdCounter = 0;
  var tasks = new Map();
  var recreateWorkerError = (sourceError) => {
    const error = new Error(sourceError.message);
    for (const [key, value] of Object.entries(sourceError)) {
      if (key !== "message") {
        error[key] = value;
      }
    }
    return error;
  };
  var createWorker = () => {
    worker = new Worker(path10.join(__dirname, "thread.js"));
    worker.on("message", (message) => {
      const task = tasks.get(message.id);
      tasks.delete(message.id);
      if (tasks.size === 0) {
        worker.unref();
      }
      if (message.error === void 0) {
        task.resolve(message.value);
      } else {
        task.reject(recreateWorkerError(message.error));
      }
    });
    worker.on("error", (error) => {
      throw error;
    });
  };
  var taskWorker = (method, args2, transferList) => new Promise((resolve, reject) => {
    const id = taskIdCounter++;
    tasks.set(id, {resolve, reject});
    if (worker === void 0) {
      createWorker();
    }
    worker.ref();
    worker.postMessage({id, method, args: args2}, transferList);
  });
  var hasha = (input, options = {}) => {
    let outputEncoding = options.encoding || "hex";
    if (outputEncoding === "buffer") {
      outputEncoding = void 0;
    }
    const hash = crypto2.createHash(options.algorithm || "sha512");
    const update = (buffer) => {
      const inputEncoding = typeof buffer === "string" ? "utf8" : void 0;
      hash.update(buffer, inputEncoding);
    };
    if (Array.isArray(input)) {
      input.forEach(update);
    } else {
      update(input);
    }
    return hash.digest(outputEncoding);
  };
  hasha.stream = (options = {}) => {
    let outputEncoding = options.encoding || "hex";
    if (outputEncoding === "buffer") {
      outputEncoding = void 0;
    }
    const stream = crypto2.createHash(options.algorithm || "sha512");
    stream.setEncoding(outputEncoding);
    return stream;
  };
  hasha.fromStream = async (stream, options = {}) => {
    if (!isStream(stream)) {
      throw new TypeError("Expected a stream");
    }
    return new Promise((resolve, reject) => {
      stream.on("error", reject).pipe(hasha.stream(options)).on("error", reject).on("finish", function() {
        resolve(this.read());
      });
    });
  };
  if (Worker === void 0) {
    hasha.fromFile = async (filePath, options) => hasha.fromStream(fs9.createReadStream(filePath), options);
    hasha.async = async (input, options) => hasha(input, options);
  } else {
    hasha.fromFile = async (filePath, {algorithm = "sha512", encoding = "hex"} = {}) => {
      const hash = await taskWorker("hashFile", [algorithm, filePath]);
      if (encoding === "buffer") {
        return Buffer.from(hash);
      }
      return Buffer.from(hash).toString(encoding);
    };
    hasha.async = async (input, {algorithm = "sha512", encoding = "hex"} = {}) => {
      if (encoding === "buffer") {
        encoding = void 0;
      }
      const hash = await taskWorker("hash", [algorithm, input]);
      if (encoding === void 0) {
        return Buffer.from(hash);
      }
      return Buffer.from(hash).toString(encoding);
    };
  }
  hasha.fromFileSync = (filePath, options) => hasha(fs9.readFileSync(filePath), options);
  module2.exports = hasha;
});

// ../../node_modules/.pnpm/@prisma+fetch-engine@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/fetch-engine/dist/downloadZip.js
var require_downloadZip = __commonJS((exports2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.downloadZip = void 0;
  var zlib_1 = __importDefault2(require("zlib"));
  var p_retry_1 = __importDefault2(require_p_retry());
  var node_fetch_1 = __importDefault2(require_lib4());
  var fs_12 = __importDefault2(require("fs"));
  var getProxyAgent_1 = require_getProxyAgent();
  var tempy_1 = __importDefault2(require_tempy());
  var path_12 = __importDefault2(require("path"));
  var debug_12 = __importDefault2(require_dist3());
  var hasha_1 = __importDefault2(require_hasha());
  var util_12 = require("util");
  var rimraf_1 = __importDefault2(require_rimraf());
  var debug3 = debug_12.default("prisma:downloadZip");
  var del = util_12.promisify(rimraf_1.default);
  async function fetchSha256(url) {
    const [zippedSha256, sha256] = [
      (await node_fetch_1.default(`${url}.sha256`, {
        agent: getProxyAgent_1.getProxyAgent(url)
      }).then((res) => res.text())).split(/\s+/)[0],
      (await node_fetch_1.default(`${url.slice(0, url.length - 3)}.sha256`, {
        agent: getProxyAgent_1.getProxyAgent(url.slice(0, url.length - 3))
      }).then((res) => res.text())).split(/\s+/)[0]
    ];
    return {sha256, zippedSha256};
  }
  async function downloadZip(url, target, progressCb) {
    const tmpDir = tempy_1.default.directory();
    const partial = path_12.default.join(tmpDir, "partial");
    const {sha256, zippedSha256} = await fetchSha256(url);
    const result = await p_retry_1.default(async () => {
      try {
        const resp = await node_fetch_1.default(url, {
          compress: false,
          agent: getProxyAgent_1.getProxyAgent(url)
        });
        if (resp.status !== 200) {
          throw new Error(resp.statusText + " " + url);
        }
        const lastModified = resp.headers.get("last-modified");
        const size = parseFloat(resp.headers.get("content-length"));
        const ws = fs_12.default.createWriteStream(partial);
        return await new Promise(async (resolve, reject) => {
          let bytesRead = 0;
          resp.body.on("error", reject).on("data", (chunk) => {
            bytesRead += chunk.length;
            if (size && progressCb) {
              progressCb(bytesRead / size);
            }
          });
          const gunzip = zlib_1.default.createGunzip();
          gunzip.on("error", reject);
          const zipStream = resp.body.pipe(gunzip);
          const zippedHashPromise = hasha_1.default.fromStream(resp.body, {
            algorithm: "sha256"
          });
          const hashPromise = hasha_1.default.fromStream(zipStream, {
            algorithm: "sha256"
          });
          zipStream.pipe(ws);
          ws.on("error", reject).on("close", () => {
            resolve({lastModified, sha256, zippedSha256});
          });
          const hash = await hashPromise;
          const zippedHash = await zippedHashPromise;
          if (zippedHash !== zippedSha256) {
            throw new Error(`sha256 of ${url} (zipped) should be ${zippedSha256} but is ${zippedHash}`);
          }
          if (hash !== sha256) {
            throw new Error(`sha256 of ${url} (uzipped) should be ${sha256} but is ${hash}`);
          }
        });
      } finally {
      }
    }, {
      retries: 2,
      onFailedAttempt: (err) => debug3(err)
    });
    fs_12.default.copyFileSync(partial, target);
    try {
      await del(partial);
      await del(tmpDir);
    } catch (e) {
      debug3(e);
    }
    return result;
  }
  exports2.downloadZip = downloadZip;
});

// ../../node_modules/.pnpm/@prisma+fetch-engine@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/fetch-engine/dist/flatMap.js
var require_flatMap = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.flatMap = void 0;
  function flatten(array) {
    return Array.prototype.concat.apply([], array);
  }
  function flatMap(array, callbackFn, thisArg) {
    return flatten(array.map(callbackFn, thisArg));
  }
  exports2.flatMap = flatMap;
});

// ../../node_modules/.pnpm/@prisma+fetch-engine@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/fetch-engine/dist/getHash.js
var require_getHash = __commonJS((exports2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getHash = void 0;
  var crypto_1 = __importDefault2(require("crypto"));
  var fs_12 = __importDefault2(require("fs"));
  function getHash(filePath) {
    const hash = crypto_1.default.createHash("sha256");
    const input = fs_12.default.createReadStream(filePath);
    return new Promise((resolve) => {
      input.on("readable", () => {
        const data = input.read();
        if (data) {
          hash.update(data);
        } else {
          resolve(hash.digest("hex"));
        }
      });
    });
  }
  exports2.getHash = getHash;
});

// ../../node_modules/.pnpm/@prisma+fetch-engine@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/fetch-engine/dist/getLatestTag.js
var require_getLatestTag = __commonJS((exports2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.urlExists = exports2.getAllUrls = exports2.getLatestTag = void 0;
  var get_platform_12 = require_dist4();
  var chalk_12 = __importDefault2(require_source());
  var execa_12 = __importDefault2(require_execa());
  var node_fetch_1 = __importDefault2(require_lib4());
  var p_map_1 = __importDefault2(require_p_map2());
  var getProxyAgent_1 = require_getProxyAgent();
  var util_12 = require_util2();
  async function getLatestTag() {
    let branch = await getBranch();
    if (branch !== "master" && !isPatchBranch(branch) && !branch.startsWith("integration/")) {
      branch = "master";
    }
    branch = branch.replace(/^integration\//, "");
    let commits = await getCommits(branch);
    if ((!commits || !Array.isArray(commits)) && branch !== "master" && !isPatchBranch(branch)) {
      console.log(`Overwriting branch "${branch}" with "master" as it's not a branch we have binaries for`);
      branch = "master";
      commits = await getCommits(branch);
    }
    if (!Array.isArray(commits)) {
      console.error(commits);
      throw new Error(`Could not fetch commits from github: ${JSON.stringify(commits, null, 2)}`);
    }
    return getFirstFinishedCommit(branch, commits);
  }
  exports2.getLatestTag = getLatestTag;
  function getAllUrls(branch, commit) {
    const urls = [];
    const excludedPlatforms = [
      "freebsd",
      "arm",
      "linux-nixos",
      "openbsd",
      "netbsd",
      "freebsd11",
      "freebsd12"
    ];
    const relevantPlatforms = get_platform_12.platforms.filter((p) => !excludedPlatforms.includes(p));
    for (const platform of relevantPlatforms) {
      for (const engine of [
        "query-engine",
        "introspection-engine",
        "migration-engine",
        "prisma-fmt"
      ]) {
        for (const extension of [
          ".gz",
          ".gz.sha256",
          ".gz.sig",
          ".sig",
          ".sha256"
        ]) {
          const downloadUrl = util_12.getDownloadUrl(branch, commit, platform, engine, extension);
          urls.push(downloadUrl);
        }
      }
    }
    return urls;
  }
  exports2.getAllUrls = getAllUrls;
  async function getFirstFinishedCommit(branch, commits) {
    for (const commit of commits) {
      const urls = getAllUrls(branch, commit);
      const exist = await p_map_1.default(urls, urlExists, {concurrency: 10});
      const hasMissing = exist.some((e) => !e);
      if (!hasMissing) {
        return commit;
      } else {
        const missing = urls.filter((_2, i) => !exist[i]);
        if (missing.length !== urls.length) {
          console.log(`${chalk_12.default.blueBright("info")} The engine commit ${commit} is not yet done. We're skipping it as we're in dev. Missing urls: ${missing.length}`);
        }
      }
    }
  }
  async function urlExists(url) {
    try {
      const res = await node_fetch_1.default(url, {
        method: "HEAD",
        agent: getProxyAgent_1.getProxyAgent(url)
      });
      const headers = fromEntries(res.headers.entries());
      if (res.status > 200) {
      }
      if (parseInt(headers["content-length"]) > 0) {
        return res.status < 300;
      }
    } catch (e) {
    }
    return false;
  }
  exports2.urlExists = urlExists;
  function fromEntries(entries) {
    const result = {};
    for (const [key, value] of entries) {
      result[key] = value;
    }
    return result;
  }
  async function getBranch() {
    if (process.env.NODE_ENV !== "test") {
      if (process.env.PATCH_BRANCH) {
        return process.env.PATCH_BRANCH;
      }
      if (process.env.BUILDKITE_BRANCH) {
        return process.env.BUILDKITE_BRANCH;
      }
      if (process.env.GITHUB_CONTEXT) {
        const context = JSON.parse(process.env.GITHUB_CONTEXT);
        return context.head_ref;
      }
    }
    try {
      const result = await execa_12.default.command("git rev-parse --abbrev-ref HEAD", {
        shell: true,
        stdio: "pipe"
      });
      return result.stdout;
    } catch (e) {
      console.error(e);
    }
    return;
  }
  function isPatchBranch(version) {
    return /^2\.(\d+)\.x/.test(version);
  }
  async function getCommits(branch) {
    const url = `https://github-cache.prisma.workers.dev/repos/prisma/prisma-engines/commits?sha=${branch}`;
    const result = await node_fetch_1.default(url, {
      agent: getProxyAgent_1.getProxyAgent(url),
      headers: {
        Authorization: process.env.GITHUB_TOKEN ? `token ${process.env.GITHUB_TOKEN}` : void 0
      }
    }).then((res) => res.json());
    if (!Array.isArray(result)) {
      return result;
    }
    const commits = result.map((r) => r.sha);
    return commits;
  }
});

// ../../node_modules/.pnpm/progress@2.0.3/node_modules/progress/lib/node-progress.js
var require_node_progress = __commonJS((exports2, module2) => {
  /*!
   * node-progress
   * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>
   * MIT Licensed
   */
  exports2 = module2.exports = ProgressBar;
  function ProgressBar(fmt, options) {
    this.stream = options.stream || process.stderr;
    if (typeof options == "number") {
      var total = options;
      options = {};
      options.total = total;
    } else {
      options = options || {};
      if (typeof fmt != "string")
        throw new Error("format required");
      if (typeof options.total != "number")
        throw new Error("total required");
    }
    this.fmt = fmt;
    this.curr = options.curr || 0;
    this.total = options.total;
    this.width = options.width || this.total;
    this.clear = options.clear;
    this.chars = {
      complete: options.complete || "=",
      incomplete: options.incomplete || "-",
      head: options.head || (options.complete || "=")
    };
    this.renderThrottle = options.renderThrottle !== 0 ? options.renderThrottle || 16 : 0;
    this.lastRender = -Infinity;
    this.callback = options.callback || function() {
    };
    this.tokens = {};
    this.lastDraw = "";
  }
  ProgressBar.prototype.tick = function(len, tokens) {
    if (len !== 0)
      len = len || 1;
    if (typeof len == "object")
      tokens = len, len = 1;
    if (tokens)
      this.tokens = tokens;
    if (this.curr == 0)
      this.start = new Date();
    this.curr += len;
    this.render();
    if (this.curr >= this.total) {
      this.render(void 0, true);
      this.complete = true;
      this.terminate();
      this.callback(this);
      return;
    }
  };
  ProgressBar.prototype.render = function(tokens, force) {
    force = force !== void 0 ? force : false;
    if (tokens)
      this.tokens = tokens;
    if (!this.stream.isTTY)
      return;
    var now = Date.now();
    var delta = now - this.lastRender;
    if (!force && delta < this.renderThrottle) {
      return;
    } else {
      this.lastRender = now;
    }
    var ratio = this.curr / this.total;
    ratio = Math.min(Math.max(ratio, 0), 1);
    var percent = Math.floor(ratio * 100);
    var incomplete, complete, completeLength;
    var elapsed = new Date() - this.start;
    var eta = percent == 100 ? 0 : elapsed * (this.total / this.curr - 1);
    var rate = this.curr / (elapsed / 1e3);
    var str = this.fmt.replace(":current", this.curr).replace(":total", this.total).replace(":elapsed", isNaN(elapsed) ? "0.0" : (elapsed / 1e3).toFixed(1)).replace(":eta", isNaN(eta) || !isFinite(eta) ? "0.0" : (eta / 1e3).toFixed(1)).replace(":percent", percent.toFixed(0) + "%").replace(":rate", Math.round(rate));
    var availableSpace = Math.max(0, this.stream.columns - str.replace(":bar", "").length);
    if (availableSpace && process.platform === "win32") {
      availableSpace = availableSpace - 1;
    }
    var width = Math.min(this.width, availableSpace);
    completeLength = Math.round(width * ratio);
    complete = Array(Math.max(0, completeLength + 1)).join(this.chars.complete);
    incomplete = Array(Math.max(0, width - completeLength + 1)).join(this.chars.incomplete);
    if (completeLength > 0)
      complete = complete.slice(0, -1) + this.chars.head;
    str = str.replace(":bar", complete + incomplete);
    if (this.tokens)
      for (var key in this.tokens)
        str = str.replace(":" + key, this.tokens[key]);
    if (this.lastDraw !== str) {
      this.stream.cursorTo(0);
      this.stream.write(str);
      this.stream.clearLine(1);
      this.lastDraw = str;
    }
  };
  ProgressBar.prototype.update = function(ratio, tokens) {
    var goal = Math.floor(ratio * this.total);
    var delta = goal - this.curr;
    this.tick(delta, tokens);
  };
  ProgressBar.prototype.interrupt = function(message) {
    this.stream.clearLine();
    this.stream.cursorTo(0);
    this.stream.write(message);
    this.stream.write("\n");
    this.stream.write(this.lastDraw);
  };
  ProgressBar.prototype.terminate = function() {
    if (this.clear) {
      if (this.stream.clearLine) {
        this.stream.clearLine();
        this.stream.cursorTo(0);
      }
    } else {
      this.stream.write("\n");
    }
  };
});

// ../../node_modules/.pnpm/progress@2.0.3/node_modules/progress/index.js
var require_progress = __commonJS((exports2, module2) => {
  module2.exports = require_node_progress();
});

// ../../node_modules/.pnpm/@prisma+fetch-engine@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/fetch-engine/dist/log.js
var require_log = __commonJS((exports2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getBar = void 0;
  var progress_1 = __importDefault2(require_progress());
  function getBar(text) {
    return new progress_1.default(`> ${text} [:bar] :percent`, {
      stream: process.stdout,
      width: 20,
      complete: "=",
      incomplete: " ",
      total: 100,
      head: "",
      clear: true
    });
  }
  exports2.getBar = getBar;
});

// ../../node_modules/.pnpm/@prisma+fetch-engine@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/fetch-engine/dist/download.js
var require_download = __commonJS((exports, module) => {
  "use strict";
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.plusX = exports.maybeCopyToTmp = exports.getBinaryEnvVarPath = exports.getBinaryName = exports.checkVersionCommand = exports.getVersion = exports.download = exports.BinaryType = void 0;
  var debug_1 = __importDefault(require_dist3());
  var get_platform_1 = require_dist4();
  var chalk_1 = __importDefault(require_source());
  var execa_1 = __importDefault(require_execa());
  var fs_1 = __importDefault(require("fs"));
  var make_dir_1 = __importDefault(require_make_dir());
  var p_filter_1 = __importDefault(require_p_filter());
  var path_1 = __importDefault(require("path"));
  var temp_dir_1 = __importDefault(require_temp_dir());
  var util_1 = require("util");
  var chmod_1 = __importDefault(require_chmod());
  var cleanupCache_1 = require_cleanupCache();
  var downloadZip_1 = require_downloadZip();
  var flatMap_1 = require_flatMap();
  var getHash_1 = require_getHash();
  var getLatestTag_1 = require_getLatestTag();
  var log_1 = require_log();
  var util_2 = require_util2();
  var debug = debug_1.default("prisma:download");
  var writeFile = util_1.promisify(fs_1.default.writeFile);
  var exists = util_1.promisify(fs_1.default.exists);
  var readFile = util_1.promisify(fs_1.default.readFile);
  var copyFile = util_1.promisify(fs_1.default.copyFile);
  var utimes = util_1.promisify(fs_1.default.utimes);
  var channel = "master";
  var BinaryType;
  (function(BinaryType3) {
    BinaryType3["queryEngine"] = "query-engine";
    BinaryType3["libqueryEngine"] = "libquery-engine";
    BinaryType3["migrationEngine"] = "migration-engine";
    BinaryType3["introspectionEngine"] = "introspection-engine";
    BinaryType3["prismaFmt"] = "prisma-fmt";
  })(BinaryType = exports.BinaryType || (exports.BinaryType = {}));
  var BINARY_TO_ENV_VAR = {
    [BinaryType.migrationEngine]: "PRISMA_MIGRATION_ENGINE_BINARY",
    [BinaryType.queryEngine]: "PRISMA_QUERY_ENGINE_BINARY",
    [BinaryType.libqueryEngine]: "PRISMA_QUERY_ENGINE_LIBRARY",
    [BinaryType.introspectionEngine]: "PRISMA_INTROSPECTION_ENGINE_BINARY",
    [BinaryType.prismaFmt]: "PRISMA_FMT_BINARY"
  };
  async function download(options) {
    var _a, _b;
    const platform = await get_platform_1.getPlatform();
    const os = await get_platform_1.getos();
    if (os.distro && ["nixos"].includes(os.distro)) {
      console.error(`${chalk_1.default.yellow("Warning")} Precompiled binaries are not available for ${os.distro}.`);
    } else if (["freebsd11", "freebsd12", "openbsd", "netbsd"].includes(platform)) {
      console.error(`${chalk_1.default.yellow("Warning")} Precompiled binaries are not available for ${platform}. Read more about building your own binaries at https://pris.ly/d/build-binaries`);
    } else if (BinaryType.libqueryEngine in options.binaries) {
      await get_platform_1.isNodeAPISupported();
    }
    if (!options.binaries || Object.values(options.binaries).length === 0) {
      return {};
    }
    const opts = {
      ...options,
      binaryTargets: (_a = options.binaryTargets) !== null && _a !== void 0 ? _a : [platform],
      version: (_b = options.version) !== null && _b !== void 0 ? _b : "latest",
      binaries: mapKeys(options.binaries, (key) => engineTypeToBinaryType(key, platform))
    };
    const binaryJobs = flatMap_1.flatMap(Object.entries(opts.binaries), ([binaryName, targetFolder]) => opts.binaryTargets.map((binaryTarget) => {
      const fileName = binaryName === BinaryType.libqueryEngine ? get_platform_1.getNodeAPIName(binaryTarget, "fs") : getBinaryName(binaryName, binaryTarget);
      const targetFilePath = path_1.default.join(targetFolder, fileName);
      return {
        binaryName,
        targetFolder,
        binaryTarget,
        fileName,
        targetFilePath,
        envVarPath: getBinaryEnvVarPath(binaryName)
      };
    }));
    if (process.env.BINARY_DOWNLOAD_VERSION) {
      opts.version = process.env.BINARY_DOWNLOAD_VERSION;
    }
    if (opts.version === "latest") {
      opts.version = await getLatestTag_1.getLatestTag();
    }
    if (opts.printVersion) {
      console.log(`version: ${opts.version}`);
    }
    const binariesToDownload = await p_filter_1.default(binaryJobs, async (job) => {
      const needsToBeDownloaded = await binaryNeedsToBeDownloaded(job, platform, opts.version, opts.failSilent);
      const isSupported = get_platform_1.platforms.includes(job.binaryTarget);
      const shouldDownload = isSupported && !job.envVarPath && (opts.ignoreCache || needsToBeDownloaded);
      if (needsToBeDownloaded && !isSupported) {
        throw new Error(`Unknown binaryTarget ${job.binaryTarget} and no custom binaries were provided`);
      }
      return shouldDownload;
    });
    if (binariesToDownload.length > 0) {
      const cleanupPromise = cleanupCache_1.cleanupCache();
      let finishBar;
      let setProgress;
      if (opts.showProgress) {
        const collectiveBar = getCollectiveBar(opts);
        finishBar = collectiveBar.finishBar;
        setProgress = collectiveBar.setProgress;
      }
      await Promise.all(binariesToDownload.map((job) => downloadBinary({
        ...job,
        version: opts.version,
        failSilent: opts.failSilent,
        progressCb: setProgress ? setProgress(job.targetFilePath) : void 0
      })));
      await cleanupPromise;
      if (finishBar) {
        finishBar();
      }
    }
    const binaryPaths = binaryJobsToBinaryPaths(binaryJobs);
    const dir = eval("__dirname");
    if (dir.startsWith("/snapshot/")) {
      for (const engineType in binaryPaths) {
        const binaryTargets = binaryPaths[engineType];
        for (const binaryTarget in binaryTargets) {
          const binaryPath = binaryTargets[binaryTarget];
          binaryTargets[binaryTarget] = await maybeCopyToTmp(binaryPath);
        }
      }
    }
    return binaryPaths;
  }
  exports.download = download;
  function getCollectiveBar(options) {
    var _a, _b;
    const hasNodeAPI = "libquery-engine" in options.binaries;
    const bar = log_1.getBar(`Downloading Prisma engines${hasNodeAPI ? " for Node-API" : ""} for ${(_a = options.binaryTargets) === null || _a === void 0 ? void 0 : _a.map((p) => chalk_1.default.bold(p)).join(" and ")}`);
    const progressMap = {};
    const numDownloads = Object.values(options.binaries).length * Object.values((_b = options === null || options === void 0 ? void 0 : options.binaryTargets) !== null && _b !== void 0 ? _b : []).length;
    const setProgress = (sourcePath) => (progress) => {
      progressMap[sourcePath] = progress;
      const progressValues = Object.values(progressMap);
      const totalProgress = progressValues.reduce((acc, curr) => {
        return acc + curr;
      }, 0) / numDownloads;
      if (options.progressCb) {
        options.progressCb(totalProgress);
      }
      if (bar) {
        bar.update(totalProgress);
      }
    };
    return {
      setProgress,
      finishBar: () => {
        bar.update(1);
        bar.terminate();
      }
    };
  }
  function binaryJobsToBinaryPaths(jobs) {
    return jobs.reduce((acc, job) => {
      if (!acc[job.binaryName]) {
        acc[job.binaryName] = {};
      }
      acc[job.binaryName][job.binaryTarget] = job.envVarPath || job.targetFilePath;
      return acc;
    }, {});
  }
  async function binaryNeedsToBeDownloaded(job, nativePlatform, version, failSilent) {
    if (job.envVarPath && fs_1.default.existsSync(job.envVarPath)) {
      return false;
    }
    const targetExists = await exists(job.targetFilePath);
    const cachedFile = await getCachedBinaryPath({
      ...job,
      version,
      failSilent
    });
    if (cachedFile) {
      const sha256FilePath = cachedFile + ".sha256";
      if (await exists(sha256FilePath)) {
        const sha256File = await readFile(sha256FilePath, "utf-8");
        const sha256Cache = await getHash_1.getHash(cachedFile);
        if (sha256File === sha256Cache) {
          if (!targetExists) {
            debug(`copying ${cachedFile} to ${job.targetFilePath}`);
            await utimes(cachedFile, new Date(), new Date());
            await copyFile(cachedFile, job.targetFilePath);
          }
          const targetSha256 = await getHash_1.getHash(job.targetFilePath);
          if (sha256File !== targetSha256) {
            debug(`overwriting ${job.targetFilePath} with ${cachedFile} as hashes do not match`);
            await copyFile(cachedFile, job.targetFilePath);
          }
          return false;
        } else {
          return true;
        }
      } else {
        return true;
      }
    }
    if (!targetExists) {
      debug(`file ${job.targetFilePath} does not exist and must be downloaded`);
      return true;
    }
    if (job.binaryTarget === nativePlatform && job.binaryName !== BinaryType.libqueryEngine) {
      const works = await checkVersionCommand(job.targetFilePath);
      return !works;
    }
    return false;
  }
  async function getVersion(enginePath) {
    const result = await execa_1.default(enginePath, ["--version"]);
    return result.stdout;
  }
  exports.getVersion = getVersion;
  async function checkVersionCommand(enginePath) {
    try {
      const version = await getVersion(enginePath);
      return version.length > 0;
    } catch (e) {
      return false;
    }
  }
  exports.checkVersionCommand = checkVersionCommand;
  function getBinaryName(binaryName, platform) {
    if (binaryName === BinaryType.libqueryEngine) {
      return `${get_platform_1.getNodeAPIName(platform, "url")}`;
    }
    const extension = platform === "windows" ? ".exe" : "";
    return `${binaryName}-${platform}${extension}`;
  }
  exports.getBinaryName = getBinaryName;
  async function getCachedBinaryPath({version, binaryTarget, binaryName}) {
    const cacheDir = await util_2.getCacheDir(channel, version, binaryTarget);
    if (!cacheDir) {
      return null;
    }
    const cachedTargetPath = path_1.default.join(cacheDir, binaryName);
    if (!fs_1.default.existsSync(cachedTargetPath)) {
      return null;
    }
    if (version !== "latest") {
      return cachedTargetPath;
    }
    if (await exists(cachedTargetPath)) {
      return cachedTargetPath;
    }
    return null;
  }
  function getBinaryEnvVarPath(binaryName) {
    const envVar = BINARY_TO_ENV_VAR[binaryName];
    if (envVar && process.env[envVar]) {
      const envVarPath = path_1.default.resolve(process.cwd(), process.env[envVar]);
      if (!fs_1.default.existsSync(envVarPath)) {
        throw new Error(`Env var ${chalk_1.default.bold(envVar)} is provided but provided path ${chalk_1.default.underline(process.env[envVar])} can't be resolved.`);
      }
      debug(`Using env var ${chalk_1.default.bold(envVar)} for binary ${chalk_1.default.bold(binaryName)}, which points to ${chalk_1.default.underline(process.env[envVar])}`);
      return envVarPath;
    }
    return null;
  }
  exports.getBinaryEnvVarPath = getBinaryEnvVarPath;
  async function downloadBinary(options) {
    const {version, progressCb, targetFilePath, binaryTarget, binaryName} = options;
    const downloadUrl = util_2.getDownloadUrl("all_commits", version, binaryTarget, binaryName);
    const targetDir = path_1.default.dirname(targetFilePath);
    try {
      fs_1.default.accessSync(targetDir, fs_1.default.constants.W_OK);
      await make_dir_1.default(targetDir);
    } catch (e) {
      if (options.failSilent || e.code !== "EACCES") {
        return;
      } else {
        throw new Error(`Can't write to ${targetDir} please make sure you install "prisma" with the right permissions.`);
      }
    }
    debug(`Downloading ${downloadUrl} to ${targetFilePath}`);
    if (progressCb) {
      progressCb(0);
    }
    const {sha256, zippedSha256} = await downloadZip_1.downloadZip(downloadUrl, targetFilePath, progressCb);
    if (progressCb) {
      progressCb(1);
    }
    if (process.platform !== "win32") {
      chmod_1.default(targetFilePath);
    }
    await saveFileToCache(options, version, sha256, zippedSha256);
  }
  async function saveFileToCache(job, version, sha256, zippedSha256) {
    const cacheDir = await util_2.getCacheDir(channel, version, job.binaryTarget);
    if (!cacheDir) {
      return;
    }
    const cachedTargetPath = path_1.default.join(cacheDir, job.binaryName);
    const cachedSha256Path = path_1.default.join(cacheDir, job.binaryName + ".sha256");
    const cachedSha256ZippedPath = path_1.default.join(cacheDir, job.binaryName + ".gz.sha256");
    try {
      await copyFile(job.targetFilePath, cachedTargetPath);
      await writeFile(cachedSha256Path, sha256);
      await writeFile(cachedSha256ZippedPath, zippedSha256);
    } catch (e) {
      debug(e);
    }
  }
  function engineTypeToBinaryType(engineType, binaryTarget) {
    if (BinaryType[engineType]) {
      return BinaryType[engineType];
    }
    if (engineType === "native") {
      return binaryTarget;
    }
    return engineType;
  }
  function mapKeys(obj, mapper) {
    return Object.entries(obj).reduce((acc, [key, value]) => {
      acc[mapper(key)] = value;
      return acc;
    }, {});
  }
  async function maybeCopyToTmp(file) {
    const dir = eval("__dirname");
    if (dir.startsWith("/snapshot/")) {
      const targetDir = path_1.default.join(temp_dir_1.default, "prisma-binaries");
      await make_dir_1.default(targetDir);
      const target = path_1.default.join(targetDir, path_1.default.basename(file));
      const data = await readFile(file);
      await writeFile(target, data);
      plusX(target);
      return target;
    }
    return file;
  }
  exports.maybeCopyToTmp = maybeCopyToTmp;
  function plusX(file) {
    const s2 = fs_1.default.statSync(file);
    const newMode = s2.mode | 64 | 8 | 1;
    if (s2.mode === newMode) {
      return;
    }
    const base8 = newMode.toString(8).slice(-3);
    fs_1.default.chmodSync(file, base8);
  }
  exports.plusX = plusX;
});

// ../../node_modules/.pnpm/@prisma+fetch-engine@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/fetch-engine/dist/index.js
var require_dist8 = __commonJS((exports2) => {
  "use strict";
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, {enumerable: true, get: function() {
      return m2[k];
    }});
  } : function(o, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m2[k];
  });
  var __exportStar2 = exports2 && exports2.__exportStar || function(m2, exports3) {
    for (var p in m2)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m2, p);
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getProxyAgent = exports2.urlExists = exports2.getLatestTag = exports2.getAllUrls = void 0;
  __exportStar2(require_download(), exports2);
  var getLatestTag_12 = require_getLatestTag();
  Object.defineProperty(exports2, "getAllUrls", {enumerable: true, get: function() {
    return getLatestTag_12.getAllUrls;
  }});
  Object.defineProperty(exports2, "getLatestTag", {enumerable: true, get: function() {
    return getLatestTag_12.getLatestTag;
  }});
  Object.defineProperty(exports2, "urlExists", {enumerable: true, get: function() {
    return getLatestTag_12.urlExists;
  }});
  var getProxyAgent_1 = require_getProxyAgent();
  Object.defineProperty(exports2, "getProxyAgent", {enumerable: true, get: function() {
    return getProxyAgent_1.getProxyAgent;
  }});
});

// ../../node_modules/.pnpm/@prisma+engine-core@2.30.2/node_modules/@prisma/engine-core/dist/common/errors/PrismaClientInitializationError.js
var require_PrismaClientInitializationError = __commonJS((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    PrismaClientInitializationError: () => PrismaClientInitializationError2
  });
  var PrismaClientInitializationError2 = class extends Error {
    constructor(message, clientVersion, errorCode) {
      super(message);
      this.clientVersion = clientVersion;
      this.errorCode = errorCode;
      Error.captureStackTrace(PrismaClientInitializationError2);
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientInitializationError";
    }
  };
});

// ../../node_modules/.pnpm/@prisma+engine-core@2.30.2/node_modules/@prisma/engine-core/dist/common/errors/PrismaClientKnownRequestError.js
var require_PrismaClientKnownRequestError = __commonJS((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    PrismaClientKnownRequestError: () => PrismaClientKnownRequestError2
  });
  var PrismaClientKnownRequestError2 = class extends Error {
    constructor(message, code, clientVersion, meta) {
      super(message);
      this.code = code;
      this.clientVersion = clientVersion;
      this.meta = meta;
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientKnownRequestError";
    }
  };
});

// ../../node_modules/.pnpm/@prisma+engine-core@2.30.2/node_modules/@prisma/engine-core/dist/common/errors/PrismaClientRustPanicError.js
var require_PrismaClientRustPanicError = __commonJS((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    PrismaClientRustPanicError: () => PrismaClientRustPanicError2
  });
  var PrismaClientRustPanicError2 = class extends Error {
    constructor(message, clientVersion) {
      super(message);
      this.clientVersion = clientVersion;
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientRustPanicError";
    }
  };
});

// ../../node_modules/.pnpm/@prisma+engine-core@2.30.2/node_modules/@prisma/engine-core/dist/common/errors/PrismaClientUnknownRequestError.js
var require_PrismaClientUnknownRequestError = __commonJS((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    PrismaClientUnknownRequestError: () => PrismaClientUnknownRequestError2
  });
  var PrismaClientUnknownRequestError2 = class extends Error {
    constructor(message, clientVersion) {
      super(message);
      this.clientVersion = clientVersion;
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientUnknownRequestError";
    }
  };
});

// ../../node_modules/.pnpm/@prisma+engine-core@2.30.2/node_modules/@prisma/engine-core/dist/common/Engine.js
var require_Engine = __commonJS((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    Engine: () => Engine2
  });
  var Engine2 = class {
  };
});

// ../../node_modules/.pnpm/ansi-escapes@4.3.2/node_modules/ansi-escapes/index.js
var require_ansi_escapes = __commonJS((exports2, module2) => {
  "use strict";
  var ansiEscapes = module2.exports;
  module2.exports.default = ansiEscapes;
  var ESC = "[";
  var OSC = "]";
  var BEL = "\x07";
  var SEP = ";";
  var isTerminalApp = process.env.TERM_PROGRAM === "Apple_Terminal";
  ansiEscapes.cursorTo = (x, y2) => {
    if (typeof x !== "number") {
      throw new TypeError("The `x` argument is required");
    }
    if (typeof y2 !== "number") {
      return ESC + (x + 1) + "G";
    }
    return ESC + (y2 + 1) + ";" + (x + 1) + "H";
  };
  ansiEscapes.cursorMove = (x, y2) => {
    if (typeof x !== "number") {
      throw new TypeError("The `x` argument is required");
    }
    let ret = "";
    if (x < 0) {
      ret += ESC + -x + "D";
    } else if (x > 0) {
      ret += ESC + x + "C";
    }
    if (y2 < 0) {
      ret += ESC + -y2 + "A";
    } else if (y2 > 0) {
      ret += ESC + y2 + "B";
    }
    return ret;
  };
  ansiEscapes.cursorUp = (count = 1) => ESC + count + "A";
  ansiEscapes.cursorDown = (count = 1) => ESC + count + "B";
  ansiEscapes.cursorForward = (count = 1) => ESC + count + "C";
  ansiEscapes.cursorBackward = (count = 1) => ESC + count + "D";
  ansiEscapes.cursorLeft = ESC + "G";
  ansiEscapes.cursorSavePosition = isTerminalApp ? "7" : ESC + "s";
  ansiEscapes.cursorRestorePosition = isTerminalApp ? "8" : ESC + "u";
  ansiEscapes.cursorGetPosition = ESC + "6n";
  ansiEscapes.cursorNextLine = ESC + "E";
  ansiEscapes.cursorPrevLine = ESC + "F";
  ansiEscapes.cursorHide = ESC + "?25l";
  ansiEscapes.cursorShow = ESC + "?25h";
  ansiEscapes.eraseLines = (count) => {
    let clear = "";
    for (let i = 0; i < count; i++) {
      clear += ansiEscapes.eraseLine + (i < count - 1 ? ansiEscapes.cursorUp() : "");
    }
    if (count) {
      clear += ansiEscapes.cursorLeft;
    }
    return clear;
  };
  ansiEscapes.eraseEndLine = ESC + "K";
  ansiEscapes.eraseStartLine = ESC + "1K";
  ansiEscapes.eraseLine = ESC + "2K";
  ansiEscapes.eraseDown = ESC + "J";
  ansiEscapes.eraseUp = ESC + "1J";
  ansiEscapes.eraseScreen = ESC + "2J";
  ansiEscapes.scrollUp = ESC + "S";
  ansiEscapes.scrollDown = ESC + "T";
  ansiEscapes.clearScreen = "c";
  ansiEscapes.clearTerminal = process.platform === "win32" ? `${ansiEscapes.eraseScreen}${ESC}0f` : `${ansiEscapes.eraseScreen}${ESC}3J${ESC}H`;
  ansiEscapes.beep = BEL;
  ansiEscapes.link = (text, url) => {
    return [
      OSC,
      "8",
      SEP,
      SEP,
      url,
      BEL,
      text,
      OSC,
      "8",
      SEP,
      SEP,
      BEL
    ].join("");
  };
  ansiEscapes.image = (buffer, options = {}) => {
    let ret = `${OSC}1337;File=inline=1`;
    if (options.width) {
      ret += `;width=${options.width}`;
    }
    if (options.height) {
      ret += `;height=${options.height}`;
    }
    if (options.preserveAspectRatio === false) {
      ret += ";preserveAspectRatio=0";
    }
    return ret + ":" + buffer.toString("base64") + BEL;
  };
  ansiEscapes.iTerm = {
    setCwd: (cwd = process.cwd()) => `${OSC}50;CurrentDir=${cwd}${BEL}`,
    annotation: (message, options = {}) => {
      let ret = `${OSC}1337;`;
      const hasX = typeof options.x !== "undefined";
      const hasY = typeof options.y !== "undefined";
      if ((hasX || hasY) && !(hasX && hasY && typeof options.length !== "undefined")) {
        throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");
      }
      message = message.replace(/\|/g, "");
      ret += options.isHidden ? "AddHiddenAnnotation=" : "AddAnnotation=";
      if (options.length > 0) {
        ret += (hasX ? [message, options.length, options.x, options.y] : [options.length, message]).join("|");
      } else {
        ret += message;
      }
      return ret + BEL;
    }
  };
});

// ../../node_modules/.pnpm/supports-hyperlinks@2.2.0/node_modules/supports-hyperlinks/index.js
var require_supports_hyperlinks = __commonJS((exports2, module2) => {
  "use strict";
  var supportsColor = require_supports_color();
  var hasFlag = require_has_flag();
  function parseVersion(versionString) {
    if (/^\d{3,4}$/.test(versionString)) {
      const m2 = /(\d{1,2})(\d{2})/.exec(versionString);
      return {
        major: 0,
        minor: parseInt(m2[1], 10),
        patch: parseInt(m2[2], 10)
      };
    }
    const versions = (versionString || "").split(".").map((n) => parseInt(n, 10));
    return {
      major: versions[0],
      minor: versions[1],
      patch: versions[2]
    };
  }
  function supportsHyperlink(stream) {
    const {env: env2} = process;
    if ("FORCE_HYPERLINK" in env2) {
      return !(env2.FORCE_HYPERLINK.length > 0 && parseInt(env2.FORCE_HYPERLINK, 10) === 0);
    }
    if (hasFlag("no-hyperlink") || hasFlag("no-hyperlinks") || hasFlag("hyperlink=false") || hasFlag("hyperlink=never")) {
      return false;
    }
    if (hasFlag("hyperlink=true") || hasFlag("hyperlink=always")) {
      return true;
    }
    if (!supportsColor.supportsColor(stream)) {
      return false;
    }
    if (stream && !stream.isTTY) {
      return false;
    }
    if (process.platform === "win32") {
      return false;
    }
    if ("NETLIFY" in env2) {
      return true;
    }
    if ("CI" in env2) {
      return false;
    }
    if ("TEAMCITY_VERSION" in env2) {
      return false;
    }
    if ("TERM_PROGRAM" in env2) {
      const version = parseVersion(env2.TERM_PROGRAM_VERSION);
      switch (env2.TERM_PROGRAM) {
        case "iTerm.app":
          if (version.major === 3) {
            return version.minor >= 1;
          }
          return version.major > 3;
      }
    }
    if ("VTE_VERSION" in env2) {
      if (env2.VTE_VERSION === "0.50.0") {
        return false;
      }
      const version = parseVersion(env2.VTE_VERSION);
      return version.major > 0 || version.minor >= 50;
    }
    return false;
  }
  module2.exports = {
    supportsHyperlink,
    stdout: supportsHyperlink(process.stdout),
    stderr: supportsHyperlink(process.stderr)
  };
});

// ../../node_modules/.pnpm/terminal-link@2.1.1/node_modules/terminal-link/index.js
var require_terminal_link = __commonJS((exports2, module2) => {
  "use strict";
  var ansiEscapes = require_ansi_escapes();
  var supportsHyperlinks = require_supports_hyperlinks();
  var terminalLink = (text, url, {target = "stdout", ...options} = {}) => {
    if (!supportsHyperlinks[target]) {
      if (options.fallback === false) {
        return text;
      }
      return typeof options.fallback === "function" ? options.fallback(text, url) : `${text} (\u200B${url}\u200B)`;
    }
    return ansiEscapes.link(text, url);
  };
  module2.exports = (text, url, options = {}) => terminalLink(text, url, options);
  module2.exports.stderr = (text, url, options = {}) => terminalLink(text, url, {target: "stderr", ...options});
  module2.exports.isSupported = supportsHyperlinks.stdout;
  module2.exports.stderr.isSupported = supportsHyperlinks.stderr;
});

// ../../node_modules/.pnpm/new-github-issue-url@0.2.1/node_modules/new-github-issue-url/index.js
var require_new_github_issue_url = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (options = {}) => {
    let repoUrl;
    if (options.repoUrl) {
      repoUrl = options.repoUrl;
    } else if (options.user && options.repo) {
      repoUrl = `https://github.com/${options.user}/${options.repo}`;
    } else {
      throw new Error("You need to specify either the `repoUrl` option or both the `user` and `repo` options");
    }
    const url = new URL(`${repoUrl}/issues/new`);
    const types = [
      "body",
      "title",
      "labels",
      "template",
      "milestone",
      "assignee",
      "projects"
    ];
    for (const type of types) {
      let value = options[type];
      if (value === void 0) {
        continue;
      }
      if (type === "labels" || type === "projects") {
        if (!Array.isArray(value)) {
          throw new TypeError(`The \`${type}\` option should be an array`);
        }
        value = value.join(",");
      }
      url.searchParams.set(type, value);
    }
    return url.toString();
  };
  module2.exports.default = module2.exports;
});

// ../../node_modules/.pnpm/@prisma+engine-core@2.30.2/node_modules/@prisma/engine-core/dist/common/utils/util.js
var require_util3 = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    fixBinaryTargets: () => fixBinaryTargets2,
    getGithubIssueUrl: () => getGithubIssueUrl,
    getRandomString: () => getRandomString,
    link: () => link5,
    plusX: () => plusX2
  });
  var import_fs9 = __toModule3(require("fs"));
  var import_terminal_link = __toModule3(require_terminal_link());
  var import_new_github_issue_url = __toModule3(require_new_github_issue_url());
  var import_chalk14 = __toModule3(require_source());
  var import_debug3 = __toModule3(require_dist2());
  var import_crypto = __toModule3(require("crypto"));
  var debug3 = (0, import_debug3.default)("plusX");
  function plusX2(file) {
    const s2 = import_fs9.default.statSync(file);
    const newMode = s2.mode | 64 | 8 | 1;
    if (s2.mode === newMode) {
      debug3(`Execution permissions of ${file} are fine`);
      return;
    }
    const base8 = newMode.toString(8).slice(-3);
    debug3(`Have to call plusX on ${file}`);
    import_fs9.default.chmodSync(file, base8);
  }
  function transformPlatformToEnvValue(platform) {
    return {fromEnvVar: null, value: platform};
  }
  function fixBinaryTargets2(binaryTargets, platform) {
    binaryTargets = binaryTargets || [];
    if (!binaryTargets.find((object) => object.value === "native")) {
      return [transformPlatformToEnvValue("native"), ...binaryTargets];
    }
    return [...binaryTargets, transformPlatformToEnvValue(platform)];
  }
  function link5(url) {
    return (0, import_terminal_link.default)(url, url, {
      fallback: (url2) => import_chalk14.default.underline(url2)
    });
  }
  function getGithubIssueUrl({
    title,
    user = "prisma",
    repo = "prisma",
    template = "bug_report.md",
    body
  }) {
    return (0, import_new_github_issue_url.default)({
      user,
      repo,
      template,
      title,
      body
    });
  }
  function getRandomString() {
    return import_crypto.default.randomBytes(12).toString("hex");
  }
});

// ../../node_modules/.pnpm/@prisma+engine-core@2.30.2/node_modules/@prisma/engine-core/dist/common/errors/utils/maskQuery.js
var require_maskQuery = __commonJS((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    maskQuery: () => maskQuery
  });
  function maskQuery(query) {
    if (!query) {
      return "";
    }
    return query.replace(/".*"/g, '"X"').replace(/[\s:\[]([+-]?([0-9]*[.])?[0-9]+)/g, (substr) => {
      return `${substr[0]}5`;
    });
  }
});

// ../../node_modules/.pnpm/@prisma+engine-core@2.30.2/node_modules/@prisma/engine-core/dist/common/errors/utils/normalizeLogs.js
var require_normalizeLogs = __commonJS((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    normalizeLogs: () => normalizeLogs
  });
  function normalizeLogs(logs) {
    return logs.split("\n").map((l) => {
      return l.replace(/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)\s*/, "").replace(/\+\d+\s*ms$/, "");
    }).join("\n");
  }
});

// ../../node_modules/.pnpm/@prisma+engine-core@2.30.2/node_modules/@prisma/engine-core/dist/common/errors/utils/getErrorMessageWithLink.js
var require_getErrorMessageWithLink = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    getErrorMessageWithLink: () => getErrorMessageWithLink
  });
  var import_debug3 = __toModule3(require_dist2());
  var import_util6 = __toModule3(require_util3());
  var import_strip_ansi = __toModule3(require_strip_ansi());
  var import_maskQuery = __toModule3(require_maskQuery());
  var import_normalizeLogs = __toModule3(require_normalizeLogs());
  function getErrorMessageWithLink({
    version,
    platform,
    title,
    description,
    engineVersion,
    database,
    query
  }) {
    var _a, _b;
    const gotLogs = (0, import_debug3.getLogs)(6e3 - ((_a = query == null ? void 0 : query.length) != null ? _a : 0));
    const logs = (0, import_normalizeLogs.normalizeLogs)((0, import_strip_ansi.default)(gotLogs));
    const moreInfo = description ? `# Description
\`\`\`
${description}
\`\`\`` : "";
    const body = (0, import_strip_ansi.default)(`Hi Prisma Team! My Prisma Client just crashed. This is the report:
## Versions

| Name            | Version            |
|-----------------|--------------------|
| Node            | ${(_b = process.version) == null ? void 0 : _b.padEnd(19)}| 
| OS              | ${platform == null ? void 0 : platform.padEnd(19)}|
| Prisma Client   | ${version == null ? void 0 : version.padEnd(19)}|
| Query Engine    | ${engineVersion == null ? void 0 : engineVersion.padEnd(19)}|
| Database        | ${database == null ? void 0 : database.padEnd(19)}|

${moreInfo}

## Logs
\`\`\`
${logs}
\`\`\`

## Client Snippet
\`\`\`ts
// PLEASE FILL YOUR CODE SNIPPET HERE
\`\`\`

## Schema
\`\`\`prisma
// PLEASE ADD YOUR SCHEMA HERE IF POSSIBLE
\`\`\`

## Prisma Engine Query
\`\`\`
${query ? (0, import_maskQuery.maskQuery)(query) : ""}
\`\`\`
`);
    const url = (0, import_util6.getGithubIssueUrl)({title, body});
    return `${title}

This is a non-recoverable error which probably happens when the Prisma Query Engine has a panic.

${(0, import_util6.link)(url)}

If you want the Prisma team to look into it, please open the link above \u{1F64F}
To increase the chance of success, please post your schema and a snippet of
how you used Prisma Client in the issue. 
`;
  }
});

// ../../node_modules/.pnpm/@prisma+engine-core@2.30.2/node_modules/@prisma/engine-core/dist/common/utils/printGeneratorConfig.js
var require_printGeneratorConfig = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    GeneratorConfigClass: () => GeneratorConfigClass,
    getOriginalBinaryTargetsValue: () => getOriginalBinaryTargetsValue2,
    printDatamodelObject: () => printDatamodelObject,
    printGeneratorConfig: () => printGeneratorConfig2
  });
  var import_indent_string = __toModule3(require_indent_string());
  function printGeneratorConfig2(config) {
    return String(new GeneratorConfigClass(config));
  }
  var GeneratorConfigClass = class {
    constructor(config) {
      this.config = config;
    }
    toString() {
      const {config} = this;
      const provider = config.provider.fromEnvVar ? `env("${config.provider.fromEnvVar}")` : config.provider.value;
      const obj = JSON.parse(JSON.stringify({
        provider,
        binaryTargets: getOriginalBinaryTargetsValue2(config.binaryTargets)
      }));
      return `generator ${config.name} {
${(0, import_indent_string.default)(printDatamodelObject(obj), 2)}
}`;
    }
  };
  function getOriginalBinaryTargetsValue2(binaryTargets) {
    let value;
    if (binaryTargets.length > 0) {
      const binaryTargetsFromEnvVar = binaryTargets.find((object) => object.fromEnvVar !== null);
      if (binaryTargetsFromEnvVar) {
        value = `env("${binaryTargetsFromEnvVar.fromEnvVar}")`;
      } else {
        value = binaryTargets.map((object) => object.value);
      }
    } else {
      value = void 0;
    }
    return value;
  }
  function printDatamodelObject(obj) {
    const maxLength = Object.keys(obj).reduce((max, curr) => Math.max(max, curr.length), 0);
    return Object.entries(obj).map(([key, value]) => `${key.padEnd(maxLength)} = ${niceStringify(value)}`).join("\n");
  }
  function niceStringify(value) {
    return JSON.parse(JSON.stringify(value, (_2, value2) => {
      if (Array.isArray(value2)) {
        return `[${value2.map((element) => JSON.stringify(element)).join(", ")}]`;
      }
      return JSON.stringify(value2);
    }));
  }
});

// ../../node_modules/.pnpm/@prisma+engine-core@2.30.2/node_modules/@prisma/engine-core/dist/library/LibraryEngine.js
var require_LibraryEngine = __commonJS((exports, module) => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name in all)
      __defProp(target, name, {get: all[name], enumerable: true});
  };
  var __reExport = (target, module2, desc) => {
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
      for (let key of __getOwnPropNames(module2))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule = (module2) => {
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
  };
  __export(exports, {
    LibraryEngine: () => LibraryEngine
  });
  var import_debug = __toModule(require_dist2());
  var import_engines = __toModule(require("@prisma/engines"));
  var import_get_platform = __toModule(require_dist4());
  var import_chalk = __toModule(require_source());
  var import_events = __toModule(require("events"));
  var import_fs = __toModule(require("fs"));
  var import_path = __toModule(require("path"));
  var import_Engine = __toModule(require_Engine());
  var import_PrismaClientKnownRequestError = __toModule(require_PrismaClientKnownRequestError());
  var import_PrismaClientInitializationError = __toModule(require_PrismaClientInitializationError());
  var import_PrismaClientRustPanicError = __toModule(require_PrismaClientRustPanicError());
  var import_PrismaClientUnknownRequestError = __toModule(require_PrismaClientUnknownRequestError());
  var import_getErrorMessageWithLink = __toModule(require_getErrorMessageWithLink());
  var import_printGeneratorConfig = __toModule(require_printGeneratorConfig());
  var import_util = __toModule(require_util3());
  var debug = (0, import_debug.default)("prisma:client:libraryEngine");
  function isQueryEvent(event) {
    return event["item_type"] === "query" && "query" in event;
  }
  function isPanicEvent(event) {
    return event.level === "error" && event["message"] === "PANIC";
  }
  var knownPlatforms = [...import_get_platform.platforms, "native"];
  var engines = [];
  var LibraryEngine = class extends import_Engine.Engine {
    constructor(config) {
      super();
      var _a, _b;
      this.datamodel = import_fs.default.readFileSync(config.datamodelPath, "utf-8");
      this.config = config;
      this.libraryStarted = false;
      this.logQueries = (_a = config.logQueries) != null ? _a : false;
      this.logLevel = (_b = config.logLevel) != null ? _b : "error";
      this.logEmitter = new import_events.default();
      this.logEmitter.on("error", (e) => {
      });
      this.datasourceOverrides = config.datasources ? this.convertDatasources(config.datasources) : {};
      if (config.enableEngineDebugMode) {
        this.logLevel = "debug";
      }
      this.libraryInstantiationPromise = this.instantiateLibrary();
      initHooks();
      engines.push(this);
      this.checkForTooManyEngines();
    }
    checkForTooManyEngines() {
      if (engines.length >= 10) {
        const runningEngines = engines.filter((e) => e.engine);
        if (runningEngines.length === 10) {
          console.warn(`${import_chalk.default.yellow("warn(prisma-client)")} Already 10 Prisma Clients are actively running.`);
        }
      }
    }
    async transaction(action, arg10) {
      var _a, _b, _c, _d, _e;
      await this.start();
      if (action === "start") {
        const jsonOptions = JSON.stringify({
          max_wait: (_a = arg10 == null ? void 0 : arg10.maxWait) != null ? _a : 2e3,
          timeout: (_b = arg10 == null ? void 0 : arg10.timeout) != null ? _b : 5e3
        });
        const result = await ((_c = this.engine) == null ? void 0 : _c.startTransaction(jsonOptions, "{}"));
        return this.parseEngineResponse(result);
      } else if (action === "commit") {
        await ((_d = this.engine) == null ? void 0 : _d.commitTransaction(arg10.id, "{}"));
      } else if (action === "rollback") {
        await ((_e = this.engine) == null ? void 0 : _e.rollbackTransaction(arg10.id, "{}"));
      }
      return void 0;
    }
    async instantiateLibrary() {
      debug("internalSetup");
      if (this.libraryInstantiationPromise) {
        return this.libraryInstantiationPromise;
      }
      await (0, import_get_platform.isNodeAPISupported)();
      this.platform = await this.getPlatform();
      await this.loadEngine();
      this.version();
    }
    async getPlatform() {
      if (this.platform)
        return this.platform;
      const platform = await (0, import_get_platform.getPlatform)();
      if (!knownPlatforms.includes(platform)) {
        throw new import_PrismaClientInitializationError.PrismaClientInitializationError(`Unknown ${import_chalk.default.red("PRISMA_QUERY_ENGINE_LIBRARY")} ${import_chalk.default.redBright.bold(this.platform)}. Possible binaryTargets: ${import_chalk.default.greenBright(knownPlatforms.join(", "))} or a path to the query engine library.
You may have to run ${import_chalk.default.greenBright("prisma generate")} for your changes to take effect.`, this.config.clientVersion);
      }
      return platform;
    }
    parseEngineResponse(response) {
      if (!response) {
        throw new import_PrismaClientUnknownRequestError.PrismaClientUnknownRequestError(`Response from the Engine was empty`, this.config.clientVersion);
      }
      try {
        const config = JSON.parse(response);
        return config;
      } catch (err) {
        throw new import_PrismaClientUnknownRequestError.PrismaClientUnknownRequestError(`Unable to JSON.parse response from engine`, this.config.clientVersion);
      }
    }
    convertDatasources(datasources) {
      const obj = Object.create(null);
      for (const {name, url} of datasources) {
        obj[name] = url;
      }
      return obj;
    }
    async loadEngine() {
      var _a;
      if (!this.libQueryEnginePath) {
        this.libQueryEnginePath = await this.getLibQueryEnginePath();
      }
      debug(`loadEngine using ${this.libQueryEnginePath}`);
      if (!this.engine) {
        if (!this.QueryEngineConstructor) {
          try {
            this.library = eval("require")(this.libQueryEnginePath);
            this.QueryEngineConstructor = this.library.QueryEngine;
          } catch (e) {
            if (import_fs.default.existsSync(this.libQueryEnginePath)) {
              if (this.libQueryEnginePath.endsWith(".node")) {
                throw new import_PrismaClientInitializationError.PrismaClientInitializationError(`Unable to load Node-API Library from ${import_chalk.default.dim(this.libQueryEnginePath)}, Library may be corrupt`, this.config.clientVersion);
              } else {
                throw new import_PrismaClientInitializationError.PrismaClientInitializationError(`Expected an Node-API Library but received ${import_chalk.default.dim(this.libQueryEnginePath)}`, this.config.clientVersion);
              }
            } else {
              throw new import_PrismaClientInitializationError.PrismaClientInitializationError(`Unable to load Node-API Library from ${import_chalk.default.dim(this.libQueryEnginePath)}, It does not exist`, this.config.clientVersion);
            }
          }
        }
        if (this.QueryEngineConstructor) {
          try {
            this.engine = new this.QueryEngineConstructor({
              datamodel: this.datamodel,
              env: process.env,
              logQueries: (_a = this.config.logQueries) != null ? _a : false,
              ignoreEnvVarErrors: false,
              datasourceOverrides: this.datasourceOverrides,
              logLevel: this.logLevel,
              configDir: this.config.cwd
            }, (err, log2) => this.logger(err, log2));
          } catch (e) {
            const error = this.parseInitError(e.message);
            if (typeof error === "string") {
              throw e;
            } else {
              throw new import_PrismaClientInitializationError.PrismaClientInitializationError(error.message, this.config.clientVersion, error.error_code);
            }
          }
        }
      }
    }
    logger(err, log2) {
      var _a;
      if (err) {
        throw err;
      }
      const event = this.parseEngineResponse(log2);
      if (!event)
        return;
      event.level = (_a = event == null ? void 0 : event.level.toLowerCase()) != null ? _a : "unknown";
      if (isQueryEvent(event)) {
        this.logEmitter.emit("query", {
          timestamp: Date.now(),
          query: event.query,
          params: event.params,
          duration: event.duration_ms,
          target: event.module_path
        });
      } else if (isPanicEvent(event)) {
        this.loggerRustPanic = new import_PrismaClientRustPanicError.PrismaClientRustPanicError(this.getErrorMessageWithLink(`${event.message}: ${event.reason} in ${event.file}:${event.line}:${event.column}`), this.config.clientVersion);
        this.logEmitter.emit("error", this.loggerRustPanic);
      } else {
        this.logEmitter.emit(event.level, event);
      }
    }
    getErrorMessageWithLink(title) {
      var _a;
      return (0, import_getErrorMessageWithLink.getErrorMessageWithLink)({
        platform: this.platform,
        title,
        version: this.config.clientVersion,
        engineVersion: (_a = this.versionInfo) == null ? void 0 : _a.version,
        database: this.config.activeProvider,
        query: this.lastQuery
      });
    }
    parseInitError(str) {
      try {
        const error = JSON.parse(str);
        if (typeof error.is_panic !== "undefined") {
          return error;
        }
      } catch (e) {
      }
      return str;
    }
    parseRequestError(str) {
      try {
        const error = JSON.parse(str);
        if (typeof error.is_panic !== "undefined") {
          return error;
        }
      } catch (e) {
      }
      return str;
    }
    on(event, listener) {
      if (event === "beforeExit") {
        this.beforeExitListener = listener;
      } else {
        this.logEmitter.on(event, listener);
      }
    }
    async runBeforeExit() {
      debug("runBeforeExit");
      if (this.beforeExitListener) {
        try {
          await this.beforeExitListener();
        } catch (e) {
          console.error(e);
        }
      }
    }
    async start() {
      await this.libraryInstantiationPromise;
      await this.libraryStoppingPromise;
      if (this.libraryStartingPromise) {
        debug(`library already starting, this.libraryStarted: ${this.libraryStarted}`);
        await this.libraryStartingPromise;
        if (this.libraryStarted) {
          return;
        }
      }
      if (!this.libraryStarted) {
        this.libraryStartingPromise = new Promise(async (res) => {
          var _a;
          debug("library starting");
          await ((_a = this.engine) == null ? void 0 : _a.connect({enableRawQueries: true}));
          this.libraryStarted = true;
          debug("library started");
          res();
        });
        return this.libraryStartingPromise;
      }
    }
    async stop() {
      await this.libraryStartingPromise;
      await this.executingQueryPromise;
      debug(`library stopping, this.libraryStarted: ${this.libraryStarted}`);
      if (this.libraryStoppingPromise) {
        debug("library is already disconnecting");
        await this.libraryStoppingPromise;
        if (!this.libraryStarted) {
          this.libraryStoppingPromise = void 0;
          return;
        }
      }
      if (this.libraryStarted) {
        this.libraryStoppingPromise = new Promise(async (res) => {
          var _a;
          await new Promise((r) => setTimeout(r, 5));
          debug("library stopping");
          await ((_a = this.engine) == null ? void 0 : _a.disconnect());
          this.libraryStarted = false;
          debug("library stopped");
          res();
        });
      }
      return this.libraryStoppingPromise;
    }
    getConfig() {
      return this.library.getConfig({
        datamodel: this.datamodel,
        datasourceOverrides: this.datasourceOverrides,
        ignoreEnvVarErrors: true,
        env: process.env
      });
    }
    version() {
      var _a, _b, _c;
      this.versionInfo = (_a = this.library) == null ? void 0 : _a.version();
      return (_c = (_b = this.versionInfo) == null ? void 0 : _b.version) != null ? _c : "unknown";
    }
    prismaGraphQLToJSError(error) {
      debug("graphQLToJSError");
      if (error.user_facing_error.error_code) {
        return new import_PrismaClientKnownRequestError.PrismaClientKnownRequestError(error.user_facing_error.message, error.user_facing_error.error_code, this.config.clientVersion, error.user_facing_error.meta);
      }
      return new import_PrismaClientUnknownRequestError.PrismaClientUnknownRequestError(error.error, this.config.clientVersion);
    }
    async request(query, headers = {}, numTry = 1) {
      var _a;
      try {
        debug(`sending request, this.libraryStarted: ${this.libraryStarted}`);
        const request = {query, variables: {}};
        const queryStr = JSON.stringify(request);
        const headerStr = JSON.stringify(headers);
        await this.start();
        this.executingQueryPromise = (_a = this.engine) == null ? void 0 : _a.query(queryStr, headerStr, headers.transactionId);
        this.lastQuery = queryStr;
        const data = this.parseEngineResponse(await this.executingQueryPromise);
        if (data.errors) {
          if (data.errors.length === 1) {
            throw this.prismaGraphQLToJSError(data.errors[0]);
          }
          throw new import_PrismaClientUnknownRequestError.PrismaClientUnknownRequestError(JSON.stringify(data.errors), this.config.clientVersion);
        } else if (this.loggerRustPanic) {
          throw this.loggerRustPanic;
        }
        return {data, elapsed: 0};
      } catch (e) {
        const error = this.parseRequestError(e.message);
        if (typeof error === "string") {
          throw e;
        } else {
          throw new import_PrismaClientUnknownRequestError.PrismaClientUnknownRequestError(`${error.message}
${error.backtrace}`, this.config.clientVersion);
        }
      }
    }
    async requestBatch(queries, headers = {}, transaction = false, numTry = 1) {
      debug("requestBatch");
      const request = {
        batch: queries.map((query) => ({query, variables: {}})),
        transaction
      };
      await this.start();
      this.lastQuery = JSON.stringify(request);
      this.executingQueryPromise = this.engine.query(this.lastQuery, JSON.stringify(headers), headers.transactionId);
      const result = await this.executingQueryPromise;
      const data = this.parseEngineResponse(result);
      if (data.errors) {
        if (data.errors.length === 1) {
          throw this.prismaGraphQLToJSError(data.errors[0]);
        }
        throw new import_PrismaClientUnknownRequestError.PrismaClientUnknownRequestError(JSON.stringify(data.errors), this.config.clientVersion);
      }
      const {batchResult, errors} = data;
      if (Array.isArray(batchResult)) {
        return batchResult.map((result2) => {
          var _a;
          if (result2.errors) {
            return (_a = this.loggerRustPanic) != null ? _a : this.prismaGraphQLToJSError(result2.errors[0]);
          }
          return {
            data: result2,
            elapsed: 0
          };
        });
      } else {
        if (errors && errors.length === 1) {
          throw new Error(errors[0].error);
        }
        throw new Error(JSON.stringify(data));
      }
    }
    async resolveEnginePath() {
      var _a, _b, _c, _d;
      const searchedLocations = [];
      let enginePath;
      if (this.libQueryEnginePath) {
        return {enginePath: this.libQueryEnginePath, searchedLocations};
      }
      this.platform = (_a = this.platform) != null ? _a : await (0, import_get_platform.getPlatform)();
      if (__filename.includes("LibraryEngine")) {
        enginePath = import_path.default.join((0, import_engines.getEnginesPath)(), (0, import_get_platform.getNodeAPIName)(this.platform, "fs"));
        return {enginePath, searchedLocations};
      }
      const searchLocations = [
        eval(`require('path').join(__dirname, '../../../.prisma/client')`),
        (_d = (_c = (_b = this.config.generator) == null ? void 0 : _b.output) == null ? void 0 : _c.value) != null ? _d : eval("__dirname"),
        import_path.default.join(eval("__dirname"), ".."),
        import_path.default.dirname(this.config.datamodelPath),
        this.config.cwd,
        "/tmp/prisma-engines"
      ];
      if (this.config.dirname) {
        searchLocations.push(this.config.dirname);
      }
      for (const location of searchLocations) {
        searchedLocations.push(location);
        debug(`Search for Query Engine Library in ${location}`);
        enginePath = import_path.default.join(location, (0, import_get_platform.getNodeAPIName)(this.platform, "fs"));
        if (import_fs.default.existsSync(enginePath)) {
          return {enginePath, searchedLocations};
        }
      }
      enginePath = import_path.default.join(__dirname, (0, import_get_platform.getNodeAPIName)(this.platform, "fs"));
      return {enginePath: enginePath != null ? enginePath : "", searchedLocations};
    }
    async getLibQueryEnginePath() {
      var _a, _b, _c, _d;
      const libPath = (_a = process.env.PRISMA_QUERY_ENGINE_LIBRARY) != null ? _a : this.config.prismaPath;
      if (libPath && import_fs.default.existsSync(libPath) && libPath.endsWith(".node")) {
        return libPath;
      }
      this.platform = (_b = this.platform) != null ? _b : await (0, import_get_platform.getPlatform)();
      const {enginePath, searchedLocations} = await this.resolveEnginePath();
      if (!import_fs.default.existsSync(enginePath)) {
        const incorrectPinnedPlatformErrorStr = this.platform ? `
You incorrectly pinned it to ${import_chalk.default.redBright.bold(`${this.platform}`)}
` : "";
        let errorText = `Query engine library for current platform "${import_chalk.default.bold(this.platform)}" could not be found.${incorrectPinnedPlatformErrorStr}
This probably happens, because you built Prisma Client on a different platform.
(Prisma Client looked in "${import_chalk.default.underline(enginePath)}")

Searched Locations:

${searchedLocations.map((f) => {
          let msg = `  ${f}`;
          if (process.env.DEBUG === "node-engine-search-locations" && import_fs.default.existsSync(f)) {
            const dir = import_fs.default.readdirSync(f);
            msg += dir.map((d2) => `    ${d2}`).join("\n");
          }
          return msg;
        }).join("\n" + (process.env.DEBUG === "node-engine-search-locations" ? "\n" : ""))}
`;
        if (this.config.generator) {
          this.platform = (_c = this.platform) != null ? _c : await (0, import_get_platform.getPlatform)();
          if (this.config.generator.binaryTargets.find((object) => object.value === this.platform) || this.config.generator.binaryTargets.find((object) => object.value === "native")) {
            errorText += `
You already added the platform${this.config.generator.binaryTargets.length > 1 ? "s" : ""} ${this.config.generator.binaryTargets.map((t) => `"${import_chalk.default.bold(t.value)}"`).join(", ")} to the "${import_chalk.default.underline("generator")}" block
in the "schema.prisma" file as described in https://pris.ly/d/client-generator,
but something went wrong. That's suboptimal.

Please create an issue at https://github.com/prisma/prisma/issues/new`;
            errorText += ``;
          } else {
            errorText += `

To solve this problem, add the platform "${this.platform}" to the "${import_chalk.default.underline("binaryTargets")}" attribute in the "${import_chalk.default.underline("generator")}" block in the "schema.prisma" file:
${import_chalk.default.greenBright(this.getFixedGenerator())}

Then run "${import_chalk.default.greenBright("prisma generate")}" for your changes to take effect.
Read more about deploying Prisma Client: https://pris.ly/d/client-generator`;
          }
        } else {
          errorText += `

Read more about deploying Prisma Client: https://pris.ly/d/client-generator
`;
        }
        throw new import_PrismaClientInitializationError.PrismaClientInitializationError(errorText, this.config.clientVersion);
      }
      this.platform = (_d = this.platform) != null ? _d : await (0, import_get_platform.getPlatform)();
      return enginePath;
    }
    getFixedGenerator() {
      const fixedGenerator = {
        ...this.config.generator,
        binaryTargets: (0, import_util.fixBinaryTargets)(this.config.generator.binaryTargets, this.platform)
      };
      return (0, import_printGeneratorConfig.printGeneratorConfig)(fixedGenerator);
    }
  };
  function hookProcess(handler, exit = false) {
    process.once(handler, async () => {
      debug(`hookProcess received: ${handler}`);
      for (const engine of engines) {
        await engine.runBeforeExit();
      }
      engines.splice(0, engines.length);
      if (exit && process.listenerCount(handler) === 0) {
        process.exit();
      }
    });
  }
  var hooksInitialized = false;
  function initHooks() {
    if (!hooksInitialized) {
      hookProcess("beforeExit");
      hookProcess("exit");
      hookProcess("SIGINT", true);
      hookProcess("SIGUSR1", true);
      hookProcess("SIGUSR2", true);
      hookProcess("SIGTERM", true);
      hooksInitialized = true;
    }
  }
});

// ../../node_modules/.pnpm/@prisma+engine-core@2.30.2/node_modules/@prisma/engine-core/dist/tools/byline.js
var require_byline = __commonJS((exports2, module2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    createLineStream: () => createLineStream,
    default: () => byline2
  });
  var stream = require("stream");
  var util2 = require("util");
  function byline2(readStream, options) {
    return module2.exports.createStream(readStream, options);
  }
  module2.exports.createStream = function(readStream, options) {
    if (readStream) {
      return createLineStream(readStream, options);
    } else {
      return new LineStream(options);
    }
  };
  function createLineStream(readStream, options) {
    if (!readStream) {
      throw new Error("expected readStream");
    }
    if (!readStream.readable) {
      throw new Error("readStream must be readable");
    }
    const ls = new LineStream(options);
    readStream.pipe(ls);
    return ls;
  }
  module2.exports.LineStream = LineStream;
  function LineStream(options) {
    stream.Transform.call(this, options);
    options = options || {};
    this._readableState.objectMode = true;
    this._lineBuffer = [];
    this._keepEmptyLines = options.keepEmptyLines || false;
    this._lastChunkEndedWithCR = false;
    this.on("pipe", function(src) {
      if (!this.encoding) {
        if (src instanceof stream.Readable) {
          this.encoding = src._readableState.encoding;
        }
      }
    });
  }
  util2.inherits(LineStream, stream.Transform);
  LineStream.prototype._transform = function(chunk, encoding, done) {
    encoding = encoding || "utf8";
    if (Buffer.isBuffer(chunk)) {
      if (encoding == "buffer") {
        chunk = chunk.toString();
        encoding = "utf8";
      } else {
        chunk = chunk.toString(encoding);
      }
    }
    this._chunkEncoding = encoding;
    const lines = chunk.split(/\r\n|\r|\n/g);
    if (this._lastChunkEndedWithCR && chunk[0] == "\n") {
      lines.shift();
    }
    if (this._lineBuffer.length > 0) {
      this._lineBuffer[this._lineBuffer.length - 1] += lines[0];
      lines.shift();
    }
    this._lastChunkEndedWithCR = chunk[chunk.length - 1] == "\r";
    this._lineBuffer = this._lineBuffer.concat(lines);
    this._pushBuffer(encoding, 1, done);
  };
  LineStream.prototype._pushBuffer = function(encoding, keep, done) {
    while (this._lineBuffer.length > keep) {
      const line = this._lineBuffer.shift();
      if (this._keepEmptyLines || line.length > 0) {
        if (!this.push(this._reencode(line, encoding))) {
          const self2 = this;
          setImmediate(function() {
            self2._pushBuffer(encoding, keep, done);
          });
          return;
        }
      }
    }
    done();
  };
  LineStream.prototype._flush = function(done) {
    this._pushBuffer(this._chunkEncoding, 0, done);
  };
  LineStream.prototype._reencode = function(line, chunkEncoding) {
    if (this.encoding && this.encoding != chunkEncoding) {
      return Buffer.from(line, chunkEncoding).toString(this.encoding);
    } else if (this.encoding) {
      return line;
    } else {
      return Buffer.from(line, chunkEncoding);
    }
  };
});

// ../../node_modules/.pnpm/@prisma+engine-core@2.30.2/node_modules/@prisma/engine-core/dist/common/errors/utils/log.js
var require_log2 = __commonJS((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    convertLog: () => convertLog,
    getBacktraceFromLog: () => getBacktraceFromLog,
    getBacktraceFromRustError: () => getBacktraceFromRustError,
    getMessage: () => getMessage,
    isRustError: () => isRustError,
    isRustErrorLog: () => isRustErrorLog,
    isRustLog: () => isRustLog
  });
  function getMessage(log2) {
    if (typeof log2 === "string") {
      return log2;
    } else if (isRustError(log2)) {
      return getBacktraceFromRustError(log2);
    } else if (isRustLog(log2)) {
      return getBacktraceFromLog(log2);
    }
    return JSON.stringify(log2);
  }
  function getBacktraceFromLog(log2) {
    var _a, _b, _c, _d, _e, _f, _g;
    if ((_a = log2.fields) == null ? void 0 : _a.message) {
      let str = (_b = log2.fields) == null ? void 0 : _b.message;
      if ((_c = log2.fields) == null ? void 0 : _c.file) {
        str += ` in ${log2.fields.file}`;
        if ((_d = log2.fields) == null ? void 0 : _d.line) {
          str += `:${log2.fields.line}`;
        }
        if ((_e = log2.fields) == null ? void 0 : _e.column) {
          str += `:${log2.fields.column}`;
        }
      }
      if ((_f = log2.fields) == null ? void 0 : _f.reason) {
        str += `
${(_g = log2.fields) == null ? void 0 : _g.reason}`;
      }
      return str;
    }
    return "Unknown error";
  }
  function getBacktraceFromRustError(err) {
    let str = "";
    if (err.is_panic) {
      str += `PANIC`;
    }
    if (err.backtrace) {
      str += ` in ${err.backtrace}`;
    }
    if (err.message) {
      str += `
${err.message}`;
    }
    return str;
  }
  function isRustLog(e) {
    return e.timestamp && typeof e.level === "string" && typeof e.target === "string";
  }
  function isRustErrorLog(e) {
    var _a, _b;
    return isRustLog(e) && (e.level === "error" || ((_b = (_a = e.fields) == null ? void 0 : _a.message) == null ? void 0 : _b.includes("fatal error")));
  }
  function isRustError(e) {
    return typeof e.is_panic !== "undefined";
  }
  function convertLog(rustLog) {
    const isQuery = isQueryLog(rustLog.fields);
    const level = isQuery ? "query" : rustLog.level.toLowerCase();
    return {
      ...rustLog,
      level,
      timestamp: new Date(new Date().getFullYear() + " " + rustLog.timestamp)
    };
  }
  function isQueryLog(fields) {
    return Boolean(fields.query);
  }
});

// ../../node_modules/.pnpm/@prisma+engine-core@2.30.2/node_modules/@prisma/engine-core/dist/common/errors/PrismaClientRustError.js
var require_PrismaClientRustError = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    PrismaClientRustError: () => PrismaClientRustError
  });
  var import_log2 = __toModule3(require_log2());
  var PrismaClientRustError = class extends Error {
    constructor({clientVersion, log: log2, error}) {
      if (log2) {
        const backtrace = (0, import_log2.getBacktraceFromLog)(log2);
        super(backtrace != null ? backtrace : "Unkown error");
      } else if (error) {
        const backtrace = (0, import_log2.getBacktraceFromRustError)(error);
        super(backtrace);
      } else {
        super(`Unknown error`);
      }
      this.clientVersion = clientVersion;
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientRustPanicError";
    }
  };
});

// ../../node_modules/.pnpm/@prisma+engine-core@2.30.2/node_modules/@prisma/engine-core/dist/tools/omit.js
var require_omit = __commonJS((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    omit: () => omit
  });
  function omit(obj, keys) {
    return Object.keys(obj).filter((key) => !keys.includes(key)).reduce((result, key) => {
      result[key] = obj[key];
      return result;
    }, {});
  }
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/node/http-parser.js
var require_http_parser = __commonJS((exports2, module2) => {
  "use strict";
  var common = require("_http_common");
  if (common.HTTPParser) {
    module2.exports = common.HTTPParser;
  } else {
    module2.exports = process.binding("http_parser").HTTPParser;
  }
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/core/symbols.js
var require_symbols = __commonJS((exports2, module2) => {
  module2.exports = {
    kUrl: Symbol("url"),
    kWriting: Symbol("writing"),
    kResuming: Symbol("resuming"),
    kQueue: Symbol("queue"),
    kConnect: Symbol("connect"),
    kIdleTimeout: Symbol("idle timeout"),
    kIdleTimeoutValue: Symbol("idle timeout value"),
    kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
    kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
    kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
    kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
    kKeepAlive: Symbol("keep alive"),
    kHeadersTimeout: Symbol("headers timeout"),
    kBodyTimeout: Symbol("body timeout"),
    kTLSServerName: Symbol("server name"),
    kHost: Symbol("host"),
    kTLSOpts: Symbol("TLS Options"),
    kClosed: Symbol("closed"),
    kNeedDrain: Symbol("need drain"),
    kReset: Symbol("reset"),
    kDestroyed: Symbol("destroyed"),
    kMaxHeadersSize: Symbol("max headers size"),
    kRunningIdx: Symbol("running index"),
    kPendingIdx: Symbol("pending index"),
    kError: Symbol("error"),
    kClient: Symbol("client"),
    kParser: Symbol("parser"),
    kOnDestroyed: Symbol("destroy callbacks"),
    kPipelining: Symbol("pipelinig"),
    kSocketPath: Symbol("socket path"),
    kSocket: Symbol("socket"),
    kTLSSession: Symbol("tls session cache"),
    kHostHeader: Symbol("host header"),
    kAgentOpts: Symbol("agent opts"),
    kAgentCache: Symbol("agent cache")
  };
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/core/errors.js
var require_errors = __commonJS((exports2, module2) => {
  "use strict";
  var UndiciError = class extends Error {
    constructor(message) {
      super(message);
      this.name = "UndiciError";
      this.code = "UND_ERR";
    }
  };
  var HeadersTimeoutError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, HeadersTimeoutError);
      this.name = "HeadersTimeoutError";
      this.message = message || "Headers Timeout Error";
      this.code = "UND_ERR_HEADERS_TIMEOUT";
    }
  };
  var BodyTimeoutError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, BodyTimeoutError);
      this.name = "BodyTimeoutError";
      this.message = message || "Body Timeout Error";
      this.code = "UND_ERR_BODY_TIMEOUT";
    }
  };
  var InvalidArgumentError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, InvalidArgumentError);
      this.name = "InvalidArgumentError";
      this.message = message || "Invalid Argument Error";
      this.code = "UND_ERR_INVALID_ARG";
    }
  };
  var InvalidReturnValueError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, InvalidReturnValueError);
      this.name = "InvalidReturnValueError";
      this.message = message || "Invalid Return Value Error";
      this.code = "UND_ERR_INVALID_RETURN_VALUE";
    }
  };
  var RequestAbortedError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, RequestAbortedError);
      this.name = "RequestAbortedError";
      this.message = message || "Request aborted";
      this.code = "UND_ERR_ABORTED";
    }
  };
  var InformationalError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, InformationalError);
      this.name = "InformationalError";
      this.message = message || "Request information";
      this.code = "UND_ERR_INFO";
    }
  };
  var ContentLengthMismatchError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ContentLengthMismatchError);
      this.name = "ContentLengthMismatchError";
      this.message = message || "Request body length does not match content-length header";
      this.code = "UND_ERR_CONTENT_LENGTH_MISMATCH";
    }
  };
  var TrailerMismatchError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, TrailerMismatchError);
      this.name = "TrailerMismatchError";
      this.message = message || "Trailers does not match trailer header";
      this.code = "UND_ERR_TRAILER_MISMATCH";
    }
  };
  var ClientDestroyedError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ClientDestroyedError);
      this.name = "ClientDestroyedError";
      this.message = message || "The client is destroyed";
      this.code = "UND_ERR_DESTROYED";
    }
  };
  var ClientClosedError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ClientClosedError);
      this.name = "ClientClosedError";
      this.message = message || "The client is closed";
      this.code = "UND_ERR_CLOSED";
    }
  };
  var SocketError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, SocketError);
      this.name = "SocketError";
      this.message = message || "Socket error";
      this.code = "UND_ERR_SOCKET";
    }
  };
  var NotSupportedError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, NotSupportedError);
      this.name = "NotSupportedError";
      this.message = message || "Not supported error";
      this.code = "UND_ERR_NOT_SUPPORTED";
    }
  };
  module2.exports = {
    UndiciError,
    HeadersTimeoutError,
    BodyTimeoutError,
    ContentLengthMismatchError,
    TrailerMismatchError,
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError,
    ClientDestroyedError,
    ClientClosedError,
    InformationalError,
    SocketError,
    NotSupportedError
  };
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/core/util.js
var require_util4 = __commonJS((exports2, module2) => {
  "use strict";
  var assert = require("assert");
  var {kDestroyed} = require_symbols();
  var {IncomingMessage} = require("http");
  var util2 = require("util");
  var net = require("net");
  var {InvalidArgumentError} = require_errors();
  function nop() {
  }
  function isStream(body) {
    return !!(body && typeof body.on === "function");
  }
  function parseURL(url) {
    if (typeof url === "string") {
      url = new URL(url);
    }
    if (!url || typeof url !== "object") {
      throw new InvalidArgumentError("invalid url");
    }
    if (url.port != null && url.port !== "" && !Number.isFinite(parseInt(url.port))) {
      throw new InvalidArgumentError("invalid port");
    }
    if (url.hostname != null && typeof url.hostname !== "string") {
      throw new InvalidArgumentError("invalid hostname");
    }
    if (!/https?/.test(url.protocol)) {
      throw new InvalidArgumentError("invalid protocol");
    }
    if (!(url instanceof URL)) {
      const port = url.port || {
        "http:": 80,
        "https:": 443
      }[url.protocol];
      assert(port != null);
      const path10 = url.path || `${url.pathname || "/"}${url.search || ""}`;
      url = new URL(`${url.protocol}//${url.hostname}:${port}${path10}`);
    }
    return url;
  }
  function parseOrigin(url) {
    url = parseURL(url);
    if (/\/.+/.test(url.pathname) || url.search || url.hash) {
      throw new InvalidArgumentError("invalid url");
    }
    return url;
  }
  function getServerName(host) {
    if (!host) {
      return null;
    }
    let servername = host;
    if (servername.startsWith("[")) {
      const idx = servername.indexOf("]");
      servername = idx === -1 ? servername : servername.substr(1, idx - 1);
    } else {
      servername = servername.split(":", 1)[0];
    }
    if (net.isIP(servername)) {
      servername = null;
    }
    return servername;
  }
  function bodyLength(body) {
    if (body && typeof body.on === "function") {
      const state = body._readableState;
      return state && state.ended === true && Number.isFinite(state.length) ? state.length : null;
    }
    assert(!body || Number.isFinite(body.byteLength));
    return body ? body.length : 0;
  }
  function isDestroyed(stream) {
    return !stream || !!(stream.destroyed || stream[kDestroyed]);
  }
  function destroy(stream, err) {
    if (!isStream(stream) || isDestroyed(stream)) {
      return;
    }
    if (typeof stream.destroy === "function") {
      if (err || Object.getPrototypeOf(stream).constructor !== IncomingMessage) {
        stream.destroy(err);
      }
    } else if (err) {
      process.nextTick((stream2, err2) => {
        stream2.emit("error", err2);
      }, stream, err);
    }
    if (stream.destroyed !== true) {
      stream[kDestroyed] = true;
    }
  }
  var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
  function parseKeepAliveTimeout(val) {
    const m2 = val.match(KEEPALIVE_TIMEOUT_EXPR);
    return m2 ? parseInt(m2[1]) * 1e3 : null;
  }
  function parseHeaders(headers, obj = {}) {
    for (let i = 0; i < headers.length; i += 2) {
      const key = headers[i].toLowerCase();
      let val = obj[key];
      if (!val) {
        obj[key] = headers[i + 1];
      } else {
        if (!Array.isArray(val)) {
          val = [val];
          obj[key] = val;
        }
        val.push(headers[i + 1]);
      }
    }
    return obj;
  }
  function isBuffer(buffer) {
    return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
  }
  function errnoException(code, syscall) {
    const name = util2.getSystemErrorName(code);
    const err = new Error(`${syscall} ${name}`);
    err.errno = err;
    err.code = code;
    err.syscall = syscall;
    return err;
  }
  module2.exports = {
    nop,
    parseOrigin,
    parseURL,
    getServerName,
    errnoException,
    isStream,
    isDestroyed,
    parseHeaders,
    parseKeepAliveTimeout,
    destroy,
    bodyLength,
    isBuffer,
    queueMicrotask: global.queueMicrotask ? global.queueMicrotask.bind(global) : (cb) => Promise.resolve().then(cb).catch((err) => setTimeout(() => {
      throw err;
    }, 0))
  };
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/core/request.js
var require_request = __commonJS((exports2, module2) => {
  "use strict";
  var {
    InvalidArgumentError,
    NotSupportedError
  } = require_errors();
  var util2 = require_util4();
  var assert = require("assert");
  var kHandler = Symbol("handler");
  var REGEXP_ABSOLUTE_URL = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\x00a1-\xffff0-9]+-?)*[a-z\x00a1-\xffff0-9]+)(?:\.(?:[a-z\x00a1-\xffff0-9]+-?)*[a-z\x00a1-\xffff0-9]+)*(?:\.(?:[a-z\x00a1-\xffff]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/ius;
  var Request2 = class {
    constructor({
      path: path10,
      method,
      body,
      headers,
      idempotent,
      upgrade
    }, handler) {
      if (typeof path10 !== "string") {
        throw new InvalidArgumentError("path must be a string");
      } else if (path10[0] !== "/" && !REGEXP_ABSOLUTE_URL.test(path10)) {
        throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
      }
      if (typeof method !== "string") {
        throw new InvalidArgumentError("method must be a string");
      }
      if (upgrade && typeof upgrade !== "string") {
        throw new InvalidArgumentError("upgrade must be a string");
      }
      this.method = method;
      if (body == null) {
        this.body = null;
      } else if (util2.isStream(body)) {
        this.body = body;
      } else if (util2.isBuffer(body)) {
        this.body = body.length ? body : null;
      } else if (typeof body === "string") {
        this.body = body.length ? Buffer.from(body) : null;
      } else {
        throw new InvalidArgumentError("body must be a string, a Buffer or a Readable stream");
      }
      this.aborted = false;
      this.upgrade = upgrade || method === "CONNECT" || null;
      this.path = path10;
      this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
      this.host = null;
      this.contentLength = null;
      this.headers = "";
      if (Array.isArray(headers)) {
        if (headers.length % 2 !== 0) {
          throw new InvalidArgumentError("headers array must be even");
        }
        for (let i = 0; i < headers.length; i += 2) {
          processHeader(this, headers[i + 0], headers[i + 1]);
        }
      } else if (headers && typeof headers === "object") {
        for (const [key, val] of Object.entries(headers)) {
          processHeader(this, key, val);
        }
      } else if (headers != null) {
        throw new InvalidArgumentError("headers must be an object or an array");
      }
      if (typeof handler.onConnect !== "function") {
        throw new InvalidArgumentError("invalid onConnect method");
      }
      if (typeof handler.onError !== "function") {
        throw new InvalidArgumentError("invalid onError method");
      }
      if (this.upgrade) {
        if (typeof handler.onUpgrade !== "function") {
          throw new InvalidArgumentError("invalid onUpgrade method");
        }
      } else {
        if (typeof handler.onHeaders !== "function") {
          throw new InvalidArgumentError("invalid onHeaders method");
        }
        if (typeof handler.onData !== "function") {
          throw new InvalidArgumentError("invalid onData method");
        }
        if (typeof handler.onComplete !== "function") {
          throw new InvalidArgumentError("invalid onComplete method");
        }
      }
      this[kHandler] = handler;
    }
    onConnect(abort) {
      assert(!this.aborted);
      return this[kHandler].onConnect(abort);
    }
    onHeaders(statusCode, headers, resume) {
      assert(!this.aborted);
      return this[kHandler].onHeaders(statusCode, headers, resume);
    }
    onData(chunk) {
      assert(!this.aborted);
      assert(!this.upgrade);
      return this[kHandler].onData(chunk);
    }
    onUpgrade(statusCode, headers, socket) {
      assert(!this.aborted);
      assert(this.upgrade);
      return this[kHandler].onUpgrade(statusCode, headers, socket);
    }
    onComplete(trailers) {
      assert(!this.aborted);
      assert(!this.upgrade);
      return this[kHandler].onComplete(trailers);
    }
    onError(err) {
      if (this.aborted) {
        return;
      }
      this.aborted = true;
      util2.queueMicrotask(() => this[kHandler].onError(err));
    }
  };
  function processHeader(request, key, val) {
    if (val && typeof val === "object") {
      throw new InvalidArgumentError(`invalid ${key} header`);
    } else if (val === void 0) {
      return;
    }
    if (request.host === null && key.length === 4 && key.toLowerCase() === "host") {
      request.host = val;
      request.headers += `${key}: ${val}\r
`;
    } else if (request.contentLength === null && key.length === 14 && key.toLowerCase() === "content-length") {
      request.contentLength = parseInt(val);
      if (!Number.isFinite(request.contentLength)) {
        throw new InvalidArgumentError("invalid content-length header");
      }
    } else if (key.length === 17 && key.toLowerCase() === "transfer-encoding") {
      throw new InvalidArgumentError("invalid transfer-encoding header");
    } else if (key.length === 10 && key.toLowerCase() === "connection") {
      throw new InvalidArgumentError("invalid connection header");
    } else if (key.length === 10 && key.toLowerCase() === "keep-alive") {
      throw new InvalidArgumentError("invalid keep-alive header");
    } else if (key.length === 7 && key.toLowerCase() === "upgrade") {
      throw new InvalidArgumentError("invalid upgrade header");
    } else if (key.length === 6 && key.toLowerCase() === "expect") {
      throw new NotSupportedError("expect header not supported");
    } else {
      request.headers += `${key}: ${val}\r
`;
    }
  }
  module2.exports = Request2;
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/core/client.js
var require_client = __commonJS((exports2, module2) => {
  "use strict";
  var net = require("net");
  var tls = require("tls");
  var HTTPParser = require_http_parser();
  var EventEmitter = require("events");
  var assert = require("assert");
  var util2 = require_util4();
  var Request2 = require_request();
  var {
    ContentLengthMismatchError,
    TrailerMismatchError,
    InvalidArgumentError,
    RequestAbortedError,
    HeadersTimeoutError,
    ClientDestroyedError,
    ClientClosedError,
    SocketError,
    InformationalError,
    BodyTimeoutError
  } = require_errors();
  var {
    kUrl,
    kReset,
    kHost,
    kClient,
    kParser,
    kConnect,
    kResuming,
    kWriting,
    kQueue,
    kNeedDrain,
    kTLSServerName,
    kKeepAliveDefaultTimeout,
    kHostHeader,
    kTLSOpts,
    kClosed,
    kDestroyed,
    kPendingIdx,
    kRunningIdx,
    kError,
    kOnDestroyed,
    kPipelining,
    kSocket,
    kSocketPath,
    kKeepAliveTimeoutValue,
    kMaxHeadersSize,
    kKeepAliveMaxTimeout,
    kKeepAliveTimeoutThreshold,
    kTLSSession,
    kIdleTimeout,
    kIdleTimeoutValue,
    kHeadersTimeout,
    kBodyTimeout
  } = require_symbols();
  var nodeVersions = process.version.split(".");
  var nodeMajorVersion = parseInt(nodeVersions[0].slice(1));
  var nodeMinorVersion = parseInt(nodeVersions[1]);
  var insecureHTTPParser = process.execArgv.includes("--insecure-http-parser");
  function getServerName(client, host) {
    return util2.getServerName(host) || client[kTLSOpts] && client[kTLSOpts].servername || util2.getServerName(client[kUrl].host || client[kUrl].hostname) || null;
  }
  var Client = class extends EventEmitter {
    constructor(url, {
      maxHeaderSize,
      headersTimeout,
      socketTimeout,
      requestTimeout,
      bodyTimeout,
      idleTimeout,
      keepAlive,
      keepAliveTimeout,
      maxKeepAliveTimeout,
      keepAliveMaxTimeout,
      keepAliveTimeoutThreshold,
      socketPath,
      pipelining,
      tls: tls2
    } = {}) {
      super();
      if (keepAlive !== void 0) {
        throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
      }
      if (socketTimeout !== void 0) {
        throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
      }
      if (requestTimeout !== void 0) {
        throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
      }
      if (idleTimeout !== void 0) {
        throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
      }
      if (maxKeepAliveTimeout !== void 0) {
        throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
      }
      if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
        throw new InvalidArgumentError("invalid maxHeaderSize");
      }
      if (socketPath != null && typeof socketPath !== "string") {
        throw new InvalidArgumentError("invalid socketPath");
      }
      if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
        throw new InvalidArgumentError("invalid keepAliveTimeout");
      }
      if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
        throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
      }
      if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
        throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
      }
      if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
        throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
      }
      if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
        throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
      }
      this[kSocket] = null;
      this[kPipelining] = pipelining != null ? pipelining : 1;
      this[kMaxHeadersSize] = maxHeaderSize || 16384;
      this[kUrl] = util2.parseOrigin(url);
      this[kSocketPath] = socketPath;
      this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
      this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
      this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;
      this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
      this[kClosed] = false;
      this[kDestroyed] = false;
      this[kTLSOpts] = tls2;
      this[kTLSServerName] = getServerName(this);
      this[kHost] = null;
      this[kOnDestroyed] = [];
      this[kResuming] = 0;
      this[kNeedDrain] = 0;
      this[kTLSSession] = null;
      this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r
`;
      this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e4;
      this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e4;
      this[kQueue] = [];
      this[kRunningIdx] = 0;
      this[kPendingIdx] = 0;
    }
    get url() {
      return this[kUrl];
    }
    get pipelining() {
      return this[kPipelining];
    }
    set pipelining(value) {
      this[kPipelining] = value;
      resume(this, true);
    }
    get connected() {
      return this[kSocket] && this[kSocket].connecting !== true && (this[kSocket].authorized !== false || this[kSocket].authorizationError) && !this[kSocket].destroyed;
    }
    get pending() {
      return this[kQueue].length - this[kPendingIdx];
    }
    get running() {
      return this[kPendingIdx] - this[kRunningIdx];
    }
    get size() {
      return this[kQueue].length - this[kRunningIdx];
    }
    get busy() {
      const socket = this[kSocket];
      return socket && (socket[kReset] || socket[kWriting]) || this.size >= (this[kPipelining] || 1) || this.pending > 0;
    }
    get destroyed() {
      return this[kDestroyed];
    }
    get closed() {
      return this[kClosed];
    }
    [kConnect](cb) {
      connect(this);
      this.once("connect", cb);
    }
    dispatch(opts, handler) {
      try {
        const request = new Request2(opts, handler);
        if (this[kDestroyed]) {
          throw new ClientDestroyedError();
        }
        if (this[kClosed]) {
          throw new ClientClosedError();
        }
        this[kQueue].push(request);
        if (this[kResuming]) {
        } else if (util2.isStream(request.body)) {
          this[kResuming] = 1;
          process.nextTick(resume, this);
        } else {
          resume(this, true);
        }
      } catch (err) {
        if (typeof handler.onError !== "function") {
          throw new InvalidArgumentError("invalid onError method");
        }
        handler.onError(err);
      }
    }
    close(callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          this.close((err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      if (this[kDestroyed]) {
        process.nextTick(callback, new ClientDestroyedError(), null);
        return;
      }
      this[kClosed] = true;
      if (!this.size) {
        this.destroy(callback);
      } else {
        this[kOnDestroyed].push(callback);
      }
    }
    destroy(err, callback) {
      if (typeof err === "function") {
        callback = err;
        err = null;
      }
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          this.destroy(err, (err2, data) => {
            return err2 ? reject(err2) : resolve(data);
          });
        });
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      if (this[kDestroyed]) {
        if (this[kOnDestroyed]) {
          this[kOnDestroyed].push(callback);
        } else {
          process.nextTick(callback, null, null);
        }
        return;
      }
      if (!err) {
        err = new ClientDestroyedError();
      }
      for (const request of this[kQueue].splice(this[kPendingIdx])) {
        request.onError(err);
      }
      this[kClosed] = true;
      this[kDestroyed] = true;
      this[kOnDestroyed].push(callback);
      const onDestroyed = () => {
        const callbacks = this[kOnDestroyed];
        this[kOnDestroyed] = null;
        for (const callback2 of callbacks) {
          callback2(null, null);
        }
      };
      if (!this[kSocket]) {
        process.nextTick(onDestroyed);
      } else {
        util2.destroy(this[kSocket].on("close", onDestroyed), err);
      }
      resume(this);
    }
  };
  var Parser = class extends HTTPParser {
    constructor(client, socket) {
      if (nodeMajorVersion === 12 && nodeMinorVersion < 19) {
        super();
        this.initialize(HTTPParser.RESPONSE, {}, 0);
      } else if (nodeMajorVersion === 12 && nodeMinorVersion >= 19) {
        super();
        this.initialize(HTTPParser.RESPONSE, {}, client[kMaxHeadersSize], 0);
      } else if (nodeMajorVersion > 12 && nodeMajorVersion < 16) {
        super();
        this.initialize(HTTPParser.RESPONSE, {}, client[kMaxHeadersSize], insecureHTTPParser, 0);
      } else if (nodeMajorVersion >= 16) {
        super();
        this.initialize(HTTPParser.RESPONSE, {}, client[kMaxHeadersSize], 0);
      } else {
        super(HTTPParser.RESPONSE);
      }
      this.client = client;
      this.socket = socket;
      this.timeout = null;
      this.statusCode = null;
      this.upgrade = false;
      this.headers = null;
      this.shouldKeepAlive = false;
      this.request = null;
      this.paused = false;
      this.resuming = false;
      this.queue = [];
      this._resume = () => {
        if (!this.paused || this.resuming) {
          return;
        }
        this.paused = false;
        this.resuming = true;
        while (this.queue.length) {
          const [fn, ...args2] = this.queue.shift();
          Reflect.apply(fn, this, args2);
          if (this.paused) {
            this.resuming = false;
            return;
          }
        }
        this.resuming = false;
        socketResume(this.socket);
      };
      this._pause = () => {
        if (this.paused) {
          return;
        }
        this.paused = true;
        socketPause(this.socket);
      };
    }
    [HTTPParser.kOnHeaders](rawHeaders) {
      if (this.paused) {
        this.queue.push([this[HTTPParser.kOnHeaders], rawHeaders]);
        return;
      }
      if (this.headers) {
        Array.prototype.push.apply(this.headers, rawHeaders);
      } else {
        this.headers = rawHeaders;
      }
    }
    [HTTPParser.kOnExecute](ret) {
      if (this.paused) {
        this.queue.push([this[HTTPParser.kOnExecute], ret]);
        return;
      }
      const {upgrade, socket} = this;
      if (!Number.isFinite(ret)) {
        assert(ret instanceof Error);
        util2.destroy(socket, ret);
        return;
      }
      if (upgrade && !socket.destroyed) {
        const {client, headers, statusCode, request} = this;
        assert(!socket.destroyed);
        assert(socket === client[kSocket]);
        assert(!socket.isPaused());
        assert(socket._handle && socket._handle.reading);
        assert(request.upgrade);
        this.headers = null;
        this.statusCode = null;
        this.request = null;
        socket._readableState.flowing = null;
        socket.unshift(this.getCurrentBuffer().slice(ret));
        try {
          request.onUpgrade(statusCode, headers, socket);
          if (!socket.destroyed && !request.aborted) {
            detachSocket(socket);
            client[kSocket] = null;
            client[kQueue][client[kRunningIdx]++] = null;
            client.emit("disconnect", new InformationalError("upgrade"));
          }
          resume(client);
        } catch (err) {
          util2.destroy(socket, err);
        }
      }
    }
    [HTTPParser.kOnHeadersComplete](versionMajor, versionMinor, rawHeaders, method, url, statusCode, statusMessage, upgrade, shouldKeepAlive) {
      if (this.paused) {
        this.queue.push([
          this[HTTPParser.kOnHeadersComplete],
          versionMajor,
          versionMinor,
          rawHeaders,
          method,
          url,
          statusCode,
          statusMessage,
          upgrade,
          shouldKeepAlive
        ]);
        return;
      }
      const {client, socket} = this;
      const request = client[kQueue][client[kRunningIdx]];
      if (socket.destroyed) {
        return;
      }
      clearTimeout(this.timeout);
      this.timeout = client[kBodyTimeout] ? setTimeout(onBodyTimeout, client[kBodyTimeout], this) : null;
      assert(!this.upgrade);
      assert(this.statusCode < 200);
      if (statusCode === 100) {
        util2.destroy(socket, new SocketError("bad response"));
        return 1;
      }
      if (request.upgrade !== true && upgrade !== Boolean(request.upgrade)) {
        util2.destroy(socket, new SocketError("bad upgrade"));
        return 1;
      }
      if (this.headers) {
        Array.prototype.push.apply(this.headers, rawHeaders);
      } else {
        this.headers = rawHeaders;
      }
      this.statusCode = statusCode;
      this.shouldKeepAlive = shouldKeepAlive;
      this.request = request;
      if (request.upgrade) {
        this.unconsume();
        this.upgrade = true;
        return 2;
      }
      let keepAlive;
      let trailers;
      const {headers} = this;
      this.headers = null;
      for (let n = 0; n < headers.length; n += 2) {
        const key = headers[n + 0];
        const val = headers[n + 1];
        if (!keepAlive && key.length === 10 && key.toLowerCase() === "keep-alive") {
          keepAlive = val;
        } else if (!trailers && key.length === 7 && key.toLowerCase() === "trailer") {
          trailers = val;
        }
      }
      this.trailers = trailers ? trailers.toLowerCase().split(/,\s*/) : null;
      if (shouldKeepAlive && client[kPipelining]) {
        const keepAliveTimeout = keepAlive ? util2.parseKeepAliveTimeout(keepAlive) : null;
        if (keepAliveTimeout != null) {
          const timeout = Math.min(keepAliveTimeout - client[kKeepAliveTimeoutThreshold], client[kKeepAliveMaxTimeout]);
          if (timeout <= 0) {
            socket[kReset] = true;
          } else {
            client[kKeepAliveTimeoutValue] = timeout;
          }
        } else {
          client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
        }
      } else {
        socket[kReset] = true;
      }
      try {
        if (request.onHeaders(statusCode, headers, this._resume) === false) {
          this._pause();
        }
      } catch (err) {
        util2.destroy(socket, err);
        return 1;
      }
      return request.method === "HEAD" || statusCode < 200 ? 1 : 0;
    }
    [HTTPParser.kOnBody](chunk, offset, length) {
      if (this.paused) {
        this.queue.push([this[HTTPParser.kOnBody], chunk, offset, length]);
        return;
      }
      const {socket, statusCode, request, timeout} = this;
      if (socket.destroyed) {
        return;
      }
      if (timeout && timeout.refresh) {
        timeout.refresh();
      }
      assert(statusCode >= 200);
      try {
        if (request.onData(chunk.slice(offset, offset + length)) === false) {
          this._pause();
        }
      } catch (err) {
        util2.destroy(socket, err);
      }
    }
    [HTTPParser.kOnMessageComplete]() {
      if (this.paused) {
        this.queue.push([this[HTTPParser.kOnMessageComplete]]);
        return;
      }
      const {client, socket, statusCode, headers, upgrade, request, trailers} = this;
      if (socket.destroyed) {
        return;
      }
      assert(statusCode >= 100);
      assert(this.resuming || socket._handle && socket._handle.reading);
      if (upgrade) {
        assert(statusCode < 300 || request.method === "CONNECT");
        return;
      }
      this.statusCode = null;
      this.headers = null;
      this.request = null;
      this.trailers = null;
      clearTimeout(this.timeout);
      this.timeout = client[kHeadersTimeout] ? setTimeout(onHeadersTimeout, client[kHeadersTimeout], this) : null;
      if (statusCode < 200) {
        return;
      }
      try {
        if (trailers) {
          if (!headers) {
            throw new TrailerMismatchError();
          }
          for (const trailer of trailers) {
            let found = false;
            for (let n = 0; n < headers.length; n += 2) {
              const key = headers[n + 0];
              if (key.length === trailer.length && key.toLowerCase() === trailer.toLowerCase()) {
                found = true;
                break;
              }
            }
            if (!found) {
              throw new TrailerMismatchError();
            }
          }
        }
        try {
          request.onComplete(headers);
        } catch (err) {
          request.onError(err);
        }
      } catch (err) {
        util2.destroy(socket, err);
        return;
      }
      client[kQueue][client[kRunningIdx]++] = null;
      if (socket[kWriting]) {
        util2.destroy(socket, new InformationalError("reset"));
      } else if (!this.shouldKeepAlive) {
        util2.destroy(socket, new InformationalError("reset"));
      } else if (socket[kReset] && !client.running) {
        util2.destroy(socket, new InformationalError("reset"));
      } else {
        resume(client);
      }
    }
    destroy() {
      clearTimeout(this.timeout);
      this.timeout = null;
      this.unconsume();
      setImmediate((self2) => self2.close(), this);
    }
  };
  function onBodyTimeout(self2) {
    if (!self2.paused) {
      util2.destroy(self2.socket, new BodyTimeoutError());
    }
  }
  function onHeadersTimeout(self2) {
    util2.destroy(self2.socket, new HeadersTimeoutError());
  }
  function onSocketConnect() {
    const {[kClient]: client} = this;
    client.emit("connect");
    resume(client);
  }
  function onSocketError(err) {
    const {[kClient]: client} = this;
    this[kError] = err;
    if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
      assert(!client.running);
      while (client.pending && client[kQueue][client[kPendingIdx]].host === client[kHost]) {
        client[kQueue][client[kPendingIdx]++].onError(err);
      }
    } else if (!client.running && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
      assert(client[kPendingIdx] === client[kRunningIdx]);
      for (const request of client[kQueue].splice(client[kRunningIdx])) {
        request.onError(err);
      }
    }
  }
  function onSocketEnd() {
    util2.destroy(this, new SocketError("other side closed"));
  }
  function detachSocket(socket) {
    clearTimeout(socket[kIdleTimeout]);
    socket[kIdleTimeout] = null;
    socket[kIdleTimeoutValue] = null;
    socket[kParser].destroy();
    socket[kParser] = null;
    socket[kClient] = null;
    socket[kError] = null;
    socket.removeListener("session", onSocketSession).removeListener("error", onSocketError).removeListener("end", onSocketEnd).removeListener("close", onSocketClose);
  }
  function onSocketClose() {
    const {[kClient]: client} = this;
    const err = this[kError] || new SocketError("closed");
    detachSocket(this);
    client[kSocket] = null;
    if (err.code !== "UND_ERR_INFO") {
      client[kTLSSession] = null;
    }
    if (client[kDestroyed]) {
      assert(!client.pending);
      for (const request of client[kQueue].splice(client[kRunningIdx])) {
        request.onError(err);
      }
      client[kPendingIdx] = client[kRunningIdx];
    } else {
      if (client.running && err.code !== "UND_ERR_INFO") {
        client[kQueue][client[kRunningIdx]].onError(err);
        client[kQueue][client[kRunningIdx]++] = null;
      }
      client[kPendingIdx] = client[kRunningIdx];
      client.emit("disconnect", err);
    }
    resume(client);
  }
  function onSocketSession(session) {
    const {[kClient]: client} = this;
    client[kTLSSession] = session;
  }
  function connect(client) {
    assert(!client[kSocket]);
    const {protocol, port, hostname} = client[kUrl];
    let socket;
    if (protocol === "https:") {
      const tlsOpts = {
        ...client[kTLSOpts],
        servername: client[kTLSServerName],
        session: client[kTLSSession]
      };
      socket = client[kSocketPath] ? tls.connect(client[kSocketPath], tlsOpts) : tls.connect(port || 443, hostname, tlsOpts);
      socket.on("session", onSocketSession);
    } else {
      socket = client[kSocketPath] ? net.connect(client[kSocketPath]) : net.connect(port || 80, hostname);
    }
    client[kSocket] = socket;
    const parser = new Parser(client, socket);
    if (nodeMajorVersion >= 12) {
      assert(socket._handle);
      parser.consume(socket._handle);
    } else {
      assert(socket._handle && socket._handle._externalStream);
      parser.consume(socket._handle._externalStream);
    }
    socket[kIdleTimeout] = null;
    socket[kIdleTimeoutValue] = null;
    socket[kWriting] = false;
    socket[kReset] = false;
    socket[kError] = null;
    socket[kParser] = parser;
    socket[kClient] = client;
    socket.setNoDelay(true).on(protocol === "https:" ? "secureConnect" : "connect", onSocketConnect).on("error", onSocketError).on("end", onSocketEnd).on("close", onSocketClose);
  }
  function socketPause(socket) {
    if (socket._handle && socket._handle.reading) {
      socket._handle.reading = false;
      const err = socket._handle.readStop();
      if (err) {
        socket.destroy(util2.errnoException(err, "read"));
      }
    }
  }
  function socketResume(socket) {
    if (socket._handle && !socket._handle.reading) {
      socket._handle.reading = true;
      const err = socket._handle.readStart();
      if (err) {
        socket.destroy(util2.errnoException(err, "read"));
      }
    }
  }
  function emitDrain(client) {
    client[kNeedDrain] = 0;
    client.emit("drain");
  }
  function resume(client, sync2) {
    if (client[kResuming] === 2) {
      return;
    }
    client[kResuming] = 2;
    _resume(client, sync2);
    client[kResuming] = 0;
    if (client[kRunningIdx] > 256) {
      client[kQueue].splice(0, client[kRunningIdx]);
      client[kPendingIdx] -= client[kRunningIdx];
      client[kRunningIdx] = 0;
    }
  }
  function _resume(client, sync2) {
    while (true) {
      if (client[kDestroyed]) {
        assert(!client.pending);
        return;
      }
      if (client[kClosed] && !client.size) {
        client.destroy(util2.nop);
        continue;
      }
      if (client[kSocket]) {
        const socket2 = client[kSocket];
        const timeout = client.running ? 0 : client[kKeepAliveTimeoutValue];
        if (socket2[kIdleTimeoutValue] !== timeout) {
          clearTimeout(socket2[kIdleTimeout]);
          if (timeout) {
            socket2[kIdleTimeout] = setTimeout((socket3) => {
              util2.destroy(socket3, new InformationalError("socket idle timeout"));
            }, timeout, socket2);
          }
          socket2[kIdleTimeoutValue] = timeout;
        }
      }
      if (client.running) {
        const {aborted} = client[kQueue][client[kRunningIdx]];
        if (aborted) {
          util2.destroy(client[kSocket]);
          return;
        }
      }
      if (client.busy) {
        client[kNeedDrain] = 2;
      } else if (client[kNeedDrain] === 2) {
        if (sync2) {
          client[kNeedDrain] = 1;
          process.nextTick(emitDrain, client);
        } else {
          emitDrain(client);
        }
        continue;
      }
      if (!client.pending) {
        return;
      }
      if (client.running >= (client[kPipelining] || 1)) {
        return;
      }
      const socket = client[kSocket];
      const request = client[kQueue][client[kPendingIdx]];
      if (client[kUrl].protocol === "https:" && client[kHost] !== request.host) {
        if (client.running) {
          return;
        }
        client[kHost] = request.host;
        const servername = getServerName(client, request.host);
        if (client[kTLSServerName] !== servername) {
          client[kTLSServerName] = servername;
          client[kTLSSession] = null;
          if (socket) {
            util2.destroy(socket, new InformationalError("servername changed"));
            return;
          }
        }
      }
      if (!socket) {
        connect(client);
        return;
      }
      if (!client.connected) {
        return;
      }
      if (socket[kWriting] || socket[kReset]) {
        return;
      }
      if (client.running && !request.idempotent) {
        return;
      }
      if (client.running && request.upgrade) {
        return;
      }
      if (util2.isStream(request.body) && util2.bodyLength(request.body) === 0) {
        request.body.on("data", function() {
          assert(false);
        }).on("error", function(err) {
          request.onError(err);
        }).on("end", function() {
          util2.destroy(this);
        });
        request.body = null;
      }
      if (client.running && util2.isStream(request.body)) {
        return;
      }
      if (!request.aborted && write2(client, request)) {
        const parser = client[kSocket][kParser];
        if (!parser.timeout && client[kHeadersTimeout]) {
          parser.timeout = setTimeout(onHeadersTimeout, client[kHeadersTimeout], parser);
        }
        client[kPendingIdx]++;
      } else {
        client[kQueue].splice(client[kPendingIdx], 1);
      }
    }
  }
  function write2(client, request) {
    const {body, method, path: path10, host, upgrade, headers} = request;
    const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
    if (body && typeof body.read === "function") {
      body.read(0);
    }
    let contentLength = util2.bodyLength(body);
    if (contentLength === null) {
      contentLength = request.contentLength;
    }
    if (contentLength === 0 && !expectsPayload) {
      contentLength = null;
    }
    if (request.contentLength !== null && request.contentLength !== contentLength) {
      request.onError(new ContentLengthMismatchError());
      return false;
    }
    if (request.aborted) {
      return false;
    }
    try {
      request.onConnect((err) => {
        if (request.aborted) {
          return;
        }
        request.onError(err || new RequestAbortedError());
        if (client[kResuming] === 0) {
          resume(client, true);
        }
      });
    } catch (err) {
      request.onError(err);
    }
    if (request.aborted) {
      return false;
    }
    const socket = client[kSocket];
    if (method === "HEAD") {
      socket[kReset] = true;
    }
    if (upgrade) {
      socket[kReset] = true;
    }
    let header;
    if (typeof upgrade === "string") {
      header = `${method} ${path10} HTTP/1.1\r
connection: upgrade\r
upgrade: ${upgrade}\r
`;
    } else if (client[kPipelining]) {
      header = `${method} ${path10} HTTP/1.1\r
connection: keep-alive\r
`;
    } else {
      header = `${method} ${path10} HTTP/1.1\r
connection: close\r
`;
    }
    if (!host) {
      header += client[kHostHeader];
    }
    if (headers) {
      header += headers;
    }
    if (!body) {
      if (contentLength === 0) {
        socket.write(`${header}content-length: ${contentLength}\r
\r
\r
`, "ascii");
      } else {
        assert(contentLength === null, "no body must not have content length");
        socket.write(`${header}\r
`, "ascii");
      }
    } else if (util2.isBuffer(body)) {
      assert(contentLength !== null, "buffer body must have content length");
      socket.cork();
      socket.write(`${header}content-length: ${contentLength}\r
\r
`, "ascii");
      socket.write(body);
      socket.write("\r\n", "ascii");
      socket.uncork();
      if (!expectsPayload) {
        socket[kReset] = true;
      }
    } else {
      socket[kWriting] = true;
      assert(util2.isStream(body));
      assert(contentLength !== 0 || !client.running, "stream body cannot be pipelined");
      let finished = false;
      let bytesWritten = 0;
      const onData = function(chunk) {
        try {
          assert(!finished);
          const len = Buffer.byteLength(chunk);
          if (!len) {
            return;
          }
          if (contentLength !== null && bytesWritten + len > contentLength) {
            util2.destroy(socket, new ContentLengthMismatchError());
            return;
          }
          if (bytesWritten === 0) {
            if (!expectsPayload) {
              socket[kReset] = true;
            }
            if (contentLength === null) {
              socket.write(`${header}transfer-encoding: chunked\r
`, "ascii");
            } else {
              socket.write(`${header}content-length: ${contentLength}\r
\r
`, "ascii");
            }
          }
          if (contentLength === null) {
            socket.write(`\r
${len.toString(16)}\r
`, "ascii");
          }
          bytesWritten += len;
          if (!socket.write(chunk) && this.pause) {
            this.pause();
          }
        } catch (err) {
          util2.destroy(this, err);
        }
      };
      const onDrain = function() {
        assert(!finished);
        if (body.resume) {
          body.resume();
        }
      };
      const onAbort = function() {
        onFinished(new RequestAbortedError());
      };
      const onFinished = function(err) {
        if (finished) {
          return;
        }
        finished = true;
        assert(socket.destroyed || socket[kWriting] && client.running <= 1);
        socket[kWriting] = false;
        if (!err && contentLength !== null && bytesWritten !== contentLength) {
          err = new ContentLengthMismatchError();
        }
        socket.removeListener("drain", onDrain).removeListener("error", onFinished);
        body.removeListener("data", onData).removeListener("end", onFinished).removeListener("error", onFinished).removeListener("close", onAbort);
        util2.destroy(body, err);
        if (err) {
          assert(client.running <= 1, "pipeline should only contain this request");
          util2.destroy(socket, err);
        }
        if (socket.destroyed) {
          return;
        }
        if (bytesWritten === 0) {
          if (expectsPayload) {
            socket.write(`${header}content-length: 0\r
\r
\r
`, "ascii");
          } else {
            socket.write(`${header}\r
`, "ascii");
          }
        } else if (contentLength === null) {
          socket.write("\r\n0\r\n\r\n", "ascii");
        }
        resume(client);
      };
      body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onAbort);
      socket.on("drain", onDrain).on("error", onFinished);
    }
    return true;
  }
  module2.exports = Client;
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/node/fixed-queue.js
var require_fixed_queue = __commonJS((exports2, module2) => {
  "use strict";
  var kSize = 2048;
  var kMask = kSize - 1;
  var FixedCircularBuffer = class {
    constructor() {
      this.bottom = 0;
      this.top = 0;
      this.list = new Array(kSize);
      this.next = null;
    }
    isEmpty() {
      return this.top === this.bottom;
    }
    isFull() {
      return (this.top + 1 & kMask) === this.bottom;
    }
    push(data) {
      this.list[this.top] = data;
      this.top = this.top + 1 & kMask;
    }
    shift() {
      const nextItem = this.list[this.bottom];
      if (nextItem === void 0)
        return null;
      this.list[this.bottom] = void 0;
      this.bottom = this.bottom + 1 & kMask;
      return nextItem;
    }
  };
  module2.exports = class FixedQueue {
    constructor() {
      this.head = this.tail = new FixedCircularBuffer();
    }
    isEmpty() {
      return this.head.isEmpty();
    }
    push(data) {
      if (this.head.isFull()) {
        this.head = this.head.next = new FixedCircularBuffer();
      }
      this.head.push(data);
    }
    shift() {
      const tail = this.tail;
      const next = tail.shift();
      if (tail.isEmpty() && tail.next !== null) {
        this.tail = tail.next;
      }
      return next;
    }
  };
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/abort-signal.js
var require_abort_signal = __commonJS((exports2, module2) => {
  var {RequestAbortedError} = require_errors();
  var kListener = Symbol("kListener");
  var kSignal = Symbol("kSignal");
  function abort(self2) {
    if (self2.abort) {
      self2.abort();
    } else {
      self2.onError(new RequestAbortedError());
    }
  }
  function addSignal(self2, signal) {
    self2[kSignal] = null;
    self2[kListener] = null;
    if (!signal) {
      return;
    }
    if (signal.aborted) {
      abort(self2);
      return;
    }
    self2[kSignal] = signal;
    self2[kListener] = () => {
      abort(self2);
    };
    if ("addEventListener" in self2[kSignal]) {
      self2[kSignal].addEventListener("abort", self2[kListener]);
    } else {
      self2[kSignal].addListener("abort", self2[kListener]);
    }
  }
  function removeSignal(self2) {
    if (!self2[kSignal]) {
      return;
    }
    if ("removeEventListener" in self2[kSignal]) {
      self2[kSignal].removeEventListener("abort", self2[kListener]);
    } else {
      self2[kSignal].removeListener("abort", self2[kListener]);
    }
    self2[kSignal] = null;
    self2[kListener] = null;
  }
  module2.exports = {
    addSignal,
    removeSignal
  };
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/client-request.js
var require_client_request = __commonJS((exports2, module2) => {
  "use strict";
  var {Readable} = require("stream");
  var {
    InvalidArgumentError,
    RequestAbortedError
  } = require_errors();
  var util2 = require_util4();
  var {AsyncResource} = require("async_hooks");
  var {addSignal, removeSignal} = require_abort_signal();
  var kAbort = Symbol("abort");
  var RequestResponse = class extends Readable {
    constructor(resume, abort) {
      super({autoDestroy: true, read: resume});
      this[kAbort] = abort;
    }
    _destroy(err, callback) {
      if (!err && !this._readableState.endEmitted) {
        err = new RequestAbortedError();
      }
      if (err) {
        this[kAbort]();
      }
      callback(err);
    }
  };
  var RequestHandler = class extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      const {signal, method, opaque, body} = opts;
      try {
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        super("UNDICI_REQUEST");
      } catch (err) {
        if (util2.isStream(body)) {
          util2.destroy(body.on("error", util2.nop), err);
        }
        throw err;
      }
      this.opaque = opaque || null;
      this.callback = callback;
      this.res = null;
      this.abort = null;
      this.body = body;
      this.trailers = {};
      if (util2.isStream(body)) {
        body.on("error", (err) => {
          this.onError(err);
        });
      }
      addSignal(this, signal);
    }
    onConnect(abort) {
      if (!this.callback) {
        throw new RequestAbortedError();
      }
      this.abort = abort;
    }
    onHeaders(statusCode, headers, resume) {
      const {callback, opaque, abort} = this;
      if (statusCode < 200) {
        return;
      }
      const body = new RequestResponse(resume, abort);
      this.callback = null;
      this.res = body;
      this.runInAsyncScope(callback, null, null, {
        statusCode,
        headers: util2.parseHeaders(headers),
        trailers: this.trailers,
        opaque,
        body
      });
    }
    onData(chunk) {
      const {res} = this;
      return res.push(chunk);
    }
    onComplete(trailers) {
      const {res} = this;
      removeSignal(this);
      if (trailers) {
        util2.parseHeaders(trailers, this.trailers);
      }
      res.push(null);
    }
    onError(err) {
      const {res, callback, body, opaque} = this;
      removeSignal(this);
      if (callback) {
        this.callback = null;
        process.nextTick((self2, callback2, err2, opaque2) => {
          self2.runInAsyncScope(callback2, null, err2, {opaque: opaque2});
        }, this, callback, err, opaque);
      }
      if (res) {
        this.res = null;
        util2.destroy(res, err);
      }
      if (body) {
        this.body = null;
        util2.destroy(body, err);
      }
    }
  };
  function request(opts, callback) {
    if (callback === void 0) {
      return new Promise((resolve, reject) => {
        request.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    try {
      this.dispatch(opts, new RequestHandler(opts, callback));
    } catch (err) {
      if (typeof callback === "function") {
        process.nextTick(callback, err, {opaque: opts && opts.opaque});
      } else {
        throw err;
      }
    }
  }
  module2.exports = request;
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/client-stream.js
var require_client_stream = __commonJS((exports2, module2) => {
  "use strict";
  var {finished} = require("stream");
  var {
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError
  } = require_errors();
  var util2 = require_util4();
  var {AsyncResource} = require("async_hooks");
  var {addSignal, removeSignal} = require_abort_signal();
  var StreamHandler = class extends AsyncResource {
    constructor(opts, factory, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      const {signal, method, opaque, body} = opts;
      try {
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("invalid factory");
        }
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        super("UNDICI_STREAM");
      } catch (err) {
        if (util2.isStream(body)) {
          util2.destroy(body.on("error", util2.nop), err);
        }
        throw err;
      }
      this.opaque = opaque || null;
      this.factory = factory;
      this.callback = callback;
      this.res = null;
      this.abort = null;
      this.trailers = null;
      this.body = body;
      if (util2.isStream(body)) {
        body.on("error", (err) => {
          this.onError(err);
        });
      }
      addSignal(this, signal);
    }
    onConnect(abort) {
      if (!this.callback) {
        throw new RequestAbortedError();
      }
      this.abort = abort;
    }
    onHeaders(statusCode, headers, resume) {
      const {factory, opaque} = this;
      if (statusCode < 200) {
        return;
      }
      this.factory = null;
      const res = this.runInAsyncScope(factory, null, {
        statusCode,
        headers: util2.parseHeaders(headers),
        opaque
      });
      if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") {
        throw new InvalidReturnValueError("expected Writable");
      }
      res.on("drain", resume);
      finished(res, {readable: false}, (err) => {
        const {callback, res: res2, opaque: opaque2, trailers, abort} = this;
        this.res = null;
        if (err || !res2.readable) {
          util2.destroy(res2, err);
        }
        this.callback = null;
        this.runInAsyncScope(callback, null, err || null, {opaque: opaque2, trailers});
        if (err) {
          abort();
        }
      });
      this.res = res;
      const needDrain = res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;
      return needDrain !== true;
    }
    onData(chunk) {
      const {res} = this;
      return res.write(chunk);
    }
    onComplete(trailers) {
      const {res} = this;
      removeSignal(this);
      this.trailers = trailers ? util2.parseHeaders(trailers) : {};
      res.end();
    }
    onError(err) {
      const {res, callback, opaque, body} = this;
      removeSignal(this);
      this.factory = null;
      if (res) {
        this.res = null;
        util2.destroy(res, err);
      } else if (callback) {
        this.callback = null;
        process.nextTick((self2, callback2, err2, opaque2) => {
          self2.runInAsyncScope(callback2, null, err2, {opaque: opaque2});
        }, this, callback, err, opaque);
      }
      if (body) {
        this.body = null;
        util2.destroy(body, err);
      }
    }
  };
  function stream(opts, factory, callback) {
    if (callback === void 0) {
      return new Promise((resolve, reject) => {
        stream.call(this, opts, factory, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    try {
      this.dispatch(opts, new StreamHandler(opts, factory, callback));
    } catch (err) {
      if (typeof callback === "function") {
        process.nextTick(callback, err, {opaque: opts && opts.opaque});
      } else {
        throw err;
      }
    }
  }
  module2.exports = stream;
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/client-pipeline.js
var require_client_pipeline = __commonJS((exports2, module2) => {
  "use strict";
  var {
    Readable,
    Duplex,
    PassThrough
  } = require("stream");
  var {
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError
  } = require_errors();
  var util2 = require_util4();
  var {AsyncResource} = require("async_hooks");
  var {assert} = require("console");
  var {addSignal, removeSignal} = require_abort_signal();
  var kResume = Symbol("resume");
  var PipelineRequest = class extends Readable {
    constructor() {
      super({autoDestroy: true});
      this[kResume] = null;
    }
    _read() {
      const {[kResume]: resume} = this;
      if (resume) {
        this[kResume] = null;
        resume();
      }
    }
    _destroy(err, callback) {
      this._read();
      assert(err || this._readableState.endEmitted);
      callback(err);
    }
  };
  var PipelineResponse = class extends Readable {
    constructor(resume) {
      super({autoDestroy: true});
      this[kResume] = resume;
    }
    _read() {
      this[kResume]();
    }
    _destroy(err, callback) {
      if (!err && !this._readableState.endEmitted) {
        err = new RequestAbortedError();
      }
      callback(err);
    }
  };
  var PipelineHandler = class extends AsyncResource {
    constructor(opts, handler) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (typeof handler !== "function") {
        throw new InvalidArgumentError("invalid handler");
      }
      const {signal, method, opaque} = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      if (method === "CONNECT") {
        throw new InvalidArgumentError("invalid method");
      }
      super("UNDICI_PIPELINE");
      this.opaque = opaque || null;
      this.handler = handler;
      this.abort = null;
      this.req = new PipelineRequest().on("error", util2.nop);
      this.ret = new Duplex({
        readableObjectMode: opts.objectMode,
        autoDestroy: true,
        read: () => {
          const {body} = this;
          if (body && body.resume) {
            body.resume();
          }
        },
        write: (chunk, encoding, callback) => {
          const {req} = this;
          if (req.push(chunk, encoding) || req._readableState.destroyed) {
            callback();
          } else {
            req[kResume] = callback;
          }
        },
        destroy: (err, callback) => {
          const {body, req, res, ret, abort} = this;
          if (!err && !ret._readableState.endEmitted) {
            err = new RequestAbortedError();
          }
          if (abort && err) {
            abort();
          }
          util2.destroy(body, err);
          util2.destroy(req, err);
          util2.destroy(res, err);
          removeSignal(this);
          callback(err);
        }
      }).on("prefinish", () => {
        const {req} = this;
        req.push(null);
      });
      this.res = null;
      addSignal(this, signal);
    }
    onConnect(abort) {
      const {ret} = this;
      if (ret.destroyed) {
        throw new RequestAbortedError();
      }
      this.abort = abort;
    }
    onHeaders(statusCode, headers, resume) {
      const {opaque, handler} = this;
      if (statusCode < 200) {
        return;
      }
      this.res = new PipelineResponse(resume);
      let body;
      try {
        this.handler = null;
        body = this.runInAsyncScope(handler, null, {
          statusCode,
          headers: util2.parseHeaders(headers),
          opaque,
          body: this.res
        });
      } catch (err) {
        this.res.on("error", util2.nop);
        throw err;
      }
      if (!body || typeof body.on !== "function") {
        throw new InvalidReturnValueError("expected Readable");
      }
      body.on("data", (chunk) => {
        const {ret, body: body2} = this;
        if (!ret.push(chunk) && body2.pause) {
          body2.pause();
        }
      }).on("error", (err) => {
        const {ret} = this;
        util2.destroy(ret, err);
      }).on("end", () => {
        const {ret} = this;
        ret.push(null);
      }).on("close", () => {
        const {ret} = this;
        if (!ret._readableState.ended) {
          util2.destroy(ret, new RequestAbortedError());
        }
      });
      this.body = body;
    }
    onData(chunk) {
      const {res} = this;
      return res.push(chunk);
    }
    onComplete(trailers) {
      const {res} = this;
      res.push(null);
    }
    onError(err) {
      const {ret} = this;
      this.handler = null;
      util2.destroy(ret, err);
    }
  };
  function pipeline(opts, handler) {
    try {
      const pipelineHandler = new PipelineHandler(opts, handler);
      const {
        path: path10,
        method,
        headers,
        idempotent,
        signal
      } = opts;
      this.dispatch({
        path: path10,
        method,
        body: pipelineHandler.req,
        headers,
        idempotent,
        signal
      }, pipelineHandler);
      return pipelineHandler.ret;
    } catch (err) {
      return new PassThrough().destroy(err);
    }
  }
  module2.exports = pipeline;
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/client-upgrade.js
var require_client_upgrade = __commonJS((exports2, module2) => {
  "use strict";
  var {InvalidArgumentError, RequestAbortedError} = require_errors();
  var {AsyncResource} = require("async_hooks");
  var util2 = require_util4();
  var {addSignal, removeSignal} = require_abort_signal();
  var assert = require("assert");
  var UpgradeHandler = class extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      const {signal, opaque} = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      super("UNDICI_UPGRADE");
      this.opaque = opaque || null;
      this.callback = callback;
      this.abort = null;
      addSignal(this, signal);
    }
    onConnect(abort) {
      if (!this.callback) {
        throw new RequestAbortedError();
      }
      this.abort = abort;
    }
    onUpgrade(statusCode, headers, socket) {
      const {callback, opaque} = this;
      assert.strictEqual(statusCode, 101);
      removeSignal(this);
      this.callback = null;
      this.runInAsyncScope(callback, null, null, {
        headers: util2.parseHeaders(headers),
        socket,
        opaque
      });
    }
    onError(err) {
      const {callback, opaque} = this;
      removeSignal(this);
      if (callback) {
        this.callback = null;
        process.nextTick((self2, callback2, err2, opaque2) => {
          self2.runInAsyncScope(callback2, null, err2, {opaque: opaque2});
        }, this, callback, err, opaque);
      }
    }
  };
  function upgrade(opts, callback) {
    if (callback === void 0) {
      return new Promise((resolve, reject) => {
        upgrade.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    if (typeof callback !== "function") {
      throw new InvalidArgumentError("invalid callback");
    }
    try {
      const upgradeHandler = new UpgradeHandler(opts, callback);
      const {
        path: path10,
        method,
        headers,
        signal,
        protocol
      } = opts;
      this.dispatch({
        path: path10,
        method: method || "GET",
        headers,
        signal,
        upgrade: protocol || "Websocket"
      }, upgradeHandler);
    } catch (err) {
      process.nextTick(callback, err, {opaque: opts && opts.opaque});
    }
  }
  module2.exports = upgrade;
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/client-connect.js
var require_client_connect = __commonJS((exports2, module2) => {
  "use strict";
  var {InvalidArgumentError, RequestAbortedError} = require_errors();
  var {AsyncResource} = require("async_hooks");
  var util2 = require_util4();
  var {addSignal, removeSignal} = require_abort_signal();
  var ConnectHandler = class extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      const {signal, opaque} = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      super("UNDICI_CONNECT");
      this.opaque = opaque || null;
      this.callback = callback;
      this.abort = null;
      addSignal(this, signal);
    }
    onConnect(abort) {
      if (!this.callback) {
        throw new RequestAbortedError();
      }
      this.abort = abort;
    }
    onUpgrade(statusCode, headers, socket) {
      const {callback, opaque} = this;
      removeSignal(this);
      this.callback = null;
      this.runInAsyncScope(callback, null, null, {
        statusCode,
        headers: util2.parseHeaders(headers),
        socket,
        opaque
      });
    }
    onError(err) {
      const {callback, opaque} = this;
      removeSignal(this);
      if (callback) {
        this.callback = null;
        process.nextTick((self2, callback2, err2, opaque2) => {
          self2.runInAsyncScope(callback2, null, err2, {opaque: opaque2});
        }, this, callback, err, opaque);
      }
    }
  };
  function connect(opts, callback) {
    if (callback === void 0) {
      return new Promise((resolve, reject) => {
        connect.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    if (typeof callback !== "function") {
      throw new InvalidArgumentError("invalid callback");
    }
    try {
      const connectHandler = new ConnectHandler(opts, callback);
      const {
        path: path10,
        headers,
        signal
      } = opts;
      this.dispatch({
        path: path10,
        method: "CONNECT",
        headers,
        signal
      }, connectHandler);
    } catch (err) {
      process.nextTick(callback, err, {opaque: opts && opts.opaque});
    }
  }
  module2.exports = connect;
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/pool.js
var require_pool = __commonJS((exports2, module2) => {
  "use strict";
  var EventEmitter = require("events");
  var Client = require_client();
  var {
    ClientClosedError,
    InvalidArgumentError,
    ClientDestroyedError
  } = require_errors();
  var FixedQueue = require_fixed_queue();
  var util2 = require_util4();
  var kClients = Symbol("clients");
  var kNeedDrain = Symbol("needDrain");
  var kQueue = Symbol("queue");
  var kDestroyed = Symbol("destroyed");
  var kClosedPromise = Symbol("closed promise");
  var kClosedResolve = Symbol("closed resolve");
  var kOptions = Symbol("options");
  var kUrl = Symbol("url");
  var kOnDrain = Symbol("onDrain");
  var kOnConnect = Symbol("onConnect");
  var kOnDisconnect = Symbol("onDisconnect");
  var kPending = Symbol("pending");
  var kConnected = Symbol("connected");
  var kConnections = Symbol("connections");
  var Pool = class extends EventEmitter {
    constructor(origin, {connections, ...options} = {}) {
      super();
      if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
        throw new InvalidArgumentError("invalid connections");
      }
      this[kConnections] = connections || null;
      this[kUrl] = util2.parseOrigin(origin);
      this[kOptions] = JSON.parse(JSON.stringify(options));
      this[kQueue] = new FixedQueue();
      this[kClosedPromise] = null;
      this[kClosedResolve] = null;
      this[kDestroyed] = false;
      this[kClients] = [];
      this[kNeedDrain] = false;
      this[kPending] = 0;
      this[kConnected] = 0;
      const pool = this;
      this[kOnDrain] = function onDrain() {
        const queue = pool[kQueue];
        while (!this.busy) {
          const item = queue.shift();
          if (!item) {
            break;
          }
          pool[kPending]--;
          this.dispatch(item.opts, item.handler);
        }
        if (pool[kNeedDrain] && !this.busy) {
          pool[kNeedDrain] = false;
          pool.emit("drain");
        }
        if (pool[kClosedResolve] && queue.isEmpty()) {
          Promise.all(pool[kClients].map((c) => c.close())).then(pool[kClosedResolve]);
        }
      };
      this[kOnConnect] = function onConnect() {
        pool[kConnected]++;
        pool.emit("connect", this);
      };
      this[kOnDisconnect] = function onDisconnect(err) {
        pool[kConnected]--;
        pool.emit("disconnect", this, err);
      };
    }
    get url() {
      return this[kUrl];
    }
    get connected() {
      return this[kConnected];
    }
    get busy() {
      if (this[kPending] > 0) {
        return true;
      }
      if (this[kConnections] && this[kClients].length === this[kConnections]) {
        for (const {busy} of this[kClients]) {
          if (!busy) {
            return false;
          }
        }
        return true;
      }
      return false;
    }
    get pending() {
      let ret = this[kPending];
      for (const {pending} of this[kClients]) {
        ret += pending;
      }
      return ret;
    }
    get running() {
      let ret = 0;
      for (const {running} of this[kClients]) {
        ret += running;
      }
      return ret;
    }
    get size() {
      let ret = this[kPending];
      for (const {size} of this[kClients]) {
        ret += size;
      }
      return ret;
    }
    get destroyed() {
      return this[kDestroyed];
    }
    get closed() {
      return this[kClosedPromise] != null;
    }
    dispatch(opts, handler) {
      try {
        if (this[kDestroyed]) {
          throw new ClientDestroyedError();
        }
        if (this[kClosedPromise]) {
          throw new ClientClosedError();
        }
        let client = this[kClients].find((client2) => !client2.busy);
        if (!client) {
          if (!this[kConnections] || this[kClients].length < this[kConnections]) {
            client = new Client(this[kUrl], this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]);
            this[kClients].push(client);
          }
        }
        if (!client) {
          this[kNeedDrain] = true;
          this[kQueue].push({opts, handler});
          this[kPending]++;
        } else {
          client.dispatch(opts, handler);
          if (client.busy && this.busy) {
            this[kNeedDrain] = true;
          }
        }
      } catch (err) {
        if (typeof handler.onError !== "function") {
          throw new InvalidArgumentError("invalid onError method");
        }
        handler.onError(err);
      }
    }
    close(cb) {
      try {
        if (this[kDestroyed]) {
          throw new ClientDestroyedError();
        }
        if (!this[kClosedPromise]) {
          if (this[kQueue].isEmpty()) {
            this[kClosedPromise] = Promise.all(this[kClients].map((c) => c.close()));
          } else {
            this[kClosedPromise] = new Promise((resolve) => {
              this[kClosedResolve] = resolve;
            });
          }
          this[kClosedPromise] = this[kClosedPromise].then(() => {
            this[kDestroyed] = true;
          });
        }
        if (cb) {
          this[kClosedPromise].then(() => cb(null, null));
        } else {
          return this[kClosedPromise];
        }
      } catch (err) {
        if (cb) {
          cb(err);
        } else {
          return Promise.reject(err);
        }
      }
    }
    destroy(err, cb) {
      this[kDestroyed] = true;
      if (typeof err === "function") {
        cb = err;
        err = null;
      }
      if (!err) {
        err = new ClientDestroyedError();
      }
      while (true) {
        const item = this[kQueue].shift();
        if (!item) {
          break;
        }
        item.handler.onError(err);
      }
      const promise = Promise.all(this[kClients].map((c) => c.destroy(err)));
      if (cb) {
        promise.then(() => cb(null, null));
      } else {
        return promise;
      }
    }
  };
  Pool.prototype.request = require_client_request();
  Pool.prototype.stream = require_client_stream();
  Pool.prototype.pipeline = require_client_pipeline();
  Pool.prototype.upgrade = require_client_upgrade();
  Pool.prototype.connect = require_client_connect();
  module2.exports = Pool;
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/agent.js
var require_agent3 = __commonJS((exports2, module2) => {
  "use strict";
  var {InvalidArgumentError, InvalidReturnValueError} = require_errors();
  var Pool = require_pool();
  var util2 = require_util4();
  var {kAgentOpts, kAgentCache} = require_symbols();
  var Agent = class {
    constructor(opts) {
      this[kAgentOpts] = opts;
      this[kAgentCache] = new Map();
    }
    get(origin) {
      if (typeof origin !== "string" || origin === "") {
        throw new InvalidArgumentError("Origin must be a non-empty string.");
      }
      const self2 = this;
      let pool = self2[kAgentCache].get(origin);
      function onDisconnect() {
        if (this.connected === 0 && this.size === 0) {
          this.off("disconnect", onDisconnect);
          self2[kAgentCache].delete(origin);
        }
      }
      if (!pool) {
        pool = new Pool(origin, self2[kAgentOpts]);
        pool.on("disconnect", onDisconnect);
        self2[kAgentCache].set(origin, pool);
      }
      return pool;
    }
    close() {
      const closePromises = [];
      for (const pool of this[kAgentCache].values()) {
        closePromises.push(pool.close());
      }
      return Promise.all(closePromises);
    }
    destroy() {
      const destroyPromises = [];
      for (const pool of this[kAgentCache].values()) {
        destroyPromises.push(pool.destroy());
      }
      return Promise.all(destroyPromises);
    }
  };
  var globalAgent = new Agent({connections: null});
  function setGlobalAgent(agent) {
    if (!agent || typeof agent.get !== "function") {
      throw new InvalidArgumentError("Argument agent must implement Agent");
    }
    globalAgent = agent;
  }
  function dispatchFromAgent(requestType) {
    return (url, {agent = globalAgent, method = "GET", ...opts} = {}, ...additionalArgs) => {
      if (opts.path != null) {
        throw new InvalidArgumentError("unsupported opts.path");
      }
      const {origin, pathname, search} = util2.parseURL(url);
      const path10 = `${pathname || "/"}${search || ""}`;
      const client = agent.get(origin);
      if (client && typeof client[requestType] !== "function") {
        throw new InvalidReturnValueError(`Client returned from Agent.get() does not implement method ${requestType}`);
      }
      return client[requestType]({...opts, method, path: path10}, ...additionalArgs);
    };
  }
  module2.exports = {
    request: dispatchFromAgent("request"),
    stream: dispatchFromAgent("stream"),
    pipeline: dispatchFromAgent("pipeline"),
    connect: dispatchFromAgent("connect"),
    upgrade: dispatchFromAgent("upgrade"),
    setGlobalAgent,
    Agent
  };
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/index.js
var require_undici = __commonJS((exports2, module2) => {
  "use strict";
  var Client = require_client();
  var errors = require_errors();
  var Pool = require_pool();
  var {Agent, request, stream, pipeline, setGlobalAgent} = require_agent3();
  Client.prototype.request = require_client_request();
  Client.prototype.stream = require_client_stream();
  Client.prototype.pipeline = require_client_pipeline();
  Client.prototype.upgrade = require_client_upgrade();
  Client.prototype.connect = require_client_connect();
  function undici(url, opts) {
    return new Pool(url, opts);
  }
  undici.Pool = Pool;
  undici.Client = Client;
  undici.errors = errors;
  undici.Agent = Agent;
  undici.request = request;
  undici.stream = stream;
  undici.pipeline = pipeline;
  undici.setGlobalAgent = setGlobalAgent;
  module2.exports = undici;
});

// ../../node_modules/.pnpm/@prisma+engine-core@2.30.2/node_modules/@prisma/engine-core/dist/binary/Connection.js
var require_Connection = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    Connection: () => Connection
  });
  var import_undici = __toModule3(require_undici());
  var getStream = require_get_stream();
  function assertHasPool(pool) {
    if (pool === void 0) {
      throw new Error("Connection has not been opened");
    }
  }
  var Connection = class {
    constructor() {
    }
    static async onHttpError(response, handler) {
      const _response = await response;
      if (_response.statusCode >= 400) {
        return handler(_response);
      }
      return _response;
    }
    open(url, options) {
      if (this._pool)
        return;
      this._pool = new import_undici.Pool(url, {
        connections: 100,
        pipelining: 10,
        keepAliveMaxTimeout: 6e5,
        headersTimeout: 0,
        ...options
      });
    }
    async raw(method, endpoint, headers, body) {
      assertHasPool(this._pool);
      const response = await this._pool.request({
        path: endpoint,
        method,
        headers: {
          "Content-Type": "application/json",
          ...headers
        },
        body,
        bodyTimeout: 0
      });
      const result = {
        statusCode: response.statusCode,
        headers: response.headers,
        data: JSON.parse(await getStream(response.body))
      };
      return result;
    }
    post(endpoint, body, headers) {
      return this.raw("POST", endpoint, headers, body);
    }
    get(path10, headers) {
      return this.raw("GET", path10, headers);
    }
    close() {
      if (this._pool) {
        this._pool.close(() => {
        });
      }
      this._pool = void 0;
    }
  };
});

// ../../node_modules/.pnpm/@prisma+engine-core@2.30.2/node_modules/@prisma/engine-core/dist/binary/BinaryEngine.js
var require_BinaryEngine = __commonJS((exports, module) => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name in all)
      __defProp(target, name, {get: all[name], enumerable: true});
  };
  var __reExport = (target, module2, desc) => {
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
      for (let key of __getOwnPropNames(module2))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule = (module2) => {
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
  };
  __export(exports, {
    BinaryEngine: () => BinaryEngine
  });
  var import_debug = __toModule(require_dist2());
  var import_engines = __toModule(require("@prisma/engines"));
  var import_get_platform = __toModule(require_dist4());
  var import_chalk = __toModule(require_source());
  var import_child_process = __toModule(require("child_process"));
  var import_events = __toModule(require("events"));
  var import_execa = __toModule(require_execa());
  var import_fs = __toModule(require("fs"));
  var import_net = __toModule(require("net"));
  var import_p_retry = __toModule(require_p_retry());
  var import_path = __toModule(require("path"));
  var import_url = __toModule(require("url"));
  var import_util = __toModule(require("util"));
  var import_byline = __toModule(require_byline());
  var import_Engine = __toModule(require_Engine());
  var import_PrismaClientKnownRequestError = __toModule(require_PrismaClientKnownRequestError());
  var import_PrismaClientInitializationError = __toModule(require_PrismaClientInitializationError());
  var import_PrismaClientRustError = __toModule(require_PrismaClientRustError());
  var import_PrismaClientRustPanicError = __toModule(require_PrismaClientRustPanicError());
  var import_PrismaClientUnknownRequestError = __toModule(require_PrismaClientUnknownRequestError());
  var import_getErrorMessageWithLink = __toModule(require_getErrorMessageWithLink());
  var import_log = __toModule(require_log2());
  var import_omit = __toModule(require_omit());
  var import_printGeneratorConfig = __toModule(require_printGeneratorConfig());
  var import_Connection = __toModule(require_Connection());
  var import_util2 = __toModule(require_util3());
  var debug = (0, import_debug.default)("prisma:engine");
  var exists = (0, import_util.promisify)(import_fs.default.exists);
  var logger = (...args2) => {
  };
  var knownPlatforms = [...import_get_platform.platforms, "native"];
  var engines = [];
  var socketPaths = [];
  var MAX_STARTS = process.env.PRISMA_CLIENT_NO_RETRY ? 1 : 2;
  var MAX_REQUEST_RETRIES = process.env.PRISMA_CLIENT_NO_RETRY ? 1 : 2;
  var BinaryEngine = class extends import_Engine.Engine {
    constructor({
      cwd,
      datamodelPath,
      prismaPath,
      generator,
      datasources,
      showColors,
      logLevel,
      logQueries,
      env: env2,
      flags,
      clientVersion,
      previewFeatures,
      engineEndpoint,
      enableDebugLogs,
      enableEngineDebugMode,
      dirname: dirname2,
      useUds,
      activeProvider
    }) {
      super();
      this.startCount = 0;
      this.previewFeatures = [];
      this.useUds = false;
      this.stderrLogs = "";
      this.handleRequestError = async (error, graceful = false) => {
        var _a2, _b;
        debug({error});
        if (this.startPromise) {
          await this.startPromise;
        }
        this.throwAsyncErrorIfExists();
        if ((_a2 = this.currentRequestPromise) == null ? void 0 : _a2.isCanceled) {
          this.throwAsyncErrorIfExists();
        } else if (error.code === "ECONNRESET" || error.code === "ECONNREFUSED" || error.code === "UND_ERR_CLOSED" || error.code === "UND_ERR_SOCKET" || error.code === "UND_ERR_DESTROYED" || error.code === "UND_ERR_ABORTED" || error.message.toLowerCase().includes("client is destroyed") || error.message.toLowerCase().includes("other side closed") || error.message.toLowerCase().includes("the client is closed")) {
          if (this.globalKillSignalReceived && !((_b = this.child) == null ? void 0 : _b.connected)) {
            throw new import_PrismaClientUnknownRequestError.PrismaClientUnknownRequestError(`The Node.js process already received a ${this.globalKillSignalReceived} signal, therefore the Prisma query engine exited
and your request can't be processed.
You probably have some open handle that prevents your process from exiting.
It could be an open http server or stream that didn't close yet.
We recommend using the \`wtfnode\` package to debug open handles.`, this.clientVersion);
          }
          this.throwAsyncErrorIfExists();
          if (this.startCount > MAX_STARTS) {
            for (let i = 0; i < 5; i++) {
              await new Promise((r) => setTimeout(r, 50));
              this.throwAsyncErrorIfExists(true);
            }
            throw new Error(`Query engine is trying to restart, but can't.
Please look into the logs or turn on the env var DEBUG=* to debug the constantly restarting query engine.`);
          }
        }
        if (!graceful) {
          this.throwAsyncErrorIfExists(true);
          throw error;
        }
        return false;
      };
      var _a;
      this.dirname = dirname2;
      this.useUds = useUds != null ? useUds : false;
      this.env = env2;
      this.cwd = this.resolveCwd(cwd);
      this.enableDebugLogs = enableDebugLogs != null ? enableDebugLogs : false;
      this.enableEngineDebugMode = enableEngineDebugMode != null ? enableEngineDebugMode : false;
      this.datamodelPath = datamodelPath;
      this.prismaPath = (_a = process.env.PRISMA_QUERY_ENGINE_BINARY) != null ? _a : prismaPath;
      this.generator = generator;
      this.datasources = datasources;
      this.logEmitter = new import_events.default();
      this.logEmitter.on("error", () => {
      });
      this.showColors = showColors != null ? showColors : false;
      this.logLevel = logLevel;
      this.logQueries = logQueries != null ? logQueries : false;
      this.clientVersion = clientVersion;
      this.flags = flags != null ? flags : [];
      this.previewFeatures = previewFeatures != null ? previewFeatures : [];
      this.activeProvider = activeProvider;
      this.connection = new import_Connection.Connection();
      initHooks();
      const removedFlags = [
        "middlewares",
        "aggregateApi",
        "distinct",
        "aggregations",
        "insensitiveFilters",
        "atomicNumberOperations",
        "transactionApi",
        "transaction",
        "connectOrCreate",
        "uncheckedScalarInputs",
        "nativeTypes",
        "createMany",
        "groupBy"
      ];
      const removedFlagsUsed = this.previewFeatures.filter((e) => removedFlags.includes(e));
      if (removedFlagsUsed.length > 0 && !process.env.PRISMA_HIDE_PREVIEW_FLAG_WARNINGS) {
        console.log(`${import_chalk.default.blueBright("info")} The preview flags \`${removedFlagsUsed.join("`, `")}\` were removed, you can now safely remove them from your schema.prisma.`);
      }
      this.previewFeatures = this.previewFeatures.filter((e) => !removedFlags.includes(e));
      this.engineEndpoint = engineEndpoint;
      if (engineEndpoint) {
        const url = new import_url.URL(engineEndpoint);
        this.port = Number(url.port);
      }
      if (this.platform) {
        if (!knownPlatforms.includes(this.platform) && !import_fs.default.existsSync(this.platform)) {
          throw new import_PrismaClientInitializationError.PrismaClientInitializationError(`Unknown ${import_chalk.default.red("PRISMA_QUERY_ENGINE_BINARY")} ${import_chalk.default.redBright.bold(this.platform)}. Possible binaryTargets: ${import_chalk.default.greenBright(knownPlatforms.join(", "))} or a path to the query engine binary.
You may have to run ${import_chalk.default.greenBright("prisma generate")} for your changes to take effect.`, this.clientVersion);
        }
      } else {
        void this.getPlatform();
      }
      if (this.enableDebugLogs) {
        import_debug.default.enable("*");
      }
      engines.push(this);
      this.checkForTooManyEngines();
    }
    setError(err) {
      var _a;
      if ((0, import_log.isRustError)(err)) {
        this.lastRustError = err;
        this.logEmitter.emit("error", new import_PrismaClientRustError.PrismaClientRustError({
          clientVersion: this.clientVersion,
          error: err
        }));
        if (err.is_panic) {
          this.handlePanic();
        }
      } else if ((0, import_log.isRustErrorLog)(err)) {
        this.lastErrorLog = err;
        this.logEmitter.emit("error", new import_PrismaClientRustError.PrismaClientRustError({
          clientVersion: this.clientVersion,
          log: err
        }));
        if (((_a = err.fields) == null ? void 0 : _a.message) === "PANIC") {
          this.handlePanic();
        }
      } else {
        this.logEmitter.emit("error", err);
      }
    }
    checkForTooManyEngines() {
      if (engines.length >= 10) {
        const runningEngines = engines.filter((e) => e.child);
        if (runningEngines.length === 10) {
          console.warn(`${import_chalk.default.yellow("warn(prisma-client)")} Already 10 Prisma Clients are actively running.`);
        }
      }
    }
    resolveCwd(cwd) {
      if (cwd && import_fs.default.existsSync(cwd) && import_fs.default.lstatSync(cwd).isDirectory()) {
        return cwd;
      }
      return process.cwd();
    }
    on(event, listener) {
      if (event === "beforeExit") {
        this.beforeExitListener = listener;
      } else {
        this.logEmitter.on(event, listener);
      }
    }
    async emitExit() {
      if (this.beforeExitListener) {
        try {
          await this.beforeExitListener();
        } catch (e) {
          console.error(e);
        }
      }
    }
    async getPlatform() {
      if (this.platformPromise) {
        return this.platformPromise;
      }
      this.platformPromise = (0, import_get_platform.getPlatform)();
      return this.platformPromise;
    }
    getQueryEnginePath(platform, prefix = __dirname) {
      let queryEnginePath = import_path.default.join(prefix, `query-engine-${platform}`);
      if (platform === "windows") {
        queryEnginePath = `${queryEnginePath}.exe`;
      }
      return queryEnginePath;
    }
    handlePanic() {
      var _a, _b;
      (_a = this.child) == null ? void 0 : _a.kill();
      if ((_b = this.currentRequestPromise) == null ? void 0 : _b.cancel) {
        this.currentRequestPromise.cancel();
      }
    }
    async resolvePrismaPath() {
      var _a, _b, _c;
      const searchedLocations = [];
      let enginePath;
      if (this.prismaPath) {
        return {prismaPath: this.prismaPath, searchedLocations};
      }
      const platform = await this.getPlatform();
      if (this.platform && this.platform !== platform) {
        this.incorrectlyPinnedBinaryTarget = this.platform;
      }
      this.platform = this.platform || platform;
      if (__filename.includes("BinaryEngine")) {
        enginePath = this.getQueryEnginePath(this.platform, (0, import_engines.getEnginesPath)());
        return {prismaPath: enginePath, searchedLocations};
      }
      const searchLocations = [
        eval(`require('path').join(__dirname, '../../../.prisma/client')`),
        (_c = (_b = (_a = this.generator) == null ? void 0 : _a.output) == null ? void 0 : _b.value) != null ? _c : eval("__dirname"),
        import_path.default.join(eval("__dirname"), ".."),
        import_path.default.dirname(this.datamodelPath),
        this.cwd,
        "/tmp/prisma-engines"
      ];
      if (this.dirname) {
        searchLocations.push(this.dirname);
      }
      for (const location of searchLocations) {
        searchedLocations.push(location);
        debug(`Search for Query Engine in ${location}`);
        enginePath = this.getQueryEnginePath(this.platform, location);
        if (import_fs.default.existsSync(enginePath)) {
          return {prismaPath: enginePath, searchedLocations};
        }
      }
      enginePath = this.getQueryEnginePath(this.platform);
      return {prismaPath: enginePath != null ? enginePath : "", searchedLocations};
    }
    async getPrismaPath() {
      const {prismaPath, searchedLocations} = await this.resolvePrismaPath();
      const platform = await this.getPlatform();
      if (!await exists(prismaPath)) {
        const pinnedStr = this.incorrectlyPinnedBinaryTarget ? `
You incorrectly pinned it to ${import_chalk.default.redBright.bold(`${this.incorrectlyPinnedBinaryTarget}`)}
` : "";
        let errorText = `Query engine binary for current platform "${import_chalk.default.bold(platform)}" could not be found.${pinnedStr}
This probably happens, because you built Prisma Client on a different platform.
(Prisma Client looked in "${import_chalk.default.underline(prismaPath)}")

Searched Locations:

${searchedLocations.map((f) => {
          let msg = `  ${f}`;
          if (process.env.DEBUG === "node-engine-search-locations" && import_fs.default.existsSync(f)) {
            const dir = import_fs.default.readdirSync(f);
            msg += dir.map((d2) => `    ${d2}`).join("\n");
          }
          return msg;
        }).join("\n" + (process.env.DEBUG === "node-engine-search-locations" ? "\n" : ""))}
`;
        if (this.generator) {
          if (this.generator.binaryTargets.find((object) => object.value === this.platform) || this.generator.binaryTargets.find((object) => object.value === "native")) {
            errorText += `
You already added the platform${this.generator.binaryTargets.length > 1 ? "s" : ""} ${this.generator.binaryTargets.map((t) => `"${import_chalk.default.bold(t.value)}"`).join(", ")} to the "${import_chalk.default.underline("generator")}" block
in the "schema.prisma" file as described in https://pris.ly/d/client-generator,
but something went wrong. That's suboptimal.

Please create an issue at https://github.com/prisma/prisma/issues/new`;
            errorText += ``;
          } else {
            errorText += `

To solve this problem, add the platform "${this.platform}" to the "${import_chalk.default.underline("binaryTargets")}" attribute in the "${import_chalk.default.underline("generator")}" block in the "schema.prisma" file:
${import_chalk.default.greenBright(this.getFixedGenerator())}

Then run "${import_chalk.default.greenBright("prisma generate")}" for your changes to take effect.
Read more about deploying Prisma Client: https://pris.ly/d/client-generator`;
          }
        } else {
          errorText += `

Read more about deploying Prisma Client: https://pris.ly/d/client-generator
`;
        }
        throw new import_PrismaClientInitializationError.PrismaClientInitializationError(errorText, this.clientVersion);
      }
      if (this.incorrectlyPinnedBinaryTarget) {
        console.error(`${import_chalk.default.yellow("Warning:")} You pinned the platform ${import_chalk.default.bold(this.incorrectlyPinnedBinaryTarget)}, but Prisma Client detects ${import_chalk.default.bold(await this.getPlatform())}.
This means you should very likely pin the platform ${import_chalk.default.greenBright(await this.getPlatform())} instead.
${import_chalk.default.dim("In case we're mistaken, please report this to us \u{1F64F}.")}`);
      }
      if (process.platform !== "win32") {
        (0, import_util2.plusX)(prismaPath);
      }
      return prismaPath;
    }
    getFixedGenerator() {
      const fixedGenerator = {
        ...this.generator,
        binaryTargets: (0, import_util2.fixBinaryTargets)(this.generator.binaryTargets, this.platform)
      };
      return (0, import_printGeneratorConfig.printGeneratorConfig)(fixedGenerator);
    }
    printDatasources() {
      if (this.datasources) {
        return JSON.stringify(this.datasources);
      }
      return "[]";
    }
    async start() {
      if (this.stopPromise) {
        await this.stopPromise;
      }
      if (!this.startPromise) {
        this.startCount++;
        this.startPromise = this.internalStart();
      }
      await this.startPromise;
      if (!this.child && !this.engineEndpoint) {
        throw new import_PrismaClientUnknownRequestError.PrismaClientUnknownRequestError(`Can't perform request, as the Engine has already been stopped`, this.clientVersion);
      }
      return this.startPromise;
    }
    getEngineEnvVars() {
      const env2 = {
        PRISMA_DML_PATH: this.datamodelPath,
        RUST_BACKTRACE: "1",
        RUST_LOG: "info"
      };
      if (this.logQueries || this.logLevel === "info") {
        env2.RUST_LOG = "info";
        if (this.logQueries) {
          env2.LOG_QUERIES = "true";
        }
      }
      if (this.datasources) {
        env2.OVERWRITE_DATASOURCES = this.printDatasources();
      }
      if (!process.env.NO_COLOR && this.showColors) {
        env2.CLICOLOR_FORCE = "1";
      }
      return {
        ...this.env,
        ...process.env,
        ...env2
      };
    }
    internalStart() {
      return new Promise(async (resolve, reject) => {
        var _a, _b, _c;
        await new Promise((r) => process.nextTick(r));
        if (this.stopPromise) {
          await this.stopPromise;
        }
        if (this.engineEndpoint) {
          try {
            await (0, import_p_retry.default)(() => this.connection.get("/"), {
              retries: 10
            });
          } catch (e) {
            return reject(e);
          }
          return resolve();
        }
        try {
          if (((_a = this.child) == null ? void 0 : _a.connected) || this.child && !((_b = this.child) == null ? void 0 : _b.killed)) {
            debug(`There is a child that still runs and we want to start again`);
          }
          this.lastRustError = void 0;
          this.lastErrorLog = void 0;
          this.lastPanic = void 0;
          logger("startin & resettin");
          this.globalKillSignalReceived = void 0;
          if (this.useUds) {
            this.socketPath = `/tmp/prisma-${(0, import_util2.getRandomString)()}.sock`;
            socketPaths.push(this.socketPath);
          }
          debug({cwd: this.cwd});
          const prismaPath = await this.getPrismaPath();
          const debugFlag = this.enableEngineDebugMode ? ["--debug"] : [];
          const flags = [...debugFlag, "--enable-raw-queries", ...this.flags];
          if (this.useUds) {
            flags.push("--unix-path", this.socketPath);
          } else {
            this.port = await this.getFreePort();
            flags.push("--port", String(this.port));
          }
          debug({flags});
          const env2 = this.getEngineEnvVars();
          this.child = (0, import_child_process.spawn)(prismaPath, flags, {
            env: env2,
            cwd: this.cwd,
            windowsHide: true,
            stdio: ["ignore", "pipe", "pipe"]
          });
          (0, import_byline.default)(this.child.stderr).on("data", (msg) => {
            const data = String(msg);
            debug("stderr", data);
            try {
              const json = JSON.parse(data);
              if (typeof json.is_panic !== "undefined") {
                debug(json);
                this.setError(json);
                if (this.engineStartDeferred) {
                  const err = new import_PrismaClientInitializationError.PrismaClientInitializationError(json.message, this.clientVersion);
                  this.engineStartDeferred.reject(err);
                }
              }
            } catch (e) {
              if (!data.includes("Printing to stderr") && !data.includes("Listening on ")) {
                this.stderrLogs += "\n" + data;
              }
            }
          });
          (0, import_byline.default)(this.child.stdout).on("data", (msg) => {
            var _a2, _b2;
            const data = String(msg);
            try {
              const json = JSON.parse(data);
              debug("stdout", (0, import_log.getMessage)(json));
              if (this.engineStartDeferred && json.level === "INFO" && json.target === "query_engine::server" && ((_b2 = (_a2 = json.fields) == null ? void 0 : _a2.message) == null ? void 0 : _b2.startsWith("Started http server"))) {
                if (this.useUds) {
                  this.connection.open("http://localhost", {
                    socketPath: this.socketPath
                  });
                } else {
                  this.connection.open(`http://localhost:${this.port}`);
                }
                this.engineStartDeferred.resolve();
                this.engineStartDeferred = void 0;
              }
              if (typeof json.is_panic === "undefined") {
                const log2 = (0, import_log.convertLog)(json);
                const logIsRustErrorLog = (0, import_log.isRustErrorLog)(log2);
                if (logIsRustErrorLog) {
                  this.setError(log2);
                } else {
                  this.logEmitter.emit(log2.level, log2);
                }
              } else {
                this.setError(json);
              }
            } catch (e) {
              debug(e, data);
            }
          });
          this.child.on("exit", (code) => {
            var _a2;
            logger("removing startPromise");
            this.startPromise = void 0;
            if (this.engineStopDeferred) {
              this.engineStopDeferred.resolve(code);
              return;
            }
            this.connection.close();
            if (code !== 0 && this.engineStartDeferred && this.startCount === 1) {
              let err;
              let msg = this.stderrLogs;
              if (this.lastRustError) {
                msg = (0, import_log.getMessage)(this.lastRustError);
              } else if (this.lastErrorLog) {
                msg = (0, import_log.getMessage)(this.lastErrorLog);
              }
              if (code !== null) {
                err = new import_PrismaClientInitializationError.PrismaClientInitializationError(`Query engine exited with code ${code}
` + msg, this.clientVersion);
              } else if ((_a2 = this.child) == null ? void 0 : _a2.signalCode) {
                err = new import_PrismaClientInitializationError.PrismaClientInitializationError(`Query engine process killed with signal ${this.child.signalCode} for unknown reason.
Make sure that the engine binary at ${prismaPath} is not corrupt.
` + msg, this.clientVersion);
              } else {
                err = new import_PrismaClientInitializationError.PrismaClientInitializationError(msg, this.clientVersion);
              }
              this.engineStartDeferred.reject(err);
            }
            if (!this.child) {
              return;
            }
            if (this.lastRustError) {
              return;
            }
            if (code === 126) {
              this.setError({
                timestamp: new Date(),
                target: "exit",
                level: "error",
                fields: {
                  message: `Couldn't start query engine as it's not executable on this operating system.
You very likely have the wrong "binaryTarget" defined in the schema.prisma file.`
                }
              });
            }
          });
          this.child.on("error", (err) => {
            this.setError({
              message: err.message,
              backtrace: "Could not start query engine",
              is_panic: false
            });
            reject(err);
          });
          this.child.on("close", (code, signal) => {
            var _a2;
            this.connection.close();
            if (code === null && signal === "SIGABRT" && this.child) {
              const error = new import_PrismaClientRustPanicError.PrismaClientRustPanicError(this.getErrorMessageWithLink("Panic in Query Engine with SIGABRT signal"), this.clientVersion);
              this.logEmitter.emit("error", error);
            } else if (code === 255 && signal === null && ((_a2 = this.lastErrorLog) == null ? void 0 : _a2.fields.message) === "PANIC" && !this.lastPanic) {
              const error = new import_PrismaClientRustPanicError.PrismaClientRustPanicError(this.getErrorMessageWithLink(`${this.lastErrorLog.fields.message}: ${this.lastErrorLog.fields.reason} in ${this.lastErrorLog.fields.file}:${this.lastErrorLog.fields.line}:${this.lastErrorLog.fields.column}`), this.clientVersion);
              this.setError(error);
            }
          });
          if (this.lastRustError) {
            return reject(new import_PrismaClientInitializationError.PrismaClientInitializationError((0, import_log.getMessage)(this.lastRustError), this.clientVersion));
          }
          if (this.lastErrorLog) {
            return reject(new import_PrismaClientInitializationError.PrismaClientInitializationError((0, import_log.getMessage)(this.lastErrorLog), this.clientVersion));
          }
          try {
            await new Promise((resolve2, reject2) => {
              this.engineStartDeferred = {resolve: resolve2, reject: reject2};
            });
          } catch (err) {
            (_c = this.child) == null ? void 0 : _c.kill();
            throw err;
          }
          void (async () => {
            try {
              const engineVersion = await this.version(true);
              debug(`Client Version: ${this.clientVersion}`);
              debug(`Engine Version: ${engineVersion}`);
              debug(`Active provider: ${this.activeProvider}`);
            } catch (e) {
              debug(e);
            }
          })();
          this.stopPromise = void 0;
          resolve();
        } catch (e) {
          reject(e);
        }
      });
    }
    async stop() {
      if (!this.stopPromise) {
        this.stopPromise = this._stop();
      }
      return this.stopPromise;
    }
    async _stop() {
      var _a;
      if (this.startPromise) {
        await this.startPromise;
      }
      await new Promise((resolve) => process.nextTick(resolve));
      if (this.currentRequestPromise) {
        try {
          await this.currentRequestPromise;
        } catch (e) {
        }
      }
      this.getConfigPromise = void 0;
      let stopChildPromise;
      if (this.child) {
        debug(`Stopping Prisma engine4`);
        if (this.startPromise) {
          debug(`Waiting for start promise`);
          await this.startPromise;
        }
        debug(`Done waiting for start promise`);
        stopChildPromise = new Promise((resolve, reject) => {
          this.engineStopDeferred = {resolve, reject};
        });
        this.connection.close();
        (_a = this.child) == null ? void 0 : _a.kill();
        this.child = void 0;
      }
      if (stopChildPromise) {
        await stopChildPromise;
      }
      await new Promise((r) => process.nextTick(r));
      this.startPromise = void 0;
      this.engineStopDeferred = void 0;
    }
    kill(signal) {
      var _a;
      this.getConfigPromise = void 0;
      this.globalKillSignalReceived = signal;
      (_a = this.child) == null ? void 0 : _a.kill();
      this.connection.close();
    }
    getFreePort() {
      return new Promise((resolve, reject) => {
        const server = import_net.default.createServer((s2) => s2.end(""));
        server.unref();
        server.on("error", reject);
        server.listen(0, () => {
          const address = server.address();
          const port = typeof address === "string" ? parseInt(address.split(":").slice(-1)[0], 10) : address.port;
          server.close((e) => {
            if (e) {
              reject(e);
            }
            resolve(port);
          });
        });
      });
    }
    async getConfig() {
      if (!this.getConfigPromise) {
        this.getConfigPromise = this._getConfig();
      }
      return this.getConfigPromise;
    }
    async _getConfig() {
      const prismaPath = await this.getPrismaPath();
      const env2 = await this.getEngineEnvVars();
      const result = await (0, import_execa.default)(prismaPath, ["cli", "get-config"], {
        env: (0, import_omit.omit)(env2, ["PORT"]),
        cwd: this.cwd
      });
      return JSON.parse(result.stdout);
    }
    async version(forceRun = false) {
      if (this.versionPromise && !forceRun) {
        return this.versionPromise;
      }
      this.versionPromise = this.internalVersion();
      return this.versionPromise;
    }
    async internalVersion() {
      const prismaPath = await this.getPrismaPath();
      const result = await (0, import_execa.default)(prismaPath, ["--version"]);
      this.lastVersion = result.stdout;
      return this.lastVersion;
    }
    async request(query, headers = {}, numTry = 1) {
      await this.start();
      this.currentRequestPromise = this.connection.post("/", stringifyQuery(query), runtimeHeadersToHttpHeaders(headers));
      this.lastQuery = query;
      try {
        const {data, headers: headers2} = await this.currentRequestPromise;
        if (data.errors) {
          if (data.errors.length === 1) {
            throw this.graphQLToJSError(data.errors[0]);
          }
          throw new import_PrismaClientUnknownRequestError.PrismaClientUnknownRequestError(JSON.stringify(data.errors), this.clientVersion);
        }
        const elapsed = parseInt(headers2["x-elapsed"]) / 1e3;
        if (this.startCount > 0) {
          this.startCount = 0;
        }
        this.currentRequestPromise = void 0;
        return {data, elapsed};
      } catch (error) {
        logger("req - e", error);
        if (error instanceof import_PrismaClientKnownRequestError.PrismaClientKnownRequestError) {
          throw error;
        }
        await this.handleRequestError(error, numTry <= MAX_REQUEST_RETRIES);
        if (numTry <= MAX_REQUEST_RETRIES) {
          logger("trying a retry now");
          return this.request(query, headers, numTry + 1);
        }
      }
      return null;
    }
    async requestBatch(queries, headers = {}, transaction = false, numTry = 1) {
      await this.start();
      const request = {
        batch: queries.map((query) => ({query, variables: {}})),
        transaction
      };
      this.lastQuery = JSON.stringify(request);
      this.currentRequestPromise = this.connection.post("/", this.lastQuery, runtimeHeadersToHttpHeaders(headers));
      return this.currentRequestPromise.then(({data, headers: headers2}) => {
        const elapsed = parseInt(headers2["x-elapsed"]) / 1e3;
        const {batchResult, errors} = data;
        if (Array.isArray(batchResult)) {
          return batchResult.map((result) => {
            if (result.errors) {
              throw this.graphQLToJSError(result.errors[0]);
            }
            return {
              data: result,
              elapsed
            };
          });
        } else {
          throw this.graphQLToJSError(errors[0]);
        }
      }).catch(async (e) => {
        const isError7 = await this.handleRequestError(e, numTry < 3);
        if (!isError7) {
          if (numTry <= MAX_REQUEST_RETRIES) {
            return this.requestBatch(queries, headers, transaction, numTry + 1);
          }
        }
        throw isError7;
      });
    }
    async transaction(action, arg10) {
      var _a, _b;
      await this.start();
      try {
        if (action === "start") {
          const jsonOptions = JSON.stringify({
            max_wait: (_a = arg10 == null ? void 0 : arg10.maxWait) != null ? _a : 2e3,
            timeout: (_b = arg10 == null ? void 0 : arg10.timeout) != null ? _b : 5e3
          });
          const result = await import_Connection.Connection.onHttpError(this.connection.post("/transaction/start", jsonOptions), transactionHttpErrorHandler);
          return result.data;
        } else if (action === "commit") {
          await import_Connection.Connection.onHttpError(this.connection.post(`/transaction/${arg10.id}/commit`), transactionHttpErrorHandler);
        } else if (action === "rollback") {
          await import_Connection.Connection.onHttpError(this.connection.post(`/transaction/${arg10.id}/rollback`), transactionHttpErrorHandler);
        }
      } catch (error) {
        this.setError(error);
      }
      return void 0;
    }
    get hasMaxRestarts() {
      return this.startCount >= MAX_STARTS;
    }
    throwAsyncErrorIfExists(forceThrow = false) {
      var _a, _b;
      logger("throwAsyncErrorIfExists", this.startCount, this.hasMaxRestarts);
      if (this.lastRustError) {
        const err = new import_PrismaClientRustPanicError.PrismaClientRustPanicError(this.getErrorMessageWithLink((0, import_log.getMessage)(this.lastRustError)), this.clientVersion);
        if (this.lastRustError.is_panic) {
          this.lastPanic = err;
        }
        if (this.hasMaxRestarts || forceThrow) {
          throw err;
        }
      }
      if (this.lastErrorLog && (0, import_log.isRustErrorLog)(this.lastErrorLog)) {
        const err = new import_PrismaClientUnknownRequestError.PrismaClientUnknownRequestError(this.getErrorMessageWithLink((0, import_log.getMessage)(this.lastErrorLog)), this.clientVersion);
        if (((_b = (_a = this.lastErrorLog) == null ? void 0 : _a.fields) == null ? void 0 : _b.message) === "PANIC") {
          this.lastPanic = err;
        }
        if (this.hasMaxRestarts || forceThrow) {
          throw err;
        }
      }
    }
    getErrorMessageWithLink(title) {
      return (0, import_getErrorMessageWithLink.getErrorMessageWithLink)({
        platform: this.platform,
        title,
        version: this.clientVersion,
        engineVersion: this.lastVersion,
        database: this.lastActiveProvider,
        query: this.lastQuery
      });
    }
    graphQLToJSError(error) {
      if (error.user_facing_error.error_code) {
        return new import_PrismaClientKnownRequestError.PrismaClientKnownRequestError(error.user_facing_error.message, error.user_facing_error.error_code, this.clientVersion, error.user_facing_error.meta);
      }
      return new import_PrismaClientUnknownRequestError.PrismaClientUnknownRequestError(error.user_facing_error.message, this.clientVersion);
    }
  };
  function stringifyQuery(q) {
    return `{"variables":{},"query":${JSON.stringify(q)}}`;
  }
  function hookProcess(handler, exit = false) {
    process.once(handler, async () => {
      for (const engine of engines) {
        await engine.emitExit();
        engine.kill(handler);
      }
      engines.splice(0, engines.length);
      if (socketPaths.length > 0) {
        for (const socketPath of socketPaths) {
          try {
            import_fs.default.unlinkSync(socketPath);
          } catch (e) {
          }
        }
      }
      if (exit && process.listenerCount(handler) === 0) {
        process.exit();
      }
    });
  }
  var hooksInitialized = false;
  function initHooks() {
    if (!hooksInitialized) {
      hookProcess("beforeExit");
      hookProcess("exit");
      hookProcess("SIGINT", true);
      hookProcess("SIGUSR1", true);
      hookProcess("SIGUSR2", true);
      hookProcess("SIGTERM", true);
      hooksInitialized = true;
    }
  }
  function transactionHttpErrorHandler(result) {
    throw result.data;
  }
  function runtimeHeadersToHttpHeaders(headers) {
    return Object.keys(headers).reduce((acc, runtimeHeaderKey) => {
      let httpHeaderKey = runtimeHeaderKey;
      if (runtimeHeaderKey === "transactionId") {
        httpHeaderKey = "X-transaction-id";
      }
      acc[httpHeaderKey] = headers[runtimeHeaderKey];
      return acc;
    }, {});
  }
});

// ../../node_modules/.pnpm/@prisma+engine-core@2.30.2/node_modules/@prisma/engine-core/dist/library/types/Library.js
var require_Library = __commonJS((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  __markAsModule3(exports2);
});

// ../../node_modules/.pnpm/@prisma+engine-core@2.30.2/node_modules/@prisma/engine-core/dist/common/utils/getInternalDatamodelJson.js
var require_getInternalDatamodelJson = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    getInternalDatamodelJson: () => getInternalDatamodelJson2
  });
  var import_path10 = __toModule3(require("path"));
  var import_child_process2 = __toModule3(require("child_process"));
  var import_byline2 = __toModule3(require_byline());
  function getInternalDatamodelJson2(datamodel, schemaInferrerPath = import_path10.default.join(__dirname, "../schema-inferrer-bin")) {
    return new Promise((resolve, reject) => {
      const proc = (0, import_child_process2.spawn)(schemaInferrerPath, {
        stdio: ["pipe", "pipe", process.stderr]
      });
      proc.on("error", function(err) {
        console.error("[schema-inferrer-bin] error: %s", err);
        reject(err);
      });
      proc.on("exit", function(code, signal) {
        if (code !== 0) {
          console.error("[schema-inferrer-bin] exit: code=%s signal=%s", code, signal);
        }
        reject();
      });
      const out = (0, import_byline2.default)(proc.stdout);
      out.on("data", (line) => {
        const result = JSON.parse(line);
        const resultB64 = Buffer.from(JSON.stringify(result)).toString("base64");
        resolve(resultB64);
      });
      const cut = datamodel.replace(/\n/g, " ");
      proc.stdin.write(JSON.stringify({dataModel: cut}) + "\n");
    });
  }
});

// ../../node_modules/.pnpm/@prisma+engine-core@2.30.2/node_modules/@prisma/engine-core/dist/index.js
var require_dist9 = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    BinaryEngine: () => import_BinaryEngine.BinaryEngine,
    DatasourceOverwrite: () => import_Engine4.DatasourceOverwrite,
    Engine: () => import_Engine2.Engine,
    EngineConfig: () => import_Engine22.EngineConfig,
    EngineEventType: () => import_Engine3.EngineEventType,
    LibraryEngine: () => import_LibraryEngine.LibraryEngine,
    NodeAPILibraryTypes: () => NodeAPILibraryTypes,
    PrismaClientInitializationError: () => import_PrismaClientInitializationError2.PrismaClientInitializationError,
    PrismaClientKnownRequestError: () => import_PrismaClientKnownRequestError2.PrismaClientKnownRequestError,
    PrismaClientRustPanicError: () => import_PrismaClientRustPanicError2.PrismaClientRustPanicError,
    PrismaClientUnknownRequestError: () => import_PrismaClientUnknownRequestError2.PrismaClientUnknownRequestError,
    fixBinaryTargets: () => import_util6.fixBinaryTargets,
    getInternalDatamodelJson: () => import_getInternalDatamodelJson.getInternalDatamodelJson,
    getOriginalBinaryTargetsValue: () => import_printGeneratorConfig2.getOriginalBinaryTargetsValue,
    plusX: () => import_util22.plusX,
    printGeneratorConfig: () => import_printGeneratorConfig2.printGeneratorConfig
  });
  var import_PrismaClientInitializationError2 = __toModule3(require_PrismaClientInitializationError());
  var import_PrismaClientKnownRequestError2 = __toModule3(require_PrismaClientKnownRequestError());
  var import_PrismaClientRustPanicError2 = __toModule3(require_PrismaClientRustPanicError());
  var import_PrismaClientUnknownRequestError2 = __toModule3(require_PrismaClientUnknownRequestError());
  var import_Engine2 = __toModule3(require_Engine());
  var import_Engine22 = __toModule3(require_Engine());
  var import_Engine3 = __toModule3(require_Engine());
  var import_Engine4 = __toModule3(require_Engine());
  var import_LibraryEngine = __toModule3(require_LibraryEngine());
  var import_BinaryEngine = __toModule3(require_BinaryEngine());
  var NodeAPILibraryTypes = __toModule3(require_Library());
  var import_printGeneratorConfig2 = __toModule3(require_printGeneratorConfig());
  var import_getInternalDatamodelJson = __toModule3(require_getInternalDatamodelJson());
  var import_util6 = __toModule3(require_util3());
  var import_util22 = __toModule3(require_util3());
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/resolveBinary.js
var require_resolveBinary = __commonJS((exports, module) => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name in all)
      __defProp(target, name, {get: all[name], enumerable: true});
  };
  var __reExport = (target, module2, desc) => {
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
      for (let key of __getOwnPropNames(module2))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule = (module2) => {
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
  };
  __export(exports, {
    BinaryType: () => import_fetch_engine.BinaryType,
    engineEnvVarMap: () => engineEnvVarMap,
    maybeCopyToTmp: () => maybeCopyToTmp,
    resolveBinary: () => resolveBinary
  });
  var import_debug = __toModule(require_dist2());
  var import_engine_core = __toModule(require_dist9());
  var import_engines = __toModule(require("@prisma/engines"));
  var import_fetch_engine = __toModule(require_dist8());
  var import_get_platform = __toModule(require_dist4());
  var import_fs = __toModule(require("fs"));
  var import_make_dir = __toModule(require_make_dir());
  var import_path = __toModule(require("path"));
  var import_temp_dir = __toModule(require_temp_dir());
  var import_util = __toModule(require("util"));
  var readFile = (0, import_util.promisify)(import_fs.default.readFile);
  var writeFile = (0, import_util.promisify)(import_fs.default.writeFile);
  var debug = (0, import_debug.default)("prisma:resolveBinary");
  var engineEnvVarMap = {
    [import_fetch_engine.BinaryType.queryEngine]: "PRISMA_QUERY_ENGINE_BINARY",
    [import_fetch_engine.BinaryType.libqueryEngine]: "PRISMA_QUERY_ENGINE_LIBRARY",
    [import_fetch_engine.BinaryType.migrationEngine]: "PRISMA_MIGRATION_ENGINE_BINARY",
    [import_fetch_engine.BinaryType.introspectionEngine]: "PRISMA_INTROSPECTION_ENGINE_BINARY",
    [import_fetch_engine.BinaryType.prismaFmt]: "PRISMA_FMT_BINARY"
  };
  async function resolveBinary(name, proposedPath) {
    if (proposedPath && !proposedPath.startsWith("/snapshot/") && import_fs.default.existsSync(proposedPath)) {
      return proposedPath;
    }
    const envVar = engineEnvVarMap[name];
    if (process.env[envVar]) {
      if (!import_fs.default.existsSync(process.env[envVar])) {
        throw new Error(`Env var ${envVar} is provided, but provided path ${process.env[envVar]} can't be resolved.`);
      }
      return process.env[envVar];
    }
    const dir = eval("__dirname");
    const platform = await (0, import_get_platform.getPlatform)();
    const extension = platform === "windows" ? ".exe" : "";
    let binaryName = `${name}-${platform}${extension}`;
    if (name === import_fetch_engine.BinaryType.libqueryEngine) {
      binaryName = (0, import_get_platform.getNodeAPIName)(platform, "fs");
      if (!import_fs.default.existsSync(import_path.default.join((0, import_engines.getEnginesPath)(), binaryName))) {
        debug("Downloading Node-API Library");
        await (0, import_fetch_engine.download)({
          binaries: {
            "libquery-engine": (0, import_engines.getEnginesPath)()
          },
          version: import_engines.enginesVersion
        });
      }
    }
    let prismaPath = import_path.default.join((0, import_engines.getEnginesPath)(), binaryName);
    if (import_fs.default.existsSync(prismaPath)) {
      return maybeCopyToTmp(prismaPath);
    }
    prismaPath = import_path.default.join(__dirname, "..", binaryName);
    if (import_fs.default.existsSync(prismaPath)) {
      return maybeCopyToTmp(prismaPath);
    }
    prismaPath = import_path.default.join(__dirname, "../..", binaryName);
    if (import_fs.default.existsSync(prismaPath)) {
      return maybeCopyToTmp(prismaPath);
    }
    prismaPath = import_path.default.join(__dirname, "../runtime", binaryName);
    if (import_fs.default.existsSync(prismaPath)) {
      return maybeCopyToTmp(prismaPath);
    }
    throw new Error(`Could not find ${name} binary. Searched in ${import_path.default.join(dir, "..", binaryName)} and ${import_path.default.join(dir, "../..", binaryName)}`);
  }
  async function maybeCopyToTmp(file) {
    const dir = eval("__dirname");
    if (dir.startsWith("/snapshot/")) {
      const targetDir = import_path.default.join(import_temp_dir.default, "prisma-binaries");
      await (0, import_make_dir.default)(targetDir);
      const target = import_path.default.join(targetDir, import_path.default.basename(file));
      const data = await readFile(file);
      await writeFile(target, data);
      (0, import_engine_core.plusX)(target);
      return target;
    }
    return file;
  }
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/engine-commands/formatSchema.js
var require_formatSchema = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    formatSchema: () => formatSchema3
  });
  var import_debug3 = __toModule3(require_dist2());
  var import_fetch_engine2 = __toModule3(require_dist8());
  var import_execa2 = __toModule3(require_execa());
  var import_fs9 = __toModule3(require("fs"));
  var import_resolveBinary = __toModule3(require_resolveBinary());
  var debug3 = (0, import_debug3.default)("prisma:formatSchema");
  var MAX_BUFFER = 1e9;
  async function formatSchema3({
    schemaPath,
    schema
  }) {
    if (!schema && !schemaPath) {
      throw new Error(`Parameter schema or schemaPath must be passed.`);
    }
    const prismaFmtPath = await (0, import_resolveBinary.resolveBinary)(import_fetch_engine2.BinaryType.prismaFmt);
    const showColors = !process.env.NO_COLOR && process.stdout.isTTY;
    const options = {
      env: {
        RUST_BACKTRACE: "1",
        ...showColors ? {CLICOLOR_FORCE: "1"} : {}
      },
      maxBuffer: MAX_BUFFER
    };
    let result;
    if (schemaPath) {
      if (!import_fs9.default.existsSync(schemaPath)) {
        throw new Error(`Schema at ${schemaPath} does not exist.`);
      }
      result = await (0, import_execa2.default)(prismaFmtPath, ["format", "-i", schemaPath], options);
    } else if (schema) {
      result = await (0, import_execa2.default)(prismaFmtPath, ["format"], {
        ...options,
        input: schema
      });
    }
    return result.stdout;
  }
});

// ../../node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/lib/rng.js
var require_rng = __commonJS((exports2, module2) => {
  var crypto2 = require("crypto");
  module2.exports = function nodeRNG() {
    return crypto2.randomBytes(16);
  };
});

// ../../node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/lib/bytesToUuid.js
var require_bytesToUuid = __commonJS((exports2, module2) => {
  var byteToHex2 = [];
  for (var i = 0; i < 256; ++i) {
    byteToHex2[i] = (i + 256).toString(16).substr(1);
  }
  function bytesToUuid(buf, offset) {
    var i2 = offset || 0;
    var bth = byteToHex2;
    return [
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]]
    ].join("");
  }
  module2.exports = bytesToUuid;
});

// ../../node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/v1.js
var require_v1 = __commonJS((exports2, module2) => {
  var rng2 = require_rng();
  var bytesToUuid = require_bytesToUuid();
  var _nodeId;
  var _clockseq;
  var _lastMSecs = 0;
  var _lastNSecs = 0;
  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];
    options = options || {};
    var node = options.node || _nodeId;
    var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
    if (node == null || clockseq == null) {
      var seedBytes = rng2();
      if (node == null) {
        node = _nodeId = [
          seedBytes[0] | 1,
          seedBytes[1],
          seedBytes[2],
          seedBytes[3],
          seedBytes[4],
          seedBytes[5]
        ];
      }
      if (clockseq == null) {
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
      }
    }
    var msecs = options.msecs !== void 0 ? options.msecs : new Date().getTime();
    var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
    var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options.clockseq === void 0) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 122192928e5;
    var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b[i++] = tl >>> 24 & 255;
    b[i++] = tl >>> 16 & 255;
    b[i++] = tl >>> 8 & 255;
    b[i++] = tl & 255;
    var tmh = msecs / 4294967296 * 1e4 & 268435455;
    b[i++] = tmh >>> 8 & 255;
    b[i++] = tmh & 255;
    b[i++] = tmh >>> 24 & 15 | 16;
    b[i++] = tmh >>> 16 & 255;
    b[i++] = clockseq >>> 8 | 128;
    b[i++] = clockseq & 255;
    for (var n = 0; n < 6; ++n) {
      b[i + n] = node[n];
    }
    return buf ? buf : bytesToUuid(b);
  }
  module2.exports = v1;
});

// ../../node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/v4.js
var require_v4 = __commonJS((exports2, module2) => {
  var rng2 = require_rng();
  var bytesToUuid = require_bytesToUuid();
  function v42(options, buf, offset) {
    var i = buf && offset || 0;
    if (typeof options == "string") {
      buf = options === "binary" ? new Array(16) : null;
      options = null;
    }
    options = options || {};
    var rnds = options.random || (options.rng || rng2)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      for (var ii = 0; ii < 16; ++ii) {
        buf[i + ii] = rnds[ii];
      }
    }
    return buf || bytesToUuid(rnds);
  }
  module2.exports = v42;
});

// ../../node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/index.js
var require_uuid = __commonJS((exports2, module2) => {
  var v1 = require_v1();
  var v42 = require_v4();
  var uuid = v42;
  uuid.v1 = v1;
  uuid.v4 = v42;
  module2.exports = uuid;
});

// ../../node_modules/.pnpm/temp-dir@1.0.0/node_modules/temp-dir/index.js
var require_temp_dir2 = __commonJS((exports2, module2) => {
  "use strict";
  var fs9 = require("fs");
  var os3 = require("os");
  var ID = "__RESOLVED_TMP_DIR__";
  if (!global[ID]) {
    Object.defineProperty(global, ID, {
      value: fs9.realpathSync(os3.tmpdir())
    });
  }
  module2.exports = global[ID];
});

// ../../node_modules/.pnpm/temp-write@4.0.0/node_modules/temp-write/index.js
var require_temp_write = __commonJS((exports2, module2) => {
  "use strict";
  var {promisify: promisify4} = require("util");
  var path10 = require("path");
  var fs9 = require_graceful_fs();
  var isStream = require_is_stream();
  var makeDir2 = require_make_dir();
  var uuid = require_uuid();
  var tempDir = require_temp_dir2();
  var writeFileP = promisify4(fs9.writeFile);
  var tempfile = (filePath) => path10.join(tempDir, uuid.v4(), filePath || "");
  var writeStream = async (filePath, fileContent) => new Promise((resolve, reject) => {
    const writable = fs9.createWriteStream(filePath);
    fileContent.on("error", (error) => {
      reject(error);
      fileContent.unpipe(writable);
      writable.end();
    }).pipe(writable).on("error", reject).on("finish", resolve);
  });
  module2.exports = async (fileContent, filePath) => {
    const tempPath = tempfile(filePath);
    const write2 = isStream(fileContent) ? writeStream : writeFileP;
    await makeDir2(path10.dirname(tempPath));
    await write2(tempPath, fileContent);
    return tempPath;
  };
  module2.exports.sync = (fileContent, filePath) => {
    const tempPath = tempfile(filePath);
    makeDir2.sync(path10.dirname(tempPath));
    fs9.writeFileSync(tempPath, fileContent);
    return tempPath;
  };
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/utils/load.js
var require_load = __commonJS((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    load: () => load2
  });
  function load2(id) {
    try {
      return require(id);
    } catch (e) {
      throw new Error(`Unable to require(\`${id}\`)
 ${e.message}`);
    }
  }
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/engine-commands/getConfig.js
var require_getConfig = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    GetConfigError: () => GetConfigError,
    getConfig: () => getConfig6
  });
  var import_debug3 = __toModule3(require_dist2());
  var import_engines6 = __toModule3(require("@prisma/engines"));
  var import_fetch_engine2 = __toModule3(require_dist8());
  var import_get_platform3 = __toModule3(require_dist4());
  var import_chalk14 = __toModule3(require_source());
  var import_execa2 = __toModule3(require_execa());
  var import_fs9 = __toModule3(require("fs"));
  var import_temp_write = __toModule3(require_temp_write());
  var import_util6 = __toModule3(require("util"));
  var import_resolveBinary = __toModule3(require_resolveBinary());
  var import_load = __toModule3(require_load());
  var debug3 = (0, import_debug3.default)("prisma:getConfig");
  var unlink2 = (0, import_util6.promisify)(import_fs9.default.unlink);
  var MAX_BUFFER = 1e9;
  var GetConfigError = class extends Error {
    constructor(message) {
      super(import_chalk14.default.redBright.bold("Get config: ") + message);
    }
  };
  async function getConfig6(options) {
    var _a, _b;
    const cliEngineBinaryType = (0, import_engines6.getCliQueryEngineBinaryType)();
    let data;
    if (cliEngineBinaryType === import_fetch_engine2.BinaryType.libqueryEngine) {
      data = await getConfigNodeAPI(options);
    } else {
      data = await getConfigBinary(options);
    }
    if (!data)
      throw new GetConfigError(`Failed to return any data`);
    if (((_b = (_a = data.datasources) == null ? void 0 : _a[0]) == null ? void 0 : _b.provider) === "sqlite" && data.generators.some((g) => g.previewFeatures.includes("createMany"))) {
      const message = `Database provider "sqlite" and the preview feature "createMany" can't be used at the same time.
  Please either remove the "createMany" feature flag or use any other database type that Prisma supports: postgres, mysql or sqlserver.`;
      throw new GetConfigError(message);
    }
    return data;
  }
  async function getConfigNodeAPI(options) {
    var _a;
    let data;
    const queryEnginePath = await (0, import_resolveBinary.resolveBinary)(import_fetch_engine2.BinaryType.libqueryEngine, options.prismaPath);
    await (0, import_get_platform3.isNodeAPISupported)();
    debug3(`Using Node-API Query Engine at: ${queryEnginePath}`);
    try {
      const NodeAPIQueryEngineLibrary = (0, import_load.load)(queryEnginePath);
      data = await NodeAPIQueryEngineLibrary.getConfig({
        datamodel: options.datamodel,
        datasourceOverrides: {},
        ignoreEnvVarErrors: (_a = options.ignoreEnvVarErrors) != null ? _a : false,
        env: process.env
      });
    } catch (e) {
      let error;
      try {
        error = JSON.parse(e.message);
      } catch (e2) {
        throw e;
      }
      let message;
      if (error.error_code === "P1012") {
        message = import_chalk14.default.redBright(`Schema Parsing ${error.error_code}

`) + error.message + "\n";
      } else {
        message = import_chalk14.default.redBright(`${error.error_code}

`) + error;
      }
      throw new GetConfigError(message);
    }
    return data;
  }
  async function getConfigBinary(options) {
    let data;
    const queryEnginePath = await (0, import_resolveBinary.resolveBinary)(import_fetch_engine2.BinaryType.queryEngine, options.prismaPath);
    debug3(`Using Query Engine Binary at: ${queryEnginePath}`);
    try {
      let tempDatamodelPath = options.datamodelPath;
      if (!tempDatamodelPath) {
        try {
          tempDatamodelPath = await (0, import_temp_write.default)(options.datamodel);
        } catch (err) {
          throw new GetConfigError("Unable to write temp data model path");
        }
      }
      const engineArgs = [];
      const args2 = options.ignoreEnvVarErrors ? ["--ignoreEnvVarErrors"] : [];
      const result = await (0, import_execa2.default)(queryEnginePath, [...engineArgs, "cli", "get-config", ...args2], {
        cwd: options.cwd,
        env: {
          PRISMA_DML_PATH: tempDatamodelPath,
          RUST_BACKTRACE: "1"
        },
        maxBuffer: MAX_BUFFER
      });
      if (!options.datamodelPath) {
        await unlink2(tempDatamodelPath);
      }
      data = JSON.parse(result.stdout);
    } catch (e) {
      if (e.stderr || e.stdout) {
        const error = e.stderr ? e.stderr : e.stout;
        let jsonError, message;
        try {
          jsonError = JSON.parse(error);
          message = `${import_chalk14.default.redBright(jsonError.message)}
`;
          if (jsonError.error_code) {
            if (jsonError.error_code === "P1012") {
              message = import_chalk14.default.redBright(`Schema Parsing ${jsonError.error_code}

`) + message;
            } else {
              message = import_chalk14.default.redBright(`${jsonError.error_code}

`) + message;
            }
          }
        } catch (e2) {
          throw new GetConfigError(error);
        }
        throw new GetConfigError(message);
      }
      throw new GetConfigError(e);
    }
    return data;
  }
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/engine-commands/getDmmf.js
var require_getDmmf = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    getDMMF: () => getDMMF5
  });
  var import_debug3 = __toModule3(require_dist2());
  var import_engines6 = __toModule3(require("@prisma/engines"));
  var import_fetch_engine2 = __toModule3(require_dist8());
  var import_get_platform3 = __toModule3(require_dist4());
  var import_chalk14 = __toModule3(require_source());
  var import_execa2 = __toModule3(require_execa());
  var import_fs9 = __toModule3(require("fs"));
  var import_temp_write = __toModule3(require_temp_write());
  var import_util6 = __toModule3(require("util"));
  var import_resolveBinary = __toModule3(require_resolveBinary());
  var import_load = __toModule3(require_load());
  var debug3 = (0, import_debug3.default)("prisma:getDMMF");
  var unlink2 = (0, import_util6.promisify)(import_fs9.default.unlink);
  var MAX_BUFFER = 1e9;
  async function getDMMF5(options) {
    warnOnDeprecatedFeatureFlag(options.previewFeatures);
    const cliEngineBinaryType = (0, import_engines6.getCliQueryEngineBinaryType)();
    let dmmf;
    if (cliEngineBinaryType === import_fetch_engine2.BinaryType.libqueryEngine) {
      dmmf = await getDmmfNodeAPI(options);
    } else {
      dmmf = await getDmmfBinary(options);
    }
    return dmmf;
  }
  async function getDmmfNodeAPI(options) {
    var _a;
    const queryEnginePath = await (0, import_resolveBinary.resolveBinary)(import_fetch_engine2.BinaryType.libqueryEngine, options.prismaPath);
    await (0, import_get_platform3.isNodeAPISupported)();
    debug3(`Using Node-API Query Engine at: ${queryEnginePath}`);
    const NodeAPIQueryEngineLibrary = (0, import_load.load)(queryEnginePath);
    const datamodel = (_a = options.datamodel) != null ? _a : import_fs9.default.readFileSync(options.datamodelPath, "utf-8");
    let dmmf;
    try {
      dmmf = JSON.parse(await NodeAPIQueryEngineLibrary.dmmf(datamodel));
    } catch (e) {
      const error = JSON.parse(e.message);
      const message = addMissingOpenSSLInfo(error.message);
      throw new Error(import_chalk14.default.redBright.bold("Schema parsing\n") + message);
    }
    return dmmf;
  }
  async function getDmmfBinary(options) {
    let result;
    const queryEnginePath = await (0, import_resolveBinary.resolveBinary)(import_fetch_engine2.BinaryType.queryEngine, options.prismaPath);
    debug3(`Using Query Engine Binary at: ${queryEnginePath}`);
    try {
      let tempDatamodelPath = options.datamodelPath;
      if (!tempDatamodelPath) {
        try {
          tempDatamodelPath = await (0, import_temp_write.default)(options.datamodel);
        } catch (err) {
          throw new Error(import_chalk14.default.redBright.bold("Get DMMF ") + "unable to write temp data model path");
        }
      }
      const execaOptions = {
        cwd: options.cwd,
        env: {
          PRISMA_DML_PATH: tempDatamodelPath,
          RUST_BACKTRACE: "1",
          ...process.env.NO_COLOR ? {} : {CLICOLOR_FORCE: "1"}
        },
        maxBuffer: MAX_BUFFER
      };
      const args2 = ["--enable-raw-queries", "cli", "dmmf"];
      result = await (0, import_execa2.default)(queryEnginePath, args2, execaOptions);
      if (!options.datamodelPath) {
        await unlink2(tempDatamodelPath);
      }
      if (result.stdout.includes("Please wait until the") && options.retry && options.retry > 0) {
        debug3('Retrying after "Please wait until"');
        await new Promise((r) => setTimeout(r, 5e3));
        return getDMMF5({
          ...options,
          retry: options.retry - 1
        });
      }
      const firstCurly = result.stdout.indexOf("{");
      const stdout = result.stdout.slice(firstCurly);
      return JSON.parse(stdout);
    } catch (e) {
      debug3("getDMMF failed", e);
      if (e.message.includes("Command failed with exit code 26 (ETXTBSY)") && options.retry && options.retry > 0) {
        await new Promise((resolve) => setTimeout(resolve, 500));
        debug3("Retrying after ETXTBSY");
        return getDMMF5({
          ...options,
          retry: options.retry - 1
        });
      }
      const output = e.stderr || e.stdout;
      if (output) {
        let json;
        try {
          json = JSON.parse(output);
        } catch (e2) {
        }
        let message = json && json.message || output;
        message = addMissingOpenSSLInfo(message);
        throw new Error(import_chalk14.default.redBright.bold("Schema parsing\n") + message);
      }
      if (e.message.includes("in JSON at position")) {
        throw new Error(`Problem while parsing the query engine response at ${queryEnginePath}. ${result == null ? void 0 : result.stdout}
${e.stack}`);
      }
      throw new Error(e);
    }
  }
  function addMissingOpenSSLInfo(message) {
    if (message.includes("debian-openssl-1.1.x: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directory") || message.includes("debian-openssl-1.0.x: error while loading shared libraries: libssl.so.1.0.0: cannot open shared object file: No such file or directory")) {
      message += `
${import_chalk14.default.green(`Your linux installation misses the openssl package. You can install it like so:
`)}${import_chalk14.default.green.bold("apt-get -qy update && apt-get -qy install openssl")}`;
    }
    return message;
  }
  function warnOnDeprecatedFeatureFlag(previewFeatures) {
    const getMessage = (flag) => `${import_chalk14.default.blueBright("info")} The preview flag "${flag}" is not needed anymore, please remove it from your schema.prisma`;
    const removedFeatureFlagMap = {
      insensitiveFilters: getMessage("insensitiveFilters"),
      atomicNumberOperations: getMessage("atomicNumberOperations"),
      connectOrCreate: getMessage("connectOrCreate"),
      transaction: getMessage("transaction"),
      transactionApi: getMessage("transactionApi"),
      uncheckedScalarInputs: getMessage("uncheckedScalarInputs"),
      nativeTypes: getMessage("nativeTypes"),
      createMany: getMessage("createMany"),
      groupBy: getMessage("groupBy")
    };
    previewFeatures == null ? void 0 : previewFeatures.forEach((f) => {
      const removedMessage = removedFeatureFlagMap[f];
      if (removedMessage && !process.env.PRISMA_HIDE_PREVIEW_FLAG_WARNINGS) {
        console.warn(removedMessage);
      }
    });
  }
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/engine-commands/getVersion.js
var require_getVersion = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    getVersion: () => getVersion3
  });
  var import_debug3 = __toModule3(require_dist2());
  var import_engines6 = __toModule3(require("@prisma/engines"));
  var import_fetch_engine2 = __toModule3(require_dist8());
  var import_get_platform3 = __toModule3(require_dist4());
  var import_execa2 = __toModule3(require_execa());
  var import_resolveBinary = __toModule3(require_resolveBinary());
  var import_load = __toModule3(require_load());
  var debug3 = (0, import_debug3.default)("prisma:getVersion");
  var MAX_BUFFER = 1e9;
  async function getVersion3(enginePath, binaryName) {
    if (!binaryName) {
      binaryName = (0, import_engines6.getCliQueryEngineBinaryType)();
    }
    enginePath = await (0, import_resolveBinary.resolveBinary)(binaryName, enginePath);
    if (binaryName === import_fetch_engine2.BinaryType.libqueryEngine) {
      await (0, import_get_platform3.isNodeAPISupported)();
      const QE = (0, import_load.load)(enginePath);
      return `libquery-engine ${QE.version().commit}`;
    } else {
      const result = await (0, import_execa2.default)(enginePath, ["--version"], {
        maxBuffer: MAX_BUFFER
      });
      return result.stdout;
    }
  }
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/engine-commands/index.js
var require_engine_commands = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    ConfigMetaFormat: () => import_getConfig.ConfigMetaFormat,
    GetDMMFOptions: () => import_getDmmf.GetDMMFOptions,
    formatSchema: () => import_formatSchema.formatSchema,
    getConfig: () => import_getConfig.getConfig,
    getDMMF: () => import_getDmmf.getDMMF,
    getVersion: () => import_getVersion.getVersion
  });
  var import_formatSchema = __toModule3(require_formatSchema());
  var import_getConfig = __toModule3(require_getConfig());
  var import_getDmmf = __toModule3(require_getDmmf());
  var import_getVersion = __toModule3(require_getVersion());
});

// ../../node_modules/.pnpm/@prisma+generator-helper@2.30.2/node_modules/@prisma/generator-helper/dist/byline.js
var require_byline2 = __commonJS((exports2, module2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    createLineStream: () => createLineStream,
    default: () => byline2
  });
  var stream = require("stream");
  var util2 = require("util");
  function byline2(readStream, options) {
    return module2.exports.createStream(readStream, options);
  }
  module2.exports.createStream = function(readStream, options) {
    if (readStream) {
      return createLineStream(readStream, options);
    } else {
      return new LineStream(options);
    }
  };
  function createLineStream(readStream, options) {
    if (!readStream) {
      throw new Error("expected readStream");
    }
    if (!readStream.readable) {
      throw new Error("readStream must be readable");
    }
    const ls = new LineStream(options);
    readStream.pipe(ls);
    return ls;
  }
  module2.exports.LineStream = LineStream;
  function LineStream(options) {
    stream.Transform.call(this, options);
    options = options || {};
    this._readableState.objectMode = true;
    this._lineBuffer = [];
    this._keepEmptyLines = options.keepEmptyLines || false;
    this._lastChunkEndedWithCR = false;
    this.on("pipe", function(src) {
      if (!this.encoding) {
        if (src instanceof stream.Readable) {
          this.encoding = src._readableState.encoding;
        }
      }
    });
  }
  util2.inherits(LineStream, stream.Transform);
  LineStream.prototype._transform = function(chunk, encoding, done) {
    encoding = encoding || "utf8";
    if (Buffer.isBuffer(chunk)) {
      if (encoding == "buffer") {
        chunk = chunk.toString();
        encoding = "utf8";
      } else {
        chunk = chunk.toString(encoding);
      }
    }
    this._chunkEncoding = encoding;
    const lines = chunk.split(/\r\n|\r|\n/g);
    if (this._lastChunkEndedWithCR && chunk[0] == "\n") {
      lines.shift();
    }
    if (this._lineBuffer.length > 0) {
      this._lineBuffer[this._lineBuffer.length - 1] += lines[0];
      lines.shift();
    }
    this._lastChunkEndedWithCR = chunk[chunk.length - 1] == "\r";
    this._lineBuffer = this._lineBuffer.concat(lines);
    this._pushBuffer(encoding, 1, done);
  };
  LineStream.prototype._pushBuffer = function(encoding, keep, done) {
    while (this._lineBuffer.length > keep) {
      const line = this._lineBuffer.shift();
      if (this._keepEmptyLines || line.length > 0) {
        if (!this.push(this._reencode(line, encoding))) {
          const self2 = this;
          setImmediate(function() {
            self2._pushBuffer(encoding, keep, done);
          });
          return;
        }
      }
    }
    done();
  };
  LineStream.prototype._flush = function(done) {
    this._pushBuffer(this._chunkEncoding, 0, done);
  };
  LineStream.prototype._reencode = function(line, chunkEncoding) {
    if (this.encoding && this.encoding != chunkEncoding) {
      return Buffer.from(line, chunkEncoding).toString(this.encoding);
    } else if (this.encoding) {
      return line;
    } else {
      return Buffer.from(line, chunkEncoding);
    }
  };
});

// ../../node_modules/.pnpm/@prisma+generator-helper@2.30.2/node_modules/@prisma/generator-helper/dist/GeneratorProcess.js
var require_GeneratorProcess = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    GeneratorError: () => GeneratorError2,
    GeneratorProcess: () => GeneratorProcess2
  });
  var import_child_process2 = __toModule3(require("child_process"));
  var import_cross_spawn = __toModule3(require_cross_spawn());
  var import_byline2 = __toModule3(require_byline2());
  var import_chalk14 = __toModule3(require_source());
  var import_debug3 = __toModule3(require_dist2());
  var debug3 = (0, import_debug3.default)("prisma:GeneratorProcess");
  var globalMessageId = 1;
  var GeneratorError2 = class extends Error {
    constructor(message, code, data) {
      super(message);
      this.code = code;
      this.data = data;
    }
  };
  var GeneratorProcess2 = class {
    constructor(executablePath, isNode) {
      this.executablePath = executablePath;
      this.isNode = isNode;
      this.listeners = {};
      this.exitCode = null;
      this.stderrLogs = "";
    }
    async init() {
      if (!this.initPromise) {
        this.initPromise = this.initSingleton();
      }
      return this.initPromise;
    }
    initSingleton() {
      return new Promise((resolve, reject) => {
        try {
          if (this.isNode) {
            this.child = (0, import_child_process2.fork)(this.executablePath, [], {
              stdio: ["pipe", "inherit", "pipe", "ipc"],
              env: {
                ...process.env,
                PRISMA_GENERATOR_INVOCATION: "true"
              },
              execArgv: ["--max-old-space-size=8096"]
            });
          } else {
            this.child = (0, import_cross_spawn.spawn)(this.executablePath, {
              stdio: ["pipe", "inherit", "pipe"],
              env: {
                ...process.env,
                PRISMA_GENERATOR_INVOCATION: "true"
              },
              shell: true
            });
          }
          this.child.on("exit", (code) => {
            this.exitCode = code;
            if (code && code > 0 && this.currentGenerateDeferred) {
              this.currentGenerateDeferred.reject(new Error(this.stderrLogs.split("\n").slice(-5).join("\n")));
            }
          });
          this.child.on("error", (err) => {
            this.lastError = err;
            if (err.message.includes("EACCES")) {
              reject(new Error(`The executable at ${this.executablePath} lacks the right chmod. Please use ${import_chalk14.default.bold(`chmod +x ${this.executablePath}`)}`));
            } else {
              reject(err);
            }
          });
          (0, import_byline2.default)(this.child.stderr).on("data", (line) => {
            const response = String(line);
            this.stderrLogs += response + "\n";
            let data;
            try {
              data = JSON.parse(response);
            } catch (e) {
              debug3(response);
            }
            if (data) {
              this.handleResponse(data);
            }
          });
          setTimeout(() => {
            if (this.exitCode && this.exitCode > 0) {
              reject(new Error(`Generator at ${this.executablePath} could not start:

${this.stderrLogs}`));
            } else {
              resolve();
            }
          }, 200);
        } catch (e) {
          reject(e);
        }
      });
    }
    handleResponse(data) {
      if (data.jsonrpc && data.id) {
        if (typeof data.id !== "number") {
          throw new Error(`message.id has to be a number. Found value ${data.id}`);
        }
        if (this.listeners[data.id]) {
          if (data.error) {
            const error = new GeneratorError2(data.error.message, data.error.code, data.error.data);
            this.listeners[data.id](null, error);
          } else {
            this.listeners[data.id](data.result);
          }
          delete this.listeners[data.id];
        }
      }
    }
    registerListener(messageId, cb) {
      this.listeners[messageId] = cb;
    }
    sendMessage(message) {
      this.child.stdin.write(JSON.stringify(message) + "\n");
    }
    getMessageId() {
      return globalMessageId++;
    }
    stop() {
      if (!this.child.killed) {
        this.child.kill();
      }
    }
    getManifest(config) {
      return new Promise((resolve, reject) => {
        const messageId = this.getMessageId();
        this.registerListener(messageId, (result, error) => {
          if (error) {
            return reject(error);
          }
          if (result.manifest) {
            resolve(result.manifest);
          } else {
            resolve(null);
          }
        });
        this.sendMessage({
          jsonrpc: "2.0",
          method: "getManifest",
          params: config,
          id: messageId
        });
      });
    }
    generate(options) {
      return new Promise((resolve, reject) => {
        const messageId = this.getMessageId();
        this.currentGenerateDeferred = {resolve, reject};
        this.registerListener(messageId, (result, error) => {
          if (error) {
            reject(error);
            this.currentGenerateDeferred = void 0;
            return;
          }
          resolve(result);
          this.currentGenerateDeferred = void 0;
        });
        this.sendMessage({
          jsonrpc: "2.0",
          method: "generate",
          params: options,
          id: messageId
        });
      });
    }
  };
});

// ../../node_modules/.pnpm/@prisma+generator-helper@2.30.2/node_modules/@prisma/generator-helper/dist/generatorHandler.js
var require_generatorHandler = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    generatorHandler: () => generatorHandler2
  });
  var import_byline2 = __toModule3(require_byline2());
  function generatorHandler2(handler) {
    (0, import_byline2.default)(process.stdin).on("data", async (line) => {
      const json = JSON.parse(String(line));
      if (json.method === "generate" && json.params) {
        try {
          const result = await handler.onGenerate(json.params);
          respond({
            jsonrpc: "2.0",
            result,
            id: json.id
          });
        } catch (e) {
          respond({
            jsonrpc: "2.0",
            error: {
              code: -32e3,
              message: e.stack || e.message,
              data: null
            },
            id: json.id
          });
        }
      }
      if (json.method === "getManifest") {
        if (handler.onManifest) {
          try {
            const manifest = handler.onManifest(json.params);
            respond({
              jsonrpc: "2.0",
              result: {
                manifest
              },
              id: json.id
            });
          } catch (e) {
            respond({
              jsonrpc: "2.0",
              error: {
                code: -32e3,
                message: e.stack || e.message,
                data: null
              },
              id: json.id
            });
          }
        } else {
          respond({
            jsonrpc: "2.0",
            result: {
              manifest: null
            },
            id: json.id
          });
        }
      }
    });
    process.stdin.resume();
  }
  function respond(response) {
    console.error(JSON.stringify(response));
  }
});

// ../../node_modules/.pnpm/@prisma+generator-helper@2.30.2/node_modules/@prisma/generator-helper/dist/types.js
var require_types2 = __commonJS((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  __markAsModule3(exports2);
});

// ../../node_modules/.pnpm/@prisma+generator-helper@2.30.2/node_modules/@prisma/generator-helper/dist/dmmf.js
var require_dmmf = __commonJS((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    DMMF: () => DMMF
  });
  var DMMF;
  (function(DMMF2) {
    let ModelAction;
    (function(ModelAction2) {
      ModelAction2["findUnique"] = "findUnique";
      ModelAction2["findFirst"] = "findFirst";
      ModelAction2["findMany"] = "findMany";
      ModelAction2["create"] = "create";
      ModelAction2["createMany"] = "createMany";
      ModelAction2["update"] = "update";
      ModelAction2["updateMany"] = "updateMany";
      ModelAction2["upsert"] = "upsert";
      ModelAction2["delete"] = "delete";
      ModelAction2["deleteMany"] = "deleteMany";
      ModelAction2["groupBy"] = "groupBy";
      ModelAction2["count"] = "count";
      ModelAction2["aggregate"] = "aggregate";
    })(ModelAction = DMMF2.ModelAction || (DMMF2.ModelAction = {}));
  })(DMMF || (DMMF = {}));
});

// ../../node_modules/.pnpm/@prisma+generator-helper@2.30.2/node_modules/@prisma/generator-helper/dist/index.js
var require_dist10 = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    GeneratorError: () => import_GeneratorProcess.GeneratorError,
    GeneratorProcess: () => import_GeneratorProcess.GeneratorProcess,
    generatorHandler: () => import_generatorHandler.generatorHandler
  });
  var import_GeneratorProcess = __toModule3(require_GeneratorProcess());
  var import_generatorHandler = __toModule3(require_generatorHandler());
  __reExport2(exports2, __toModule3(require_types2()));
  __reExport2(exports2, __toModule3(require_dmmf()));
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/Generator.js
var require_Generator = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    Generator: () => Generator2
  });
  var import_generator_helper = __toModule3(require_dist10());
  var Generator2 = class {
    constructor(executablePath, config, isNode) {
      this.manifest = null;
      this.config = config;
      this.generatorProcess = new import_generator_helper.GeneratorProcess(executablePath, isNode);
    }
    async init() {
      await this.generatorProcess.init();
      this.manifest = await this.generatorProcess.getManifest(this.config);
    }
    stop() {
      this.generatorProcess.stop();
    }
    generate() {
      if (!this.options) {
        throw new Error(`Please first run .setOptions() on the Generator to initialize the options`);
      }
      return this.generatorProcess.generate(this.options);
    }
    setOptions(options) {
      this.options = options;
    }
    setBinaryPaths(binaryPaths) {
      if (!this.options) {
        throw new Error(`Please first run .setOptions() on the Generator to initialize the options`);
      }
      this.options.binaryPaths = binaryPaths;
    }
  };
});

// ../../node_modules/.pnpm/ini@2.0.0/node_modules/ini/ini.js
var require_ini = __commonJS((exports2, module2) => {
  var {hasOwnProperty} = Object.prototype;
  var eol = typeof process !== "undefined" && process.platform === "win32" ? "\r\n" : "\n";
  var encode = (obj, opt) => {
    const children = [];
    let out = "";
    if (typeof opt === "string") {
      opt = {
        section: opt,
        whitespace: false
      };
    } else {
      opt = opt || Object.create(null);
      opt.whitespace = opt.whitespace === true;
    }
    const separator = opt.whitespace ? " = " : "=";
    for (const k of Object.keys(obj)) {
      const val = obj[k];
      if (val && Array.isArray(val)) {
        for (const item of val)
          out += safe(k + "[]") + separator + safe(item) + "\n";
      } else if (val && typeof val === "object")
        children.push(k);
      else
        out += safe(k) + separator + safe(val) + eol;
    }
    if (opt.section && out.length)
      out = "[" + safe(opt.section) + "]" + eol + out;
    for (const k of children) {
      const nk = dotSplit(k).join("\\.");
      const section = (opt.section ? opt.section + "." : "") + nk;
      const {whitespace} = opt;
      const child = encode(obj[k], {
        section,
        whitespace
      });
      if (out.length && child.length)
        out += eol;
      out += child;
    }
    return out;
  };
  var dotSplit = (str) => str.replace(/\1/g, "LITERAL\\1LITERAL").replace(/\\\./g, "").split(/\./).map((part) => part.replace(/\1/g, "\\.").replace(/\2LITERAL\\1LITERAL\2/g, ""));
  var decode = (str) => {
    const out = Object.create(null);
    let p = out;
    let section = null;
    const re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i;
    const lines = str.split(/[\r\n]+/g);
    for (const line of lines) {
      if (!line || line.match(/^\s*[;#]/))
        continue;
      const match = line.match(re);
      if (!match)
        continue;
      if (match[1] !== void 0) {
        section = unsafe(match[1]);
        if (section === "__proto__") {
          p = Object.create(null);
          continue;
        }
        p = out[section] = out[section] || Object.create(null);
        continue;
      }
      const keyRaw = unsafe(match[2]);
      const isArray = keyRaw.length > 2 && keyRaw.slice(-2) === "[]";
      const key = isArray ? keyRaw.slice(0, -2) : keyRaw;
      if (key === "__proto__")
        continue;
      const valueRaw = match[3] ? unsafe(match[4]) : true;
      const value = valueRaw === "true" || valueRaw === "false" || valueRaw === "null" ? JSON.parse(valueRaw) : valueRaw;
      if (isArray) {
        if (!hasOwnProperty.call(p, key))
          p[key] = [];
        else if (!Array.isArray(p[key]))
          p[key] = [p[key]];
      }
      if (Array.isArray(p[key]))
        p[key].push(value);
      else
        p[key] = value;
    }
    const remove = [];
    for (const k of Object.keys(out)) {
      if (!hasOwnProperty.call(out, k) || typeof out[k] !== "object" || Array.isArray(out[k]))
        continue;
      const parts = dotSplit(k);
      let p2 = out;
      const l = parts.pop();
      const nl = l.replace(/\\\./g, ".");
      for (const part of parts) {
        if (part === "__proto__")
          continue;
        if (!hasOwnProperty.call(p2, part) || typeof p2[part] !== "object")
          p2[part] = Object.create(null);
        p2 = p2[part];
      }
      if (p2 === out && nl === l)
        continue;
      p2[nl] = out[k];
      remove.push(k);
    }
    for (const del of remove)
      delete out[del];
    return out;
  };
  var isQuoted = (val) => val.charAt(0) === '"' && val.slice(-1) === '"' || val.charAt(0) === "'" && val.slice(-1) === "'";
  var safe = (val) => typeof val !== "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim() ? JSON.stringify(val) : val.replace(/;/g, "\\;").replace(/#/g, "\\#");
  var unsafe = (val, doUnesc) => {
    val = (val || "").trim();
    if (isQuoted(val)) {
      if (val.charAt(0) === "'")
        val = val.substr(1, val.length - 2);
      try {
        val = JSON.parse(val);
      } catch (_2) {
      }
    } else {
      let esc = false;
      let unesc = "";
      for (let i = 0, l = val.length; i < l; i++) {
        const c = val.charAt(i);
        if (esc) {
          if ("\\;#".indexOf(c) !== -1)
            unesc += c;
          else
            unesc += "\\" + c;
          esc = false;
        } else if (";#".indexOf(c) !== -1)
          break;
        else if (c === "\\")
          esc = true;
        else
          unesc += c;
      }
      if (esc)
        unesc += "\\";
      return unesc.trim();
    }
    return val;
  };
  module2.exports = {
    parse: decode,
    decode,
    stringify: encode,
    encode,
    safe,
    unsafe
  };
});

// ../../node_modules/.pnpm/global-dirs@3.0.0/node_modules/global-dirs/index.js
var require_global_dirs = __commonJS((exports2) => {
  "use strict";
  var path10 = require("path");
  var os3 = require("os");
  var fs9 = require("fs");
  var ini = require_ini();
  var isWindows = process.platform === "win32";
  var readRc = (filePath) => {
    try {
      return ini.parse(fs9.readFileSync(filePath, "utf8")).prefix;
    } catch (e) {
    }
  };
  var getEnvNpmPrefix = () => {
    return Object.keys(process.env).reduce((prefix, name) => {
      return /^npm_config_prefix$/i.test(name) ? process.env[name] : prefix;
    }, void 0);
  };
  var getGlobalNpmrc = () => {
    if (isWindows && process.env.APPDATA) {
      return path10.join(process.env.APPDATA, "/npm/etc/npmrc");
    }
    if (process.execPath.includes("/Cellar/node")) {
      const homebrewPrefix = process.execPath.slice(0, process.execPath.indexOf("/Cellar/node"));
      return path10.join(homebrewPrefix, "/lib/node_modules/npm/npmrc");
    }
    if (process.execPath.endsWith("/bin/node")) {
      const installDir = path10.dirname(path10.dirname(process.execPath));
      return path10.join(installDir, "/etc/npmrc");
    }
  };
  var getDefaultNpmPrefix = () => {
    if (isWindows) {
      return path10.dirname(process.execPath);
    }
    return path10.dirname(path10.dirname(process.execPath));
  };
  var getNpmPrefix = () => {
    const envPrefix = getEnvNpmPrefix();
    if (envPrefix) {
      return envPrefix;
    }
    const homePrefix = readRc(path10.join(os3.homedir(), ".npmrc"));
    if (homePrefix) {
      return homePrefix;
    }
    if (process.env.PREFIX) {
      return process.env.PREFIX;
    }
    const globalPrefix = readRc(getGlobalNpmrc());
    if (globalPrefix) {
      return globalPrefix;
    }
    return getDefaultNpmPrefix();
  };
  var npmPrefix = path10.resolve(getNpmPrefix());
  var getYarnWindowsDirectory = () => {
    if (isWindows && process.env.LOCALAPPDATA) {
      const dir = path10.join(process.env.LOCALAPPDATA, "Yarn");
      if (fs9.existsSync(dir)) {
        return dir;
      }
    }
    return false;
  };
  var getYarnPrefix = () => {
    if (process.env.PREFIX) {
      return process.env.PREFIX;
    }
    const windowsPrefix = getYarnWindowsDirectory();
    if (windowsPrefix) {
      return windowsPrefix;
    }
    const configPrefix = path10.join(os3.homedir(), ".config/yarn");
    if (fs9.existsSync(configPrefix)) {
      return configPrefix;
    }
    const homePrefix = path10.join(os3.homedir(), ".yarn-config");
    if (fs9.existsSync(homePrefix)) {
      return homePrefix;
    }
    return npmPrefix;
  };
  exports2.npm = {};
  exports2.npm.prefix = npmPrefix;
  exports2.npm.packages = path10.join(npmPrefix, isWindows ? "node_modules" : "lib/node_modules");
  exports2.npm.binaries = isWindows ? npmPrefix : path10.join(npmPrefix, "bin");
  var yarnPrefix = path10.resolve(getYarnPrefix());
  exports2.yarn = {};
  exports2.yarn.prefix = yarnPrefix;
  exports2.yarn.packages = path10.join(yarnPrefix, getYarnWindowsDirectory() ? "Data/global/node_modules" : "global/node_modules");
  exports2.yarn.binaries = path10.join(exports2.yarn.packages, ".bin");
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/isCurrentBinInstalledGlobally.js
var require_isCurrentBinInstalledGlobally = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    isCurrentBinInstalledGlobally: () => isCurrentBinInstalledGlobally4
  });
  var import_fs9 = __toModule3(require("fs"));
  var import_global_dirs = __toModule3(require_global_dirs());
  function isCurrentBinInstalledGlobally4() {
    try {
      const realPrismaPath = import_fs9.default.realpathSync(process.argv[1]);
      const usingGlobalYarn = realPrismaPath.indexOf(import_global_dirs.default.yarn.packages) === 0;
      const usingGlobalNpm = realPrismaPath.indexOf(import_fs9.default.realpathSync(import_global_dirs.default.npm.packages)) === 0;
      if (usingGlobalNpm) {
        return "npm";
      }
      if (usingGlobalYarn) {
        return "yarn";
      } else {
        false;
      }
    } catch (e) {
    }
    return false;
  }
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/getCommandWithExecutor.js
var require_getCommandWithExecutor = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    getCommandWithExecutor: () => getCommandWithExecutor3
  });
  var import_isCurrentBinInstalledGlobally = __toModule3(require_isCurrentBinInstalledGlobally());
  function getCommandWithExecutor3(command) {
    var _a;
    if ((0, import_isCurrentBinInstalledGlobally.isCurrentBinInstalledGlobally)()) {
      return command;
    } else {
      const yarnUsed = (_a = process.env.npm_config_user_agent) == null ? void 0 : _a.includes("yarn");
      const npxUsed = __dirname.includes("_npx");
      if (npxUsed) {
        return `npx ${command}`;
      } else if (yarnUsed) {
        return `yarn ${command}`;
      } else {
        return command;
      }
    }
  }
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/versions.js
var require_versions = __commonJS((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    engineVersions: () => engineVersions2
  });
  var engineVersions2 = {
    "2.0.0-preview025": "8814060fa684793b73d07dbfccd4b7777b3361ae",
    "2.0.0-beta.1": "2accb9c7eacdc984874eaeb63377fe705dfd3203",
    "2.0.0-beta.2": "76857c35ba1e1764dd5473656ecbbb2f739e1822",
    "2.0.0-beta.3": "2fb8f444d9cdf7c0beee7b041194b42d7a9ce1e6",
    "2.0.0-beta.4": "afd294205618b1c825b013ba6f5a6ebe4aa4a514",
    "2.0.0-beta.5": "0c2ec197653b278b2978845ef958db88824cd82e",
    "2.0.0-beta.6": "c48b94aa8d1d9a0e5582dcd14e25202b76303dca",
    "2.0.0-beta.7": "5d39801acf2e3475bd9dab029a63634358b07bf1",
    "2.0.0-beta.8": "ff6959d77f8880ec037ed8201fff4a92f3aabaa0",
    "2.0.0-beta.9": "de2bc1cbdb5561ad73d2f08463fa2eec48993f56",
    "2.0.0": "de2bc1cbdb5561ad73d2f08463fa2eec48993f56",
    "2.1.0-dev.1": "de2bc1cbdb5561ad73d2f08463fa2eec48993f56",
    "2.1.0-dev.3": "de2bc1cbdb5561ad73d2f08463fa2eec48993f56",
    "2.1.0-dev.4": "de2bc1cbdb5561ad73d2f08463fa2eec48993f56",
    "2.1.0-dev.5": "8276c7c5aa78dbfea6213a4f9918200ee909b9a1",
    "2.1.0-dev.6": "f64916f0b6ce4210f7793b551f6bf9bfab7fd45a",
    "2.1.0-dev.7": "f64916f0b6ce4210f7793b551f6bf9bfab7fd45a",
    "2.1.0-dev.8": "f64916f0b6ce4210f7793b551f6bf9bfab7fd45a",
    "2.1.0-dev.9": "dc0f43d1460553447c563479493914279205d48f",
    "2.1.0-dev.10": "dc0f43d1460553447c563479493914279205d48f",
    "2.1.0-dev.11": "dc0f43d1460553447c563479493914279205d48f",
    "2.1.0-dev.12": "e52ce7fbe503b390ca40425e62efeb5bc2cefb7e",
    "2.1.0-dev.13": "6c7b34889020f8b10eea253f37022b6a1a935de3",
    "2.1.0-dev.14": "d75f4952ce0649fcf62c068cf03c18944b0bce34",
    "2.1.0-dev.15": "e172ae243853e2a47c75a1abe5547d0677980346",
    "2.1.0-dev.16": "077166a5c1ab914cf3d9764adc44ed812c7aa5b3",
    "2.1.0-dev.17": "7862cc88dc37aad8eb16913b5c09af408e5239fc",
    "2.1.0-dev.18": "487d9dd9cd33fa68a3eb9f3a991be11927fee9aa",
    "2.1.0-dev.19": "4e71ba30f44f81b4a62e51502941aa71e451be66",
    "2.1.0-dev.20": "55f869ed93b06baf167e981f5d4f2d8161f49998",
    "2.1.0-dev.21": "55f869ed93b06baf167e981f5d4f2d8161f49998",
    "2.1.0-dev.22": "55f869ed93b06baf167e981f5d4f2d8161f49998",
    "2.1.0-dev.24": "55f869ed93b06baf167e981f5d4f2d8161f49998",
    "2.1.0-dev.25": "8375158b46e194d6f48fb78be6e4ac58e693f2d4",
    "2.1.0-dev.26": "8375158b46e194d6f48fb78be6e4ac58e693f2d4",
    "2.1.0-dev.27": "8375158b46e194d6f48fb78be6e4ac58e693f2d4",
    "2.0.1-dev.1": "7d77a7cd570c9dedb4cdf31a1cbec615cf2e1eda",
    "2.0.1-dev.2": "7d77a7cd570c9dedb4cdf31a1cbec615cf2e1eda",
    "2.1.0-dev.28": "6838566f3107ff9f8de79e3bb8a731e70c02fb00",
    "2.1.0-dev.29": "6838566f3107ff9f8de79e3bb8a731e70c02fb00",
    "2.0.1-dev.3": "7d77a7cd570c9dedb4cdf31a1cbec615cf2e1eda",
    "2.0.1": "7d77a7cd570c9dedb4cdf31a1cbec615cf2e1eda",
    "2.1.0-dev.30": "2e65011d592bae491ee9dd5f8a6159c85c35e767",
    "2.1.0-dev.31": "2e65011d592bae491ee9dd5f8a6159c85c35e767",
    "2.1.0-dev.32": "2e65011d592bae491ee9dd5f8a6159c85c35e767",
    "2.1.0-dev.33": "2e65011d592bae491ee9dd5f8a6159c85c35e767",
    "2.1.0-dev.34": "2e65011d592bae491ee9dd5f8a6159c85c35e767",
    "2.1.0-dev.35": "2e65011d592bae491ee9dd5f8a6159c85c35e767",
    "2.1.0-dev.36": "12d156ebbe4bd254b3d20a2fa132bcc66a802502",
    "2.1.0-dev.37": "12d156ebbe4bd254b3d20a2fa132bcc66a802502",
    "2.1.0-dev.38": "12d156ebbe4bd254b3d20a2fa132bcc66a802502",
    "2.1.0-dev.39": "ffc156935b82a02a6770ab5e355e33312a0d0706",
    "2.1.0-dev.40": "bb1356b9cbd72b74787bfa66bbe5c8e338810b05",
    "2.1.0-dev.41": "bb1356b9cbd72b74787bfa66bbe5c8e338810b05",
    "2.1.0-dev.42": "bb1356b9cbd72b74787bfa66bbe5c8e338810b05",
    "2.1.0-dev.43": "bb1356b9cbd72b74787bfa66bbe5c8e338810b05",
    "2.1.0-dev.44": "9a43c75685826419972aa2ee5847d7a7107a176f",
    "2.1.0-dev.45": "9a43c75685826419972aa2ee5847d7a7107a176f",
    "2.1.0-dev.46": "9a43c75685826419972aa2ee5847d7a7107a176f",
    "2.1.0-dev.47": "9a43c75685826419972aa2ee5847d7a7107a176f",
    "2.1.0-dev.48": "dbeb321de898f94b03cd6f9b525c0187d93c3119",
    "2.1.0-dev.49": "64064ad0b1018ccb2309d97cbe958b666e5c55ea",
    "2.1.0-dev.50": "eef69002f93443908594c3293eca977e22008b22",
    "2.1.0-dev.51": "38d970371091514dcd2965847e30e9bf56820057",
    "2.1.0-dev.52": "c60e0db03225f303cfed42afcb6814999c95c6d8",
    "2.1.0-dev.53": "18c02927ce69cd6d593e1bfca4647ec46ee172d7",
    "2.1.0-dev.54": "6b10f7bfb5c09d707016877e7ec2e0c35f26eb67",
    "2.1.0-dev.55": "713204c8241b1870c0ae1145a256232744708cce",
    "2.1.0-dev.56": "713204c8241b1870c0ae1145a256232744708cce",
    "2.1.0-dev.57": "713204c8241b1870c0ae1145a256232744708cce",
    "2.1.0-dev.58": "4440772035795a0424be62040e2295c56e5c6ad0",
    "2.1.0-dev.59": "4440772035795a0424be62040e2295c56e5c6ad0",
    "2.1.0": "4440772035795a0424be62040e2295c56e5c6ad0",
    "2.2.0-dev.1": "30a3b13a02ea2b9a1bfa980e7c25b41bdbf77ea5",
    "2.2.0-dev.2": "30a3b13a02ea2b9a1bfa980e7c25b41bdbf77ea5",
    "2.1.1-dev.2": "34b761660584e32d715c3e86ecec3e2c4d50d0d9",
    "2.1.1": "34b761660584e32d715c3e86ecec3e2c4d50d0d9",
    "2.2.0-dev.3": "34b761660584e32d715c3e86ecec3e2c4d50d0d9",
    "2.2.0-dev.4": "43a04d7fe56db1d914cdd3619ef5c819c783d243",
    "2.2.0-dev.5": "219a8d806a3568142dee4c8673e767750e9d0136",
    "2.2.0-dev.6": "36247a04e8ff91aec3ecd2af1680494201048f34",
    "2.2.0-dev.7": "36247a04e8ff91aec3ecd2af1680494201048f34",
    "2.2.0-dev.8": "e006ba7fcfd6257d81e616e4e1bbbab8e017a9fe",
    "2.2.0-dev.9": "632c075edd87eff798b1babf16a4965ae2b45a9b",
    "2.2.0-dev.10": "632c075edd87eff798b1babf16a4965ae2b45a9b",
    "2.2.0-dev.11": "4414d4e066670f6edb6da381e6c8fcf544d6178f",
    "2.2.0-dev.12": "d23f217662512ed9c9a4a6a920c377154053a0a4",
    "2.2.0-dev.13": "700298ef090d8d45bed3750e99f56ba0be03673d",
    "2.2.0-dev.14": "700298ef090d8d45bed3750e99f56ba0be03673d",
    "2.2.0-dev.15": "297d4dddf12cd89b7c6de31ef15c42967f5cc559",
    "2.1.2-dev.1": "363f5a521d6b06543e53d134652a0037a3096d41",
    "2.1.2-dev.2": "363f5a521d6b06543e53d134652a0037a3096d41",
    "2.1.2": "363f5a521d6b06543e53d134652a0037a3096d41",
    "2.1.3-dev.1": "363f5a521d6b06543e53d134652a0037a3096d41",
    "2.1.3": "363f5a521d6b06543e53d134652a0037a3096d41",
    "2.2.0-dev.16": "297d4dddf12cd89b7c6de31ef15c42967f5cc559",
    "2.2.0-dev.17": "297d4dddf12cd89b7c6de31ef15c42967f5cc559",
    "2.2.0-dev.18": "297d4dddf12cd89b7c6de31ef15c42967f5cc559",
    "2.2.0-dev.19": "cb47e060d4a557e1e7870f50fc7b3c014f278114",
    "2.2.0-dev.20": "9216be08662d7280cc02246b4f5cc5f4b93cf8a3",
    "2.2.0-dev.21": "9216be08662d7280cc02246b4f5cc5f4b93cf8a3",
    "2.2.0-dev.23": "9216be08662d7280cc02246b4f5cc5f4b93cf8a3",
    "2.2.0-dev.24": "9216be08662d7280cc02246b4f5cc5f4b93cf8a3",
    "2.2.0-dev.25": "9216be08662d7280cc02246b4f5cc5f4b93cf8a3",
    "2.2.0-dev.26": "c29fbcd0f57c67e11722e479b9d135b346767e69",
    "2.2.0-dev.27": "c29fbcd0f57c67e11722e479b9d135b346767e69",
    "2.2.0-dev.28": "d6ff7119649922b84e413b3b69660e2f49e2ddf3",
    "2.2.0-dev.29": "d6ff7119649922b84e413b3b69660e2f49e2ddf3",
    "2.2.0-dev.30": "f5632770336d9cd89b6fa90204c3decf335c065a",
    "2.2.0-dev.31": "f5632770336d9cd89b6fa90204c3decf335c065a",
    "2.2.0-dev.32": "f5632770336d9cd89b6fa90204c3decf335c065a",
    "2.2.0-dev.33": "f5632770336d9cd89b6fa90204c3decf335c065a",
    "2.2.0-dev.34": "75d49d38ea10c8099ff9e90336c721fa6b47b90a",
    "2.2.0-dev.35": "c65f7b5d18ee8dbd0f43f654571bd3e85b625d80",
    "2.2.0-dev.36": "a0b56e4a4bc0dc6216e1cb26bd91a4094b868010",
    "2.2.0-dev.37": "ea035543e59571161e00ccd4063f5638283bfba7",
    "2.2.0-dev.38": "ea035543e59571161e00ccd4063f5638283bfba7",
    "2.2.0-dev.39": "ea035543e59571161e00ccd4063f5638283bfba7",
    "2.2.0-dev.40": "ea035543e59571161e00ccd4063f5638283bfba7",
    "2.2.0-dev.41": "1c840bb755d3b03acf9259f689303db93159c7b5",
    "2.2.0-dev.42": "1c840bb755d3b03acf9259f689303db93159c7b5",
    "2.2.0-dev.43": "ed51c9476579e3aa52ec43079fb2a351c70f5bb7",
    "2.2.0-dev.44": "ed51c9476579e3aa52ec43079fb2a351c70f5bb7",
    "2.2.0-dev.45": "ed51c9476579e3aa52ec43079fb2a351c70f5bb7",
    "2.2.0-dev.46": "ed51c9476579e3aa52ec43079fb2a351c70f5bb7",
    "2.2.0-dev.47": "ed51c9476579e3aa52ec43079fb2a351c70f5bb7",
    "2.2.0-dev.48": "ed51c9476579e3aa52ec43079fb2a351c70f5bb7",
    "2.2.0-dev.49": "ed51c9476579e3aa52ec43079fb2a351c70f5bb7",
    "2.2.0-dev.50": "83ac782d5d93dcee37efeba8ccbeff596701148a",
    "2.2.0-dev.51": "83ac782d5d93dcee37efeba8ccbeff596701148a",
    "2.2.0-dev.52": "83ac782d5d93dcee37efeba8ccbeff596701148a",
    "2.2.0-dev.53": "83ac782d5d93dcee37efeba8ccbeff596701148a",
    "2.2.0-dev.54": "83ac782d5d93dcee37efeba8ccbeff596701148a",
    "2.2.0-dev.55": "87846242af9393fb8fe9d3644cbb2dec2e322155",
    "2.2.0-dev.56": "87846242af9393fb8fe9d3644cbb2dec2e322155",
    "2.2.0-dev.57": "87846242af9393fb8fe9d3644cbb2dec2e322155",
    "2.2.0-dev.58": "87846242af9393fb8fe9d3644cbb2dec2e322155",
    "2.2.0-dev.59": "87846242af9393fb8fe9d3644cbb2dec2e322155",
    "2.2.0-dev.60": "87846242af9393fb8fe9d3644cbb2dec2e322155",
    "2.2.0-dev.61": "87846242af9393fb8fe9d3644cbb2dec2e322155",
    "2.2.0-dev.62": "87846242af9393fb8fe9d3644cbb2dec2e322155",
    "2.2.0-dev.63": "45c4da4dd3ccd6a322796b228bdf937c7ce884e8",
    "2.2.0": "45c4da4dd3ccd6a322796b228bdf937c7ce884e8",
    "2.3.0-dev.1": "3b7bab56afd3c41d2b1e92b21607c25527376819",
    "2.3.0-dev.2": "341b5a03061332a0a107760fc5be098168b7af49",
    "2.3.0-dev.3": "f21b611f21983123efdd86b230717b552898db2c",
    "2.3.0-dev.4": "7c61a28fce591bca9794f84bada575727c8d3a81",
    "2.3.0-dev.5": "7c61a28fce591bca9794f84bada575727c8d3a81",
    "2.3.0-dev.6": "9a238f2a34ac96b4006d0622063cda5d7c550f39",
    "2.3.0-dev.7": "225c75492b90e646e0224803ae30926eb676bdd0",
    "2.3.0-dev.8": "6b4130069651151477456fde7c6f1adce7e5aba1",
    "2.3.0-dev.9": "6b4130069651151477456fde7c6f1adce7e5aba1",
    "2.3.0-dev.10": "9fa0e57d0617e4e18ceae3b23280702f90b18412",
    "2.3.0-dev.11": "9fa0e57d0617e4e18ceae3b23280702f90b18412",
    "2.3.0-dev.12": "68efc71c4b657c5dbd59b177ecf2daf18e5b0201",
    "2.2.1-dev.1": "832e37683666c748b0a1cbdc2c5068b5e443e816",
    "2.2.1-dev.2": "832e37683666c748b0a1cbdc2c5068b5e443e816",
    "2.3.0-dev.13": "ba2d82113a01f9d56c88cf52279fb0bd5f74fac0",
    "2.2.1-dev.3": "832e37683666c748b0a1cbdc2c5068b5e443e816",
    "2.2.1-dev.4": "832e37683666c748b0a1cbdc2c5068b5e443e816",
    "2.3.0-dev.14": "21bd701db858e37b8f3157190a86da93e21ec5df",
    "2.2.1-dev.5": "832e37683666c748b0a1cbdc2c5068b5e443e816",
    "2.3.0-dev.15": "21bd701db858e37b8f3157190a86da93e21ec5df",
    "2.3.0-dev.16": "21bd701db858e37b8f3157190a86da93e21ec5df",
    "2.3.0-dev.17": "21bd701db858e37b8f3157190a86da93e21ec5df",
    "2.2.1-dev.6": "832e37683666c748b0a1cbdc2c5068b5e443e816",
    "2.3.0-dev.18": "21bd701db858e37b8f3157190a86da93e21ec5df",
    "2.2.1": "832e37683666c748b0a1cbdc2c5068b5e443e816",
    "2.3.0-dev.19": "81e452517f2e53825001cddd130dc09e0862711b",
    "2.2.2-dev.1": "a9e8c3d97ef2a0cf59256e6b26097f2a80f0a6a4",
    "2.2.2": "a9e8c3d97ef2a0cf59256e6b26097f2a80f0a6a4",
    "2.3.0-dev.20": "7dd62871982e0897f81591928ef43d4669b2a176",
    "2.3.0-dev.21": "7dd62871982e0897f81591928ef43d4669b2a176",
    "2.3.0-dev.23": "b032e1220061befb095deef6f8ee2e36bacbf4d9",
    "2.3.0-dev.25": "b032e1220061befb095deef6f8ee2e36bacbf4d9",
    "2.3.0-dev.26": "b032e1220061befb095deef6f8ee2e36bacbf4d9",
    "2.3.0-dev.27": "b032e1220061befb095deef6f8ee2e36bacbf4d9",
    "2.3.0-dev.28": "b032e1220061befb095deef6f8ee2e36bacbf4d9",
    "2.3.0-dev.29": "99bc0e4998e8148ef5716312495fcaa7293b62ff",
    "2.3.0-dev.30": "a1ea05fcba2ecf3d741a559a8394a61a0958b662",
    "2.3.0-dev.31": "a1ea05fcba2ecf3d741a559a8394a61a0958b662",
    "2.3.0-dev.32": "a6590bef185927e77afebb0bf8a1bc3defe5d0ad",
    "2.3.0-dev.33": "ba26cce0f10f923f1de113aae0763d2412e18247",
    "2.3.0-dev.34": "ba26cce0f10f923f1de113aae0763d2412e18247",
    "2.3.0-dev.35": "ba26cce0f10f923f1de113aae0763d2412e18247",
    "2.3.0-dev.36": "0335c039a0bc842a20ffe7832d26e592f34ea916",
    "2.3.0-dev.37": "0335c039a0bc842a20ffe7832d26e592f34ea916",
    "2.3.0-dev.38": "cdc255245a255c24b3dd50db25a050636973ec77",
    "2.3.0-dev.39": "1efe9b96955f1316d84351b2e771d81246873022",
    "2.3.0-dev.40": "156ad9546453b9b64fd2feeede6ad8991bb9de22",
    "2.3.0-dev.41": "8619f7cdd8edc678160849a499cdaaf73dc9b63c",
    "2.3.0-dev.42": "f7829d796be36394ee9a64f1fc67c643aae046f2",
    "2.3.0-dev.43": "f7829d796be36394ee9a64f1fc67c643aae046f2",
    "2.3.0-dev.44": "ede20e7638e18c628b4f70b3d2483c87b919982a",
    "2.3.0-dev.45": "862d67e6b9ca50e232d4cdbc3b12b3f1f08cec8a",
    "2.3.0-dev.46": "862d67e6b9ca50e232d4cdbc3b12b3f1f08cec8a",
    "2.3.0-dev.47": "862d67e6b9ca50e232d4cdbc3b12b3f1f08cec8a",
    "2.3.0-dev.48": "143a8265b75aefe077e9f483f4a275ab5e0ad5f6",
    "2.3.0-dev.49": "143a8265b75aefe077e9f483f4a275ab5e0ad5f6",
    "2.3.0-dev.50": "143a8265b75aefe077e9f483f4a275ab5e0ad5f6",
    "2.3.0-dev.51": "143a8265b75aefe077e9f483f4a275ab5e0ad5f6",
    "2.3.0-dev.52": "143a8265b75aefe077e9f483f4a275ab5e0ad5f6",
    "2.3.0-dev.53": "b1c5396ac9832eb8481b3c7f36c393ab1747211d",
    "2.3.0-dev.54": "b1c5396ac9832eb8481b3c7f36c393ab1747211d",
    "2.3.0-dev.55": "b1c5396ac9832eb8481b3c7f36c393ab1747211d",
    "2.3.0-dev.56": "b1c5396ac9832eb8481b3c7f36c393ab1747211d",
    "2.3.0-dev.57": "e11114fa1ea826f9e7b4fa1ced34e78892fe8e0e",
    "2.3.0": "e11114fa1ea826f9e7b4fa1ced34e78892fe8e0e",
    "2.4.0-dev.1": "bbc9be76da4bf5af6bacb8655633ae4ea56b6f6f",
    "2.4.0-dev.2": "346c7b5b70ae5ed4e10b0342b556e7d53c27c0af",
    "2.4.0-dev.3": "84202350ac21bc9479513fe91cc3510629aac69f",
    "2.4.0-dev.4": "1fdb184ea79af011b9c0ac677562719088f490af",
    "2.4.0-dev.5": "d995a75689d1bd4e90b019fd083d90d6fa2d48fa",
    "2.4.0-dev.6": "d995a75689d1bd4e90b019fd083d90d6fa2d48fa",
    "2.4.0-dev.7": "0f3750ce5b6509b766811fbe350e83f232daa57f",
    "2.4.0-dev.8": "0f3750ce5b6509b766811fbe350e83f232daa57f",
    "2.4.0-dev.9": "05ff93c8e9cea55e82b3bd3e50f71a571c6b0de5",
    "2.4.0-dev.10": "1e19628edbd4755d416300449b4c7bbb9d85e03f",
    "2.4.0-dev.11": "70bbce05e86a6109ced7ad133bd5dca095b3fa58",
    "2.4.0-dev.12": "054d8fd21e5ab5c9955492c3aad62dbb8c15f40b",
    "2.4.0-dev.13": "0912eb4031e6d77c4e13637447099b7100e602a3",
    "2.4.0-dev.14": "3a3fd0fe2660782248c1e42fa75ae0731fed8819",
    "2.4.0-dev.15": "9d759290dff266f4d4c39e415d8ac846827a4053",
    "2.4.0-dev.16": "ab6fccbd80bff0d30b57f371c8929de7b48c77e2",
    "2.4.0-dev.17": "fed4a488fd2a7c81fc556262f9ece4eb3fe6bd23",
    "2.4.0-dev.18": "b5c495e1e22d312e3ade4f4d8dbf5123e1ff9e30",
    "2.4.0-dev.19": "37468de984a57c89edf7ebde8c5ebd81d1e7183b",
    "2.4.0-dev.20": "37468de984a57c89edf7ebde8c5ebd81d1e7183b",
    "2.4.0-dev.21": "37468de984a57c89edf7ebde8c5ebd81d1e7183b",
    "2.4.0-dev.22": "37468de984a57c89edf7ebde8c5ebd81d1e7183b",
    "2.4.0-dev.23": "37468de984a57c89edf7ebde8c5ebd81d1e7183b",
    "2.4.0-dev.24": "37468de984a57c89edf7ebde8c5ebd81d1e7183b",
    "2.4.0-dev.25": "37468de984a57c89edf7ebde8c5ebd81d1e7183b",
    "2.4.0-dev.26": "f12ffba327775df35dca10f5cbcb829e866614e8",
    "2.4.0-dev.27": "1e72e2311f531c77af7675b1e1acac595d26bb49",
    "2.4.0-dev.28": "8eb4af13db3ce3b6b0e02e11d4d236082544281a",
    "2.4.0-dev.29": "8eb4af13db3ce3b6b0e02e11d4d236082544281a",
    "2.4.0-dev.30": "8eb4af13db3ce3b6b0e02e11d4d236082544281a",
    "2.4.0-dev.31": "8eb4af13db3ce3b6b0e02e11d4d236082544281a",
    "2.4.0-dev.32": "8eb4af13db3ce3b6b0e02e11d4d236082544281a",
    "2.4.0-dev.33": "8eb4af13db3ce3b6b0e02e11d4d236082544281a",
    "2.4.0-dev.34": "8eb4af13db3ce3b6b0e02e11d4d236082544281a",
    "2.4.0-dev.35": "8eb4af13db3ce3b6b0e02e11d4d236082544281a",
    "2.4.0-dev.36": "8eb4af13db3ce3b6b0e02e11d4d236082544281a",
    "2.4.0-dev.37": "8eb4af13db3ce3b6b0e02e11d4d236082544281a",
    "2.4.0-dev.38": "8eb4af13db3ce3b6b0e02e11d4d236082544281a",
    "2.4.0-dev.39": "8eb4af13db3ce3b6b0e02e11d4d236082544281a",
    "2.4.0-dev.40": "8eb4af13db3ce3b6b0e02e11d4d236082544281a",
    "2.4.0-dev.41": "8eb4af13db3ce3b6b0e02e11d4d236082544281a",
    "2.4.0-dev.42": "8eb4af13db3ce3b6b0e02e11d4d236082544281a",
    "2.4.0-dev.43": "8337329d29aec488119918879493ab6fd38c880e",
    "2.4.0-dev.44": "8337329d29aec488119918879493ab6fd38c880e",
    "2.4.0-dev.45": "8337329d29aec488119918879493ab6fd38c880e",
    "2.4.0-dev.46": "8337329d29aec488119918879493ab6fd38c880e",
    "2.4.0-dev.47": "8337329d29aec488119918879493ab6fd38c880e",
    "2.4.0-dev.48": "8337329d29aec488119918879493ab6fd38c880e",
    "2.4.0-dev.49": "4c91943360cd3d09eb0a9d55286c2670ed9e5e88",
    "2.4.0-dev.50": "4c91943360cd3d09eb0a9d55286c2670ed9e5e88",
    "2.4.0-dev.51": "4c91943360cd3d09eb0a9d55286c2670ed9e5e88",
    "2.4.0-dev.52": "d65a057850f62704205d0e392faf01613293d6f4",
    "2.4.0-dev.53": "bb57b5bea80ee2dd82fcae105e0204a2349a54c2",
    "2.4.0-dev.54": "bb57b5bea80ee2dd82fcae105e0204a2349a54c2",
    "2.4.0-dev.55": "6c777331554df4c3e0a90dd841339c7b0619d0e1",
    "2.4.0-dev.56": "6c777331554df4c3e0a90dd841339c7b0619d0e1",
    "2.4.0-dev.57": "6c777331554df4c3e0a90dd841339c7b0619d0e1",
    "2.4.0-dev.58": "6c777331554df4c3e0a90dd841339c7b0619d0e1",
    "2.4.0-dev.59": "6c777331554df4c3e0a90dd841339c7b0619d0e1",
    "2.4.0-dev.60": "6c777331554df4c3e0a90dd841339c7b0619d0e1",
    "2.4.0": "6c777331554df4c3e0a90dd841339c7b0619d0e1",
    "2.5.0-dev.1": "8badef702a0bb0e6121197ccec5976d9af178cc4",
    "2.5.0-dev.2": "8badef702a0bb0e6121197ccec5976d9af178cc4",
    "2.5.0-dev.3": "e745b5f2a9bea5d04faeb768b619aa761d176b7d",
    "2.5.0-dev.4": "e745b5f2a9bea5d04faeb768b619aa761d176b7d",
    "2.5.0-dev.5": "6e674469fff1a603c0139a09a5c7665af0c0b915",
    "2.4.1-dev.1": "195d4bdc2d16132977f4ba7a8ca312f7906cb086",
    "2.4.1": "195d4bdc2d16132977f4ba7a8ca312f7906cb086",
    "2.5.0-dev.6": "a4c0b19a07ff370234d8e6205a60aa885daed3c9",
    "2.5.0-dev.7": "2d5db567f479b50d4a793d4141fb3dad6b6d14af",
    "2.5.0-dev.8": "2dbcdc81e4161f23e736d2d7a5356926f4abfda7",
    "2.5.0-dev.9": "8e4f3a5c140fa60e254d5ca37536c5991960dc7f",
    "2.5.0-dev.10": "734ab53bd8e2cadf18b8b71cb53bf2d2bed46517",
    "2.5.0-dev.11": "734ab53bd8e2cadf18b8b71cb53bf2d2bed46517",
    "2.5.0-dev.12": "96dcc3c34f040c9808059de63409f04687c9beff",
    "2.5.0-dev.13": "2deb6252cdc82d12effe3a000748397cd6a1ba6e",
    "2.5.0-dev.14": "2deb6252cdc82d12effe3a000748397cd6a1ba6e",
    "2.5.0-dev.15": "2deb6252cdc82d12effe3a000748397cd6a1ba6e",
    "2.5.0-dev.16": "9f61a69f7e2e04c849ba039136a8ee3625e03859",
    "2.5.0-dev.17": "9f61a69f7e2e04c849ba039136a8ee3625e03859",
    "2.5.0-dev.18": "9f61a69f7e2e04c849ba039136a8ee3625e03859",
    "2.5.0-dev.19": "9f61a69f7e2e04c849ba039136a8ee3625e03859",
    "2.5.0-dev.20": "6fa13fa129a579cce403a8cdf65aa3bd7a19028b",
    "2.5.0-dev.21": "e8c86b2eed97ef06abd25651f450e957b21f5c31",
    "2.5.0-dev.22": "e8c86b2eed97ef06abd25651f450e957b21f5c31",
    "2.5.0-dev.23": "e8c86b2eed97ef06abd25651f450e957b21f5c31",
    "2.5.0-dev.24": "e8c86b2eed97ef06abd25651f450e957b21f5c31",
    "2.5.0-dev.25": "e8c86b2eed97ef06abd25651f450e957b21f5c31",
    "2.5.0-dev.26": "b6c3e2ef9589d6e08cb9ad74d68e733f4007650c",
    "2.5.0-dev.27": "ac051172582b2c03c3d6e2f1470a0eccb274e4c5",
    "2.5.0-dev.28": "c0231c315abebc8c3ed7c32927a2a091bffda4a3",
    "2.5.0-dev.29": "c0231c315abebc8c3ed7c32927a2a091bffda4a3",
    "2.5.0-dev.30": "c0231c315abebc8c3ed7c32927a2a091bffda4a3",
    "2.5.0-dev.31": "c0231c315abebc8c3ed7c32927a2a091bffda4a3",
    "2.5.0-dev.32": "c0231c315abebc8c3ed7c32927a2a091bffda4a3",
    "2.5.0-dev.33": "c0231c315abebc8c3ed7c32927a2a091bffda4a3",
    "2.5.0-dev.34": "c0231c315abebc8c3ed7c32927a2a091bffda4a3",
    "2.5.0-dev.35": "c0231c315abebc8c3ed7c32927a2a091bffda4a3",
    "2.5.0-dev.36": "c0231c315abebc8c3ed7c32927a2a091bffda4a3",
    "2.5.0-dev.37": "c0231c315abebc8c3ed7c32927a2a091bffda4a3",
    "2.5.0-dev.38": "31a949effe4ea834d8ccd4f8087e0375bcffccfa",
    "2.5.0-dev.39": "ee46c0006296d91f8a23684a8ced0ce259386cea",
    "2.5.0-dev.40": "ee46c0006296d91f8a23684a8ced0ce259386cea",
    "2.5.0-dev.41": "5ae6907bd5ffc701ed7d93ba74080da8d2f7c158",
    "2.5.0-dev.42": "5ae6907bd5ffc701ed7d93ba74080da8d2f7c158",
    "2.5.0-dev.43": "5ae6907bd5ffc701ed7d93ba74080da8d2f7c158",
    "2.5.0-dev.44": "5ae6907bd5ffc701ed7d93ba74080da8d2f7c158",
    "2.5.0-dev.45": "5ae6907bd5ffc701ed7d93ba74080da8d2f7c158",
    "2.5.0-dev.46": "5ae6907bd5ffc701ed7d93ba74080da8d2f7c158",
    "2.5.0-dev.47": "f3df39ce7a842e659445cf7436ee8b268b8bff17",
    "2.5.0-dev.48": "f3df39ce7a842e659445cf7436ee8b268b8bff17",
    "2.5.0-dev.49": "f3df39ce7a842e659445cf7436ee8b268b8bff17",
    "2.5.0-dev.50": "8f08c6fa89afd00710e41d99621786150b7eebbe",
    "2.5.0-dev.51": "8f08c6fa89afd00710e41d99621786150b7eebbe",
    "2.5.0-dev.52": "8f08c6fa89afd00710e41d99621786150b7eebbe",
    "2.5.0-dev.53": "8f08c6fa89afd00710e41d99621786150b7eebbe",
    "2.5.0-dev.54": "8f08c6fa89afd00710e41d99621786150b7eebbe",
    "2.5.0-dev.55": "8f08c6fa89afd00710e41d99621786150b7eebbe",
    "2.5.0-dev.56": "8f08c6fa89afd00710e41d99621786150b7eebbe",
    "2.5.0-dev.57": "8f08c6fa89afd00710e41d99621786150b7eebbe",
    "2.5.0-dev.58": "cc6843945c4485b397f541fcbe18d1bd94346ef7",
    "2.5.0-dev.59": "cc6843945c4485b397f541fcbe18d1bd94346ef7",
    "2.5.0-dev.60": "cc6843945c4485b397f541fcbe18d1bd94346ef7",
    "2.5.0-dev.61": "cc6843945c4485b397f541fcbe18d1bd94346ef7",
    "2.5.0-dev.62": "fa212b81aa9797f9cc8290b31cf74f49a242cb4a",
    "2.5.0-dev.63": "fa212b81aa9797f9cc8290b31cf74f49a242cb4a",
    "2.5.0-dev.64": "fa212b81aa9797f9cc8290b31cf74f49a242cb4a",
    "2.5.0-dev.65": "e280b792354efc65b91253bfb9a0f4b73dca85e7",
    "2.5.0-dev.66": "e280b792354efc65b91253bfb9a0f4b73dca85e7",
    "2.5.0-dev.67": "e280b792354efc65b91253bfb9a0f4b73dca85e7",
    "2.5.0-dev.68": "f2e54efb31f58a6c1c6d697e0c40aaddbb306993",
    "2.5.0-dev.69": "f2e54efb31f58a6c1c6d697e0c40aaddbb306993",
    "2.5.0-dev.70": "f2e54efb31f58a6c1c6d697e0c40aaddbb306993",
    "2.5.0-dev.71": "9a670138b1db276001d785a2adcba1584c869d24",
    "2.5.0-dev.72": "9a670138b1db276001d785a2adcba1584c869d24",
    "2.5.0-dev.73": "9a670138b1db276001d785a2adcba1584c869d24",
    "2.5.0": "9a670138b1db276001d785a2adcba1584c869d24",
    "2.6.0-dev.1": "03bb4d5bc838046aeb5f477d8fd5940864f0ecd8",
    "2.6.0-dev.2": "03bb4d5bc838046aeb5f477d8fd5940864f0ecd8",
    "2.6.0-dev.3": "499fa463c4bce9f1e4773876b7659d1a0a1c59fe",
    "2.6.0-dev.4": "499fa463c4bce9f1e4773876b7659d1a0a1c59fe",
    "2.6.0-dev.5": "499fa463c4bce9f1e4773876b7659d1a0a1c59fe",
    "2.6.0-dev.6": "499fa463c4bce9f1e4773876b7659d1a0a1c59fe",
    "2.6.0-dev.7": "62c83f00cd815bc777fd0f326c7284d5b1556f8f",
    "2.6.0-dev.8": "62c83f00cd815bc777fd0f326c7284d5b1556f8f",
    "2.5.1-dev.1": "9a670138b1db276001d785a2adcba1584c869d24",
    "2.5.1-dev.2": "9a670138b1db276001d785a2adcba1584c869d24",
    "2.5.1-dev.3": "9a670138b1db276001d785a2adcba1584c869d24",
    "2.5.1-dev.4": "c88925ce44a9b89b4351aec85ba6a28979d2658e",
    "2.6.0-dev.9": "24a240e041612473ba2085961b4571205450fc13",
    "2.5.1-dev.5": "c88925ce44a9b89b4351aec85ba6a28979d2658e",
    "2.5.1": "c88925ce44a9b89b4351aec85ba6a28979d2658e",
    "2.6.0-dev.10": "08d3349c7d493866c34e5e403fe1a4220509b1b6",
    "2.6.0-dev.11": "08d3349c7d493866c34e5e403fe1a4220509b1b6",
    "2.6.0-dev.12": "08d3349c7d493866c34e5e403fe1a4220509b1b6",
    "2.6.0-dev.13": "fff0920741f15deea278830b4afd16f5fa81708b",
    "2.6.0-dev.14": "22ce6892be334bb50f8d7dcb5829d0ee124cd444",
    "2.6.0-dev.15": "62af2a2328bf6013fb6633f83eaf8c31617e641a",
    "2.6.0-dev.16": "62af2a2328bf6013fb6633f83eaf8c31617e641a",
    "2.6.0-dev.17": "acfba31b83f7edec8e740dc4d94e0aec0855b2d6",
    "2.6.0-dev.18": "acfba31b83f7edec8e740dc4d94e0aec0855b2d6",
    "2.6.0-dev.19": "a5fde664c5c57de5ac374be1138dd0f7ec5dc5ab",
    "2.6.0-dev.20": "a5fde664c5c57de5ac374be1138dd0f7ec5dc5ab",
    "2.6.0-dev.21": "a5fde664c5c57de5ac374be1138dd0f7ec5dc5ab",
    "2.6.0-dev.22": "a5fde664c5c57de5ac374be1138dd0f7ec5dc5ab",
    "2.6.0-dev.23": "a5fde664c5c57de5ac374be1138dd0f7ec5dc5ab",
    "2.6.0-dev.24": "4207c64a590fe98ef0e456b5f49e99ea4f7f0ce0",
    "2.6.0-dev.25": "4207c64a590fe98ef0e456b5f49e99ea4f7f0ce0",
    "2.6.0-dev.26": "4207c64a590fe98ef0e456b5f49e99ea4f7f0ce0",
    "2.6.0-dev.27": "4207c64a590fe98ef0e456b5f49e99ea4f7f0ce0",
    "2.6.0-dev.28": "4207c64a590fe98ef0e456b5f49e99ea4f7f0ce0",
    "2.6.0-dev.29": "4207c64a590fe98ef0e456b5f49e99ea4f7f0ce0",
    "2.6.0-dev.30": "4207c64a590fe98ef0e456b5f49e99ea4f7f0ce0",
    "2.6.0-dev.31": "4207c64a590fe98ef0e456b5f49e99ea4f7f0ce0",
    "2.6.0-dev.32": "4207c64a590fe98ef0e456b5f49e99ea4f7f0ce0",
    "2.6.0-dev.33": "4207c64a590fe98ef0e456b5f49e99ea4f7f0ce0",
    "2.6.0-dev.34": "4207c64a590fe98ef0e456b5f49e99ea4f7f0ce0",
    "2.6.0-dev.35": "4207c64a590fe98ef0e456b5f49e99ea4f7f0ce0",
    "2.6.0-dev.36": "4207c64a590fe98ef0e456b5f49e99ea4f7f0ce0",
    "2.6.0-dev.37": "4207c64a590fe98ef0e456b5f49e99ea4f7f0ce0",
    "2.6.0-dev.38": "0250d982a01f9505bba89c380f5d8b0a7649633e",
    "2.6.0-dev.39": "96965f6c3db61abe3a54aee1a2f2af4e9bddace1",
    "2.6.0-dev.40": "96965f6c3db61abe3a54aee1a2f2af4e9bddace1",
    "2.6.0-dev.41": "ef1b5f6a28c2cf3933b0be3b48677edd6e0852a0",
    "2.6.0-dev.42": "ef1b5f6a28c2cf3933b0be3b48677edd6e0852a0",
    "2.6.0-dev.43": "b9dcf38b7fb0a74d3a8c9a0e8234bf7cee8417c2",
    "2.6.0-dev.44": "686b1f56ade7661ab2f1e60a6b3346abe2746175",
    "2.6.0-dev.45": "919f9059847d54a5f74e5c6e1f0ca9e036b91925",
    "2.6.0-dev.46": "a0b427d77d040aa7a76ddeedfb63e269351d63d7",
    "2.6.0-dev.47": "9da5ffb8b4a4d6b30bb6a124b6427493733e25c0",
    "2.6.0-dev.48": "650b5d0348ec38ae61e1e7db69bb54808418ede4",
    "2.6.0-dev.49": "650b5d0348ec38ae61e1e7db69bb54808418ede4",
    "2.6.0-dev.50": "650b5d0348ec38ae61e1e7db69bb54808418ede4",
    "2.6.0-dev.51": "650b5d0348ec38ae61e1e7db69bb54808418ede4",
    "2.6.0-dev.52": "650b5d0348ec38ae61e1e7db69bb54808418ede4",
    "2.6.0-dev.53": "650b5d0348ec38ae61e1e7db69bb54808418ede4",
    "2.6.0-dev.54": "650b5d0348ec38ae61e1e7db69bb54808418ede4",
    "2.6.0-dev.55": "650b5d0348ec38ae61e1e7db69bb54808418ede4",
    "2.6.0-dev.56": "650b5d0348ec38ae61e1e7db69bb54808418ede4",
    "2.6.0-dev.57": "650b5d0348ec38ae61e1e7db69bb54808418ede4",
    "2.6.0-dev.58": "650b5d0348ec38ae61e1e7db69bb54808418ede4",
    "2.6.0-dev.59": "650b5d0348ec38ae61e1e7db69bb54808418ede4",
    "2.6.0-dev.60": "650b5d0348ec38ae61e1e7db69bb54808418ede4",
    "2.6.0-dev.61": "650b5d0348ec38ae61e1e7db69bb54808418ede4",
    "2.6.0": "650b5d0348ec38ae61e1e7db69bb54808418ede4",
    "2.6.1-dev.1": "6a8054bb549e4cc23f157b0010cb2e95cb2637fb",
    "2.7.0-dev.1": "0dfa041d0d802be2e3ae0dd1ce2e4c307e39038b",
    "2.7.0-dev.2": "d1dd8a0508dfc82ae8bd83d91159e0ac807593ec",
    "2.6.1-dev.2": "6a8054bb549e4cc23f157b0010cb2e95cb2637fb",
    "2.6.1": "6a8054bb549e4cc23f157b0010cb2e95cb2637fb",
    "2.7.0-dev.3": "d1dd8a0508dfc82ae8bd83d91159e0ac807593ec",
    "2.7.0-dev.4": "d1dd8a0508dfc82ae8bd83d91159e0ac807593ec",
    "2.7.0-dev.5": "d1dd8a0508dfc82ae8bd83d91159e0ac807593ec",
    "2.7.0-dev.6": "d1dd8a0508dfc82ae8bd83d91159e0ac807593ec",
    "2.7.0-dev.7": "d1dd8a0508dfc82ae8bd83d91159e0ac807593ec",
    "2.7.0-dev.8": "e7e85356e6a71c0fda2447148512ca5ee761dbea",
    "2.6.2-dev.1": "6a8054bb549e4cc23f157b0010cb2e95cb2637fb",
    "2.7.0-dev.9": "7fe7c5b50aa571ac388a8183b3abae2114f948e8",
    "2.7.0-dev.10": "7fe7c5b50aa571ac388a8183b3abae2114f948e8",
    "2.7.0-dev.11": "7c19ae69057b1b46b2e7f90d531d99909cc85502",
    "2.6.2-dev.2": "6a8054bb549e4cc23f157b0010cb2e95cb2637fb",
    "2.6.2": "6a8054bb549e4cc23f157b0010cb2e95cb2637fb",
    "2.7.0-dev.12": "7c19ae69057b1b46b2e7f90d531d99909cc85502",
    "2.7.0-dev.13": "7c19ae69057b1b46b2e7f90d531d99909cc85502",
    "2.7.0-dev.14": "8ac7250d6543fc68cb07fb097003323856fb77fd",
    "2.7.0-dev.15": "8ac7250d6543fc68cb07fb097003323856fb77fd",
    "2.7.0-dev.16": "8ac7250d6543fc68cb07fb097003323856fb77fd",
    "2.7.0-dev.17": "8ac7250d6543fc68cb07fb097003323856fb77fd",
    "2.7.0-dev.18": "8ac7250d6543fc68cb07fb097003323856fb77fd",
    "2.7.0-dev.19": "8ac7250d6543fc68cb07fb097003323856fb77fd",
    "2.7.0-dev.20": "8ac7250d6543fc68cb07fb097003323856fb77fd",
    "2.7.0-dev.21": "8ac7250d6543fc68cb07fb097003323856fb77fd",
    "2.7.0-dev.22": "8ac7250d6543fc68cb07fb097003323856fb77fd",
    "2.7.0-dev.23": "8ac7250d6543fc68cb07fb097003323856fb77fd",
    "2.7.0-dev.24": "66ab5fb1ad3262553bee50cedb3144f3c26f67a7",
    "2.7.0-dev.25": "66ab5fb1ad3262553bee50cedb3144f3c26f67a7",
    "2.7.0-dev.26": "66ab5fb1ad3262553bee50cedb3144f3c26f67a7",
    "2.7.0-dev.27": "66ab5fb1ad3262553bee50cedb3144f3c26f67a7",
    "2.7.0-dev.28": "66ab5fb1ad3262553bee50cedb3144f3c26f67a7",
    "2.7.0-dev.29": "0d6f8376a03ae544c2be7c0279bc58a42d4bd302",
    "2.7.0-dev.30": "69cfbd5356b6cc807550b1660a501d6343cd805e",
    "2.7.0-dev.31": "69cfbd5356b6cc807550b1660a501d6343cd805e",
    "2.7.0-dev.32": "69cfbd5356b6cc807550b1660a501d6343cd805e",
    "2.7.0-dev.33": "69cfbd5356b6cc807550b1660a501d6343cd805e",
    "2.7.0-dev.34": "e6ec802febb5404ce4444eb440b0771ac896e3a4",
    "2.7.0-dev.35": "8b73a3e33a902f2b1f66f0ee82aecd716d3df824",
    "2.7.0-dev.36": "9552a36ff01a7ca7c7b811dc629ca3678da321f4",
    "2.7.0-dev.37": "a25d3c320c457986fe1b343b25c7f9182d8072f7",
    "2.7.0-dev.38": "a70da9750b0dd1eabc6b11c8548c40b856e298db",
    "2.7.0-dev.39": "a70da9750b0dd1eabc6b11c8548c40b856e298db",
    "2.7.0-dev.40": "a70da9750b0dd1eabc6b11c8548c40b856e298db",
    "2.7.0-dev.41": "a70da9750b0dd1eabc6b11c8548c40b856e298db",
    "2.7.0-dev.42": "a25edead86c5f3f39055ab41b078b8d7cb36477a",
    "2.7.0-dev.43": "a25edead86c5f3f39055ab41b078b8d7cb36477a",
    "2.7.0-dev.44": "a25edead86c5f3f39055ab41b078b8d7cb36477a",
    "2.7.0-dev.45": "a25edead86c5f3f39055ab41b078b8d7cb36477a",
    "2.7.0-dev.46": "a25edead86c5f3f39055ab41b078b8d7cb36477a",
    "2.7.0-dev.47": "a25edead86c5f3f39055ab41b078b8d7cb36477a",
    "2.7.0-dev.48": "a25edead86c5f3f39055ab41b078b8d7cb36477a",
    "2.7.0-dev.49": "a25edead86c5f3f39055ab41b078b8d7cb36477a",
    "2.7.0-dev.50": "a25edead86c5f3f39055ab41b078b8d7cb36477a",
    "2.7.0-dev.51": "3425da02811ca5d0994ba994c81192f304545fbc",
    "2.7.0-dev.52": "3425da02811ca5d0994ba994c81192f304545fbc",
    "2.7.0-dev.53": "3425da02811ca5d0994ba994c81192f304545fbc",
    "2.7.0-dev.54": "3425da02811ca5d0994ba994c81192f304545fbc",
    "2.7.0-dev.55": "1326cc350d369f69e2b4c0ea3bddc97ff384629e",
    "2.7.0-dev.56": "c508cbd521381ba4f3926e3f5ab1878a2881537d",
    "2.7.0-dev.57": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.58": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.59": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.60": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.61": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.62": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.63": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.64": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.65": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.66": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.67": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.68": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.69": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.70": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.71": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.72": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.73": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.74": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.75": "eaade828a21d8ee3f4940f0af7da3ae0922db4df",
    "2.7.0-dev.76": "eaade828a21d8ee3f4940f0af7da3ae0922db4df",
    "2.7.0-dev.77": "eaade828a21d8ee3f4940f0af7da3ae0922db4df",
    "2.7.0-dev.78": "eaade828a21d8ee3f4940f0af7da3ae0922db4df",
    "2.7.0-dev.79": "eaade828a21d8ee3f4940f0af7da3ae0922db4df",
    "2.7.0-dev.80": "eaade828a21d8ee3f4940f0af7da3ae0922db4df",
    "2.7.0-dev.81": "eaade828a21d8ee3f4940f0af7da3ae0922db4df",
    "2.7.0-dev.82": "eaade828a21d8ee3f4940f0af7da3ae0922db4df",
    "2.7.0": "eaade828a21d8ee3f4940f0af7da3ae0922db4df",
    "2.8.0-dev.1": "290eb7c11a5561ad869041aa86323b85b337b12d",
    "2.8.0-dev.2": "2b4c3254badf30765f7839e350e4aa11a0842a8d",
    "2.8.0-dev.3": "2b4c3254badf30765f7839e350e4aa11a0842a8d",
    "2.7.1-dev.1": "5c2ad460cf4fe8c9330e6640b266c046542c8b6a",
    "2.8.0-dev.4": "2b4c3254badf30765f7839e350e4aa11a0842a8d",
    "2.8.0-dev.5": "d516bd2a52ad91031ba1c2ff3bd6d4429e727322",
    "2.8.0-dev.6": "d516bd2a52ad91031ba1c2ff3bd6d4429e727322",
    "2.7.1": "5c2ad460cf4fe8c9330e6640b266c046542c8b6a",
    "2.8.0-dev.7": "d516bd2a52ad91031ba1c2ff3bd6d4429e727322",
    "2.8.0-dev.8": "d516bd2a52ad91031ba1c2ff3bd6d4429e727322",
    "2.8.0-dev.9": "d516bd2a52ad91031ba1c2ff3bd6d4429e727322",
    "2.8.0-dev.10": "296e3b5c93fde73fdf2df594765395c51ddbdae0",
    "2.8.0-dev.11": "296e3b5c93fde73fdf2df594765395c51ddbdae0",
    "2.8.0-dev.12": "a1097622fd3779393f345f246e050da017d3aa2d",
    "2.8.0-dev.13": "97b83cec7c1e2276d16624341947ddf44379cff6",
    "2.8.0-dev.14": "97b83cec7c1e2276d16624341947ddf44379cff6",
    "2.8.0-dev.15": "014c300b2749e2f856db131ea8fdc8ad4a3c00e8",
    "2.8.0-dev.16": "16b2e7be003d50a60b7f0ebff88ae7e2c8caf863",
    "2.8.0-dev.17": "16b2e7be003d50a60b7f0ebff88ae7e2c8caf863",
    "2.8.0-dev.18": "16b2e7be003d50a60b7f0ebff88ae7e2c8caf863",
    "2.8.0-dev.19": "16b2e7be003d50a60b7f0ebff88ae7e2c8caf863",
    "2.8.0-dev.20": "16b2e7be003d50a60b7f0ebff88ae7e2c8caf863",
    "2.8.0-dev.21": "16b2e7be003d50a60b7f0ebff88ae7e2c8caf863",
    "2.8.0-dev.22": "2c8f6b14f5d65afe712de0b8b7a18eae29446d45",
    "2.8.0-dev.23": "1c3ee33299fa6f9ae067f6b37867467d1749f74d",
    "2.8.0-dev.24": "4ad878f36e79cf50b5b4f9781fd8be266a2e8eea",
    "2.8.0-dev.25": "b2ba0251835a0fb068871fe65272136853245dd3",
    "2.8.0-dev.26": "ee3559ca54391582e5fe8c208f93ae6e178aeed8",
    "2.8.0-dev.27": "7aef029819840cd88e6333b5037105264c82e2f4",
    "2.8.0-dev.28": "37b9492b5e3f80c980323b027712a9ec227ebb07",
    "2.8.0-dev.29": "37b9492b5e3f80c980323b027712a9ec227ebb07",
    "2.8.0-dev.30": "62fcc29194c5c1ed16d16c65c21b944d60acfd81",
    "2.8.0-dev.31": "62fcc29194c5c1ed16d16c65c21b944d60acfd81",
    "2.8.0-dev.32": "62fcc29194c5c1ed16d16c65c21b944d60acfd81",
    "2.8.0-dev.33": "62fcc29194c5c1ed16d16c65c21b944d60acfd81",
    "2.8.0-dev.34": "9b958b23288b9108f357c08d16ab5a054e9456b8",
    "2.8.0-dev.35": "9b958b23288b9108f357c08d16ab5a054e9456b8",
    "2.8.0-dev.36": "9b958b23288b9108f357c08d16ab5a054e9456b8",
    "2.8.0-dev.37": "5ed0deef17ce35faf058462e43ccc86fed761dfe",
    "2.8.0-dev.38": "fc6db18a9ab2e659cbf600340f5d4f4abb0b1974",
    "2.8.0-dev.39": "4a88935fd579c4284cec066046b3fcfe32f0c0fa",
    "2.8.0-dev.40": "eff0f4d1aecdbd12d9f5ca2ff0a21b54f4b90bf5",
    "2.8.0-dev.41": "3eba5fc0d5e2f0b42c495e3fcb677f16157a0549",
    "2.8.0-dev.42": "3eba5fc0d5e2f0b42c495e3fcb677f16157a0549",
    "2.8.0-dev.43": "2c65c7e137baad4c34f9d7c410633f3b0398a373",
    "2.8.0-dev.44": "4f4fb2e5ea3d830a9cf8f4e83b824f844fa43a0d",
    "2.8.0-dev.45": "2c65c7e137baad4c34f9d7c410633f3b0398a373",
    "2.8.0-dev.46": "2c65c7e137baad4c34f9d7c410633f3b0398a373",
    "2.8.0-dev.47": "2c65c7e137baad4c34f9d7c410633f3b0398a373",
    "2.8.0-dev.48": "301a95d643e1ba39474bb520faba726ce856884c",
    "2.8.0-dev.49": "301a95d643e1ba39474bb520faba726ce856884c",
    "2.8.0-dev.50": "b2d67bfad6619134331404603b61ab85fde90771",
    "2.8.0-dev.51": "aff73c7aeee85c32082de75962424f199530284d"
  };
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/getAllVersions.js
var require_getAllVersions = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    engineVersions: () => import_versions.engineVersions
  });
  var import_versions = __toModule3(require_versions());
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/pick.js
var require_pick = __commonJS((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    pick: () => pick3
  });
  function pick3(obj, keys) {
    return Object.entries(obj).reduce((acc, [key, value]) => {
      if (keys.includes(key)) {
        acc[key] = value;
      }
      return acc;
    }, {});
  }
});

// ../../node_modules/.pnpm/has-yarn@2.1.0/node_modules/has-yarn/index.js
var require_has_yarn = __commonJS((exports2, module2) => {
  "use strict";
  var path10 = require("path");
  var fs9 = require("fs");
  var hasYarn = (cwd = process.cwd()) => fs9.existsSync(path10.resolve(cwd, "yarn.lock"));
  module2.exports = hasYarn;
  module2.exports.default = hasYarn;
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/utils/resolve.js
var require_resolve2 = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    resolve: () => resolve,
    resolvePkg: () => resolvePkg2
  });
  var import_resolve = __toModule3(require_resolve());
  var import_path10 = __toModule3(require("path"));
  async function resolve(id, options) {
    const _options = {preserveSymlinks: false, ...options};
    return new Promise((res) => {
      (0, import_resolve.default)(id, _options, (e, v) => {
        if (e)
          res(void 0);
        res(v);
      });
    });
  }
  async function resolvePkg2(id, options) {
    const resolvedPath = await resolve(`${id}/package.json`, options);
    return resolvedPath && import_path10.default.dirname(resolvedPath);
  }
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/predefinedGeneratorResolvers.js
var require_predefinedGeneratorResolvers = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    predefinedGeneratorResolvers: () => predefinedGeneratorResolvers
  });
  var import_debug3 = __toModule3(require_dist2());
  var import_chalk14 = __toModule3(require_source());
  var import_execa2 = __toModule3(require_execa());
  var import_fs9 = __toModule3(require("fs"));
  var import_has_yarn = __toModule3(require_has_yarn());
  var import_path10 = __toModule3(require("path"));
  var import_resolve = __toModule3(require_resolve2());
  var import__2 = __toModule3(require_dist12());
  var import_getCommandWithExecutor = __toModule3(require_getCommandWithExecutor());
  var debug3 = (0, import_debug3.default)("prisma:generator");
  var realPath = import_fs9.default.promises.realpath;
  async function findPrismaClientDir(baseDir) {
    const resolveOpts = {basedir: baseDir, preserveSymlinks: true};
    const CLIDir = await (0, import_resolve.resolvePkg)("prisma", resolveOpts);
    const clientDir = await (0, import_resolve.resolvePkg)("@prisma/client", resolveOpts);
    const resolvedClientDir = clientDir && await realPath(clientDir);
    debug3("prismaCLIDir", CLIDir);
    debug3("prismaClientDir", clientDir);
    if (CLIDir === void 0)
      return resolvedClientDir;
    if (clientDir === void 0)
      return resolvedClientDir;
    const relDir = import_path10.default.relative(CLIDir, clientDir).split(import_path10.default.sep);
    if (relDir[0] !== ".." || relDir[1] === "..")
      return void 0;
    return resolvedClientDir;
  }
  var predefinedGeneratorResolvers = {
    photonjs: () => {
      throw new Error(`Oops! Photon has been renamed to Prisma Client. Please make the following adjustments:
  1. Rename ${import_chalk14.default.red('provider = "photonjs"')} to ${import_chalk14.default.green('provider = "prisma-client-js"')} in your ${import_chalk14.default.bold("schema.prisma")} file.
  2. Replace your ${import_chalk14.default.bold("package.json")}'s ${import_chalk14.default.red("@prisma/photon")} dependency to ${import_chalk14.default.green("@prisma/client")}
  3. Replace ${import_chalk14.default.red("import { Photon } from '@prisma/photon'")} with ${import_chalk14.default.green("import { PrismaClient } from '@prisma/client'")} in your code.
  4. Run ${import_chalk14.default.green((0, import_getCommandWithExecutor.getCommandWithExecutor)("prisma generate"))} again.
      `);
    },
    "prisma-client-js": async (baseDir, version) => {
      let prismaClientDir = await findPrismaClientDir(baseDir);
      debug3("baseDir", baseDir);
      checkYarnVersion();
      await checkTypeScriptVersion();
      if (!prismaClientDir && !process.env.PRISMA_GENERATE_SKIP_AUTOINSTALL) {
        if (!import_fs9.default.existsSync(import_path10.default.join(process.cwd(), "package.json")) && !import_fs9.default.existsSync(import_path10.default.join(process.cwd(), "../package.json"))) {
          const defaultPackageJson = `{
  "name": "my-prisma-project",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \\"Error: no test specified\\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
`;
          import_fs9.default.writeFileSync(import_path10.default.join(process.cwd(), "package.json"), defaultPackageJson);
          console.info(`\u2714 Created ${import_chalk14.default.bold.green("./package.json")}`);
        }
        await installPackage(baseDir, `-D prisma@${version != null ? version : "latest"}`);
        await installPackage(baseDir, `@prisma/client@${version != null ? version : "latest"}`);
        prismaClientDir = await findPrismaClientDir(import_path10.default.join(".", baseDir));
        if (!prismaClientDir) {
          throw new Error(`Could not resolve @prisma/client despite the installation that we just tried.
Please try to install it by hand with ${import_chalk14.default.bold.greenBright("npm install @prisma/client")} and rerun ${import_chalk14.default.bold((0, import_getCommandWithExecutor.getCommandWithExecutor)("prisma generate"))} \u{1F64F}.`);
        }
        console.info(`
\u2714 Installed the ${import_chalk14.default.bold.green("@prisma/client")} and ${import_chalk14.default.bold.green("prisma")} packages in your project`);
      }
      if (!prismaClientDir) {
        throw new Error(`Could not resolve @prisma/client.
Please try to install it with ${import_chalk14.default.bold.greenBright("npm install @prisma/client")} and rerun ${import_chalk14.default.bold((0, import_getCommandWithExecutor.getCommandWithExecutor)("prisma generate"))} \u{1F64F}.`);
      }
      return {
        outputPath: prismaClientDir,
        generatorPath: import_path10.default.resolve(prismaClientDir, "generator-build/index.js"),
        isNode: true
      };
    }
  };
  async function installPackage(baseDir, pkg2) {
    const yarnUsed = (0, import_has_yarn.default)(baseDir) || (0, import_has_yarn.default)(import_path10.default.join(baseDir, ".."));
    const cmdName = yarnUsed ? "yarn add" : "npm install";
    await import_execa2.default.command(`${cmdName} ${pkg2}`, {
      cwd: baseDir,
      stdio: "inherit",
      env: {
        PRISMA_SKIP_POSTINSTALL_GENERATE: "true"
      }
    });
  }
  function checkYarnVersion() {
    if (process.env.npm_config_user_agent) {
      const match = parseUserAgentString(process.env.npm_config_user_agent);
      if (match) {
        const {agent, major, minor, patch} = match;
        if (agent === "yarn" && major === 1) {
          const currentYarnVersion = `${major}.${minor}.${patch}`;
          const minYarnVersion = "1.19.2";
          if (semverLt(currentYarnVersion, minYarnVersion)) {
            import__2.logger.warn(`Your ${import_chalk14.default.bold("yarn")} has version ${currentYarnVersion}, which is outdated. Please update it to ${import_chalk14.default.bold(minYarnVersion)} or ${import_chalk14.default.bold("newer")} in order to use Prisma.`);
          }
        }
      }
    }
  }
  async function checkTypeScriptVersion() {
    const minVersion = "4.1.0";
    try {
      const typescriptPath = await (0, import_resolve.resolvePkg)("typescript", {
        basedir: process.cwd()
      });
      const typescriptPkg = typescriptPath && import_path10.default.join(typescriptPath, "package.json");
      if (typescriptPkg && import_fs9.default.existsSync(typescriptPkg)) {
        const pjson = require(typescriptPkg);
        const currentVersion = pjson.version;
        if (semverLt(currentVersion, minVersion)) {
          import__2.logger.warn(`Prisma detected that your ${import_chalk14.default.bold("TypeScript")} version ${currentVersion} is outdated. If you want to use Prisma Client with TypeScript please update it to version ${import_chalk14.default.bold(minVersion)} or ${import_chalk14.default.bold("newer")}`);
        }
      }
    } catch (e) {
    }
  }
  function semverLt(a, b) {
    const [major1, minor1, patch1] = a.split(".");
    const [major2, minor2, patch2] = b.split(".");
    if (major1 < major2) {
      return true;
    }
    if (major1 > major2) {
      return false;
    }
    if (minor1 < minor2) {
      return true;
    }
    if (minor1 > minor2) {
      return false;
    }
    if (patch1 < patch2) {
      return true;
    }
    if (patch1 > patch2) {
      return false;
    }
    return false;
  }
  function parseUserAgentString(str) {
    const userAgentRegex = /(\w+)\/(\d+)\.(\d+)\.(\d+)/;
    const match = userAgentRegex.exec(str);
    if (match) {
      const agent = match[1];
      const major = parseInt(match[2]);
      const minor = parseInt(match[3]);
      const patch = parseInt(match[4]);
      return {agent, major, minor, patch};
    }
    return null;
  }
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/resolveOutput.js
var require_resolveOutput = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    resolveOutput: () => resolveOutput
  });
  var import_fs9 = __toModule3(require("fs"));
  var import_path10 = __toModule3(require("path"));
  var import_util6 = __toModule3(require("util"));
  var exists2 = (0, import_util6.promisify)(import_fs9.default.exists);
  async function resolveNodeModulesBase(cwd) {
    if (await exists2(import_path10.default.resolve(process.cwd(), "prisma/schema.prisma"))) {
      return process.cwd();
    }
    if (import_path10.default.relative(process.cwd(), cwd) === "prisma" && await exists2(import_path10.default.resolve(process.cwd(), "package.json"))) {
      return process.cwd();
    }
    if (await exists2(import_path10.default.resolve(cwd, "node_modules"))) {
      return cwd;
    }
    if (await exists2(import_path10.default.resolve(cwd, "../node_modules"))) {
      return import_path10.default.join(cwd, "../");
    }
    if (await exists2(import_path10.default.resolve(cwd, "package.json"))) {
      return cwd;
    }
    if (await exists2(import_path10.default.resolve(cwd, "../package.json"))) {
      return import_path10.default.join(cwd, "../");
    }
    return cwd;
  }
  async function resolveOutput(options) {
    const defaultOutput = stripRelativePath(options.defaultOutput);
    if (defaultOutput.startsWith("node_modules")) {
      const nodeModulesBase = await resolveNodeModulesBase(options.baseDir);
      return import_path10.default.resolve(nodeModulesBase, defaultOutput);
    }
    return import_path10.default.resolve(options.baseDir, defaultOutput);
  }
  function stripRelativePath(pathString) {
    if (pathString.startsWith("./")) {
      return pathString.slice(2);
    }
    return pathString;
  }
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/utils/parseEnvValue.js
var require_parseEnvValue = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    parseBinaryTargetsEnvValue: () => parseBinaryTargetsEnvValue2,
    parseEnvValue: () => parseEnvValue3
  });
  var import_chalk14 = __toModule3(require_source());
  function parseEnvValue3(object) {
    if (object.fromEnvVar && object.fromEnvVar != "null") {
      const value = process.env[object.fromEnvVar];
      if (!value) {
        throw new Error(`Attempted to load provider value using \`env(${object.fromEnvVar})\` but it was not present. Please ensure that ${import_chalk14.default.dim(object.fromEnvVar)} is present in your Environment Variables`);
      }
      return value;
    }
    return object.value;
  }
  function parseBinaryTargetsEnvValue2(object) {
    if (object.fromEnvVar && object.fromEnvVar != "null") {
      const value = process.env[object.fromEnvVar];
      if (!value) {
        throw new Error(`Attempted to load binaryTargets value using \`env(${object.fromEnvVar})\` but it was not present. Please ensure that ${import_chalk14.default.dim(object.fromEnvVar)} is present in your Environment Variables`);
      }
      return JSON.parse(value);
    }
    return object.value;
  }
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/utils/extractPreviewFeatures.js
var require_extractPreviewFeatures = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    extractPreviewFeatures: () => extractPreviewFeatures2
  });
  var import_parseEnvValue2 = __toModule3(require_parseEnvValue());
  function extractPreviewFeatures2(config) {
    var _a;
    return ((_a = config.generators.find((g) => (0, import_parseEnvValue2.parseEnvValue)(g.provider) === "prisma-client-js")) == null ? void 0 : _a.previewFeatures) || [];
  }
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/utils/mapPreviewFeatures.js
var require_mapPreviewFeatures = __commonJS((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    mapPreviewFeatures: () => mapPreviewFeatures2
  });
  var featureFlagMap = {
    transactionApi: "transaction",
    aggregateApi: "aggregations"
  };
  function mapPreviewFeatures2(features) {
    if (Array.isArray(features) && features.length > 0) {
      return features.map((f) => {
        var _a;
        return (_a = featureFlagMap[f]) != null ? _a : f;
      });
    }
    return [];
  }
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/highlight/theme.js
var require_theme = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    blue: () => blue,
    brightBlue: () => brightBlue,
    darkBrightBlue: () => darkBrightBlue,
    gamboge: () => gamboge,
    identity: () => identity,
    theme: () => theme
  });
  var import_chalk14 = __toModule3(require_source());
  var gamboge = import_chalk14.default.rgb(228, 155, 15);
  var darkBrightBlue = import_chalk14.default.rgb(107, 139, 140);
  var blue = import_chalk14.default.cyan;
  var brightBlue = import_chalk14.default.rgb(127, 155, 175);
  var identity = (str) => str || "";
  var theme = {
    keyword: blue,
    entity: blue,
    value: brightBlue,
    punctuation: darkBrightBlue,
    directive: blue,
    function: blue,
    variable: brightBlue,
    string: brightBlue,
    boolean: gamboge,
    comment: import_chalk14.default.dim
  };
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/highlight/prism.js
var require_prism = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    Prism: () => Prism,
    Token: () => Token
  });
  var import_theme = __toModule3(require_theme());
  var _self = {};
  var uniqueId = 0;
  var Prism = {
    manual: _self.Prism && _self.Prism.manual,
    disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,
    util: {
      encode: function(tokens) {
        if (tokens instanceof Token) {
          const anyTokens = tokens;
          return new Token(anyTokens.type, Prism.util.encode(anyTokens.content), anyTokens.alias);
        } else if (Array.isArray(tokens)) {
          return tokens.map(Prism.util.encode);
        } else {
          return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
        }
      },
      type: function(o) {
        return Object.prototype.toString.call(o).slice(8, -1);
      },
      objId: function(obj) {
        if (!obj["__id"]) {
          Object.defineProperty(obj, "__id", {value: ++uniqueId});
        }
        return obj["__id"];
      },
      clone: function deepClone(o, visited) {
        visited = visited || {};
        let clone, id;
        const type = Prism.util.type(o);
        switch (type) {
          case "Object":
            id = Prism.util.objId(o);
            if (visited[id]) {
              return visited[id];
            }
            clone = {};
            visited[id] = clone;
            for (const key in o) {
              if (o.hasOwnProperty(key)) {
                clone[key] = deepClone(o[key], visited);
              }
            }
            return clone;
          case "Array":
            id = Prism.util.objId(o);
            if (visited[id]) {
              return visited[id];
            }
            clone = [];
            visited[id] = clone;
            o.forEach(function(v, i) {
              clone[i] = deepClone(v, visited);
            });
            return clone;
          default:
            return o;
        }
      }
    },
    languages: {
      extend: function(id, redef) {
        const lang = Prism.util.clone(Prism.languages[id]);
        for (const key in redef) {
          lang[key] = redef[key];
        }
        return lang;
      },
      insertBefore: function(inside, before, insert, root) {
        root = root || Prism.languages;
        const grammar = root[inside];
        const ret = {};
        for (const token in grammar) {
          if (grammar.hasOwnProperty(token)) {
            if (token == before) {
              for (const newToken in insert) {
                if (insert.hasOwnProperty(newToken)) {
                  ret[newToken] = insert[newToken];
                }
              }
            }
            if (!insert.hasOwnProperty(token)) {
              ret[token] = grammar[token];
            }
          }
        }
        const old = root[inside];
        root[inside] = ret;
        Prism.languages.DFS(Prism.languages, function(key, value) {
          if (value === old && key != inside) {
            this[key] = ret;
          }
        });
        return ret;
      },
      DFS: function DFS(o, callback, type, visited) {
        visited = visited || {};
        const objId = Prism.util.objId;
        for (const i in o) {
          if (o.hasOwnProperty(i)) {
            callback.call(o, i, o[i], type || i);
            const property = o[i], propertyType = Prism.util.type(property);
            if (propertyType === "Object" && !visited[objId(property)]) {
              visited[objId(property)] = true;
              DFS(property, callback, null, visited);
            } else if (propertyType === "Array" && !visited[objId(property)]) {
              visited[objId(property)] = true;
              DFS(property, callback, i, visited);
            }
          }
        }
      }
    },
    plugins: {},
    highlight: function(text, grammar, language) {
      const env2 = {
        code: text,
        grammar,
        language
      };
      Prism.hooks.run("before-tokenize", env2);
      env2.tokens = Prism.tokenize(env2.code, env2.grammar);
      Prism.hooks.run("after-tokenize", env2);
      return Token.stringify(Prism.util.encode(env2.tokens), env2.language);
    },
    matchGrammar: function(text, strarr, grammar, index, startPos, oneshot, target) {
      for (const token in grammar) {
        if (!grammar.hasOwnProperty(token) || !grammar[token]) {
          continue;
        }
        if (token == target) {
          return;
        }
        let patterns = grammar[token];
        patterns = Prism.util.type(patterns) === "Array" ? patterns : [patterns];
        for (let j = 0; j < patterns.length; ++j) {
          let pattern = patterns[j], inside = pattern.inside, lookbehind = !!pattern.lookbehind, greedy = !!pattern.greedy, lookbehindLength = 0, alias = pattern.alias;
          if (greedy && !pattern.pattern.global) {
            const flags = pattern.pattern.toString().match(/[imuy]*$/)[0];
            pattern.pattern = RegExp(pattern.pattern.source, flags + "g");
          }
          pattern = pattern.pattern || pattern;
          for (let i = index, pos = startPos; i < strarr.length; pos += strarr[i].length, ++i) {
            let str = strarr[i];
            if (strarr.length > text.length) {
              return;
            }
            if (str instanceof Token) {
              continue;
            }
            if (greedy && i != strarr.length - 1) {
              pattern.lastIndex = pos;
              const match2 = pattern.exec(text);
              if (!match2) {
                break;
              }
              var from = match2.index + (lookbehind ? match2[1].length : 0), to = match2.index + match2[0].length, k = i, p = pos;
              for (let len = strarr.length; k < len && (p < to || !strarr[k].type && !strarr[k - 1].greedy); ++k) {
                p += strarr[k].length;
                if (from >= p) {
                  ++i;
                  pos = p;
                }
              }
              if (strarr[i] instanceof Token) {
                continue;
              }
              delNum = k - i;
              str = text.slice(pos, p);
              match2.index -= pos;
            } else {
              pattern.lastIndex = 0;
              var match = pattern.exec(str), delNum = 1;
            }
            if (!match) {
              if (oneshot) {
                break;
              }
              continue;
            }
            if (lookbehind) {
              lookbehindLength = match[1] ? match[1].length : 0;
            }
            var from = match.index + lookbehindLength, match = match[0].slice(lookbehindLength), to = from + match.length, before = str.slice(0, from), after = str.slice(to);
            const args2 = [i, delNum];
            if (before) {
              ++i;
              pos += before.length;
              args2.push(before);
            }
            const wrapped = new Token(token, inside ? Prism.tokenize(match, inside) : match, alias, match, greedy);
            args2.push(wrapped);
            if (after) {
              args2.push(after);
            }
            Array.prototype.splice.apply(strarr, args2);
            if (delNum != 1)
              Prism.matchGrammar(text, strarr, grammar, i, pos, true, token);
            if (oneshot)
              break;
          }
        }
      }
    },
    tokenize: function(text, grammar) {
      const strarr = [text];
      const rest = grammar.rest;
      if (rest) {
        for (const token in rest) {
          grammar[token] = rest[token];
        }
        delete grammar.rest;
      }
      Prism.matchGrammar(text, strarr, grammar, 0, 0, false);
      return strarr;
    },
    hooks: {
      all: {},
      add: function(name, callback) {
        const hooks = Prism.hooks.all;
        hooks[name] = hooks[name] || [];
        hooks[name].push(callback);
      },
      run: function(name, env2) {
        const callbacks = Prism.hooks.all[name];
        if (!callbacks || !callbacks.length) {
          return;
        }
        for (var i = 0, callback; callback = callbacks[i++]; ) {
          callback(env2);
        }
      }
    },
    Token
  };
  Prism.languages.clike = {
    comment: [
      {
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: true
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: true,
        greedy: true
      }
    ],
    string: {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: true
    },
    "class-name": {
      pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i,
      lookbehind: true,
      inside: {
        punctuation: /[.\\]/
      }
    },
    keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
    boolean: /\b(?:true|false)\b/,
    function: /\w+(?=\()/,
    number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,
    operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
    punctuation: /[{}[\];(),.:]/
  };
  Prism.languages.javascript = Prism.languages.extend("clike", {
    "class-name": [
      Prism.languages.clike["class-name"],
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/,
        lookbehind: true
      }
    ],
    keyword: [
      {
        pattern: /((?:^|})\s*)(?:catch|finally)\b/,
        lookbehind: true
      },
      {
        pattern: /(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
        lookbehind: true
      }
    ],
    number: /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,
    function: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    operator: /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/
  });
  Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;
  Prism.languages.insertBefore("javascript", "keyword", {
    regex: {
      pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/,
      lookbehind: true,
      greedy: true
    },
    "function-variable": {
      pattern: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/,
      alias: "function"
    },
    parameter: [
      {
        pattern: /(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/,
        lookbehind: true,
        inside: Prism.languages.javascript
      },
      {
        pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i,
        inside: Prism.languages.javascript
      },
      {
        pattern: /(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/,
        lookbehind: true,
        inside: Prism.languages.javascript
      },
      {
        pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/,
        lookbehind: true,
        inside: Prism.languages.javascript
      }
    ],
    constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
  });
  Prism.languages.insertBefore("javascript", "string", {
    "template-string": {
      pattern: /`(?:\\[\s\S]|\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}|[^\\`])*`/,
      greedy: true,
      inside: {
        interpolation: {
          pattern: /\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}/,
          inside: {
            "interpolation-punctuation": {
              pattern: /^\${|}$/,
              alias: "punctuation"
            },
            rest: Prism.languages.javascript
          }
        },
        string: /[\s\S]+/
      }
    }
  });
  if (Prism.languages.markup) {
    Prism.languages.markup.tag.addInlined("script", "javascript");
  }
  Prism.languages.js = Prism.languages.javascript;
  Prism.languages.typescript = Prism.languages.extend("javascript", {
    keyword: /\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\b/,
    builtin: /\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/
  });
  Prism.languages.ts = Prism.languages.typescript;
  function Token(type, content, alias, matchedStr, greedy) {
    this.type = type;
    this.content = content;
    this.alias = alias;
    this.length = (matchedStr || "").length | 0;
    this.greedy = !!greedy;
  }
  Token.stringify = function(o, language) {
    if (typeof o == "string") {
      return o;
    }
    if (Array.isArray(o)) {
      return o.map(function(element) {
        return Token.stringify(element, language);
      }).join("");
    }
    return getColorForSyntaxKind(o.type)(o.content);
  };
  function getColorForSyntaxKind(syntaxKind) {
    return import_theme.theme[syntaxKind] || import_theme.identity;
  }
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/highlight/languages/dml.js
var require_dml = __commonJS((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    dml: () => dml
  });
  var dml = {
    string: [/\"(.*)\"/g, /\'(.*)\'/g],
    directive: {pattern: /(@.*)/g},
    entity: [
      /model\s+\w+/g,
      /enum\s+\w+/g,
      /datasource\s+\w+/g,
      /source\s+\w+/g,
      /generator\s+\w+/g
    ],
    comment: /#.*/g,
    value: [/\b\s+(\w+)/g],
    punctuation: /(\:|}|{|"|=)/g,
    boolean: /(true|false)/g
  };
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/highlight/languages/sql.js
var require_sql = __commonJS((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    sql: () => sql
  });
  var sql = {
    comment: {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
      lookbehind: true
    },
    variable: [
      {
        pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
        greedy: true
      },
      /@[\w.$]+/
    ],
    string: {
      pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
      greedy: true,
      lookbehind: true
    },
    function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
    keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:_INSERT|COL)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURNS?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
    boolean: /\b(?:TRUE|FALSE|NULL)\b/i,
    number: /\b0x[\da-f]+\b|\b\d+\.?\d*|\B\.\d+\b/i,
    operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|IN|LIKE|NOT|OR|IS|DIV|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
    punctuation: /[;[\]()`,.]/
  };
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/highlight/highlight.js
var require_highlight = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    highlightDatamodel: () => highlightDatamodel2,
    highlightSql: () => highlightSql2,
    highlightTS: () => highlightTS2
  });
  var import_prism = __toModule3(require_prism());
  var import_dml = __toModule3(require_dml());
  var import_sql = __toModule3(require_sql());
  function highlightDatamodel2(str) {
    return highlight(str, import_dml.dml);
  }
  function highlightSql2(str) {
    return highlight(str, import_sql.sql);
  }
  function highlightTS2(str) {
    return highlight(str, import_prism.Prism.languages.javascript);
  }
  function highlight(str, grammar) {
    const tokens = import_prism.Prism.tokenize(str, grammar);
    return tokens.map((t) => import_prism.Token.stringify(t)).join("");
  }
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/link.js
var require_link = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    link: () => link5
  });
  var import_terminal_link = __toModule3(require_terminal_link());
  var import_chalk14 = __toModule3(require_source());
  function link5(url) {
    return (0, import_terminal_link.default)(url, url, {
      fallback: (url2) => import_chalk14.default.underline(url2)
    });
  }
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/utils/missingDatasource.js
var require_missingDatasource = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    missingDatasource: () => missingDatasource
  });
  var import_chalk14 = __toModule3(require_source());
  var import_highlight = __toModule3(require_highlight());
  var import_link = __toModule3(require_link());
  var missingDatasource = `
You don't have any ${import_chalk14.default.bold("datasource")} defined in your ${import_chalk14.default.bold("schema.prisma")}.
You can define a datasource like this:

${import_chalk14.default.bold((0, import_highlight.highlightDatamodel)(`datasource db {
  provider = "postgresql"
  url      = env("DB_URL")
}`))}

More information in our documentation:
${(0, import_link.link)("https://pris.ly/d/prisma-schema")}
`;
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/utils/missingGeneratorMessage.js
var require_missingGeneratorMessage = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    missingGeneratorMessage: () => missingGeneratorMessage2,
    missingModelMessage: () => missingModelMessage,
    missingModelMessageMongoDB: () => missingModelMessageMongoDB
  });
  var import_chalk14 = __toModule3(require_source());
  var import_highlight = __toModule3(require_highlight());
  var import_link = __toModule3(require_link());
  var missingGeneratorMessage2 = `
${import_chalk14.default.blue("info")} You don't have any generators defined in your ${import_chalk14.default.bold("schema.prisma")}, so nothing will be generated.
You can define them like this:

${import_chalk14.default.bold((0, import_highlight.highlightDatamodel)(`generator client {
  provider = "prisma-client-js"
}`))}`;
  var missingModelMessage = `
You don't have any ${import_chalk14.default.bold("models")} defined in your ${import_chalk14.default.bold("schema.prisma")}, so nothing will be generated.
You can define a model like this:

${import_chalk14.default.bold((0, import_highlight.highlightDatamodel)(`model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
}`))}

More information in our documentation:
${(0, import_link.link)("https://pris.ly/d/prisma-schema")}
`;
  var missingModelMessageMongoDB = `
You don't have any ${import_chalk14.default.bold("models")} defined in your ${import_chalk14.default.bold("schema.prisma")}, so nothing will be generated.
You can define a model like this:

${import_chalk14.default.bold((0, import_highlight.highlightDatamodel)(`model User {
  id    String  @id @default(dbgenerated()) @map("_id") @db.ObjectId
  email String  @unique
  name  String?
}`))}

More information in our documentation:
${(0, import_link.link)("https://pris.ly/d/prisma-schema")}
`;
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/utils/mongoFeatureFlagMissingMessage.js
var require_mongoFeatureFlagMissingMessage = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    mongoFeatureFlagMissingMessage: () => mongoFeatureFlagMissingMessage
  });
  var import_chalk14 = __toModule3(require_source());
  var import_highlight = __toModule3(require_highlight());
  var import_link = __toModule3(require_link());
  var mongoFeatureFlagMissingMessage = `
In order to use the ${import_chalk14.default.bold("mongodb")} provider,
you need to set the ${import_chalk14.default.green("mongodb")} feature flag.
You can define the feature flag like this:

${import_chalk14.default.bold((0, import_highlight.highlightDatamodel)(`generator client {
    provider = "prisma-client-js"
    previewFeatures = ["mongodb"]
  }`))}

More information in our documentation:
${(0, import_link.link)("https://pris.ly/d/prisma-schema")}
`;
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/utils/printConfigWarnings.js
var require_printConfigWarnings = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    printConfigWarnings: () => printConfigWarnings2
  });
  var import_chalk14 = __toModule3(require_source());
  function printConfigWarnings2(warnings) {
    if (warnings && warnings.length > 0) {
      const message = warnings.map((warning) => `${import_chalk14.default.yellow("warn")} ${warning}`).join("\n");
      console.warn(message);
    }
  }
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/getGenerators.js
var require_getGenerators = __commonJS((exports, module) => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name in all)
      __defProp(target, name, {get: all[name], enumerable: true});
  };
  var __reExport = (target, module2, desc) => {
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
      for (let key of __getOwnPropNames(module2))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule = (module2) => {
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
  };
  __export(exports, {
    getGenerator: () => getGenerator,
    getGenerators: () => getGenerators,
    knownBinaryTargets: () => knownBinaryTargets,
    skipIndex: () => skipIndex
  });
  var import_debug = __toModule(require_dist2());
  var import_engine_core = __toModule(require_dist9());
  var import_engines = __toModule(require("@prisma/engines"));
  var import_fetch_engine = __toModule(require_dist8());
  var import_get_platform = __toModule(require_dist4());
  var import_chalk = __toModule(require_source());
  var import_fs = __toModule(require("fs"));
  var import_make_dir = __toModule(require_make_dir());
  var import_p_map = __toModule(require_p_map2());
  var import_path = __toModule(require("path"));
  var import__ = __toModule(require_dist12());
  var import_Generator = __toModule(require_Generator());
  var import_getAllVersions = __toModule(require_getAllVersions());
  var import_pick = __toModule(require_pick());
  var import_predefinedGeneratorResolvers = __toModule(require_predefinedGeneratorResolvers());
  var import_resolveOutput = __toModule(require_resolveOutput());
  var import_extractPreviewFeatures = __toModule(require_extractPreviewFeatures());
  var import_mapPreviewFeatures = __toModule(require_mapPreviewFeatures());
  var import_missingDatasource = __toModule(require_missingDatasource());
  var import_missingGeneratorMessage = __toModule(require_missingGeneratorMessage());
  var import_mongoFeatureFlagMissingMessage = __toModule(require_mongoFeatureFlagMissingMessage());
  var import_parseEnvValue = __toModule(require_parseEnvValue());
  var import_printConfigWarnings = __toModule(require_printConfigWarnings());
  var debug = (0, import_debug.default)("prisma:getGenerators");
  async function getGenerators({
    schemaPath,
    providerAliases: aliases,
    version,
    cliVersion,
    printDownloadProgress,
    baseDir = import_path.default.dirname(schemaPath),
    overrideGenerators,
    skipDownload,
    binaryPathsOverride
  }) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    if (!schemaPath) {
      throw new Error(`schemaPath for getGenerators got invalid value ${schemaPath}`);
    }
    if (!import_fs.default.existsSync(schemaPath)) {
      throw new Error(`${schemaPath} does not exist`);
    }
    const platform = await (0, import_get_platform.getPlatform)();
    const queryEngineBinaryType = (0, import_engines.getCliQueryEngineBinaryType)();
    const queryEngineType = binaryTypeToEngineType(queryEngineBinaryType);
    let prismaPath = binaryPathsOverride == null ? void 0 : binaryPathsOverride[queryEngineType];
    if (version && !prismaPath) {
      const potentialPath = eval(`require('path').join(__dirname, '..')`);
      if (!potentialPath.startsWith("/snapshot/")) {
        const downloadParams = {
          binaries: {
            [queryEngineBinaryType]: potentialPath
          },
          binaryTargets: [platform],
          showProgress: false,
          version,
          skipDownload
        };
        const binaryPathsWithEngineType = await (0, import_fetch_engine.download)(downloadParams);
        prismaPath = binaryPathsWithEngineType[queryEngineBinaryType][platform];
      }
    }
    const datamodel = import_fs.default.readFileSync(schemaPath, "utf-8");
    const config = await (0, import__.getConfig)({
      datamodel,
      datamodelPath: schemaPath,
      prismaPath,
      ignoreEnvVarErrors: true
    });
    if (config.datasources.length === 0) {
      throw new Error(import_missingDatasource.missingDatasource);
    }
    (0, import_printConfigWarnings.printConfigWarnings)(config.warnings);
    const previewFeatures = (0, import_mapPreviewFeatures.mapPreviewFeatures)((0, import_extractPreviewFeatures.extractPreviewFeatures)(config));
    const dmmf = await (0, import__.getDMMF)({
      datamodel,
      datamodelPath: schemaPath,
      prismaPath,
      previewFeatures
    });
    if (dmmf.datamodel.models.length === 0) {
      if (config.datasources.some((d2) => d2.provider === "mongodb")) {
        throw new Error(import_missingGeneratorMessage.missingModelMessageMongoDB);
      }
      throw new Error(import_missingGeneratorMessage.missingModelMessage);
    }
    if (config.datasources.some((d2) => d2.provider === "mongodb") && !previewFeatures.includes("mongoDb")) {
      throw new Error(import_mongoFeatureFlagMissingMessage.mongoFeatureFlagMissingMessage);
    }
    const generatorConfigs = overrideGenerators || config.generators;
    await validateGenerators(generatorConfigs);
    const runningGenerators = [];
    try {
      const generators = await (0, import_p_map.default)(generatorConfigs, async (generator, index) => {
        let generatorPath = (0, import_parseEnvValue.parseEnvValue)(generator.provider);
        let paths;
        const providerValue = (0, import_parseEnvValue.parseEnvValue)(generator.provider);
        if (aliases && aliases[providerValue]) {
          generatorPath = aliases[providerValue].generatorPath;
          paths = aliases[providerValue];
        } else if (import_predefinedGeneratorResolvers.predefinedGeneratorResolvers[providerValue]) {
          paths = await import_predefinedGeneratorResolvers.predefinedGeneratorResolvers[providerValue](baseDir, cliVersion);
          generatorPath = paths.generatorPath;
        }
        const generatorInstance = new import_Generator.Generator(generatorPath, generator, paths == null ? void 0 : paths.isNode);
        await generatorInstance.init();
        if (generator.output) {
          generator.output = {
            value: import_path.default.resolve(baseDir, (0, import_parseEnvValue.parseEnvValue)(generator.output)),
            fromEnvVar: null
          };
          generator.isCustomOutput = true;
        } else if (paths) {
          generator.output = {
            value: paths.outputPath,
            fromEnvVar: null
          };
        } else {
          if (!generatorInstance.manifest || !generatorInstance.manifest.defaultOutput) {
            throw new Error(`Can't resolve output dir for generator ${import_chalk.default.bold(generator.name)} with provider ${import_chalk.default.bold(generator.provider)}.
The generator needs to either define the \`defaultOutput\` path in the manifest or you need to define \`output\` in the datamodel.prisma file.`);
          }
          generator.output = {
            value: await (0, import_resolveOutput.resolveOutput)({
              defaultOutput: generatorInstance.manifest.defaultOutput,
              baseDir
            }),
            fromEnvVar: "null"
          };
        }
        const options = {
          datamodel,
          datasources: config.datasources,
          generator,
          dmmf,
          otherGenerators: skipIndex(generatorConfigs, index),
          schemaPath,
          version: version || import_engines.enginesVersion
        };
        generatorInstance.setOptions(options);
        runningGenerators.push(generatorInstance);
        return generatorInstance;
      }, {
        stopOnError: false
      });
      const generatorProviders = generatorConfigs.map((g) => (0, import_parseEnvValue.parseEnvValue)(g.provider));
      for (const g of generators) {
        if (((_a = g == null ? void 0 : g.manifest) == null ? void 0 : _a.requiresGenerators) && ((_b = g == null ? void 0 : g.manifest) == null ? void 0 : _b.requiresGenerators.length) > 0) {
          for (const neededGenerator of (_c = g == null ? void 0 : g.manifest) == null ? void 0 : _c.requiresGenerators) {
            if (!generatorProviders.includes(neededGenerator)) {
              throw new Error(`Generator "${g.manifest.prettyName}" requires generator "${neededGenerator}", but it is missing in your schema.prisma.
Please add it to your schema.prisma:

generator gen {
  provider = "${neededGenerator}"
}
`);
            }
          }
        }
      }
      const neededVersions = Object.create(null);
      for (const g of generators) {
        if (((_d = g.manifest) == null ? void 0 : _d.requiresEngines) && Array.isArray((_e = g.manifest) == null ? void 0 : _e.requiresEngines) && g.manifest.requiresEngines.length > 0) {
          const neededVersion = getEngineVersionForGenerator(g.manifest, version);
          if (!neededVersions[neededVersion]) {
            neededVersions[neededVersion] = {engines: [], binaryTargets: []};
          }
          for (const engine of (_f = g.manifest) == null ? void 0 : _f.requiresEngines) {
            if (!neededVersions[neededVersion].engines.includes(engine)) {
              neededVersions[neededVersion].engines.push(engine);
            }
          }
          const generatorBinaryTargets = (_h = (_g = g.options) == null ? void 0 : _g.generator) == null ? void 0 : _h.binaryTargets;
          if (generatorBinaryTargets && generatorBinaryTargets.length > 0) {
            const binaryTarget0 = generatorBinaryTargets[0];
            if (binaryTarget0.fromEnvVar !== null) {
              const parsedBinaryTargetsEnvValue = (0, import_parseEnvValue.parseBinaryTargetsEnvValue)(binaryTarget0);
              generatorBinaryTargets.shift();
              if (Array.isArray(parsedBinaryTargetsEnvValue)) {
                for (const platformName of parsedBinaryTargetsEnvValue) {
                  generatorBinaryTargets.push({
                    fromEnvVar: binaryTarget0.fromEnvVar,
                    value: platformName
                  });
                }
              } else {
                generatorBinaryTargets.push({
                  fromEnvVar: binaryTarget0.fromEnvVar,
                  value: parsedBinaryTargetsEnvValue
                });
              }
            }
            for (const binaryTarget of generatorBinaryTargets) {
              if (binaryTarget.value === "native") {
                binaryTarget.value = platform;
              }
              if (!neededVersions[neededVersion].binaryTargets.find((object) => object.value === binaryTarget.value)) {
                neededVersions[neededVersion].binaryTargets.push(binaryTarget);
              }
            }
          }
        }
      }
      debug("neededVersions", JSON.stringify(neededVersions, null, 2));
      const binaryPathsByVersion = await getBinaryPathsByVersion({
        neededVersions,
        platform,
        version,
        printDownloadProgress,
        skipDownload,
        binaryPathsOverride
      });
      for (const generator of generators) {
        if (generator.manifest && generator.manifest.requiresEngines) {
          const engineVersion = getEngineVersionForGenerator(generator.manifest, version);
          const binaryPaths = binaryPathsByVersion[engineVersion];
          const generatorBinaryPaths = (0, import_pick.pick)(binaryPaths, generator.manifest.requiresEngines);
          debug({generatorBinaryPaths});
          generator.setBinaryPaths(generatorBinaryPaths);
          if (engineVersion !== version && generator.options && generator.manifest.requiresEngines.includes(queryEngineType) && generatorBinaryPaths[queryEngineType] && ((_i = generatorBinaryPaths[queryEngineType]) == null ? void 0 : _i[platform])) {
            const customDmmf = await (0, import__.getDMMF)({
              datamodel,
              datamodelPath: schemaPath,
              prismaPath: (_j = generatorBinaryPaths[queryEngineType]) == null ? void 0 : _j[platform],
              previewFeatures
            });
            const options = {...generator.options, dmmf: customDmmf};
            debug("generator.manifest.prettyName", generator.manifest.prettyName);
            debug("options", options);
            debug("options.generator.binaryTargets", options.generator.binaryTargets);
            generator.setOptions(options);
          }
        }
      }
      return generators;
    } catch (e) {
      runningGenerators.forEach((g) => g.stop());
      throw e;
    }
  }
  async function getBinaryPathsByVersion({
    neededVersions,
    platform,
    version,
    printDownloadProgress,
    skipDownload,
    binaryPathsOverride
  }) {
    const binaryPathsByVersion = Object.create(null);
    for (const currentVersion in neededVersions) {
      binaryPathsByVersion[currentVersion] = {};
      const neededVersion = neededVersions[currentVersion];
      if (neededVersion.binaryTargets.length === 0) {
        neededVersion.binaryTargets = [{fromEnvVar: null, value: platform}];
      }
      if (process.env.NETLIFY && !neededVersion.binaryTargets.find((object) => object.value === "rhel-openssl-1.0.x")) {
        neededVersion.binaryTargets.push({
          fromEnvVar: null,
          value: "rhel-openssl-1.0.x"
        });
      }
      let binaryTargetBaseDir = eval(`require('path').join(__dirname, '..')`);
      if (version !== currentVersion) {
        binaryTargetBaseDir = import_path.default.join(binaryTargetBaseDir, `./engines/${currentVersion}/`);
        await (0, import_make_dir.default)(binaryTargetBaseDir).catch((e) => console.error(e));
      }
      const binariesConfig = neededVersion.engines.reduce((acc, curr) => {
        if (!(binaryPathsOverride == null ? void 0 : binaryPathsOverride[curr])) {
          acc[engineTypeToBinaryType(curr)] = binaryTargetBaseDir;
        }
        return acc;
      }, Object.create(null));
      if (Object.values(binariesConfig).length > 0) {
        const platforms2 = neededVersion.binaryTargets.map((binaryTarget) => binaryTarget.value);
        const downloadParams = {
          binaries: binariesConfig,
          binaryTargets: platforms2,
          showProgress: typeof printDownloadProgress === "boolean" ? printDownloadProgress : true,
          version: currentVersion && currentVersion !== "latest" ? currentVersion : import_engines.enginesVersion,
          skipDownload
        };
        const binaryPathsWithEngineType = await (0, import_fetch_engine.download)(downloadParams);
        const binaryPaths = mapKeys(binaryPathsWithEngineType, binaryTypeToEngineType);
        binaryPathsByVersion[currentVersion] = binaryPaths;
      }
      if (binaryPathsOverride) {
        const overrideEngines = Object.keys(binaryPathsOverride);
        const enginesCoveredByOverride = neededVersion.engines.filter((engine) => overrideEngines.includes(engine));
        if (enginesCoveredByOverride.length > 0) {
          for (const engine of enginesCoveredByOverride) {
            const enginePath = binaryPathsOverride[engine];
            binaryPathsByVersion[currentVersion][engine] = {
              [platform]: enginePath
            };
          }
        }
      }
    }
    return binaryPathsByVersion;
  }
  async function getGenerator(options) {
    const generators = await getGenerators(options);
    return generators[0];
  }
  function skipIndex(arr, index) {
    return [...arr.slice(0, index), ...arr.slice(index + 1)];
  }
  var knownBinaryTargets = [...import_get_platform.platforms, "native"];
  var oldToNewBinaryTargetsMapping = {
    "linux-glibc-libssl1.0.1": "debian-openssl-1.0.x",
    "linux-glibc-libssl1.0.2": "debian-openssl-1.0.x",
    "linux-glibc-libssl1.1.0": "debian-openssl1.1.x"
  };
  async function validateGenerators(generators) {
    const platform = await (0, import_get_platform.getPlatform)();
    for (const generator of generators) {
      if ((0, import_parseEnvValue.parseEnvValue)(generator.provider) === "photonjs") {
        throw new Error(`Oops! Photon has been renamed to Prisma Client. Please make the following adjustments:
  1. Rename ${import_chalk.default.red('provider = "photonjs"')} to ${import_chalk.default.green('provider = "prisma-client-js"')} in your ${import_chalk.default.bold("schema.prisma")} file.
  2. Replace your ${import_chalk.default.bold("package.json")}'s ${import_chalk.default.red("@prisma/photon")} dependency to ${import_chalk.default.green("@prisma/client")}
  3. Replace ${import_chalk.default.red("import { Photon } from '@prisma/photon'")} with ${import_chalk.default.green("import { PrismaClient } from '@prisma/client'")} in your code.
  4. Run ${import_chalk.default.green("prisma generate")} again.
      `);
      }
      if (generator.config.platforms) {
        throw new Error(`The \`platforms\` field on the generator definition is deprecated. Please rename it to \`binaryTargets\`.`);
      }
      if (generator.config.pinnedBinaryTargets) {
        throw new Error(`The \`pinnedBinaryTargets\` field on the generator definition is deprecated.
Please use the PRISMA_QUERY_ENGINE_BINARY env var instead to pin the binary target.`);
      }
      if (generator.binaryTargets) {
        const binaryTargets = generator.binaryTargets && generator.binaryTargets.length > 0 ? generator.binaryTargets : [{fromEnvVar: null, value: "native"}];
        const resolvedBinaryTargets = binaryTargets.flatMap((object) => (0, import_parseEnvValue.parseBinaryTargetsEnvValue)(object)).map((p) => p === "native" ? platform : p);
        for (const resolvedBinaryTarget of resolvedBinaryTargets) {
          if (oldToNewBinaryTargetsMapping[resolvedBinaryTarget]) {
            throw new Error(`Binary target ${import_chalk.default.red.bold(resolvedBinaryTarget)} is deprecated. Please use ${import_chalk.default.green.bold(oldToNewBinaryTargetsMapping[resolvedBinaryTarget])} instead.`);
          }
          if (!knownBinaryTargets.includes(resolvedBinaryTarget)) {
            throw new Error(`Unknown binary target ${import_chalk.default.red(resolvedBinaryTarget)} in generator ${import_chalk.default.bold(generator.name)}.
Possible binaryTargets: ${import_chalk.default.greenBright(knownBinaryTargets.join(", "))}`);
          }
        }
        if (!resolvedBinaryTargets.includes(platform)) {
          const originalBinaryTargetsConfig = (0, import_engine_core.getOriginalBinaryTargetsValue)(generator.binaryTargets);
          if (generator) {
            console.log(`${import_chalk.default.yellow("Warning:")} Your current platform \`${import_chalk.default.bold(platform)}\` is not included in your generator's \`binaryTargets\` configuration ${JSON.stringify(originalBinaryTargetsConfig)}.
    To fix it, use this generator config in your ${import_chalk.default.bold("schema.prisma")}:
    ${import_chalk.default.greenBright((0, import_engine_core.printGeneratorConfig)({
              ...generator,
              binaryTargets: (0, import_engine_core.fixBinaryTargets)(generator.binaryTargets, platform)
            }))}
    ${import_chalk.default.gray(`Note, that by providing \`native\`, Prisma Client automatically resolves \`${platform}\`.
    Read more about deploying Prisma Client: ${import_chalk.default.underline("https://github.com/prisma/prisma/blob/main/docs/core/generators/prisma-client-js.md")}`)}
`);
          } else {
            console.log(`${import_chalk.default.yellow("Warning")} The binaryTargets ${JSON.stringify(originalBinaryTargetsConfig)} don't include your local platform ${platform}, which you can also point to with \`native\`.
    In case you want to fix this, you can provide ${import_chalk.default.greenBright(`binaryTargets: ${JSON.stringify(["native", ...binaryTargets || []])}`)} in the schema.prisma file.`);
          }
        }
      }
    }
  }
  function engineTypeToBinaryType(engineType) {
    if (engineType === "introspectionEngine") {
      return import_fetch_engine.BinaryType.introspectionEngine;
    }
    if (engineType === "migrationEngine") {
      return import_fetch_engine.BinaryType.migrationEngine;
    }
    if (engineType === "queryEngine") {
      return import_fetch_engine.BinaryType.queryEngine;
    }
    if (engineType === "libqueryEngine") {
      return import_fetch_engine.BinaryType.libqueryEngine;
    }
    if (engineType === "prismaFmt") {
      return import_fetch_engine.BinaryType.prismaFmt;
    }
    throw new Error(`Could not convert engine type ${engineType}`);
  }
  function binaryTypeToEngineType(binaryType) {
    if (binaryType === import_fetch_engine.BinaryType.introspectionEngine) {
      return "introspectionEngine";
    }
    if (binaryType === import_fetch_engine.BinaryType.migrationEngine) {
      return "migrationEngine";
    }
    if (binaryType === import_fetch_engine.BinaryType.libqueryEngine) {
      return "libqueryEngine";
    }
    if (binaryType === import_fetch_engine.BinaryType.queryEngine) {
      return "queryEngine";
    }
    if (binaryType === import_fetch_engine.BinaryType.prismaFmt) {
      return "prismaFmt";
    }
    throw new Error(`Could not convert binary type ${binaryType}`);
  }
  function mapKeys(obj, mapper) {
    return Object.entries(obj).reduce((acc, [key, value]) => {
      acc[mapper(key)] = value;
      return acc;
    }, {});
  }
  function getEngineVersionForGenerator(manifest, defaultVersion) {
    let neededVersion = manifest.requiresEngineVersion;
    if ((manifest == null ? void 0 : manifest.version) && import_getAllVersions.engineVersions[manifest == null ? void 0 : manifest.version]) {
      neededVersion = import_getAllVersions.engineVersions[manifest == null ? void 0 : manifest.version];
    }
    neededVersion = neededVersion != null ? neededVersion : defaultVersion;
    return neededVersion != null ? neededVersion : "latest";
  }
});

// ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/opts-arg.js
var require_opts_arg = __commonJS((exports2, module2) => {
  var {promisify: promisify4} = require("util");
  var fs9 = require("fs");
  var optsArg = (opts) => {
    if (!opts)
      opts = {mode: 511, fs: fs9};
    else if (typeof opts === "object")
      opts = {mode: 511, fs: fs9, ...opts};
    else if (typeof opts === "number")
      opts = {mode: opts, fs: fs9};
    else if (typeof opts === "string")
      opts = {mode: parseInt(opts, 8), fs: fs9};
    else
      throw new TypeError("invalid options argument");
    opts.mkdir = opts.mkdir || opts.fs.mkdir || fs9.mkdir;
    opts.mkdirAsync = promisify4(opts.mkdir);
    opts.stat = opts.stat || opts.fs.stat || fs9.stat;
    opts.statAsync = promisify4(opts.stat);
    opts.statSync = opts.statSync || opts.fs.statSync || fs9.statSync;
    opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs9.mkdirSync;
    return opts;
  };
  module2.exports = optsArg;
});

// ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/path-arg.js
var require_path_arg = __commonJS((exports2, module2) => {
  var platform = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform;
  var {resolve, parse: parse2} = require("path");
  var pathArg = (path10) => {
    if (/\0/.test(path10)) {
      throw Object.assign(new TypeError("path must be a string without null bytes"), {
        path: path10,
        code: "ERR_INVALID_ARG_VALUE"
      });
    }
    path10 = resolve(path10);
    if (platform === "win32") {
      const badWinChars = /[*|"<>?:]/;
      const {root} = parse2(path10);
      if (badWinChars.test(path10.substr(root.length))) {
        throw Object.assign(new Error("Illegal characters in path."), {
          path: path10,
          code: "EINVAL"
        });
      }
    }
    return path10;
  };
  module2.exports = pathArg;
});

// ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/find-made.js
var require_find_made = __commonJS((exports2, module2) => {
  var {dirname: dirname2} = require("path");
  var findMade = (opts, parent, path10 = void 0) => {
    if (path10 === parent)
      return Promise.resolve();
    return opts.statAsync(parent).then((st) => st.isDirectory() ? path10 : void 0, (er) => er.code === "ENOENT" ? findMade(opts, dirname2(parent), parent) : void 0);
  };
  var findMadeSync = (opts, parent, path10 = void 0) => {
    if (path10 === parent)
      return void 0;
    try {
      return opts.statSync(parent).isDirectory() ? path10 : void 0;
    } catch (er) {
      return er.code === "ENOENT" ? findMadeSync(opts, dirname2(parent), parent) : void 0;
    }
  };
  module2.exports = {findMade, findMadeSync};
});

// ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/mkdirp-manual.js
var require_mkdirp_manual = __commonJS((exports2, module2) => {
  var {dirname: dirname2} = require("path");
  var mkdirpManual = (path10, opts, made) => {
    opts.recursive = false;
    const parent = dirname2(path10);
    if (parent === path10) {
      return opts.mkdirAsync(path10, opts).catch((er) => {
        if (er.code !== "EISDIR")
          throw er;
      });
    }
    return opts.mkdirAsync(path10, opts).then(() => made || path10, (er) => {
      if (er.code === "ENOENT")
        return mkdirpManual(parent, opts).then((made2) => mkdirpManual(path10, opts, made2));
      if (er.code !== "EEXIST" && er.code !== "EROFS")
        throw er;
      return opts.statAsync(path10).then((st) => {
        if (st.isDirectory())
          return made;
        else
          throw er;
      }, () => {
        throw er;
      });
    });
  };
  var mkdirpManualSync = (path10, opts, made) => {
    const parent = dirname2(path10);
    opts.recursive = false;
    if (parent === path10) {
      try {
        return opts.mkdirSync(path10, opts);
      } catch (er) {
        if (er.code !== "EISDIR")
          throw er;
        else
          return;
      }
    }
    try {
      opts.mkdirSync(path10, opts);
      return made || path10;
    } catch (er) {
      if (er.code === "ENOENT")
        return mkdirpManualSync(path10, opts, mkdirpManualSync(parent, opts, made));
      if (er.code !== "EEXIST" && er.code !== "EROFS")
        throw er;
      try {
        if (!opts.statSync(path10).isDirectory())
          throw er;
      } catch (_2) {
        throw er;
      }
    }
  };
  module2.exports = {mkdirpManual, mkdirpManualSync};
});

// ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/mkdirp-native.js
var require_mkdirp_native = __commonJS((exports2, module2) => {
  var {dirname: dirname2} = require("path");
  var {findMade, findMadeSync} = require_find_made();
  var {mkdirpManual, mkdirpManualSync} = require_mkdirp_manual();
  var mkdirpNative = (path10, opts) => {
    opts.recursive = true;
    const parent = dirname2(path10);
    if (parent === path10)
      return opts.mkdirAsync(path10, opts);
    return findMade(opts, path10).then((made) => opts.mkdirAsync(path10, opts).then(() => made).catch((er) => {
      if (er.code === "ENOENT")
        return mkdirpManual(path10, opts);
      else
        throw er;
    }));
  };
  var mkdirpNativeSync = (path10, opts) => {
    opts.recursive = true;
    const parent = dirname2(path10);
    if (parent === path10)
      return opts.mkdirSync(path10, opts);
    const made = findMadeSync(opts, path10);
    try {
      opts.mkdirSync(path10, opts);
      return made;
    } catch (er) {
      if (er.code === "ENOENT")
        return mkdirpManualSync(path10, opts);
      else
        throw er;
    }
  };
  module2.exports = {mkdirpNative, mkdirpNativeSync};
});

// ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/use-native.js
var require_use_native = __commonJS((exports2, module2) => {
  var fs9 = require("fs");
  var version = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version;
  var versArr = version.replace(/^v/, "").split(".");
  var hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12;
  var useNative = !hasNative ? () => false : (opts) => opts.mkdir === fs9.mkdir;
  var useNativeSync = !hasNative ? () => false : (opts) => opts.mkdirSync === fs9.mkdirSync;
  module2.exports = {useNative, useNativeSync};
});

// ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/index.js
var require_mkdirp = __commonJS((exports2, module2) => {
  var optsArg = require_opts_arg();
  var pathArg = require_path_arg();
  var {mkdirpNative, mkdirpNativeSync} = require_mkdirp_native();
  var {mkdirpManual, mkdirpManualSync} = require_mkdirp_manual();
  var {useNative, useNativeSync} = require_use_native();
  var mkdirp = (path10, opts) => {
    path10 = pathArg(path10);
    opts = optsArg(opts);
    return useNative(opts) ? mkdirpNative(path10, opts) : mkdirpManual(path10, opts);
  };
  var mkdirpSync = (path10, opts) => {
    path10 = pathArg(path10);
    opts = optsArg(opts);
    return useNativeSync(opts) ? mkdirpNativeSync(path10, opts) : mkdirpManualSync(path10, opts);
  };
  mkdirp.sync = mkdirpSync;
  mkdirp.native = (path10, opts) => mkdirpNative(pathArg(path10), optsArg(opts));
  mkdirp.manual = (path10, opts) => mkdirpManual(pathArg(path10), optsArg(opts));
  mkdirp.nativeSync = (path10, opts) => mkdirpNativeSync(pathArg(path10), optsArg(opts));
  mkdirp.manualSync = (path10, opts) => mkdirpManualSync(pathArg(path10), optsArg(opts));
  module2.exports = mkdirp;
});

// ../../node_modules/.pnpm/prettysize@2.0.0/node_modules/prettysize/index.js
var require_prettysize = __commonJS((exports2, module2) => {
  "use strict";
  var sizes = [
    "Bytes",
    "kB",
    "MB",
    "GB",
    "TB",
    "PB",
    "EB"
  ];
  module2.exports = function(size, nospace, one, places, numOnly) {
    if (typeof nospace === "object") {
      var opts = nospace;
      nospace = opts.nospace;
      one = opts.one;
      places = opts.places || 1;
      numOnly = opts.numOnly;
    } else {
      places = places || 1;
    }
    var mysize;
    for (var id = 0; id < sizes.length; ++id) {
      var unit = sizes[id];
      if (one) {
        unit = unit.slice(0, 1);
      }
      var s2 = Math.pow(1024, id);
      var fixed;
      if (size >= s2) {
        fixed = String((size / s2).toFixed(places));
        if (fixed.indexOf(".0") === fixed.length - 2) {
          fixed = fixed.slice(0, -2);
        }
        mysize = fixed + (nospace ? "" : " ") + unit;
      }
    }
    if (!mysize) {
      var _unit = one ? sizes[0].slice(0, 1) : sizes[0];
      mysize = "0" + (nospace ? "" : " ") + _unit;
    }
    if (numOnly) {
      mysize = Number.parseFloat(mysize);
    }
    return mysize;
  };
});

// ../../node_modules/.pnpm/@timsuchanek+sleep-promise@8.0.1/node_modules/@timsuchanek/sleep-promise/build/cjs.js
var require_cjs = __commonJS((exports2, module2) => {
  "use strict";
  var cachedSetTimeout = setTimeout;
  function createSleepPromise(a, b) {
    var c = b.useCachedSetTimeout, d2 = c ? cachedSetTimeout : setTimeout;
    return new Promise(function(b2) {
      d2(b2, a);
    });
  }
  function sleep(a) {
    function b(a2) {
      return e.then(function() {
        return a2;
      });
    }
    var c = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : {}, d2 = c.useCachedSetTimeout, e = createSleepPromise(a, {useCachedSetTimeout: d2});
    return b.then = function() {
      return e.then.apply(e, arguments);
    }, b.catch = Promise.resolve().catch, b;
  }
  module2.exports = sleep;
});

// ../../node_modules/.pnpm/@timsuchanek+copy@1.4.5/node_modules/@timsuchanek/copy/index.js
var require_copy = __commonJS((exports2, module2) => {
  var fs9 = require("fs");
  var path10 = require("path");
  var {promisify: promisify4} = require("util");
  var readFile3 = promisify4(fs9.readFile);
  var writeFile2 = promisify4(fs9.writeFile);
  var mkdir2 = promisify4(fs9.mkdir);
  var mkdirp = require_mkdirp();
  var pretty = require_prettysize();
  var sleep = require_cjs();
  var assert = require("assert");
  var Copy = class {
    constructor(options = {}) {
      this.from = path10.normalize(options.from);
      this.to = path10.normalize(options.to);
      this.recursive = options.recursive || false;
      this.overwrite = options.overwrite || false;
      this.overwriteMismatches = options.overwriteMismatches || false;
      this.verbose = options.verbose || false;
      this.json = options.json || false;
      this.ignoreErrors = options.ignoreErrors || false;
      this.parallelJobs = options.parallelJobs || 1;
      this.stateFile = options.state;
      this.stateFrequency = options.stateFrequency || 100;
      this.fns = {
        stat: promisify4(options.stat || fs9.stat),
        readdir: promisify4(options.readdir || fs9.readdir),
        copyFile: promisify4(options.copyFile || fs9.copyFile)
      };
      this.stateCatchUp = 0;
      this.state = {
        wip: [],
        counts: {
          directories: 0,
          files: 0,
          copies: 0
        }
      };
      this.pending = [];
      this.errors = [];
      assert.equal(typeof this.from, "string", "from should be a string");
      assert.equal(typeof this.to, "string", "to should be a string");
      assert.equal(typeof this.parallelJobs, "number", "parallelJobs should be a number");
      assert.equal(typeof this.stateFrequency, "number", "stateFrequency should be a number");
      assert.equal(typeof this.fns.stat, "function", "stat should be a function");
      assert.equal(typeof this.fns.readdir, "function", "readdir should be a function");
      assert.equal(typeof this.fns.copyFile, "function", "copyFile should be a function");
    }
    async start() {
      try {
        await this.loadState();
        if ((await this.fns.stat(this.from)).isDirectory()) {
          await mkdirp(this.to);
        } else {
          const basedir = path10.dirname(this.to);
          await mkdirp(basedir);
        }
        await this.copy(this.from, this.to);
        while (this.pending.length > 0) {
          await sleep(10);
        }
        await this.processJobErrors();
        await this.saveState();
        if (this.state.wip.length) {
          throw new Error("Incomplete `wip` found. Copy likely incomplete.");
        }
        return this.state;
      } catch (err) {
        err.state = this.state;
        throw err;
      }
    }
    async loadState() {
      if (!this.stateFile)
        return;
      try {
        await this.fns.stat(this.stateFile);
        this.state = JSON.parse(await readFile3(this.stateFile));
        this.stateCatchUp = this.state.wip.length;
      } catch (err) {
        if (err.code !== "ENOENT") {
          throw err;
        }
      }
    }
    async saveState() {
      if (!this.stateFile)
        return;
      await writeFile2(this.stateFile, JSON.stringify(this.state, null, 2));
    }
    async processJobErrors() {
      let err = this.errors.shift();
      while (err) {
        this.handleError(err);
        err = this.errors.shift();
      }
    }
    async copy(from, to) {
      let catchingUp = this.stateCatchUp > 0;
      if (catchingUp) {
        if (this.state.wip.includes(from)) {
          this.stateCatchUp -= 1;
        } else if (!this.state.wip.some((wipFile) => wipFile.startsWith(from))) {
          return;
        }
      }
      try {
        await this.processJobErrors();
        const fromStat = await this.fns.stat(from);
        const isDirectory = fromStat.isDirectory();
        if (isDirectory && this.recursive) {
          await this.copyDirectory(from, to);
        } else if (!isDirectory) {
          if (!catchingUp) {
            this.state.wip.push(from);
          }
          await this.queueAction(() => this.copyFile(from, to, fromStat));
          if (this.state.counts.files % this.stateFrequency === 0) {
            await this.saveState();
          }
        }
      } catch (err) {
        this.handleError(err);
      }
    }
    async copyDirectory(from, to) {
      try {
        try {
          await this.fns.stat(to);
        } catch (err) {
          if (err.code === "ENOENT") {
            await mkdir2(to);
          } else {
            throw err;
          }
        }
        const files = await this.fns.readdir(from);
        for (let file of files) {
          await this.copy(path10.join(from, file), path10.join(to, file));
        }
      } catch (err) {
        this.handleError(err);
      } finally {
        this.state.counts.directories++;
      }
    }
    async queueAction(asyncFunction) {
      while (this.pending.length >= this.parallelJobs) {
        await sleep(10);
      }
      const action = async () => {
        try {
          await asyncFunction();
        } finally {
          this.pending.splice(this.pending.indexOf(asyncFunction), 1);
        }
      };
      this.pending.push(action);
      action().catch((err) => this.errors.push(err));
    }
    async copyFile(from, to, fromStat) {
      this.logCopyAction(to, "start");
      try {
        const toStat = await this.fns.stat(to);
        if (this.overwrite) {
          await this.doCopy(from, to, fromStat);
        } else if (this.overwriteMismatches) {
          if (fromStat.size !== toStat.size || fromStat.mtimeMs > toStat.mtimeMs) {
            this.logCopyAction(to, "stats mismatch", {
              fromStat: {
                size: fromStat.size,
                mtimeMs: fromStat.mtimeMs
              },
              toStat: {
                size: toStat.size,
                mtimeMs: toStat.mtimeMs
              }
            });
            await this.doCopy(from, to, fromStat);
          } else {
            this.logCopyAction(to, "skipped, stats match");
          }
        } else {
          this.logCopyAction(to, "skipped");
        }
        this.removeWip(from);
      } catch (err) {
        if (err.code === "ENOENT") {
          await this.doCopy(from, to, fromStat);
          this.removeWip(from);
        } else {
          throw err;
        }
      }
      this.state.counts.files++;
    }
    async doCopy(from, to, fromStat) {
      try {
        if (this.verbose || this.json) {
          const start = Date.now();
          await this.fns.copyFile(from, to);
          const speed = fromStat.size / ((Date.now() - start) / 1e3);
          this.logCopyAction(to, "complete", {speed});
        } else {
          await this.fns.copyFile(from, to);
        }
        this.state.counts.copies++;
      } catch (err) {
        this.logCopyAction(to, "error");
        this.handleError(err);
      }
    }
    removeWip(from) {
      let wipIndex = this.state.wip.indexOf(from);
      if (wipIndex >= 0) {
        this.state.wip.splice(wipIndex, 1);
      }
    }
    log(message) {
      if (this.verbose || this.json) {
        if (this.json === "pretty") {
          console.log(JSON.stringify({message, state: this.state}, null, 2) + "\n");
        } else if (this.json) {
          console.log(JSON.stringify({message, state: this.state}));
        } else {
          console.log(`Count: ${this.state.counts.directories}d ${this.state.counts.files}f Jobs: ${this.pending.length} ${message}`);
        }
      }
    }
    logCopyAction(file, action, extra) {
      if (this.json) {
        let message = {file, action};
        if (extra) {
          Object.assign(message, extra);
        }
        this.log(message);
      } else {
        let message = `Copying: '${file}' (${action})`;
        if (extra && extra.speed !== void 0) {
          message += ` (${pretty(extra.speed)}/s)`;
        }
        this.log(message);
      }
    }
    handleError(err) {
      if (this.ignoreErrors) {
        console.error(err);
      } else {
        throw err;
      }
    }
  };
  module2.exports = (options) => {
    const copy = new Copy(options);
    return copy.start();
  };
  module2.exports.Copy = Copy;
});

// ../../node_modules/.pnpm/shell-quote@1.7.2/node_modules/shell-quote/index.js
var require_shell_quote = __commonJS((exports2) => {
  exports2.quote = function(xs) {
    return xs.map(function(s2) {
      if (s2 && typeof s2 === "object") {
        return s2.op.replace(/(.)/g, "\\$1");
      } else if (/["\s]/.test(s2) && !/'/.test(s2)) {
        return "'" + s2.replace(/(['\\])/g, "\\$1") + "'";
      } else if (/["'\s]/.test(s2)) {
        return '"' + s2.replace(/(["\\$`!])/g, "\\$1") + '"';
      } else {
        return String(s2).replace(/([A-z]:)?([#!"$&'()*,:;<=>?@\[\\\]^`{|}])/g, "$1\\$2");
      }
    }).join(" ");
  };
  var CONTROL = "(?:" + [
    "\\|\\|",
    "\\&\\&",
    ";;",
    "\\|\\&",
    "\\<\\(",
    ">>",
    ">\\&",
    "[&;()|<>]"
  ].join("|") + ")";
  var META = "|&;()<> \\t";
  var BAREWORD = `(\\\\['"` + META + `]|[^\\s'"` + META + "])+";
  var SINGLE_QUOTE = '"((\\\\"|[^"])*?)"';
  var DOUBLE_QUOTE = "'((\\\\'|[^'])*?)'";
  var TOKEN = "";
  for (var i = 0; i < 4; i++) {
    TOKEN += (Math.pow(16, 8) * Math.random()).toString(16);
  }
  exports2.parse = function(s2, env2, opts) {
    var mapped = parse2(s2, env2, opts);
    if (typeof env2 !== "function")
      return mapped;
    return mapped.reduce(function(acc, s3) {
      if (typeof s3 === "object")
        return acc.concat(s3);
      var xs = s3.split(RegExp("(" + TOKEN + ".*?" + TOKEN + ")", "g"));
      if (xs.length === 1)
        return acc.concat(xs[0]);
      return acc.concat(xs.filter(Boolean).map(function(x) {
        if (RegExp("^" + TOKEN).test(x)) {
          return JSON.parse(x.split(TOKEN)[1]);
        } else
          return x;
      }));
    }, []);
  };
  function parse2(s2, env2, opts) {
    var chunker = new RegExp([
      "(" + CONTROL + ")",
      "(" + BAREWORD + "|" + SINGLE_QUOTE + "|" + DOUBLE_QUOTE + ")*"
    ].join("|"), "g");
    var match = s2.match(chunker).filter(Boolean);
    var commented = false;
    if (!match)
      return [];
    if (!env2)
      env2 = {};
    if (!opts)
      opts = {};
    return match.map(function(s3, j) {
      if (commented) {
        return;
      }
      if (RegExp("^" + CONTROL + "$").test(s3)) {
        return {op: s3};
      }
      var SQ = "'";
      var DQ = '"';
      var DS = "$";
      var BS = opts.escape || "\\";
      var quote = false;
      var esc = false;
      var out = "";
      var isGlob = false;
      for (var i2 = 0, len = s3.length; i2 < len; i2++) {
        var c = s3.charAt(i2);
        isGlob = isGlob || !quote && (c === "*" || c === "?");
        if (esc) {
          out += c;
          esc = false;
        } else if (quote) {
          if (c === quote) {
            quote = false;
          } else if (quote == SQ) {
            out += c;
          } else {
            if (c === BS) {
              i2 += 1;
              c = s3.charAt(i2);
              if (c === DQ || c === BS || c === DS) {
                out += c;
              } else {
                out += BS + c;
              }
            } else if (c === DS) {
              out += parseEnvVar();
            } else {
              out += c;
            }
          }
        } else if (c === DQ || c === SQ) {
          quote = c;
        } else if (RegExp("^" + CONTROL + "$").test(c)) {
          return {op: s3};
        } else if (RegExp("^#$").test(c)) {
          commented = true;
          if (out.length) {
            return [out, {comment: s3.slice(i2 + 1) + match.slice(j + 1).join(" ")}];
          }
          return [{comment: s3.slice(i2 + 1) + match.slice(j + 1).join(" ")}];
        } else if (c === BS) {
          esc = true;
        } else if (c === DS) {
          out += parseEnvVar();
        } else
          out += c;
      }
      if (isGlob)
        return {op: "glob", pattern: out};
      return out;
      function parseEnvVar() {
        i2 += 1;
        var varend, varname;
        if (s3.charAt(i2) === "{") {
          i2 += 1;
          if (s3.charAt(i2) === "}") {
            throw new Error("Bad substitution: " + s3.substr(i2 - 2, 3));
          }
          varend = s3.indexOf("}", i2);
          if (varend < 0) {
            throw new Error("Bad substitution: " + s3.substr(i2));
          }
          varname = s3.substr(i2, varend - i2);
          i2 = varend;
        } else if (/[*@#?$!_\-]/.test(s3.charAt(i2))) {
          varname = s3.charAt(i2);
          i2 += 1;
        } else {
          varend = s3.substr(i2).match(/[^\w\d_]/);
          if (!varend) {
            varname = s3.substr(i2);
            i2 = s3.length;
          } else {
            varname = s3.substr(i2, varend.index);
            i2 += varend.index - 1;
          }
        }
        return getVar(null, "", varname);
      }
    }).reduce(function(prev, arg10) {
      if (arg10 === void 0) {
        return prev;
      }
      return prev.concat(arg10);
    }, []);
    function getVar(_2, pre, key) {
      var r = typeof env2 === "function" ? env2(key) : env2[key];
      if (r === void 0 && key != "")
        r = "";
      else if (r === void 0)
        r = "$";
      if (typeof r === "object") {
        return pre + TOKEN + JSON.stringify(r) + TOKEN;
      } else
        return pre + r;
    }
  }
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/high-level-opt.js
var require_high_level_opt = __commonJS((exports2, module2) => {
  "use strict";
  var argmap = new Map([
    ["C", "cwd"],
    ["f", "file"],
    ["z", "gzip"],
    ["P", "preservePaths"],
    ["U", "unlink"],
    ["strip-components", "strip"],
    ["stripComponents", "strip"],
    ["keep-newer", "newer"],
    ["keepNewer", "newer"],
    ["keep-newer-files", "newer"],
    ["keepNewerFiles", "newer"],
    ["k", "keep"],
    ["keep-existing", "keep"],
    ["keepExisting", "keep"],
    ["m", "noMtime"],
    ["no-mtime", "noMtime"],
    ["p", "preserveOwner"],
    ["L", "follow"],
    ["h", "follow"]
  ]);
  module2.exports = (opt) => opt ? Object.keys(opt).map((k) => [
    argmap.has(k) ? argmap.get(k) : k,
    opt[k]
  ]).reduce((set, kv) => (set[kv[0]] = kv[1], set), Object.create(null)) : {};
});

// ../../node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/iterator.js
var require_iterator = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(Yallist) {
    Yallist.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head; walker; walker = walker.next) {
        yield walker.value;
      }
    };
  };
});

// ../../node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/yallist.js
var require_yallist = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Yallist;
  Yallist.Node = Node;
  Yallist.create = Yallist;
  function Yallist(list) {
    var self2 = this;
    if (!(self2 instanceof Yallist)) {
      self2 = new Yallist();
    }
    self2.tail = null;
    self2.head = null;
    self2.length = 0;
    if (list && typeof list.forEach === "function") {
      list.forEach(function(item) {
        self2.push(item);
      });
    } else if (arguments.length > 0) {
      for (var i = 0, l = arguments.length; i < l; i++) {
        self2.push(arguments[i]);
      }
    }
    return self2;
  }
  Yallist.prototype.removeNode = function(node) {
    if (node.list !== this) {
      throw new Error("removing node which does not belong to this list");
    }
    var next = node.next;
    var prev = node.prev;
    if (next) {
      next.prev = prev;
    }
    if (prev) {
      prev.next = next;
    }
    if (node === this.head) {
      this.head = next;
    }
    if (node === this.tail) {
      this.tail = prev;
    }
    node.list.length--;
    node.next = null;
    node.prev = null;
    node.list = null;
    return next;
  };
  Yallist.prototype.unshiftNode = function(node) {
    if (node === this.head) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var head = this.head;
    node.list = this;
    node.next = head;
    if (head) {
      head.prev = node;
    }
    this.head = node;
    if (!this.tail) {
      this.tail = node;
    }
    this.length++;
  };
  Yallist.prototype.pushNode = function(node) {
    if (node === this.tail) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var tail = this.tail;
    node.list = this;
    node.prev = tail;
    if (tail) {
      tail.next = node;
    }
    this.tail = node;
    if (!this.head) {
      this.head = node;
    }
    this.length++;
  };
  Yallist.prototype.push = function() {
    for (var i = 0, l = arguments.length; i < l; i++) {
      push(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.unshift = function() {
    for (var i = 0, l = arguments.length; i < l; i++) {
      unshift(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.pop = function() {
    if (!this.tail) {
      return void 0;
    }
    var res = this.tail.value;
    this.tail = this.tail.prev;
    if (this.tail) {
      this.tail.next = null;
    } else {
      this.head = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.shift = function() {
    if (!this.head) {
      return void 0;
    }
    var res = this.head.value;
    this.head = this.head.next;
    if (this.head) {
      this.head.prev = null;
    } else {
      this.tail = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.forEach = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.head, i = 0; walker !== null; i++) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.next;
    }
  };
  Yallist.prototype.forEachReverse = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.prev;
    }
  };
  Yallist.prototype.get = function(n) {
    for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
      walker = walker.next;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.getReverse = function(n) {
    for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
      walker = walker.prev;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.map = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for (var walker = this.head; walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.next;
    }
    return res;
  };
  Yallist.prototype.mapReverse = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for (var walker = this.tail; walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.prev;
    }
    return res;
  };
  Yallist.prototype.reduce = function(fn, initial) {
    var acc;
    var walker = this.head;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.head) {
      walker = this.head.next;
      acc = this.head.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = 0; walker !== null; i++) {
      acc = fn(acc, walker.value, i);
      walker = walker.next;
    }
    return acc;
  };
  Yallist.prototype.reduceReverse = function(fn, initial) {
    var acc;
    var walker = this.tail;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.tail) {
      walker = this.tail.prev;
      acc = this.tail.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = this.length - 1; walker !== null; i--) {
      acc = fn(acc, walker.value, i);
      walker = walker.prev;
    }
    return acc;
  };
  Yallist.prototype.toArray = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.head; walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.next;
    }
    return arr;
  };
  Yallist.prototype.toArrayReverse = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.tail; walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.prev;
    }
    return arr;
  };
  Yallist.prototype.slice = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist();
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
      walker = walker.next;
    }
    for (; walker !== null && i < to; i++, walker = walker.next) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.sliceReverse = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist();
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
      walker = walker.prev;
    }
    for (; walker !== null && i > from; i--, walker = walker.prev) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
    if (start > this.length) {
      start = this.length - 1;
    }
    if (start < 0) {
      start = this.length + start;
    }
    for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
      walker = walker.next;
    }
    var ret = [];
    for (var i = 0; walker && i < deleteCount; i++) {
      ret.push(walker.value);
      walker = this.removeNode(walker);
    }
    if (walker === null) {
      walker = this.tail;
    }
    if (walker !== this.head && walker !== this.tail) {
      walker = walker.prev;
    }
    for (var i = 0; i < nodes.length; i++) {
      walker = insert(this, walker, nodes[i]);
    }
    return ret;
  };
  Yallist.prototype.reverse = function() {
    var head = this.head;
    var tail = this.tail;
    for (var walker = head; walker !== null; walker = walker.prev) {
      var p = walker.prev;
      walker.prev = walker.next;
      walker.next = p;
    }
    this.head = tail;
    this.tail = head;
    return this;
  };
  function insert(self2, node, value) {
    var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
    if (inserted.next === null) {
      self2.tail = inserted;
    }
    if (inserted.prev === null) {
      self2.head = inserted;
    }
    self2.length++;
    return inserted;
  }
  function push(self2, item) {
    self2.tail = new Node(item, self2.tail, null, self2);
    if (!self2.head) {
      self2.head = self2.tail;
    }
    self2.length++;
  }
  function unshift(self2, item) {
    self2.head = new Node(item, null, self2.head, self2);
    if (!self2.tail) {
      self2.tail = self2.head;
    }
    self2.length++;
  }
  function Node(value, prev, next, list) {
    if (!(this instanceof Node)) {
      return new Node(value, prev, next, list);
    }
    this.list = list;
    this.value = value;
    if (prev) {
      prev.next = this;
      this.prev = prev;
    } else {
      this.prev = null;
    }
    if (next) {
      next.prev = this;
      this.next = next;
    } else {
      this.next = null;
    }
  }
  try {
    require_iterator()(Yallist);
  } catch (er) {
  }
});

// ../../node_modules/.pnpm/minipass@3.1.3/node_modules/minipass/index.js
var require_minipass = __commonJS((exports2, module2) => {
  "use strict";
  var EE = require("events");
  var Stream = require("stream");
  var Yallist = require_yallist();
  var SD = require("string_decoder").StringDecoder;
  var EOF = Symbol("EOF");
  var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
  var EMITTED_END = Symbol("emittedEnd");
  var EMITTING_END = Symbol("emittingEnd");
  var CLOSED = Symbol("closed");
  var READ = Symbol("read");
  var FLUSH = Symbol("flush");
  var FLUSHCHUNK = Symbol("flushChunk");
  var ENCODING = Symbol("encoding");
  var DECODER = Symbol("decoder");
  var FLOWING = Symbol("flowing");
  var PAUSED = Symbol("paused");
  var RESUME = Symbol("resume");
  var BUFFERLENGTH = Symbol("bufferLength");
  var BUFFERPUSH = Symbol("bufferPush");
  var BUFFERSHIFT = Symbol("bufferShift");
  var OBJECTMODE = Symbol("objectMode");
  var DESTROYED = Symbol("destroyed");
  var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
  var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
  var ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
  var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
  var isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
  var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
  module2.exports = class Minipass extends Stream {
    constructor(options) {
      super();
      this[FLOWING] = false;
      this[PAUSED] = false;
      this.pipes = new Yallist();
      this.buffer = new Yallist();
      this[OBJECTMODE] = options && options.objectMode || false;
      if (this[OBJECTMODE])
        this[ENCODING] = null;
      else
        this[ENCODING] = options && options.encoding || null;
      if (this[ENCODING] === "buffer")
        this[ENCODING] = null;
      this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
      this[EOF] = false;
      this[EMITTED_END] = false;
      this[EMITTING_END] = false;
      this[CLOSED] = false;
      this.writable = true;
      this.readable = true;
      this[BUFFERLENGTH] = 0;
      this[DESTROYED] = false;
    }
    get bufferLength() {
      return this[BUFFERLENGTH];
    }
    get encoding() {
      return this[ENCODING];
    }
    set encoding(enc) {
      if (this[OBJECTMODE])
        throw new Error("cannot set encoding in objectMode");
      if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
        throw new Error("cannot change encoding");
      if (this[ENCODING] !== enc) {
        this[DECODER] = enc ? new SD(enc) : null;
        if (this.buffer.length)
          this.buffer = this.buffer.map((chunk) => this[DECODER].write(chunk));
      }
      this[ENCODING] = enc;
    }
    setEncoding(enc) {
      this.encoding = enc;
    }
    get objectMode() {
      return this[OBJECTMODE];
    }
    set objectMode(om) {
      this[OBJECTMODE] = this[OBJECTMODE] || !!om;
    }
    write(chunk, encoding, cb) {
      if (this[EOF])
        throw new Error("write after end");
      if (this[DESTROYED]) {
        this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), {code: "ERR_STREAM_DESTROYED"}));
        return true;
      }
      if (typeof encoding === "function")
        cb = encoding, encoding = "utf8";
      if (!encoding)
        encoding = "utf8";
      if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
        if (isArrayBufferView(chunk))
          chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
        else if (isArrayBuffer(chunk))
          chunk = Buffer.from(chunk);
        else if (typeof chunk !== "string")
          this.objectMode = true;
      }
      if (!this.objectMode && !chunk.length) {
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          cb();
        return this.flowing;
      }
      if (typeof chunk === "string" && !this[OBJECTMODE] && !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
        chunk = Buffer.from(chunk, encoding);
      }
      if (Buffer.isBuffer(chunk) && this[ENCODING])
        chunk = this[DECODER].write(chunk);
      if (this.flowing) {
        if (this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        this.emit("data", chunk);
      } else
        this[BUFFERPUSH](chunk);
      if (this[BUFFERLENGTH] !== 0)
        this.emit("readable");
      if (cb)
        cb();
      return this.flowing;
    }
    read(n) {
      if (this[DESTROYED])
        return null;
      try {
        if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH])
          return null;
        if (this[OBJECTMODE])
          n = null;
        if (this.buffer.length > 1 && !this[OBJECTMODE]) {
          if (this.encoding)
            this.buffer = new Yallist([
              Array.from(this.buffer).join("")
            ]);
          else
            this.buffer = new Yallist([
              Buffer.concat(Array.from(this.buffer), this[BUFFERLENGTH])
            ]);
        }
        return this[READ](n || null, this.buffer.head.value);
      } finally {
        this[MAYBE_EMIT_END]();
      }
    }
    [READ](n, chunk) {
      if (n === chunk.length || n === null)
        this[BUFFERSHIFT]();
      else {
        this.buffer.head.value = chunk.slice(n);
        chunk = chunk.slice(0, n);
        this[BUFFERLENGTH] -= n;
      }
      this.emit("data", chunk);
      if (!this.buffer.length && !this[EOF])
        this.emit("drain");
      return chunk;
    }
    end(chunk, encoding, cb) {
      if (typeof chunk === "function")
        cb = chunk, chunk = null;
      if (typeof encoding === "function")
        cb = encoding, encoding = "utf8";
      if (chunk)
        this.write(chunk, encoding);
      if (cb)
        this.once("end", cb);
      this[EOF] = true;
      this.writable = false;
      if (this.flowing || !this[PAUSED])
        this[MAYBE_EMIT_END]();
      return this;
    }
    [RESUME]() {
      if (this[DESTROYED])
        return;
      this[PAUSED] = false;
      this[FLOWING] = true;
      this.emit("resume");
      if (this.buffer.length)
        this[FLUSH]();
      else if (this[EOF])
        this[MAYBE_EMIT_END]();
      else
        this.emit("drain");
    }
    resume() {
      return this[RESUME]();
    }
    pause() {
      this[FLOWING] = false;
      this[PAUSED] = true;
    }
    get destroyed() {
      return this[DESTROYED];
    }
    get flowing() {
      return this[FLOWING];
    }
    get paused() {
      return this[PAUSED];
    }
    [BUFFERPUSH](chunk) {
      if (this[OBJECTMODE])
        this[BUFFERLENGTH] += 1;
      else
        this[BUFFERLENGTH] += chunk.length;
      return this.buffer.push(chunk);
    }
    [BUFFERSHIFT]() {
      if (this.buffer.length) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] -= 1;
        else
          this[BUFFERLENGTH] -= this.buffer.head.value.length;
      }
      return this.buffer.shift();
    }
    [FLUSH](noDrain) {
      do {
      } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));
      if (!noDrain && !this.buffer.length && !this[EOF])
        this.emit("drain");
    }
    [FLUSHCHUNK](chunk) {
      return chunk ? (this.emit("data", chunk), this.flowing) : false;
    }
    pipe(dest, opts) {
      if (this[DESTROYED])
        return;
      const ended = this[EMITTED_END];
      opts = opts || {};
      if (dest === process.stdout || dest === process.stderr)
        opts.end = false;
      else
        opts.end = opts.end !== false;
      const p = {dest, opts, ondrain: (_2) => this[RESUME]()};
      this.pipes.push(p);
      dest.on("drain", p.ondrain);
      this[RESUME]();
      if (ended && p.opts.end)
        p.dest.end();
      return dest;
    }
    addListener(ev, fn) {
      return this.on(ev, fn);
    }
    on(ev, fn) {
      try {
        return super.on(ev, fn);
      } finally {
        if (ev === "data" && !this.pipes.length && !this.flowing)
          this[RESUME]();
        else if (isEndish(ev) && this[EMITTED_END]) {
          super.emit(ev);
          this.removeAllListeners(ev);
        }
      }
    }
    get emittedEnd() {
      return this[EMITTED_END];
    }
    [MAYBE_EMIT_END]() {
      if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this.buffer.length === 0 && this[EOF]) {
        this[EMITTING_END] = true;
        this.emit("end");
        this.emit("prefinish");
        this.emit("finish");
        if (this[CLOSED])
          this.emit("close");
        this[EMITTING_END] = false;
      }
    }
    emit(ev, data) {
      if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
        return;
      else if (ev === "data") {
        if (!data)
          return;
        if (this.pipes.length)
          this.pipes.forEach((p) => p.dest.write(data) === false && this.pause());
      } else if (ev === "end") {
        if (this[EMITTED_END] === true)
          return;
        this[EMITTED_END] = true;
        this.readable = false;
        if (this[DECODER]) {
          data = this[DECODER].end();
          if (data) {
            this.pipes.forEach((p) => p.dest.write(data));
            super.emit("data", data);
          }
        }
        this.pipes.forEach((p) => {
          p.dest.removeListener("drain", p.ondrain);
          if (p.opts.end)
            p.dest.end();
        });
      } else if (ev === "close") {
        this[CLOSED] = true;
        if (!this[EMITTED_END] && !this[DESTROYED])
          return;
      }
      const args2 = new Array(arguments.length);
      args2[0] = ev;
      args2[1] = data;
      if (arguments.length > 2) {
        for (let i = 2; i < arguments.length; i++) {
          args2[i] = arguments[i];
        }
      }
      try {
        return super.emit.apply(this, args2);
      } finally {
        if (!isEndish(ev))
          this[MAYBE_EMIT_END]();
        else
          this.removeAllListeners(ev);
      }
    }
    collect() {
      const buf = [];
      if (!this[OBJECTMODE])
        buf.dataLength = 0;
      const p = this.promise();
      this.on("data", (c) => {
        buf.push(c);
        if (!this[OBJECTMODE])
          buf.dataLength += c.length;
      });
      return p.then(() => buf);
    }
    concat() {
      return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then((buf) => this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength));
    }
    promise() {
      return new Promise((resolve, reject) => {
        this.on(DESTROYED, () => reject(new Error("stream destroyed")));
        this.on("end", () => resolve());
        this.on("error", (er) => reject(er));
      });
    }
    [ASYNCITERATOR]() {
      const next = () => {
        const res = this.read();
        if (res !== null)
          return Promise.resolve({done: false, value: res});
        if (this[EOF])
          return Promise.resolve({done: true});
        let resolve = null;
        let reject = null;
        const onerr = (er) => {
          this.removeListener("data", ondata);
          this.removeListener("end", onend);
          reject(er);
        };
        const ondata = (value) => {
          this.removeListener("error", onerr);
          this.removeListener("end", onend);
          this.pause();
          resolve({value, done: !!this[EOF]});
        };
        const onend = () => {
          this.removeListener("error", onerr);
          this.removeListener("data", ondata);
          resolve({done: true});
        };
        const ondestroy = () => onerr(new Error("stream destroyed"));
        return new Promise((res2, rej) => {
          reject = rej;
          resolve = res2;
          this.once(DESTROYED, ondestroy);
          this.once("error", onerr);
          this.once("end", onend);
          this.once("data", ondata);
        });
      };
      return {next};
    }
    [ITERATOR]() {
      const next = () => {
        const value = this.read();
        const done = value === null;
        return {value, done};
      };
      return {next};
    }
    destroy(er) {
      if (this[DESTROYED]) {
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      this[DESTROYED] = true;
      this.buffer = new Yallist();
      this[BUFFERLENGTH] = 0;
      if (typeof this.close === "function" && !this[CLOSED])
        this.close();
      if (er)
        this.emit("error", er);
      else
        this.emit(DESTROYED);
      return this;
    }
    static isStream(s2) {
      return !!s2 && (s2 instanceof Minipass || s2 instanceof Stream || s2 instanceof EE && (typeof s2.pipe === "function" || typeof s2.write === "function" && typeof s2.end === "function"));
    }
  };
});

// ../../node_modules/.pnpm/minizlib@2.1.2/node_modules/minizlib/constants.js
var require_constants4 = __commonJS((exports2, module2) => {
  var realZlibConstants = require("zlib").constants || {ZLIB_VERNUM: 4736};
  module2.exports = Object.freeze(Object.assign(Object.create(null), {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    Z_VERSION_ERROR: -6,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    DEFLATE: 1,
    INFLATE: 2,
    GZIP: 3,
    GUNZIP: 4,
    DEFLATERAW: 5,
    INFLATERAW: 6,
    UNZIP: 7,
    BROTLI_DECODE: 8,
    BROTLI_ENCODE: 9,
    Z_MIN_WINDOWBITS: 8,
    Z_MAX_WINDOWBITS: 15,
    Z_DEFAULT_WINDOWBITS: 15,
    Z_MIN_CHUNK: 64,
    Z_MAX_CHUNK: Infinity,
    Z_DEFAULT_CHUNK: 16384,
    Z_MIN_MEMLEVEL: 1,
    Z_MAX_MEMLEVEL: 9,
    Z_DEFAULT_MEMLEVEL: 8,
    Z_MIN_LEVEL: -1,
    Z_MAX_LEVEL: 9,
    Z_DEFAULT_LEVEL: -1,
    BROTLI_OPERATION_PROCESS: 0,
    BROTLI_OPERATION_FLUSH: 1,
    BROTLI_OPERATION_FINISH: 2,
    BROTLI_OPERATION_EMIT_METADATA: 3,
    BROTLI_MODE_GENERIC: 0,
    BROTLI_MODE_TEXT: 1,
    BROTLI_MODE_FONT: 2,
    BROTLI_DEFAULT_MODE: 0,
    BROTLI_MIN_QUALITY: 0,
    BROTLI_MAX_QUALITY: 11,
    BROTLI_DEFAULT_QUALITY: 11,
    BROTLI_MIN_WINDOW_BITS: 10,
    BROTLI_MAX_WINDOW_BITS: 24,
    BROTLI_LARGE_MAX_WINDOW_BITS: 30,
    BROTLI_DEFAULT_WINDOW: 22,
    BROTLI_MIN_INPUT_BLOCK_BITS: 16,
    BROTLI_MAX_INPUT_BLOCK_BITS: 24,
    BROTLI_PARAM_MODE: 0,
    BROTLI_PARAM_QUALITY: 1,
    BROTLI_PARAM_LGWIN: 2,
    BROTLI_PARAM_LGBLOCK: 3,
    BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
    BROTLI_PARAM_SIZE_HINT: 5,
    BROTLI_PARAM_LARGE_WINDOW: 6,
    BROTLI_PARAM_NPOSTFIX: 7,
    BROTLI_PARAM_NDIRECT: 8,
    BROTLI_DECODER_RESULT_ERROR: 0,
    BROTLI_DECODER_RESULT_SUCCESS: 1,
    BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
    BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
    BROTLI_DECODER_NO_ERROR: 0,
    BROTLI_DECODER_SUCCESS: 1,
    BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
    BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
    BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
    BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
    BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
    BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
    BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
    BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
    BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
    BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
    BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
    BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
    BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
    BROTLI_DECODER_ERROR_UNREACHABLE: -31
  }, realZlibConstants));
});

// ../../node_modules/.pnpm/minizlib@2.1.2/node_modules/minizlib/index.js
var require_minizlib = __commonJS((exports2) => {
  "use strict";
  var assert = require("assert");
  var Buffer2 = require("buffer").Buffer;
  var realZlib = require("zlib");
  var constants = exports2.constants = require_constants4();
  var Minipass = require_minipass();
  var OriginalBufferConcat = Buffer2.concat;
  var _superWrite = Symbol("_superWrite");
  var ZlibError = class extends Error {
    constructor(err) {
      super("zlib: " + err.message);
      this.code = err.code;
      this.errno = err.errno;
      if (!this.code)
        this.code = "ZLIB_ERROR";
      this.message = "zlib: " + err.message;
      Error.captureStackTrace(this, this.constructor);
    }
    get name() {
      return "ZlibError";
    }
  };
  var _opts = Symbol("opts");
  var _flushFlag = Symbol("flushFlag");
  var _finishFlushFlag = Symbol("finishFlushFlag");
  var _fullFlushFlag = Symbol("fullFlushFlag");
  var _handle = Symbol("handle");
  var _onError = Symbol("onError");
  var _sawError = Symbol("sawError");
  var _level = Symbol("level");
  var _strategy = Symbol("strategy");
  var _ended = Symbol("ended");
  var _defaultFullFlush = Symbol("_defaultFullFlush");
  var ZlibBase = class extends Minipass {
    constructor(opts, mode) {
      if (!opts || typeof opts !== "object")
        throw new TypeError("invalid options for ZlibBase constructor");
      super(opts);
      this[_sawError] = false;
      this[_ended] = false;
      this[_opts] = opts;
      this[_flushFlag] = opts.flush;
      this[_finishFlushFlag] = opts.finishFlush;
      try {
        this[_handle] = new realZlib[mode](opts);
      } catch (er) {
        throw new ZlibError(er);
      }
      this[_onError] = (err) => {
        if (this[_sawError])
          return;
        this[_sawError] = true;
        this.close();
        this.emit("error", err);
      };
      this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));
      this.once("end", () => this.close);
    }
    close() {
      if (this[_handle]) {
        this[_handle].close();
        this[_handle] = null;
        this.emit("close");
      }
    }
    reset() {
      if (!this[_sawError]) {
        assert(this[_handle], "zlib binding closed");
        return this[_handle].reset();
      }
    }
    flush(flushFlag) {
      if (this.ended)
        return;
      if (typeof flushFlag !== "number")
        flushFlag = this[_fullFlushFlag];
      this.write(Object.assign(Buffer2.alloc(0), {[_flushFlag]: flushFlag}));
    }
    end(chunk, encoding, cb) {
      if (chunk)
        this.write(chunk, encoding);
      this.flush(this[_finishFlushFlag]);
      this[_ended] = true;
      return super.end(null, null, cb);
    }
    get ended() {
      return this[_ended];
    }
    write(chunk, encoding, cb) {
      if (typeof encoding === "function")
        cb = encoding, encoding = "utf8";
      if (typeof chunk === "string")
        chunk = Buffer2.from(chunk, encoding);
      if (this[_sawError])
        return;
      assert(this[_handle], "zlib binding closed");
      const nativeHandle = this[_handle]._handle;
      const originalNativeClose = nativeHandle.close;
      nativeHandle.close = () => {
      };
      const originalClose = this[_handle].close;
      this[_handle].close = () => {
      };
      Buffer2.concat = (args2) => args2;
      let result;
      try {
        const flushFlag = typeof chunk[_flushFlag] === "number" ? chunk[_flushFlag] : this[_flushFlag];
        result = this[_handle]._processChunk(chunk, flushFlag);
        Buffer2.concat = OriginalBufferConcat;
      } catch (err) {
        Buffer2.concat = OriginalBufferConcat;
        this[_onError](new ZlibError(err));
      } finally {
        if (this[_handle]) {
          this[_handle]._handle = nativeHandle;
          nativeHandle.close = originalNativeClose;
          this[_handle].close = originalClose;
          this[_handle].removeAllListeners("error");
        }
      }
      if (this[_handle])
        this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));
      let writeReturn;
      if (result) {
        if (Array.isArray(result) && result.length > 0) {
          writeReturn = this[_superWrite](Buffer2.from(result[0]));
          for (let i = 1; i < result.length; i++) {
            writeReturn = this[_superWrite](result[i]);
          }
        } else {
          writeReturn = this[_superWrite](Buffer2.from(result));
        }
      }
      if (cb)
        cb();
      return writeReturn;
    }
    [_superWrite](data) {
      return super.write(data);
    }
  };
  var Zlib = class extends ZlibBase {
    constructor(opts, mode) {
      opts = opts || {};
      opts.flush = opts.flush || constants.Z_NO_FLUSH;
      opts.finishFlush = opts.finishFlush || constants.Z_FINISH;
      super(opts, mode);
      this[_fullFlushFlag] = constants.Z_FULL_FLUSH;
      this[_level] = opts.level;
      this[_strategy] = opts.strategy;
    }
    params(level, strategy) {
      if (this[_sawError])
        return;
      if (!this[_handle])
        throw new Error("cannot switch params when binding is closed");
      if (!this[_handle].params)
        throw new Error("not supported in this implementation");
      if (this[_level] !== level || this[_strategy] !== strategy) {
        this.flush(constants.Z_SYNC_FLUSH);
        assert(this[_handle], "zlib binding closed");
        const origFlush = this[_handle].flush;
        this[_handle].flush = (flushFlag, cb) => {
          this.flush(flushFlag);
          cb();
        };
        try {
          this[_handle].params(level, strategy);
        } finally {
          this[_handle].flush = origFlush;
        }
        if (this[_handle]) {
          this[_level] = level;
          this[_strategy] = strategy;
        }
      }
    }
  };
  var Deflate = class extends Zlib {
    constructor(opts) {
      super(opts, "Deflate");
    }
  };
  var Inflate = class extends Zlib {
    constructor(opts) {
      super(opts, "Inflate");
    }
  };
  var _portable = Symbol("_portable");
  var Gzip = class extends Zlib {
    constructor(opts) {
      super(opts, "Gzip");
      this[_portable] = opts && !!opts.portable;
    }
    [_superWrite](data) {
      if (!this[_portable])
        return super[_superWrite](data);
      this[_portable] = false;
      data[9] = 255;
      return super[_superWrite](data);
    }
  };
  var Gunzip = class extends Zlib {
    constructor(opts) {
      super(opts, "Gunzip");
    }
  };
  var DeflateRaw = class extends Zlib {
    constructor(opts) {
      super(opts, "DeflateRaw");
    }
  };
  var InflateRaw = class extends Zlib {
    constructor(opts) {
      super(opts, "InflateRaw");
    }
  };
  var Unzip = class extends Zlib {
    constructor(opts) {
      super(opts, "Unzip");
    }
  };
  var Brotli = class extends ZlibBase {
    constructor(opts, mode) {
      opts = opts || {};
      opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS;
      opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH;
      super(opts, mode);
      this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH;
    }
  };
  var BrotliCompress = class extends Brotli {
    constructor(opts) {
      super(opts, "BrotliCompress");
    }
  };
  var BrotliDecompress = class extends Brotli {
    constructor(opts) {
      super(opts, "BrotliDecompress");
    }
  };
  exports2.Deflate = Deflate;
  exports2.Inflate = Inflate;
  exports2.Gzip = Gzip;
  exports2.Gunzip = Gunzip;
  exports2.DeflateRaw = DeflateRaw;
  exports2.InflateRaw = InflateRaw;
  exports2.Unzip = Unzip;
  if (typeof realZlib.BrotliCompress === "function") {
    exports2.BrotliCompress = BrotliCompress;
    exports2.BrotliDecompress = BrotliDecompress;
  } else {
    exports2.BrotliCompress = exports2.BrotliDecompress = class {
      constructor() {
        throw new Error("Brotli is not supported in this version of Node.js");
      }
    };
  }
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/normalize-windows-path.js
var require_normalize_windows_path = __commonJS((exports2, module2) => {
  var platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
  module2.exports = platform !== "win32" ? (p) => p : (p) => p && p.replace(/\\/g, "/");
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/read-entry.js
var require_read_entry = __commonJS((exports2, module2) => {
  "use strict";
  var MiniPass = require_minipass();
  var normPath = require_normalize_windows_path();
  var SLURP = Symbol("slurp");
  module2.exports = class ReadEntry extends MiniPass {
    constructor(header, ex, gex) {
      super();
      this.pause();
      this.extended = ex;
      this.globalExtended = gex;
      this.header = header;
      this.startBlockSize = 512 * Math.ceil(header.size / 512);
      this.blockRemain = this.startBlockSize;
      this.remain = header.size;
      this.type = header.type;
      this.meta = false;
      this.ignore = false;
      switch (this.type) {
        case "File":
        case "OldFile":
        case "Link":
        case "SymbolicLink":
        case "CharacterDevice":
        case "BlockDevice":
        case "Directory":
        case "FIFO":
        case "ContiguousFile":
        case "GNUDumpDir":
          break;
        case "NextFileHasLongLinkpath":
        case "NextFileHasLongPath":
        case "OldGnuLongPath":
        case "GlobalExtendedHeader":
        case "ExtendedHeader":
        case "OldExtendedHeader":
          this.meta = true;
          break;
        default:
          this.ignore = true;
      }
      this.path = normPath(header.path);
      this.mode = header.mode;
      if (this.mode)
        this.mode = this.mode & 4095;
      this.uid = header.uid;
      this.gid = header.gid;
      this.uname = header.uname;
      this.gname = header.gname;
      this.size = header.size;
      this.mtime = header.mtime;
      this.atime = header.atime;
      this.ctime = header.ctime;
      this.linkpath = normPath(header.linkpath);
      this.uname = header.uname;
      this.gname = header.gname;
      if (ex)
        this[SLURP](ex);
      if (gex)
        this[SLURP](gex, true);
    }
    write(data) {
      const writeLen = data.length;
      if (writeLen > this.blockRemain)
        throw new Error("writing more to entry than is appropriate");
      const r = this.remain;
      const br = this.blockRemain;
      this.remain = Math.max(0, r - writeLen);
      this.blockRemain = Math.max(0, br - writeLen);
      if (this.ignore)
        return true;
      if (r >= writeLen)
        return super.write(data);
      return super.write(data.slice(0, r));
    }
    [SLURP](ex, global2) {
      for (const k in ex) {
        if (ex[k] !== null && ex[k] !== void 0 && !(global2 && k === "path"))
          this[k] = k === "path" || k === "linkpath" ? normPath(ex[k]) : ex[k];
      }
    }
  };
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/types.js
var require_types3 = __commonJS((exports2) => {
  "use strict";
  exports2.name = new Map([
    ["0", "File"],
    ["", "OldFile"],
    ["1", "Link"],
    ["2", "SymbolicLink"],
    ["3", "CharacterDevice"],
    ["4", "BlockDevice"],
    ["5", "Directory"],
    ["6", "FIFO"],
    ["7", "ContiguousFile"],
    ["g", "GlobalExtendedHeader"],
    ["x", "ExtendedHeader"],
    ["A", "SolarisACL"],
    ["D", "GNUDumpDir"],
    ["I", "Inode"],
    ["K", "NextFileHasLongLinkpath"],
    ["L", "NextFileHasLongPath"],
    ["M", "ContinuationFile"],
    ["N", "OldGnuLongPath"],
    ["S", "SparseFile"],
    ["V", "TapeVolumeHeader"],
    ["X", "OldExtendedHeader"]
  ]);
  exports2.code = new Map(Array.from(exports2.name).map((kv) => [kv[1], kv[0]]));
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/large-numbers.js
var require_large_numbers = __commonJS((exports2, module2) => {
  "use strict";
  var encode = (num, buf) => {
    if (!Number.isSafeInteger(num))
      throw Error("cannot encode number outside of javascript safe integer range");
    else if (num < 0)
      encodeNegative(num, buf);
    else
      encodePositive(num, buf);
    return buf;
  };
  var encodePositive = (num, buf) => {
    buf[0] = 128;
    for (var i = buf.length; i > 1; i--) {
      buf[i - 1] = num & 255;
      num = Math.floor(num / 256);
    }
  };
  var encodeNegative = (num, buf) => {
    buf[0] = 255;
    var flipped = false;
    num = num * -1;
    for (var i = buf.length; i > 1; i--) {
      var byte = num & 255;
      num = Math.floor(num / 256);
      if (flipped)
        buf[i - 1] = onesComp(byte);
      else if (byte === 0)
        buf[i - 1] = 0;
      else {
        flipped = true;
        buf[i - 1] = twosComp(byte);
      }
    }
  };
  var parse2 = (buf) => {
    const pre = buf[0];
    const value = pre === 128 ? pos(buf.slice(1, buf.length)) : pre === 255 ? twos(buf) : null;
    if (value === null)
      throw Error("invalid base256 encoding");
    if (!Number.isSafeInteger(value))
      throw Error("parsed number outside of javascript safe integer range");
    return value;
  };
  var twos = (buf) => {
    var len = buf.length;
    var sum = 0;
    var flipped = false;
    for (var i = len - 1; i > -1; i--) {
      var byte = buf[i];
      var f;
      if (flipped)
        f = onesComp(byte);
      else if (byte === 0)
        f = byte;
      else {
        flipped = true;
        f = twosComp(byte);
      }
      if (f !== 0)
        sum -= f * Math.pow(256, len - i - 1);
    }
    return sum;
  };
  var pos = (buf) => {
    var len = buf.length;
    var sum = 0;
    for (var i = len - 1; i > -1; i--) {
      var byte = buf[i];
      if (byte !== 0)
        sum += byte * Math.pow(256, len - i - 1);
    }
    return sum;
  };
  var onesComp = (byte) => (255 ^ byte) & 255;
  var twosComp = (byte) => (255 ^ byte) + 1 & 255;
  module2.exports = {
    encode,
    parse: parse2
  };
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/header.js
var require_header = __commonJS((exports2, module2) => {
  "use strict";
  var types = require_types3();
  var pathModule = require("path").posix;
  var large = require_large_numbers();
  var SLURP = Symbol("slurp");
  var TYPE = Symbol("type");
  var Header = class {
    constructor(data, off, ex, gex) {
      this.cksumValid = false;
      this.needPax = false;
      this.nullBlock = false;
      this.block = null;
      this.path = null;
      this.mode = null;
      this.uid = null;
      this.gid = null;
      this.size = null;
      this.mtime = null;
      this.cksum = null;
      this[TYPE] = "0";
      this.linkpath = null;
      this.uname = null;
      this.gname = null;
      this.devmaj = 0;
      this.devmin = 0;
      this.atime = null;
      this.ctime = null;
      if (Buffer.isBuffer(data))
        this.decode(data, off || 0, ex, gex);
      else if (data)
        this.set(data);
    }
    decode(buf, off, ex, gex) {
      if (!off)
        off = 0;
      if (!buf || !(buf.length >= off + 512))
        throw new Error("need 512 bytes for header");
      this.path = decString(buf, off, 100);
      this.mode = decNumber(buf, off + 100, 8);
      this.uid = decNumber(buf, off + 108, 8);
      this.gid = decNumber(buf, off + 116, 8);
      this.size = decNumber(buf, off + 124, 12);
      this.mtime = decDate(buf, off + 136, 12);
      this.cksum = decNumber(buf, off + 148, 12);
      this[SLURP](ex);
      this[SLURP](gex, true);
      this[TYPE] = decString(buf, off + 156, 1);
      if (this[TYPE] === "")
        this[TYPE] = "0";
      if (this[TYPE] === "0" && this.path.substr(-1) === "/")
        this[TYPE] = "5";
      if (this[TYPE] === "5")
        this.size = 0;
      this.linkpath = decString(buf, off + 157, 100);
      if (buf.slice(off + 257, off + 265).toString() === "ustar\x0000") {
        this.uname = decString(buf, off + 265, 32);
        this.gname = decString(buf, off + 297, 32);
        this.devmaj = decNumber(buf, off + 329, 8);
        this.devmin = decNumber(buf, off + 337, 8);
        if (buf[off + 475] !== 0) {
          const prefix = decString(buf, off + 345, 155);
          this.path = prefix + "/" + this.path;
        } else {
          const prefix = decString(buf, off + 345, 130);
          if (prefix)
            this.path = prefix + "/" + this.path;
          this.atime = decDate(buf, off + 476, 12);
          this.ctime = decDate(buf, off + 488, 12);
        }
      }
      let sum = 8 * 32;
      for (let i = off; i < off + 148; i++)
        sum += buf[i];
      for (let i = off + 156; i < off + 512; i++)
        sum += buf[i];
      this.cksumValid = sum === this.cksum;
      if (this.cksum === null && sum === 8 * 32)
        this.nullBlock = true;
    }
    [SLURP](ex, global2) {
      for (const k in ex) {
        if (ex[k] !== null && ex[k] !== void 0 && !(global2 && k === "path"))
          this[k] = ex[k];
      }
    }
    encode(buf, off) {
      if (!buf) {
        buf = this.block = Buffer.alloc(512);
        off = 0;
      }
      if (!off)
        off = 0;
      if (!(buf.length >= off + 512))
        throw new Error("need 512 bytes for header");
      const prefixSize = this.ctime || this.atime ? 130 : 155;
      const split = splitPrefix(this.path || "", prefixSize);
      const path10 = split[0];
      const prefix = split[1];
      this.needPax = split[2];
      this.needPax = encString(buf, off, 100, path10) || this.needPax;
      this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax;
      this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax;
      this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax;
      this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax;
      this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax;
      buf[off + 156] = this[TYPE].charCodeAt(0);
      this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax;
      buf.write("ustar\x0000", off + 257, 8);
      this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax;
      this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax;
      this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax;
      this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax;
      this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax;
      if (buf[off + 475] !== 0)
        this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax;
      else {
        this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax;
        this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax;
        this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax;
      }
      let sum = 8 * 32;
      for (let i = off; i < off + 148; i++)
        sum += buf[i];
      for (let i = off + 156; i < off + 512; i++)
        sum += buf[i];
      this.cksum = sum;
      encNumber(buf, off + 148, 8, this.cksum);
      this.cksumValid = true;
      return this.needPax;
    }
    set(data) {
      for (const i in data) {
        if (data[i] !== null && data[i] !== void 0)
          this[i] = data[i];
      }
    }
    get type() {
      return types.name.get(this[TYPE]) || this[TYPE];
    }
    get typeKey() {
      return this[TYPE];
    }
    set type(type) {
      if (types.code.has(type))
        this[TYPE] = types.code.get(type);
      else
        this[TYPE] = type;
    }
  };
  var splitPrefix = (p, prefixSize) => {
    const pathSize = 100;
    let pp = p;
    let prefix = "";
    let ret;
    const root = pathModule.parse(p).root || ".";
    if (Buffer.byteLength(pp) < pathSize)
      ret = [pp, prefix, false];
    else {
      prefix = pathModule.dirname(pp);
      pp = pathModule.basename(pp);
      do {
        if (Buffer.byteLength(pp) <= pathSize && Buffer.byteLength(prefix) <= prefixSize)
          ret = [pp, prefix, false];
        else if (Buffer.byteLength(pp) > pathSize && Buffer.byteLength(prefix) <= prefixSize)
          ret = [pp.substr(0, pathSize - 1), prefix, true];
        else {
          pp = pathModule.join(pathModule.basename(prefix), pp);
          prefix = pathModule.dirname(prefix);
        }
      } while (prefix !== root && !ret);
      if (!ret)
        ret = [p.substr(0, pathSize - 1), "", true];
    }
    return ret;
  };
  var decString = (buf, off, size) => buf.slice(off, off + size).toString("utf8").replace(/\0.*/, "");
  var decDate = (buf, off, size) => numToDate(decNumber(buf, off, size));
  var numToDate = (num) => num === null ? null : new Date(num * 1e3);
  var decNumber = (buf, off, size) => buf[off] & 128 ? large.parse(buf.slice(off, off + size)) : decSmallNumber(buf, off, size);
  var nanNull = (value) => isNaN(value) ? null : value;
  var decSmallNumber = (buf, off, size) => nanNull(parseInt(buf.slice(off, off + size).toString("utf8").replace(/\0.*$/, "").trim(), 8));
  var MAXNUM = {
    12: 8589934591,
    8: 2097151
  };
  var encNumber = (buf, off, size, number) => number === null ? false : number > MAXNUM[size] || number < 0 ? (large.encode(number, buf.slice(off, off + size)), true) : (encSmallNumber(buf, off, size, number), false);
  var encSmallNumber = (buf, off, size, number) => buf.write(octalString(number, size), off, size, "ascii");
  var octalString = (number, size) => padOctal(Math.floor(number).toString(8), size);
  var padOctal = (string, size) => (string.length === size - 1 ? string : new Array(size - string.length - 1).join("0") + string + " ") + "\0";
  var encDate = (buf, off, size, date) => date === null ? false : encNumber(buf, off, size, date.getTime() / 1e3);
  var NULLS = new Array(156).join("\0");
  var encString = (buf, off, size, string) => string === null ? false : (buf.write(string + NULLS, off, size, "utf8"), string.length !== Buffer.byteLength(string) || string.length > size);
  module2.exports = Header;
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/pax.js
var require_pax = __commonJS((exports2, module2) => {
  "use strict";
  var Header = require_header();
  var path10 = require("path");
  var Pax = class {
    constructor(obj, global2) {
      this.atime = obj.atime || null;
      this.charset = obj.charset || null;
      this.comment = obj.comment || null;
      this.ctime = obj.ctime || null;
      this.gid = obj.gid || null;
      this.gname = obj.gname || null;
      this.linkpath = obj.linkpath || null;
      this.mtime = obj.mtime || null;
      this.path = obj.path || null;
      this.size = obj.size || null;
      this.uid = obj.uid || null;
      this.uname = obj.uname || null;
      this.dev = obj.dev || null;
      this.ino = obj.ino || null;
      this.nlink = obj.nlink || null;
      this.global = global2 || false;
    }
    encode() {
      const body = this.encodeBody();
      if (body === "")
        return null;
      const bodyLen = Buffer.byteLength(body);
      const bufLen = 512 * Math.ceil(1 + bodyLen / 512);
      const buf = Buffer.allocUnsafe(bufLen);
      for (let i = 0; i < 512; i++)
        buf[i] = 0;
      new Header({
        path: ("PaxHeader/" + path10.basename(this.path)).slice(0, 99),
        mode: this.mode || 420,
        uid: this.uid || null,
        gid: this.gid || null,
        size: bodyLen,
        mtime: this.mtime || null,
        type: this.global ? "GlobalExtendedHeader" : "ExtendedHeader",
        linkpath: "",
        uname: this.uname || "",
        gname: this.gname || "",
        devmaj: 0,
        devmin: 0,
        atime: this.atime || null,
        ctime: this.ctime || null
      }).encode(buf);
      buf.write(body, 512, bodyLen, "utf8");
      for (let i = bodyLen + 512; i < buf.length; i++)
        buf[i] = 0;
      return buf;
    }
    encodeBody() {
      return this.encodeField("path") + this.encodeField("ctime") + this.encodeField("atime") + this.encodeField("dev") + this.encodeField("ino") + this.encodeField("nlink") + this.encodeField("charset") + this.encodeField("comment") + this.encodeField("gid") + this.encodeField("gname") + this.encodeField("linkpath") + this.encodeField("mtime") + this.encodeField("size") + this.encodeField("uid") + this.encodeField("uname");
    }
    encodeField(field) {
      if (this[field] === null || this[field] === void 0)
        return "";
      const v = this[field] instanceof Date ? this[field].getTime() / 1e3 : this[field];
      const s2 = " " + (field === "dev" || field === "ino" || field === "nlink" ? "SCHILY." : "") + field + "=" + v + "\n";
      const byteLen = Buffer.byteLength(s2);
      let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1;
      if (byteLen + digits >= Math.pow(10, digits))
        digits += 1;
      const len = digits + byteLen;
      return len + s2;
    }
  };
  Pax.parse = (string, ex, g) => new Pax(merge(parseKV(string), ex), g);
  var merge = (a, b) => b ? Object.keys(a).reduce((s2, k) => (s2[k] = a[k], s2), b) : a;
  var parseKV = (string) => string.replace(/\n$/, "").split("\n").reduce(parseKVLine, Object.create(null));
  var parseKVLine = (set, line) => {
    const n = parseInt(line, 10);
    if (n !== Buffer.byteLength(line) + 1)
      return set;
    line = line.substr((n + " ").length);
    const kv = line.split("=");
    const k = kv.shift().replace(/^SCHILY\.(dev|ino|nlink)/, "$1");
    if (!k)
      return set;
    const v = kv.join("=");
    set[k] = /^([A-Z]+\.)?([mac]|birth|creation)time$/.test(k) ? new Date(v * 1e3) : /^[0-9]+$/.test(v) ? +v : v;
    return set;
  };
  module2.exports = Pax;
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/strip-trailing-slashes.js
var require_strip_trailing_slashes = __commonJS((exports2, module2) => {
  var batchStrings = [
    "/".repeat(1024),
    "/".repeat(512),
    "/".repeat(256),
    "/".repeat(128),
    "/".repeat(64),
    "/".repeat(32),
    "/".repeat(16),
    "/".repeat(8),
    "/".repeat(4),
    "/".repeat(2),
    "/"
  ];
  module2.exports = (str) => {
    for (const s2 of batchStrings) {
      while (str.length >= s2.length && str.slice(-1 * s2.length) === s2)
        str = str.slice(0, -1 * s2.length);
    }
    return str;
  };
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/warn-mixin.js
var require_warn_mixin = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (Base) => class extends Base {
    warn(code, message, data = {}) {
      if (this.file)
        data.file = this.file;
      if (this.cwd)
        data.cwd = this.cwd;
      data.code = message instanceof Error && message.code || code;
      data.tarCode = code;
      if (!this.strict && data.recoverable !== false) {
        if (message instanceof Error) {
          data = Object.assign(message, data);
          message = message.message;
        }
        this.emit("warn", data.tarCode, message, data);
      } else if (message instanceof Error)
        this.emit("error", Object.assign(message, data));
      else
        this.emit("error", Object.assign(new Error(`${code}: ${message}`), data));
    }
  };
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/winchars.js
var require_winchars = __commonJS((exports2, module2) => {
  "use strict";
  var raw = [
    "|",
    "<",
    ">",
    "?",
    ":"
  ];
  var win = raw.map((char) => String.fromCharCode(61440 + char.charCodeAt(0)));
  var toWin = new Map(raw.map((char, i) => [char, win[i]]));
  var toRaw = new Map(win.map((char, i) => [char, raw[i]]));
  module2.exports = {
    encode: (s2) => raw.reduce((s3, c) => s3.split(c).join(toWin.get(c)), s2),
    decode: (s2) => win.reduce((s3, c) => s3.split(c).join(toRaw.get(c)), s2)
  };
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/strip-absolute-path.js
var require_strip_absolute_path = __commonJS((exports2, module2) => {
  var {isAbsolute, parse: parse2} = require("path").win32;
  module2.exports = (path10) => {
    let r = "";
    while (isAbsolute(path10)) {
      const root = path10.charAt(0) === "/" ? "/" : parse2(path10).root;
      path10 = path10.substr(root.length);
      r += root;
    }
    return [r, path10];
  };
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/mode-fix.js
var require_mode_fix = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (mode, isDir, portable) => {
    mode &= 4095;
    if (portable)
      mode = (mode | 384) & ~18;
    if (isDir) {
      if (mode & 256)
        mode |= 64;
      if (mode & 32)
        mode |= 8;
      if (mode & 4)
        mode |= 1;
    }
    return mode;
  };
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/write-entry.js
var require_write_entry = __commonJS((exports2, module2) => {
  "use strict";
  var MiniPass = require_minipass();
  var Pax = require_pax();
  var Header = require_header();
  var fs9 = require("fs");
  var path10 = require("path");
  var normPath = require_normalize_windows_path();
  var stripSlash = require_strip_trailing_slashes();
  var prefixPath = (path11, prefix) => {
    if (!prefix)
      return normPath(path11);
    path11 = normPath(path11).replace(/^\.(\/|$)/, "");
    return stripSlash(prefix) + "/" + path11;
  };
  var maxReadSize = 16 * 1024 * 1024;
  var PROCESS = Symbol("process");
  var FILE = Symbol("file");
  var DIRECTORY = Symbol("directory");
  var SYMLINK = Symbol("symlink");
  var HARDLINK = Symbol("hardlink");
  var HEADER = Symbol("header");
  var READ = Symbol("read");
  var LSTAT = Symbol("lstat");
  var ONLSTAT = Symbol("onlstat");
  var ONREAD = Symbol("onread");
  var ONREADLINK = Symbol("onreadlink");
  var OPENFILE = Symbol("openfile");
  var ONOPENFILE = Symbol("onopenfile");
  var CLOSE = Symbol("close");
  var MODE = Symbol("mode");
  var AWAITDRAIN = Symbol("awaitDrain");
  var ONDRAIN = Symbol("ondrain");
  var PREFIX = Symbol("prefix");
  var HAD_ERROR = Symbol("hadError");
  var warner = require_warn_mixin();
  var winchars = require_winchars();
  var stripAbsolutePath = require_strip_absolute_path();
  var modeFix = require_mode_fix();
  var WriteEntry = warner(class WriteEntry extends MiniPass {
    constructor(p, opt) {
      opt = opt || {};
      super(opt);
      if (typeof p !== "string")
        throw new TypeError("path is required");
      this.path = normPath(p);
      this.portable = !!opt.portable;
      this.myuid = process.getuid && process.getuid() || 0;
      this.myuser = process.env.USER || "";
      this.maxReadSize = opt.maxReadSize || maxReadSize;
      this.linkCache = opt.linkCache || new Map();
      this.statCache = opt.statCache || new Map();
      this.preservePaths = !!opt.preservePaths;
      this.cwd = normPath(opt.cwd || process.cwd());
      this.strict = !!opt.strict;
      this.noPax = !!opt.noPax;
      this.noMtime = !!opt.noMtime;
      this.mtime = opt.mtime || null;
      this.prefix = opt.prefix ? normPath(opt.prefix) : null;
      this.fd = null;
      this.blockLen = null;
      this.blockRemain = null;
      this.buf = null;
      this.offset = null;
      this.length = null;
      this.pos = null;
      this.remain = null;
      if (typeof opt.onwarn === "function")
        this.on("warn", opt.onwarn);
      let pathWarn = false;
      if (!this.preservePaths) {
        const [root, stripped] = stripAbsolutePath(this.path);
        if (root) {
          this.path = stripped;
          pathWarn = root;
        }
      }
      this.win32 = !!opt.win32 || process.platform === "win32";
      if (this.win32) {
        this.path = winchars.decode(this.path.replace(/\\/g, "/"));
        p = p.replace(/\\/g, "/");
      }
      this.absolute = normPath(opt.absolute || path10.resolve(this.cwd, p));
      if (this.path === "")
        this.path = "./";
      if (pathWarn) {
        this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
          entry: this,
          path: pathWarn + this.path
        });
      }
      if (this.statCache.has(this.absolute))
        this[ONLSTAT](this.statCache.get(this.absolute));
      else
        this[LSTAT]();
    }
    emit(ev, ...data) {
      if (ev === "error")
        this[HAD_ERROR] = true;
      return super.emit(ev, ...data);
    }
    [LSTAT]() {
      fs9.lstat(this.absolute, (er, stat) => {
        if (er)
          return this.emit("error", er);
        this[ONLSTAT](stat);
      });
    }
    [ONLSTAT](stat) {
      this.statCache.set(this.absolute, stat);
      this.stat = stat;
      if (!stat.isFile())
        stat.size = 0;
      this.type = getType(stat);
      this.emit("stat", stat);
      this[PROCESS]();
    }
    [PROCESS]() {
      switch (this.type) {
        case "File":
          return this[FILE]();
        case "Directory":
          return this[DIRECTORY]();
        case "SymbolicLink":
          return this[SYMLINK]();
        default:
          return this.end();
      }
    }
    [MODE](mode) {
      return modeFix(mode, this.type === "Directory", this.portable);
    }
    [PREFIX](path11) {
      return prefixPath(path11, this.prefix);
    }
    [HEADER]() {
      if (this.type === "Directory" && this.portable)
        this.noMtime = true;
      this.header = new Header({
        path: this[PREFIX](this.path),
        linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
        mode: this[MODE](this.stat.mode),
        uid: this.portable ? null : this.stat.uid,
        gid: this.portable ? null : this.stat.gid,
        size: this.stat.size,
        mtime: this.noMtime ? null : this.mtime || this.stat.mtime,
        type: this.type,
        uname: this.portable ? null : this.stat.uid === this.myuid ? this.myuser : "",
        atime: this.portable ? null : this.stat.atime,
        ctime: this.portable ? null : this.stat.ctime
      });
      if (this.header.encode() && !this.noPax) {
        super.write(new Pax({
          atime: this.portable ? null : this.header.atime,
          ctime: this.portable ? null : this.header.ctime,
          gid: this.portable ? null : this.header.gid,
          mtime: this.noMtime ? null : this.mtime || this.header.mtime,
          path: this[PREFIX](this.path),
          linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
          size: this.header.size,
          uid: this.portable ? null : this.header.uid,
          uname: this.portable ? null : this.header.uname,
          dev: this.portable ? null : this.stat.dev,
          ino: this.portable ? null : this.stat.ino,
          nlink: this.portable ? null : this.stat.nlink
        }).encode());
      }
      super.write(this.header.block);
    }
    [DIRECTORY]() {
      if (this.path.substr(-1) !== "/")
        this.path += "/";
      this.stat.size = 0;
      this[HEADER]();
      this.end();
    }
    [SYMLINK]() {
      fs9.readlink(this.absolute, (er, linkpath) => {
        if (er)
          return this.emit("error", er);
        this[ONREADLINK](linkpath);
      });
    }
    [ONREADLINK](linkpath) {
      this.linkpath = normPath(linkpath);
      this[HEADER]();
      this.end();
    }
    [HARDLINK](linkpath) {
      this.type = "Link";
      this.linkpath = normPath(path10.relative(this.cwd, linkpath));
      this.stat.size = 0;
      this[HEADER]();
      this.end();
    }
    [FILE]() {
      if (this.stat.nlink > 1) {
        const linkKey = this.stat.dev + ":" + this.stat.ino;
        if (this.linkCache.has(linkKey)) {
          const linkpath = this.linkCache.get(linkKey);
          if (linkpath.indexOf(this.cwd) === 0)
            return this[HARDLINK](linkpath);
        }
        this.linkCache.set(linkKey, this.absolute);
      }
      this[HEADER]();
      if (this.stat.size === 0)
        return this.end();
      this[OPENFILE]();
    }
    [OPENFILE]() {
      fs9.open(this.absolute, "r", (er, fd) => {
        if (er)
          return this.emit("error", er);
        this[ONOPENFILE](fd);
      });
    }
    [ONOPENFILE](fd) {
      this.fd = fd;
      if (this[HAD_ERROR])
        return this[CLOSE]();
      this.blockLen = 512 * Math.ceil(this.stat.size / 512);
      this.blockRemain = this.blockLen;
      const bufLen = Math.min(this.blockLen, this.maxReadSize);
      this.buf = Buffer.allocUnsafe(bufLen);
      this.offset = 0;
      this.pos = 0;
      this.remain = this.stat.size;
      this.length = this.buf.length;
      this[READ]();
    }
    [READ]() {
      const {fd, buf, offset, length, pos} = this;
      fs9.read(fd, buf, offset, length, pos, (er, bytesRead) => {
        if (er) {
          return this[CLOSE](() => this.emit("error", er));
        }
        this[ONREAD](bytesRead);
      });
    }
    [CLOSE](cb) {
      fs9.close(this.fd, cb);
    }
    [ONREAD](bytesRead) {
      if (bytesRead <= 0 && this.remain > 0) {
        const er = new Error("encountered unexpected EOF");
        er.path = this.absolute;
        er.syscall = "read";
        er.code = "EOF";
        return this[CLOSE](() => this.emit("error", er));
      }
      if (bytesRead > this.remain) {
        const er = new Error("did not encounter expected EOF");
        er.path = this.absolute;
        er.syscall = "read";
        er.code = "EOF";
        return this[CLOSE](() => this.emit("error", er));
      }
      if (bytesRead === this.remain) {
        for (let i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++) {
          this.buf[i + this.offset] = 0;
          bytesRead++;
          this.remain++;
        }
      }
      const writeBuf = this.offset === 0 && bytesRead === this.buf.length ? this.buf : this.buf.slice(this.offset, this.offset + bytesRead);
      const flushed = this.write(writeBuf);
      if (!flushed)
        this[AWAITDRAIN](() => this[ONDRAIN]());
      else
        this[ONDRAIN]();
    }
    [AWAITDRAIN](cb) {
      this.once("drain", cb);
    }
    write(writeBuf) {
      if (this.blockRemain < writeBuf.length) {
        const er = new Error("writing more data than expected");
        er.path = this.absolute;
        return this.emit("error", er);
      }
      this.remain -= writeBuf.length;
      this.blockRemain -= writeBuf.length;
      this.pos += writeBuf.length;
      this.offset += writeBuf.length;
      return super.write(writeBuf);
    }
    [ONDRAIN]() {
      if (!this.remain) {
        if (this.blockRemain)
          super.write(Buffer.alloc(this.blockRemain));
        return this[CLOSE]((er) => er ? this.emit("error", er) : this.end());
      }
      if (this.offset >= this.length) {
        this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length));
        this.offset = 0;
      }
      this.length = this.buf.length - this.offset;
      this[READ]();
    }
  });
  var WriteEntrySync = class extends WriteEntry {
    [LSTAT]() {
      this[ONLSTAT](fs9.lstatSync(this.absolute));
    }
    [SYMLINK]() {
      this[ONREADLINK](fs9.readlinkSync(this.absolute));
    }
    [OPENFILE]() {
      this[ONOPENFILE](fs9.openSync(this.absolute, "r"));
    }
    [READ]() {
      let threw = true;
      try {
        const {fd, buf, offset, length, pos} = this;
        const bytesRead = fs9.readSync(fd, buf, offset, length, pos);
        this[ONREAD](bytesRead);
        threw = false;
      } finally {
        if (threw) {
          try {
            this[CLOSE](() => {
            });
          } catch (er) {
          }
        }
      }
    }
    [AWAITDRAIN](cb) {
      cb();
    }
    [CLOSE](cb) {
      fs9.closeSync(this.fd);
      cb();
    }
  };
  var WriteEntryTar = warner(class WriteEntryTar extends MiniPass {
    constructor(readEntry, opt) {
      opt = opt || {};
      super(opt);
      this.preservePaths = !!opt.preservePaths;
      this.portable = !!opt.portable;
      this.strict = !!opt.strict;
      this.noPax = !!opt.noPax;
      this.noMtime = !!opt.noMtime;
      this.readEntry = readEntry;
      this.type = readEntry.type;
      if (this.type === "Directory" && this.portable)
        this.noMtime = true;
      this.prefix = opt.prefix || null;
      this.path = normPath(readEntry.path);
      this.mode = this[MODE](readEntry.mode);
      this.uid = this.portable ? null : readEntry.uid;
      this.gid = this.portable ? null : readEntry.gid;
      this.uname = this.portable ? null : readEntry.uname;
      this.gname = this.portable ? null : readEntry.gname;
      this.size = readEntry.size;
      this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime;
      this.atime = this.portable ? null : readEntry.atime;
      this.ctime = this.portable ? null : readEntry.ctime;
      this.linkpath = normPath(readEntry.linkpath);
      if (typeof opt.onwarn === "function")
        this.on("warn", opt.onwarn);
      let pathWarn = false;
      if (!this.preservePaths) {
        const [root, stripped] = stripAbsolutePath(this.path);
        if (root) {
          this.path = stripped;
          pathWarn = root;
        }
      }
      this.remain = readEntry.size;
      this.blockRemain = readEntry.startBlockSize;
      this.header = new Header({
        path: this[PREFIX](this.path),
        linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
        mode: this.mode,
        uid: this.portable ? null : this.uid,
        gid: this.portable ? null : this.gid,
        size: this.size,
        mtime: this.noMtime ? null : this.mtime,
        type: this.type,
        uname: this.portable ? null : this.uname,
        atime: this.portable ? null : this.atime,
        ctime: this.portable ? null : this.ctime
      });
      if (pathWarn) {
        this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
          entry: this,
          path: pathWarn + this.path
        });
      }
      if (this.header.encode() && !this.noPax) {
        super.write(new Pax({
          atime: this.portable ? null : this.atime,
          ctime: this.portable ? null : this.ctime,
          gid: this.portable ? null : this.gid,
          mtime: this.noMtime ? null : this.mtime,
          path: this[PREFIX](this.path),
          linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
          size: this.size,
          uid: this.portable ? null : this.uid,
          uname: this.portable ? null : this.uname,
          dev: this.portable ? null : this.readEntry.dev,
          ino: this.portable ? null : this.readEntry.ino,
          nlink: this.portable ? null : this.readEntry.nlink
        }).encode());
      }
      super.write(this.header.block);
      readEntry.pipe(this);
    }
    [PREFIX](path11) {
      return prefixPath(path11, this.prefix);
    }
    [MODE](mode) {
      return modeFix(mode, this.type === "Directory", this.portable);
    }
    write(data) {
      const writeLen = data.length;
      if (writeLen > this.blockRemain)
        throw new Error("writing more to entry than is appropriate");
      this.blockRemain -= writeLen;
      return super.write(data);
    }
    end() {
      if (this.blockRemain)
        super.write(Buffer.alloc(this.blockRemain));
      return super.end();
    }
  });
  WriteEntry.Sync = WriteEntrySync;
  WriteEntry.Tar = WriteEntryTar;
  var getType = (stat) => stat.isFile() ? "File" : stat.isDirectory() ? "Directory" : stat.isSymbolicLink() ? "SymbolicLink" : "Unsupported";
  module2.exports = WriteEntry;
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/pack.js
var require_pack = __commonJS((exports2, module2) => {
  "use strict";
  var PackJob = class {
    constructor(path11, absolute) {
      this.path = path11 || "./";
      this.absolute = absolute;
      this.entry = null;
      this.stat = null;
      this.readdir = null;
      this.pending = false;
      this.ignore = false;
      this.piped = false;
    }
  };
  var MiniPass = require_minipass();
  var zlib = require_minizlib();
  var ReadEntry = require_read_entry();
  var WriteEntry = require_write_entry();
  var WriteEntrySync = WriteEntry.Sync;
  var WriteEntryTar = WriteEntry.Tar;
  var Yallist = require_yallist();
  var EOF = Buffer.alloc(1024);
  var ONSTAT = Symbol("onStat");
  var ENDED = Symbol("ended");
  var QUEUE = Symbol("queue");
  var CURRENT = Symbol("current");
  var PROCESS = Symbol("process");
  var PROCESSING = Symbol("processing");
  var PROCESSJOB = Symbol("processJob");
  var JOBS = Symbol("jobs");
  var JOBDONE = Symbol("jobDone");
  var ADDFSENTRY = Symbol("addFSEntry");
  var ADDTARENTRY = Symbol("addTarEntry");
  var STAT = Symbol("stat");
  var READDIR = Symbol("readdir");
  var ONREADDIR = Symbol("onreaddir");
  var PIPE = Symbol("pipe");
  var ENTRY = Symbol("entry");
  var ENTRYOPT = Symbol("entryOpt");
  var WRITEENTRYCLASS = Symbol("writeEntryClass");
  var WRITE = Symbol("write");
  var ONDRAIN = Symbol("ondrain");
  var fs9 = require("fs");
  var path10 = require("path");
  var warner = require_warn_mixin();
  var normPath = require_normalize_windows_path();
  var Pack = warner(class Pack extends MiniPass {
    constructor(opt) {
      super(opt);
      opt = opt || Object.create(null);
      this.opt = opt;
      this.file = opt.file || "";
      this.cwd = opt.cwd || process.cwd();
      this.maxReadSize = opt.maxReadSize;
      this.preservePaths = !!opt.preservePaths;
      this.strict = !!opt.strict;
      this.noPax = !!opt.noPax;
      this.prefix = normPath(opt.prefix || "");
      this.linkCache = opt.linkCache || new Map();
      this.statCache = opt.statCache || new Map();
      this.readdirCache = opt.readdirCache || new Map();
      this[WRITEENTRYCLASS] = WriteEntry;
      if (typeof opt.onwarn === "function")
        this.on("warn", opt.onwarn);
      this.portable = !!opt.portable;
      this.zip = null;
      if (opt.gzip) {
        if (typeof opt.gzip !== "object")
          opt.gzip = {};
        if (this.portable)
          opt.gzip.portable = true;
        this.zip = new zlib.Gzip(opt.gzip);
        this.zip.on("data", (chunk) => super.write(chunk));
        this.zip.on("end", (_2) => super.end());
        this.zip.on("drain", (_2) => this[ONDRAIN]());
        this.on("resume", (_2) => this.zip.resume());
      } else
        this.on("drain", this[ONDRAIN]);
      this.noDirRecurse = !!opt.noDirRecurse;
      this.follow = !!opt.follow;
      this.noMtime = !!opt.noMtime;
      this.mtime = opt.mtime || null;
      this.filter = typeof opt.filter === "function" ? opt.filter : (_2) => true;
      this[QUEUE] = new Yallist();
      this[JOBS] = 0;
      this.jobs = +opt.jobs || 4;
      this[PROCESSING] = false;
      this[ENDED] = false;
    }
    [WRITE](chunk) {
      return super.write(chunk);
    }
    add(path11) {
      this.write(path11);
      return this;
    }
    end(path11) {
      if (path11)
        this.write(path11);
      this[ENDED] = true;
      this[PROCESS]();
      return this;
    }
    write(path11) {
      if (this[ENDED])
        throw new Error("write after end");
      if (path11 instanceof ReadEntry)
        this[ADDTARENTRY](path11);
      else
        this[ADDFSENTRY](path11);
      return this.flowing;
    }
    [ADDTARENTRY](p) {
      const absolute = normPath(path10.resolve(this.cwd, p.path));
      if (!this.filter(p.path, p))
        p.resume();
      else {
        const job = new PackJob(p.path, absolute, false);
        job.entry = new WriteEntryTar(p, this[ENTRYOPT](job));
        job.entry.on("end", (_2) => this[JOBDONE](job));
        this[JOBS] += 1;
        this[QUEUE].push(job);
      }
      this[PROCESS]();
    }
    [ADDFSENTRY](p) {
      const absolute = normPath(path10.resolve(this.cwd, p));
      this[QUEUE].push(new PackJob(p, absolute));
      this[PROCESS]();
    }
    [STAT](job) {
      job.pending = true;
      this[JOBS] += 1;
      const stat = this.follow ? "stat" : "lstat";
      fs9[stat](job.absolute, (er, stat2) => {
        job.pending = false;
        this[JOBS] -= 1;
        if (er)
          this.emit("error", er);
        else
          this[ONSTAT](job, stat2);
      });
    }
    [ONSTAT](job, stat) {
      this.statCache.set(job.absolute, stat);
      job.stat = stat;
      if (!this.filter(job.path, stat))
        job.ignore = true;
      this[PROCESS]();
    }
    [READDIR](job) {
      job.pending = true;
      this[JOBS] += 1;
      fs9.readdir(job.absolute, (er, entries) => {
        job.pending = false;
        this[JOBS] -= 1;
        if (er)
          return this.emit("error", er);
        this[ONREADDIR](job, entries);
      });
    }
    [ONREADDIR](job, entries) {
      this.readdirCache.set(job.absolute, entries);
      job.readdir = entries;
      this[PROCESS]();
    }
    [PROCESS]() {
      if (this[PROCESSING])
        return;
      this[PROCESSING] = true;
      for (let w2 = this[QUEUE].head; w2 !== null && this[JOBS] < this.jobs; w2 = w2.next) {
        this[PROCESSJOB](w2.value);
        if (w2.value.ignore) {
          const p = w2.next;
          this[QUEUE].removeNode(w2);
          w2.next = p;
        }
      }
      this[PROCESSING] = false;
      if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {
        if (this.zip)
          this.zip.end(EOF);
        else {
          super.write(EOF);
          super.end();
        }
      }
    }
    get [CURRENT]() {
      return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value;
    }
    [JOBDONE](job) {
      this[QUEUE].shift();
      this[JOBS] -= 1;
      this[PROCESS]();
    }
    [PROCESSJOB](job) {
      if (job.pending)
        return;
      if (job.entry) {
        if (job === this[CURRENT] && !job.piped)
          this[PIPE](job);
        return;
      }
      if (!job.stat) {
        if (this.statCache.has(job.absolute))
          this[ONSTAT](job, this.statCache.get(job.absolute));
        else
          this[STAT](job);
      }
      if (!job.stat)
        return;
      if (job.ignore)
        return;
      if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {
        if (this.readdirCache.has(job.absolute))
          this[ONREADDIR](job, this.readdirCache.get(job.absolute));
        else
          this[READDIR](job);
        if (!job.readdir)
          return;
      }
      job.entry = this[ENTRY](job);
      if (!job.entry) {
        job.ignore = true;
        return;
      }
      if (job === this[CURRENT] && !job.piped)
        this[PIPE](job);
    }
    [ENTRYOPT](job) {
      return {
        onwarn: (code, msg, data) => this.warn(code, msg, data),
        noPax: this.noPax,
        cwd: this.cwd,
        absolute: job.absolute,
        preservePaths: this.preservePaths,
        maxReadSize: this.maxReadSize,
        strict: this.strict,
        portable: this.portable,
        linkCache: this.linkCache,
        statCache: this.statCache,
        noMtime: this.noMtime,
        mtime: this.mtime,
        prefix: this.prefix
      };
    }
    [ENTRY](job) {
      this[JOBS] += 1;
      try {
        return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job)).on("end", () => this[JOBDONE](job)).on("error", (er) => this.emit("error", er));
      } catch (er) {
        this.emit("error", er);
      }
    }
    [ONDRAIN]() {
      if (this[CURRENT] && this[CURRENT].entry)
        this[CURRENT].entry.resume();
    }
    [PIPE](job) {
      job.piped = true;
      if (job.readdir) {
        job.readdir.forEach((entry) => {
          const p = job.path;
          const base = p === "./" ? "" : p.replace(/\/*$/, "/");
          this[ADDFSENTRY](base + entry);
        });
      }
      const source = job.entry;
      const zip = this.zip;
      if (zip) {
        source.on("data", (chunk) => {
          if (!zip.write(chunk))
            source.pause();
        });
      } else {
        source.on("data", (chunk) => {
          if (!super.write(chunk))
            source.pause();
        });
      }
    }
    pause() {
      if (this.zip)
        this.zip.pause();
      return super.pause();
    }
  });
  var PackSync = class extends Pack {
    constructor(opt) {
      super(opt);
      this[WRITEENTRYCLASS] = WriteEntrySync;
    }
    pause() {
    }
    resume() {
    }
    [STAT](job) {
      const stat = this.follow ? "statSync" : "lstatSync";
      this[ONSTAT](job, fs9[stat](job.absolute));
    }
    [READDIR](job, stat) {
      this[ONREADDIR](job, fs9.readdirSync(job.absolute));
    }
    [PIPE](job) {
      const source = job.entry;
      const zip = this.zip;
      if (job.readdir) {
        job.readdir.forEach((entry) => {
          const p = job.path;
          const base = p === "./" ? "" : p.replace(/\/*$/, "/");
          this[ADDFSENTRY](base + entry);
        });
      }
      if (zip) {
        source.on("data", (chunk) => {
          zip.write(chunk);
        });
      } else {
        source.on("data", (chunk) => {
          super[WRITE](chunk);
        });
      }
    }
  };
  Pack.Sync = PackSync;
  module2.exports = Pack;
});

// ../../node_modules/.pnpm/fs-minipass@2.1.0/node_modules/fs-minipass/index.js
var require_fs_minipass = __commonJS((exports2) => {
  "use strict";
  var MiniPass = require_minipass();
  var EE = require("events").EventEmitter;
  var fs9 = require("fs");
  var writev = fs9.writev;
  if (!writev) {
    const binding = process.binding("fs");
    const FSReqWrap = binding.FSReqWrap || binding.FSReqCallback;
    writev = (fd, iovec, pos, cb) => {
      const done = (er, bw) => cb(er, bw, iovec);
      const req = new FSReqWrap();
      req.oncomplete = done;
      binding.writeBuffers(fd, iovec, pos, req);
    };
  }
  var _autoClose = Symbol("_autoClose");
  var _close = Symbol("_close");
  var _ended = Symbol("_ended");
  var _fd = Symbol("_fd");
  var _finished = Symbol("_finished");
  var _flags = Symbol("_flags");
  var _flush = Symbol("_flush");
  var _handleChunk = Symbol("_handleChunk");
  var _makeBuf = Symbol("_makeBuf");
  var _mode = Symbol("_mode");
  var _needDrain = Symbol("_needDrain");
  var _onerror = Symbol("_onerror");
  var _onopen = Symbol("_onopen");
  var _onread = Symbol("_onread");
  var _onwrite = Symbol("_onwrite");
  var _open = Symbol("_open");
  var _path = Symbol("_path");
  var _pos = Symbol("_pos");
  var _queue = Symbol("_queue");
  var _read = Symbol("_read");
  var _readSize = Symbol("_readSize");
  var _reading = Symbol("_reading");
  var _remain = Symbol("_remain");
  var _size = Symbol("_size");
  var _write = Symbol("_write");
  var _writing = Symbol("_writing");
  var _defaultFlag = Symbol("_defaultFlag");
  var _errored = Symbol("_errored");
  var ReadStream = class extends MiniPass {
    constructor(path10, opt) {
      opt = opt || {};
      super(opt);
      this.readable = true;
      this.writable = false;
      if (typeof path10 !== "string")
        throw new TypeError("path must be a string");
      this[_errored] = false;
      this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
      this[_path] = path10;
      this[_readSize] = opt.readSize || 16 * 1024 * 1024;
      this[_reading] = false;
      this[_size] = typeof opt.size === "number" ? opt.size : Infinity;
      this[_remain] = this[_size];
      this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
      if (typeof this[_fd] === "number")
        this[_read]();
      else
        this[_open]();
    }
    get fd() {
      return this[_fd];
    }
    get path() {
      return this[_path];
    }
    write() {
      throw new TypeError("this is a readable stream");
    }
    end() {
      throw new TypeError("this is a readable stream");
    }
    [_open]() {
      fs9.open(this[_path], "r", (er, fd) => this[_onopen](er, fd));
    }
    [_onopen](er, fd) {
      if (er)
        this[_onerror](er);
      else {
        this[_fd] = fd;
        this.emit("open", fd);
        this[_read]();
      }
    }
    [_makeBuf]() {
      return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));
    }
    [_read]() {
      if (!this[_reading]) {
        this[_reading] = true;
        const buf = this[_makeBuf]();
        if (buf.length === 0)
          return process.nextTick(() => this[_onread](null, 0, buf));
        fs9.read(this[_fd], buf, 0, buf.length, null, (er, br, buf2) => this[_onread](er, br, buf2));
      }
    }
    [_onread](er, br, buf) {
      this[_reading] = false;
      if (er)
        this[_onerror](er);
      else if (this[_handleChunk](br, buf))
        this[_read]();
    }
    [_close]() {
      if (this[_autoClose] && typeof this[_fd] === "number") {
        const fd = this[_fd];
        this[_fd] = null;
        fs9.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
      }
    }
    [_onerror](er) {
      this[_reading] = true;
      this[_close]();
      this.emit("error", er);
    }
    [_handleChunk](br, buf) {
      let ret = false;
      this[_remain] -= br;
      if (br > 0)
        ret = super.write(br < buf.length ? buf.slice(0, br) : buf);
      if (br === 0 || this[_remain] <= 0) {
        ret = false;
        this[_close]();
        super.end();
      }
      return ret;
    }
    emit(ev, data) {
      switch (ev) {
        case "prefinish":
        case "finish":
          break;
        case "drain":
          if (typeof this[_fd] === "number")
            this[_read]();
          break;
        case "error":
          if (this[_errored])
            return;
          this[_errored] = true;
          return super.emit(ev, data);
        default:
          return super.emit(ev, data);
      }
    }
  };
  var ReadStreamSync = class extends ReadStream {
    [_open]() {
      let threw = true;
      try {
        this[_onopen](null, fs9.openSync(this[_path], "r"));
        threw = false;
      } finally {
        if (threw)
          this[_close]();
      }
    }
    [_read]() {
      let threw = true;
      try {
        if (!this[_reading]) {
          this[_reading] = true;
          do {
            const buf = this[_makeBuf]();
            const br = buf.length === 0 ? 0 : fs9.readSync(this[_fd], buf, 0, buf.length, null);
            if (!this[_handleChunk](br, buf))
              break;
          } while (true);
          this[_reading] = false;
        }
        threw = false;
      } finally {
        if (threw)
          this[_close]();
      }
    }
    [_close]() {
      if (this[_autoClose] && typeof this[_fd] === "number") {
        const fd = this[_fd];
        this[_fd] = null;
        fs9.closeSync(fd);
        this.emit("close");
      }
    }
  };
  var WriteStream = class extends EE {
    constructor(path10, opt) {
      opt = opt || {};
      super(opt);
      this.readable = false;
      this.writable = true;
      this[_errored] = false;
      this[_writing] = false;
      this[_ended] = false;
      this[_needDrain] = false;
      this[_queue] = [];
      this[_path] = path10;
      this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
      this[_mode] = opt.mode === void 0 ? 438 : opt.mode;
      this[_pos] = typeof opt.start === "number" ? opt.start : null;
      this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
      const defaultFlag = this[_pos] !== null ? "r+" : "w";
      this[_defaultFlag] = opt.flags === void 0;
      this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags;
      if (this[_fd] === null)
        this[_open]();
    }
    emit(ev, data) {
      if (ev === "error") {
        if (this[_errored])
          return;
        this[_errored] = true;
      }
      return super.emit(ev, data);
    }
    get fd() {
      return this[_fd];
    }
    get path() {
      return this[_path];
    }
    [_onerror](er) {
      this[_close]();
      this[_writing] = true;
      this.emit("error", er);
    }
    [_open]() {
      fs9.open(this[_path], this[_flags], this[_mode], (er, fd) => this[_onopen](er, fd));
    }
    [_onopen](er, fd) {
      if (this[_defaultFlag] && this[_flags] === "r+" && er && er.code === "ENOENT") {
        this[_flags] = "w";
        this[_open]();
      } else if (er)
        this[_onerror](er);
      else {
        this[_fd] = fd;
        this.emit("open", fd);
        this[_flush]();
      }
    }
    end(buf, enc) {
      if (buf)
        this.write(buf, enc);
      this[_ended] = true;
      if (!this[_writing] && !this[_queue].length && typeof this[_fd] === "number")
        this[_onwrite](null, 0);
      return this;
    }
    write(buf, enc) {
      if (typeof buf === "string")
        buf = Buffer.from(buf, enc);
      if (this[_ended]) {
        this.emit("error", new Error("write() after end()"));
        return false;
      }
      if (this[_fd] === null || this[_writing] || this[_queue].length) {
        this[_queue].push(buf);
        this[_needDrain] = true;
        return false;
      }
      this[_writing] = true;
      this[_write](buf);
      return true;
    }
    [_write](buf) {
      fs9.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) => this[_onwrite](er, bw));
    }
    [_onwrite](er, bw) {
      if (er)
        this[_onerror](er);
      else {
        if (this[_pos] !== null)
          this[_pos] += bw;
        if (this[_queue].length)
          this[_flush]();
        else {
          this[_writing] = false;
          if (this[_ended] && !this[_finished]) {
            this[_finished] = true;
            this[_close]();
            this.emit("finish");
          } else if (this[_needDrain]) {
            this[_needDrain] = false;
            this.emit("drain");
          }
        }
      }
    }
    [_flush]() {
      if (this[_queue].length === 0) {
        if (this[_ended])
          this[_onwrite](null, 0);
      } else if (this[_queue].length === 1)
        this[_write](this[_queue].pop());
      else {
        const iovec = this[_queue];
        this[_queue] = [];
        writev(this[_fd], iovec, this[_pos], (er, bw) => this[_onwrite](er, bw));
      }
    }
    [_close]() {
      if (this[_autoClose] && typeof this[_fd] === "number") {
        const fd = this[_fd];
        this[_fd] = null;
        fs9.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
      }
    }
  };
  var WriteStreamSync = class extends WriteStream {
    [_open]() {
      let fd;
      if (this[_defaultFlag] && this[_flags] === "r+") {
        try {
          fd = fs9.openSync(this[_path], this[_flags], this[_mode]);
        } catch (er) {
          if (er.code === "ENOENT") {
            this[_flags] = "w";
            return this[_open]();
          } else
            throw er;
        }
      } else
        fd = fs9.openSync(this[_path], this[_flags], this[_mode]);
      this[_onopen](null, fd);
    }
    [_close]() {
      if (this[_autoClose] && typeof this[_fd] === "number") {
        const fd = this[_fd];
        this[_fd] = null;
        fs9.closeSync(fd);
        this.emit("close");
      }
    }
    [_write](buf) {
      let threw = true;
      try {
        this[_onwrite](null, fs9.writeSync(this[_fd], buf, 0, buf.length, this[_pos]));
        threw = false;
      } finally {
        if (threw)
          try {
            this[_close]();
          } catch (_2) {
          }
      }
    }
  };
  exports2.ReadStream = ReadStream;
  exports2.ReadStreamSync = ReadStreamSync;
  exports2.WriteStream = WriteStream;
  exports2.WriteStreamSync = WriteStreamSync;
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/parse.js
var require_parse5 = __commonJS((exports2, module2) => {
  "use strict";
  var warner = require_warn_mixin();
  var Header = require_header();
  var EE = require("events");
  var Yallist = require_yallist();
  var maxMetaEntrySize = 1024 * 1024;
  var Entry = require_read_entry();
  var Pax = require_pax();
  var zlib = require_minizlib();
  var gzipHeader = Buffer.from([31, 139]);
  var STATE = Symbol("state");
  var WRITEENTRY = Symbol("writeEntry");
  var READENTRY = Symbol("readEntry");
  var NEXTENTRY = Symbol("nextEntry");
  var PROCESSENTRY = Symbol("processEntry");
  var EX = Symbol("extendedHeader");
  var GEX = Symbol("globalExtendedHeader");
  var META = Symbol("meta");
  var EMITMETA = Symbol("emitMeta");
  var BUFFER = Symbol("buffer");
  var QUEUE = Symbol("queue");
  var ENDED = Symbol("ended");
  var EMITTEDEND = Symbol("emittedEnd");
  var EMIT = Symbol("emit");
  var UNZIP = Symbol("unzip");
  var CONSUMECHUNK = Symbol("consumeChunk");
  var CONSUMECHUNKSUB = Symbol("consumeChunkSub");
  var CONSUMEBODY = Symbol("consumeBody");
  var CONSUMEMETA = Symbol("consumeMeta");
  var CONSUMEHEADER = Symbol("consumeHeader");
  var CONSUMING = Symbol("consuming");
  var BUFFERCONCAT = Symbol("bufferConcat");
  var MAYBEEND = Symbol("maybeEnd");
  var WRITING = Symbol("writing");
  var ABORTED = Symbol("aborted");
  var DONE = Symbol("onDone");
  var SAW_VALID_ENTRY = Symbol("sawValidEntry");
  var SAW_NULL_BLOCK = Symbol("sawNullBlock");
  var SAW_EOF = Symbol("sawEOF");
  var noop = (_2) => true;
  module2.exports = warner(class Parser extends EE {
    constructor(opt) {
      opt = opt || {};
      super(opt);
      this.file = opt.file || "";
      this[SAW_VALID_ENTRY] = null;
      this.on(DONE, (_2) => {
        if (this[STATE] === "begin" || this[SAW_VALID_ENTRY] === false) {
          this.warn("TAR_BAD_ARCHIVE", "Unrecognized archive format");
        }
      });
      if (opt.ondone)
        this.on(DONE, opt.ondone);
      else {
        this.on(DONE, (_2) => {
          this.emit("prefinish");
          this.emit("finish");
          this.emit("end");
          this.emit("close");
        });
      }
      this.strict = !!opt.strict;
      this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize;
      this.filter = typeof opt.filter === "function" ? opt.filter : noop;
      this.writable = true;
      this.readable = false;
      this[QUEUE] = new Yallist();
      this[BUFFER] = null;
      this[READENTRY] = null;
      this[WRITEENTRY] = null;
      this[STATE] = "begin";
      this[META] = "";
      this[EX] = null;
      this[GEX] = null;
      this[ENDED] = false;
      this[UNZIP] = null;
      this[ABORTED] = false;
      this[SAW_NULL_BLOCK] = false;
      this[SAW_EOF] = false;
      if (typeof opt.onwarn === "function")
        this.on("warn", opt.onwarn);
      if (typeof opt.onentry === "function")
        this.on("entry", opt.onentry);
    }
    [CONSUMEHEADER](chunk, position) {
      if (this[SAW_VALID_ENTRY] === null)
        this[SAW_VALID_ENTRY] = false;
      let header;
      try {
        header = new Header(chunk, position, this[EX], this[GEX]);
      } catch (er) {
        return this.warn("TAR_ENTRY_INVALID", er);
      }
      if (header.nullBlock) {
        if (this[SAW_NULL_BLOCK]) {
          this[SAW_EOF] = true;
          if (this[STATE] === "begin")
            this[STATE] = "header";
          this[EMIT]("eof");
        } else {
          this[SAW_NULL_BLOCK] = true;
          this[EMIT]("nullBlock");
        }
      } else {
        this[SAW_NULL_BLOCK] = false;
        if (!header.cksumValid)
          this.warn("TAR_ENTRY_INVALID", "checksum failure", {header});
        else if (!header.path)
          this.warn("TAR_ENTRY_INVALID", "path is required", {header});
        else {
          const type = header.type;
          if (/^(Symbolic)?Link$/.test(type) && !header.linkpath)
            this.warn("TAR_ENTRY_INVALID", "linkpath required", {header});
          else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath)
            this.warn("TAR_ENTRY_INVALID", "linkpath forbidden", {header});
          else {
            const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX]);
            if (!this[SAW_VALID_ENTRY]) {
              if (entry.remain) {
                const onend = () => {
                  if (!entry.invalid)
                    this[SAW_VALID_ENTRY] = true;
                };
                entry.on("end", onend);
              } else
                this[SAW_VALID_ENTRY] = true;
            }
            if (entry.meta) {
              if (entry.size > this.maxMetaEntrySize) {
                entry.ignore = true;
                this[EMIT]("ignoredEntry", entry);
                this[STATE] = "ignore";
                entry.resume();
              } else if (entry.size > 0) {
                this[META] = "";
                entry.on("data", (c) => this[META] += c);
                this[STATE] = "meta";
              }
            } else {
              this[EX] = null;
              entry.ignore = entry.ignore || !this.filter(entry.path, entry);
              if (entry.ignore) {
                this[EMIT]("ignoredEntry", entry);
                this[STATE] = entry.remain ? "ignore" : "header";
                entry.resume();
              } else {
                if (entry.remain)
                  this[STATE] = "body";
                else {
                  this[STATE] = "header";
                  entry.end();
                }
                if (!this[READENTRY]) {
                  this[QUEUE].push(entry);
                  this[NEXTENTRY]();
                } else
                  this[QUEUE].push(entry);
              }
            }
          }
        }
      }
    }
    [PROCESSENTRY](entry) {
      let go = true;
      if (!entry) {
        this[READENTRY] = null;
        go = false;
      } else if (Array.isArray(entry))
        this.emit.apply(this, entry);
      else {
        this[READENTRY] = entry;
        this.emit("entry", entry);
        if (!entry.emittedEnd) {
          entry.on("end", (_2) => this[NEXTENTRY]());
          go = false;
        }
      }
      return go;
    }
    [NEXTENTRY]() {
      do {
      } while (this[PROCESSENTRY](this[QUEUE].shift()));
      if (!this[QUEUE].length) {
        const re = this[READENTRY];
        const drainNow = !re || re.flowing || re.size === re.remain;
        if (drainNow) {
          if (!this[WRITING])
            this.emit("drain");
        } else
          re.once("drain", (_2) => this.emit("drain"));
      }
    }
    [CONSUMEBODY](chunk, position) {
      const entry = this[WRITEENTRY];
      const br = entry.blockRemain;
      const c = br >= chunk.length && position === 0 ? chunk : chunk.slice(position, position + br);
      entry.write(c);
      if (!entry.blockRemain) {
        this[STATE] = "header";
        this[WRITEENTRY] = null;
        entry.end();
      }
      return c.length;
    }
    [CONSUMEMETA](chunk, position) {
      const entry = this[WRITEENTRY];
      const ret = this[CONSUMEBODY](chunk, position);
      if (!this[WRITEENTRY])
        this[EMITMETA](entry);
      return ret;
    }
    [EMIT](ev, data, extra) {
      if (!this[QUEUE].length && !this[READENTRY])
        this.emit(ev, data, extra);
      else
        this[QUEUE].push([ev, data, extra]);
    }
    [EMITMETA](entry) {
      this[EMIT]("meta", this[META]);
      switch (entry.type) {
        case "ExtendedHeader":
        case "OldExtendedHeader":
          this[EX] = Pax.parse(this[META], this[EX], false);
          break;
        case "GlobalExtendedHeader":
          this[GEX] = Pax.parse(this[META], this[GEX], true);
          break;
        case "NextFileHasLongPath":
        case "OldGnuLongPath":
          this[EX] = this[EX] || Object.create(null);
          this[EX].path = this[META].replace(/\0.*/, "");
          break;
        case "NextFileHasLongLinkpath":
          this[EX] = this[EX] || Object.create(null);
          this[EX].linkpath = this[META].replace(/\0.*/, "");
          break;
        default:
          throw new Error("unknown meta: " + entry.type);
      }
    }
    abort(error) {
      this[ABORTED] = true;
      this.emit("abort", error);
      this.warn("TAR_ABORT", error, {recoverable: false});
    }
    write(chunk) {
      if (this[ABORTED])
        return;
      if (this[UNZIP] === null && chunk) {
        if (this[BUFFER]) {
          chunk = Buffer.concat([this[BUFFER], chunk]);
          this[BUFFER] = null;
        }
        if (chunk.length < gzipHeader.length) {
          this[BUFFER] = chunk;
          return true;
        }
        for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {
          if (chunk[i] !== gzipHeader[i])
            this[UNZIP] = false;
        }
        if (this[UNZIP] === null) {
          const ended = this[ENDED];
          this[ENDED] = false;
          this[UNZIP] = new zlib.Unzip();
          this[UNZIP].on("data", (chunk2) => this[CONSUMECHUNK](chunk2));
          this[UNZIP].on("error", (er) => this.abort(er));
          this[UNZIP].on("end", (_2) => {
            this[ENDED] = true;
            this[CONSUMECHUNK]();
          });
          this[WRITING] = true;
          const ret2 = this[UNZIP][ended ? "end" : "write"](chunk);
          this[WRITING] = false;
          return ret2;
        }
      }
      this[WRITING] = true;
      if (this[UNZIP])
        this[UNZIP].write(chunk);
      else
        this[CONSUMECHUNK](chunk);
      this[WRITING] = false;
      const ret = this[QUEUE].length ? false : this[READENTRY] ? this[READENTRY].flowing : true;
      if (!ret && !this[QUEUE].length)
        this[READENTRY].once("drain", (_2) => this.emit("drain"));
      return ret;
    }
    [BUFFERCONCAT](c) {
      if (c && !this[ABORTED])
        this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c;
    }
    [MAYBEEND]() {
      if (this[ENDED] && !this[EMITTEDEND] && !this[ABORTED] && !this[CONSUMING]) {
        this[EMITTEDEND] = true;
        const entry = this[WRITEENTRY];
        if (entry && entry.blockRemain) {
          const have = this[BUFFER] ? this[BUFFER].length : 0;
          this.warn("TAR_BAD_ARCHIVE", `Truncated input (needed ${entry.blockRemain} more bytes, only ${have} available)`, {entry});
          if (this[BUFFER])
            entry.write(this[BUFFER]);
          entry.end();
        }
        this[EMIT](DONE);
      }
    }
    [CONSUMECHUNK](chunk) {
      if (this[CONSUMING])
        this[BUFFERCONCAT](chunk);
      else if (!chunk && !this[BUFFER])
        this[MAYBEEND]();
      else {
        this[CONSUMING] = true;
        if (this[BUFFER]) {
          this[BUFFERCONCAT](chunk);
          const c = this[BUFFER];
          this[BUFFER] = null;
          this[CONSUMECHUNKSUB](c);
        } else
          this[CONSUMECHUNKSUB](chunk);
        while (this[BUFFER] && this[BUFFER].length >= 512 && !this[ABORTED] && !this[SAW_EOF]) {
          const c = this[BUFFER];
          this[BUFFER] = null;
          this[CONSUMECHUNKSUB](c);
        }
        this[CONSUMING] = false;
      }
      if (!this[BUFFER] || this[ENDED])
        this[MAYBEEND]();
    }
    [CONSUMECHUNKSUB](chunk) {
      let position = 0;
      const length = chunk.length;
      while (position + 512 <= length && !this[ABORTED] && !this[SAW_EOF]) {
        switch (this[STATE]) {
          case "begin":
          case "header":
            this[CONSUMEHEADER](chunk, position);
            position += 512;
            break;
          case "ignore":
          case "body":
            position += this[CONSUMEBODY](chunk, position);
            break;
          case "meta":
            position += this[CONSUMEMETA](chunk, position);
            break;
          default:
            throw new Error("invalid state: " + this[STATE]);
        }
      }
      if (position < length) {
        if (this[BUFFER])
          this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]]);
        else
          this[BUFFER] = chunk.slice(position);
      }
    }
    end(chunk) {
      if (!this[ABORTED]) {
        if (this[UNZIP])
          this[UNZIP].end(chunk);
        else {
          this[ENDED] = true;
          this.write(chunk);
        }
      }
    }
  });
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/list.js
var require_list = __commonJS((exports2, module2) => {
  "use strict";
  var hlo = require_high_level_opt();
  var Parser = require_parse5();
  var fs9 = require("fs");
  var fsm = require_fs_minipass();
  var path10 = require("path");
  var stripSlash = require_strip_trailing_slashes();
  module2.exports = (opt_, files, cb) => {
    if (typeof opt_ === "function")
      cb = opt_, files = null, opt_ = {};
    else if (Array.isArray(opt_))
      files = opt_, opt_ = {};
    if (typeof files === "function")
      cb = files, files = null;
    if (!files)
      files = [];
    else
      files = Array.from(files);
    const opt = hlo(opt_);
    if (opt.sync && typeof cb === "function")
      throw new TypeError("callback not supported for sync tar functions");
    if (!opt.file && typeof cb === "function")
      throw new TypeError("callback only supported with file option");
    if (files.length)
      filesFilter(opt, files);
    if (!opt.noResume)
      onentryFunction(opt);
    return opt.file && opt.sync ? listFileSync(opt) : opt.file ? listFile(opt, cb) : list(opt);
  };
  var onentryFunction = (opt) => {
    const onentry = opt.onentry;
    opt.onentry = onentry ? (e) => {
      onentry(e);
      e.resume();
    } : (e) => e.resume();
  };
  var filesFilter = (opt, files) => {
    const map = new Map(files.map((f) => [stripSlash(f), true]));
    const filter = opt.filter;
    const mapHas = (file, r) => {
      const root = r || path10.parse(file).root || ".";
      const ret = file === root ? false : map.has(file) ? map.get(file) : mapHas(path10.dirname(file), root);
      map.set(file, ret);
      return ret;
    };
    opt.filter = filter ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file)) : (file) => mapHas(stripSlash(file));
  };
  var listFileSync = (opt) => {
    const p = list(opt);
    const file = opt.file;
    let threw = true;
    let fd;
    try {
      const stat = fs9.statSync(file);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      if (stat.size < readSize)
        p.end(fs9.readFileSync(file));
      else {
        let pos = 0;
        const buf = Buffer.allocUnsafe(readSize);
        fd = fs9.openSync(file, "r");
        while (pos < stat.size) {
          const bytesRead = fs9.readSync(fd, buf, 0, readSize, pos);
          pos += bytesRead;
          p.write(buf.slice(0, bytesRead));
        }
        p.end();
      }
      threw = false;
    } finally {
      if (threw && fd) {
        try {
          fs9.closeSync(fd);
        } catch (er) {
        }
      }
    }
  };
  var listFile = (opt, cb) => {
    const parse2 = new Parser(opt);
    const readSize = opt.maxReadSize || 16 * 1024 * 1024;
    const file = opt.file;
    const p = new Promise((resolve, reject) => {
      parse2.on("error", reject);
      parse2.on("end", resolve);
      fs9.stat(file, (er, stat) => {
        if (er)
          reject(er);
        else {
          const stream = new fsm.ReadStream(file, {
            readSize,
            size: stat.size
          });
          stream.on("error", reject);
          stream.pipe(parse2);
        }
      });
    });
    return cb ? p.then(cb, cb) : p;
  };
  var list = (opt) => new Parser(opt);
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/create.js
var require_create = __commonJS((exports2, module2) => {
  "use strict";
  var hlo = require_high_level_opt();
  var Pack = require_pack();
  var fsm = require_fs_minipass();
  var t = require_list();
  var path10 = require("path");
  module2.exports = (opt_, files, cb) => {
    if (typeof files === "function")
      cb = files;
    if (Array.isArray(opt_))
      files = opt_, opt_ = {};
    if (!files || !Array.isArray(files) || !files.length)
      throw new TypeError("no files or directories specified");
    files = Array.from(files);
    const opt = hlo(opt_);
    if (opt.sync && typeof cb === "function")
      throw new TypeError("callback not supported for sync tar functions");
    if (!opt.file && typeof cb === "function")
      throw new TypeError("callback only supported with file option");
    return opt.file && opt.sync ? createFileSync(opt, files) : opt.file ? createFile(opt, files, cb) : opt.sync ? createSync(opt, files) : create(opt, files);
  };
  var createFileSync = (opt, files) => {
    const p = new Pack.Sync(opt);
    const stream = new fsm.WriteStreamSync(opt.file, {
      mode: opt.mode || 438
    });
    p.pipe(stream);
    addFilesSync(p, files);
  };
  var createFile = (opt, files, cb) => {
    const p = new Pack(opt);
    const stream = new fsm.WriteStream(opt.file, {
      mode: opt.mode || 438
    });
    p.pipe(stream);
    const promise = new Promise((res, rej) => {
      stream.on("error", rej);
      stream.on("close", res);
      p.on("error", rej);
    });
    addFilesAsync(p, files);
    return cb ? promise.then(cb, cb) : promise;
  };
  var addFilesSync = (p, files) => {
    files.forEach((file) => {
      if (file.charAt(0) === "@") {
        t({
          file: path10.resolve(p.cwd, file.substr(1)),
          sync: true,
          noResume: true,
          onentry: (entry) => p.add(entry)
        });
      } else
        p.add(file);
    });
    p.end();
  };
  var addFilesAsync = (p, files) => {
    while (files.length) {
      const file = files.shift();
      if (file.charAt(0) === "@") {
        return t({
          file: path10.resolve(p.cwd, file.substr(1)),
          noResume: true,
          onentry: (entry) => p.add(entry)
        }).then((_2) => addFilesAsync(p, files));
      } else
        p.add(file);
    }
    p.end();
  };
  var createSync = (opt, files) => {
    const p = new Pack.Sync(opt);
    addFilesSync(p, files);
    return p;
  };
  var create = (opt, files) => {
    const p = new Pack(opt);
    addFilesAsync(p, files);
    return p;
  };
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/replace.js
var require_replace = __commonJS((exports2, module2) => {
  "use strict";
  var hlo = require_high_level_opt();
  var Pack = require_pack();
  var fs9 = require("fs");
  var fsm = require_fs_minipass();
  var t = require_list();
  var path10 = require("path");
  var Header = require_header();
  module2.exports = (opt_, files, cb) => {
    const opt = hlo(opt_);
    if (!opt.file)
      throw new TypeError("file is required");
    if (opt.gzip)
      throw new TypeError("cannot append to compressed archives");
    if (!files || !Array.isArray(files) || !files.length)
      throw new TypeError("no files or directories specified");
    files = Array.from(files);
    return opt.sync ? replaceSync(opt, files) : replace(opt, files, cb);
  };
  var replaceSync = (opt, files) => {
    const p = new Pack.Sync(opt);
    let threw = true;
    let fd;
    let position;
    try {
      try {
        fd = fs9.openSync(opt.file, "r+");
      } catch (er) {
        if (er.code === "ENOENT")
          fd = fs9.openSync(opt.file, "w+");
        else
          throw er;
      }
      const st = fs9.fstatSync(fd);
      const headBuf = Buffer.alloc(512);
      POSITION:
        for (position = 0; position < st.size; position += 512) {
          for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {
            bytes = fs9.readSync(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos);
            if (position === 0 && headBuf[0] === 31 && headBuf[1] === 139)
              throw new Error("cannot append to compressed archives");
            if (!bytes)
              break POSITION;
          }
          const h2 = new Header(headBuf);
          if (!h2.cksumValid)
            break;
          const entryBlockSize = 512 * Math.ceil(h2.size / 512);
          if (position + entryBlockSize + 512 > st.size)
            break;
          position += entryBlockSize;
          if (opt.mtimeCache)
            opt.mtimeCache.set(h2.path, h2.mtime);
        }
      threw = false;
      streamSync(opt, p, position, fd, files);
    } finally {
      if (threw) {
        try {
          fs9.closeSync(fd);
        } catch (er) {
        }
      }
    }
  };
  var streamSync = (opt, p, position, fd, files) => {
    const stream = new fsm.WriteStreamSync(opt.file, {
      fd,
      start: position
    });
    p.pipe(stream);
    addFilesSync(p, files);
  };
  var replace = (opt, files, cb) => {
    files = Array.from(files);
    const p = new Pack(opt);
    const getPos = (fd, size, cb_) => {
      const cb2 = (er, pos) => {
        if (er)
          fs9.close(fd, (_2) => cb_(er));
        else
          cb_(null, pos);
      };
      let position = 0;
      if (size === 0)
        return cb2(null, 0);
      let bufPos = 0;
      const headBuf = Buffer.alloc(512);
      const onread = (er, bytes) => {
        if (er)
          return cb2(er);
        bufPos += bytes;
        if (bufPos < 512 && bytes) {
          return fs9.read(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos, onread);
        }
        if (position === 0 && headBuf[0] === 31 && headBuf[1] === 139)
          return cb2(new Error("cannot append to compressed archives"));
        if (bufPos < 512)
          return cb2(null, position);
        const h2 = new Header(headBuf);
        if (!h2.cksumValid)
          return cb2(null, position);
        const entryBlockSize = 512 * Math.ceil(h2.size / 512);
        if (position + entryBlockSize + 512 > size)
          return cb2(null, position);
        position += entryBlockSize + 512;
        if (position >= size)
          return cb2(null, position);
        if (opt.mtimeCache)
          opt.mtimeCache.set(h2.path, h2.mtime);
        bufPos = 0;
        fs9.read(fd, headBuf, 0, 512, position, onread);
      };
      fs9.read(fd, headBuf, 0, 512, position, onread);
    };
    const promise = new Promise((resolve, reject) => {
      p.on("error", reject);
      let flag = "r+";
      const onopen = (er, fd) => {
        if (er && er.code === "ENOENT" && flag === "r+") {
          flag = "w+";
          return fs9.open(opt.file, flag, onopen);
        }
        if (er)
          return reject(er);
        fs9.fstat(fd, (er2, st) => {
          if (er2)
            return fs9.close(fd, () => reject(er2));
          getPos(fd, st.size, (er3, position) => {
            if (er3)
              return reject(er3);
            const stream = new fsm.WriteStream(opt.file, {
              fd,
              start: position
            });
            p.pipe(stream);
            stream.on("error", reject);
            stream.on("close", resolve);
            addFilesAsync(p, files);
          });
        });
      };
      fs9.open(opt.file, flag, onopen);
    });
    return cb ? promise.then(cb, cb) : promise;
  };
  var addFilesSync = (p, files) => {
    files.forEach((file) => {
      if (file.charAt(0) === "@") {
        t({
          file: path10.resolve(p.cwd, file.substr(1)),
          sync: true,
          noResume: true,
          onentry: (entry) => p.add(entry)
        });
      } else
        p.add(file);
    });
    p.end();
  };
  var addFilesAsync = (p, files) => {
    while (files.length) {
      const file = files.shift();
      if (file.charAt(0) === "@") {
        return t({
          file: path10.resolve(p.cwd, file.substr(1)),
          noResume: true,
          onentry: (entry) => p.add(entry)
        }).then((_2) => addFilesAsync(p, files));
      } else
        p.add(file);
    }
    p.end();
  };
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/update.js
var require_update = __commonJS((exports2, module2) => {
  "use strict";
  var hlo = require_high_level_opt();
  var r = require_replace();
  module2.exports = (opt_, files, cb) => {
    const opt = hlo(opt_);
    if (!opt.file)
      throw new TypeError("file is required");
    if (opt.gzip)
      throw new TypeError("cannot append to compressed archives");
    if (!files || !Array.isArray(files) || !files.length)
      throw new TypeError("no files or directories specified");
    files = Array.from(files);
    mtimeFilter(opt);
    return r(opt, files, cb);
  };
  var mtimeFilter = (opt) => {
    const filter = opt.filter;
    if (!opt.mtimeCache)
      opt.mtimeCache = new Map();
    opt.filter = filter ? (path10, stat) => filter(path10, stat) && !(opt.mtimeCache.get(path10) > stat.mtime) : (path10, stat) => !(opt.mtimeCache.get(path10) > stat.mtime);
  };
});

// ../../node_modules/.pnpm/chownr@2.0.0/node_modules/chownr/chownr.js
var require_chownr = __commonJS((exports2, module2) => {
  "use strict";
  var fs9 = require("fs");
  var path10 = require("path");
  var LCHOWN = fs9.lchown ? "lchown" : "chown";
  var LCHOWNSYNC = fs9.lchownSync ? "lchownSync" : "chownSync";
  var needEISDIRHandled = fs9.lchown && !process.version.match(/v1[1-9]+\./) && !process.version.match(/v10\.[6-9]/);
  var lchownSync = (path11, uid, gid) => {
    try {
      return fs9[LCHOWNSYNC](path11, uid, gid);
    } catch (er) {
      if (er.code !== "ENOENT")
        throw er;
    }
  };
  var chownSync = (path11, uid, gid) => {
    try {
      return fs9.chownSync(path11, uid, gid);
    } catch (er) {
      if (er.code !== "ENOENT")
        throw er;
    }
  };
  var handleEISDIR = needEISDIRHandled ? (path11, uid, gid, cb) => (er) => {
    if (!er || er.code !== "EISDIR")
      cb(er);
    else
      fs9.chown(path11, uid, gid, cb);
  } : (_2, __, ___, cb) => cb;
  var handleEISDirSync = needEISDIRHandled ? (path11, uid, gid) => {
    try {
      return lchownSync(path11, uid, gid);
    } catch (er) {
      if (er.code !== "EISDIR")
        throw er;
      chownSync(path11, uid, gid);
    }
  } : (path11, uid, gid) => lchownSync(path11, uid, gid);
  var nodeVersion = process.version;
  var readdir2 = (path11, options, cb) => fs9.readdir(path11, options, cb);
  var readdirSync = (path11, options) => fs9.readdirSync(path11, options);
  if (/^v4\./.test(nodeVersion))
    readdir2 = (path11, options, cb) => fs9.readdir(path11, cb);
  var chown = (cpath, uid, gid, cb) => {
    fs9[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, (er) => {
      cb(er && er.code !== "ENOENT" ? er : null);
    }));
  };
  var chownrKid = (p, child, uid, gid, cb) => {
    if (typeof child === "string")
      return fs9.lstat(path10.resolve(p, child), (er, stats) => {
        if (er)
          return cb(er.code !== "ENOENT" ? er : null);
        stats.name = child;
        chownrKid(p, stats, uid, gid, cb);
      });
    if (child.isDirectory()) {
      chownr(path10.resolve(p, child.name), uid, gid, (er) => {
        if (er)
          return cb(er);
        const cpath = path10.resolve(p, child.name);
        chown(cpath, uid, gid, cb);
      });
    } else {
      const cpath = path10.resolve(p, child.name);
      chown(cpath, uid, gid, cb);
    }
  };
  var chownr = (p, uid, gid, cb) => {
    readdir2(p, {withFileTypes: true}, (er, children) => {
      if (er) {
        if (er.code === "ENOENT")
          return cb();
        else if (er.code !== "ENOTDIR" && er.code !== "ENOTSUP")
          return cb(er);
      }
      if (er || !children.length)
        return chown(p, uid, gid, cb);
      let len = children.length;
      let errState = null;
      const then = (er2) => {
        if (errState)
          return;
        if (er2)
          return cb(errState = er2);
        if (--len === 0)
          return chown(p, uid, gid, cb);
      };
      children.forEach((child) => chownrKid(p, child, uid, gid, then));
    });
  };
  var chownrKidSync = (p, child, uid, gid) => {
    if (typeof child === "string") {
      try {
        const stats = fs9.lstatSync(path10.resolve(p, child));
        stats.name = child;
        child = stats;
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        else
          throw er;
      }
    }
    if (child.isDirectory())
      chownrSync(path10.resolve(p, child.name), uid, gid);
    handleEISDirSync(path10.resolve(p, child.name), uid, gid);
  };
  var chownrSync = (p, uid, gid) => {
    let children;
    try {
      children = readdirSync(p, {withFileTypes: true});
    } catch (er) {
      if (er.code === "ENOENT")
        return;
      else if (er.code === "ENOTDIR" || er.code === "ENOTSUP")
        return handleEISDirSync(p, uid, gid);
      else
        throw er;
    }
    if (children && children.length)
      children.forEach((child) => chownrKidSync(p, child, uid, gid));
    return handleEISDirSync(p, uid, gid);
  };
  module2.exports = chownr;
  chownr.sync = chownrSync;
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/mkdir.js
var require_mkdir = __commonJS((exports2, module2) => {
  "use strict";
  var mkdirp = require_mkdirp();
  var fs9 = require("fs");
  var path10 = require("path");
  var chownr = require_chownr();
  var normPath = require_normalize_windows_path();
  var SymlinkError = class extends Error {
    constructor(symlink, path11) {
      super("Cannot extract through symbolic link");
      this.path = path11;
      this.symlink = symlink;
    }
    get name() {
      return "SylinkError";
    }
  };
  var CwdError = class extends Error {
    constructor(path11, code) {
      super(code + ": Cannot cd into '" + path11 + "'");
      this.path = path11;
      this.code = code;
    }
    get name() {
      return "CwdError";
    }
  };
  var cGet = (cache, key) => cache.get(normPath(key));
  var cSet = (cache, key, val) => cache.set(normPath(key), val);
  var checkCwd = (dir, cb) => {
    fs9.stat(dir, (er, st) => {
      if (er || !st.isDirectory())
        er = new CwdError(dir, er && er.code || "ENOTDIR");
      cb(er);
    });
  };
  module2.exports = (dir, opt, cb) => {
    dir = normPath(dir);
    const umask = opt.umask;
    const mode = opt.mode | 448;
    const needChmod = (mode & umask) !== 0;
    const uid = opt.uid;
    const gid = opt.gid;
    const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
    const preserve = opt.preserve;
    const unlink2 = opt.unlink;
    const cache = opt.cache;
    const cwd = normPath(opt.cwd);
    const done = (er, created) => {
      if (er)
        cb(er);
      else {
        cSet(cache, dir, true);
        if (created && doChown)
          chownr(created, uid, gid, (er2) => done(er2));
        else if (needChmod)
          fs9.chmod(dir, mode, cb);
        else
          cb();
      }
    };
    if (cache && cGet(cache, dir) === true)
      return done();
    if (dir === cwd)
      return checkCwd(dir, done);
    if (preserve)
      return mkdirp(dir, {mode}).then((made) => done(null, made), done);
    const sub = normPath(path10.relative(cwd, dir));
    const parts = sub.split("/");
    mkdir_(cwd, parts, mode, cache, unlink2, cwd, null, done);
  };
  var mkdir_ = (base, parts, mode, cache, unlink2, cwd, created, cb) => {
    if (!parts.length)
      return cb(null, created);
    const p = parts.shift();
    const part = normPath(path10.resolve(base + "/" + p));
    if (cGet(cache, part))
      return mkdir_(part, parts, mode, cache, unlink2, cwd, created, cb);
    fs9.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink2, cwd, created, cb));
  };
  var onmkdir = (part, parts, mode, cache, unlink2, cwd, created, cb) => (er) => {
    if (er) {
      fs9.lstat(part, (statEr, st) => {
        if (statEr) {
          statEr.path = statEr.path && normPath(statEr.path);
          cb(statEr);
        } else if (st.isDirectory())
          mkdir_(part, parts, mode, cache, unlink2, cwd, created, cb);
        else if (unlink2) {
          fs9.unlink(part, (er2) => {
            if (er2)
              return cb(er2);
            fs9.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink2, cwd, created, cb));
          });
        } else if (st.isSymbolicLink())
          return cb(new SymlinkError(part, part + "/" + parts.join("/")));
        else
          cb(er);
      });
    } else {
      created = created || part;
      mkdir_(part, parts, mode, cache, unlink2, cwd, created, cb);
    }
  };
  var checkCwdSync = (dir) => {
    let ok = false;
    let code = "ENOTDIR";
    try {
      ok = fs9.statSync(dir).isDirectory();
    } catch (er) {
      code = er.code;
    } finally {
      if (!ok)
        throw new CwdError(dir, code);
    }
  };
  module2.exports.sync = (dir, opt) => {
    dir = normPath(dir);
    const umask = opt.umask;
    const mode = opt.mode | 448;
    const needChmod = (mode & umask) !== 0;
    const uid = opt.uid;
    const gid = opt.gid;
    const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
    const preserve = opt.preserve;
    const unlink2 = opt.unlink;
    const cache = opt.cache;
    const cwd = normPath(opt.cwd);
    const done = (created2) => {
      cSet(cache, dir, true);
      if (created2 && doChown)
        chownr.sync(created2, uid, gid);
      if (needChmod)
        fs9.chmodSync(dir, mode);
    };
    if (cache && cGet(cache, dir) === true)
      return done();
    if (dir === cwd) {
      checkCwdSync(cwd);
      return done();
    }
    if (preserve)
      return done(mkdirp.sync(dir, mode));
    const sub = normPath(path10.relative(cwd, dir));
    const parts = sub.split("/");
    let created = null;
    for (let p = parts.shift(), part = cwd; p && (part += "/" + p); p = parts.shift()) {
      part = normPath(path10.resolve(part));
      if (cGet(cache, part))
        continue;
      try {
        fs9.mkdirSync(part, mode);
        created = created || part;
        cSet(cache, part, true);
      } catch (er) {
        const st = fs9.lstatSync(part);
        if (st.isDirectory()) {
          cSet(cache, part, true);
          continue;
        } else if (unlink2) {
          fs9.unlinkSync(part);
          fs9.mkdirSync(part, mode);
          created = created || part;
          cSet(cache, part, true);
          continue;
        } else if (st.isSymbolicLink())
          return new SymlinkError(part, part + "/" + parts.join("/"));
      }
    }
    return done(created);
  };
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/path-reservations.js
var require_path_reservations = __commonJS((exports2, module2) => {
  var assert = require("assert");
  var normPath = require_normalize_windows_path();
  var {join: join2} = require("path");
  module2.exports = () => {
    const queues = new Map();
    const reservations = new Map();
    const getDirs = (path10) => path10.split("/").slice(0, -1).reduce((set, path11) => set.length ? set.concat(normPath(join2(set[set.length - 1], path11))) : [path11], []);
    const running = new Set();
    const getQueues = (fn) => {
      const res = reservations.get(fn);
      if (!res)
        throw new Error("function does not have any path reservations");
      return {
        paths: res.paths.map((path10) => queues.get(path10)),
        dirs: [...res.dirs].map((path10) => queues.get(path10))
      };
    };
    const check3 = (fn) => {
      const {paths, dirs} = getQueues(fn);
      return paths.every((q) => q[0] === fn) && dirs.every((q) => q[0] instanceof Set && q[0].has(fn));
    };
    const run = (fn) => {
      if (running.has(fn) || !check3(fn))
        return false;
      running.add(fn);
      fn(() => clear(fn));
      return true;
    };
    const clear = (fn) => {
      if (!running.has(fn))
        return false;
      const {paths, dirs} = reservations.get(fn);
      const next = new Set();
      paths.forEach((path10) => {
        const q = queues.get(path10);
        assert.equal(q[0], fn);
        if (q.length === 1)
          queues.delete(path10);
        else {
          q.shift();
          if (typeof q[0] === "function")
            next.add(q[0]);
          else
            q[0].forEach((fn2) => next.add(fn2));
        }
      });
      dirs.forEach((dir) => {
        const q = queues.get(dir);
        assert(q[0] instanceof Set);
        if (q[0].size === 1 && q.length === 1)
          queues.delete(dir);
        else if (q[0].size === 1) {
          q.shift();
          next.add(q[0]);
        } else
          q[0].delete(fn);
      });
      running.delete(fn);
      next.forEach((fn2) => run(fn2));
      return true;
    };
    const reserve = (paths, fn) => {
      paths = paths.map((p) => normPath(join2(p)).toLowerCase());
      const dirs = new Set(paths.map((path10) => getDirs(path10)).reduce((a, b) => a.concat(b)));
      reservations.set(fn, {dirs, paths});
      paths.forEach((path10) => {
        const q = queues.get(path10);
        if (!q)
          queues.set(path10, [fn]);
        else
          q.push(fn);
      });
      dirs.forEach((dir) => {
        const q = queues.get(dir);
        if (!q)
          queues.set(dir, [new Set([fn])]);
        else if (q[q.length - 1] instanceof Set)
          q[q.length - 1].add(fn);
        else
          q.push(new Set([fn]));
      });
      return run(fn);
    };
    return {check: check3, reserve};
  };
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/get-write-flag.js
var require_get_write_flag = __commonJS((exports2, module2) => {
  var platform = process.env.__FAKE_PLATFORM__ || process.platform;
  var isWindows = platform === "win32";
  var fs9 = global.__FAKE_TESTING_FS__ || require("fs");
  var {O_CREAT, O_TRUNC, O_WRONLY, UV_FS_O_FILEMAP = 0} = fs9.constants;
  var fMapEnabled = isWindows && !!UV_FS_O_FILEMAP;
  var fMapLimit = 512 * 1024;
  var fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY;
  module2.exports = !fMapEnabled ? () => "w" : (size) => size < fMapLimit ? fMapFlag : "w";
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/unpack.js
var require_unpack = __commonJS((exports2, module2) => {
  "use strict";
  var assert = require("assert");
  var Parser = require_parse5();
  var fs9 = require("fs");
  var fsm = require_fs_minipass();
  var path10 = require("path");
  var mkdir2 = require_mkdir();
  var wc = require_winchars();
  var pathReservations = require_path_reservations();
  var stripAbsolutePath = require_strip_absolute_path();
  var normPath = require_normalize_windows_path();
  var ONENTRY = Symbol("onEntry");
  var CHECKFS = Symbol("checkFs");
  var CHECKFS2 = Symbol("checkFs2");
  var ISREUSABLE = Symbol("isReusable");
  var MAKEFS = Symbol("makeFs");
  var FILE = Symbol("file");
  var DIRECTORY = Symbol("directory");
  var LINK = Symbol("link");
  var SYMLINK = Symbol("symlink");
  var HARDLINK = Symbol("hardlink");
  var UNSUPPORTED = Symbol("unsupported");
  var CHECKPATH = Symbol("checkPath");
  var MKDIR = Symbol("mkdir");
  var ONERROR = Symbol("onError");
  var PENDING = Symbol("pending");
  var PEND = Symbol("pend");
  var UNPEND = Symbol("unpend");
  var ENDED = Symbol("ended");
  var MAYBECLOSE = Symbol("maybeClose");
  var SKIP = Symbol("skip");
  var DOCHOWN = Symbol("doChown");
  var UID = Symbol("uid");
  var GID = Symbol("gid");
  var CHECKED_CWD = Symbol("checkedCwd");
  var crypto2 = require("crypto");
  var getFlag = require_get_write_flag();
  var unlinkFile = (path11, cb) => {
    if (process.platform !== "win32")
      return fs9.unlink(path11, cb);
    const name = path11 + ".DELETE." + crypto2.randomBytes(16).toString("hex");
    fs9.rename(path11, name, (er) => {
      if (er)
        return cb(er);
      fs9.unlink(name, cb);
    });
  };
  var unlinkFileSync = (path11) => {
    if (process.platform !== "win32")
      return fs9.unlinkSync(path11);
    const name = path11 + ".DELETE." + crypto2.randomBytes(16).toString("hex");
    fs9.renameSync(path11, name);
    fs9.unlinkSync(name);
  };
  var uint32 = (a, b, c) => a === a >>> 0 ? a : b === b >>> 0 ? b : c;
  var pruneCache = (cache, abs) => {
    abs = normPath(abs).toLowerCase();
    for (const path11 of cache.keys()) {
      const plower = path11.toLowerCase();
      if (plower === abs || plower.toLowerCase().indexOf(abs + "/") === 0)
        cache.delete(path11);
    }
  };
  var Unpack = class extends Parser {
    constructor(opt) {
      if (!opt)
        opt = {};
      opt.ondone = (_2) => {
        this[ENDED] = true;
        this[MAYBECLOSE]();
      };
      super(opt);
      this[CHECKED_CWD] = false;
      this.reservations = pathReservations();
      this.transform = typeof opt.transform === "function" ? opt.transform : null;
      this.writable = true;
      this.readable = false;
      this[PENDING] = 0;
      this[ENDED] = false;
      this.dirCache = opt.dirCache || new Map();
      if (typeof opt.uid === "number" || typeof opt.gid === "number") {
        if (typeof opt.uid !== "number" || typeof opt.gid !== "number")
          throw new TypeError("cannot set owner without number uid and gid");
        if (opt.preserveOwner) {
          throw new TypeError("cannot preserve owner in archive and also set owner explicitly");
        }
        this.uid = opt.uid;
        this.gid = opt.gid;
        this.setOwner = true;
      } else {
        this.uid = null;
        this.gid = null;
        this.setOwner = false;
      }
      if (opt.preserveOwner === void 0 && typeof opt.uid !== "number")
        this.preserveOwner = process.getuid && process.getuid() === 0;
      else
        this.preserveOwner = !!opt.preserveOwner;
      this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ? process.getuid() : null;
      this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ? process.getgid() : null;
      this.forceChown = opt.forceChown === true;
      this.win32 = !!opt.win32 || process.platform === "win32";
      this.newer = !!opt.newer;
      this.keep = !!opt.keep;
      this.noMtime = !!opt.noMtime;
      this.preservePaths = !!opt.preservePaths;
      this.unlink = !!opt.unlink;
      this.cwd = normPath(path10.resolve(opt.cwd || process.cwd()));
      this.strip = +opt.strip || 0;
      this.processUmask = opt.noChmod ? 0 : process.umask();
      this.umask = typeof opt.umask === "number" ? opt.umask : this.processUmask;
      this.dmode = opt.dmode || 511 & ~this.umask;
      this.fmode = opt.fmode || 438 & ~this.umask;
      this.on("entry", (entry) => this[ONENTRY](entry));
    }
    warn(code, msg, data = {}) {
      if (code === "TAR_BAD_ARCHIVE" || code === "TAR_ABORT")
        data.recoverable = false;
      return super.warn(code, msg, data);
    }
    [MAYBECLOSE]() {
      if (this[ENDED] && this[PENDING] === 0) {
        this.emit("prefinish");
        this.emit("finish");
        this.emit("end");
        this.emit("close");
      }
    }
    [CHECKPATH](entry) {
      if (this.strip) {
        const parts = normPath(entry.path).split("/");
        if (parts.length < this.strip)
          return false;
        entry.path = parts.slice(this.strip).join("/");
        if (entry.type === "Link") {
          const linkparts = normPath(entry.linkpath).split("/");
          if (linkparts.length >= this.strip)
            entry.linkpath = linkparts.slice(this.strip).join("/");
          else
            return false;
        }
      }
      if (!this.preservePaths) {
        const p = normPath(entry.path);
        if (p.split("/").includes("..")) {
          this.warn("TAR_ENTRY_ERROR", `path contains '..'`, {
            entry,
            path: p
          });
          return false;
        }
        const [root, stripped] = stripAbsolutePath(p);
        if (root) {
          entry.path = stripped;
          this.warn("TAR_ENTRY_INFO", `stripping ${root} from absolute path`, {
            entry,
            path: p
          });
        }
      }
      if (path10.isAbsolute(entry.path))
        entry.absolute = normPath(path10.resolve(entry.path));
      else
        entry.absolute = normPath(path10.resolve(this.cwd, entry.path));
      if (entry.absolute === this.cwd && entry.type !== "Directory" && entry.type !== "GNUDumpDir")
        return false;
      if (this.win32) {
        const {root: aRoot} = path10.win32.parse(entry.absolute);
        entry.absolute = aRoot + wc.encode(entry.absolute.substr(aRoot.length));
        const {root: pRoot} = path10.win32.parse(entry.path);
        entry.path = pRoot + wc.encode(entry.path.substr(pRoot.length));
      }
      return true;
    }
    [ONENTRY](entry) {
      if (!this[CHECKPATH](entry))
        return entry.resume();
      assert.equal(typeof entry.absolute, "string");
      switch (entry.type) {
        case "Directory":
        case "GNUDumpDir":
          if (entry.mode)
            entry.mode = entry.mode | 448;
        case "File":
        case "OldFile":
        case "ContiguousFile":
        case "Link":
        case "SymbolicLink":
          return this[CHECKFS](entry);
        case "CharacterDevice":
        case "BlockDevice":
        case "FIFO":
        default:
          return this[UNSUPPORTED](entry);
      }
    }
    [ONERROR](er, entry) {
      if (er.name === "CwdError")
        this.emit("error", er);
      else {
        this.warn("TAR_ENTRY_ERROR", er, {entry});
        this[UNPEND]();
        entry.resume();
      }
    }
    [MKDIR](dir, mode, cb) {
      mkdir2(normPath(dir), {
        uid: this.uid,
        gid: this.gid,
        processUid: this.processUid,
        processGid: this.processGid,
        umask: this.processUmask,
        preserve: this.preservePaths,
        unlink: this.unlink,
        cache: this.dirCache,
        cwd: this.cwd,
        mode,
        noChmod: this.noChmod
      }, cb);
    }
    [DOCHOWN](entry) {
      return this.forceChown || this.preserveOwner && (typeof entry.uid === "number" && entry.uid !== this.processUid || typeof entry.gid === "number" && entry.gid !== this.processGid) || (typeof this.uid === "number" && this.uid !== this.processUid || typeof this.gid === "number" && this.gid !== this.processGid);
    }
    [UID](entry) {
      return uint32(this.uid, entry.uid, this.processUid);
    }
    [GID](entry) {
      return uint32(this.gid, entry.gid, this.processGid);
    }
    [FILE](entry, fullyDone) {
      const mode = entry.mode & 4095 || this.fmode;
      const stream = new fsm.WriteStream(entry.absolute, {
        flags: getFlag(entry.size),
        mode,
        autoClose: false
      });
      stream.on("error", (er) => {
        if (stream.fd)
          fs9.close(stream.fd, () => {
          });
        stream.write = () => true;
        this[ONERROR](er, entry);
        fullyDone();
      });
      let actions = 1;
      const done = (er) => {
        if (er) {
          if (stream.fd)
            fs9.close(stream.fd, () => {
            });
          this[ONERROR](er, entry);
          fullyDone();
          return;
        }
        if (--actions === 0) {
          fs9.close(stream.fd, (er2) => {
            if (er2)
              this[ONERROR](er2, entry);
            else
              this[UNPEND]();
            fullyDone();
          });
        }
      };
      stream.on("finish", (_2) => {
        const abs = entry.absolute;
        const fd = stream.fd;
        if (entry.mtime && !this.noMtime) {
          actions++;
          const atime = entry.atime || new Date();
          const mtime = entry.mtime;
          fs9.futimes(fd, atime, mtime, (er) => er ? fs9.utimes(abs, atime, mtime, (er2) => done(er2 && er)) : done());
        }
        if (this[DOCHOWN](entry)) {
          actions++;
          const uid = this[UID](entry);
          const gid = this[GID](entry);
          fs9.fchown(fd, uid, gid, (er) => er ? fs9.chown(abs, uid, gid, (er2) => done(er2 && er)) : done());
        }
        done();
      });
      const tx = this.transform ? this.transform(entry) || entry : entry;
      if (tx !== entry) {
        tx.on("error", (er) => {
          this[ONERROR](er, entry);
          fullyDone();
        });
        entry.pipe(tx);
      }
      tx.pipe(stream);
    }
    [DIRECTORY](entry, fullyDone) {
      const mode = entry.mode & 4095 || this.dmode;
      this[MKDIR](entry.absolute, mode, (er) => {
        if (er) {
          this[ONERROR](er, entry);
          fullyDone();
          return;
        }
        let actions = 1;
        const done = (_2) => {
          if (--actions === 0) {
            fullyDone();
            this[UNPEND]();
            entry.resume();
          }
        };
        if (entry.mtime && !this.noMtime) {
          actions++;
          fs9.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done);
        }
        if (this[DOCHOWN](entry)) {
          actions++;
          fs9.chown(entry.absolute, this[UID](entry), this[GID](entry), done);
        }
        done();
      });
    }
    [UNSUPPORTED](entry) {
      entry.unsupported = true;
      this.warn("TAR_ENTRY_UNSUPPORTED", `unsupported entry type: ${entry.type}`, {entry});
      entry.resume();
    }
    [SYMLINK](entry, done) {
      this[LINK](entry, entry.linkpath, "symlink", done);
    }
    [HARDLINK](entry, done) {
      const linkpath = normPath(path10.resolve(this.cwd, entry.linkpath));
      this[LINK](entry, linkpath, "link", done);
    }
    [PEND]() {
      this[PENDING]++;
    }
    [UNPEND]() {
      this[PENDING]--;
      this[MAYBECLOSE]();
    }
    [SKIP](entry) {
      this[UNPEND]();
      entry.resume();
    }
    [ISREUSABLE](entry, st) {
      return entry.type === "File" && !this.unlink && st.isFile() && st.nlink <= 1 && process.platform !== "win32";
    }
    [CHECKFS](entry) {
      this[PEND]();
      const paths = [entry.path];
      if (entry.linkpath)
        paths.push(entry.linkpath);
      this.reservations.reserve(paths, (done) => this[CHECKFS2](entry, done));
    }
    [CHECKFS2](entry, done) {
      if (entry.type !== "Directory")
        pruneCache(this.dirCache, entry.absolute);
      const checkCwd = () => {
        this[MKDIR](this.cwd, this.dmode, (er) => {
          if (er) {
            this[ONERROR](er, entry);
            done();
            return;
          }
          this[CHECKED_CWD] = true;
          start();
        });
      };
      const start = () => {
        if (entry.absolute !== this.cwd) {
          const parent = normPath(path10.dirname(entry.absolute));
          if (parent !== this.cwd) {
            return this[MKDIR](parent, this.dmode, (er) => {
              if (er) {
                this[ONERROR](er, entry);
                done();
                return;
              }
              afterMakeParent();
            });
          }
        }
        afterMakeParent();
      };
      const afterMakeParent = () => {
        fs9.lstat(entry.absolute, (lstatEr, st) => {
          if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {
            this[SKIP](entry);
            done();
            return;
          }
          if (lstatEr || this[ISREUSABLE](entry, st))
            return this[MAKEFS](null, entry, done);
          if (st.isDirectory()) {
            if (entry.type === "Directory") {
              const needChmod = !this.noChmod && entry.mode && (st.mode & 4095) !== entry.mode;
              const afterChmod = (er) => this[MAKEFS](er, entry, done);
              if (!needChmod)
                return afterChmod();
              return fs9.chmod(entry.absolute, entry.mode, afterChmod);
            }
            if (entry.absolute !== this.cwd) {
              return fs9.rmdir(entry.absolute, (er) => this[MAKEFS](er, entry, done));
            }
          }
          if (entry.absolute === this.cwd)
            return this[MAKEFS](null, entry, done);
          unlinkFile(entry.absolute, (er) => this[MAKEFS](er, entry, done));
        });
      };
      if (this[CHECKED_CWD])
        start();
      else
        checkCwd();
    }
    [MAKEFS](er, entry, done) {
      if (er) {
        this[ONERROR](er, entry);
        done();
        return;
      }
      switch (entry.type) {
        case "File":
        case "OldFile":
        case "ContiguousFile":
          return this[FILE](entry, done);
        case "Link":
          return this[HARDLINK](entry, done);
        case "SymbolicLink":
          return this[SYMLINK](entry, done);
        case "Directory":
        case "GNUDumpDir":
          return this[DIRECTORY](entry, done);
      }
    }
    [LINK](entry, linkpath, link5, done) {
      fs9[link5](linkpath, entry.absolute, (er) => {
        if (er)
          this[ONERROR](er, entry);
        else {
          this[UNPEND]();
          entry.resume();
        }
        done();
      });
    }
  };
  var callSync = (fn) => {
    try {
      return [null, fn()];
    } catch (er) {
      return [er, null];
    }
  };
  var UnpackSync = class extends Unpack {
    [MAKEFS](er, entry) {
      return super[MAKEFS](er, entry, () => {
      });
    }
    [CHECKFS](entry) {
      if (entry.type !== "Directory")
        pruneCache(this.dirCache, entry.absolute);
      if (!this[CHECKED_CWD]) {
        const er2 = this[MKDIR](this.cwd, this.dmode);
        if (er2)
          return this[ONERROR](er2, entry);
        this[CHECKED_CWD] = true;
      }
      if (entry.absolute !== this.cwd) {
        const parent = normPath(path10.dirname(entry.absolute));
        if (parent !== this.cwd) {
          const mkParent = this[MKDIR](parent, this.dmode);
          if (mkParent)
            return this[ONERROR](mkParent, entry);
        }
      }
      const [lstatEr, st] = callSync(() => fs9.lstatSync(entry.absolute));
      if (st && (this.keep || this.newer && st.mtime > entry.mtime))
        return this[SKIP](entry);
      if (lstatEr || this[ISREUSABLE](entry, st))
        return this[MAKEFS](null, entry);
      if (st.isDirectory()) {
        if (entry.type === "Directory") {
          const needChmod = !this.noChmod && entry.mode && (st.mode & 4095) !== entry.mode;
          const [er3] = needChmod ? callSync(() => {
            fs9.chmodSync(entry.absolute, entry.mode);
          }) : [];
          return this[MAKEFS](er3, entry);
        }
        const [er2] = callSync(() => fs9.rmdirSync(entry.absolute));
        this[MAKEFS](er2, entry);
      }
      const [er] = entry.absolute === this.cwd ? [] : callSync(() => unlinkFileSync(entry.absolute));
      this[MAKEFS](er, entry);
    }
    [FILE](entry, _2) {
      const mode = entry.mode & 4095 || this.fmode;
      const oner = (er) => {
        let closeError;
        try {
          fs9.closeSync(fd);
        } catch (e) {
          closeError = e;
        }
        if (er || closeError)
          this[ONERROR](er || closeError, entry);
      };
      let fd;
      try {
        fd = fs9.openSync(entry.absolute, getFlag(entry.size), mode);
      } catch (er) {
        return oner(er);
      }
      const tx = this.transform ? this.transform(entry) || entry : entry;
      if (tx !== entry) {
        tx.on("error", (er) => this[ONERROR](er, entry));
        entry.pipe(tx);
      }
      tx.on("data", (chunk) => {
        try {
          fs9.writeSync(fd, chunk, 0, chunk.length);
        } catch (er) {
          oner(er);
        }
      });
      tx.on("end", (_3) => {
        let er = null;
        if (entry.mtime && !this.noMtime) {
          const atime = entry.atime || new Date();
          const mtime = entry.mtime;
          try {
            fs9.futimesSync(fd, atime, mtime);
          } catch (futimeser) {
            try {
              fs9.utimesSync(entry.absolute, atime, mtime);
            } catch (utimeser) {
              er = futimeser;
            }
          }
        }
        if (this[DOCHOWN](entry)) {
          const uid = this[UID](entry);
          const gid = this[GID](entry);
          try {
            fs9.fchownSync(fd, uid, gid);
          } catch (fchowner) {
            try {
              fs9.chownSync(entry.absolute, uid, gid);
            } catch (chowner) {
              er = er || fchowner;
            }
          }
        }
        oner(er);
      });
    }
    [DIRECTORY](entry, _2) {
      const mode = entry.mode & 4095 || this.dmode;
      const er = this[MKDIR](entry.absolute, mode);
      if (er)
        return this[ONERROR](er, entry);
      if (entry.mtime && !this.noMtime) {
        try {
          fs9.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime);
        } catch (er2) {
        }
      }
      if (this[DOCHOWN](entry)) {
        try {
          fs9.chownSync(entry.absolute, this[UID](entry), this[GID](entry));
        } catch (er2) {
        }
      }
      entry.resume();
    }
    [MKDIR](dir, mode) {
      try {
        return mkdir2.sync(normPath(dir), {
          uid: this.uid,
          gid: this.gid,
          processUid: this.processUid,
          processGid: this.processGid,
          umask: this.processUmask,
          preserve: this.preservePaths,
          unlink: this.unlink,
          cache: this.dirCache,
          cwd: this.cwd,
          mode
        });
      } catch (er) {
        return er;
      }
    }
    [LINK](entry, linkpath, link5, _2) {
      try {
        fs9[link5 + "Sync"](linkpath, entry.absolute);
        entry.resume();
      } catch (er) {
        return this[ONERROR](er, entry);
      }
    }
  };
  Unpack.Sync = UnpackSync;
  module2.exports = Unpack;
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/extract.js
var require_extract = __commonJS((exports2, module2) => {
  "use strict";
  var hlo = require_high_level_opt();
  var Unpack = require_unpack();
  var fs9 = require("fs");
  var fsm = require_fs_minipass();
  var path10 = require("path");
  var stripSlash = require_strip_trailing_slashes();
  module2.exports = (opt_, files, cb) => {
    if (typeof opt_ === "function")
      cb = opt_, files = null, opt_ = {};
    else if (Array.isArray(opt_))
      files = opt_, opt_ = {};
    if (typeof files === "function")
      cb = files, files = null;
    if (!files)
      files = [];
    else
      files = Array.from(files);
    const opt = hlo(opt_);
    if (opt.sync && typeof cb === "function")
      throw new TypeError("callback not supported for sync tar functions");
    if (!opt.file && typeof cb === "function")
      throw new TypeError("callback only supported with file option");
    if (files.length)
      filesFilter(opt, files);
    return opt.file && opt.sync ? extractFileSync(opt) : opt.file ? extractFile(opt, cb) : opt.sync ? extractSync(opt) : extract(opt);
  };
  var filesFilter = (opt, files) => {
    const map = new Map(files.map((f) => [stripSlash(f), true]));
    const filter = opt.filter;
    const mapHas = (file, r) => {
      const root = r || path10.parse(file).root || ".";
      const ret = file === root ? false : map.has(file) ? map.get(file) : mapHas(path10.dirname(file), root);
      map.set(file, ret);
      return ret;
    };
    opt.filter = filter ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file)) : (file) => mapHas(stripSlash(file));
  };
  var extractFileSync = (opt) => {
    const u = new Unpack.Sync(opt);
    const file = opt.file;
    const stat = fs9.statSync(file);
    const readSize = opt.maxReadSize || 16 * 1024 * 1024;
    const stream = new fsm.ReadStreamSync(file, {
      readSize,
      size: stat.size
    });
    stream.pipe(u);
  };
  var extractFile = (opt, cb) => {
    const u = new Unpack(opt);
    const readSize = opt.maxReadSize || 16 * 1024 * 1024;
    const file = opt.file;
    const p = new Promise((resolve, reject) => {
      u.on("error", reject);
      u.on("close", resolve);
      fs9.stat(file, (er, stat) => {
        if (er)
          reject(er);
        else {
          const stream = new fsm.ReadStream(file, {
            readSize,
            size: stat.size
          });
          stream.on("error", reject);
          stream.pipe(u);
        }
      });
    });
    return cb ? p.then(cb, cb) : p;
  };
  var extractSync = (opt) => new Unpack.Sync(opt);
  var extract = (opt) => new Unpack(opt);
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/index.js
var require_tar = __commonJS((exports2) => {
  "use strict";
  exports2.c = exports2.create = require_create();
  exports2.r = exports2.replace = require_replace();
  exports2.t = exports2.list = require_list();
  exports2.u = exports2.update = require_update();
  exports2.x = exports2.extract = require_extract();
  exports2.Pack = require_pack();
  exports2.Unpack = require_unpack();
  exports2.Parse = require_parse5();
  exports2.ReadEntry = require_read_entry();
  exports2.WriteEntry = require_write_entry();
  exports2.Header = require_header();
  exports2.Pax = require_pax();
  exports2.types = require_types3();
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/utils/hasYarn.js
var require_hasYarn = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    hasYarn: () => hasYarn
  });
  var import_execa2 = __toModule3(require_execa());
  async function hasYarn(packageDir) {
    try {
      await import_execa2.default.command("yarn --version", {
        shell: true,
        cwd: packageDir
      });
      return true;
    } catch (e) {
      return false;
    }
  }
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/getPackedPackage.js
var require_getPackedPackage = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    getPackedPackage: () => getPackedPackage2
  });
  var import_copy = __toModule3(require_copy());
  var import_execa2 = __toModule3(require_execa());
  var import_fs9 = __toModule3(require("fs"));
  var import_make_dir2 = __toModule3(require_make_dir());
  var import_path10 = __toModule3(require("path"));
  var import_read_pkg_up = __toModule3(require_read_pkg_up());
  var import_resolve = __toModule3(require_resolve2());
  var import_rimraf = __toModule3(require_rimraf());
  var import_shell_quote = __toModule3(require_shell_quote());
  var import_tar = __toModule3(require_tar());
  var import_tempy = __toModule3(require_tempy());
  var import_util6 = __toModule3(require("util"));
  var import_hasYarn = __toModule3(require_hasYarn());
  var del = (0, import_util6.promisify)(import_rimraf.default);
  var readdir2 = (0, import_util6.promisify)(import_fs9.default.readdir);
  var rename2 = (0, import_util6.promisify)(import_fs9.default.rename);
  async function getPackedPackage2(name, target, packageDir) {
    packageDir = packageDir || await (0, import_resolve.resolvePkg)(name, {basedir: process.cwd()}) || await (0, import_resolve.resolvePkg)(name, {basedir: target});
    if (!packageDir) {
      const pkg2 = await (0, import_read_pkg_up.default)({
        cwd: target
      });
      if (pkg2 && pkg2.packageJson.name === name) {
        packageDir = import_path10.default.dirname(pkg2.path);
      }
    }
    if (!packageDir && import_fs9.default.existsSync(import_path10.default.join(process.cwd(), "package.json"))) {
      packageDir = process.cwd();
    }
    if (!packageDir) {
      throw new Error(`Error in getPackage: Could not resolve package ${name} from ${__dirname}`);
    }
    const tmpDir = import_tempy.default.directory();
    const archivePath = import_path10.default.join(tmpDir, `package.tgz`);
    const isYarn = await (0, import_hasYarn.hasYarn)(packageDir);
    const packCmd = isYarn ? ["yarn", "pack", "-f", archivePath] : ["npm", "pack", packageDir];
    const escapedCmd = (0, import_shell_quote.quote)(packCmd);
    await import_execa2.default.command(escapedCmd, {
      shell: true,
      cwd: isYarn ? packageDir : tmpDir
    });
    if (!isYarn) {
      const filename = (await readdir2(tmpDir))[0];
      await rename2(import_path10.default.join(tmpDir, filename), archivePath);
    }
    await import_tar.default.extract({
      cwd: tmpDir,
      file: archivePath
    });
    await del(archivePath);
    if (target) {
      await (0, import_make_dir2.default)(target);
      await (0, import_copy.default)({
        from: import_path10.default.join(tmpDir, "package"),
        to: target,
        recursive: true,
        parallelJobs: 20,
        overwrite: true
      });
      await del(tmpDir);
    }
    return import_path10.default.join(tmpDir, "package");
  }
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/panic.js
var require_panic = __commonJS((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    ErrorArea: () => ErrorArea2,
    RustPanic: () => RustPanic2
  });
  var RustPanic2 = class extends Error {
    constructor(message, rustStack, request, area, schemaPath, schema, introspectionUrl) {
      super(message);
      this.rustStack = rustStack;
      this.request = request;
      this.area = area;
      this.schemaPath = schemaPath;
      this.schema = schema;
      this.introspectionUrl = introspectionUrl;
    }
  };
  var ErrorArea2;
  (function(ErrorArea22) {
    ErrorArea22["LIFT_CLI"] = "LIFT_CLI";
    ErrorArea22["PHOTON_STUDIO"] = "PHOTON_STUDIO";
    ErrorArea22["INTROSPECTION_CLI"] = "INTROSPECTION_CLI";
  })(ErrorArea2 || (ErrorArea2 = {}));
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/utils/byline.js
var require_byline3 = __commonJS((exports2, module2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    createLineStream: () => createLineStream,
    default: () => byline2
  });
  var stream = require("stream");
  var util2 = require("util");
  function byline2(readStream, options) {
    return module2.exports.createStream(readStream, options);
  }
  module2.exports.createStream = function(readStream, options) {
    if (readStream) {
      return createLineStream(readStream, options);
    } else {
      return new LineStream(options);
    }
  };
  function createLineStream(readStream, options) {
    if (!readStream) {
      throw new Error("expected readStream");
    }
    if (!readStream.readable) {
      throw new Error("readStream must be readable");
    }
    const ls = new LineStream(options);
    readStream.pipe(ls);
    return ls;
  }
  module2.exports.LineStream = LineStream;
  function LineStream(options) {
    stream.Transform.call(this, options);
    options = options || {};
    this._readableState.objectMode = true;
    this._lineBuffer = [];
    this._keepEmptyLines = options.keepEmptyLines || false;
    this._lastChunkEndedWithCR = false;
    this.on("pipe", function(src) {
      if (!this.encoding) {
        if (src instanceof stream.Readable) {
          this.encoding = src._readableState.encoding;
        }
      }
    });
  }
  util2.inherits(LineStream, stream.Transform);
  LineStream.prototype._transform = function(chunk, encoding, done) {
    encoding = encoding || "utf8";
    if (Buffer.isBuffer(chunk)) {
      if (encoding == "buffer") {
        chunk = chunk.toString();
        encoding = "utf8";
      } else {
        chunk = chunk.toString(encoding);
      }
    }
    this._chunkEncoding = encoding;
    const lines = chunk.split(/\r\n|\r|\n/g);
    if (this._lastChunkEndedWithCR && chunk[0] == "\n") {
      lines.shift();
    }
    if (this._lineBuffer.length > 0) {
      this._lineBuffer[this._lineBuffer.length - 1] += lines[0];
      lines.shift();
    }
    this._lastChunkEndedWithCR = chunk[chunk.length - 1] == "\r";
    this._lineBuffer = this._lineBuffer.concat(lines);
    this._pushBuffer(encoding, 1, done);
  };
  LineStream.prototype._pushBuffer = function(encoding, keep, done) {
    while (this._lineBuffer.length > keep) {
      const line = this._lineBuffer.shift();
      if (this._keepEmptyLines || line.length > 0) {
        if (!this.push(this._reencode(line, encoding))) {
          const self2 = this;
          setImmediate(function() {
            self2._pushBuffer(encoding, keep, done);
          });
          return;
        }
      }
    }
    done();
  };
  LineStream.prototype._flush = function(done) {
    this._pushBuffer(this._chunkEncoding, 0, done);
  };
  LineStream.prototype._reencode = function(line, chunkEncoding) {
    if (this.encoding && this.encoding != chunkEncoding) {
      return Buffer.from(line, chunkEncoding).toString(this.encoding);
    } else if (this.encoding) {
      return line;
    } else {
      return Buffer.from(line, chunkEncoding);
    }
  };
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/IntrospectionEngine.js
var require_IntrospectionEngine = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    IntrospectionEngine: () => IntrospectionEngine3,
    IntrospectionError: () => IntrospectionError,
    IntrospectionPanic: () => IntrospectionPanic
  });
  var import_debug3 = __toModule3(require_dist2());
  var import_fetch_engine2 = __toModule3(require_dist8());
  var import_chalk14 = __toModule3(require_source());
  var import_child_process2 = __toModule3(require("child_process"));
  var import_panic = __toModule3(require_panic());
  var import_resolveBinary = __toModule3(require_resolveBinary());
  var import_byline2 = __toModule3(require_byline3());
  var debugCli = (0, import_debug3.default)("prisma:introspectionEngine:cli");
  var debugRpc = (0, import_debug3.default)("prisma:introspectionEngine:rpc");
  var debugStderr = (0, import_debug3.default)("prisma:introspectionEngine:stderr");
  var debugStdin = (0, import_debug3.default)("prisma:introspectionEngine:stdin");
  var IntrospectionPanic = class extends Error {
    constructor(message, rustStack, request) {
      super(message);
      this.rustStack = rustStack;
      this.request = request;
    }
  };
  var IntrospectionError = class extends Error {
    constructor(message, code) {
      super(message);
      this.code = code;
    }
  };
  var messageId = 1;
  var IntrospectionEngine3 = class {
    constructor({debug: debug3, cwd} = {
      debug: false,
      cwd: process.cwd()
    }) {
      this.listeners = {};
      this.messages = [];
      this.isRunning = false;
      if (debug3) {
        import_debug3.default.enable("IntrospectionEngine*");
      }
      this.debug = Boolean(debug3);
      this.cwd = cwd || process.cwd();
    }
    stop() {
      if (this.child) {
        this.child.kill();
        this.isRunning = false;
      }
    }
    rejectAll(err) {
      Object.entries(this.listeners).map(([id, listener]) => {
        listener(null, err);
        delete this.listeners[id];
      });
    }
    registerCallback(id, callback) {
      this.listeners[id] = callback;
    }
    getDatabaseDescription(schema) {
      return this.runCommand(this.getRPCPayload("getDatabaseDescription", {schema}));
    }
    getDatabaseVersion(schema) {
      return this.runCommand(this.getRPCPayload("getDatabaseVersion", {schema}));
    }
    introspect(schema, force) {
      this.lastUrl = schema;
      return this.runCommand(this.getRPCPayload("introspect", {schema, force}));
    }
    debugPanic() {
      return this.runCommand(this.getRPCPayload("debugPanic", void 0));
    }
    listDatabases(schema) {
      this.lastUrl = schema;
      return this.runCommand(this.getRPCPayload("listDatabases", {schema}));
    }
    getDatabaseMetadata(schema) {
      this.lastUrl = schema;
      return this.runCommand(this.getRPCPayload("getDatabaseMetadata", {schema}));
    }
    handleResponse(response) {
      let result;
      try {
        result = JSON.parse(response);
      } catch (e) {
        console.error(`Could not parse introspection engine response: ${response.slice(0, 200)}`);
      }
      if (result) {
        if (result.backtrace) {
          console.log(result);
        }
        if (!result.id) {
          console.error(`Response ${JSON.stringify(result)} doesn't have an id and I can't handle that (yet)`);
        }
        if (!this.listeners[result.id]) {
          console.error(`Got result for unknown id ${result.id}`);
        }
        if (this.listeners[result.id]) {
          this.listeners[result.id](result);
          delete this.listeners[result.id];
        }
      }
    }
    init() {
      if (!this.initPromise) {
        this.initPromise = this.internalInit();
      }
      return this.initPromise;
    }
    internalInit() {
      return new Promise(async (resolve, reject) => {
        var _a, _b;
        try {
          const binaryPath = await (0, import_resolveBinary.resolveBinary)(import_fetch_engine2.BinaryType.introspectionEngine);
          debugRpc("starting introspection engine with binary: " + binaryPath);
          this.child = (0, import_child_process2.spawn)(binaryPath, {
            env: process.env,
            cwd: this.cwd,
            stdio: ["pipe", "pipe", "pipe"]
          });
          this.isRunning = true;
          this.child.on("error", (err) => {
            var _a2;
            console.error("[introspection-engine] error: %s", err);
            (_a2 = this.child) == null ? void 0 : _a2.kill();
            this.rejectAll(err);
            reject(err);
          });
          (_a = this.child.stdin) == null ? void 0 : _a.on("error", (err) => {
            var _a2;
            console.error(err);
            (_a2 = this.child) == null ? void 0 : _a2.kill();
          });
          this.child.on("exit", (code) => {
            this.isRunning = false;
            if (code === 255 && this.lastError && this.lastError.is_panic) {
              const err2 = new import_panic.RustPanic(this.lastError.message, this.lastError.backtrace, this.lastRequest, import_panic.ErrorArea.INTROSPECTION_CLI, void 0, this.lastUrl);
              this.rejectAll(err2);
              reject(err2);
              return;
            }
            const messages = this.messages.join("\n");
            let err;
            if (code !== 0 || messages.includes("panicked at")) {
              let errorMessage = import_chalk14.default.red.bold("Error in introspection engine: ") + messages;
              if (this.lastError && this.lastError.msg === "PANIC") {
                errorMessage = serializePanic(this.lastError);
                err = new IntrospectionPanic(errorMessage, messages, this.lastRequest);
              } else if (messages.includes("panicked at")) {
                err = new IntrospectionPanic(errorMessage, messages, this.lastRequest);
              }
              err = err || new Error(errorMessage);
              this.rejectAll(err);
              reject(err);
            }
          });
          this.child.stdin.on("error", (err) => {
            debugStdin(err);
          });
          (0, import_byline2.default)(this.child.stderr).on("data", (data) => {
            const msg = String(data);
            this.messages.push(msg);
            debugStderr(msg);
            try {
              const json = JSON.parse(msg);
              if (json.backtrace) {
                this.lastError = json;
              }
              if (json.level === "ERRO") {
                this.lastError = json;
              }
            } catch (e) {
              debugCli(e);
            }
          });
          (0, import_byline2.default)(this.child.stdout).on("data", (line) => {
            this.handleResponse(String(line));
          });
          setImmediate(() => {
            resolve();
          });
        } catch (e) {
          (_b = this.child) == null ? void 0 : _b.kill();
          reject(e);
        }
      });
    }
    async runCommand(request) {
      var _a;
      await this.init();
      if (process.env.FORCE_PANIC_INTROSPECTION_ENGINE) {
        request = this.getRPCPayload("debugPanic", void 0);
      }
      if ((_a = this.child) == null ? void 0 : _a.killed) {
        throw new Error(`Can't execute ${JSON.stringify(request)} because introspection engine already exited.`);
      }
      return new Promise((resolve, reject) => {
        this.registerCallback(request.id, (response, err) => {
          var _a2, _b, _c, _d, _e, _f, _g;
          if (err) {
            return reject(err);
          }
          if (typeof response.result !== "undefined") {
            resolve(response.result);
          } else {
            if (response.error) {
              (_a2 = this.child) == null ? void 0 : _a2.kill();
              debugRpc(response);
              if ((_b = response.error.data) == null ? void 0 : _b.is_panic) {
                const message = (_e = (_d = (_c = response.error.data) == null ? void 0 : _c.error) == null ? void 0 : _d.message) != null ? _e : response.error.message;
                reject(new import_panic.RustPanic(message, message, request, import_panic.ErrorArea.INTROSPECTION_CLI, void 0, this.lastUrl));
              } else if ((_f = response.error.data) == null ? void 0 : _f.message) {
                let message = `${import_chalk14.default.redBright(response.error.data.message)}
`;
                if ((_g = response.error.data) == null ? void 0 : _g.error_code) {
                  message = import_chalk14.default.redBright(`${response.error.data.error_code}

`) + message;
                  reject(new IntrospectionError(message, response.error.data.error_code));
                } else {
                  reject(new Error(message));
                }
              } else {
                reject(new Error(`${import_chalk14.default.redBright("Error in RPC")}
 Request: ${JSON.stringify(request, null, 2)}
Response: ${JSON.stringify(response, null, 2)}
${response.error.message}
`));
              }
            } else {
              reject(new Error(`Got invalid RPC response without .result property: ${JSON.stringify(response)}`));
            }
          }
        });
        if (this.child.stdin.destroyed) {
          throw new Error(`Can't execute ${JSON.stringify(request)} because introspection engine is destroyed.`);
        }
        debugRpc("SENDING RPC CALL", JSON.stringify(request));
        this.child.stdin.write(JSON.stringify(request) + "\n");
        this.lastRequest = request;
      });
    }
    getRPCPayload(method, params) {
      return {
        id: messageId++,
        jsonrpc: "2.0",
        method,
        params: params ? [{...params}] : void 0
      };
    }
  };
  function serializePanic(log2) {
    return `${import_chalk14.default.red.bold("Error in introspection engine.\nReason: ")}${import_chalk14.default.red(`${log2.reason} in ${import_chalk14.default.underline(`${log2.file}:${log2.line}:${log2.column}`)}`)}

Please create an issue in the ${import_chalk14.default.bold("prisma")} repo with the error \u{1F64F}:
${import_chalk14.default.underline("https://github.com/prisma/prisma/issues/new")}
`;
  }
});

// ../../node_modules/.pnpm/ci-info@3.2.0/node_modules/ci-info/vendors.json
var require_vendors = __commonJS((exports2, module2) => {
  module2.exports = [
    {
      name: "AppVeyor",
      constant: "APPVEYOR",
      env: "APPVEYOR",
      pr: "APPVEYOR_PULL_REQUEST_NUMBER"
    },
    {
      name: "Azure Pipelines",
      constant: "AZURE_PIPELINES",
      env: "SYSTEM_TEAMFOUNDATIONCOLLECTIONURI",
      pr: "SYSTEM_PULLREQUEST_PULLREQUESTID"
    },
    {
      name: "Appcircle",
      constant: "APPCIRCLE",
      env: "AC_APPCIRCLE"
    },
    {
      name: "Bamboo",
      constant: "BAMBOO",
      env: "bamboo_planKey"
    },
    {
      name: "Bitbucket Pipelines",
      constant: "BITBUCKET",
      env: "BITBUCKET_COMMIT",
      pr: "BITBUCKET_PR_ID"
    },
    {
      name: "Bitrise",
      constant: "BITRISE",
      env: "BITRISE_IO",
      pr: "BITRISE_PULL_REQUEST"
    },
    {
      name: "Buddy",
      constant: "BUDDY",
      env: "BUDDY_WORKSPACE_ID",
      pr: "BUDDY_EXECUTION_PULL_REQUEST_ID"
    },
    {
      name: "Buildkite",
      constant: "BUILDKITE",
      env: "BUILDKITE",
      pr: {env: "BUILDKITE_PULL_REQUEST", ne: "false"}
    },
    {
      name: "CircleCI",
      constant: "CIRCLE",
      env: "CIRCLECI",
      pr: "CIRCLE_PULL_REQUEST"
    },
    {
      name: "Cirrus CI",
      constant: "CIRRUS",
      env: "CIRRUS_CI",
      pr: "CIRRUS_PR"
    },
    {
      name: "AWS CodeBuild",
      constant: "CODEBUILD",
      env: "CODEBUILD_BUILD_ARN"
    },
    {
      name: "Codefresh",
      constant: "CODEFRESH",
      env: "CF_BUILD_ID",
      pr: {any: ["CF_PULL_REQUEST_NUMBER", "CF_PULL_REQUEST_ID"]}
    },
    {
      name: "Codeship",
      constant: "CODESHIP",
      env: {CI_NAME: "codeship"}
    },
    {
      name: "Drone",
      constant: "DRONE",
      env: "DRONE",
      pr: {DRONE_BUILD_EVENT: "pull_request"}
    },
    {
      name: "dsari",
      constant: "DSARI",
      env: "DSARI"
    },
    {
      name: "GitHub Actions",
      constant: "GITHUB_ACTIONS",
      env: "GITHUB_ACTIONS",
      pr: {GITHUB_EVENT_NAME: "pull_request"}
    },
    {
      name: "GitLab CI",
      constant: "GITLAB",
      env: "GITLAB_CI",
      pr: "CI_MERGE_REQUEST_ID"
    },
    {
      name: "GoCD",
      constant: "GOCD",
      env: "GO_PIPELINE_LABEL"
    },
    {
      name: "LayerCI",
      constant: "LAYERCI",
      env: "LAYERCI",
      pr: "LAYERCI_PULL_REQUEST"
    },
    {
      name: "Hudson",
      constant: "HUDSON",
      env: "HUDSON_URL"
    },
    {
      name: "Jenkins",
      constant: "JENKINS",
      env: ["JENKINS_URL", "BUILD_ID"],
      pr: {any: ["ghprbPullId", "CHANGE_ID"]}
    },
    {
      name: "Magnum CI",
      constant: "MAGNUM",
      env: "MAGNUM"
    },
    {
      name: "Netlify CI",
      constant: "NETLIFY",
      env: "NETLIFY",
      pr: {env: "PULL_REQUEST", ne: "false"}
    },
    {
      name: "Nevercode",
      constant: "NEVERCODE",
      env: "NEVERCODE",
      pr: {env: "NEVERCODE_PULL_REQUEST", ne: "false"}
    },
    {
      name: "Render",
      constant: "RENDER",
      env: "RENDER",
      pr: {IS_PULL_REQUEST: "true"}
    },
    {
      name: "Sail CI",
      constant: "SAIL",
      env: "SAILCI",
      pr: "SAIL_PULL_REQUEST_NUMBER"
    },
    {
      name: "Semaphore",
      constant: "SEMAPHORE",
      env: "SEMAPHORE",
      pr: "PULL_REQUEST_NUMBER"
    },
    {
      name: "Screwdriver",
      constant: "SCREWDRIVER",
      env: "SCREWDRIVER",
      pr: {env: "SD_PULL_REQUEST", ne: "false"}
    },
    {
      name: "Shippable",
      constant: "SHIPPABLE",
      env: "SHIPPABLE",
      pr: {IS_PULL_REQUEST: "true"}
    },
    {
      name: "Solano CI",
      constant: "SOLANO",
      env: "TDDIUM",
      pr: "TDDIUM_PR_ID"
    },
    {
      name: "Strider CD",
      constant: "STRIDER",
      env: "STRIDER"
    },
    {
      name: "TaskCluster",
      constant: "TASKCLUSTER",
      env: ["TASK_ID", "RUN_ID"]
    },
    {
      name: "TeamCity",
      constant: "TEAMCITY",
      env: "TEAMCITY_VERSION"
    },
    {
      name: "Travis CI",
      constant: "TRAVIS",
      env: "TRAVIS",
      pr: {env: "TRAVIS_PULL_REQUEST", ne: "false"}
    },
    {
      name: "Vercel",
      constant: "VERCEL",
      env: "NOW_BUILDER"
    },
    {
      name: "Visual Studio App Center",
      constant: "APPCENTER",
      env: "APPCENTER_BUILD_ID"
    }
  ];
});

// ../../node_modules/.pnpm/ci-info@3.2.0/node_modules/ci-info/index.js
var require_ci_info = __commonJS((exports2) => {
  "use strict";
  var vendors = require_vendors();
  var env2 = process.env;
  Object.defineProperty(exports2, "_vendors", {
    value: vendors.map(function(v) {
      return v.constant;
    })
  });
  exports2.name = null;
  exports2.isPR = null;
  vendors.forEach(function(vendor) {
    const envs = Array.isArray(vendor.env) ? vendor.env : [vendor.env];
    const isCI = envs.every(function(obj) {
      return checkEnv(obj);
    });
    exports2[vendor.constant] = isCI;
    if (isCI) {
      exports2.name = vendor.name;
      switch (typeof vendor.pr) {
        case "string":
          exports2.isPR = !!env2[vendor.pr];
          break;
        case "object":
          if ("env" in vendor.pr) {
            exports2.isPR = vendor.pr.env in env2 && env2[vendor.pr.env] !== vendor.pr.ne;
          } else if ("any" in vendor.pr) {
            exports2.isPR = vendor.pr.any.some(function(key) {
              return !!env2[key];
            });
          } else {
            exports2.isPR = checkEnv(vendor.pr);
          }
          break;
        default:
          exports2.isPR = null;
      }
    }
  });
  exports2.isCI = !!(env2.CI || env2.CONTINUOUS_INTEGRATION || env2.BUILD_NUMBER || env2.RUN_ID || exports2.name || false);
  function checkEnv(obj) {
    if (typeof obj === "string")
      return !!env2[obj];
    return Object.keys(obj).every(function(k) {
      return env2[k] === obj[k];
    });
  }
});

// ../../node_modules/.pnpm/is-ci@3.0.0/node_modules/is-ci/index.js
var require_is_ci = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = require_ci_info().isCI;
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/isCi.js
var require_isCi = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    isCi: () => isCi2
  });
  var import_is_ci = __toModule3(require_is_ci());
  var isCi2 = () => {
    return !process.stdout.isTTY || import_is_ci.isCi || Boolean(process.env.GITHUB_ACTIONS);
  };
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/keyBy.js
var require_keyBy = __commonJS((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    keyBy: () => keyBy3
  });
  var keyBy3 = (collection, iteratee) => {
    return collection.reduce((acc, curr) => {
      acc[iteratee(curr)] = curr;
      return acc;
    }, {});
  };
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/logger.js
var require_logger = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    error: () => error,
    info: () => info,
    log: () => log2,
    query: () => query,
    should: () => should,
    tags: () => tags,
    warn: () => warn
  });
  var import_chalk14 = __toModule3(require_source());
  var tags = {
    error: import_chalk14.default.red("prisma:error"),
    warn: import_chalk14.default.yellow("prisma:warn"),
    info: import_chalk14.default.cyan("prisma:info"),
    query: import_chalk14.default.blue("prisma:query")
  };
  var should = {
    warn: !process.env.PRISMA_DISABLE_WARNINGS
  };
  function log2(...data) {
    console.log(...data);
  }
  function warn(message, ...optionalParams) {
    if (should.warn) {
      console.warn(`${tags.warn} ${message}`, ...optionalParams);
    }
  }
  function info(message, ...optionalParams) {
    console.info(`${tags.info} ${message}`, ...optionalParams);
  }
  function error(message, ...optionalParams) {
    console.error(`${tags.error} ${message}`, ...optionalParams);
  }
  function query(message, ...optionalParams) {
    console.log(`${tags.query} ${message}`, ...optionalParams);
  }
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/migrateEngineCommands.js
var require_migrateEngineCommands = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    MigrateEngineExitCode: () => MigrateEngineExitCode2,
    canConnectToDatabase: () => canConnectToDatabase4,
    createDatabase: () => createDatabase2,
    doesSqliteDbExist: () => doesSqliteDbExist,
    dropDatabase: () => dropDatabase2,
    execaCommand: () => execaCommand
  });
  var import_fetch_engine2 = __toModule3(require_dist8());
  var import_execa2 = __toModule3(require_execa());
  var import_fs9 = __toModule3(require("fs"));
  var import_path10 = __toModule3(require("path"));
  var import_util6 = __toModule3(require("util"));
  var import_getSchema = __toModule3(require_getSchema());
  var import_convertCredentials2 = __toModule3(require_convertCredentials());
  var import_resolveBinary = __toModule3(require_resolveBinary());
  var exists2 = (0, import_util6.promisify)(import_fs9.default.exists);
  var MigrateEngineExitCode2;
  (function(MigrateEngineExitCode22) {
    MigrateEngineExitCode22[MigrateEngineExitCode22["Success"] = 0] = "Success";
    MigrateEngineExitCode22[MigrateEngineExitCode22["Error"] = 1] = "Error";
    MigrateEngineExitCode22[MigrateEngineExitCode22["Panic"] = 101] = "Panic";
  })(MigrateEngineExitCode2 || (MigrateEngineExitCode2 = {}));
  function parseJsonFromStderr(stderr) {
    const lines = stderr.split(/\r?\n/).slice(1);
    const logs = [];
    for (const line of lines) {
      const data = String(line);
      try {
        const json = JSON.parse(data);
        logs.push(json);
      } catch (e) {
        throw new Error(`Could not parse migration engine response: ${e}`);
      }
    }
    return logs;
  }
  async function canConnectToDatabase4(connectionString, cwd = process.cwd(), migrationEnginePath) {
    if (!connectionString) {
      throw new Error("Connection url is empty. See https://www.prisma.io/docs/reference/database-reference/connection-urls");
    }
    const provider = (0, import_convertCredentials2.protocolToConnectorType)(`${connectionString.split(":")[0]}:`);
    if (provider === "sqlite") {
      const sqliteExists = await doesSqliteDbExist(connectionString, cwd);
      if (sqliteExists) {
        return true;
      } else {
        return {
          code: "P1003",
          message: "SQLite database file doesn't exist"
        };
      }
    }
    try {
      await execaCommand({
        connectionString,
        cwd,
        migrationEnginePath,
        engineCommandName: "can-connect-to-database"
      });
    } catch (e) {
      if (e.stderr) {
        const logs = parseJsonFromStderr(e.stderr);
        const error = logs.find((it) => it.level === "ERROR" && it.target === "migration_engine::logger");
        if (error && error.fields.error_code && error.fields.message) {
          return {
            code: error.fields.error_code,
            message: error.fields.message
          };
        } else {
          throw new Error(`Migration engine error:
${logs.map((log2) => log2.fields.message).join("\n")}`);
        }
      } else {
        throw new Error(`Migration engine exited.`);
      }
    }
    return true;
  }
  async function createDatabase2(connectionString, cwd = process.cwd(), migrationEnginePath) {
    const dbExists = await canConnectToDatabase4(connectionString, cwd, migrationEnginePath);
    if (dbExists === true) {
      return false;
    }
    try {
      await execaCommand({
        connectionString,
        cwd,
        migrationEnginePath,
        engineCommandName: "create-database"
      });
      return true;
    } catch (e) {
      if (e.stderr) {
        const logs = parseJsonFromStderr(e.stderr);
        const error = logs.find((it) => it.level === "ERROR" && it.target === "migration_engine::logger");
        if (error && error.fields.error_code && error.fields.message) {
          throw new Error(`${error.fields.error_code}: ${error.fields.message}`);
        } else {
          throw new Error(`Migration engine error:
${logs.map((log2) => log2.fields.message).join("\n")}`);
        }
      } else {
        throw new Error(`Migration engine exited.`);
      }
    }
  }
  async function dropDatabase2(connectionString, cwd = process.cwd(), migrationEnginePath) {
    try {
      const result = await execaCommand({
        connectionString,
        cwd,
        migrationEnginePath,
        engineCommandName: "drop-database"
      });
      if (result && result.exitCode === 0 && result.stderr.includes("The database was successfully dropped")) {
        return true;
      } else {
        throw Error(`An error occurred during the drop: ${JSON.stringify(result, void 0, 2)}`);
      }
    } catch (e) {
      if (e.stderr) {
        const logs = parseJsonFromStderr(e.stderr);
        throw new Error(`Migration engine error:
${logs.map((log2) => log2.fields.message).join("\n")}`);
      } else {
        throw new Error(`Migration engine exited.`);
      }
    }
  }
  async function execaCommand({
    connectionString,
    cwd,
    migrationEnginePath,
    engineCommandName
  }) {
    migrationEnginePath = migrationEnginePath || await (0, import_resolveBinary.resolveBinary)(import_fetch_engine2.BinaryType.migrationEngine);
    try {
      return await (0, import_execa2.default)(migrationEnginePath, ["cli", "--datasource", connectionString, engineCommandName], {
        cwd,
        env: {
          RUST_BACKTRACE: "1",
          RUST_LOG: "info"
        }
      });
    } catch (e) {
      if (e.message) {
        e.message = e.message.replace(connectionString, "<REDACTED>");
      }
      if (e.stdout) {
        e.stdout = e.stdout.replace(connectionString, "<REDACTED>");
      }
      if (e.stderr) {
        e.stderr = e.stderr.replace(connectionString, "<REDACTED>");
      }
      throw e;
    }
  }
  async function doesSqliteDbExist(connectionString, schemaDir) {
    let filePath = connectionString;
    if (filePath.startsWith("file:")) {
      filePath = filePath.slice(5);
    } else if (filePath.startsWith("sqlite:")) {
      filePath = filePath.slice(7);
    }
    const cwd = schemaDir || await (0, import_getSchema.getSchemaDir)();
    if (!cwd) {
      throw new Error(`Could not find schema.prisma in ${process.cwd()}`);
    }
    const absoluteTarget = import_path10.default.resolve(cwd, filePath);
    return exists2(absoluteTarget);
  }
});

// ../../node_modules/.pnpm/async@3.2.0/node_modules/async/dist/async.js
var require_async7 = __commonJS((exports2, module2) => {
  (function(global2, factory) {
    typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.async = {});
  })(exports2, function(exports3) {
    "use strict";
    function apply(fn, ...args2) {
      return (...callArgs) => fn(...args2, ...callArgs);
    }
    function initialParams(fn) {
      return function(...args2) {
        var callback = args2.pop();
        return fn.call(this, args2, callback);
      };
    }
    var hasSetImmediate = typeof setImmediate === "function" && setImmediate;
    var hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
    function fallback(fn) {
      setTimeout(fn, 0);
    }
    function wrap(defer) {
      return (fn, ...args2) => defer(() => fn(...args2));
    }
    var _defer;
    if (hasSetImmediate) {
      _defer = setImmediate;
    } else if (hasNextTick) {
      _defer = process.nextTick;
    } else {
      _defer = fallback;
    }
    var setImmediate$1 = wrap(_defer);
    function asyncify(func) {
      if (isAsync(func)) {
        return function(...args2) {
          const callback = args2.pop();
          const promise = func.apply(this, args2);
          return handlePromise(promise, callback);
        };
      }
      return initialParams(function(args2, callback) {
        var result;
        try {
          result = func.apply(this, args2);
        } catch (e) {
          return callback(e);
        }
        if (result && typeof result.then === "function") {
          return handlePromise(result, callback);
        } else {
          callback(null, result);
        }
      });
    }
    function handlePromise(promise, callback) {
      return promise.then((value) => {
        invokeCallback(callback, null, value);
      }, (err) => {
        invokeCallback(callback, err && err.message ? err : new Error(err));
      });
    }
    function invokeCallback(callback, error, value) {
      try {
        callback(error, value);
      } catch (err) {
        setImmediate$1((e) => {
          throw e;
        }, err);
      }
    }
    function isAsync(fn) {
      return fn[Symbol.toStringTag] === "AsyncFunction";
    }
    function isAsyncGenerator(fn) {
      return fn[Symbol.toStringTag] === "AsyncGenerator";
    }
    function isAsyncIterable(obj) {
      return typeof obj[Symbol.asyncIterator] === "function";
    }
    function wrapAsync(asyncFn) {
      if (typeof asyncFn !== "function")
        throw new Error("expected a function");
      return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
    }
    function awaitify(asyncFn, arity = asyncFn.length) {
      if (!arity)
        throw new Error("arity is undefined");
      function awaitable(...args2) {
        if (typeof args2[arity - 1] === "function") {
          return asyncFn.apply(this, args2);
        }
        return new Promise((resolve, reject2) => {
          args2[arity - 1] = (err, ...cbArgs) => {
            if (err)
              return reject2(err);
            resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
          };
          asyncFn.apply(this, args2);
        });
      }
      return awaitable;
    }
    function applyEach(eachfn) {
      return function applyEach2(fns, ...callArgs) {
        const go = awaitify(function(callback) {
          var that = this;
          return eachfn(fns, (fn, cb) => {
            wrapAsync(fn).apply(that, callArgs.concat(cb));
          }, callback);
        });
        return go;
      };
    }
    function _asyncMap(eachfn, arr, iteratee, callback) {
      arr = arr || [];
      var results = [];
      var counter2 = 0;
      var _iteratee = wrapAsync(iteratee);
      return eachfn(arr, (value, _2, iterCb) => {
        var index2 = counter2++;
        _iteratee(value, (err, v) => {
          results[index2] = v;
          iterCb(err);
        });
      }, (err) => {
        callback(err, results);
      });
    }
    function isArrayLike(value) {
      return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
    }
    const breakLoop = {};
    function once(fn) {
      function wrapper(...args2) {
        if (fn === null)
          return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, args2);
      }
      Object.assign(wrapper, fn);
      return wrapper;
    }
    function getIterator(coll) {
      return coll[Symbol.iterator] && coll[Symbol.iterator]();
    }
    function createArrayIterator(coll) {
      var i = -1;
      var len = coll.length;
      return function next() {
        return ++i < len ? {value: coll[i], key: i} : null;
      };
    }
    function createES2015Iterator(iterator) {
      var i = -1;
      return function next() {
        var item = iterator.next();
        if (item.done)
          return null;
        i++;
        return {value: item.value, key: i};
      };
    }
    function createObjectIterator(obj) {
      var okeys = obj ? Object.keys(obj) : [];
      var i = -1;
      var len = okeys.length;
      return function next() {
        var key = okeys[++i];
        return i < len ? {value: obj[key], key} : null;
      };
    }
    function createIterator(coll) {
      if (isArrayLike(coll)) {
        return createArrayIterator(coll);
      }
      var iterator = getIterator(coll);
      return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
    }
    function onlyOnce(fn) {
      return function(...args2) {
        if (fn === null)
          throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, args2);
      };
    }
    function asyncEachOfLimit(generator, limit, iteratee, callback) {
      let done = false;
      let canceled = false;
      let awaiting = false;
      let running = 0;
      let idx = 0;
      function replenish() {
        if (running >= limit || awaiting || done)
          return;
        awaiting = true;
        generator.next().then(({value, done: iterDone}) => {
          if (canceled || done)
            return;
          awaiting = false;
          if (iterDone) {
            done = true;
            if (running <= 0) {
              callback(null);
            }
            return;
          }
          running++;
          iteratee(value, idx, iterateeCallback);
          idx++;
          replenish();
        }).catch(handleError);
      }
      function iterateeCallback(err, result) {
        running -= 1;
        if (canceled)
          return;
        if (err)
          return handleError(err);
        if (err === false) {
          done = true;
          canceled = true;
          return;
        }
        if (result === breakLoop || done && running <= 0) {
          done = true;
          return callback(null);
        }
        replenish();
      }
      function handleError(err) {
        if (canceled)
          return;
        awaiting = false;
        done = true;
        callback(err);
      }
      replenish();
    }
    var eachOfLimit = (limit) => {
      return (obj, iteratee, callback) => {
        callback = once(callback);
        if (limit <= 0) {
          throw new RangeError("concurrency limit cannot be less than 1");
        }
        if (!obj) {
          return callback(null);
        }
        if (isAsyncGenerator(obj)) {
          return asyncEachOfLimit(obj, limit, iteratee, callback);
        }
        if (isAsyncIterable(obj)) {
          return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit, iteratee, callback);
        }
        var nextElem = createIterator(obj);
        var done = false;
        var canceled = false;
        var running = 0;
        var looping = false;
        function iterateeCallback(err, value) {
          if (canceled)
            return;
          running -= 1;
          if (err) {
            done = true;
            callback(err);
          } else if (err === false) {
            done = true;
            canceled = true;
          } else if (value === breakLoop || done && running <= 0) {
            done = true;
            return callback(null);
          } else if (!looping) {
            replenish();
          }
        }
        function replenish() {
          looping = true;
          while (running < limit && !done) {
            var elem = nextElem();
            if (elem === null) {
              done = true;
              if (running <= 0) {
                callback(null);
              }
              return;
            }
            running += 1;
            iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
          }
          looping = false;
        }
        replenish();
      };
    };
    function eachOfLimit$1(coll, limit, iteratee, callback) {
      return eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);
    }
    var eachOfLimit$2 = awaitify(eachOfLimit$1, 4);
    function eachOfArrayLike(coll, iteratee, callback) {
      callback = once(callback);
      var index2 = 0, completed = 0, {length} = coll, canceled = false;
      if (length === 0) {
        callback(null);
      }
      function iteratorCallback(err, value) {
        if (err === false) {
          canceled = true;
        }
        if (canceled === true)
          return;
        if (err) {
          callback(err);
        } else if (++completed === length || value === breakLoop) {
          callback(null);
        }
      }
      for (; index2 < length; index2++) {
        iteratee(coll[index2], index2, onlyOnce(iteratorCallback));
      }
    }
    function eachOfGeneric(coll, iteratee, callback) {
      return eachOfLimit$2(coll, Infinity, iteratee, callback);
    }
    function eachOf(coll, iteratee, callback) {
      var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
      return eachOfImplementation(coll, wrapAsync(iteratee), callback);
    }
    var eachOf$1 = awaitify(eachOf, 3);
    function map(coll, iteratee, callback) {
      return _asyncMap(eachOf$1, coll, iteratee, callback);
    }
    var map$1 = awaitify(map, 3);
    var applyEach$1 = applyEach(map$1);
    function eachOfSeries(coll, iteratee, callback) {
      return eachOfLimit$2(coll, 1, iteratee, callback);
    }
    var eachOfSeries$1 = awaitify(eachOfSeries, 3);
    function mapSeries(coll, iteratee, callback) {
      return _asyncMap(eachOfSeries$1, coll, iteratee, callback);
    }
    var mapSeries$1 = awaitify(mapSeries, 3);
    var applyEachSeries = applyEach(mapSeries$1);
    const PROMISE_SYMBOL = Symbol("promiseCallback");
    function promiseCallback() {
      let resolve, reject2;
      function callback(err, ...args2) {
        if (err)
          return reject2(err);
        resolve(args2.length > 1 ? args2 : args2[0]);
      }
      callback[PROMISE_SYMBOL] = new Promise((res, rej) => {
        resolve = res, reject2 = rej;
      });
      return callback;
    }
    function auto(tasks, concurrency, callback) {
      if (typeof concurrency !== "number") {
        callback = concurrency;
        concurrency = null;
      }
      callback = once(callback || promiseCallback());
      var numTasks = Object.keys(tasks).length;
      if (!numTasks) {
        return callback(null);
      }
      if (!concurrency) {
        concurrency = numTasks;
      }
      var results = {};
      var runningTasks = 0;
      var canceled = false;
      var hasError = false;
      var listeners = Object.create(null);
      var readyTasks = [];
      var readyToCheck = [];
      var uncheckedDependencies = {};
      Object.keys(tasks).forEach((key) => {
        var task = tasks[key];
        if (!Array.isArray(task)) {
          enqueueTask(key, [task]);
          readyToCheck.push(key);
          return;
        }
        var dependencies = task.slice(0, task.length - 1);
        var remainingDependencies = dependencies.length;
        if (remainingDependencies === 0) {
          enqueueTask(key, task);
          readyToCheck.push(key);
          return;
        }
        uncheckedDependencies[key] = remainingDependencies;
        dependencies.forEach((dependencyName) => {
          if (!tasks[dependencyName]) {
            throw new Error("async.auto task `" + key + "` has a non-existent dependency `" + dependencyName + "` in " + dependencies.join(", "));
          }
          addListener(dependencyName, () => {
            remainingDependencies--;
            if (remainingDependencies === 0) {
              enqueueTask(key, task);
            }
          });
        });
      });
      checkForDeadlocks();
      processQueue();
      function enqueueTask(key, task) {
        readyTasks.push(() => runTask(key, task));
      }
      function processQueue() {
        if (canceled)
          return;
        if (readyTasks.length === 0 && runningTasks === 0) {
          return callback(null, results);
        }
        while (readyTasks.length && runningTasks < concurrency) {
          var run = readyTasks.shift();
          run();
        }
      }
      function addListener(taskName, fn) {
        var taskListeners = listeners[taskName];
        if (!taskListeners) {
          taskListeners = listeners[taskName] = [];
        }
        taskListeners.push(fn);
      }
      function taskComplete(taskName) {
        var taskListeners = listeners[taskName] || [];
        taskListeners.forEach((fn) => fn());
        processQueue();
      }
      function runTask(key, task) {
        if (hasError)
          return;
        var taskCallback = onlyOnce((err, ...result) => {
          runningTasks--;
          if (err === false) {
            canceled = true;
            return;
          }
          if (result.length < 2) {
            [result] = result;
          }
          if (err) {
            var safeResults = {};
            Object.keys(results).forEach((rkey) => {
              safeResults[rkey] = results[rkey];
            });
            safeResults[key] = result;
            hasError = true;
            listeners = Object.create(null);
            if (canceled)
              return;
            callback(err, safeResults);
          } else {
            results[key] = result;
            taskComplete(key);
          }
        });
        runningTasks++;
        var taskFn = wrapAsync(task[task.length - 1]);
        if (task.length > 1) {
          taskFn(results, taskCallback);
        } else {
          taskFn(taskCallback);
        }
      }
      function checkForDeadlocks() {
        var currentTask;
        var counter2 = 0;
        while (readyToCheck.length) {
          currentTask = readyToCheck.pop();
          counter2++;
          getDependents(currentTask).forEach((dependent) => {
            if (--uncheckedDependencies[dependent] === 0) {
              readyToCheck.push(dependent);
            }
          });
        }
        if (counter2 !== numTasks) {
          throw new Error("async.auto cannot execute tasks due to a recursive dependency");
        }
      }
      function getDependents(taskName) {
        var result = [];
        Object.keys(tasks).forEach((key) => {
          const task = tasks[key];
          if (Array.isArray(task) && task.indexOf(taskName) >= 0) {
            result.push(key);
          }
        });
        return result;
      }
      return callback[PROMISE_SYMBOL];
    }
    var FN_ARGS = /^(?:async\s+)?(?:function)?\s*\w*\s*\(\s*([^)]+)\s*\)(?:\s*{)/;
    var ARROW_FN_ARGS = /^(?:async\s+)?\(?\s*([^)=]+)\s*\)?(?:\s*=>)/;
    var FN_ARG_SPLIT = /,/;
    var FN_ARG = /(=.+)?(\s*)$/;
    var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
    function parseParams(func) {
      const src = func.toString().replace(STRIP_COMMENTS, "");
      let match = src.match(FN_ARGS);
      if (!match) {
        match = src.match(ARROW_FN_ARGS);
      }
      if (!match)
        throw new Error("could not parse args in autoInject\nSource:\n" + src);
      let [, args2] = match;
      return args2.replace(/\s/g, "").split(FN_ARG_SPLIT).map((arg10) => arg10.replace(FN_ARG, "").trim());
    }
    function autoInject(tasks, callback) {
      var newTasks = {};
      Object.keys(tasks).forEach((key) => {
        var taskFn = tasks[key];
        var params;
        var fnIsAsync = isAsync(taskFn);
        var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;
        if (Array.isArray(taskFn)) {
          params = [...taskFn];
          taskFn = params.pop();
          newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
        } else if (hasNoDeps) {
          newTasks[key] = taskFn;
        } else {
          params = parseParams(taskFn);
          if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {
            throw new Error("autoInject task functions require explicit parameters.");
          }
          if (!fnIsAsync)
            params.pop();
          newTasks[key] = params.concat(newTask);
        }
        function newTask(results, taskCb) {
          var newArgs = params.map((name) => results[name]);
          newArgs.push(taskCb);
          wrapAsync(taskFn)(...newArgs);
        }
      });
      return auto(newTasks, callback);
    }
    class DLL {
      constructor() {
        this.head = this.tail = null;
        this.length = 0;
      }
      removeLink(node) {
        if (node.prev)
          node.prev.next = node.next;
        else
          this.head = node.next;
        if (node.next)
          node.next.prev = node.prev;
        else
          this.tail = node.prev;
        node.prev = node.next = null;
        this.length -= 1;
        return node;
      }
      empty() {
        while (this.head)
          this.shift();
        return this;
      }
      insertAfter(node, newNode) {
        newNode.prev = node;
        newNode.next = node.next;
        if (node.next)
          node.next.prev = newNode;
        else
          this.tail = newNode;
        node.next = newNode;
        this.length += 1;
      }
      insertBefore(node, newNode) {
        newNode.prev = node.prev;
        newNode.next = node;
        if (node.prev)
          node.prev.next = newNode;
        else
          this.head = newNode;
        node.prev = newNode;
        this.length += 1;
      }
      unshift(node) {
        if (this.head)
          this.insertBefore(this.head, node);
        else
          setInitial(this, node);
      }
      push(node) {
        if (this.tail)
          this.insertAfter(this.tail, node);
        else
          setInitial(this, node);
      }
      shift() {
        return this.head && this.removeLink(this.head);
      }
      pop() {
        return this.tail && this.removeLink(this.tail);
      }
      toArray() {
        return [...this];
      }
      *[Symbol.iterator]() {
        var cur = this.head;
        while (cur) {
          yield cur.data;
          cur = cur.next;
        }
      }
      remove(testFn) {
        var curr = this.head;
        while (curr) {
          var {next} = curr;
          if (testFn(curr)) {
            this.removeLink(curr);
          }
          curr = next;
        }
        return this;
      }
    }
    function setInitial(dll, node) {
      dll.length = 1;
      dll.head = dll.tail = node;
    }
    function queue(worker, concurrency, payload) {
      if (concurrency == null) {
        concurrency = 1;
      } else if (concurrency === 0) {
        throw new RangeError("Concurrency must not be zero");
      }
      var _worker = wrapAsync(worker);
      var numRunning = 0;
      var workersList = [];
      const events = {
        error: [],
        drain: [],
        saturated: [],
        unsaturated: [],
        empty: []
      };
      function on(event, handler) {
        events[event].push(handler);
      }
      function once2(event, handler) {
        const handleAndRemove = (...args2) => {
          off(event, handleAndRemove);
          handler(...args2);
        };
        events[event].push(handleAndRemove);
      }
      function off(event, handler) {
        if (!event)
          return Object.keys(events).forEach((ev) => events[ev] = []);
        if (!handler)
          return events[event] = [];
        events[event] = events[event].filter((ev) => ev !== handler);
      }
      function trigger(event, ...args2) {
        events[event].forEach((handler) => handler(...args2));
      }
      var processingScheduled = false;
      function _insert(data, insertAtFront, rejectOnError, callback) {
        if (callback != null && typeof callback !== "function") {
          throw new Error("task callback must be a function");
        }
        q.started = true;
        var res, rej;
        function promiseCallback2(err, ...args2) {
          if (err)
            return rejectOnError ? rej(err) : res();
          if (args2.length <= 1)
            return res(args2[0]);
          res(args2);
        }
        var item = {
          data,
          callback: rejectOnError ? promiseCallback2 : callback || promiseCallback2
        };
        if (insertAtFront) {
          q._tasks.unshift(item);
        } else {
          q._tasks.push(item);
        }
        if (!processingScheduled) {
          processingScheduled = true;
          setImmediate$1(() => {
            processingScheduled = false;
            q.process();
          });
        }
        if (rejectOnError || !callback) {
          return new Promise((resolve, reject2) => {
            res = resolve;
            rej = reject2;
          });
        }
      }
      function _createCB(tasks) {
        return function(err, ...args2) {
          numRunning -= 1;
          for (var i = 0, l = tasks.length; i < l; i++) {
            var task = tasks[i];
            var index2 = workersList.indexOf(task);
            if (index2 === 0) {
              workersList.shift();
            } else if (index2 > 0) {
              workersList.splice(index2, 1);
            }
            task.callback(err, ...args2);
            if (err != null) {
              trigger("error", err, task.data);
            }
          }
          if (numRunning <= q.concurrency - q.buffer) {
            trigger("unsaturated");
          }
          if (q.idle()) {
            trigger("drain");
          }
          q.process();
        };
      }
      function _maybeDrain(data) {
        if (data.length === 0 && q.idle()) {
          setImmediate$1(() => trigger("drain"));
          return true;
        }
        return false;
      }
      const eventMethod = (name) => (handler) => {
        if (!handler) {
          return new Promise((resolve, reject2) => {
            once2(name, (err, data) => {
              if (err)
                return reject2(err);
              resolve(data);
            });
          });
        }
        off(name);
        on(name, handler);
      };
      var isProcessing = false;
      var q = {
        _tasks: new DLL(),
        *[Symbol.iterator]() {
          yield* q._tasks[Symbol.iterator]();
        },
        concurrency,
        payload,
        buffer: concurrency / 4,
        started: false,
        paused: false,
        push(data, callback) {
          if (Array.isArray(data)) {
            if (_maybeDrain(data))
              return;
            return data.map((datum) => _insert(datum, false, false, callback));
          }
          return _insert(data, false, false, callback);
        },
        pushAsync(data, callback) {
          if (Array.isArray(data)) {
            if (_maybeDrain(data))
              return;
            return data.map((datum) => _insert(datum, false, true, callback));
          }
          return _insert(data, false, true, callback);
        },
        kill() {
          off();
          q._tasks.empty();
        },
        unshift(data, callback) {
          if (Array.isArray(data)) {
            if (_maybeDrain(data))
              return;
            return data.map((datum) => _insert(datum, true, false, callback));
          }
          return _insert(data, true, false, callback);
        },
        unshiftAsync(data, callback) {
          if (Array.isArray(data)) {
            if (_maybeDrain(data))
              return;
            return data.map((datum) => _insert(datum, true, true, callback));
          }
          return _insert(data, true, true, callback);
        },
        remove(testFn) {
          q._tasks.remove(testFn);
        },
        process() {
          if (isProcessing) {
            return;
          }
          isProcessing = true;
          while (!q.paused && numRunning < q.concurrency && q._tasks.length) {
            var tasks = [], data = [];
            var l = q._tasks.length;
            if (q.payload)
              l = Math.min(l, q.payload);
            for (var i = 0; i < l; i++) {
              var node = q._tasks.shift();
              tasks.push(node);
              workersList.push(node);
              data.push(node.data);
            }
            numRunning += 1;
            if (q._tasks.length === 0) {
              trigger("empty");
            }
            if (numRunning === q.concurrency) {
              trigger("saturated");
            }
            var cb = onlyOnce(_createCB(tasks));
            _worker(data, cb);
          }
          isProcessing = false;
        },
        length() {
          return q._tasks.length;
        },
        running() {
          return numRunning;
        },
        workersList() {
          return workersList;
        },
        idle() {
          return q._tasks.length + numRunning === 0;
        },
        pause() {
          q.paused = true;
        },
        resume() {
          if (q.paused === false) {
            return;
          }
          q.paused = false;
          setImmediate$1(q.process);
        }
      };
      Object.defineProperties(q, {
        saturated: {
          writable: false,
          value: eventMethod("saturated")
        },
        unsaturated: {
          writable: false,
          value: eventMethod("unsaturated")
        },
        empty: {
          writable: false,
          value: eventMethod("empty")
        },
        drain: {
          writable: false,
          value: eventMethod("drain")
        },
        error: {
          writable: false,
          value: eventMethod("error")
        }
      });
      return q;
    }
    function cargo(worker, payload) {
      return queue(worker, 1, payload);
    }
    function cargo$1(worker, concurrency, payload) {
      return queue(worker, concurrency, payload);
    }
    function reduce(coll, memo, iteratee, callback) {
      callback = once(callback);
      var _iteratee = wrapAsync(iteratee);
      return eachOfSeries$1(coll, (x, i, iterCb) => {
        _iteratee(memo, x, (err, v) => {
          memo = v;
          iterCb(err);
        });
      }, (err) => callback(err, memo));
    }
    var reduce$1 = awaitify(reduce, 4);
    function seq(...functions) {
      var _functions = functions.map(wrapAsync);
      return function(...args2) {
        var that = this;
        var cb = args2[args2.length - 1];
        if (typeof cb == "function") {
          args2.pop();
        } else {
          cb = promiseCallback();
        }
        reduce$1(_functions, args2, (newargs, fn, iterCb) => {
          fn.apply(that, newargs.concat((err, ...nextargs) => {
            iterCb(err, nextargs);
          }));
        }, (err, results) => cb(err, ...results));
        return cb[PROMISE_SYMBOL];
      };
    }
    function compose(...args2) {
      return seq(...args2.reverse());
    }
    function mapLimit(coll, limit, iteratee, callback) {
      return _asyncMap(eachOfLimit(limit), coll, iteratee, callback);
    }
    var mapLimit$1 = awaitify(mapLimit, 4);
    function concatLimit(coll, limit, iteratee, callback) {
      var _iteratee = wrapAsync(iteratee);
      return mapLimit$1(coll, limit, (val, iterCb) => {
        _iteratee(val, (err, ...args2) => {
          if (err)
            return iterCb(err);
          return iterCb(err, args2);
        });
      }, (err, mapResults) => {
        var result = [];
        for (var i = 0; i < mapResults.length; i++) {
          if (mapResults[i]) {
            result = result.concat(...mapResults[i]);
          }
        }
        return callback(err, result);
      });
    }
    var concatLimit$1 = awaitify(concatLimit, 4);
    function concat(coll, iteratee, callback) {
      return concatLimit$1(coll, Infinity, iteratee, callback);
    }
    var concat$1 = awaitify(concat, 3);
    function concatSeries(coll, iteratee, callback) {
      return concatLimit$1(coll, 1, iteratee, callback);
    }
    var concatSeries$1 = awaitify(concatSeries, 3);
    function constant(...args2) {
      return function(...ignoredArgs) {
        var callback = ignoredArgs.pop();
        return callback(null, ...args2);
      };
    }
    function _createTester(check3, getResult) {
      return (eachfn, arr, _iteratee, cb) => {
        var testPassed = false;
        var testResult;
        const iteratee = wrapAsync(_iteratee);
        eachfn(arr, (value, _2, callback) => {
          iteratee(value, (err, result) => {
            if (err || err === false)
              return callback(err);
            if (check3(result) && !testResult) {
              testPassed = true;
              testResult = getResult(true, value);
              return callback(null, breakLoop);
            }
            callback();
          });
        }, (err) => {
          if (err)
            return cb(err);
          cb(null, testPassed ? testResult : getResult(false));
        });
      };
    }
    function detect(coll, iteratee, callback) {
      return _createTester((bool) => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback);
    }
    var detect$1 = awaitify(detect, 3);
    function detectLimit(coll, limit, iteratee, callback) {
      return _createTester((bool) => bool, (res, item) => item)(eachOfLimit(limit), coll, iteratee, callback);
    }
    var detectLimit$1 = awaitify(detectLimit, 4);
    function detectSeries(coll, iteratee, callback) {
      return _createTester((bool) => bool, (res, item) => item)(eachOfLimit(1), coll, iteratee, callback);
    }
    var detectSeries$1 = awaitify(detectSeries, 3);
    function consoleFunc(name) {
      return (fn, ...args2) => wrapAsync(fn)(...args2, (err, ...resultArgs) => {
        if (typeof console === "object") {
          if (err) {
            if (console.error) {
              console.error(err);
            }
          } else if (console[name]) {
            resultArgs.forEach((x) => console[name](x));
          }
        }
      });
    }
    var dir = consoleFunc("dir");
    function doWhilst(iteratee, test, callback) {
      callback = onlyOnce(callback);
      var _fn = wrapAsync(iteratee);
      var _test = wrapAsync(test);
      var results;
      function next(err, ...args2) {
        if (err)
          return callback(err);
        if (err === false)
          return;
        results = args2;
        _test(...args2, check3);
      }
      function check3(err, truth) {
        if (err)
          return callback(err);
        if (err === false)
          return;
        if (!truth)
          return callback(null, ...results);
        _fn(next);
      }
      return check3(null, true);
    }
    var doWhilst$1 = awaitify(doWhilst, 3);
    function doUntil(iteratee, test, callback) {
      const _test = wrapAsync(test);
      return doWhilst$1(iteratee, (...args2) => {
        const cb = args2.pop();
        _test(...args2, (err, truth) => cb(err, !truth));
      }, callback);
    }
    function _withoutIndex(iteratee) {
      return (value, index2, callback) => iteratee(value, callback);
    }
    function eachLimit(coll, iteratee, callback) {
      return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);
    }
    var each = awaitify(eachLimit, 3);
    function eachLimit$1(coll, limit, iteratee, callback) {
      return eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
    }
    var eachLimit$2 = awaitify(eachLimit$1, 4);
    function eachSeries(coll, iteratee, callback) {
      return eachLimit$2(coll, 1, iteratee, callback);
    }
    var eachSeries$1 = awaitify(eachSeries, 3);
    function ensureAsync(fn) {
      if (isAsync(fn))
        return fn;
      return function(...args2) {
        var callback = args2.pop();
        var sync2 = true;
        args2.push((...innerArgs) => {
          if (sync2) {
            setImmediate$1(() => callback(...innerArgs));
          } else {
            callback(...innerArgs);
          }
        });
        fn.apply(this, args2);
        sync2 = false;
      };
    }
    function every(coll, iteratee, callback) {
      return _createTester((bool) => !bool, (res) => !res)(eachOf$1, coll, iteratee, callback);
    }
    var every$1 = awaitify(every, 3);
    function everyLimit(coll, limit, iteratee, callback) {
      return _createTester((bool) => !bool, (res) => !res)(eachOfLimit(limit), coll, iteratee, callback);
    }
    var everyLimit$1 = awaitify(everyLimit, 4);
    function everySeries(coll, iteratee, callback) {
      return _createTester((bool) => !bool, (res) => !res)(eachOfSeries$1, coll, iteratee, callback);
    }
    var everySeries$1 = awaitify(everySeries, 3);
    function filterArray(eachfn, arr, iteratee, callback) {
      var truthValues = new Array(arr.length);
      eachfn(arr, (x, index2, iterCb) => {
        iteratee(x, (err, v) => {
          truthValues[index2] = !!v;
          iterCb(err);
        });
      }, (err) => {
        if (err)
          return callback(err);
        var results = [];
        for (var i = 0; i < arr.length; i++) {
          if (truthValues[i])
            results.push(arr[i]);
        }
        callback(null, results);
      });
    }
    function filterGeneric(eachfn, coll, iteratee, callback) {
      var results = [];
      eachfn(coll, (x, index2, iterCb) => {
        iteratee(x, (err, v) => {
          if (err)
            return iterCb(err);
          if (v) {
            results.push({index: index2, value: x});
          }
          iterCb(err);
        });
      }, (err) => {
        if (err)
          return callback(err);
        callback(null, results.sort((a, b) => a.index - b.index).map((v) => v.value));
      });
    }
    function _filter(eachfn, coll, iteratee, callback) {
      var filter2 = isArrayLike(coll) ? filterArray : filterGeneric;
      return filter2(eachfn, coll, wrapAsync(iteratee), callback);
    }
    function filter(coll, iteratee, callback) {
      return _filter(eachOf$1, coll, iteratee, callback);
    }
    var filter$1 = awaitify(filter, 3);
    function filterLimit(coll, limit, iteratee, callback) {
      return _filter(eachOfLimit(limit), coll, iteratee, callback);
    }
    var filterLimit$1 = awaitify(filterLimit, 4);
    function filterSeries(coll, iteratee, callback) {
      return _filter(eachOfSeries$1, coll, iteratee, callback);
    }
    var filterSeries$1 = awaitify(filterSeries, 3);
    function forever(fn, errback) {
      var done = onlyOnce(errback);
      var task = wrapAsync(ensureAsync(fn));
      function next(err) {
        if (err)
          return done(err);
        if (err === false)
          return;
        task(next);
      }
      return next();
    }
    var forever$1 = awaitify(forever, 2);
    function groupByLimit(coll, limit, iteratee, callback) {
      var _iteratee = wrapAsync(iteratee);
      return mapLimit$1(coll, limit, (val, iterCb) => {
        _iteratee(val, (err, key) => {
          if (err)
            return iterCb(err);
          return iterCb(err, {key, val});
        });
      }, (err, mapResults) => {
        var result = {};
        var {hasOwnProperty} = Object.prototype;
        for (var i = 0; i < mapResults.length; i++) {
          if (mapResults[i]) {
            var {key} = mapResults[i];
            var {val} = mapResults[i];
            if (hasOwnProperty.call(result, key)) {
              result[key].push(val);
            } else {
              result[key] = [val];
            }
          }
        }
        return callback(err, result);
      });
    }
    var groupByLimit$1 = awaitify(groupByLimit, 4);
    function groupBy(coll, iteratee, callback) {
      return groupByLimit$1(coll, Infinity, iteratee, callback);
    }
    function groupBySeries(coll, iteratee, callback) {
      return groupByLimit$1(coll, 1, iteratee, callback);
    }
    var log2 = consoleFunc("log");
    function mapValuesLimit(obj, limit, iteratee, callback) {
      callback = once(callback);
      var newObj = {};
      var _iteratee = wrapAsync(iteratee);
      return eachOfLimit(limit)(obj, (val, key, next) => {
        _iteratee(val, key, (err, result) => {
          if (err)
            return next(err);
          newObj[key] = result;
          next(err);
        });
      }, (err) => callback(err, newObj));
    }
    var mapValuesLimit$1 = awaitify(mapValuesLimit, 4);
    function mapValues(obj, iteratee, callback) {
      return mapValuesLimit$1(obj, Infinity, iteratee, callback);
    }
    function mapValuesSeries(obj, iteratee, callback) {
      return mapValuesLimit$1(obj, 1, iteratee, callback);
    }
    function memoize(fn, hasher = (v) => v) {
      var memo = Object.create(null);
      var queues = Object.create(null);
      var _fn = wrapAsync(fn);
      var memoized = initialParams((args2, callback) => {
        var key = hasher(...args2);
        if (key in memo) {
          setImmediate$1(() => callback(null, ...memo[key]));
        } else if (key in queues) {
          queues[key].push(callback);
        } else {
          queues[key] = [callback];
          _fn(...args2, (err, ...resultArgs) => {
            if (!err) {
              memo[key] = resultArgs;
            }
            var q = queues[key];
            delete queues[key];
            for (var i = 0, l = q.length; i < l; i++) {
              q[i](err, ...resultArgs);
            }
          });
        }
      });
      memoized.memo = memo;
      memoized.unmemoized = fn;
      return memoized;
    }
    var _defer$1;
    if (hasNextTick) {
      _defer$1 = process.nextTick;
    } else if (hasSetImmediate) {
      _defer$1 = setImmediate;
    } else {
      _defer$1 = fallback;
    }
    var nextTick = wrap(_defer$1);
    var parallel = awaitify((eachfn, tasks, callback) => {
      var results = isArrayLike(tasks) ? [] : {};
      eachfn(tasks, (task, key, taskCb) => {
        wrapAsync(task)((err, ...result) => {
          if (result.length < 2) {
            [result] = result;
          }
          results[key] = result;
          taskCb(err);
        });
      }, (err) => callback(err, results));
    }, 3);
    function parallel$1(tasks, callback) {
      return parallel(eachOf$1, tasks, callback);
    }
    function parallelLimit(tasks, limit, callback) {
      return parallel(eachOfLimit(limit), tasks, callback);
    }
    function queue$1(worker, concurrency) {
      var _worker = wrapAsync(worker);
      return queue((items, cb) => {
        _worker(items[0], cb);
      }, concurrency, 1);
    }
    class Heap {
      constructor() {
        this.heap = [];
        this.pushCount = Number.MIN_SAFE_INTEGER;
      }
      get length() {
        return this.heap.length;
      }
      empty() {
        this.heap = [];
        return this;
      }
      percUp(index2) {
        let p;
        while (index2 > 0 && smaller(this.heap[index2], this.heap[p = parent(index2)])) {
          let t = this.heap[index2];
          this.heap[index2] = this.heap[p];
          this.heap[p] = t;
          index2 = p;
        }
      }
      percDown(index2) {
        let l;
        while ((l = leftChi(index2)) < this.heap.length) {
          if (l + 1 < this.heap.length && smaller(this.heap[l + 1], this.heap[l])) {
            l = l + 1;
          }
          if (smaller(this.heap[index2], this.heap[l])) {
            break;
          }
          let t = this.heap[index2];
          this.heap[index2] = this.heap[l];
          this.heap[l] = t;
          index2 = l;
        }
      }
      push(node) {
        node.pushCount = ++this.pushCount;
        this.heap.push(node);
        this.percUp(this.heap.length - 1);
      }
      unshift(node) {
        return this.heap.push(node);
      }
      shift() {
        let [top] = this.heap;
        this.heap[0] = this.heap[this.heap.length - 1];
        this.heap.pop();
        this.percDown(0);
        return top;
      }
      toArray() {
        return [...this];
      }
      *[Symbol.iterator]() {
        for (let i = 0; i < this.heap.length; i++) {
          yield this.heap[i].data;
        }
      }
      remove(testFn) {
        let j = 0;
        for (let i = 0; i < this.heap.length; i++) {
          if (!testFn(this.heap[i])) {
            this.heap[j] = this.heap[i];
            j++;
          }
        }
        this.heap.splice(j);
        for (let i = parent(this.heap.length - 1); i >= 0; i--) {
          this.percDown(i);
        }
        return this;
      }
    }
    function leftChi(i) {
      return (i << 1) + 1;
    }
    function parent(i) {
      return (i + 1 >> 1) - 1;
    }
    function smaller(x, y2) {
      if (x.priority !== y2.priority) {
        return x.priority < y2.priority;
      } else {
        return x.pushCount < y2.pushCount;
      }
    }
    function priorityQueue(worker, concurrency) {
      var q = queue$1(worker, concurrency);
      q._tasks = new Heap();
      q.push = function(data, priority = 0, callback = () => {
      }) {
        if (typeof callback !== "function") {
          throw new Error("task callback must be a function");
        }
        q.started = true;
        if (!Array.isArray(data)) {
          data = [data];
        }
        if (data.length === 0 && q.idle()) {
          return setImmediate$1(() => q.drain());
        }
        for (var i = 0, l = data.length; i < l; i++) {
          var item = {
            data: data[i],
            priority,
            callback
          };
          q._tasks.push(item);
        }
        setImmediate$1(q.process);
      };
      delete q.unshift;
      return q;
    }
    function race(tasks, callback) {
      callback = once(callback);
      if (!Array.isArray(tasks))
        return callback(new TypeError("First argument to race must be an array of functions"));
      if (!tasks.length)
        return callback();
      for (var i = 0, l = tasks.length; i < l; i++) {
        wrapAsync(tasks[i])(callback);
      }
    }
    var race$1 = awaitify(race, 2);
    function reduceRight(array, memo, iteratee, callback) {
      var reversed = [...array].reverse();
      return reduce$1(reversed, memo, iteratee, callback);
    }
    function reflect(fn) {
      var _fn = wrapAsync(fn);
      return initialParams(function reflectOn(args2, reflectCallback) {
        args2.push((error, ...cbArgs) => {
          let retVal = {};
          if (error) {
            retVal.error = error;
          }
          if (cbArgs.length > 0) {
            var value = cbArgs;
            if (cbArgs.length <= 1) {
              [value] = cbArgs;
            }
            retVal.value = value;
          }
          reflectCallback(null, retVal);
        });
        return _fn.apply(this, args2);
      });
    }
    function reflectAll(tasks) {
      var results;
      if (Array.isArray(tasks)) {
        results = tasks.map(reflect);
      } else {
        results = {};
        Object.keys(tasks).forEach((key) => {
          results[key] = reflect.call(this, tasks[key]);
        });
      }
      return results;
    }
    function reject(eachfn, arr, _iteratee, callback) {
      const iteratee = wrapAsync(_iteratee);
      return _filter(eachfn, arr, (value, cb) => {
        iteratee(value, (err, v) => {
          cb(err, !v);
        });
      }, callback);
    }
    function reject$1(coll, iteratee, callback) {
      return reject(eachOf$1, coll, iteratee, callback);
    }
    var reject$2 = awaitify(reject$1, 3);
    function rejectLimit(coll, limit, iteratee, callback) {
      return reject(eachOfLimit(limit), coll, iteratee, callback);
    }
    var rejectLimit$1 = awaitify(rejectLimit, 4);
    function rejectSeries(coll, iteratee, callback) {
      return reject(eachOfSeries$1, coll, iteratee, callback);
    }
    var rejectSeries$1 = awaitify(rejectSeries, 3);
    function constant$1(value) {
      return function() {
        return value;
      };
    }
    const DEFAULT_TIMES = 5;
    const DEFAULT_INTERVAL = 0;
    function retry(opts, task, callback) {
      var options = {
        times: DEFAULT_TIMES,
        intervalFunc: constant$1(DEFAULT_INTERVAL)
      };
      if (arguments.length < 3 && typeof opts === "function") {
        callback = task || promiseCallback();
        task = opts;
      } else {
        parseTimes(options, opts);
        callback = callback || promiseCallback();
      }
      if (typeof task !== "function") {
        throw new Error("Invalid arguments for async.retry");
      }
      var _task = wrapAsync(task);
      var attempt = 1;
      function retryAttempt() {
        _task((err, ...args2) => {
          if (err === false)
            return;
          if (err && attempt++ < options.times && (typeof options.errorFilter != "function" || options.errorFilter(err))) {
            setTimeout(retryAttempt, options.intervalFunc(attempt - 1));
          } else {
            callback(err, ...args2);
          }
        });
      }
      retryAttempt();
      return callback[PROMISE_SYMBOL];
    }
    function parseTimes(acc, t) {
      if (typeof t === "object") {
        acc.times = +t.times || DEFAULT_TIMES;
        acc.intervalFunc = typeof t.interval === "function" ? t.interval : constant$1(+t.interval || DEFAULT_INTERVAL);
        acc.errorFilter = t.errorFilter;
      } else if (typeof t === "number" || typeof t === "string") {
        acc.times = +t || DEFAULT_TIMES;
      } else {
        throw new Error("Invalid arguments for async.retry");
      }
    }
    function retryable(opts, task) {
      if (!task) {
        task = opts;
        opts = null;
      }
      let arity = opts && opts.arity || task.length;
      if (isAsync(task)) {
        arity += 1;
      }
      var _task = wrapAsync(task);
      return initialParams((args2, callback) => {
        if (args2.length < arity - 1 || callback == null) {
          args2.push(callback);
          callback = promiseCallback();
        }
        function taskFn(cb) {
          _task(...args2, cb);
        }
        if (opts)
          retry(opts, taskFn, callback);
        else
          retry(taskFn, callback);
        return callback[PROMISE_SYMBOL];
      });
    }
    function series(tasks, callback) {
      return parallel(eachOfSeries$1, tasks, callback);
    }
    function some(coll, iteratee, callback) {
      return _createTester(Boolean, (res) => res)(eachOf$1, coll, iteratee, callback);
    }
    var some$1 = awaitify(some, 3);
    function someLimit(coll, limit, iteratee, callback) {
      return _createTester(Boolean, (res) => res)(eachOfLimit(limit), coll, iteratee, callback);
    }
    var someLimit$1 = awaitify(someLimit, 4);
    function someSeries(coll, iteratee, callback) {
      return _createTester(Boolean, (res) => res)(eachOfSeries$1, coll, iteratee, callback);
    }
    var someSeries$1 = awaitify(someSeries, 3);
    function sortBy(coll, iteratee, callback) {
      var _iteratee = wrapAsync(iteratee);
      return map$1(coll, (x, iterCb) => {
        _iteratee(x, (err, criteria) => {
          if (err)
            return iterCb(err);
          iterCb(err, {value: x, criteria});
        });
      }, (err, results) => {
        if (err)
          return callback(err);
        callback(null, results.sort(comparator).map((v) => v.value));
      });
      function comparator(left, right) {
        var a = left.criteria, b = right.criteria;
        return a < b ? -1 : a > b ? 1 : 0;
      }
    }
    var sortBy$1 = awaitify(sortBy, 3);
    function timeout(asyncFn, milliseconds, info) {
      var fn = wrapAsync(asyncFn);
      return initialParams((args2, callback) => {
        var timedOut = false;
        var timer;
        function timeoutCallback() {
          var name = asyncFn.name || "anonymous";
          var error = new Error('Callback function "' + name + '" timed out.');
          error.code = "ETIMEDOUT";
          if (info) {
            error.info = info;
          }
          timedOut = true;
          callback(error);
        }
        args2.push((...cbArgs) => {
          if (!timedOut) {
            callback(...cbArgs);
            clearTimeout(timer);
          }
        });
        timer = setTimeout(timeoutCallback, milliseconds);
        fn(...args2);
      });
    }
    function range(size) {
      var result = Array(size);
      while (size--) {
        result[size] = size;
      }
      return result;
    }
    function timesLimit(count, limit, iteratee, callback) {
      var _iteratee = wrapAsync(iteratee);
      return mapLimit$1(range(count), limit, _iteratee, callback);
    }
    function times(n, iteratee, callback) {
      return timesLimit(n, Infinity, iteratee, callback);
    }
    function timesSeries(n, iteratee, callback) {
      return timesLimit(n, 1, iteratee, callback);
    }
    function transform(coll, accumulator, iteratee, callback) {
      if (arguments.length <= 3 && typeof accumulator === "function") {
        callback = iteratee;
        iteratee = accumulator;
        accumulator = Array.isArray(coll) ? [] : {};
      }
      callback = once(callback || promiseCallback());
      var _iteratee = wrapAsync(iteratee);
      eachOf$1(coll, (v, k, cb) => {
        _iteratee(accumulator, v, k, cb);
      }, (err) => callback(err, accumulator));
      return callback[PROMISE_SYMBOL];
    }
    function tryEach(tasks, callback) {
      var error = null;
      var result;
      return eachSeries$1(tasks, (task, taskCb) => {
        wrapAsync(task)((err, ...args2) => {
          if (err === false)
            return taskCb(err);
          if (args2.length < 2) {
            [result] = args2;
          } else {
            result = args2;
          }
          error = err;
          taskCb(err ? null : {});
        });
      }, () => callback(error, result));
    }
    var tryEach$1 = awaitify(tryEach);
    function unmemoize(fn) {
      return (...args2) => {
        return (fn.unmemoized || fn)(...args2);
      };
    }
    function whilst(test, iteratee, callback) {
      callback = onlyOnce(callback);
      var _fn = wrapAsync(iteratee);
      var _test = wrapAsync(test);
      var results = [];
      function next(err, ...rest) {
        if (err)
          return callback(err);
        results = rest;
        if (err === false)
          return;
        _test(check3);
      }
      function check3(err, truth) {
        if (err)
          return callback(err);
        if (err === false)
          return;
        if (!truth)
          return callback(null, ...results);
        _fn(next);
      }
      return _test(check3);
    }
    var whilst$1 = awaitify(whilst, 3);
    function until(test, iteratee, callback) {
      const _test = wrapAsync(test);
      return whilst$1((cb) => _test((err, truth) => cb(err, !truth)), iteratee, callback);
    }
    function waterfall(tasks, callback) {
      callback = once(callback);
      if (!Array.isArray(tasks))
        return callback(new Error("First argument to waterfall must be an array of functions"));
      if (!tasks.length)
        return callback();
      var taskIndex = 0;
      function nextTask(args2) {
        var task = wrapAsync(tasks[taskIndex++]);
        task(...args2, onlyOnce(next));
      }
      function next(err, ...args2) {
        if (err === false)
          return;
        if (err || taskIndex === tasks.length) {
          return callback(err, ...args2);
        }
        nextTask(args2);
      }
      nextTask([]);
    }
    var waterfall$1 = awaitify(waterfall);
    var index = {
      apply,
      applyEach: applyEach$1,
      applyEachSeries,
      asyncify,
      auto,
      autoInject,
      cargo,
      cargoQueue: cargo$1,
      compose,
      concat: concat$1,
      concatLimit: concatLimit$1,
      concatSeries: concatSeries$1,
      constant,
      detect: detect$1,
      detectLimit: detectLimit$1,
      detectSeries: detectSeries$1,
      dir,
      doUntil,
      doWhilst: doWhilst$1,
      each,
      eachLimit: eachLimit$2,
      eachOf: eachOf$1,
      eachOfLimit: eachOfLimit$2,
      eachOfSeries: eachOfSeries$1,
      eachSeries: eachSeries$1,
      ensureAsync,
      every: every$1,
      everyLimit: everyLimit$1,
      everySeries: everySeries$1,
      filter: filter$1,
      filterLimit: filterLimit$1,
      filterSeries: filterSeries$1,
      forever: forever$1,
      groupBy,
      groupByLimit: groupByLimit$1,
      groupBySeries,
      log: log2,
      map: map$1,
      mapLimit: mapLimit$1,
      mapSeries: mapSeries$1,
      mapValues,
      mapValuesLimit: mapValuesLimit$1,
      mapValuesSeries,
      memoize,
      nextTick,
      parallel: parallel$1,
      parallelLimit,
      priorityQueue,
      queue: queue$1,
      race: race$1,
      reduce: reduce$1,
      reduceRight,
      reflect,
      reflectAll,
      reject: reject$2,
      rejectLimit: rejectLimit$1,
      rejectSeries: rejectSeries$1,
      retry,
      retryable,
      seq,
      series,
      setImmediate: setImmediate$1,
      some: some$1,
      someLimit: someLimit$1,
      someSeries: someSeries$1,
      sortBy: sortBy$1,
      timeout,
      times,
      timesLimit,
      timesSeries,
      transform,
      tryEach: tryEach$1,
      unmemoize,
      until,
      waterfall: waterfall$1,
      whilst: whilst$1,
      all: every$1,
      allLimit: everyLimit$1,
      allSeries: everySeries$1,
      any: some$1,
      anyLimit: someLimit$1,
      anySeries: someSeries$1,
      find: detect$1,
      findLimit: detectLimit$1,
      findSeries: detectSeries$1,
      flatMap: concat$1,
      flatMapLimit: concatLimit$1,
      flatMapSeries: concatSeries$1,
      forEach: each,
      forEachSeries: eachSeries$1,
      forEachLimit: eachLimit$2,
      forEachOf: eachOf$1,
      forEachOfSeries: eachOfSeries$1,
      forEachOfLimit: eachOfLimit$2,
      inject: reduce$1,
      foldl: reduce$1,
      foldr: reduceRight,
      select: filter$1,
      selectLimit: filterLimit$1,
      selectSeries: filterSeries$1,
      wrapSync: asyncify,
      during: whilst$1,
      doDuring: doWhilst$1
    };
    exports3.default = index;
    exports3.apply = apply;
    exports3.applyEach = applyEach$1;
    exports3.applyEachSeries = applyEachSeries;
    exports3.asyncify = asyncify;
    exports3.auto = auto;
    exports3.autoInject = autoInject;
    exports3.cargo = cargo;
    exports3.cargoQueue = cargo$1;
    exports3.compose = compose;
    exports3.concat = concat$1;
    exports3.concatLimit = concatLimit$1;
    exports3.concatSeries = concatSeries$1;
    exports3.constant = constant;
    exports3.detect = detect$1;
    exports3.detectLimit = detectLimit$1;
    exports3.detectSeries = detectSeries$1;
    exports3.dir = dir;
    exports3.doUntil = doUntil;
    exports3.doWhilst = doWhilst$1;
    exports3.each = each;
    exports3.eachLimit = eachLimit$2;
    exports3.eachOf = eachOf$1;
    exports3.eachOfLimit = eachOfLimit$2;
    exports3.eachOfSeries = eachOfSeries$1;
    exports3.eachSeries = eachSeries$1;
    exports3.ensureAsync = ensureAsync;
    exports3.every = every$1;
    exports3.everyLimit = everyLimit$1;
    exports3.everySeries = everySeries$1;
    exports3.filter = filter$1;
    exports3.filterLimit = filterLimit$1;
    exports3.filterSeries = filterSeries$1;
    exports3.forever = forever$1;
    exports3.groupBy = groupBy;
    exports3.groupByLimit = groupByLimit$1;
    exports3.groupBySeries = groupBySeries;
    exports3.log = log2;
    exports3.map = map$1;
    exports3.mapLimit = mapLimit$1;
    exports3.mapSeries = mapSeries$1;
    exports3.mapValues = mapValues;
    exports3.mapValuesLimit = mapValuesLimit$1;
    exports3.mapValuesSeries = mapValuesSeries;
    exports3.memoize = memoize;
    exports3.nextTick = nextTick;
    exports3.parallel = parallel$1;
    exports3.parallelLimit = parallelLimit;
    exports3.priorityQueue = priorityQueue;
    exports3.queue = queue$1;
    exports3.race = race$1;
    exports3.reduce = reduce$1;
    exports3.reduceRight = reduceRight;
    exports3.reflect = reflect;
    exports3.reflectAll = reflectAll;
    exports3.reject = reject$2;
    exports3.rejectLimit = rejectLimit$1;
    exports3.rejectSeries = rejectSeries$1;
    exports3.retry = retry;
    exports3.retryable = retryable;
    exports3.seq = seq;
    exports3.series = series;
    exports3.setImmediate = setImmediate$1;
    exports3.some = some$1;
    exports3.someLimit = someLimit$1;
    exports3.someSeries = someSeries$1;
    exports3.sortBy = sortBy$1;
    exports3.timeout = timeout;
    exports3.times = times;
    exports3.timesLimit = timesLimit;
    exports3.timesSeries = timesSeries;
    exports3.transform = transform;
    exports3.tryEach = tryEach$1;
    exports3.unmemoize = unmemoize;
    exports3.until = until;
    exports3.waterfall = waterfall$1;
    exports3.whilst = whilst$1;
    exports3.all = every$1;
    exports3.allLimit = everyLimit$1;
    exports3.allSeries = everySeries$1;
    exports3.any = some$1;
    exports3.anyLimit = someLimit$1;
    exports3.anySeries = someSeries$1;
    exports3.find = detect$1;
    exports3.findLimit = detectLimit$1;
    exports3.findSeries = detectSeries$1;
    exports3.flatMap = concat$1;
    exports3.flatMapLimit = concatLimit$1;
    exports3.flatMapSeries = concatSeries$1;
    exports3.forEach = each;
    exports3.forEachSeries = eachSeries$1;
    exports3.forEachLimit = eachLimit$2;
    exports3.forEachOf = eachOf$1;
    exports3.forEachOfSeries = eachOfSeries$1;
    exports3.forEachOfLimit = eachOfLimit$2;
    exports3.inject = reduce$1;
    exports3.foldl = reduce$1;
    exports3.foldr = reduceRight;
    exports3.select = filter$1;
    exports3.selectLimit = filterLimit$1;
    exports3.selectSeries = filterSeries$1;
    exports3.wrapSync = asyncify;
    exports3.during = whilst$1;
    exports3.doDuring = doWhilst$1;
    Object.defineProperty(exports3, "__esModule", {value: true});
  });
});

// ../../node_modules/.pnpm/process-nextick-args@2.0.1/node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS((exports2, module2) => {
  "use strict";
  if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
    module2.exports = {nextTick};
  } else {
    module2.exports = process;
  }
  function nextTick(fn, arg1, arg22, arg32) {
    if (typeof fn !== "function") {
      throw new TypeError('"callback" argument must be a function');
    }
    var len = arguments.length;
    var args2, i;
    switch (len) {
      case 0:
      case 1:
        return process.nextTick(fn);
      case 2:
        return process.nextTick(function afterTickOne() {
          fn.call(null, arg1);
        });
      case 3:
        return process.nextTick(function afterTickTwo() {
          fn.call(null, arg1, arg22);
        });
      case 4:
        return process.nextTick(function afterTickThree() {
          fn.call(null, arg1, arg22, arg32);
        });
      default:
        args2 = new Array(len - 1);
        i = 0;
        while (i < args2.length) {
          args2[i++] = arguments[i];
        }
        return process.nextTick(function afterTick() {
          fn.apply(null, args2);
        });
    }
  }
});

// ../../node_modules/.pnpm/isarray@1.0.0/node_modules/isarray/index.js
var require_isarray = __commonJS((exports2, module2) => {
  var toString = {}.toString;
  module2.exports = Array.isArray || function(arr) {
    return toString.call(arr) == "[object Array]";
  };
});

// ../../node_modules/.pnpm/readable-stream@2.3.7/node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream6 = __commonJS((exports2, module2) => {
  module2.exports = require("stream");
});

// ../../node_modules/.pnpm/safe-buffer@5.1.2/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports2, module2) => {
  var buffer = require("buffer");
  var Buffer2 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module2.exports = buffer;
  } else {
    copyProps(buffer, exports2);
    exports2.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg10, encodingOrOffset, length) {
    return Buffer2(arg10, encodingOrOffset, length);
  }
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg10, encodingOrOffset, length) {
    if (typeof arg10 === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg10, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== void 0) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// ../../node_modules/.pnpm/core-util-is@1.0.2/node_modules/core-util-is/lib/util.js
var require_util5 = __commonJS((exports2) => {
  function isArray(arg10) {
    if (Array.isArray) {
      return Array.isArray(arg10);
    }
    return objectToString(arg10) === "[object Array]";
  }
  exports2.isArray = isArray;
  function isBoolean(arg10) {
    return typeof arg10 === "boolean";
  }
  exports2.isBoolean = isBoolean;
  function isNull(arg10) {
    return arg10 === null;
  }
  exports2.isNull = isNull;
  function isNullOrUndefined(arg10) {
    return arg10 == null;
  }
  exports2.isNullOrUndefined = isNullOrUndefined;
  function isNumber(arg10) {
    return typeof arg10 === "number";
  }
  exports2.isNumber = isNumber;
  function isString(arg10) {
    return typeof arg10 === "string";
  }
  exports2.isString = isString;
  function isSymbol(arg10) {
    return typeof arg10 === "symbol";
  }
  exports2.isSymbol = isSymbol;
  function isUndefined(arg10) {
    return arg10 === void 0;
  }
  exports2.isUndefined = isUndefined;
  function isRegExp(re) {
    return objectToString(re) === "[object RegExp]";
  }
  exports2.isRegExp = isRegExp;
  function isObject(arg10) {
    return typeof arg10 === "object" && arg10 !== null;
  }
  exports2.isObject = isObject;
  function isDate(d2) {
    return objectToString(d2) === "[object Date]";
  }
  exports2.isDate = isDate;
  function isError7(e) {
    return objectToString(e) === "[object Error]" || e instanceof Error;
  }
  exports2.isError = isError7;
  function isFunction(arg10) {
    return typeof arg10 === "function";
  }
  exports2.isFunction = isFunction;
  function isPrimitive(arg10) {
    return arg10 === null || typeof arg10 === "boolean" || typeof arg10 === "number" || typeof arg10 === "string" || typeof arg10 === "symbol" || typeof arg10 === "undefined";
  }
  exports2.isPrimitive = isPrimitive;
  exports2.isBuffer = Buffer.isBuffer;
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
});

// ../../node_modules/.pnpm/readable-stream@2.3.7/node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS((exports2, module2) => {
  "use strict";
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var Buffer2 = require_safe_buffer().Buffer;
  var util2 = require("util");
  function copyBuffer(src, target, offset) {
    src.copy(target, offset);
  }
  module2.exports = function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    BufferList.prototype.push = function push(v) {
      var entry = {data: v, next: null};
      if (this.length > 0)
        this.tail.next = entry;
      else
        this.head = entry;
      this.tail = entry;
      ++this.length;
    };
    BufferList.prototype.unshift = function unshift(v) {
      var entry = {data: v, next: this.head};
      if (this.length === 0)
        this.tail = entry;
      this.head = entry;
      ++this.length;
    };
    BufferList.prototype.shift = function shift() {
      if (this.length === 0)
        return;
      var ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret;
    };
    BufferList.prototype.clear = function clear() {
      this.head = this.tail = null;
      this.length = 0;
    };
    BufferList.prototype.join = function join2(s2) {
      if (this.length === 0)
        return "";
      var p = this.head;
      var ret = "" + p.data;
      while (p = p.next) {
        ret += s2 + p.data;
      }
      return ret;
    };
    BufferList.prototype.concat = function concat(n) {
      if (this.length === 0)
        return Buffer2.alloc(0);
      if (this.length === 1)
        return this.head.data;
      var ret = Buffer2.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    };
    return BufferList;
  }();
  if (util2 && util2.inspect && util2.inspect.custom) {
    module2.exports.prototype[util2.inspect.custom] = function() {
      var obj = util2.inspect({length: this.length});
      return this.constructor.name + " " + obj;
    };
  }
});

// ../../node_modules/.pnpm/readable-stream@2.3.7/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS((exports2, module2) => {
  "use strict";
  var pna = require_process_nextick_args();
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
        pna.nextTick(emitErrorNT, this, err);
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        pna.nextTick(emitErrorNT, _this, err2);
        if (_this._writableState) {
          _this._writableState.errorEmitted = true;
        }
      } else if (cb) {
        cb(err2);
      }
    });
    return this;
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  module2.exports = {
    destroy,
    undestroy
  };
});

// ../../node_modules/.pnpm/util-deprecate@1.0.2/node_modules/util-deprecate/node.js
var require_node4 = __commonJS((exports2, module2) => {
  module2.exports = require("util").deprecate;
});

// ../../node_modules/.pnpm/readable-stream@2.3.7/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS((exports2, module2) => {
  "use strict";
  var pna = require_process_nextick_args();
  module2.exports = Writable;
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state);
    };
  }
  var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
  var Duplex;
  Writable.WritableState = WritableState;
  var util2 = Object.create(require_util5());
  util2.inherits = require_inherits();
  var internalUtil = {
    deprecate: require_node4()
  };
  var Stream = require_stream6();
  var Buffer2 = require_safe_buffer().Buffer;
  var OurUint8Array = global.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = require_destroy();
  util2.inherits(Writable, Stream);
  function nop() {
  }
  function WritableState(options, stream) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    var isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0))
      this.highWaterMark = writableHwm;
    else
      this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_2) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function(object) {
      return object instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require_stream_duplex();
    if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
      return new Writable(options);
    }
    this._writableState = new WritableState(options, this);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function writeAfterEnd(stream, cb) {
    var er = new Error("write after end");
    stream.emit("error", er);
    pna.nextTick(cb, er);
  }
  function validChunk(stream, state, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
      er = new TypeError("May not write null values to stream");
    } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
      stream.emit("error", er);
      pna.nextTick(cb, er);
      valid = false;
    }
    return valid;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state.ended)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    var state = this._writableState;
    state.corked++;
  };
  Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (writev)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, sync2, er, cb) {
    --state.pendingcb;
    if (sync2) {
      pna.nextTick(cb, er);
      pna.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
      finishMaybe(stream, state);
    }
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync2 = state.sync;
    var cb = state.writecb;
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream, state, sync2, er, cb);
    else {
      var finished = needFinish(state);
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }
      if (sync2) {
        asyncWrite(afterWrite, stream, state, finished, cb);
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  }
  function afterWrite(stream, state, finished, cb) {
    if (!finished)
      onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l = state.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream, state, true, state.length, buffer, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("_write() is not implemented"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0)
      this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending && !state.finished)
      endWritable(this, state, cb);
  };
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function callFinal(stream, state) {
    stream._final(function(err) {
      state.pendingcb--;
      if (err) {
        stream.emit("error", err);
      }
      state.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state);
    });
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === "function") {
        state.pendingcb++;
        state.finalCalled = true;
        pna.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit("finish");
      }
    }
    return need;
  }
  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished)
        pna.nextTick(cb);
      else
        stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = corkReq;
    } else {
      state.corkedRequestsFree = corkReq;
    }
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    get: function() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    this.end();
    cb(err);
  };
});

// ../../node_modules/.pnpm/readable-stream@2.3.7/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS((exports2, module2) => {
  "use strict";
  var pna = require_process_nextick_args();
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  module2.exports = Duplex;
  var util2 = Object.create(require_util5());
  util2.inherits = require_inherits();
  var Readable = require_stream_readable();
  var Writable = require_stream_writable();
  util2.inherits(Duplex, Readable);
  {
    keys = objectKeys(Writable.prototype);
    for (v = 0; v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  var keys;
  var method;
  var v;
  function Duplex(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    if (options && options.readable === false)
      this.readable = false;
    if (options && options.writable === false)
      this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false)
      this.allowHalfOpen = false;
    this.once("end", onend);
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended)
      return;
    pna.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  Duplex.prototype._destroy = function(err, cb) {
    this.push(null);
    this.end();
    pna.nextTick(cb, err);
  };
});

// ../../node_modules/.pnpm/readable-stream@2.3.7/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS((exports2, module2) => {
  "use strict";
  var pna = require_process_nextick_args();
  module2.exports = Readable;
  var isArray = require_isarray();
  var Duplex;
  Readable.ReadableState = ReadableState;
  var EE = require("events").EventEmitter;
  var EElistenerCount = function(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream = require_stream6();
  var Buffer2 = require_safe_buffer().Buffer;
  var OurUint8Array = global.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var util2 = Object.create(require_util5());
  util2.inherits = require_inherits();
  var debugUtil = require("util");
  var debug3 = void 0;
  if (debugUtil && debugUtil.debuglog) {
    debug3 = debugUtil.debuglog("stream");
  } else {
    debug3 = function() {
    };
  }
  var BufferList = require_BufferList();
  var destroyImpl = require_destroy();
  var StringDecoder;
  util2.inherits(Readable, Stream);
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    var isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    var hwm = options.highWaterMark;
    var readableHwm = options.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0))
      this.highWaterMark = readableHwm;
    else
      this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = require("string_decoder/").StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex = Duplex || require_stream_duplex();
    if (!(this instanceof Readable))
      return new Readable(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    this.push(null);
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    var state = stream._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit("error", er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state.endEmitted)
            stream.emit("error", new Error("stream.unshift() after end event"));
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          stream.emit("error", new Error("stream.push() after EOF"));
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
      }
    }
    return needMoreData(state);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      stream.emit("data", chunk);
      stream.read(0);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if (state.needReadable)
        emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  }
  function needMoreData(state) {
    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = require("string_decoder/").StringDecoder;
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
  };
  var MAX_HWM = 8388608;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n !== n) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length)
      return n;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  Readable.prototype.read = function(n) {
    debug3("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0)
      state.emittedReadable = false;
    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
      debug3("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug3("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug3("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug3("reading or ended", doRead);
    } else if (doRead) {
      debug3("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0)
        state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading)
        n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0)
      ret = fromList(n, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = true;
      n = 0;
    } else {
      state.length -= n;
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state) {
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    emitReadable(stream);
  }
  function emitReadable(stream) {
    var state = stream._readableState;
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug3("emitReadable", state.flowing);
      state.emittedReadable = true;
      if (state.sync)
        pna.nextTick(emitReadable_, stream);
      else
        emitReadable_(stream);
    }
  }
  function emitReadable_(stream) {
    debug3("emit readable");
    stream.emit("readable");
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      pna.nextTick(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    var len = state.length;
    while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
      debug3("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
      else
        len = state.length;
    }
    state.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug3("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      pna.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug3("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup2();
        }
      }
    }
    function onend() {
      debug3("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup2() {
      debug3("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    var increasedAwaitDrain = false;
    src.on("data", ondata);
    function ondata(chunk) {
      debug3("ondata");
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (ret === false && !increasedAwaitDrain) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug3("false write response, pause", src._readableState.awaitDrain);
          src._readableState.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug3("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        dest.emit("error", er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug3("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug3("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug3("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function() {
      var state = src._readableState;
      debug3("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {hasUnpiped: false};
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i = 0; i < len; i++) {
        dests[i].emit("unpipe", this, unpipeInfo);
      }
      return this;
    }
    var index = indexOf(state.pipes, dest);
    if (index === -1)
      return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
      state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    if (ev === "data") {
      if (this._readableState.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      var state = this._readableState;
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.emittedReadable = false;
        if (!state.reading) {
          pna.nextTick(nReadingNextTick, this);
        } else if (state.length) {
          emitReadable(this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  function nReadingNextTick(self2) {
    debug3("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug3("resume");
      state.flowing = true;
      resume(this, state);
    }
    return this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      pna.nextTick(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    if (!state.reading) {
      debug3("resume read 0");
      stream.read(0);
    }
    state.resumeScheduled = false;
    state.awaitDrain = 0;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading)
      stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug3("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug3("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    return this;
  };
  function flow(stream) {
    var state = stream._readableState;
    debug3("flow", state.flowing);
    while (state.flowing && stream.read() !== null) {
    }
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug3("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug3("wrapped data");
      if (state.decoder)
        chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === void 0))
        return;
      else if (!state.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i in stream) {
      if (this[i] === void 0 && typeof stream[i] === "function") {
        this[i] = function(method) {
          return function() {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug3("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  });
  Readable._fromList = fromList;
  function fromList(n, state) {
    if (state.length === 0)
      return null;
    var ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n || n >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.head.data;
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = fromListPartial(n, state.buffer, state.decoder);
    }
    return ret;
  }
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      ret = list.shift();
    } else {
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length)
        ret += str;
      else
        ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function copyFromBuffer(n, list) {
    var ret = Buffer2.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function endReadable(stream) {
    var state = stream._readableState;
    if (state.length > 0)
      throw new Error('"endReadable()" called on non-empty stream');
    if (!state.endEmitted) {
      state.ended = true;
      pna.nextTick(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
    }
  }
  function indexOf(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x)
        return i;
    }
    return -1;
  }
});

// ../../node_modules/.pnpm/readable-stream@2.3.7/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Transform;
  var Duplex = require_stream_duplex();
  var util2 = Object.create(require_util5());
  util2.inherits = require_inherits();
  util2.inherits(Transform, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) {
      return this.emit("error", new Error("write callback called multiple times"));
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform))
      return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function") {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("_transform() is not implemented");
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    var _this2 = this;
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
      _this2.emit("close");
    });
  };
  function done(stream, er, data) {
    if (er)
      return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length)
      throw new Error("Calling transform done when ws.length != 0");
    if (stream._transformState.transforming)
      throw new Error("Calling transform done when still transforming");
    return stream.push(null);
  }
});

// ../../node_modules/.pnpm/readable-stream@2.3.7/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = PassThrough;
  var Transform = require_stream_transform();
  var util2 = Object.create(require_util5());
  util2.inherits = require_inherits();
  util2.inherits(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
});

// ../../node_modules/.pnpm/readable-stream@2.3.7/node_modules/readable-stream/readable.js
var require_readable = __commonJS((exports2, module2) => {
  var Stream = require("stream");
  if (process.env.READABLE_STREAM === "disable" && Stream) {
    module2.exports = Stream;
    exports2 = module2.exports = Stream.Readable;
    exports2.Readable = Stream.Readable;
    exports2.Writable = Stream.Writable;
    exports2.Duplex = Stream.Duplex;
    exports2.Transform = Stream.Transform;
    exports2.PassThrough = Stream.PassThrough;
    exports2.Stream = Stream;
  } else {
    exports2 = module2.exports = require_stream_readable();
    exports2.Stream = Stream || exports2;
    exports2.Readable = exports2;
    exports2.Writable = require_stream_writable();
    exports2.Duplex = require_stream_duplex();
    exports2.Transform = require_stream_transform();
    exports2.PassThrough = require_stream_passthrough();
  }
});

// ../../node_modules/.pnpm/readable-stream@2.3.7/node_modules/readable-stream/passthrough.js
var require_passthrough = __commonJS((exports2, module2) => {
  module2.exports = require_readable().PassThrough;
});

// ../../node_modules/.pnpm/lazystream@1.0.0/node_modules/lazystream/lib/lazystream.js
var require_lazystream = __commonJS((exports2, module2) => {
  var util2 = require("util");
  var PassThrough = require_passthrough();
  module2.exports = {
    Readable,
    Writable
  };
  util2.inherits(Readable, PassThrough);
  util2.inherits(Writable, PassThrough);
  function beforeFirstCall(instance, method, callback) {
    instance[method] = function() {
      delete instance[method];
      callback.apply(this, arguments);
      return this[method].apply(this, arguments);
    };
  }
  function Readable(fn, options) {
    if (!(this instanceof Readable))
      return new Readable(fn, options);
    PassThrough.call(this, options);
    beforeFirstCall(this, "_read", function() {
      var source = fn.call(this, options);
      var emit = this.emit.bind(this, "error");
      source.on("error", emit);
      source.pipe(this);
    });
    this.emit("readable");
  }
  function Writable(fn, options) {
    if (!(this instanceof Writable))
      return new Writable(fn, options);
    PassThrough.call(this, options);
    beforeFirstCall(this, "_write", function() {
      var destination = fn.call(this, options);
      var emit = this.emit.bind(this, "error");
      destination.on("error", emit);
      this.pipe(destination);
    });
    this.emit("writable");
  }
});

// ../../node_modules/.pnpm/normalize-path@3.0.0/node_modules/normalize-path/index.js
var require_normalize_path = __commonJS((exports2, module2) => {
  /*!
   * normalize-path <https://github.com/jonschlinkert/normalize-path>
   *
   * Copyright (c) 2014-2018, Jon Schlinkert.
   * Released under the MIT License.
   */
  module2.exports = function(path10, stripTrailing) {
    if (typeof path10 !== "string") {
      throw new TypeError("expected path to be a string");
    }
    if (path10 === "\\" || path10 === "/")
      return "/";
    var len = path10.length;
    if (len <= 1)
      return path10;
    var prefix = "";
    if (len > 4 && path10[3] === "\\") {
      var ch = path10[2];
      if ((ch === "?" || ch === ".") && path10.slice(0, 2) === "\\\\") {
        path10 = path10.slice(2);
        prefix = "//";
      }
    }
    var segs = path10.split(/[/\\]+/);
    if (stripTrailing !== false && segs[segs.length - 1] === "") {
      segs.pop();
    }
    return prefix + segs.join("/");
  };
});

// ../../node_modules/.pnpm/lodash.defaults@4.2.0/node_modules/lodash.defaults/index.js
var require_lodash = __commonJS((exports2, module2) => {
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function apply(func, thisArg, args2) {
    switch (args2.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args2[0]);
      case 2:
        return func.call(thisArg, args2[0], args2[1]);
      case 3:
        return func.call(thisArg, args2[0], args2[1], args2[2]);
    }
    return func.apply(thisArg, args2);
  }
  function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var nativeMax = Math.max;
  function arrayLikeKeys(value, inherited) {
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function assignInDefaults(objValue, srcValue, key, object) {
    if (objValue === void 0 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
      return srcValue;
    }
    return objValue;
  }
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
      object[key] = value;
    }
  }
  function baseKeysIn(object) {
    if (!isObject(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object), result = [];
    for (var key in object) {
      if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }
  function baseRest(func, start) {
    start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
    return function() {
      var args2 = arguments, index = -1, length = nativeMax(args2.length - start, 0), array = Array(length);
      while (++index < length) {
        array[index] = args2[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args2[index];
      }
      otherArgs[start] = array;
      return apply(func, this, otherArgs);
    };
  }
  function copyObject(source, props, object, customizer) {
    object || (object = {});
    var index = -1, length = props.length;
    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
      assignValue(object, key, newValue === void 0 ? source[key] : newValue);
    }
    return object;
  }
  function createAssigner(assigner) {
    return baseRest(function(object, sources) {
      var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? void 0 : customizer;
        length = 1;
      }
      object = Object(object);
      while (++index < length) {
        var source = sources[index];
        if (source) {
          assigner(object, source, index, customizer);
        }
      }
      return object;
    });
  }
  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isIterateeCall(value, index, object) {
    if (!isObject(object)) {
      return false;
    }
    var type = typeof index;
    if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
      return eq(object[index], value);
    }
    return false;
  }
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
  }
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  }
  var isArray = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
    copyObject(source, keysIn(source), object, customizer);
  });
  var defaults = baseRest(function(args2) {
    args2.push(void 0, assignInDefaults);
    return apply(assignInWith, void 0, args2);
  });
  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }
  module2.exports = defaults;
});

// ../../node_modules/.pnpm/lodash.flatten@4.4.0/node_modules/lodash.flatten/index.js
var require_lodash2 = __commonJS((exports2, module2) => {
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var Symbol2 = root.Symbol;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1, length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index < length) {
      var value = array[index];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }
  function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  function flatten(array) {
    var length = array ? array.length : 0;
    return length ? baseFlatten(array, 1) : [];
  }
  function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  }
  var isArray = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  module2.exports = flatten;
});

// ../../node_modules/.pnpm/lodash.difference@4.5.0/node_modules/lodash.difference/index.js
var require_lodash3 = __commonJS((exports2, module2) => {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  function apply(func, thisArg, args2) {
    switch (args2.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args2[0]);
      case 2:
        return func.call(thisArg, args2[0], args2[1]);
      case 3:
        return func.call(thisArg, args2[0], args2[1], args2[2]);
    }
    return func.apply(thisArg, args2);
  }
  function arrayIncludes(array, value) {
    var length = array ? array.length : 0;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }
  function arrayIncludesWith(array, value, comparator) {
    var index = -1, length = array ? array.length : 0;
    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }
  function arrayMap(array, iteratee) {
    var index = -1, length = array ? array.length : 0, result = Array(length);
    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }
  function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }
  function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
      return baseFindIndex(array, baseIsNaN, fromIndex);
    }
    var index = fromIndex - 1, length = array.length;
    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }
  function baseIsNaN(value) {
    return value !== value;
  }
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  function cacheHas(cache, key) {
    return cache.has(key);
  }
  function getValue(object, key) {
    return object == null ? void 0 : object[key];
  }
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result = !!(value + "");
      } catch (e) {
      }
    }
    return result;
  }
  var arrayProto = Array.prototype;
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var coreJsData = root["__core-js_shared__"];
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  var Symbol2 = root.Symbol;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var splice = arrayProto.splice;
  var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
  var nativeMax = Math.max;
  var Map2 = getNative(root, "Map");
  var nativeCreate = getNative(Object, "create");
  function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }
  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : void 0;
  }
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
  }
  function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
  }
  function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    return true;
  }
  function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? void 0 : data[index][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.__data__ = {
      hash: new Hash(),
      map: new (Map2 || ListCache)(),
      string: new Hash()
    };
  }
  function mapCacheDelete(key) {
    return getMapData(this, key)["delete"](key);
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function SetCache(values) {
    var index = -1, length = values ? values.length : 0;
    this.__data__ = new MapCache();
    while (++index < length) {
      this.add(values[index]);
    }
  }
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseDifference(array, values, iteratee, comparator) {
    var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
    if (!length) {
      return result;
    }
    if (iteratee) {
      values = arrayMap(values, baseUnary(iteratee));
    }
    if (comparator) {
      includes = arrayIncludesWith;
      isCommon = false;
    } else if (values.length >= LARGE_ARRAY_SIZE) {
      includes = cacheHas;
      isCommon = false;
      values = new SetCache(values);
    }
    outer:
      while (++index < length) {
        var value = array[index], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        } else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
    return result;
  }
  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1, length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index < length) {
      var value = array[index];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function baseRest(func, start) {
    start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
    return function() {
      var args2 = arguments, index = -1, length = nativeMax(args2.length - start, 0), array = Array(length);
      while (++index < length) {
        array[index] = args2[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args2[index];
      }
      otherArgs[start] = array;
      return apply(func, this, otherArgs);
    };
  }
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : void 0;
  }
  function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  var difference = baseRest(function(array, values) {
    return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
  });
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  }
  var isArray = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  module2.exports = difference;
});

// ../../node_modules/.pnpm/lodash.union@4.6.0/node_modules/lodash.union/index.js
var require_lodash4 = __commonJS((exports2, module2) => {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var INFINITY = 1 / 0;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  function apply(func, thisArg, args2) {
    switch (args2.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args2[0]);
      case 2:
        return func.call(thisArg, args2[0], args2[1]);
      case 3:
        return func.call(thisArg, args2[0], args2[1], args2[2]);
    }
    return func.apply(thisArg, args2);
  }
  function arrayIncludes(array, value) {
    var length = array ? array.length : 0;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }
  function arrayIncludesWith(array, value, comparator) {
    var index = -1, length = array ? array.length : 0;
    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }
  function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }
  function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
      return baseFindIndex(array, baseIsNaN, fromIndex);
    }
    var index = fromIndex - 1, length = array.length;
    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }
  function baseIsNaN(value) {
    return value !== value;
  }
  function cacheHas(cache, key) {
    return cache.has(key);
  }
  function getValue(object, key) {
    return object == null ? void 0 : object[key];
  }
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result = !!(value + "");
      } catch (e) {
      }
    }
    return result;
  }
  function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }
  var arrayProto = Array.prototype;
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var coreJsData = root["__core-js_shared__"];
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  var Symbol2 = root.Symbol;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var splice = arrayProto.splice;
  var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
  var nativeMax = Math.max;
  var Map2 = getNative(root, "Map");
  var Set2 = getNative(root, "Set");
  var nativeCreate = getNative(Object, "create");
  function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }
  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : void 0;
  }
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
  }
  function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
  }
  function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    return true;
  }
  function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? void 0 : data[index][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.__data__ = {
      hash: new Hash(),
      map: new (Map2 || ListCache)(),
      string: new Hash()
    };
  }
  function mapCacheDelete(key) {
    return getMapData(this, key)["delete"](key);
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function SetCache(values) {
    var index = -1, length = values ? values.length : 0;
    this.__data__ = new MapCache();
    while (++index < length) {
      this.add(values[index]);
    }
  }
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1, length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index < length) {
      var value = array[index];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function baseRest(func, start) {
    start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
    return function() {
      var args2 = arguments, index = -1, length = nativeMax(args2.length - start, 0), array = Array(length);
      while (++index < length) {
        array[index] = args2[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args2[index];
      }
      otherArgs[start] = array;
      return apply(func, this, otherArgs);
    };
  }
  function baseUniq(array, iteratee, comparator) {
    var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
    if (comparator) {
      isCommon = false;
      includes = arrayIncludesWith;
    } else if (length >= LARGE_ARRAY_SIZE) {
      var set = iteratee ? null : createSet(array);
      if (set) {
        return setToArray(set);
      }
      isCommon = false;
      includes = cacheHas;
      seen = new SetCache();
    } else {
      seen = iteratee ? [] : result;
    }
    outer:
      while (++index < length) {
        var value = array[index], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        } else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
    return result;
  }
  var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
    return new Set2(values);
  };
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : void 0;
  }
  function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  var union = baseRest(function(arrays) {
    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
  });
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  }
  var isArray = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function noop() {
  }
  module2.exports = union;
});

// ../../node_modules/.pnpm/lodash.isplainobject@4.0.6/node_modules/lodash.isplainobject/index.js
var require_lodash5 = __commonJS((exports2, module2) => {
  var objectTag = "[object Object]";
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result = !!(value + "");
      } catch (e) {
      }
    }
    return result;
  }
  function overArg(func, transform) {
    return function(arg10) {
      return func(transform(arg10));
    };
  }
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  var objectToString = objectProto.toString;
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isPlainObject(value) {
    if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  module2.exports = isPlainObject;
});

// ../../node_modules/.pnpm/archiver-utils@2.1.0/node_modules/archiver-utils/file.js
var require_file = __commonJS((exports2, module2) => {
  var fs9 = require_graceful_fs();
  var path10 = require("path");
  var flatten = require_lodash2();
  var difference = require_lodash3();
  var union = require_lodash4();
  var isPlainObject = require_lodash5();
  var glob = require_glob();
  var file = module2.exports = {};
  var pathSeparatorRe = /[\/\\]/g;
  var processPatterns = function(patterns, fn) {
    var result = [];
    flatten(patterns).forEach(function(pattern) {
      var exclusion = pattern.indexOf("!") === 0;
      if (exclusion) {
        pattern = pattern.slice(1);
      }
      var matches = fn(pattern);
      if (exclusion) {
        result = difference(result, matches);
      } else {
        result = union(result, matches);
      }
    });
    return result;
  };
  file.exists = function() {
    var filepath = path10.join.apply(path10, arguments);
    return fs9.existsSync(filepath);
  };
  file.expand = function(...args2) {
    var options = isPlainObject(args2[0]) ? args2.shift() : {};
    var patterns = Array.isArray(args2[0]) ? args2[0] : args2;
    if (patterns.length === 0) {
      return [];
    }
    var matches = processPatterns(patterns, function(pattern) {
      return glob.sync(pattern, options);
    });
    if (options.filter) {
      matches = matches.filter(function(filepath) {
        filepath = path10.join(options.cwd || "", filepath);
        try {
          if (typeof options.filter === "function") {
            return options.filter(filepath);
          } else {
            return fs9.statSync(filepath)[options.filter]();
          }
        } catch (e) {
          return false;
        }
      });
    }
    return matches;
  };
  file.expandMapping = function(patterns, destBase, options) {
    options = Object.assign({
      rename: function(destBase2, destPath) {
        return path10.join(destBase2 || "", destPath);
      }
    }, options);
    var files = [];
    var fileByDest = {};
    file.expand(options, patterns).forEach(function(src) {
      var destPath = src;
      if (options.flatten) {
        destPath = path10.basename(destPath);
      }
      if (options.ext) {
        destPath = destPath.replace(/(\.[^\/]*)?$/, options.ext);
      }
      var dest = options.rename(destBase, destPath, options);
      if (options.cwd) {
        src = path10.join(options.cwd, src);
      }
      dest = dest.replace(pathSeparatorRe, "/");
      src = src.replace(pathSeparatorRe, "/");
      if (fileByDest[dest]) {
        fileByDest[dest].src.push(src);
      } else {
        files.push({
          src: [src],
          dest
        });
        fileByDest[dest] = files[files.length - 1];
      }
    });
    return files;
  };
  file.normalizeFilesArray = function(data) {
    var files = [];
    data.forEach(function(obj) {
      var prop;
      if ("src" in obj || "dest" in obj) {
        files.push(obj);
      }
    });
    if (files.length === 0) {
      return [];
    }
    files = _(files).chain().forEach(function(obj) {
      if (!("src" in obj) || !obj.src) {
        return;
      }
      if (Array.isArray(obj.src)) {
        obj.src = flatten(obj.src);
      } else {
        obj.src = [obj.src];
      }
    }).map(function(obj) {
      var expandOptions = Object.assign({}, obj);
      delete expandOptions.src;
      delete expandOptions.dest;
      if (obj.expand) {
        return file.expandMapping(obj.src, obj.dest, expandOptions).map(function(mapObj) {
          var result2 = Object.assign({}, obj);
          result2.orig = Object.assign({}, obj);
          result2.src = mapObj.src;
          result2.dest = mapObj.dest;
          ["expand", "cwd", "flatten", "rename", "ext"].forEach(function(prop) {
            delete result2[prop];
          });
          return result2;
        });
      }
      var result = Object.assign({}, obj);
      result.orig = Object.assign({}, obj);
      if ("src" in result) {
        Object.defineProperty(result, "src", {
          enumerable: true,
          get: function fn() {
            var src;
            if (!("result" in fn)) {
              src = obj.src;
              src = Array.isArray(src) ? flatten(src) : [src];
              fn.result = file.expand(expandOptions, src);
            }
            return fn.result;
          }
        });
      }
      if ("dest" in result) {
        result.dest = obj.dest;
      }
      return result;
    }).flatten().value();
    return files;
  };
});

// ../../node_modules/.pnpm/archiver-utils@2.1.0/node_modules/archiver-utils/index.js
var require_archiver_utils = __commonJS((exports2, module2) => {
  var fs9 = require_graceful_fs();
  var path10 = require("path");
  var nutil = require("util");
  var lazystream = require_lazystream();
  var normalizePath = require_normalize_path();
  var defaults = require_lodash();
  var Stream = require("stream").Stream;
  var PassThrough = require_readable().PassThrough;
  var utils = module2.exports = {};
  utils.file = require_file();
  utils.collectStream = function(source, callback) {
    var collection = [];
    var size = 0;
    source.on("error", callback);
    source.on("data", function(chunk) {
      collection.push(chunk);
      size += chunk.length;
    });
    source.on("end", function() {
      var buf = new Buffer(size);
      var offset = 0;
      collection.forEach(function(data) {
        data.copy(buf, offset);
        offset += data.length;
      });
      callback(null, buf);
    });
  };
  utils.dateify = function(dateish) {
    dateish = dateish || new Date();
    if (dateish instanceof Date) {
      dateish = dateish;
    } else if (typeof dateish === "string") {
      dateish = new Date(dateish);
    } else {
      dateish = new Date();
    }
    return dateish;
  };
  utils.defaults = function(object, source, guard) {
    var args2 = arguments;
    args2[0] = args2[0] || {};
    return defaults(...args2);
  };
  utils.isStream = function(source) {
    return source instanceof Stream;
  };
  utils.lazyReadStream = function(filepath) {
    return new lazystream.Readable(function() {
      return fs9.createReadStream(filepath);
    });
  };
  utils.normalizeInputSource = function(source) {
    if (source === null) {
      return new Buffer(0);
    } else if (typeof source === "string") {
      return new Buffer(source);
    } else if (utils.isStream(source) && !source._readableState) {
      var normalized = new PassThrough();
      source.pipe(normalized);
      return normalized;
    }
    return source;
  };
  utils.sanitizePath = function(filepath) {
    return normalizePath(filepath, false).replace(/^\w+:/, "").replace(/^(\.\.\/|\/)+/, "");
  };
  utils.trailingSlashIt = function(str) {
    return str.slice(-1) !== "/" ? str + "/" : str;
  };
  utils.unixifyPath = function(filepath) {
    return normalizePath(filepath, false).replace(/^\w+:/, "");
  };
  utils.walkdir = function(dirpath, base, callback) {
    var results = [];
    if (typeof base === "function") {
      callback = base;
      base = dirpath;
    }
    fs9.readdir(dirpath, function(err, list) {
      var i = 0;
      var file;
      var filepath;
      if (err) {
        return callback(err);
      }
      (function next() {
        file = list[i++];
        if (!file) {
          return callback(null, results);
        }
        filepath = path10.join(dirpath, file);
        fs9.stat(filepath, function(err2, stats) {
          results.push({
            path: filepath,
            relative: path10.relative(base, filepath).replace(/\\/g, "/"),
            stats
          });
          if (stats && stats.isDirectory()) {
            utils.walkdir(filepath, base, function(err3, res) {
              res.forEach(function(dirEntry) {
                results.push(dirEntry);
              });
              next();
            });
          } else {
            next();
          }
        });
      })();
    });
  };
});

// ../../node_modules/.pnpm/archiver@4.0.2/node_modules/archiver/lib/error.js
var require_error3 = __commonJS((exports2, module2) => {
  /**
   * Archiver Core
   *
   * @ignore
   * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
   * @copyright (c) 2012-2014 Chris Talkington, contributors.
   */
  var util2 = require("util");
  var ERROR_CODES = {
    ABORTED: "archive was aborted",
    DIRECTORYDIRPATHREQUIRED: "diretory dirpath argument must be a non-empty string value",
    DIRECTORYFUNCTIONINVALIDDATA: "invalid data returned by directory custom data function",
    ENTRYNAMEREQUIRED: "entry name must be a non-empty string value",
    FILEFILEPATHREQUIRED: "file filepath argument must be a non-empty string value",
    FINALIZING: "archive already finalizing",
    QUEUECLOSED: "queue closed",
    NOENDMETHOD: "no suitable finalize/end method defined by module",
    DIRECTORYNOTSUPPORTED: "support for directory entries not defined by module",
    FORMATSET: "archive format already set",
    INPUTSTEAMBUFFERREQUIRED: "input source must be valid Stream or Buffer instance",
    MODULESET: "module already set",
    SYMLINKNOTSUPPORTED: "support for symlink entries not defined by module",
    SYMLINKFILEPATHREQUIRED: "symlink filepath argument must be a non-empty string value",
    SYMLINKTARGETREQUIRED: "symlink target argument must be a non-empty string value",
    ENTRYNOTSUPPORTED: "entry not supported"
  };
  function ArchiverError(code, data) {
    Error.captureStackTrace(this, this.constructor);
    this.message = ERROR_CODES[code] || code;
    this.code = code;
    this.data = data;
  }
  util2.inherits(ArchiverError, Error);
  exports2 = module2.exports = ArchiverError;
});

// ../../node_modules/.pnpm/readable-stream@3.6.0/node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream7 = __commonJS((exports2, module2) => {
  module2.exports = require("stream");
});

// ../../node_modules/.pnpm/readable-stream@3.6.0/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS((exports2, module2) => {
  "use strict";
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  var _require = require("buffer");
  var Buffer2 = _require.Buffer;
  var _require2 = require("util");
  var inspect = _require2.inspect;
  var custom = inspect && inspect.custom || "inspect";
  function copyBuffer(src, target, offset) {
    Buffer2.prototype.copy.call(src, target, offset);
  }
  module2.exports = /* @__PURE__ */ function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList, [{
      key: "push",
      value: function push(v) {
        var entry = {
          data: v,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v) {
        var entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join2(s2) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s2 + p.data;
        }
        return ret;
      }
    }, {
      key: "concat",
      value: function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
    }, {
      key: "consume",
      value: function consume(n, hasStrings) {
        var ret;
        if (n < this.head.data.length) {
          ret = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
    }, {
      key: "_getString",
      value: function _getString(n) {
        var p = this.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length)
            ret += str;
          else
            ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n) {
        var ret = Buffer2.allocUnsafe(n);
        var p = this.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
    }, {
      key: custom,
      value: function value(_2, options) {
        return inspect(this, _objectSpread({}, options, {
          depth: 0,
          customInspect: false
        }));
      }
    }]);
    return BufferList;
  }();
});

// ../../node_modules/.pnpm/readable-stream@3.6.0/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy2 = __commonJS((exports2, module2) => {
  "use strict";
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          process.nextTick(emitErrorAndCloseNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process.nextTick(emitErrorAndCloseNT, _this, err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process.nextTick(emitCloseNT, _this);
        cb(err2);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    });
    return this;
  }
  function emitErrorAndCloseNT(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    if (self2._writableState && !self2._writableState.emitClose)
      return;
    if (self2._readableState && !self2._readableState.emitClose)
      return;
    self2.emit("close");
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  function errorOrDestroy(stream, err) {
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy)
      stream.destroy(err);
    else
      stream.emit("error", err);
  }
  module2.exports = {
    destroy,
    undestroy,
    errorOrDestroy
  };
});

// ../../node_modules/.pnpm/readable-stream@3.6.0/node_modules/readable-stream/errors.js
var require_errors2 = __commonJS((exports2, module2) => {
  "use strict";
  var codes = {};
  function createErrorType(code, message, Base) {
    if (!Base) {
      Base = Error;
    }
    function getMessage(arg1, arg22, arg32) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg22, arg32);
      }
    }
    class NodeError extends Base {
      constructor(arg1, arg22, arg32) {
        super(getMessage(arg1, arg22, arg32));
      }
    }
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
  }
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      const len = expected.length;
      expected = expected.map((i) => String(i));
      if (len > 2) {
        return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
      } else if (len === 2) {
        return `one of ${thing} ${expected[0]} or ${expected[1]}`;
      } else {
        return `of ${thing} ${expected[0]}`;
      }
    } else {
      return `of ${thing} ${String(expected)}`;
    }
  }
  function startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
  }
  function endsWith(str, search, this_len) {
    if (this_len === void 0 || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function includes(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }
  createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    let determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    let msg;
    if (endsWith(name, " argument")) {
      msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
    } else {
      const type = includes(name, ".") ? "property" : "argument";
      msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
    }
    msg += `. Received type ${typeof actual}`;
    return msg;
  }, TypeError);
  createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
    return "The " + name + " method is not implemented";
  });
  createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  createErrorType("ERR_STREAM_DESTROYED", function(name) {
    return "Cannot call " + name + " after a stream was destroyed";
  });
  createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  createErrorType("ERR_UNKNOWN_ENCODING", function(arg10) {
    return "Unknown encoding: " + arg10;
  }, TypeError);
  createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  module2.exports.codes = codes;
});

// ../../node_modules/.pnpm/readable-stream@3.6.0/node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS((exports2, module2) => {
  "use strict";
  var ERR_INVALID_OPT_VALUE = require_errors2().codes.ERR_INVALID_OPT_VALUE;
  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }
  function getHighWaterMark(state, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name, hwm);
      }
      return Math.floor(hwm);
    }
    return state.objectMode ? 16 : 16 * 1024;
  }
  module2.exports = {
    getHighWaterMark
  };
});

// ../../node_modules/.pnpm/readable-stream@3.6.0/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Writable;
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state);
    };
  }
  var Duplex;
  Writable.WritableState = WritableState;
  var internalUtil = {
    deprecate: require_node4()
  };
  var Stream = require_stream7();
  var Buffer2 = require("buffer").Buffer;
  var OurUint8Array = global.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = require_destroy2();
  var _require = require_state();
  var getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = require_errors2().codes;
  var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
  var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
  var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
  var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
  var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  require_inherits()(Writable, Stream);
  function nop() {
  }
  function WritableState(options, stream, isDuplex) {
    Duplex = Duplex || require_stream_duplex2();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_2) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function value(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance2(object) {
      return object instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require_stream_duplex2();
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this))
      return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
  };
  function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
  }
  function validChunk(stream, state, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== "string" && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
      return false;
    }
    return true;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state.ending)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableBuffer", {
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed)
      state.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, sync2, er, cb) {
    --state.pendingcb;
    if (sync2) {
      process.nextTick(cb, er);
      process.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
      finishMaybe(stream, state);
    }
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync2 = state.sync;
    var cb = state.writecb;
    if (typeof cb !== "function")
      throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream, state, sync2, er, cb);
    else {
      var finished = needFinish(state) || stream.destroyed;
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }
      if (sync2) {
        process.nextTick(afterWrite, stream, state, finished, cb);
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  }
  function afterWrite(stream, state, finished, cb) {
    if (!finished)
      onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l = state.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream, state, true, state.length, buffer, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0)
      this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending)
      endWritable(this, state, cb);
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableLength", {
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function callFinal(stream, state) {
    stream._final(function(err) {
      state.pendingcb--;
      if (err) {
        errorOrDestroy(stream, err);
      }
      state.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state);
    });
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === "function" && !state.destroyed) {
        state.pendingcb++;
        state.finalCalled = true;
        process.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit("finish");
        if (state.autoDestroy) {
          var rState = stream._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished)
        process.nextTick(cb);
      else
        stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    cb(err);
  };
});

// ../../node_modules/.pnpm/readable-stream@3.6.0/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex2 = __commonJS((exports2, module2) => {
  "use strict";
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  module2.exports = Duplex;
  var Readable = require_stream_readable2();
  var Writable = require_stream_writable2();
  require_inherits()(Duplex, Readable);
  {
    keys = objectKeys(Writable.prototype);
    for (v = 0; v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  var keys;
  var method;
  var v;
  function Duplex(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false)
        this.readable = false;
      if (options.writable === false)
        this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex.prototype, "writableBuffer", {
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex.prototype, "writableLength", {
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended)
      return;
    process.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
});

// ../../node_modules/.pnpm/readable-stream@3.6.0/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS((exports2, module2) => {
  "use strict";
  var ERR_STREAM_PREMATURE_CLOSE = require_errors2().codes.ERR_STREAM_PREMATURE_CLOSE;
  function once(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      for (var _len = arguments.length, args2 = new Array(_len), _key = 0; _key < _len; _key++) {
        args2[_key] = arguments[_key];
      }
      callback.apply(this, args2);
    };
  }
  function noop() {
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function eos(stream, opts, callback) {
    if (typeof opts === "function")
      return eos(stream, null, opts);
    if (!opts)
      opts = {};
    callback = once(callback || noop);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish2() {
      if (!stream.writable)
        onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish2() {
      writable = false;
      writableEnded = true;
      if (!readable)
        callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend2() {
      readable = false;
      readableEnded = true;
      if (!writable)
        callback.call(stream);
    };
    var onerror = function onerror2(err) {
      callback.call(stream, err);
    };
    var onclose = function onclose2() {
      var err;
      if (readable && !readableEnded) {
        if (!stream._readableState || !stream._readableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
      if (writable && !writableEnded) {
        if (!stream._writableState || !stream._writableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
    };
    var onrequest = function onrequest2() {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req)
        onrequest();
      else
        stream.on("request", onrequest);
    } else if (writable && !stream._writableState) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false)
      stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req)
        stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  }
  module2.exports = eos;
});

// ../../node_modules/.pnpm/readable-stream@3.6.0/node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS((exports2, module2) => {
  "use strict";
  var _Object$setPrototypeO;
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var finished = require_end_of_stream();
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult(value, done) {
    return {
      value,
      done
    };
  }
  function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
      var data = iter[kStream].read();
      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve(createIterResult(data, false));
      }
    }
  }
  function onReadable(iter) {
    process.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve(createIterResult(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error = this[kError];
      if (error !== null) {
        return Promise.reject(error);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve, reject) {
          process.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve(createIterResult(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data = this[kStream].read();
        if (data !== null) {
          return Promise.resolve(createIterResult(data, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve(createIterResult(void 0, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve, reject) {
        var data = iterator[kStream].read();
        if (data) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(data, false));
        } else {
          iterator[kLastResolve] = resolve;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator[kLastReject];
        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err);
        }
        iterator[kError] = err;
        return;
      }
      var resolve = iterator[kLastResolve];
      if (resolve !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(void 0, true));
      }
      iterator[kEnded] = true;
    });
    stream.on("readable", onReadable.bind(null, iterator));
    return iterator;
  };
  module2.exports = createReadableStreamAsyncIterator;
});

// ../../node_modules/.pnpm/readable-stream@3.6.0/node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS((exports2, module2) => {
  "use strict";
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg10) {
    try {
      var info = gen[key](arg10);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function() {
      var self2 = this, args2 = arguments;
      return new Promise(function(resolve, reject) {
        var gen = fn.apply(self2, args2);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(void 0);
      });
    };
  }
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var ERR_INVALID_ARG_TYPE = require_errors2().codes.ERR_INVALID_ARG_TYPE;
  function from(Readable, iterable, opts) {
    var iterator;
    if (iterable && typeof iterable.next === "function") {
      iterator = iterable;
    } else if (iterable && iterable[Symbol.asyncIterator])
      iterator = iterable[Symbol.asyncIterator]();
    else if (iterable && iterable[Symbol.iterator])
      iterator = iterable[Symbol.iterator]();
    else
      throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
    var readable = new Readable(_objectSpread({
      objectMode: true
    }, opts));
    var reading = false;
    readable._read = function() {
      if (!reading) {
        reading = true;
        next();
      }
    };
    function next() {
      return _next2.apply(this, arguments);
    }
    function _next2() {
      _next2 = _asyncToGenerator(function* () {
        try {
          var _ref = yield iterator.next(), value = _ref.value, done = _ref.done;
          if (done) {
            readable.push(null);
          } else if (readable.push(yield value)) {
            next();
          } else {
            reading = false;
          }
        } catch (err) {
          readable.destroy(err);
        }
      });
      return _next2.apply(this, arguments);
    }
    return readable;
  }
  module2.exports = from;
});

// ../../node_modules/.pnpm/readable-stream@3.6.0/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Readable;
  var Duplex;
  Readable.ReadableState = ReadableState;
  var EE = require("events").EventEmitter;
  var EElistenerCount = function EElistenerCount2(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream = require_stream7();
  var Buffer2 = require("buffer").Buffer;
  var OurUint8Array = global.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var debugUtil = require("util");
  var debug3;
  if (debugUtil && debugUtil.debuglog) {
    debug3 = debugUtil.debuglog("stream");
  } else {
    debug3 = function debug4() {
    };
  }
  var BufferList = require_buffer_list();
  var destroyImpl = require_destroy2();
  var _require = require_state();
  var getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = require_errors2().codes;
  var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
  var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;
  require_inherits()(Readable, Stream);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream, isDuplex) {
    Duplex = Duplex || require_stream_duplex2();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = require("string_decoder/").StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex = Duplex || require_stream_duplex2();
    if (!(this instanceof Readable))
      return new Readable(options);
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug3("readableAddChunk", chunk);
    var state = stream._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state, chunk);
      if (er) {
        errorOrDestroy(stream, er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state.endEmitted)
            errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed) {
          return false;
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
        maybeReadMore(stream, state);
      }
    }
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      state.awaitDrain = 0;
      stream.emit("data", chunk);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if (state.needReadable)
        emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = require("string_decoder/").StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p = this._readableState.buffer.head;
    var content = "";
    while (p !== null) {
      content += decoder.write(p.data);
      p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== "")
      this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n !== n) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length)
      return n;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  Readable.prototype.read = function(n) {
    debug3("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0)
      state.emittedReadable = false;
    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
      debug3("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug3("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug3("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug3("reading or ended", doRead);
    } else if (doRead) {
      debug3("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0)
        state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading)
        n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0)
      ret = fromList(n, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = state.length <= state.highWaterMark;
      n = 0;
    } else {
      state.length -= n;
      state.awaitDrain = 0;
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state) {
    debug3("onEofChunk");
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    if (state.sync) {
      emitReadable(stream);
    } else {
      state.needReadable = false;
      if (!state.emittedReadable) {
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
  }
  function emitReadable(stream) {
    var state = stream._readableState;
    debug3("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug3("emitReadable", state.flowing);
      state.emittedReadable = true;
      process.nextTick(emitReadable_, stream);
    }
  }
  function emitReadable_(stream) {
    var state = stream._readableState;
    debug3("emitReadable_", state.destroyed, state.length, state.ended);
    if (!state.destroyed && (state.length || state.ended)) {
      stream.emit("readable");
      state.emittedReadable = false;
    }
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      process.nextTick(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
      var len = state.length;
      debug3("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
    }
    state.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug3("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      process.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug3("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup2();
        }
      }
    }
    function onend() {
      debug3("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup2() {
      debug3("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug3("ondata");
      var ret = dest.write(chunk);
      debug3("dest.write", ret);
      if (ret === false) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug3("false write response, pause", state.awaitDrain);
          state.awaitDrain++;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug3("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        errorOrDestroy(dest, er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug3("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug3("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug3("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
      var state = src._readableState;
      debug3("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i = 0; i < len; i++) {
        dests[i].emit("unpipe", this, {
          hasUnpiped: false
        });
      }
      return this;
    }
    var index = indexOf(state.pipes, dest);
    if (index === -1)
      return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
      state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state = this._readableState;
    if (ev === "data") {
      state.readableListening = this.listenerCount("readable") > 0;
      if (state.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.flowing = false;
        state.emittedReadable = false;
        debug3("on readable", state.length, state.reading);
        if (state.length) {
          emitReadable(this);
        } else if (!state.reading) {
          process.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  Readable.prototype.removeListener = function(ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === void 0) {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    var state = self2._readableState;
    state.readableListening = self2.listenerCount("readable") > 0;
    if (state.resumeScheduled && !state.paused) {
      state.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug3("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug3("resume");
      state.flowing = !state.readableListening;
      resume(this, state);
    }
    state.paused = false;
    return this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      process.nextTick(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    debug3("resume", state.reading);
    if (!state.reading) {
      stream.read(0);
    }
    state.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading)
      stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug3("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug3("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream) {
    var state = stream._readableState;
    debug3("flow", state.flowing);
    while (state.flowing && stream.read() !== null) {
      ;
    }
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug3("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug3("wrapped data");
      if (state.decoder)
        chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === void 0))
        return;
      else if (!state.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i in stream) {
      if (this[i] === void 0 && typeof stream[i] === "function") {
        this[i] = function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug3("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === void 0) {
        createReadableStreamAsyncIterator = require_async_iterator();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable.prototype, "readableBuffer", {
    enumerable: false,
    get: function get() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable.prototype, "readableFlowing", {
    enumerable: false,
    get: function get() {
      return this._readableState.flowing;
    },
    set: function set(state) {
      if (this._readableState) {
        this._readableState.flowing = state;
      }
    }
  });
  Readable._fromList = fromList;
  Object.defineProperty(Readable.prototype, "readableLength", {
    enumerable: false,
    get: function get() {
      return this._readableState.length;
    }
  });
  function fromList(n, state) {
    if (state.length === 0)
      return null;
    var ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n || n >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.first();
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = state.buffer.consume(n, state.decoder);
    }
    return ret;
  }
  function endReadable(stream) {
    var state = stream._readableState;
    debug3("endReadable", state.endEmitted);
    if (!state.endEmitted) {
      state.ended = true;
      process.nextTick(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    debug3("endReadableNT", state.endEmitted, state.length);
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
      if (state.autoDestroy) {
        var wState = stream._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream.destroy();
        }
      }
    }
  }
  if (typeof Symbol === "function") {
    Readable.from = function(iterable, opts) {
      if (from === void 0) {
        from = require_from();
      }
      return from(Readable, iterable, opts);
    };
  }
  function indexOf(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x)
        return i;
    }
    return -1;
  }
});

// ../../node_modules/.pnpm/readable-stream@3.6.0/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Transform;
  var _require$codes = require_errors2().codes;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
  var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
  var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex = require_stream_duplex2();
  require_inherits()(Transform, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
      return this.emit("error", new ERR_MULTIPLE_CALLBACK());
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform))
      return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
    });
  };
  function done(stream, er, data) {
    if (er)
      return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length)
      throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream._transformState.transforming)
      throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream.push(null);
  }
});

// ../../node_modules/.pnpm/readable-stream@3.6.0/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = PassThrough;
  var Transform = require_stream_transform2();
  require_inherits()(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
});

// ../../node_modules/.pnpm/readable-stream@3.6.0/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS((exports2, module2) => {
  "use strict";
  var eos;
  function once(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      callback.apply(void 0, arguments);
    };
  }
  var _require$codes = require_errors2().codes;
  var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
  var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  function noop(err) {
    if (err)
      throw err;
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function destroyer(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on("close", function() {
      closed = true;
    });
    if (eos === void 0)
      eos = require_end_of_stream();
    eos(stream, {
      readable: reading,
      writable: writing
    }, function(err) {
      if (err)
        return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed)
        return;
      if (destroyed)
        return;
      destroyed = true;
      if (isRequest(stream))
        return stream.abort();
      if (typeof stream.destroy === "function")
        return stream.destroy();
      callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
  }
  function call(fn) {
    fn();
  }
  function pipe(from, to) {
    return from.pipe(to);
  }
  function popCallback(streams) {
    if (!streams.length)
      return noop;
    if (typeof streams[streams.length - 1] !== "function")
      return noop;
    return streams.pop();
  }
  function pipeline() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
      streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0]))
      streams = streams[0];
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    var error;
    var destroys = streams.map(function(stream, i) {
      var reading = i < streams.length - 1;
      var writing = i > 0;
      return destroyer(stream, reading, writing, function(err) {
        if (!error)
          error = err;
        if (err)
          destroys.forEach(call);
        if (reading)
          return;
        destroys.forEach(call);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  }
  module2.exports = pipeline;
});

// ../../node_modules/.pnpm/readable-stream@3.6.0/node_modules/readable-stream/readable.js
var require_readable2 = __commonJS((exports2, module2) => {
  var Stream = require("stream");
  if (process.env.READABLE_STREAM === "disable" && Stream) {
    module2.exports = Stream.Readable;
    Object.assign(module2.exports, Stream);
    module2.exports.Stream = Stream;
  } else {
    exports2 = module2.exports = require_stream_readable2();
    exports2.Stream = Stream || exports2;
    exports2.Readable = exports2;
    exports2.Writable = require_stream_writable2();
    exports2.Duplex = require_stream_duplex2();
    exports2.Transform = require_stream_transform2();
    exports2.PassThrough = require_stream_passthrough2();
    exports2.finished = require_end_of_stream();
    exports2.pipeline = require_pipeline();
  }
});

// ../../node_modules/.pnpm/archiver@4.0.2/node_modules/archiver/lib/core.js
var require_core5 = __commonJS((exports2, module2) => {
  /**
   * Archiver Core
   *
   * @ignore
   * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
   * @copyright (c) 2012-2014 Chris Talkington, contributors.
   */
  var fs9 = require("fs");
  var glob = require_glob();
  var async = require_async7();
  var path10 = require("path");
  var util2 = require_archiver_utils();
  var inherits = require("util").inherits;
  var ArchiverError = require_error3();
  var Transform = require_readable2().Transform;
  var win32 = process.platform === "win32";
  var Archiver = function(format10, options) {
    if (!(this instanceof Archiver)) {
      return new Archiver(format10, options);
    }
    if (typeof format10 !== "string") {
      options = format10;
      format10 = "zip";
    }
    options = this.options = util2.defaults(options, {
      highWaterMark: 1024 * 1024,
      statConcurrency: 4
    });
    Transform.call(this, options);
    this._format = false;
    this._module = false;
    this._pending = 0;
    this._pointer = 0;
    this._entriesCount = 0;
    this._entriesProcessedCount = 0;
    this._fsEntriesTotalBytes = 0;
    this._fsEntriesProcessedBytes = 0;
    this._queue = async.queue(this._onQueueTask.bind(this), 1);
    this._queue.drain(this._onQueueDrain.bind(this));
    this._statQueue = async.queue(this._onStatQueueTask.bind(this), options.statConcurrency);
    this._statQueue.drain(this._onQueueDrain.bind(this));
    this._state = {
      aborted: false,
      finalize: false,
      finalizing: false,
      finalized: false,
      modulePiped: false
    };
    this._streams = [];
  };
  inherits(Archiver, Transform);
  Archiver.prototype._abort = function() {
    this._state.aborted = true;
    this._queue.kill();
    this._statQueue.kill();
    if (this._queue.idle()) {
      this._shutdown();
    }
  };
  Archiver.prototype._append = function(filepath, data) {
    data = data || {};
    var task = {
      source: null,
      filepath
    };
    if (!data.name) {
      data.name = filepath;
    }
    data.sourcePath = filepath;
    task.data = data;
    this._entriesCount++;
    if (data.stats && data.stats instanceof fs9.Stats) {
      task = this._updateQueueTaskWithStats(task, data.stats);
      if (task) {
        if (data.stats.size) {
          this._fsEntriesTotalBytes += data.stats.size;
        }
        this._queue.push(task);
      }
    } else {
      this._statQueue.push(task);
    }
  };
  Archiver.prototype._finalize = function() {
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
      return;
    }
    this._state.finalizing = true;
    this._moduleFinalize();
    this._state.finalizing = false;
    this._state.finalized = true;
  };
  Archiver.prototype._maybeFinalize = function() {
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
      return false;
    }
    if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {
      this._finalize();
      return true;
    }
    return false;
  };
  Archiver.prototype._moduleAppend = function(source, data, callback) {
    if (this._state.aborted) {
      callback();
      return;
    }
    this._module.append(source, data, function(err) {
      this._task = null;
      if (this._state.aborted) {
        this._shutdown();
        return;
      }
      if (err) {
        this.emit("error", err);
        setImmediate(callback);
        return;
      }
      this.emit("entry", data);
      this._entriesProcessedCount++;
      if (data.stats && data.stats.size) {
        this._fsEntriesProcessedBytes += data.stats.size;
      }
      this.emit("progress", {
        entries: {
          total: this._entriesCount,
          processed: this._entriesProcessedCount
        },
        fs: {
          totalBytes: this._fsEntriesTotalBytes,
          processedBytes: this._fsEntriesProcessedBytes
        }
      });
      setImmediate(callback);
    }.bind(this));
  };
  Archiver.prototype._moduleFinalize = function() {
    if (typeof this._module.finalize === "function") {
      this._module.finalize();
    } else if (typeof this._module.end === "function") {
      this._module.end();
    } else {
      this.emit("error", new ArchiverError("NOENDMETHOD"));
    }
  };
  Archiver.prototype._modulePipe = function() {
    this._module.on("error", this._onModuleError.bind(this));
    this._module.pipe(this);
    this._state.modulePiped = true;
  };
  Archiver.prototype._moduleSupports = function(key) {
    if (!this._module.supports || !this._module.supports[key]) {
      return false;
    }
    return this._module.supports[key];
  };
  Archiver.prototype._moduleUnpipe = function() {
    this._module.unpipe(this);
    this._state.modulePiped = false;
  };
  Archiver.prototype._normalizeEntryData = function(data, stats) {
    data = util2.defaults(data, {
      type: "file",
      name: null,
      date: null,
      mode: null,
      prefix: null,
      sourcePath: null,
      stats: false
    });
    if (stats && data.stats === false) {
      data.stats = stats;
    }
    var isDir = data.type === "directory";
    if (data.name) {
      if (typeof data.prefix === "string" && data.prefix !== "") {
        data.name = data.prefix + "/" + data.name;
        data.prefix = null;
      }
      data.name = util2.sanitizePath(data.name);
      if (data.type !== "symlink" && data.name.slice(-1) === "/") {
        isDir = true;
        data.type = "directory";
      } else if (isDir) {
        data.name += "/";
      }
    }
    if (typeof data.mode === "number") {
      if (win32) {
        data.mode &= 511;
      } else {
        data.mode &= 4095;
      }
    } else if (data.stats && data.mode === null) {
      if (win32) {
        data.mode = data.stats.mode & 511;
      } else {
        data.mode = data.stats.mode & 4095;
      }
      if (win32 && isDir) {
        data.mode = 493;
      }
    } else if (data.mode === null) {
      data.mode = isDir ? 493 : 420;
    }
    if (data.stats && data.date === null) {
      data.date = data.stats.mtime;
    } else {
      data.date = util2.dateify(data.date);
    }
    return data;
  };
  Archiver.prototype._onModuleError = function(err) {
    this.emit("error", err);
  };
  Archiver.prototype._onQueueDrain = function() {
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
      return;
    }
    if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {
      this._finalize();
    }
  };
  Archiver.prototype._onQueueTask = function(task, callback) {
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
      callback();
      return;
    }
    this._task = task;
    this._moduleAppend(task.source, task.data, callback);
  };
  Archiver.prototype._onStatQueueTask = function(task, callback) {
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
      callback();
      return;
    }
    fs9.lstat(task.filepath, function(err, stats) {
      if (this._state.aborted) {
        setImmediate(callback);
        return;
      }
      if (err) {
        this._entriesCount--;
        this.emit("warning", err);
        setImmediate(callback);
        return;
      }
      task = this._updateQueueTaskWithStats(task, stats);
      if (task) {
        if (stats.size) {
          this._fsEntriesTotalBytes += stats.size;
        }
        this._queue.push(task);
      }
      setImmediate(callback);
    }.bind(this));
  };
  Archiver.prototype._shutdown = function() {
    this._moduleUnpipe();
    this.end();
  };
  Archiver.prototype._transform = function(chunk, encoding, callback) {
    if (chunk) {
      this._pointer += chunk.length;
    }
    callback(null, chunk);
  };
  Archiver.prototype._updateQueueTaskWithStats = function(task, stats) {
    if (stats.isFile()) {
      task.data.type = "file";
      task.data.sourceType = "stream";
      task.source = util2.lazyReadStream(task.filepath);
    } else if (stats.isDirectory() && this._moduleSupports("directory")) {
      task.data.name = util2.trailingSlashIt(task.data.name);
      task.data.type = "directory";
      task.data.sourcePath = util2.trailingSlashIt(task.filepath);
      task.data.sourceType = "buffer";
      task.source = Buffer.concat([]);
    } else if (stats.isSymbolicLink() && this._moduleSupports("symlink")) {
      var linkPath = fs9.readlinkSync(task.filepath);
      var dirName = path10.dirname(task.filepath);
      task.data.type = "symlink";
      task.data.linkname = path10.relative(dirName, path10.resolve(dirName, linkPath));
      task.data.sourceType = "buffer";
      task.source = Buffer.concat([]);
    } else {
      if (stats.isDirectory()) {
        this.emit("warning", new ArchiverError("DIRECTORYNOTSUPPORTED", task.data));
      } else if (stats.isSymbolicLink()) {
        this.emit("warning", new ArchiverError("SYMLINKNOTSUPPORTED", task.data));
      } else {
        this.emit("warning", new ArchiverError("ENTRYNOTSUPPORTED", task.data));
      }
      return null;
    }
    task.data = this._normalizeEntryData(task.data, stats);
    return task;
  };
  Archiver.prototype.abort = function() {
    if (this._state.aborted || this._state.finalized) {
      return this;
    }
    this._abort();
    return this;
  };
  Archiver.prototype.append = function(source, data) {
    if (this._state.finalize || this._state.aborted) {
      this.emit("error", new ArchiverError("QUEUECLOSED"));
      return this;
    }
    data = this._normalizeEntryData(data);
    if (typeof data.name !== "string" || data.name.length === 0) {
      this.emit("error", new ArchiverError("ENTRYNAMEREQUIRED"));
      return this;
    }
    if (data.type === "directory" && !this._moduleSupports("directory")) {
      this.emit("error", new ArchiverError("DIRECTORYNOTSUPPORTED", {name: data.name}));
      return this;
    }
    source = util2.normalizeInputSource(source);
    if (Buffer.isBuffer(source)) {
      data.sourceType = "buffer";
    } else if (util2.isStream(source)) {
      data.sourceType = "stream";
    } else {
      this.emit("error", new ArchiverError("INPUTSTEAMBUFFERREQUIRED", {name: data.name}));
      return this;
    }
    this._entriesCount++;
    this._queue.push({
      data,
      source
    });
    return this;
  };
  Archiver.prototype.directory = function(dirpath, destpath, data) {
    if (this._state.finalize || this._state.aborted) {
      this.emit("error", new ArchiverError("QUEUECLOSED"));
      return this;
    }
    if (typeof dirpath !== "string" || dirpath.length === 0) {
      this.emit("error", new ArchiverError("DIRECTORYDIRPATHREQUIRED"));
      return this;
    }
    this._pending++;
    if (destpath === false) {
      destpath = "";
    } else if (typeof destpath !== "string") {
      destpath = dirpath;
    }
    var dataFunction = false;
    if (typeof data === "function") {
      dataFunction = data;
      data = {};
    } else if (typeof data !== "object") {
      data = {};
    }
    var globOptions = {
      stat: false,
      dot: true,
      cwd: dirpath
    };
    function onGlobEnd() {
      this._pending--;
      this._maybeFinalize();
    }
    function onGlobError(err) {
      this.emit("error", err);
    }
    function onGlobMatch(match) {
      var ignoreMatch = false;
      var entryData = Object.assign({}, data);
      entryData.name = match;
      entryData.prefix = destpath;
      match = globber._makeAbs(match);
      try {
        if (dataFunction) {
          entryData = dataFunction(entryData);
          if (entryData === false) {
            ignoreMatch = true;
          } else if (typeof entryData !== "object") {
            throw new ArchiverError("DIRECTORYFUNCTIONINVALIDDATA", {dirpath});
          }
        }
      } catch (e) {
        this.emit("error", e);
        return;
      }
      if (ignoreMatch) {
        return;
      }
      this._append(match, entryData);
    }
    var globber = glob("**", globOptions);
    globber.on("error", onGlobError.bind(this));
    globber.on("match", onGlobMatch.bind(this));
    globber.on("end", onGlobEnd.bind(this));
    return this;
  };
  Archiver.prototype.file = function(filepath, data) {
    if (this._state.finalize || this._state.aborted) {
      this.emit("error", new ArchiverError("QUEUECLOSED"));
      return this;
    }
    if (typeof filepath !== "string" || filepath.length === 0) {
      this.emit("error", new ArchiverError("FILEFILEPATHREQUIRED"));
      return this;
    }
    this._append(filepath, data);
    return this;
  };
  Archiver.prototype.glob = function(pattern, options, data) {
    this._pending++;
    options = util2.defaults(options, {
      stat: false
    });
    function onGlobEnd() {
      this._pending--;
      this._maybeFinalize();
    }
    function onGlobError(err) {
      this.emit("error", err);
    }
    function onGlobMatch(match) {
      var entryData = Object.assign({}, data);
      if (options.cwd) {
        entryData.name = match;
        match = globber._makeAbs(match);
      }
      this._append(match, entryData);
    }
    var globber = glob(pattern, options);
    globber.on("error", onGlobError.bind(this));
    globber.on("match", onGlobMatch.bind(this));
    globber.on("end", onGlobEnd.bind(this));
    return this;
  };
  Archiver.prototype.finalize = function() {
    if (this._state.aborted) {
      this.emit("error", new ArchiverError("ABORTED"));
      return this;
    }
    if (this._state.finalize) {
      this.emit("error", new ArchiverError("FINALIZING"));
      return this;
    }
    this._state.finalize = true;
    if (this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {
      this._finalize();
    }
    var self2 = this;
    return new Promise(function(resolve, reject) {
      var errored;
      self2._module.on("end", function() {
        if (!errored) {
          resolve();
        }
      });
      self2._module.on("error", function(err) {
        errored = true;
        reject(err);
      });
    });
  };
  Archiver.prototype.setFormat = function(format10) {
    if (this._format) {
      this.emit("error", new ArchiverError("FORMATSET"));
      return this;
    }
    this._format = format10;
    return this;
  };
  Archiver.prototype.setModule = function(module3) {
    if (this._state.aborted) {
      this.emit("error", new ArchiverError("ABORTED"));
      return this;
    }
    if (this._state.module) {
      this.emit("error", new ArchiverError("MODULESET"));
      return this;
    }
    this._module = module3;
    this._modulePipe();
    return this;
  };
  Archiver.prototype.symlink = function(filepath, target) {
    if (this._state.finalize || this._state.aborted) {
      this.emit("error", new ArchiverError("QUEUECLOSED"));
      return this;
    }
    if (typeof filepath !== "string" || filepath.length === 0) {
      this.emit("error", new ArchiverError("SYMLINKFILEPATHREQUIRED"));
      return this;
    }
    if (typeof target !== "string" || target.length === 0) {
      this.emit("error", new ArchiverError("SYMLINKTARGETREQUIRED", {filepath}));
      return this;
    }
    if (!this._moduleSupports("symlink")) {
      this.emit("error", new ArchiverError("SYMLINKNOTSUPPORTED", {filepath}));
      return this;
    }
    var data = {};
    data.type = "symlink";
    data.name = filepath.replace(/\\/g, "/");
    data.linkname = target.replace(/\\/g, "/");
    data.sourceType = "buffer";
    this._entriesCount++;
    this._queue.push({
      data,
      source: Buffer.concat([])
    });
    return this;
  };
  Archiver.prototype.pointer = function() {
    return this._pointer;
  };
  Archiver.prototype.use = function(plugin) {
    this._streams.push(plugin);
    return this;
  };
  module2.exports = Archiver;
});

// ../../node_modules/.pnpm/compress-commons@3.0.0/node_modules/compress-commons/lib/archivers/archive-entry.js
var require_archive_entry = __commonJS((exports2, module2) => {
  var ArchiveEntry = module2.exports = function() {
  };
  ArchiveEntry.prototype.getName = function() {
  };
  ArchiveEntry.prototype.getSize = function() {
  };
  ArchiveEntry.prototype.getLastModifiedDate = function() {
  };
  ArchiveEntry.prototype.isDirectory = function() {
  };
});

// ../../node_modules/.pnpm/compress-commons@3.0.0/node_modules/compress-commons/lib/archivers/zip/util.js
var require_util6 = __commonJS((exports2, module2) => {
  var util2 = module2.exports = {};
  util2.dateToDos = function(d2, forceLocalTime) {
    forceLocalTime = forceLocalTime || false;
    var year = forceLocalTime ? d2.getFullYear() : d2.getUTCFullYear();
    if (year < 1980) {
      return 2162688;
    } else if (year >= 2044) {
      return 2141175677;
    }
    var val = {
      year,
      month: forceLocalTime ? d2.getMonth() : d2.getUTCMonth(),
      date: forceLocalTime ? d2.getDate() : d2.getUTCDate(),
      hours: forceLocalTime ? d2.getHours() : d2.getUTCHours(),
      minutes: forceLocalTime ? d2.getMinutes() : d2.getUTCMinutes(),
      seconds: forceLocalTime ? d2.getSeconds() : d2.getUTCSeconds()
    };
    return val.year - 1980 << 25 | val.month + 1 << 21 | val.date << 16 | val.hours << 11 | val.minutes << 5 | val.seconds / 2;
  };
  util2.dosToDate = function(dos) {
    return new Date((dos >> 25 & 127) + 1980, (dos >> 21 & 15) - 1, dos >> 16 & 31, dos >> 11 & 31, dos >> 5 & 63, (dos & 31) << 1);
  };
  util2.fromDosTime = function(buf) {
    return util2.dosToDate(buf.readUInt32LE(0));
  };
  util2.getEightBytes = function(v) {
    var buf = Buffer.alloc(8);
    buf.writeUInt32LE(v % 4294967296, 0);
    buf.writeUInt32LE(v / 4294967296 | 0, 4);
    return buf;
  };
  util2.getShortBytes = function(v) {
    var buf = Buffer.alloc(2);
    buf.writeUInt16LE((v & 65535) >>> 0, 0);
    return buf;
  };
  util2.getShortBytesValue = function(buf, offset) {
    return buf.readUInt16LE(offset);
  };
  util2.getLongBytes = function(v) {
    var buf = Buffer.alloc(4);
    buf.writeUInt32LE((v & 4294967295) >>> 0, 0);
    return buf;
  };
  util2.getLongBytesValue = function(buf, offset) {
    return buf.readUInt32LE(offset);
  };
  util2.toDosTime = function(d2) {
    return util2.getLongBytes(util2.dateToDos(d2));
  };
});

// ../../node_modules/.pnpm/compress-commons@3.0.0/node_modules/compress-commons/lib/archivers/zip/general-purpose-bit.js
var require_general_purpose_bit = __commonJS((exports2, module2) => {
  var zipUtil = require_util6();
  var DATA_DESCRIPTOR_FLAG = 1 << 3;
  var ENCRYPTION_FLAG = 1 << 0;
  var NUMBER_OF_SHANNON_FANO_TREES_FLAG = 1 << 2;
  var SLIDING_DICTIONARY_SIZE_FLAG = 1 << 1;
  var STRONG_ENCRYPTION_FLAG = 1 << 6;
  var UFT8_NAMES_FLAG = 1 << 11;
  var GeneralPurposeBit = module2.exports = function() {
    if (!(this instanceof GeneralPurposeBit)) {
      return new GeneralPurposeBit();
    }
    this.descriptor = false;
    this.encryption = false;
    this.utf8 = false;
    this.numberOfShannonFanoTrees = 0;
    this.strongEncryption = false;
    this.slidingDictionarySize = 0;
    return this;
  };
  GeneralPurposeBit.prototype.encode = function() {
    return zipUtil.getShortBytes((this.descriptor ? DATA_DESCRIPTOR_FLAG : 0) | (this.utf8 ? UFT8_NAMES_FLAG : 0) | (this.encryption ? ENCRYPTION_FLAG : 0) | (this.strongEncryption ? STRONG_ENCRYPTION_FLAG : 0));
  };
  GeneralPurposeBit.prototype.parse = function(buf, offset) {
    var flag = zipUtil.getShortBytesValue(buf, offset);
    var gbp = new GeneralPurposeBit();
    gbp.useDataDescriptor((flag & DATA_DESCRIPTOR_FLAG) !== 0);
    gbp.useUTF8ForNames((flag & UFT8_NAMES_FLAG) !== 0);
    gbp.useStrongEncryption((flag & STRONG_ENCRYPTION_FLAG) !== 0);
    gbp.useEncryption((flag & ENCRYPTION_FLAG) !== 0);
    gbp.setSlidingDictionarySize((flag & SLIDING_DICTIONARY_SIZE_FLAG) !== 0 ? 8192 : 4096);
    gbp.setNumberOfShannonFanoTrees((flag & NUMBER_OF_SHANNON_FANO_TREES_FLAG) !== 0 ? 3 : 2);
    return gbp;
  };
  GeneralPurposeBit.prototype.setNumberOfShannonFanoTrees = function(n) {
    this.numberOfShannonFanoTrees = n;
  };
  GeneralPurposeBit.prototype.getNumberOfShannonFanoTrees = function() {
    return this.numberOfShannonFanoTrees;
  };
  GeneralPurposeBit.prototype.setSlidingDictionarySize = function(n) {
    this.slidingDictionarySize = n;
  };
  GeneralPurposeBit.prototype.getSlidingDictionarySize = function() {
    return this.slidingDictionarySize;
  };
  GeneralPurposeBit.prototype.useDataDescriptor = function(b) {
    this.descriptor = b;
  };
  GeneralPurposeBit.prototype.usesDataDescriptor = function() {
    return this.descriptor;
  };
  GeneralPurposeBit.prototype.useEncryption = function(b) {
    this.encryption = b;
  };
  GeneralPurposeBit.prototype.usesEncryption = function() {
    return this.encryption;
  };
  GeneralPurposeBit.prototype.useStrongEncryption = function(b) {
    this.strongEncryption = b;
  };
  GeneralPurposeBit.prototype.usesStrongEncryption = function() {
    return this.strongEncryption;
  };
  GeneralPurposeBit.prototype.useUTF8ForNames = function(b) {
    this.utf8 = b;
  };
  GeneralPurposeBit.prototype.usesUTF8ForNames = function() {
    return this.utf8;
  };
});

// ../../node_modules/.pnpm/compress-commons@3.0.0/node_modules/compress-commons/lib/archivers/zip/unix-stat.js
var require_unix_stat = __commonJS((exports2, module2) => {
  module2.exports = {
    PERM_MASK: 4095,
    FILE_TYPE_FLAG: 61440,
    LINK_FLAG: 40960,
    FILE_FLAG: 32768,
    DIR_FLAG: 16384,
    DEFAULT_LINK_PERM: 511,
    DEFAULT_DIR_PERM: 493,
    DEFAULT_FILE_PERM: 420
  };
});

// ../../node_modules/.pnpm/compress-commons@3.0.0/node_modules/compress-commons/lib/archivers/zip/constants.js
var require_constants5 = __commonJS((exports2, module2) => {
  module2.exports = {
    WORD: 4,
    DWORD: 8,
    EMPTY: Buffer.alloc(0),
    SHORT: 2,
    SHORT_MASK: 65535,
    SHORT_SHIFT: 16,
    SHORT_ZERO: Buffer.from(Array(2)),
    LONG: 4,
    LONG_ZERO: Buffer.from(Array(4)),
    MIN_VERSION_INITIAL: 10,
    MIN_VERSION_DATA_DESCRIPTOR: 20,
    MIN_VERSION_ZIP64: 45,
    VERSION_MADEBY: 45,
    METHOD_STORED: 0,
    METHOD_DEFLATED: 8,
    PLATFORM_UNIX: 3,
    PLATFORM_FAT: 0,
    SIG_LFH: 67324752,
    SIG_DD: 134695760,
    SIG_CFH: 33639248,
    SIG_EOCD: 101010256,
    SIG_ZIP64_EOCD: 101075792,
    SIG_ZIP64_EOCD_LOC: 117853008,
    ZIP64_MAGIC_SHORT: 65535,
    ZIP64_MAGIC: 4294967295,
    ZIP64_EXTRA_ID: 1,
    ZLIB_NO_COMPRESSION: 0,
    ZLIB_BEST_SPEED: 1,
    ZLIB_BEST_COMPRESSION: 9,
    ZLIB_DEFAULT_COMPRESSION: -1,
    MODE_MASK: 4095,
    DEFAULT_FILE_MODE: 33188,
    DEFAULT_DIR_MODE: 16877,
    EXT_FILE_ATTR_DIR: 1106051088,
    EXT_FILE_ATTR_FILE: 2175008800,
    S_IFMT: 61440,
    S_IFIFO: 4096,
    S_IFCHR: 8192,
    S_IFDIR: 16384,
    S_IFBLK: 24576,
    S_IFREG: 32768,
    S_IFLNK: 40960,
    S_IFSOCK: 49152,
    S_DOS_A: 32,
    S_DOS_D: 16,
    S_DOS_V: 8,
    S_DOS_S: 4,
    S_DOS_H: 2,
    S_DOS_R: 1
  };
});

// ../../node_modules/.pnpm/compress-commons@3.0.0/node_modules/compress-commons/lib/archivers/zip/zip-archive-entry.js
var require_zip_archive_entry = __commonJS((exports2, module2) => {
  var inherits = require("util").inherits;
  var normalizePath = require_normalize_path();
  var ArchiveEntry = require_archive_entry();
  var GeneralPurposeBit = require_general_purpose_bit();
  var UnixStat = require_unix_stat();
  var constants = require_constants5();
  var zipUtil = require_util6();
  var ZipArchiveEntry = module2.exports = function(name) {
    if (!(this instanceof ZipArchiveEntry)) {
      return new ZipArchiveEntry(name);
    }
    ArchiveEntry.call(this);
    this.platform = constants.PLATFORM_FAT;
    this.method = -1;
    this.name = null;
    this.size = 0;
    this.csize = 0;
    this.gpb = new GeneralPurposeBit();
    this.crc = 0;
    this.time = -1;
    this.minver = constants.MIN_VERSION_INITIAL;
    this.mode = -1;
    this.extra = null;
    this.exattr = 0;
    this.inattr = 0;
    this.comment = null;
    if (name) {
      this.setName(name);
    }
  };
  inherits(ZipArchiveEntry, ArchiveEntry);
  ZipArchiveEntry.prototype.getCentralDirectoryExtra = function() {
    return this.getExtra();
  };
  ZipArchiveEntry.prototype.getComment = function() {
    return this.comment !== null ? this.comment : "";
  };
  ZipArchiveEntry.prototype.getCompressedSize = function() {
    return this.csize;
  };
  ZipArchiveEntry.prototype.getCrc = function() {
    return this.crc;
  };
  ZipArchiveEntry.prototype.getExternalAttributes = function() {
    return this.exattr;
  };
  ZipArchiveEntry.prototype.getExtra = function() {
    return this.extra !== null ? this.extra : constants.EMPTY;
  };
  ZipArchiveEntry.prototype.getGeneralPurposeBit = function() {
    return this.gpb;
  };
  ZipArchiveEntry.prototype.getInternalAttributes = function() {
    return this.inattr;
  };
  ZipArchiveEntry.prototype.getLastModifiedDate = function() {
    return this.getTime();
  };
  ZipArchiveEntry.prototype.getLocalFileDataExtra = function() {
    return this.getExtra();
  };
  ZipArchiveEntry.prototype.getMethod = function() {
    return this.method;
  };
  ZipArchiveEntry.prototype.getName = function() {
    return this.name;
  };
  ZipArchiveEntry.prototype.getPlatform = function() {
    return this.platform;
  };
  ZipArchiveEntry.prototype.getSize = function() {
    return this.size;
  };
  ZipArchiveEntry.prototype.getTime = function() {
    return this.time !== -1 ? zipUtil.dosToDate(this.time) : -1;
  };
  ZipArchiveEntry.prototype.getTimeDos = function() {
    return this.time !== -1 ? this.time : 0;
  };
  ZipArchiveEntry.prototype.getUnixMode = function() {
    return this.platform !== constants.PLATFORM_UNIX ? 0 : this.getExternalAttributes() >> constants.SHORT_SHIFT & constants.SHORT_MASK;
  };
  ZipArchiveEntry.prototype.getVersionNeededToExtract = function() {
    return this.minver;
  };
  ZipArchiveEntry.prototype.setComment = function(comment) {
    if (Buffer.byteLength(comment) !== comment.length) {
      this.getGeneralPurposeBit().useUTF8ForNames(true);
    }
    this.comment = comment;
  };
  ZipArchiveEntry.prototype.setCompressedSize = function(size) {
    if (size < 0) {
      throw new Error("invalid entry compressed size");
    }
    this.csize = size;
  };
  ZipArchiveEntry.prototype.setCrc = function(crc) {
    if (crc < 0) {
      throw new Error("invalid entry crc32");
    }
    this.crc = crc;
  };
  ZipArchiveEntry.prototype.setExternalAttributes = function(attr) {
    this.exattr = attr >>> 0;
  };
  ZipArchiveEntry.prototype.setExtra = function(extra) {
    this.extra = extra;
  };
  ZipArchiveEntry.prototype.setGeneralPurposeBit = function(gpb) {
    if (!(gpb instanceof GeneralPurposeBit)) {
      throw new Error("invalid entry GeneralPurposeBit");
    }
    this.gpb = gpb;
  };
  ZipArchiveEntry.prototype.setInternalAttributes = function(attr) {
    this.inattr = attr;
  };
  ZipArchiveEntry.prototype.setMethod = function(method) {
    if (method < 0) {
      throw new Error("invalid entry compression method");
    }
    this.method = method;
  };
  ZipArchiveEntry.prototype.setName = function(name) {
    name = normalizePath(name, false).replace(/^\w+:/, "").replace(/^(\.\.\/|\/)+/, "");
    if (Buffer.byteLength(name) !== name.length) {
      this.getGeneralPurposeBit().useUTF8ForNames(true);
    }
    this.name = name;
  };
  ZipArchiveEntry.prototype.setPlatform = function(platform) {
    this.platform = platform;
  };
  ZipArchiveEntry.prototype.setSize = function(size) {
    if (size < 0) {
      throw new Error("invalid entry size");
    }
    this.size = size;
  };
  ZipArchiveEntry.prototype.setTime = function(time, forceLocalTime) {
    if (!(time instanceof Date)) {
      throw new Error("invalid entry time");
    }
    this.time = zipUtil.dateToDos(time, forceLocalTime);
  };
  ZipArchiveEntry.prototype.setUnixMode = function(mode) {
    mode |= this.isDirectory() ? constants.S_IFDIR : constants.S_IFREG;
    var extattr = 0;
    extattr |= mode << constants.SHORT_SHIFT | (this.isDirectory() ? constants.S_DOS_D : constants.S_DOS_A);
    this.setExternalAttributes(extattr);
    this.mode = mode & constants.MODE_MASK;
    this.platform = constants.PLATFORM_UNIX;
  };
  ZipArchiveEntry.prototype.setVersionNeededToExtract = function(minver) {
    this.minver = minver;
  };
  ZipArchiveEntry.prototype.isDirectory = function() {
    return this.getName().slice(-1) === "/";
  };
  ZipArchiveEntry.prototype.isUnixSymlink = function() {
    return (this.getUnixMode() & UnixStat.FILE_TYPE_FLAG) === UnixStat.LINK_FLAG;
  };
  ZipArchiveEntry.prototype.isZip64 = function() {
    return this.csize > constants.ZIP64_MAGIC || this.size > constants.ZIP64_MAGIC;
  };
});

// ../../node_modules/.pnpm/compress-commons@3.0.0/node_modules/compress-commons/lib/util/index.js
var require_util7 = __commonJS((exports2, module2) => {
  var Stream = require("stream").Stream;
  var PassThrough = require_readable().PassThrough;
  var util2 = module2.exports = {};
  util2.isStream = function(source) {
    return source instanceof Stream;
  };
  util2.normalizeInputSource = function(source) {
    if (source === null) {
      return Buffer.alloc(0);
    } else if (typeof source === "string") {
      return Buffer.from(source);
    } else if (util2.isStream(source) && !source._readableState) {
      var normalized = new PassThrough();
      source.pipe(normalized);
      return normalized;
    }
    return source;
  };
});

// ../../node_modules/.pnpm/compress-commons@3.0.0/node_modules/compress-commons/lib/archivers/archive-output-stream.js
var require_archive_output_stream = __commonJS((exports2, module2) => {
  var inherits = require("util").inherits;
  var Transform = require_readable().Transform;
  var ArchiveEntry = require_archive_entry();
  var util2 = require_util7();
  var ArchiveOutputStream = module2.exports = function(options) {
    if (!(this instanceof ArchiveOutputStream)) {
      return new ArchiveOutputStream(options);
    }
    Transform.call(this, options);
    this.offset = 0;
    this._archive = {
      finish: false,
      finished: false,
      processing: false
    };
  };
  inherits(ArchiveOutputStream, Transform);
  ArchiveOutputStream.prototype._appendBuffer = function(zae, source, callback) {
  };
  ArchiveOutputStream.prototype._appendStream = function(zae, source, callback) {
  };
  ArchiveOutputStream.prototype._emitErrorCallback = function(err) {
    if (err) {
      this.emit("error", err);
    }
  };
  ArchiveOutputStream.prototype._finish = function(ae) {
  };
  ArchiveOutputStream.prototype._normalizeEntry = function(ae) {
  };
  ArchiveOutputStream.prototype._transform = function(chunk, encoding, callback) {
    callback(null, chunk);
  };
  ArchiveOutputStream.prototype.entry = function(ae, source, callback) {
    source = source || null;
    if (typeof callback !== "function") {
      callback = this._emitErrorCallback.bind(this);
    }
    if (!(ae instanceof ArchiveEntry)) {
      callback(new Error("not a valid instance of ArchiveEntry"));
      return;
    }
    if (this._archive.finish || this._archive.finished) {
      callback(new Error("unacceptable entry after finish"));
      return;
    }
    if (this._archive.processing) {
      callback(new Error("already processing an entry"));
      return;
    }
    this._archive.processing = true;
    this._normalizeEntry(ae);
    this._entry = ae;
    source = util2.normalizeInputSource(source);
    if (Buffer.isBuffer(source)) {
      this._appendBuffer(ae, source, callback);
    } else if (util2.isStream(source)) {
      this._appendStream(ae, source, callback);
    } else {
      this._archive.processing = false;
      callback(new Error("input source must be valid Stream or Buffer instance"));
      return;
    }
    return this;
  };
  ArchiveOutputStream.prototype.finish = function() {
    if (this._archive.processing) {
      this._archive.finish = true;
      return;
    }
    this._finish();
  };
  ArchiveOutputStream.prototype.getBytesWritten = function() {
    return this.offset;
  };
  ArchiveOutputStream.prototype.write = function(chunk, cb) {
    if (chunk) {
      this.offset += chunk.length;
    }
    return Transform.prototype.write.call(this, chunk, cb);
  };
});

// ../../node_modules/.pnpm/buffer-crc32@0.2.13/node_modules/buffer-crc32/index.js
var require_buffer_crc32 = __commonJS((exports2, module2) => {
  var Buffer2 = require("buffer").Buffer;
  var CRC_TABLE = [
    0,
    1996959894,
    3993919788,
    2567524794,
    124634137,
    1886057615,
    3915621685,
    2657392035,
    249268274,
    2044508324,
    3772115230,
    2547177864,
    162941995,
    2125561021,
    3887607047,
    2428444049,
    498536548,
    1789927666,
    4089016648,
    2227061214,
    450548861,
    1843258603,
    4107580753,
    2211677639,
    325883990,
    1684777152,
    4251122042,
    2321926636,
    335633487,
    1661365465,
    4195302755,
    2366115317,
    997073096,
    1281953886,
    3579855332,
    2724688242,
    1006888145,
    1258607687,
    3524101629,
    2768942443,
    901097722,
    1119000684,
    3686517206,
    2898065728,
    853044451,
    1172266101,
    3705015759,
    2882616665,
    651767980,
    1373503546,
    3369554304,
    3218104598,
    565507253,
    1454621731,
    3485111705,
    3099436303,
    671266974,
    1594198024,
    3322730930,
    2970347812,
    795835527,
    1483230225,
    3244367275,
    3060149565,
    1994146192,
    31158534,
    2563907772,
    4023717930,
    1907459465,
    112637215,
    2680153253,
    3904427059,
    2013776290,
    251722036,
    2517215374,
    3775830040,
    2137656763,
    141376813,
    2439277719,
    3865271297,
    1802195444,
    476864866,
    2238001368,
    4066508878,
    1812370925,
    453092731,
    2181625025,
    4111451223,
    1706088902,
    314042704,
    2344532202,
    4240017532,
    1658658271,
    366619977,
    2362670323,
    4224994405,
    1303535960,
    984961486,
    2747007092,
    3569037538,
    1256170817,
    1037604311,
    2765210733,
    3554079995,
    1131014506,
    879679996,
    2909243462,
    3663771856,
    1141124467,
    855842277,
    2852801631,
    3708648649,
    1342533948,
    654459306,
    3188396048,
    3373015174,
    1466479909,
    544179635,
    3110523913,
    3462522015,
    1591671054,
    702138776,
    2966460450,
    3352799412,
    1504918807,
    783551873,
    3082640443,
    3233442989,
    3988292384,
    2596254646,
    62317068,
    1957810842,
    3939845945,
    2647816111,
    81470997,
    1943803523,
    3814918930,
    2489596804,
    225274430,
    2053790376,
    3826175755,
    2466906013,
    167816743,
    2097651377,
    4027552580,
    2265490386,
    503444072,
    1762050814,
    4150417245,
    2154129355,
    426522225,
    1852507879,
    4275313526,
    2312317920,
    282753626,
    1742555852,
    4189708143,
    2394877945,
    397917763,
    1622183637,
    3604390888,
    2714866558,
    953729732,
    1340076626,
    3518719985,
    2797360999,
    1068828381,
    1219638859,
    3624741850,
    2936675148,
    906185462,
    1090812512,
    3747672003,
    2825379669,
    829329135,
    1181335161,
    3412177804,
    3160834842,
    628085408,
    1382605366,
    3423369109,
    3138078467,
    570562233,
    1426400815,
    3317316542,
    2998733608,
    733239954,
    1555261956,
    3268935591,
    3050360625,
    752459403,
    1541320221,
    2607071920,
    3965973030,
    1969922972,
    40735498,
    2617837225,
    3943577151,
    1913087877,
    83908371,
    2512341634,
    3803740692,
    2075208622,
    213261112,
    2463272603,
    3855990285,
    2094854071,
    198958881,
    2262029012,
    4057260610,
    1759359992,
    534414190,
    2176718541,
    4139329115,
    1873836001,
    414664567,
    2282248934,
    4279200368,
    1711684554,
    285281116,
    2405801727,
    4167216745,
    1634467795,
    376229701,
    2685067896,
    3608007406,
    1308918612,
    956543938,
    2808555105,
    3495958263,
    1231636301,
    1047427035,
    2932959818,
    3654703836,
    1088359270,
    936918e3,
    2847714899,
    3736837829,
    1202900863,
    817233897,
    3183342108,
    3401237130,
    1404277552,
    615818150,
    3134207493,
    3453421203,
    1423857449,
    601450431,
    3009837614,
    3294710456,
    1567103746,
    711928724,
    3020668471,
    3272380065,
    1510334235,
    755167117
  ];
  if (typeof Int32Array !== "undefined") {
    CRC_TABLE = new Int32Array(CRC_TABLE);
  }
  function ensureBuffer(input) {
    if (Buffer2.isBuffer(input)) {
      return input;
    }
    var hasNewBufferAPI = typeof Buffer2.alloc === "function" && typeof Buffer2.from === "function";
    if (typeof input === "number") {
      return hasNewBufferAPI ? Buffer2.alloc(input) : new Buffer2(input);
    } else if (typeof input === "string") {
      return hasNewBufferAPI ? Buffer2.from(input) : new Buffer2(input);
    } else {
      throw new Error("input must be buffer, number, or string, received " + typeof input);
    }
  }
  function bufferizeInt(num) {
    var tmp = ensureBuffer(4);
    tmp.writeInt32BE(num, 0);
    return tmp;
  }
  function _crc32(buf, previous) {
    buf = ensureBuffer(buf);
    if (Buffer2.isBuffer(previous)) {
      previous = previous.readUInt32BE(0);
    }
    var crc = ~~previous ^ -1;
    for (var n = 0; n < buf.length; n++) {
      crc = CRC_TABLE[(crc ^ buf[n]) & 255] ^ crc >>> 8;
    }
    return crc ^ -1;
  }
  function crc32() {
    return bufferizeInt(_crc32.apply(null, arguments));
  }
  crc32.signed = function() {
    return _crc32.apply(null, arguments);
  };
  crc32.unsigned = function() {
    return _crc32.apply(null, arguments) >>> 0;
  };
  module2.exports = crc32;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/es6/create_buffer.js
var require_create_buffer = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _buffer = require("buffer");
  var createBuffer = _buffer.Buffer.from && _buffer.Buffer.alloc && _buffer.Buffer.allocUnsafe && _buffer.Buffer.allocUnsafeSlow ? _buffer.Buffer.from : function(val) {
    return new _buffer.Buffer(val);
  };
  exports2.default = createBuffer;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/es6/define_crc.js
var require_define_crc = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = function(model, calc) {
    var fn = function fn2(buf, previous) {
      return calc(buf, previous) >>> 0;
    };
    fn.signed = calc;
    fn.unsigned = fn;
    fn.model = model;
    return fn;
  };
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/es6/crc1.js
var require_crc1 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _buffer = require("buffer");
  var _create_buffer = require_create_buffer();
  var _create_buffer2 = _interopRequireDefault(_create_buffer);
  var _define_crc = require_define_crc();
  var _define_crc2 = _interopRequireDefault(_define_crc);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var crc1 = (0, _define_crc2.default)("crc1", function(buf, previous) {
    if (!_buffer.Buffer.isBuffer(buf))
      buf = (0, _create_buffer2.default)(buf);
    var crc = ~~previous;
    var accum = 0;
    for (var index = 0; index < buf.length; index++) {
      var byte = buf[index];
      accum += byte;
    }
    crc += accum % 256;
    return crc % 256;
  });
  exports2.default = crc1;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/crc1.js
var require_crc12 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = require_crc1().default;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/es6/crc8.js
var require_crc8 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _buffer = require("buffer");
  var _create_buffer = require_create_buffer();
  var _create_buffer2 = _interopRequireDefault(_create_buffer);
  var _define_crc = require_define_crc();
  var _define_crc2 = _interopRequireDefault(_define_crc);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var TABLE = [0, 7, 14, 9, 28, 27, 18, 21, 56, 63, 54, 49, 36, 35, 42, 45, 112, 119, 126, 121, 108, 107, 98, 101, 72, 79, 70, 65, 84, 83, 90, 93, 224, 231, 238, 233, 252, 251, 242, 245, 216, 223, 214, 209, 196, 195, 202, 205, 144, 151, 158, 153, 140, 139, 130, 133, 168, 175, 166, 161, 180, 179, 186, 189, 199, 192, 201, 206, 219, 220, 213, 210, 255, 248, 241, 246, 227, 228, 237, 234, 183, 176, 185, 190, 171, 172, 165, 162, 143, 136, 129, 134, 147, 148, 157, 154, 39, 32, 41, 46, 59, 60, 53, 50, 31, 24, 17, 22, 3, 4, 13, 10, 87, 80, 89, 94, 75, 76, 69, 66, 111, 104, 97, 102, 115, 116, 125, 122, 137, 142, 135, 128, 149, 146, 155, 156, 177, 182, 191, 184, 173, 170, 163, 164, 249, 254, 247, 240, 229, 226, 235, 236, 193, 198, 207, 200, 221, 218, 211, 212, 105, 110, 103, 96, 117, 114, 123, 124, 81, 86, 95, 88, 77, 74, 67, 68, 25, 30, 23, 16, 5, 2, 11, 12, 33, 38, 47, 40, 61, 58, 51, 52, 78, 73, 64, 71, 82, 85, 92, 91, 118, 113, 120, 127, 106, 109, 100, 99, 62, 57, 48, 55, 34, 37, 44, 43, 6, 1, 8, 15, 26, 29, 20, 19, 174, 169, 160, 167, 178, 181, 188, 187, 150, 145, 152, 159, 138, 141, 132, 131, 222, 217, 208, 215, 194, 197, 204, 203, 230, 225, 232, 239, 250, 253, 244, 243];
  if (typeof Int32Array !== "undefined")
    TABLE = new Int32Array(TABLE);
  var crc8 = (0, _define_crc2.default)("crc-8", function(buf, previous) {
    if (!_buffer.Buffer.isBuffer(buf))
      buf = (0, _create_buffer2.default)(buf);
    var crc = ~~previous;
    for (var index = 0; index < buf.length; index++) {
      var byte = buf[index];
      crc = TABLE[(crc ^ byte) & 255] & 255;
    }
    return crc;
  });
  exports2.default = crc8;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/crc8.js
var require_crc82 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = require_crc8().default;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/es6/crc81wire.js
var require_crc81wire = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _buffer = require("buffer");
  var _create_buffer = require_create_buffer();
  var _create_buffer2 = _interopRequireDefault(_create_buffer);
  var _define_crc = require_define_crc();
  var _define_crc2 = _interopRequireDefault(_define_crc);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var TABLE = [0, 94, 188, 226, 97, 63, 221, 131, 194, 156, 126, 32, 163, 253, 31, 65, 157, 195, 33, 127, 252, 162, 64, 30, 95, 1, 227, 189, 62, 96, 130, 220, 35, 125, 159, 193, 66, 28, 254, 160, 225, 191, 93, 3, 128, 222, 60, 98, 190, 224, 2, 92, 223, 129, 99, 61, 124, 34, 192, 158, 29, 67, 161, 255, 70, 24, 250, 164, 39, 121, 155, 197, 132, 218, 56, 102, 229, 187, 89, 7, 219, 133, 103, 57, 186, 228, 6, 88, 25, 71, 165, 251, 120, 38, 196, 154, 101, 59, 217, 135, 4, 90, 184, 230, 167, 249, 27, 69, 198, 152, 122, 36, 248, 166, 68, 26, 153, 199, 37, 123, 58, 100, 134, 216, 91, 5, 231, 185, 140, 210, 48, 110, 237, 179, 81, 15, 78, 16, 242, 172, 47, 113, 147, 205, 17, 79, 173, 243, 112, 46, 204, 146, 211, 141, 111, 49, 178, 236, 14, 80, 175, 241, 19, 77, 206, 144, 114, 44, 109, 51, 209, 143, 12, 82, 176, 238, 50, 108, 142, 208, 83, 13, 239, 177, 240, 174, 76, 18, 145, 207, 45, 115, 202, 148, 118, 40, 171, 245, 23, 73, 8, 86, 180, 234, 105, 55, 213, 139, 87, 9, 235, 181, 54, 104, 138, 212, 149, 203, 41, 119, 244, 170, 72, 22, 233, 183, 85, 11, 136, 214, 52, 106, 43, 117, 151, 201, 74, 20, 246, 168, 116, 42, 200, 150, 21, 75, 169, 247, 182, 232, 10, 84, 215, 137, 107, 53];
  if (typeof Int32Array !== "undefined")
    TABLE = new Int32Array(TABLE);
  var crc81wire = (0, _define_crc2.default)("dallas-1-wire", function(buf, previous) {
    if (!_buffer.Buffer.isBuffer(buf))
      buf = (0, _create_buffer2.default)(buf);
    var crc = ~~previous;
    for (var index = 0; index < buf.length; index++) {
      var byte = buf[index];
      crc = TABLE[(crc ^ byte) & 255] & 255;
    }
    return crc;
  });
  exports2.default = crc81wire;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/crc8_1wire.js
var require_crc8_1wire = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = require_crc81wire().default;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/es6/crc16.js
var require_crc16 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _buffer = require("buffer");
  var _create_buffer = require_create_buffer();
  var _create_buffer2 = _interopRequireDefault(_create_buffer);
  var _define_crc = require_define_crc();
  var _define_crc2 = _interopRequireDefault(_define_crc);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var TABLE = [0, 49345, 49537, 320, 49921, 960, 640, 49729, 50689, 1728, 1920, 51009, 1280, 50625, 50305, 1088, 52225, 3264, 3456, 52545, 3840, 53185, 52865, 3648, 2560, 51905, 52097, 2880, 51457, 2496, 2176, 51265, 55297, 6336, 6528, 55617, 6912, 56257, 55937, 6720, 7680, 57025, 57217, 8e3, 56577, 7616, 7296, 56385, 5120, 54465, 54657, 5440, 55041, 6080, 5760, 54849, 53761, 4800, 4992, 54081, 4352, 53697, 53377, 4160, 61441, 12480, 12672, 61761, 13056, 62401, 62081, 12864, 13824, 63169, 63361, 14144, 62721, 13760, 13440, 62529, 15360, 64705, 64897, 15680, 65281, 16320, 16e3, 65089, 64001, 15040, 15232, 64321, 14592, 63937, 63617, 14400, 10240, 59585, 59777, 10560, 60161, 11200, 10880, 59969, 60929, 11968, 12160, 61249, 11520, 60865, 60545, 11328, 58369, 9408, 9600, 58689, 9984, 59329, 59009, 9792, 8704, 58049, 58241, 9024, 57601, 8640, 8320, 57409, 40961, 24768, 24960, 41281, 25344, 41921, 41601, 25152, 26112, 42689, 42881, 26432, 42241, 26048, 25728, 42049, 27648, 44225, 44417, 27968, 44801, 28608, 28288, 44609, 43521, 27328, 27520, 43841, 26880, 43457, 43137, 26688, 30720, 47297, 47489, 31040, 47873, 31680, 31360, 47681, 48641, 32448, 32640, 48961, 32e3, 48577, 48257, 31808, 46081, 29888, 30080, 46401, 30464, 47041, 46721, 30272, 29184, 45761, 45953, 29504, 45313, 29120, 28800, 45121, 20480, 37057, 37249, 20800, 37633, 21440, 21120, 37441, 38401, 22208, 22400, 38721, 21760, 38337, 38017, 21568, 39937, 23744, 23936, 40257, 24320, 40897, 40577, 24128, 23040, 39617, 39809, 23360, 39169, 22976, 22656, 38977, 34817, 18624, 18816, 35137, 19200, 35777, 35457, 19008, 19968, 36545, 36737, 20288, 36097, 19904, 19584, 35905, 17408, 33985, 34177, 17728, 34561, 18368, 18048, 34369, 33281, 17088, 17280, 33601, 16640, 33217, 32897, 16448];
  if (typeof Int32Array !== "undefined")
    TABLE = new Int32Array(TABLE);
  var crc16 = (0, _define_crc2.default)("crc-16", function(buf, previous) {
    if (!_buffer.Buffer.isBuffer(buf))
      buf = (0, _create_buffer2.default)(buf);
    var crc = ~~previous;
    for (var index = 0; index < buf.length; index++) {
      var byte = buf[index];
      crc = (TABLE[(crc ^ byte) & 255] ^ crc >> 8) & 65535;
    }
    return crc;
  });
  exports2.default = crc16;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/crc16.js
var require_crc162 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = require_crc16().default;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/es6/crc16ccitt.js
var require_crc16ccitt = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _buffer = require("buffer");
  var _create_buffer = require_create_buffer();
  var _create_buffer2 = _interopRequireDefault(_create_buffer);
  var _define_crc = require_define_crc();
  var _define_crc2 = _interopRequireDefault(_define_crc);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var TABLE = [0, 4129, 8258, 12387, 16516, 20645, 24774, 28903, 33032, 37161, 41290, 45419, 49548, 53677, 57806, 61935, 4657, 528, 12915, 8786, 21173, 17044, 29431, 25302, 37689, 33560, 45947, 41818, 54205, 50076, 62463, 58334, 9314, 13379, 1056, 5121, 25830, 29895, 17572, 21637, 42346, 46411, 34088, 38153, 58862, 62927, 50604, 54669, 13907, 9842, 5649, 1584, 30423, 26358, 22165, 18100, 46939, 42874, 38681, 34616, 63455, 59390, 55197, 51132, 18628, 22757, 26758, 30887, 2112, 6241, 10242, 14371, 51660, 55789, 59790, 63919, 35144, 39273, 43274, 47403, 23285, 19156, 31415, 27286, 6769, 2640, 14899, 10770, 56317, 52188, 64447, 60318, 39801, 35672, 47931, 43802, 27814, 31879, 19684, 23749, 11298, 15363, 3168, 7233, 60846, 64911, 52716, 56781, 44330, 48395, 36200, 40265, 32407, 28342, 24277, 20212, 15891, 11826, 7761, 3696, 65439, 61374, 57309, 53244, 48923, 44858, 40793, 36728, 37256, 33193, 45514, 41451, 53516, 49453, 61774, 57711, 4224, 161, 12482, 8419, 20484, 16421, 28742, 24679, 33721, 37784, 41979, 46042, 49981, 54044, 58239, 62302, 689, 4752, 8947, 13010, 16949, 21012, 25207, 29270, 46570, 42443, 38312, 34185, 62830, 58703, 54572, 50445, 13538, 9411, 5280, 1153, 29798, 25671, 21540, 17413, 42971, 47098, 34713, 38840, 59231, 63358, 50973, 55100, 9939, 14066, 1681, 5808, 26199, 30326, 17941, 22068, 55628, 51565, 63758, 59695, 39368, 35305, 47498, 43435, 22596, 18533, 30726, 26663, 6336, 2273, 14466, 10403, 52093, 56156, 60223, 64286, 35833, 39896, 43963, 48026, 19061, 23124, 27191, 31254, 2801, 6864, 10931, 14994, 64814, 60687, 56684, 52557, 48554, 44427, 40424, 36297, 31782, 27655, 23652, 19525, 15522, 11395, 7392, 3265, 61215, 65342, 53085, 57212, 44955, 49082, 36825, 40952, 28183, 32310, 20053, 24180, 11923, 16050, 3793, 7920];
  if (typeof Int32Array !== "undefined")
    TABLE = new Int32Array(TABLE);
  var crc16ccitt = (0, _define_crc2.default)("ccitt", function(buf, previous) {
    if (!_buffer.Buffer.isBuffer(buf))
      buf = (0, _create_buffer2.default)(buf);
    var crc = typeof previous !== "undefined" ? ~~previous : 65535;
    for (var index = 0; index < buf.length; index++) {
      var byte = buf[index];
      crc = (TABLE[(crc >> 8 ^ byte) & 255] ^ crc << 8) & 65535;
    }
    return crc;
  });
  exports2.default = crc16ccitt;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/crc16_ccitt.js
var require_crc16_ccitt = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = require_crc16ccitt().default;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/es6/crc16modbus.js
var require_crc16modbus = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _buffer = require("buffer");
  var _create_buffer = require_create_buffer();
  var _create_buffer2 = _interopRequireDefault(_create_buffer);
  var _define_crc = require_define_crc();
  var _define_crc2 = _interopRequireDefault(_define_crc);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var TABLE = [0, 49345, 49537, 320, 49921, 960, 640, 49729, 50689, 1728, 1920, 51009, 1280, 50625, 50305, 1088, 52225, 3264, 3456, 52545, 3840, 53185, 52865, 3648, 2560, 51905, 52097, 2880, 51457, 2496, 2176, 51265, 55297, 6336, 6528, 55617, 6912, 56257, 55937, 6720, 7680, 57025, 57217, 8e3, 56577, 7616, 7296, 56385, 5120, 54465, 54657, 5440, 55041, 6080, 5760, 54849, 53761, 4800, 4992, 54081, 4352, 53697, 53377, 4160, 61441, 12480, 12672, 61761, 13056, 62401, 62081, 12864, 13824, 63169, 63361, 14144, 62721, 13760, 13440, 62529, 15360, 64705, 64897, 15680, 65281, 16320, 16e3, 65089, 64001, 15040, 15232, 64321, 14592, 63937, 63617, 14400, 10240, 59585, 59777, 10560, 60161, 11200, 10880, 59969, 60929, 11968, 12160, 61249, 11520, 60865, 60545, 11328, 58369, 9408, 9600, 58689, 9984, 59329, 59009, 9792, 8704, 58049, 58241, 9024, 57601, 8640, 8320, 57409, 40961, 24768, 24960, 41281, 25344, 41921, 41601, 25152, 26112, 42689, 42881, 26432, 42241, 26048, 25728, 42049, 27648, 44225, 44417, 27968, 44801, 28608, 28288, 44609, 43521, 27328, 27520, 43841, 26880, 43457, 43137, 26688, 30720, 47297, 47489, 31040, 47873, 31680, 31360, 47681, 48641, 32448, 32640, 48961, 32e3, 48577, 48257, 31808, 46081, 29888, 30080, 46401, 30464, 47041, 46721, 30272, 29184, 45761, 45953, 29504, 45313, 29120, 28800, 45121, 20480, 37057, 37249, 20800, 37633, 21440, 21120, 37441, 38401, 22208, 22400, 38721, 21760, 38337, 38017, 21568, 39937, 23744, 23936, 40257, 24320, 40897, 40577, 24128, 23040, 39617, 39809, 23360, 39169, 22976, 22656, 38977, 34817, 18624, 18816, 35137, 19200, 35777, 35457, 19008, 19968, 36545, 36737, 20288, 36097, 19904, 19584, 35905, 17408, 33985, 34177, 17728, 34561, 18368, 18048, 34369, 33281, 17088, 17280, 33601, 16640, 33217, 32897, 16448];
  if (typeof Int32Array !== "undefined")
    TABLE = new Int32Array(TABLE);
  var crc16modbus = (0, _define_crc2.default)("crc-16-modbus", function(buf, previous) {
    if (!_buffer.Buffer.isBuffer(buf))
      buf = (0, _create_buffer2.default)(buf);
    var crc = typeof previous !== "undefined" ? ~~previous : 65535;
    for (var index = 0; index < buf.length; index++) {
      var byte = buf[index];
      crc = (TABLE[(crc ^ byte) & 255] ^ crc >> 8) & 65535;
    }
    return crc;
  });
  exports2.default = crc16modbus;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/crc16_modbus.js
var require_crc16_modbus = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = require_crc16modbus().default;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/es6/crc16xmodem.js
var require_crc16xmodem = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _buffer = require("buffer");
  var _create_buffer = require_create_buffer();
  var _create_buffer2 = _interopRequireDefault(_create_buffer);
  var _define_crc = require_define_crc();
  var _define_crc2 = _interopRequireDefault(_define_crc);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var crc16xmodem = (0, _define_crc2.default)("xmodem", function(buf, previous) {
    if (!_buffer.Buffer.isBuffer(buf))
      buf = (0, _create_buffer2.default)(buf);
    var crc = typeof previous !== "undefined" ? ~~previous : 0;
    for (var index = 0; index < buf.length; index++) {
      var byte = buf[index];
      var code = crc >>> 8 & 255;
      code ^= byte & 255;
      code ^= code >>> 4;
      crc = crc << 8 & 65535;
      crc ^= code;
      code = code << 5 & 65535;
      crc ^= code;
      code = code << 7 & 65535;
      crc ^= code;
    }
    return crc;
  });
  exports2.default = crc16xmodem;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/crc16_xmodem.js
var require_crc16_xmodem = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = require_crc16xmodem().default;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/es6/crc16kermit.js
var require_crc16kermit = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _buffer = require("buffer");
  var _create_buffer = require_create_buffer();
  var _create_buffer2 = _interopRequireDefault(_create_buffer);
  var _define_crc = require_define_crc();
  var _define_crc2 = _interopRequireDefault(_define_crc);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var TABLE = [0, 4489, 8978, 12955, 17956, 22445, 25910, 29887, 35912, 40385, 44890, 48851, 51820, 56293, 59774, 63735, 4225, 264, 13203, 8730, 22181, 18220, 30135, 25662, 40137, 36160, 49115, 44626, 56045, 52068, 63999, 59510, 8450, 12427, 528, 5017, 26406, 30383, 17460, 21949, 44362, 48323, 36440, 40913, 60270, 64231, 51324, 55797, 12675, 8202, 4753, 792, 30631, 26158, 21685, 17724, 48587, 44098, 40665, 36688, 64495, 60006, 55549, 51572, 16900, 21389, 24854, 28831, 1056, 5545, 10034, 14011, 52812, 57285, 60766, 64727, 34920, 39393, 43898, 47859, 21125, 17164, 29079, 24606, 5281, 1320, 14259, 9786, 57037, 53060, 64991, 60502, 39145, 35168, 48123, 43634, 25350, 29327, 16404, 20893, 9506, 13483, 1584, 6073, 61262, 65223, 52316, 56789, 43370, 47331, 35448, 39921, 29575, 25102, 20629, 16668, 13731, 9258, 5809, 1848, 65487, 60998, 56541, 52564, 47595, 43106, 39673, 35696, 33800, 38273, 42778, 46739, 49708, 54181, 57662, 61623, 2112, 6601, 11090, 15067, 20068, 24557, 28022, 31999, 38025, 34048, 47003, 42514, 53933, 49956, 61887, 57398, 6337, 2376, 15315, 10842, 24293, 20332, 32247, 27774, 42250, 46211, 34328, 38801, 58158, 62119, 49212, 53685, 10562, 14539, 2640, 7129, 28518, 32495, 19572, 24061, 46475, 41986, 38553, 34576, 62383, 57894, 53437, 49460, 14787, 10314, 6865, 2904, 32743, 28270, 23797, 19836, 50700, 55173, 58654, 62615, 32808, 37281, 41786, 45747, 19012, 23501, 26966, 30943, 3168, 7657, 12146, 16123, 54925, 50948, 62879, 58390, 37033, 33056, 46011, 41522, 23237, 19276, 31191, 26718, 7393, 3432, 16371, 11898, 59150, 63111, 50204, 54677, 41258, 45219, 33336, 37809, 27462, 31439, 18516, 23005, 11618, 15595, 3696, 8185, 63375, 58886, 54429, 50452, 45483, 40994, 37561, 33584, 31687, 27214, 22741, 18780, 15843, 11370, 7921, 3960];
  if (typeof Int32Array !== "undefined")
    TABLE = new Int32Array(TABLE);
  var crc16kermit = (0, _define_crc2.default)("kermit", function(buf, previous) {
    if (!_buffer.Buffer.isBuffer(buf))
      buf = (0, _create_buffer2.default)(buf);
    var crc = typeof previous !== "undefined" ? ~~previous : 0;
    for (var index = 0; index < buf.length; index++) {
      var byte = buf[index];
      crc = (TABLE[(crc ^ byte) & 255] ^ crc >> 8) & 65535;
    }
    return crc;
  });
  exports2.default = crc16kermit;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/crc16_kermit.js
var require_crc16_kermit = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = require_crc16kermit().default;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/es6/crc24.js
var require_crc24 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _buffer = require("buffer");
  var _create_buffer = require_create_buffer();
  var _create_buffer2 = _interopRequireDefault(_create_buffer);
  var _define_crc = require_define_crc();
  var _define_crc2 = _interopRequireDefault(_define_crc);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var TABLE = [0, 8801531, 9098509, 825846, 9692897, 1419802, 1651692, 10452759, 10584377, 2608578, 2839604, 11344079, 3303384, 11807523, 12104405, 4128302, 12930697, 4391538, 5217156, 13227903, 5679208, 13690003, 14450021, 5910942, 6606768, 14844747, 15604413, 6837830, 16197969, 7431594, 8256604, 16494759, 840169, 9084178, 8783076, 18463, 10434312, 1670131, 1434117, 9678590, 11358416, 2825259, 2590173, 10602790, 4109873, 12122826, 11821884, 3289031, 13213536, 5231515, 4409965, 12912278, 5929345, 14431610, 13675660, 5693559, 6823513, 15618722, 14863188, 6588335, 16513208, 8238147, 7417269, 16212302, 1680338, 10481449, 9664223, 1391140, 9061683, 788936, 36926, 8838341, 12067563, 4091408, 3340262, 11844381, 2868234, 11372785, 10555655, 2579964, 14478683, 5939616, 5650518, 13661357, 5180346, 13190977, 12967607, 4428364, 8219746, 16457881, 16234863, 7468436, 15633027, 6866552, 6578062, 14816117, 1405499, 9649856, 10463030, 1698765, 8819930, 55329, 803287, 9047340, 11858690, 3325945, 4072975, 12086004, 2561507, 10574104, 11387118, 2853909, 13647026, 5664841, 5958079, 14460228, 4446803, 12949160, 13176670, 5194661, 7454091, 16249200, 16476294, 8201341, 14834538, 6559633, 6852199, 15647388, 3360676, 11864927, 12161705, 4185682, 10527045, 2551230, 2782280, 11286707, 9619101, 1346150, 1577872, 10379115, 73852, 8875143, 9172337, 899466, 16124205, 7357910, 8182816, 16421083, 6680524, 14918455, 15678145, 6911546, 5736468, 13747439, 14507289, 5968354, 12873461, 4334094, 5159928, 13170435, 4167245, 12180150, 11879232, 3346363, 11301036, 2767959, 2532769, 10545498, 10360692, 1596303, 1360505, 9604738, 913813, 9157998, 8856728, 92259, 16439492, 8164415, 7343561, 16138546, 6897189, 15692510, 14936872, 6662099, 5986813, 14488838, 13733104, 5750795, 13156124, 5174247, 4352529, 12855018, 2810998, 11315341, 10498427, 2522496, 12124823, 4148844, 3397530, 11901793, 9135439, 862644, 110658, 8912057, 1606574, 10407765, 9590435, 1317464, 15706879, 6940164, 6651890, 14889737, 8145950, 16384229, 16161043, 7394792, 5123014, 13133629, 12910283, 4370992, 14535975, 5997020, 5707818, 13718737, 2504095, 10516836, 11329682, 2796649, 11916158, 3383173, 4130419, 12143240, 8893606, 129117, 876971, 9121104, 1331783, 9576124, 10389322, 1625009, 14908182, 6633453, 6925851, 15721184, 7380471, 16175372, 16402682, 8127489, 4389423, 12891860, 13119266, 5137369, 13704398, 5722165, 6015427, 14517560];
  if (typeof Int32Array !== "undefined")
    TABLE = new Int32Array(TABLE);
  var crc24 = (0, _define_crc2.default)("crc-24", function(buf, previous) {
    if (!_buffer.Buffer.isBuffer(buf))
      buf = (0, _create_buffer2.default)(buf);
    var crc = typeof previous !== "undefined" ? ~~previous : 11994318;
    for (var index = 0; index < buf.length; index++) {
      var byte = buf[index];
      crc = (TABLE[(crc >> 16 ^ byte) & 255] ^ crc << 8) & 16777215;
    }
    return crc;
  });
  exports2.default = crc24;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/crc24.js
var require_crc242 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = require_crc24().default;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/es6/crc32.js
var require_crc32 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _buffer = require("buffer");
  var _create_buffer = require_create_buffer();
  var _create_buffer2 = _interopRequireDefault(_create_buffer);
  var _define_crc = require_define_crc();
  var _define_crc2 = _interopRequireDefault(_define_crc);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var TABLE = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117];
  if (typeof Int32Array !== "undefined")
    TABLE = new Int32Array(TABLE);
  var crc32 = (0, _define_crc2.default)("crc-32", function(buf, previous) {
    if (!_buffer.Buffer.isBuffer(buf))
      buf = (0, _create_buffer2.default)(buf);
    var crc = previous === 0 ? 0 : ~~previous ^ -1;
    for (var index = 0; index < buf.length; index++) {
      var byte = buf[index];
      crc = TABLE[(crc ^ byte) & 255] ^ crc >>> 8;
    }
    return crc ^ -1;
  });
  exports2.default = crc32;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/crc32.js
var require_crc322 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = require_crc32().default;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/es6/crcjam.js
var require_crcjam = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _buffer = require("buffer");
  var _create_buffer = require_create_buffer();
  var _create_buffer2 = _interopRequireDefault(_create_buffer);
  var _define_crc = require_define_crc();
  var _define_crc2 = _interopRequireDefault(_define_crc);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var TABLE = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117];
  if (typeof Int32Array !== "undefined")
    TABLE = new Int32Array(TABLE);
  var crcjam = (0, _define_crc2.default)("jam", function(buf) {
    var previous = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
    if (!_buffer.Buffer.isBuffer(buf))
      buf = (0, _create_buffer2.default)(buf);
    var crc = previous === 0 ? 0 : ~~previous;
    for (var index = 0; index < buf.length; index++) {
      var byte = buf[index];
      crc = TABLE[(crc ^ byte) & 255] ^ crc >>> 8;
    }
    return crc;
  });
  exports2.default = crcjam;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/crcjam.js
var require_crcjam2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = require_crcjam().default;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/index.js
var require_lib5 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    crc1: require_crc12(),
    crc8: require_crc82(),
    crc81wire: require_crc8_1wire(),
    crc16: require_crc162(),
    crc16ccitt: require_crc16_ccitt(),
    crc16modbus: require_crc16_modbus(),
    crc16xmodem: require_crc16_xmodem(),
    crc16kermit: require_crc16_kermit(),
    crc24: require_crc242(),
    crc32: require_crc322(),
    crcjam: require_crcjam2()
  };
});

// ../../node_modules/.pnpm/crc32-stream@3.0.1/node_modules/crc32-stream/lib/crc32-stream.js
var require_crc32_stream = __commonJS((exports2, module2) => {
  "use strict";
  var {Transform} = require_readable2();
  var {crc32} = require_lib5();
  var CRC32Stream = class extends Transform {
    constructor(options) {
      super(options);
      this.checksum = Buffer.allocUnsafe(4);
      this.checksum.writeInt32BE(0, 0);
      this.rawSize = 0;
    }
    _transform(chunk, encoding, callback) {
      if (chunk) {
        this.checksum = crc32(chunk, this.checksum);
        this.rawSize += chunk.length;
      }
      callback(null, chunk);
    }
    digest(encoding) {
      const checksum = Buffer.allocUnsafe(4);
      checksum.writeUInt32BE(this.checksum >>> 0, 0);
      return encoding ? checksum.toString(encoding) : checksum;
    }
    hex() {
      return this.digest("hex").toUpperCase();
    }
    size() {
      return this.rawSize;
    }
  };
  module2.exports = CRC32Stream;
});

// ../../node_modules/.pnpm/crc32-stream@3.0.1/node_modules/crc32-stream/lib/deflate-crc32-stream.js
var require_deflate_crc32_stream = __commonJS((exports2, module2) => {
  "use strict";
  var {DeflateRaw} = require("zlib");
  var {crc32} = require_lib5();
  var DeflateCRC32Stream = class extends DeflateRaw {
    constructor(options) {
      super(options);
      this.checksum = Buffer.allocUnsafe(4);
      this.checksum.writeInt32BE(0, 0);
      this.rawSize = 0;
      this.compressedSize = 0;
    }
    push(chunk, encoding) {
      if (chunk) {
        this.compressedSize += chunk.length;
      }
      return super.push(chunk, encoding);
    }
    write(chunk, enc, cb) {
      if (chunk) {
        this.checksum = crc32(chunk, this.checksum);
        this.rawSize += chunk.length;
      }
      return super.write(chunk, enc, cb);
    }
    digest(encoding) {
      const checksum = Buffer.allocUnsafe(4);
      checksum.writeUInt32BE(this.checksum >>> 0, 0);
      return encoding ? checksum.toString(encoding) : checksum;
    }
    hex() {
      return this.digest("hex").toUpperCase();
    }
    size(compressed = false) {
      if (compressed) {
        return this.compressedSize;
      } else {
        return this.rawSize;
      }
    }
  };
  module2.exports = DeflateCRC32Stream;
});

// ../../node_modules/.pnpm/crc32-stream@3.0.1/node_modules/crc32-stream/lib/index.js
var require_lib6 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    CRC32Stream: require_crc32_stream(),
    DeflateCRC32Stream: require_deflate_crc32_stream()
  };
});

// ../../node_modules/.pnpm/compress-commons@3.0.0/node_modules/compress-commons/lib/archivers/zip/zip-archive-output-stream.js
var require_zip_archive_output_stream = __commonJS((exports2, module2) => {
  var inherits = require("util").inherits;
  var crc32 = require_buffer_crc32();
  var {CRC32Stream} = require_lib6();
  var {DeflateCRC32Stream} = require_lib6();
  var ArchiveOutputStream = require_archive_output_stream();
  var ZipArchiveEntry = require_zip_archive_entry();
  var GeneralPurposeBit = require_general_purpose_bit();
  var constants = require_constants5();
  var util2 = require_util7();
  var zipUtil = require_util6();
  var ZipArchiveOutputStream = module2.exports = function(options) {
    if (!(this instanceof ZipArchiveOutputStream)) {
      return new ZipArchiveOutputStream(options);
    }
    options = this.options = this._defaults(options);
    ArchiveOutputStream.call(this, options);
    this._entry = null;
    this._entries = [];
    this._archive = {
      centralLength: 0,
      centralOffset: 0,
      comment: "",
      finish: false,
      finished: false,
      processing: false,
      forceZip64: options.forceZip64,
      forceLocalTime: options.forceLocalTime
    };
  };
  inherits(ZipArchiveOutputStream, ArchiveOutputStream);
  ZipArchiveOutputStream.prototype._afterAppend = function(ae) {
    this._entries.push(ae);
    if (ae.getGeneralPurposeBit().usesDataDescriptor()) {
      this._writeDataDescriptor(ae);
    }
    this._archive.processing = false;
    this._entry = null;
    if (this._archive.finish && !this._archive.finished) {
      this._finish();
    }
  };
  ZipArchiveOutputStream.prototype._appendBuffer = function(ae, source, callback) {
    if (source.length === 0) {
      ae.setMethod(constants.METHOD_STORED);
    }
    var method = ae.getMethod();
    if (method === constants.METHOD_STORED) {
      ae.setSize(source.length);
      ae.setCompressedSize(source.length);
      ae.setCrc(crc32.unsigned(source));
    }
    this._writeLocalFileHeader(ae);
    if (method === constants.METHOD_STORED) {
      this.write(source);
      this._afterAppend(ae);
      callback(null, ae);
      return;
    } else if (method === constants.METHOD_DEFLATED) {
      this._smartStream(ae, callback).end(source);
      return;
    } else {
      callback(new Error("compression method " + method + " not implemented"));
      return;
    }
  };
  ZipArchiveOutputStream.prototype._appendStream = function(ae, source, callback) {
    ae.getGeneralPurposeBit().useDataDescriptor(true);
    ae.setVersionNeededToExtract(constants.MIN_VERSION_DATA_DESCRIPTOR);
    this._writeLocalFileHeader(ae);
    var smart = this._smartStream(ae, callback);
    source.once("error", function(err) {
      smart.emit("error", err);
      smart.end();
    });
    source.pipe(smart);
  };
  ZipArchiveOutputStream.prototype._defaults = function(o) {
    if (typeof o !== "object") {
      o = {};
    }
    if (typeof o.zlib !== "object") {
      o.zlib = {};
    }
    if (typeof o.zlib.level !== "number") {
      o.zlib.level = constants.ZLIB_BEST_SPEED;
    }
    o.forceZip64 = !!o.forceZip64;
    o.forceLocalTime = !!o.forceLocalTime;
    return o;
  };
  ZipArchiveOutputStream.prototype._finish = function() {
    this._archive.centralOffset = this.offset;
    this._entries.forEach(function(ae) {
      this._writeCentralFileHeader(ae);
    }.bind(this));
    this._archive.centralLength = this.offset - this._archive.centralOffset;
    if (this.isZip64()) {
      this._writeCentralDirectoryZip64();
    }
    this._writeCentralDirectoryEnd();
    this._archive.processing = false;
    this._archive.finish = true;
    this._archive.finished = true;
    this.end();
  };
  ZipArchiveOutputStream.prototype._normalizeEntry = function(ae) {
    if (ae.getMethod() === -1) {
      ae.setMethod(constants.METHOD_DEFLATED);
    }
    if (ae.getMethod() === constants.METHOD_DEFLATED) {
      ae.getGeneralPurposeBit().useDataDescriptor(true);
      ae.setVersionNeededToExtract(constants.MIN_VERSION_DATA_DESCRIPTOR);
    }
    if (ae.getTime() === -1) {
      ae.setTime(new Date(), this._archive.forceLocalTime);
    }
    ae._offsets = {
      file: 0,
      data: 0,
      contents: 0
    };
  };
  ZipArchiveOutputStream.prototype._smartStream = function(ae, callback) {
    var deflate = ae.getMethod() === constants.METHOD_DEFLATED;
    var process2 = deflate ? new DeflateCRC32Stream(this.options.zlib) : new CRC32Stream();
    var error = null;
    function handleStuff() {
      var digest = process2.digest().readUInt32BE(0);
      ae.setCrc(digest);
      ae.setSize(process2.size());
      ae.setCompressedSize(process2.size(true));
      this._afterAppend(ae);
      callback(error, ae);
    }
    process2.once("end", handleStuff.bind(this));
    process2.once("error", function(err) {
      error = err;
    });
    process2.pipe(this, {end: false});
    return process2;
  };
  ZipArchiveOutputStream.prototype._writeCentralDirectoryEnd = function() {
    var records = this._entries.length;
    var size = this._archive.centralLength;
    var offset = this._archive.centralOffset;
    if (this.isZip64()) {
      records = constants.ZIP64_MAGIC_SHORT;
      size = constants.ZIP64_MAGIC;
      offset = constants.ZIP64_MAGIC;
    }
    this.write(zipUtil.getLongBytes(constants.SIG_EOCD));
    this.write(constants.SHORT_ZERO);
    this.write(constants.SHORT_ZERO);
    this.write(zipUtil.getShortBytes(records));
    this.write(zipUtil.getShortBytes(records));
    this.write(zipUtil.getLongBytes(size));
    this.write(zipUtil.getLongBytes(offset));
    var comment = this.getComment();
    var commentLength = Buffer.byteLength(comment);
    this.write(zipUtil.getShortBytes(commentLength));
    this.write(comment);
  };
  ZipArchiveOutputStream.prototype._writeCentralDirectoryZip64 = function() {
    this.write(zipUtil.getLongBytes(constants.SIG_ZIP64_EOCD));
    this.write(zipUtil.getEightBytes(44));
    this.write(zipUtil.getShortBytes(constants.MIN_VERSION_ZIP64));
    this.write(zipUtil.getShortBytes(constants.MIN_VERSION_ZIP64));
    this.write(constants.LONG_ZERO);
    this.write(constants.LONG_ZERO);
    this.write(zipUtil.getEightBytes(this._entries.length));
    this.write(zipUtil.getEightBytes(this._entries.length));
    this.write(zipUtil.getEightBytes(this._archive.centralLength));
    this.write(zipUtil.getEightBytes(this._archive.centralOffset));
    this.write(zipUtil.getLongBytes(constants.SIG_ZIP64_EOCD_LOC));
    this.write(constants.LONG_ZERO);
    this.write(zipUtil.getEightBytes(this._archive.centralOffset + this._archive.centralLength));
    this.write(zipUtil.getLongBytes(1));
  };
  ZipArchiveOutputStream.prototype._writeCentralFileHeader = function(ae) {
    var gpb = ae.getGeneralPurposeBit();
    var method = ae.getMethod();
    var offsets = ae._offsets;
    var size = ae.getSize();
    var compressedSize = ae.getCompressedSize();
    if (ae.isZip64() || offsets.file > constants.ZIP64_MAGIC) {
      size = constants.ZIP64_MAGIC;
      compressedSize = constants.ZIP64_MAGIC;
      ae.setVersionNeededToExtract(constants.MIN_VERSION_ZIP64);
      var extraBuf = Buffer.concat([
        zipUtil.getShortBytes(constants.ZIP64_EXTRA_ID),
        zipUtil.getShortBytes(24),
        zipUtil.getEightBytes(ae.getSize()),
        zipUtil.getEightBytes(ae.getCompressedSize()),
        zipUtil.getEightBytes(offsets.file)
      ], 28);
      ae.setExtra(extraBuf);
    }
    this.write(zipUtil.getLongBytes(constants.SIG_CFH));
    this.write(zipUtil.getShortBytes(ae.getPlatform() << 8 | constants.VERSION_MADEBY));
    this.write(zipUtil.getShortBytes(ae.getVersionNeededToExtract()));
    this.write(gpb.encode());
    this.write(zipUtil.getShortBytes(method));
    this.write(zipUtil.getLongBytes(ae.getTimeDos()));
    this.write(zipUtil.getLongBytes(ae.getCrc()));
    this.write(zipUtil.getLongBytes(compressedSize));
    this.write(zipUtil.getLongBytes(size));
    var name = ae.getName();
    var comment = ae.getComment();
    var extra = ae.getCentralDirectoryExtra();
    if (gpb.usesUTF8ForNames()) {
      name = Buffer.from(name);
      comment = Buffer.from(comment);
    }
    this.write(zipUtil.getShortBytes(name.length));
    this.write(zipUtil.getShortBytes(extra.length));
    this.write(zipUtil.getShortBytes(comment.length));
    this.write(constants.SHORT_ZERO);
    this.write(zipUtil.getShortBytes(ae.getInternalAttributes()));
    this.write(zipUtil.getLongBytes(ae.getExternalAttributes()));
    if (offsets.file > constants.ZIP64_MAGIC) {
      this.write(zipUtil.getLongBytes(constants.ZIP64_MAGIC));
    } else {
      this.write(zipUtil.getLongBytes(offsets.file));
    }
    this.write(name);
    this.write(extra);
    this.write(comment);
  };
  ZipArchiveOutputStream.prototype._writeDataDescriptor = function(ae) {
    this.write(zipUtil.getLongBytes(constants.SIG_DD));
    this.write(zipUtil.getLongBytes(ae.getCrc()));
    if (ae.isZip64()) {
      this.write(zipUtil.getEightBytes(ae.getCompressedSize()));
      this.write(zipUtil.getEightBytes(ae.getSize()));
    } else {
      this.write(zipUtil.getLongBytes(ae.getCompressedSize()));
      this.write(zipUtil.getLongBytes(ae.getSize()));
    }
  };
  ZipArchiveOutputStream.prototype._writeLocalFileHeader = function(ae) {
    var gpb = ae.getGeneralPurposeBit();
    var method = ae.getMethod();
    var name = ae.getName();
    var extra = ae.getLocalFileDataExtra();
    if (ae.isZip64()) {
      gpb.useDataDescriptor(true);
      ae.setVersionNeededToExtract(constants.MIN_VERSION_ZIP64);
    }
    if (gpb.usesUTF8ForNames()) {
      name = Buffer.from(name);
    }
    ae._offsets.file = this.offset;
    this.write(zipUtil.getLongBytes(constants.SIG_LFH));
    this.write(zipUtil.getShortBytes(ae.getVersionNeededToExtract()));
    this.write(gpb.encode());
    this.write(zipUtil.getShortBytes(method));
    this.write(zipUtil.getLongBytes(ae.getTimeDos()));
    ae._offsets.data = this.offset;
    if (gpb.usesDataDescriptor()) {
      this.write(constants.LONG_ZERO);
      this.write(constants.LONG_ZERO);
      this.write(constants.LONG_ZERO);
    } else {
      this.write(zipUtil.getLongBytes(ae.getCrc()));
      this.write(zipUtil.getLongBytes(ae.getCompressedSize()));
      this.write(zipUtil.getLongBytes(ae.getSize()));
    }
    this.write(zipUtil.getShortBytes(name.length));
    this.write(zipUtil.getShortBytes(extra.length));
    this.write(name);
    this.write(extra);
    ae._offsets.contents = this.offset;
  };
  ZipArchiveOutputStream.prototype.getComment = function(comment) {
    return this._archive.comment !== null ? this._archive.comment : "";
  };
  ZipArchiveOutputStream.prototype.isZip64 = function() {
    return this._archive.forceZip64 || this._entries.length > constants.ZIP64_MAGIC_SHORT || this._archive.centralLength > constants.ZIP64_MAGIC || this._archive.centralOffset > constants.ZIP64_MAGIC;
  };
  ZipArchiveOutputStream.prototype.setComment = function(comment) {
    this._archive.comment = comment;
  };
});

// ../../node_modules/.pnpm/compress-commons@3.0.0/node_modules/compress-commons/lib/compress-commons.js
var require_compress_commons = __commonJS((exports2, module2) => {
  module2.exports = {
    ArchiveEntry: require_archive_entry(),
    ZipArchiveEntry: require_zip_archive_entry(),
    ArchiveOutputStream: require_archive_output_stream(),
    ZipArchiveOutputStream: require_zip_archive_output_stream()
  };
});

// ../../node_modules/.pnpm/zip-stream@3.0.1/node_modules/zip-stream/index.js
var require_zip_stream = __commonJS((exports2, module2) => {
  /**
   * ZipStream
   *
   * @ignore
   * @license [MIT]{@link https://github.com/archiverjs/node-zip-stream/blob/master/LICENSE}
   * @copyright (c) 2014 Chris Talkington, contributors.
   */
  var inherits = require("util").inherits;
  var ZipArchiveOutputStream = require_compress_commons().ZipArchiveOutputStream;
  var ZipArchiveEntry = require_compress_commons().ZipArchiveEntry;
  var util2 = require_archiver_utils();
  var ZipStream = module2.exports = function(options) {
    if (!(this instanceof ZipStream)) {
      return new ZipStream(options);
    }
    options = this.options = options || {};
    options.zlib = options.zlib || {};
    ZipArchiveOutputStream.call(this, options);
    if (typeof options.level === "number" && options.level >= 0) {
      options.zlib.level = options.level;
      delete options.level;
    }
    if (!options.forceZip64 && typeof options.zlib.level === "number" && options.zlib.level === 0) {
      options.store = true;
    }
    if (options.comment && options.comment.length > 0) {
      this.setComment(options.comment);
    }
  };
  inherits(ZipStream, ZipArchiveOutputStream);
  ZipStream.prototype._normalizeFileData = function(data) {
    data = util2.defaults(data, {
      type: "file",
      name: null,
      linkname: null,
      date: null,
      mode: null,
      store: this.options.store,
      comment: ""
    });
    var isDir = data.type === "directory";
    var isSymlink = data.type === "symlink";
    if (data.name) {
      data.name = util2.sanitizePath(data.name);
      if (!isSymlink && data.name.slice(-1) === "/") {
        isDir = true;
        data.type = "directory";
      } else if (isDir) {
        data.name += "/";
      }
    }
    if (isDir || isSymlink) {
      data.store = true;
    }
    data.date = util2.dateify(data.date);
    return data;
  };
  ZipStream.prototype.entry = function(source, data, callback) {
    if (typeof callback !== "function") {
      callback = this._emitErrorCallback.bind(this);
    }
    data = this._normalizeFileData(data);
    if (data.type !== "file" && data.type !== "directory" && data.type !== "symlink") {
      callback(new Error(data.type + " entries not currently supported"));
      return;
    }
    if (typeof data.name !== "string" || data.name.length === 0) {
      callback(new Error("entry name must be a non-empty string value"));
      return;
    }
    if (data.type === "symlink" && typeof data.linkname !== "string") {
      callback(new Error("entry linkname must be a non-empty string value when type equals symlink"));
      return;
    }
    var entry = new ZipArchiveEntry(data.name);
    entry.setTime(data.date, this.options.forceLocalTime);
    if (data.store) {
      entry.setMethod(0);
    }
    if (data.comment.length > 0) {
      entry.setComment(data.comment);
    }
    if (data.type === "symlink" && typeof data.mode !== "number") {
      data.mode = 40960;
    }
    if (typeof data.mode === "number") {
      if (data.type === "symlink") {
        data.mode |= 40960;
      }
      entry.setUnixMode(data.mode);
    }
    if (data.type === "symlink" && typeof data.linkname === "string") {
      source = Buffer.from(data.linkname);
    }
    return ZipArchiveOutputStream.prototype.entry.call(this, entry, source, callback);
  };
  ZipStream.prototype.finalize = function() {
    this.finish();
  };
});

// ../../node_modules/.pnpm/archiver@4.0.2/node_modules/archiver/lib/plugins/zip.js
var require_zip = __commonJS((exports2, module2) => {
  /**
   * ZIP Format Plugin
   *
   * @module plugins/zip
   * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
   * @copyright (c) 2012-2014 Chris Talkington, contributors.
   */
  var engine = require_zip_stream();
  var util2 = require_archiver_utils();
  var Zip = function(options) {
    if (!(this instanceof Zip)) {
      return new Zip(options);
    }
    options = this.options = util2.defaults(options, {
      comment: "",
      forceUTC: false,
      store: false
    });
    this.supports = {
      directory: true,
      symlink: true
    };
    this.engine = new engine(options);
  };
  Zip.prototype.append = function(source, data, callback) {
    this.engine.entry(source, data, callback);
  };
  Zip.prototype.finalize = function() {
    this.engine.finalize();
  };
  Zip.prototype.on = function() {
    return this.engine.on.apply(this.engine, arguments);
  };
  Zip.prototype.pipe = function() {
    return this.engine.pipe.apply(this.engine, arguments);
  };
  Zip.prototype.unpipe = function() {
    return this.engine.unpipe.apply(this.engine, arguments);
  };
  module2.exports = Zip;
});

// ../../node_modules/.pnpm/bl@4.1.0/node_modules/bl/BufferList.js
var require_BufferList2 = __commonJS((exports2, module2) => {
  "use strict";
  var {Buffer: Buffer2} = require("buffer");
  var symbol = Symbol.for("BufferList");
  function BufferList(buf) {
    if (!(this instanceof BufferList)) {
      return new BufferList(buf);
    }
    BufferList._init.call(this, buf);
  }
  BufferList._init = function _init(buf) {
    Object.defineProperty(this, symbol, {value: true});
    this._bufs = [];
    this.length = 0;
    if (buf) {
      this.append(buf);
    }
  };
  BufferList.prototype._new = function _new(buf) {
    return new BufferList(buf);
  };
  BufferList.prototype._offset = function _offset(offset) {
    if (offset === 0) {
      return [0, 0];
    }
    let tot = 0;
    for (let i = 0; i < this._bufs.length; i++) {
      const _t = tot + this._bufs[i].length;
      if (offset < _t || i === this._bufs.length - 1) {
        return [i, offset - tot];
      }
      tot = _t;
    }
  };
  BufferList.prototype._reverseOffset = function(blOffset) {
    const bufferId = blOffset[0];
    let offset = blOffset[1];
    for (let i = 0; i < bufferId; i++) {
      offset += this._bufs[i].length;
    }
    return offset;
  };
  BufferList.prototype.get = function get(index) {
    if (index > this.length || index < 0) {
      return void 0;
    }
    const offset = this._offset(index);
    return this._bufs[offset[0]][offset[1]];
  };
  BufferList.prototype.slice = function slice(start, end) {
    if (typeof start === "number" && start < 0) {
      start += this.length;
    }
    if (typeof end === "number" && end < 0) {
      end += this.length;
    }
    return this.copy(null, 0, start, end);
  };
  BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
    if (typeof srcStart !== "number" || srcStart < 0) {
      srcStart = 0;
    }
    if (typeof srcEnd !== "number" || srcEnd > this.length) {
      srcEnd = this.length;
    }
    if (srcStart >= this.length) {
      return dst || Buffer2.alloc(0);
    }
    if (srcEnd <= 0) {
      return dst || Buffer2.alloc(0);
    }
    const copy2 = !!dst;
    const off = this._offset(srcStart);
    const len = srcEnd - srcStart;
    let bytes = len;
    let bufoff = copy2 && dstStart || 0;
    let start = off[1];
    if (srcStart === 0 && srcEnd === this.length) {
      if (!copy2) {
        return this._bufs.length === 1 ? this._bufs[0] : Buffer2.concat(this._bufs, this.length);
      }
      for (let i = 0; i < this._bufs.length; i++) {
        this._bufs[i].copy(dst, bufoff);
        bufoff += this._bufs[i].length;
      }
      return dst;
    }
    if (bytes <= this._bufs[off[0]].length - start) {
      return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
    }
    if (!copy2) {
      dst = Buffer2.allocUnsafe(len);
    }
    for (let i = off[0]; i < this._bufs.length; i++) {
      const l = this._bufs[i].length - start;
      if (bytes > l) {
        this._bufs[i].copy(dst, bufoff, start);
        bufoff += l;
      } else {
        this._bufs[i].copy(dst, bufoff, start, start + bytes);
        bufoff += l;
        break;
      }
      bytes -= l;
      if (start) {
        start = 0;
      }
    }
    if (dst.length > bufoff)
      return dst.slice(0, bufoff);
    return dst;
  };
  BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
    start = start || 0;
    end = typeof end !== "number" ? this.length : end;
    if (start < 0) {
      start += this.length;
    }
    if (end < 0) {
      end += this.length;
    }
    if (start === end) {
      return this._new();
    }
    const startOffset = this._offset(start);
    const endOffset = this._offset(end);
    const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
    if (endOffset[1] === 0) {
      buffers.pop();
    } else {
      buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
    }
    if (startOffset[1] !== 0) {
      buffers[0] = buffers[0].slice(startOffset[1]);
    }
    return this._new(buffers);
  };
  BufferList.prototype.toString = function toString(encoding, start, end) {
    return this.slice(start, end).toString(encoding);
  };
  BufferList.prototype.consume = function consume(bytes) {
    bytes = Math.trunc(bytes);
    if (Number.isNaN(bytes) || bytes <= 0)
      return this;
    while (this._bufs.length) {
      if (bytes >= this._bufs[0].length) {
        bytes -= this._bufs[0].length;
        this.length -= this._bufs[0].length;
        this._bufs.shift();
      } else {
        this._bufs[0] = this._bufs[0].slice(bytes);
        this.length -= bytes;
        break;
      }
    }
    return this;
  };
  BufferList.prototype.duplicate = function duplicate() {
    const copy = this._new();
    for (let i = 0; i < this._bufs.length; i++) {
      copy.append(this._bufs[i]);
    }
    return copy;
  };
  BufferList.prototype.append = function append(buf) {
    if (buf == null) {
      return this;
    }
    if (buf.buffer) {
      this._appendBuffer(Buffer2.from(buf.buffer, buf.byteOffset, buf.byteLength));
    } else if (Array.isArray(buf)) {
      for (let i = 0; i < buf.length; i++) {
        this.append(buf[i]);
      }
    } else if (this._isBufferList(buf)) {
      for (let i = 0; i < buf._bufs.length; i++) {
        this.append(buf._bufs[i]);
      }
    } else {
      if (typeof buf === "number") {
        buf = buf.toString();
      }
      this._appendBuffer(Buffer2.from(buf));
    }
    return this;
  };
  BufferList.prototype._appendBuffer = function appendBuffer(buf) {
    this._bufs.push(buf);
    this.length += buf.length;
  };
  BufferList.prototype.indexOf = function(search, offset, encoding) {
    if (encoding === void 0 && typeof offset === "string") {
      encoding = offset;
      offset = void 0;
    }
    if (typeof search === "function" || Array.isArray(search)) {
      throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
    } else if (typeof search === "number") {
      search = Buffer2.from([search]);
    } else if (typeof search === "string") {
      search = Buffer2.from(search, encoding);
    } else if (this._isBufferList(search)) {
      search = search.slice();
    } else if (Array.isArray(search.buffer)) {
      search = Buffer2.from(search.buffer, search.byteOffset, search.byteLength);
    } else if (!Buffer2.isBuffer(search)) {
      search = Buffer2.from(search);
    }
    offset = Number(offset || 0);
    if (isNaN(offset)) {
      offset = 0;
    }
    if (offset < 0) {
      offset = this.length + offset;
    }
    if (offset < 0) {
      offset = 0;
    }
    if (search.length === 0) {
      return offset > this.length ? this.length : offset;
    }
    const blOffset = this._offset(offset);
    let blIndex = blOffset[0];
    let buffOffset = blOffset[1];
    for (; blIndex < this._bufs.length; blIndex++) {
      const buff = this._bufs[blIndex];
      while (buffOffset < buff.length) {
        const availableWindow = buff.length - buffOffset;
        if (availableWindow >= search.length) {
          const nativeSearchResult = buff.indexOf(search, buffOffset);
          if (nativeSearchResult !== -1) {
            return this._reverseOffset([blIndex, nativeSearchResult]);
          }
          buffOffset = buff.length - search.length + 1;
        } else {
          const revOffset = this._reverseOffset([blIndex, buffOffset]);
          if (this._match(revOffset, search)) {
            return revOffset;
          }
          buffOffset++;
        }
      }
      buffOffset = 0;
    }
    return -1;
  };
  BufferList.prototype._match = function(offset, search) {
    if (this.length - offset < search.length) {
      return false;
    }
    for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
      if (this.get(offset + searchOffset) !== search[searchOffset]) {
        return false;
      }
    }
    return true;
  };
  (function() {
    const methods = {
      readDoubleBE: 8,
      readDoubleLE: 8,
      readFloatBE: 4,
      readFloatLE: 4,
      readInt32BE: 4,
      readInt32LE: 4,
      readUInt32BE: 4,
      readUInt32LE: 4,
      readInt16BE: 2,
      readInt16LE: 2,
      readUInt16BE: 2,
      readUInt16LE: 2,
      readInt8: 1,
      readUInt8: 1,
      readIntBE: null,
      readIntLE: null,
      readUIntBE: null,
      readUIntLE: null
    };
    for (const m2 in methods) {
      (function(m3) {
        if (methods[m3] === null) {
          BufferList.prototype[m3] = function(offset, byteLength) {
            return this.slice(offset, offset + byteLength)[m3](0, byteLength);
          };
        } else {
          BufferList.prototype[m3] = function(offset = 0) {
            return this.slice(offset, offset + methods[m3])[m3](0);
          };
        }
      })(m2);
    }
  })();
  BufferList.prototype._isBufferList = function _isBufferList(b) {
    return b instanceof BufferList || BufferList.isBufferList(b);
  };
  BufferList.isBufferList = function isBufferList(b) {
    return b != null && b[symbol];
  };
  module2.exports = BufferList;
});

// ../../node_modules/.pnpm/bl@4.1.0/node_modules/bl/bl.js
var require_bl = __commonJS((exports2, module2) => {
  "use strict";
  var DuplexStream = require_readable2().Duplex;
  var inherits = require_inherits();
  var BufferList = require_BufferList2();
  function BufferListStream(callback) {
    if (!(this instanceof BufferListStream)) {
      return new BufferListStream(callback);
    }
    if (typeof callback === "function") {
      this._callback = callback;
      const piper = function piper2(err) {
        if (this._callback) {
          this._callback(err);
          this._callback = null;
        }
      }.bind(this);
      this.on("pipe", function onPipe(src) {
        src.on("error", piper);
      });
      this.on("unpipe", function onUnpipe(src) {
        src.removeListener("error", piper);
      });
      callback = null;
    }
    BufferList._init.call(this, callback);
    DuplexStream.call(this);
  }
  inherits(BufferListStream, DuplexStream);
  Object.assign(BufferListStream.prototype, BufferList.prototype);
  BufferListStream.prototype._new = function _new(callback) {
    return new BufferListStream(callback);
  };
  BufferListStream.prototype._write = function _write(buf, encoding, callback) {
    this._appendBuffer(buf);
    if (typeof callback === "function") {
      callback();
    }
  };
  BufferListStream.prototype._read = function _read(size) {
    if (!this.length) {
      return this.push(null);
    }
    size = Math.min(size, this.length);
    this.push(this.slice(0, size));
    this.consume(size);
  };
  BufferListStream.prototype.end = function end(chunk) {
    DuplexStream.prototype.end.call(this, chunk);
    if (this._callback) {
      this._callback(null, this.slice());
      this._callback = null;
    }
  };
  BufferListStream.prototype._destroy = function _destroy(err, cb) {
    this._bufs.length = 0;
    this.length = 0;
    cb(err);
  };
  BufferListStream.prototype._isBufferList = function _isBufferList(b) {
    return b instanceof BufferListStream || b instanceof BufferList || BufferListStream.isBufferList(b);
  };
  BufferListStream.isBufferList = BufferList.isBufferList;
  module2.exports = BufferListStream;
  module2.exports.BufferListStream = BufferListStream;
  module2.exports.BufferList = BufferList;
});

// ../../node_modules/.pnpm/tar-stream@2.2.0/node_modules/tar-stream/headers.js
var require_headers = __commonJS((exports2) => {
  var alloc = Buffer.alloc;
  var ZEROS = "0000000000000000000";
  var SEVENS = "7777777777777777777";
  var ZERO_OFFSET = "0".charCodeAt(0);
  var USTAR_MAGIC = Buffer.from("ustar\0", "binary");
  var USTAR_VER = Buffer.from("00", "binary");
  var GNU_MAGIC = Buffer.from("ustar ", "binary");
  var GNU_VER = Buffer.from(" \0", "binary");
  var MASK = parseInt("7777", 8);
  var MAGIC_OFFSET = 257;
  var VERSION_OFFSET = 263;
  var clamp = function(index, len, defaultValue) {
    if (typeof index !== "number")
      return defaultValue;
    index = ~~index;
    if (index >= len)
      return len;
    if (index >= 0)
      return index;
    index += len;
    if (index >= 0)
      return index;
    return 0;
  };
  var toType = function(flag) {
    switch (flag) {
      case 0:
        return "file";
      case 1:
        return "link";
      case 2:
        return "symlink";
      case 3:
        return "character-device";
      case 4:
        return "block-device";
      case 5:
        return "directory";
      case 6:
        return "fifo";
      case 7:
        return "contiguous-file";
      case 72:
        return "pax-header";
      case 55:
        return "pax-global-header";
      case 27:
        return "gnu-long-link-path";
      case 28:
      case 30:
        return "gnu-long-path";
    }
    return null;
  };
  var toTypeflag = function(flag) {
    switch (flag) {
      case "file":
        return 0;
      case "link":
        return 1;
      case "symlink":
        return 2;
      case "character-device":
        return 3;
      case "block-device":
        return 4;
      case "directory":
        return 5;
      case "fifo":
        return 6;
      case "contiguous-file":
        return 7;
      case "pax-header":
        return 72;
    }
    return 0;
  };
  var indexOf = function(block, num, offset, end) {
    for (; offset < end; offset++) {
      if (block[offset] === num)
        return offset;
    }
    return end;
  };
  var cksum = function(block) {
    var sum = 8 * 32;
    for (var i = 0; i < 148; i++)
      sum += block[i];
    for (var j = 156; j < 512; j++)
      sum += block[j];
    return sum;
  };
  var encodeOct = function(val, n) {
    val = val.toString(8);
    if (val.length > n)
      return SEVENS.slice(0, n) + " ";
    else
      return ZEROS.slice(0, n - val.length) + val + " ";
  };
  function parse256(buf) {
    var positive;
    if (buf[0] === 128)
      positive = true;
    else if (buf[0] === 255)
      positive = false;
    else
      return null;
    var tuple = [];
    for (var i = buf.length - 1; i > 0; i--) {
      var byte = buf[i];
      if (positive)
        tuple.push(byte);
      else
        tuple.push(255 - byte);
    }
    var sum = 0;
    var l = tuple.length;
    for (i = 0; i < l; i++) {
      sum += tuple[i] * Math.pow(256, i);
    }
    return positive ? sum : -1 * sum;
  }
  var decodeOct = function(val, offset, length) {
    val = val.slice(offset, offset + length);
    offset = 0;
    if (val[offset] & 128) {
      return parse256(val);
    } else {
      while (offset < val.length && val[offset] === 32)
        offset++;
      var end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length);
      while (offset < end && val[offset] === 0)
        offset++;
      if (end === offset)
        return 0;
      return parseInt(val.slice(offset, end).toString(), 8);
    }
  };
  var decodeStr = function(val, offset, length, encoding) {
    return val.slice(offset, indexOf(val, 0, offset, offset + length)).toString(encoding);
  };
  var addLength = function(str) {
    var len = Buffer.byteLength(str);
    var digits = Math.floor(Math.log(len) / Math.log(10)) + 1;
    if (len + digits >= Math.pow(10, digits))
      digits++;
    return len + digits + str;
  };
  exports2.decodeLongPath = function(buf, encoding) {
    return decodeStr(buf, 0, buf.length, encoding);
  };
  exports2.encodePax = function(opts) {
    var result = "";
    if (opts.name)
      result += addLength(" path=" + opts.name + "\n");
    if (opts.linkname)
      result += addLength(" linkpath=" + opts.linkname + "\n");
    var pax = opts.pax;
    if (pax) {
      for (var key in pax) {
        result += addLength(" " + key + "=" + pax[key] + "\n");
      }
    }
    return Buffer.from(result);
  };
  exports2.decodePax = function(buf) {
    var result = {};
    while (buf.length) {
      var i = 0;
      while (i < buf.length && buf[i] !== 32)
        i++;
      var len = parseInt(buf.slice(0, i).toString(), 10);
      if (!len)
        return result;
      var b = buf.slice(i + 1, len - 1).toString();
      var keyIndex = b.indexOf("=");
      if (keyIndex === -1)
        return result;
      result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1);
      buf = buf.slice(len);
    }
    return result;
  };
  exports2.encode = function(opts) {
    var buf = alloc(512);
    var name = opts.name;
    var prefix = "";
    if (opts.typeflag === 5 && name[name.length - 1] !== "/")
      name += "/";
    if (Buffer.byteLength(name) !== name.length)
      return null;
    while (Buffer.byteLength(name) > 100) {
      var i = name.indexOf("/");
      if (i === -1)
        return null;
      prefix += prefix ? "/" + name.slice(0, i) : name.slice(0, i);
      name = name.slice(i + 1);
    }
    if (Buffer.byteLength(name) > 100 || Buffer.byteLength(prefix) > 155)
      return null;
    if (opts.linkname && Buffer.byteLength(opts.linkname) > 100)
      return null;
    buf.write(name);
    buf.write(encodeOct(opts.mode & MASK, 6), 100);
    buf.write(encodeOct(opts.uid, 6), 108);
    buf.write(encodeOct(opts.gid, 6), 116);
    buf.write(encodeOct(opts.size, 11), 124);
    buf.write(encodeOct(opts.mtime.getTime() / 1e3 | 0, 11), 136);
    buf[156] = ZERO_OFFSET + toTypeflag(opts.type);
    if (opts.linkname)
      buf.write(opts.linkname, 157);
    USTAR_MAGIC.copy(buf, MAGIC_OFFSET);
    USTAR_VER.copy(buf, VERSION_OFFSET);
    if (opts.uname)
      buf.write(opts.uname, 265);
    if (opts.gname)
      buf.write(opts.gname, 297);
    buf.write(encodeOct(opts.devmajor || 0, 6), 329);
    buf.write(encodeOct(opts.devminor || 0, 6), 337);
    if (prefix)
      buf.write(prefix, 345);
    buf.write(encodeOct(cksum(buf), 6), 148);
    return buf;
  };
  exports2.decode = function(buf, filenameEncoding, allowUnknownFormat) {
    var typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET;
    var name = decodeStr(buf, 0, 100, filenameEncoding);
    var mode = decodeOct(buf, 100, 8);
    var uid = decodeOct(buf, 108, 8);
    var gid = decodeOct(buf, 116, 8);
    var size = decodeOct(buf, 124, 12);
    var mtime = decodeOct(buf, 136, 12);
    var type = toType(typeflag);
    var linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding);
    var uname = decodeStr(buf, 265, 32);
    var gname = decodeStr(buf, 297, 32);
    var devmajor = decodeOct(buf, 329, 8);
    var devminor = decodeOct(buf, 337, 8);
    var c = cksum(buf);
    if (c === 8 * 32)
      return null;
    if (c !== decodeOct(buf, 148, 8))
      throw new Error("Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?");
    if (USTAR_MAGIC.compare(buf, MAGIC_OFFSET, MAGIC_OFFSET + 6) === 0) {
      if (buf[345])
        name = decodeStr(buf, 345, 155, filenameEncoding) + "/" + name;
    } else if (GNU_MAGIC.compare(buf, MAGIC_OFFSET, MAGIC_OFFSET + 6) === 0 && GNU_VER.compare(buf, VERSION_OFFSET, VERSION_OFFSET + 2) === 0) {
    } else {
      if (!allowUnknownFormat) {
        throw new Error("Invalid tar header: unknown format.");
      }
    }
    if (typeflag === 0 && name && name[name.length - 1] === "/")
      typeflag = 5;
    return {
      name,
      mode,
      uid,
      gid,
      size,
      mtime: new Date(1e3 * mtime),
      type,
      linkname,
      uname,
      gname,
      devmajor,
      devminor
    };
  };
});

// ../../node_modules/.pnpm/tar-stream@2.2.0/node_modules/tar-stream/extract.js
var require_extract2 = __commonJS((exports2, module2) => {
  var util2 = require("util");
  var bl = require_bl();
  var headers = require_headers();
  var Writable = require_readable2().Writable;
  var PassThrough = require_readable2().PassThrough;
  var noop = function() {
  };
  var overflow = function(size) {
    size &= 511;
    return size && 512 - size;
  };
  var emptyStream = function(self2, offset) {
    var s2 = new Source(self2, offset);
    s2.end();
    return s2;
  };
  var mixinPax = function(header, pax) {
    if (pax.path)
      header.name = pax.path;
    if (pax.linkpath)
      header.linkname = pax.linkpath;
    if (pax.size)
      header.size = parseInt(pax.size, 10);
    header.pax = pax;
    return header;
  };
  var Source = function(self2, offset) {
    this._parent = self2;
    this.offset = offset;
    PassThrough.call(this, {autoDestroy: false});
  };
  util2.inherits(Source, PassThrough);
  Source.prototype.destroy = function(err) {
    this._parent.destroy(err);
  };
  var Extract = function(opts) {
    if (!(this instanceof Extract))
      return new Extract(opts);
    Writable.call(this, opts);
    opts = opts || {};
    this._offset = 0;
    this._buffer = bl();
    this._missing = 0;
    this._partial = false;
    this._onparse = noop;
    this._header = null;
    this._stream = null;
    this._overflow = null;
    this._cb = null;
    this._locked = false;
    this._destroyed = false;
    this._pax = null;
    this._paxGlobal = null;
    this._gnuLongPath = null;
    this._gnuLongLinkPath = null;
    var self2 = this;
    var b = self2._buffer;
    var oncontinue = function() {
      self2._continue();
    };
    var onunlock = function(err) {
      self2._locked = false;
      if (err)
        return self2.destroy(err);
      if (!self2._stream)
        oncontinue();
    };
    var onstreamend = function() {
      self2._stream = null;
      var drain = overflow(self2._header.size);
      if (drain)
        self2._parse(drain, ondrain);
      else
        self2._parse(512, onheader);
      if (!self2._locked)
        oncontinue();
    };
    var ondrain = function() {
      self2._buffer.consume(overflow(self2._header.size));
      self2._parse(512, onheader);
      oncontinue();
    };
    var onpaxglobalheader = function() {
      var size = self2._header.size;
      self2._paxGlobal = headers.decodePax(b.slice(0, size));
      b.consume(size);
      onstreamend();
    };
    var onpaxheader = function() {
      var size = self2._header.size;
      self2._pax = headers.decodePax(b.slice(0, size));
      if (self2._paxGlobal)
        self2._pax = Object.assign({}, self2._paxGlobal, self2._pax);
      b.consume(size);
      onstreamend();
    };
    var ongnulongpath = function() {
      var size = self2._header.size;
      this._gnuLongPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding);
      b.consume(size);
      onstreamend();
    };
    var ongnulonglinkpath = function() {
      var size = self2._header.size;
      this._gnuLongLinkPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding);
      b.consume(size);
      onstreamend();
    };
    var onheader = function() {
      var offset = self2._offset;
      var header;
      try {
        header = self2._header = headers.decode(b.slice(0, 512), opts.filenameEncoding, opts.allowUnknownFormat);
      } catch (err) {
        self2.emit("error", err);
      }
      b.consume(512);
      if (!header) {
        self2._parse(512, onheader);
        oncontinue();
        return;
      }
      if (header.type === "gnu-long-path") {
        self2._parse(header.size, ongnulongpath);
        oncontinue();
        return;
      }
      if (header.type === "gnu-long-link-path") {
        self2._parse(header.size, ongnulonglinkpath);
        oncontinue();
        return;
      }
      if (header.type === "pax-global-header") {
        self2._parse(header.size, onpaxglobalheader);
        oncontinue();
        return;
      }
      if (header.type === "pax-header") {
        self2._parse(header.size, onpaxheader);
        oncontinue();
        return;
      }
      if (self2._gnuLongPath) {
        header.name = self2._gnuLongPath;
        self2._gnuLongPath = null;
      }
      if (self2._gnuLongLinkPath) {
        header.linkname = self2._gnuLongLinkPath;
        self2._gnuLongLinkPath = null;
      }
      if (self2._pax) {
        self2._header = header = mixinPax(header, self2._pax);
        self2._pax = null;
      }
      self2._locked = true;
      if (!header.size || header.type === "directory") {
        self2._parse(512, onheader);
        self2.emit("entry", header, emptyStream(self2, offset), onunlock);
        return;
      }
      self2._stream = new Source(self2, offset);
      self2.emit("entry", header, self2._stream, onunlock);
      self2._parse(header.size, onstreamend);
      oncontinue();
    };
    this._onheader = onheader;
    this._parse(512, onheader);
  };
  util2.inherits(Extract, Writable);
  Extract.prototype.destroy = function(err) {
    if (this._destroyed)
      return;
    this._destroyed = true;
    if (err)
      this.emit("error", err);
    this.emit("close");
    if (this._stream)
      this._stream.emit("close");
  };
  Extract.prototype._parse = function(size, onparse) {
    if (this._destroyed)
      return;
    this._offset += size;
    this._missing = size;
    if (onparse === this._onheader)
      this._partial = false;
    this._onparse = onparse;
  };
  Extract.prototype._continue = function() {
    if (this._destroyed)
      return;
    var cb = this._cb;
    this._cb = noop;
    if (this._overflow)
      this._write(this._overflow, void 0, cb);
    else
      cb();
  };
  Extract.prototype._write = function(data, enc, cb) {
    if (this._destroyed)
      return;
    var s2 = this._stream;
    var b = this._buffer;
    var missing = this._missing;
    if (data.length)
      this._partial = true;
    if (data.length < missing) {
      this._missing -= data.length;
      this._overflow = null;
      if (s2)
        return s2.write(data, cb);
      b.append(data);
      return cb();
    }
    this._cb = cb;
    this._missing = 0;
    var overflow2 = null;
    if (data.length > missing) {
      overflow2 = data.slice(missing);
      data = data.slice(0, missing);
    }
    if (s2)
      s2.end(data);
    else
      b.append(data);
    this._overflow = overflow2;
    this._onparse();
  };
  Extract.prototype._final = function(cb) {
    if (this._partial)
      return this.destroy(new Error("Unexpected end of data"));
    cb();
  };
  module2.exports = Extract;
});

// ../../node_modules/.pnpm/fs-constants@1.0.0/node_modules/fs-constants/index.js
var require_fs_constants = __commonJS((exports2, module2) => {
  module2.exports = require("fs").constants || require("constants");
});

// ../../node_modules/.pnpm/end-of-stream@1.4.4/node_modules/end-of-stream/index.js
var require_end_of_stream2 = __commonJS((exports2, module2) => {
  var once = require_once();
  var noop = function() {
  };
  var isRequest = function(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  };
  var isChildProcess = function(stream) {
    return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
  };
  var eos = function(stream, opts, callback) {
    if (typeof opts === "function")
      return eos(stream, null, opts);
    if (!opts)
      opts = {};
    callback = once(callback || noop);
    var ws = stream._writableState;
    var rs = stream._readableState;
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var cancelled = false;
    var onlegacyfinish = function() {
      if (!stream.writable)
        onfinish();
    };
    var onfinish = function() {
      writable = false;
      if (!readable)
        callback.call(stream);
    };
    var onend = function() {
      readable = false;
      if (!writable)
        callback.call(stream);
    };
    var onexit = function(exitCode) {
      callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
    };
    var onerror = function(err) {
      callback.call(stream, err);
    };
    var onclose = function() {
      process.nextTick(onclosenexttick);
    };
    var onclosenexttick = function() {
      if (cancelled)
        return;
      if (readable && !(rs && (rs.ended && !rs.destroyed)))
        return callback.call(stream, new Error("premature close"));
      if (writable && !(ws && (ws.ended && !ws.destroyed)))
        return callback.call(stream, new Error("premature close"));
    };
    var onrequest = function() {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req)
        onrequest();
      else
        stream.on("request", onrequest);
    } else if (writable && !ws) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    if (isChildProcess(stream))
      stream.on("exit", onexit);
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false)
      stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
      cancelled = true;
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req)
        stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("exit", onexit);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  };
  module2.exports = eos;
});

// ../../node_modules/.pnpm/tar-stream@2.2.0/node_modules/tar-stream/pack.js
var require_pack2 = __commonJS((exports2, module2) => {
  var constants = require_fs_constants();
  var eos = require_end_of_stream2();
  var inherits = require_inherits();
  var alloc = Buffer.alloc;
  var Readable = require_readable2().Readable;
  var Writable = require_readable2().Writable;
  var StringDecoder = require("string_decoder").StringDecoder;
  var headers = require_headers();
  var DMODE = parseInt("755", 8);
  var FMODE = parseInt("644", 8);
  var END_OF_TAR = alloc(1024);
  var noop = function() {
  };
  var overflow = function(self2, size) {
    size &= 511;
    if (size)
      self2.push(END_OF_TAR.slice(0, 512 - size));
  };
  function modeToType(mode) {
    switch (mode & constants.S_IFMT) {
      case constants.S_IFBLK:
        return "block-device";
      case constants.S_IFCHR:
        return "character-device";
      case constants.S_IFDIR:
        return "directory";
      case constants.S_IFIFO:
        return "fifo";
      case constants.S_IFLNK:
        return "symlink";
    }
    return "file";
  }
  var Sink = function(to) {
    Writable.call(this);
    this.written = 0;
    this._to = to;
    this._destroyed = false;
  };
  inherits(Sink, Writable);
  Sink.prototype._write = function(data, enc, cb) {
    this.written += data.length;
    if (this._to.push(data))
      return cb();
    this._to._drain = cb;
  };
  Sink.prototype.destroy = function() {
    if (this._destroyed)
      return;
    this._destroyed = true;
    this.emit("close");
  };
  var LinkSink = function() {
    Writable.call(this);
    this.linkname = "";
    this._decoder = new StringDecoder("utf-8");
    this._destroyed = false;
  };
  inherits(LinkSink, Writable);
  LinkSink.prototype._write = function(data, enc, cb) {
    this.linkname += this._decoder.write(data);
    cb();
  };
  LinkSink.prototype.destroy = function() {
    if (this._destroyed)
      return;
    this._destroyed = true;
    this.emit("close");
  };
  var Void = function() {
    Writable.call(this);
    this._destroyed = false;
  };
  inherits(Void, Writable);
  Void.prototype._write = function(data, enc, cb) {
    cb(new Error("No body allowed for this entry"));
  };
  Void.prototype.destroy = function() {
    if (this._destroyed)
      return;
    this._destroyed = true;
    this.emit("close");
  };
  var Pack = function(opts) {
    if (!(this instanceof Pack))
      return new Pack(opts);
    Readable.call(this, opts);
    this._drain = noop;
    this._finalized = false;
    this._finalizing = false;
    this._destroyed = false;
    this._stream = null;
  };
  inherits(Pack, Readable);
  Pack.prototype.entry = function(header, buffer, callback) {
    if (this._stream)
      throw new Error("already piping an entry");
    if (this._finalized || this._destroyed)
      return;
    if (typeof buffer === "function") {
      callback = buffer;
      buffer = null;
    }
    if (!callback)
      callback = noop;
    var self2 = this;
    if (!header.size || header.type === "symlink")
      header.size = 0;
    if (!header.type)
      header.type = modeToType(header.mode);
    if (!header.mode)
      header.mode = header.type === "directory" ? DMODE : FMODE;
    if (!header.uid)
      header.uid = 0;
    if (!header.gid)
      header.gid = 0;
    if (!header.mtime)
      header.mtime = new Date();
    if (typeof buffer === "string")
      buffer = Buffer.from(buffer);
    if (Buffer.isBuffer(buffer)) {
      header.size = buffer.length;
      this._encode(header);
      var ok = this.push(buffer);
      overflow(self2, header.size);
      if (ok)
        process.nextTick(callback);
      else
        this._drain = callback;
      return new Void();
    }
    if (header.type === "symlink" && !header.linkname) {
      var linkSink = new LinkSink();
      eos(linkSink, function(err) {
        if (err) {
          self2.destroy();
          return callback(err);
        }
        header.linkname = linkSink.linkname;
        self2._encode(header);
        callback();
      });
      return linkSink;
    }
    this._encode(header);
    if (header.type !== "file" && header.type !== "contiguous-file") {
      process.nextTick(callback);
      return new Void();
    }
    var sink = new Sink(this);
    this._stream = sink;
    eos(sink, function(err) {
      self2._stream = null;
      if (err) {
        self2.destroy();
        return callback(err);
      }
      if (sink.written !== header.size) {
        self2.destroy();
        return callback(new Error("size mismatch"));
      }
      overflow(self2, header.size);
      if (self2._finalizing)
        self2.finalize();
      callback();
    });
    return sink;
  };
  Pack.prototype.finalize = function() {
    if (this._stream) {
      this._finalizing = true;
      return;
    }
    if (this._finalized)
      return;
    this._finalized = true;
    this.push(END_OF_TAR);
    this.push(null);
  };
  Pack.prototype.destroy = function(err) {
    if (this._destroyed)
      return;
    this._destroyed = true;
    if (err)
      this.emit("error", err);
    this.emit("close");
    if (this._stream && this._stream.destroy)
      this._stream.destroy();
  };
  Pack.prototype._encode = function(header) {
    if (!header.pax) {
      var buf = headers.encode(header);
      if (buf) {
        this.push(buf);
        return;
      }
    }
    this._encodePax(header);
  };
  Pack.prototype._encodePax = function(header) {
    var paxHeader = headers.encodePax({
      name: header.name,
      linkname: header.linkname,
      pax: header.pax
    });
    var newHeader = {
      name: "PaxHeader",
      mode: header.mode,
      uid: header.uid,
      gid: header.gid,
      size: paxHeader.length,
      mtime: header.mtime,
      type: "pax-header",
      linkname: header.linkname && "PaxHeader",
      uname: header.uname,
      gname: header.gname,
      devmajor: header.devmajor,
      devminor: header.devminor
    };
    this.push(headers.encode(newHeader));
    this.push(paxHeader);
    overflow(this, paxHeader.length);
    newHeader.size = header.size;
    newHeader.type = header.type;
    this.push(headers.encode(newHeader));
  };
  Pack.prototype._read = function(n) {
    var drain = this._drain;
    this._drain = noop;
    drain();
  };
  module2.exports = Pack;
});

// ../../node_modules/.pnpm/tar-stream@2.2.0/node_modules/tar-stream/index.js
var require_tar_stream = __commonJS((exports2) => {
  exports2.extract = require_extract2();
  exports2.pack = require_pack2();
});

// ../../node_modules/.pnpm/archiver@4.0.2/node_modules/archiver/lib/plugins/tar.js
var require_tar2 = __commonJS((exports2, module2) => {
  /**
   * TAR Format Plugin
   *
   * @module plugins/tar
   * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
   * @copyright (c) 2012-2014 Chris Talkington, contributors.
   */
  var zlib = require("zlib");
  var engine = require_tar_stream();
  var util2 = require_archiver_utils();
  var Tar = function(options) {
    if (!(this instanceof Tar)) {
      return new Tar(options);
    }
    options = this.options = util2.defaults(options, {
      gzip: false
    });
    if (typeof options.gzipOptions !== "object") {
      options.gzipOptions = {};
    }
    this.supports = {
      directory: true,
      symlink: true
    };
    this.engine = engine.pack(options);
    this.compressor = false;
    if (options.gzip) {
      this.compressor = zlib.createGzip(options.gzipOptions);
      this.compressor.on("error", this._onCompressorError.bind(this));
    }
  };
  Tar.prototype._onCompressorError = function(err) {
    this.engine.emit("error", err);
  };
  Tar.prototype.append = function(source, data, callback) {
    var self2 = this;
    data.mtime = data.date;
    function append(err, sourceBuffer) {
      if (err) {
        callback(err);
        return;
      }
      self2.engine.entry(data, sourceBuffer, function(err2) {
        callback(err2, data);
      });
    }
    if (data.sourceType === "buffer") {
      append(null, source);
    } else if (data.sourceType === "stream" && data.stats) {
      data.size = data.stats.size;
      var entry = self2.engine.entry(data, function(err) {
        callback(err, data);
      });
      source.pipe(entry);
    } else if (data.sourceType === "stream") {
      util2.collectStream(source, append);
    }
  };
  Tar.prototype.finalize = function() {
    this.engine.finalize();
  };
  Tar.prototype.on = function() {
    return this.engine.on.apply(this.engine, arguments);
  };
  Tar.prototype.pipe = function(destination, options) {
    if (this.compressor) {
      return this.engine.pipe.apply(this.engine, [this.compressor]).pipe(destination, options);
    } else {
      return this.engine.pipe.apply(this.engine, arguments);
    }
  };
  Tar.prototype.unpipe = function() {
    if (this.compressor) {
      return this.compressor.unpipe.apply(this.compressor, arguments);
    } else {
      return this.engine.unpipe.apply(this.engine, arguments);
    }
  };
  module2.exports = Tar;
});

// ../../node_modules/.pnpm/archiver@4.0.2/node_modules/archiver/lib/plugins/json.js
var require_json = __commonJS((exports2, module2) => {
  /**
   * JSON Format Plugin
   *
   * @module plugins/json
   * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
   * @copyright (c) 2012-2014 Chris Talkington, contributors.
   */
  var inherits = require("util").inherits;
  var Transform = require_readable2().Transform;
  var crc32 = require_buffer_crc32();
  var util2 = require_archiver_utils();
  var Json = function(options) {
    if (!(this instanceof Json)) {
      return new Json(options);
    }
    options = this.options = util2.defaults(options, {});
    Transform.call(this, options);
    this.supports = {
      directory: true,
      symlink: true
    };
    this.files = [];
  };
  inherits(Json, Transform);
  Json.prototype._transform = function(chunk, encoding, callback) {
    callback(null, chunk);
  };
  Json.prototype._writeStringified = function() {
    var fileString = JSON.stringify(this.files);
    this.write(fileString);
  };
  Json.prototype.append = function(source, data, callback) {
    var self2 = this;
    data.crc32 = 0;
    function onend(err, sourceBuffer) {
      if (err) {
        callback(err);
        return;
      }
      data.size = sourceBuffer.length || 0;
      data.crc32 = crc32.unsigned(sourceBuffer);
      self2.files.push(data);
      callback(null, data);
    }
    if (data.sourceType === "buffer") {
      onend(null, source);
    } else if (data.sourceType === "stream") {
      util2.collectStream(source, onend);
    }
  };
  Json.prototype.finalize = function() {
    this._writeStringified();
    this.end();
  };
  module2.exports = Json;
});

// ../../node_modules/.pnpm/archiver@4.0.2/node_modules/archiver/index.js
var require_archiver = __commonJS((exports2, module2) => {
  /**
   * Archiver Vending
   *
   * @ignore
   * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
   * @copyright (c) 2012-2014 Chris Talkington, contributors.
   */
  var Archiver = require_core5();
  var formats = {};
  var vending = function(format10, options) {
    return vending.create(format10, options);
  };
  vending.create = function(format10, options) {
    if (formats[format10]) {
      var instance = new Archiver(format10, options);
      instance.setFormat(format10);
      instance.setModule(new formats[format10](options));
      return instance;
    } else {
      throw new Error("create(" + format10 + "): format not registered");
    }
  };
  vending.registerFormat = function(format10, module3) {
    if (formats[format10]) {
      throw new Error("register(" + format10 + "): format already registered");
    }
    if (typeof module3 !== "function") {
      throw new Error("register(" + format10 + "): format module invalid");
    }
    if (typeof module3.prototype.append !== "function" || typeof module3.prototype.finalize !== "function") {
      throw new Error("register(" + format10 + "): format module missing methods");
    }
    formats[format10] = module3;
  };
  vending.registerFormat("zip", require_zip());
  vending.registerFormat("tar", require_tar2());
  vending.registerFormat("json", require_json());
  module2.exports = vending;
});

// ../../node_modules/.pnpm/tmp@0.2.1/node_modules/tmp/lib/tmp.js
var require_tmp = __commonJS((exports2, module2) => {
  /*!
   * Tmp
   *
   * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>
   *
   * MIT Licensed
   */
  var fs9 = require("fs");
  var os3 = require("os");
  var path10 = require("path");
  var crypto2 = require("crypto");
  var _c = {fs: fs9.constants, os: os3.constants};
  var rimraf = require_rimraf();
  var RANDOM_CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  var TEMPLATE_PATTERN = /XXXXXX/;
  var DEFAULT_TRIES = 3;
  var CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR);
  var IS_WIN32 = os3.platform() === "win32";
  var EBADF = _c.EBADF || _c.os.errno.EBADF;
  var ENOENT = _c.ENOENT || _c.os.errno.ENOENT;
  var DIR_MODE = 448;
  var FILE_MODE = 384;
  var EXIT = "exit";
  var _removeObjects = [];
  var FN_RMDIR_SYNC = fs9.rmdirSync.bind(fs9);
  var FN_RIMRAF_SYNC = rimraf.sync;
  var _gracefulCleanup = false;
  function tmpName(options, callback) {
    const args2 = _parseArguments(options, callback), opts = args2[0], cb = args2[1];
    try {
      _assertAndSanitizeOptions(opts);
    } catch (err) {
      return cb(err);
    }
    let tries = opts.tries;
    (function _getUniqueName() {
      try {
        const name = _generateTmpName(opts);
        fs9.stat(name, function(err) {
          if (!err) {
            if (tries-- > 0)
              return _getUniqueName();
            return cb(new Error("Could not get a unique tmp filename, max tries reached " + name));
          }
          cb(null, name);
        });
      } catch (err) {
        cb(err);
      }
    })();
  }
  function tmpNameSync(options) {
    const args2 = _parseArguments(options), opts = args2[0];
    _assertAndSanitizeOptions(opts);
    let tries = opts.tries;
    do {
      const name = _generateTmpName(opts);
      try {
        fs9.statSync(name);
      } catch (e) {
        return name;
      }
    } while (tries-- > 0);
    throw new Error("Could not get a unique tmp filename, max tries reached");
  }
  function file(options, callback) {
    const args2 = _parseArguments(options, callback), opts = args2[0], cb = args2[1];
    tmpName(opts, function _tmpNameCreated(err, name) {
      if (err)
        return cb(err);
      fs9.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err2, fd) {
        if (err2)
          return cb(err2);
        if (opts.discardDescriptor) {
          return fs9.close(fd, function _discardCallback(possibleErr) {
            return cb(possibleErr, name, void 0, _prepareTmpFileRemoveCallback(name, -1, opts, false));
          });
        } else {
          const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
          cb(null, name, fd, _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, false));
        }
      });
    });
  }
  function fileSync(options) {
    const args2 = _parseArguments(options), opts = args2[0];
    const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
    const name = tmpNameSync(opts);
    var fd = fs9.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);
    if (opts.discardDescriptor) {
      fs9.closeSync(fd);
      fd = void 0;
    }
    return {
      name,
      fd,
      removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, true)
    };
  }
  function dir(options, callback) {
    const args2 = _parseArguments(options, callback), opts = args2[0], cb = args2[1];
    tmpName(opts, function _tmpNameCreated(err, name) {
      if (err)
        return cb(err);
      fs9.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err2) {
        if (err2)
          return cb(err2);
        cb(null, name, _prepareTmpDirRemoveCallback(name, opts, false));
      });
    });
  }
  function dirSync(options) {
    const args2 = _parseArguments(options), opts = args2[0];
    const name = tmpNameSync(opts);
    fs9.mkdirSync(name, opts.mode || DIR_MODE);
    return {
      name,
      removeCallback: _prepareTmpDirRemoveCallback(name, opts, true)
    };
  }
  function _removeFileAsync(fdPath, next) {
    const _handler = function(err) {
      if (err && !_isENOENT(err)) {
        return next(err);
      }
      next();
    };
    if (0 <= fdPath[0])
      fs9.close(fdPath[0], function() {
        fs9.unlink(fdPath[1], _handler);
      });
    else
      fs9.unlink(fdPath[1], _handler);
  }
  function _removeFileSync(fdPath) {
    let rethrownException = null;
    try {
      if (0 <= fdPath[0])
        fs9.closeSync(fdPath[0]);
    } catch (e) {
      if (!_isEBADF(e) && !_isENOENT(e))
        throw e;
    } finally {
      try {
        fs9.unlinkSync(fdPath[1]);
      } catch (e) {
        if (!_isENOENT(e))
          rethrownException = e;
      }
    }
    if (rethrownException !== null) {
      throw rethrownException;
    }
  }
  function _prepareTmpFileRemoveCallback(name, fd, opts, sync2) {
    const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [fd, name], sync2);
    const removeCallback = _prepareRemoveCallback(_removeFileAsync, [fd, name], sync2, removeCallbackSync);
    if (!opts.keep)
      _removeObjects.unshift(removeCallbackSync);
    return sync2 ? removeCallbackSync : removeCallback;
  }
  function _prepareTmpDirRemoveCallback(name, opts, sync2) {
    const removeFunction = opts.unsafeCleanup ? rimraf : fs9.rmdir.bind(fs9);
    const removeFunctionSync = opts.unsafeCleanup ? FN_RIMRAF_SYNC : FN_RMDIR_SYNC;
    const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name, sync2);
    const removeCallback = _prepareRemoveCallback(removeFunction, name, sync2, removeCallbackSync);
    if (!opts.keep)
      _removeObjects.unshift(removeCallbackSync);
    return sync2 ? removeCallbackSync : removeCallback;
  }
  function _prepareRemoveCallback(removeFunction, fileOrDirName, sync2, cleanupCallbackSync) {
    let called = false;
    return function _cleanupCallback(next) {
      if (!called) {
        const toRemove = cleanupCallbackSync || _cleanupCallback;
        const index = _removeObjects.indexOf(toRemove);
        if (index >= 0)
          _removeObjects.splice(index, 1);
        called = true;
        if (sync2 || removeFunction === FN_RMDIR_SYNC || removeFunction === FN_RIMRAF_SYNC) {
          return removeFunction(fileOrDirName);
        } else {
          return removeFunction(fileOrDirName, next || function() {
          });
        }
      }
    };
  }
  function _garbageCollector() {
    if (!_gracefulCleanup)
      return;
    while (_removeObjects.length) {
      try {
        _removeObjects[0]();
      } catch (e) {
      }
    }
  }
  function _randomChars(howMany) {
    let value = [], rnd = null;
    try {
      rnd = crypto2.randomBytes(howMany);
    } catch (e) {
      rnd = crypto2.pseudoRandomBytes(howMany);
    }
    for (var i = 0; i < howMany; i++) {
      value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);
    }
    return value.join("");
  }
  function _isBlank(s2) {
    return s2 === null || _isUndefined(s2) || !s2.trim();
  }
  function _isUndefined(obj) {
    return typeof obj === "undefined";
  }
  function _parseArguments(options, callback) {
    if (typeof options === "function") {
      return [{}, options];
    }
    if (_isUndefined(options)) {
      return [{}, callback];
    }
    const actualOptions = {};
    for (const key of Object.getOwnPropertyNames(options)) {
      actualOptions[key] = options[key];
    }
    return [actualOptions, callback];
  }
  function _generateTmpName(opts) {
    const tmpDir = opts.tmpdir;
    if (!_isUndefined(opts.name))
      return path10.join(tmpDir, opts.dir, opts.name);
    if (!_isUndefined(opts.template))
      return path10.join(tmpDir, opts.dir, opts.template).replace(TEMPLATE_PATTERN, _randomChars(6));
    const name = [
      opts.prefix ? opts.prefix : "tmp",
      "-",
      process.pid,
      "-",
      _randomChars(12),
      opts.postfix ? "-" + opts.postfix : ""
    ].join("");
    return path10.join(tmpDir, opts.dir, name);
  }
  function _assertAndSanitizeOptions(options) {
    options.tmpdir = _getTmpDir(options);
    const tmpDir = options.tmpdir;
    if (!_isUndefined(options.name))
      _assertIsRelative(options.name, "name", tmpDir);
    if (!_isUndefined(options.dir))
      _assertIsRelative(options.dir, "dir", tmpDir);
    if (!_isUndefined(options.template)) {
      _assertIsRelative(options.template, "template", tmpDir);
      if (!options.template.match(TEMPLATE_PATTERN))
        throw new Error(`Invalid template, found "${options.template}".`);
    }
    if (!_isUndefined(options.tries) && isNaN(options.tries) || options.tries < 0)
      throw new Error(`Invalid tries, found "${options.tries}".`);
    options.tries = _isUndefined(options.name) ? options.tries || DEFAULT_TRIES : 1;
    options.keep = !!options.keep;
    options.detachDescriptor = !!options.detachDescriptor;
    options.discardDescriptor = !!options.discardDescriptor;
    options.unsafeCleanup = !!options.unsafeCleanup;
    options.dir = _isUndefined(options.dir) ? "" : path10.relative(tmpDir, _resolvePath(options.dir, tmpDir));
    options.template = _isUndefined(options.template) ? void 0 : path10.relative(tmpDir, _resolvePath(options.template, tmpDir));
    options.template = _isBlank(options.template) ? void 0 : path10.relative(options.dir, options.template);
    options.name = _isUndefined(options.name) ? void 0 : _sanitizeName(options.name);
    options.prefix = _isUndefined(options.prefix) ? "" : options.prefix;
    options.postfix = _isUndefined(options.postfix) ? "" : options.postfix;
  }
  function _resolvePath(name, tmpDir) {
    const sanitizedName = _sanitizeName(name);
    if (sanitizedName.startsWith(tmpDir)) {
      return path10.resolve(sanitizedName);
    } else {
      return path10.resolve(path10.join(tmpDir, sanitizedName));
    }
  }
  function _sanitizeName(name) {
    if (_isBlank(name)) {
      return name;
    }
    return name.replace(/["']/g, "");
  }
  function _assertIsRelative(name, option, tmpDir) {
    if (option === "name") {
      if (path10.isAbsolute(name))
        throw new Error(`${option} option must not contain an absolute path, found "${name}".`);
      let basename = path10.basename(name);
      if (basename === ".." || basename === "." || basename !== name)
        throw new Error(`${option} option must not contain a path, found "${name}".`);
    } else {
      if (path10.isAbsolute(name) && !name.startsWith(tmpDir)) {
        throw new Error(`${option} option must be relative to "${tmpDir}", found "${name}".`);
      }
      let resolvedPath = _resolvePath(name, tmpDir);
      if (!resolvedPath.startsWith(tmpDir))
        throw new Error(`${option} option must be relative to "${tmpDir}", found "${resolvedPath}".`);
    }
  }
  function _isEBADF(error) {
    return _isExpectedError(error, -EBADF, "EBADF");
  }
  function _isENOENT(error) {
    return _isExpectedError(error, -ENOENT, "ENOENT");
  }
  function _isExpectedError(error, errno, code) {
    return IS_WIN32 ? error.code === code : error.code === code && error.errno === errno;
  }
  function setGracefulCleanup() {
    _gracefulCleanup = true;
  }
  function _getTmpDir(options) {
    return path10.resolve(_sanitizeName(options && options.tmpdir || os3.tmpdir()));
  }
  process.addListener(EXIT, _garbageCollector);
  Object.defineProperty(module2.exports, "tmpdir", {
    enumerable: true,
    configurable: false,
    get: function() {
      return _getTmpDir();
    }
  });
  module2.exports.dir = dir;
  module2.exports.dirSync = dirSync;
  module2.exports.file = file;
  module2.exports.fileSync = fileSync;
  module2.exports.tmpName = tmpName;
  module2.exports.tmpNameSync = tmpNameSync;
  module2.exports.setGracefulCleanup = setGracefulCleanup;
});

// ../../node_modules/.pnpm/ci-info@3.1.1/node_modules/ci-info/vendors.json
var require_vendors2 = __commonJS((exports2, module2) => {
  module2.exports = [
    {
      name: "AppVeyor",
      constant: "APPVEYOR",
      env: "APPVEYOR",
      pr: "APPVEYOR_PULL_REQUEST_NUMBER"
    },
    {
      name: "Azure Pipelines",
      constant: "AZURE_PIPELINES",
      env: "SYSTEM_TEAMFOUNDATIONCOLLECTIONURI",
      pr: "SYSTEM_PULLREQUEST_PULLREQUESTID"
    },
    {
      name: "Bamboo",
      constant: "BAMBOO",
      env: "bamboo_planKey"
    },
    {
      name: "Bitbucket Pipelines",
      constant: "BITBUCKET",
      env: "BITBUCKET_COMMIT",
      pr: "BITBUCKET_PR_ID"
    },
    {
      name: "Bitrise",
      constant: "BITRISE",
      env: "BITRISE_IO",
      pr: "BITRISE_PULL_REQUEST"
    },
    {
      name: "Buddy",
      constant: "BUDDY",
      env: "BUDDY_WORKSPACE_ID",
      pr: "BUDDY_EXECUTION_PULL_REQUEST_ID"
    },
    {
      name: "Buildkite",
      constant: "BUILDKITE",
      env: "BUILDKITE",
      pr: {env: "BUILDKITE_PULL_REQUEST", ne: "false"}
    },
    {
      name: "CircleCI",
      constant: "CIRCLE",
      env: "CIRCLECI",
      pr: "CIRCLE_PULL_REQUEST"
    },
    {
      name: "Cirrus CI",
      constant: "CIRRUS",
      env: "CIRRUS_CI",
      pr: "CIRRUS_PR"
    },
    {
      name: "AWS CodeBuild",
      constant: "CODEBUILD",
      env: "CODEBUILD_BUILD_ARN"
    },
    {
      name: "Codeship",
      constant: "CODESHIP",
      env: {CI_NAME: "codeship"}
    },
    {
      name: "Drone",
      constant: "DRONE",
      env: "DRONE",
      pr: {DRONE_BUILD_EVENT: "pull_request"}
    },
    {
      name: "dsari",
      constant: "DSARI",
      env: "DSARI"
    },
    {
      name: "GitHub Actions",
      constant: "GITHUB_ACTIONS",
      env: "GITHUB_ACTIONS",
      pr: {GITHUB_EVENT_NAME: "pull_request"}
    },
    {
      name: "GitLab CI",
      constant: "GITLAB",
      env: "GITLAB_CI",
      pr: "CI_MERGE_REQUEST_ID"
    },
    {
      name: "GoCD",
      constant: "GOCD",
      env: "GO_PIPELINE_LABEL"
    },
    {
      name: "Hudson",
      constant: "HUDSON",
      env: "HUDSON_URL"
    },
    {
      name: "Jenkins",
      constant: "JENKINS",
      env: ["JENKINS_URL", "BUILD_ID"],
      pr: {any: ["ghprbPullId", "CHANGE_ID"]}
    },
    {
      name: "Magnum CI",
      constant: "MAGNUM",
      env: "MAGNUM"
    },
    {
      name: "Netlify CI",
      constant: "NETLIFY",
      env: "NETLIFY",
      pr: {env: "PULL_REQUEST", ne: "false"}
    },
    {
      name: "Nevercode",
      constant: "NEVERCODE",
      env: "NEVERCODE",
      pr: {env: "NEVERCODE_PULL_REQUEST", ne: "false"}
    },
    {
      name: "Render",
      constant: "RENDER",
      env: "RENDER",
      pr: {IS_PULL_REQUEST: "true"}
    },
    {
      name: "Sail CI",
      constant: "SAIL",
      env: "SAILCI",
      pr: "SAIL_PULL_REQUEST_NUMBER"
    },
    {
      name: "Semaphore",
      constant: "SEMAPHORE",
      env: "SEMAPHORE",
      pr: "PULL_REQUEST_NUMBER"
    },
    {
      name: "Screwdriver",
      constant: "SCREWDRIVER",
      env: "SCREWDRIVER",
      pr: {env: "SD_PULL_REQUEST", ne: "false"}
    },
    {
      name: "Shippable",
      constant: "SHIPPABLE",
      env: "SHIPPABLE",
      pr: {IS_PULL_REQUEST: "true"}
    },
    {
      name: "Solano CI",
      constant: "SOLANO",
      env: "TDDIUM",
      pr: "TDDIUM_PR_ID"
    },
    {
      name: "Strider CD",
      constant: "STRIDER",
      env: "STRIDER"
    },
    {
      name: "TaskCluster",
      constant: "TASKCLUSTER",
      env: ["TASK_ID", "RUN_ID"]
    },
    {
      name: "TeamCity",
      constant: "TEAMCITY",
      env: "TEAMCITY_VERSION"
    },
    {
      name: "Travis CI",
      constant: "TRAVIS",
      env: "TRAVIS",
      pr: {env: "TRAVIS_PULL_REQUEST", ne: "false"}
    },
    {
      name: "Vercel",
      constant: "VERCEL",
      env: "NOW_BUILDER"
    },
    {
      name: "Visual Studio App Center",
      constant: "APPCENTER",
      env: "APPCENTER_BUILD_ID"
    }
  ];
});

// ../../node_modules/.pnpm/ci-info@3.1.1/node_modules/ci-info/index.js
var require_ci_info2 = __commonJS((exports2) => {
  "use strict";
  var vendors = require_vendors2();
  var env2 = process.env;
  Object.defineProperty(exports2, "_vendors", {
    value: vendors.map(function(v) {
      return v.constant;
    })
  });
  exports2.name = null;
  exports2.isPR = null;
  vendors.forEach(function(vendor) {
    const envs = Array.isArray(vendor.env) ? vendor.env : [vendor.env];
    const isCI = envs.every(function(obj) {
      return checkEnv(obj);
    });
    exports2[vendor.constant] = isCI;
    if (isCI) {
      exports2.name = vendor.name;
      switch (typeof vendor.pr) {
        case "string":
          exports2.isPR = !!env2[vendor.pr];
          break;
        case "object":
          if ("env" in vendor.pr) {
            exports2.isPR = vendor.pr.env in env2 && env2[vendor.pr.env] !== vendor.pr.ne;
          } else if ("any" in vendor.pr) {
            exports2.isPR = vendor.pr.any.some(function(key) {
              return !!env2[key];
            });
          } else {
            exports2.isPR = checkEnv(vendor.pr);
          }
          break;
        default:
          exports2.isPR = null;
      }
    }
  });
  exports2.isCI = !!(env2.CI || env2.CONTINUOUS_INTEGRATION || env2.BUILD_NUMBER || env2.RUN_ID || exports2.name || false);
  function checkEnv(obj) {
    if (typeof obj === "string")
      return !!env2[obj];
    return Object.keys(obj).every(function(k) {
      return env2[k] === obj[k];
    });
  }
});

// ../../node_modules/.pnpm/checkpoint-client@1.1.20/node_modules/checkpoint-client/dist/index.js
var require_dist11 = __commonJS((exports, module) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  var fs = require("fs");
  var path = require("path");
  var os = require("os");
  var util = require("util");
  var crypto = require("crypto");
  var child_process = require("child_process");
  function _interopDefaultLegacy(e) {
    return e && typeof e === "object" && "default" in e ? e : {default: e};
  }
  var fs__default = /* @__PURE__ */ _interopDefaultLegacy(fs);
  var path__default = /* @__PURE__ */ _interopDefaultLegacy(path);
  var os__default = /* @__PURE__ */ _interopDefaultLegacy(os);
  var util__default = /* @__PURE__ */ _interopDefaultLegacy(util);
  var crypto__default = /* @__PURE__ */ _interopDefaultLegacy(crypto);
  var {open, write, close, rename, fsync, unlink} = fs__default["default"];
  var {join, dirname} = path__default["default"];
  var counter = 0;
  function cleanup(dest, err, cb) {
    unlink(dest, function() {
      cb(err);
    });
  }
  function closeAndCleanup(fd, dest, err, cb) {
    close(fd, cleanup.bind(null, dest, err, cb));
  }
  function writeLoop(fd, content, contentLength, offset, cb) {
    write(fd, content, offset, function(err, bytesWritten) {
      if (err) {
        cb(err);
        return;
      }
      return bytesWritten < contentLength - offset ? writeLoop(fd, content, contentLength, offset + bytesWritten, cb) : cb(null);
    });
  }
  function openLoop(dest, cb) {
    open(dest, "w", function(err, fd) {
      if (err) {
        return err.code === "EMFILE" ? openLoop(dest, cb) : cb(err);
      }
      cb(null, fd);
    });
  }
  function writeAtomic(path10, content, cb) {
    const tmp = join(dirname(path10), "." + process.pid + "." + counter++);
    openLoop(tmp, function(err, fd) {
      if (err) {
        cb(err);
        return;
      }
      const contentLength = Buffer.byteLength(content);
      writeLoop(fd, content, contentLength, 0, function(err2) {
        if (err2) {
          closeAndCleanup(fd, tmp, err2, cb);
          return;
        }
        fsync(fd, function(err3) {
          if (err3) {
            closeAndCleanup(fd, tmp, err3, cb);
            return;
          }
          close(fd, function(err4) {
            if (err4) {
              cleanup(tmp, err4, cb);
              return;
            }
            rename(tmp, path10, (err5) => {
              if (err5) {
                cleanup(tmp, err5, cb);
                return;
              }
              cb(null);
            });
          });
        });
      });
      content = null;
    });
  }
  var fastWriteAtomic = writeAtomic;
  var rnds8Pool = new Uint8Array(256);
  var poolPtr = rnds8Pool.length;
  function rng() {
    if (poolPtr > rnds8Pool.length - 16) {
      crypto__default["default"].randomFillSync(rnds8Pool);
      poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
  }
  var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  function validate(uuid) {
    return typeof uuid === "string" && REGEX.test(uuid);
  }
  var byteToHex = [];
  for (let i = 0; i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).substr(1));
  }
  function stringify(arr, offset = 0) {
    const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    if (!validate(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  }
  function v4(options, buf, offset) {
    options = options || {};
    const rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return stringify(rnds);
  }
  var homedir = os__default["default"].homedir();
  var tmpdir = os__default["default"].tmpdir();
  var {env} = process;
  var macos = (name) => {
    const library = path__default["default"].join(homedir, "Library");
    return {
      data: path__default["default"].join(library, "Application Support", name),
      config: path__default["default"].join(library, "Preferences", name),
      cache: path__default["default"].join(library, "Caches", name),
      log: path__default["default"].join(library, "Logs", name),
      temp: path__default["default"].join(tmpdir, name)
    };
  };
  var windows = (name) => {
    const appData = env.APPDATA || path__default["default"].join(homedir, "AppData", "Roaming");
    const localAppData = env.LOCALAPPDATA || path__default["default"].join(homedir, "AppData", "Local");
    return {
      data: path__default["default"].join(localAppData, name, "Data"),
      config: path__default["default"].join(appData, name, "Config"),
      cache: path__default["default"].join(localAppData, name, "Cache"),
      log: path__default["default"].join(localAppData, name, "Log"),
      temp: path__default["default"].join(tmpdir, name)
    };
  };
  var linux = (name) => {
    const username = path__default["default"].basename(homedir);
    return {
      data: path__default["default"].join(env.XDG_DATA_HOME || path__default["default"].join(homedir, ".local", "share"), name),
      config: path__default["default"].join(env.XDG_CONFIG_HOME || path__default["default"].join(homedir, ".config"), name),
      cache: path__default["default"].join(env.XDG_CACHE_HOME || path__default["default"].join(homedir, ".cache"), name),
      log: path__default["default"].join(env.XDG_STATE_HOME || path__default["default"].join(homedir, ".local", "state"), name),
      temp: path__default["default"].join(tmpdir, username, name)
    };
  };
  var envPaths = (name, options) => {
    if (typeof name !== "string") {
      throw new TypeError(`Expected string, got ${typeof name}`);
    }
    options = Object.assign({suffix: "nodejs"}, options);
    if (options.suffix) {
      name += `-${options.suffix}`;
    }
    if (process.platform === "darwin") {
      return macos(name);
    }
    if (process.platform === "win32") {
      return windows(name);
    }
    return linux(name);
  };
  var envPaths_1 = envPaths;
  var _default = envPaths;
  envPaths_1.default = _default;
  function createCommonjsModule(fn) {
    var module2 = {exports: {}};
    return fn(module2, module2.exports), module2.exports;
  }
  var semver = createCommonjsModule(function(module2, exports2) {
    exports2 = module2.exports = SemVer;
    var debug3;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug3 = function() {
        var args2 = Array.prototype.slice.call(arguments, 0);
        args2.unshift("SEMVER");
        console.log.apply(console, args2);
      };
    } else {
      debug3 = function() {
      };
    }
    exports2.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var re = exports2.re = [];
    var src = exports2.src = [];
    var t = exports2.tokens = {};
    var R = 0;
    function tok(n) {
      t[n] = R++;
    }
    tok("NUMERICIDENTIFIER");
    src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    tok("NUMERICIDENTIFIERLOOSE");
    src[t.NUMERICIDENTIFIERLOOSE] = "[0-9]+";
    tok("NONNUMERICIDENTIFIER");
    src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
    tok("MAINVERSION");
    src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")";
    tok("MAINVERSIONLOOSE");
    src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")";
    tok("PRERELEASEIDENTIFIER");
    src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASEIDENTIFIERLOOSE");
    src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASE");
    src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))";
    tok("PRERELEASELOOSE");
    src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))";
    tok("BUILDIDENTIFIER");
    src[t.BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
    tok("BUILD");
    src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))";
    tok("FULL");
    tok("FULLPLAIN");
    src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?";
    src[t.FULL] = "^" + src[t.FULLPLAIN] + "$";
    tok("LOOSEPLAIN");
    src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?";
    tok("LOOSE");
    src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$";
    tok("GTLT");
    src[t.GTLT] = "((?:<|>)?=?)";
    tok("XRANGEIDENTIFIERLOOSE");
    src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    tok("XRANGEIDENTIFIER");
    src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*";
    tok("XRANGEPLAIN");
    src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?)?)?";
    tok("XRANGEPLAINLOOSE");
    src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?)?)?";
    tok("XRANGE");
    src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$";
    tok("XRANGELOOSE");
    src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$";
    tok("COERCE");
    src[t.COERCE] = "(^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    tok("COERCERTL");
    re[t.COERCERTL] = new RegExp(src[t.COERCE], "g");
    tok("LONETILDE");
    src[t.LONETILDE] = "(?:~>?)";
    tok("TILDETRIM");
    src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+";
    re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
    var tildeTrimReplace = "$1~";
    tok("TILDE");
    src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$";
    tok("TILDELOOSE");
    src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$";
    tok("LONECARET");
    src[t.LONECARET] = "(?:\\^)";
    tok("CARETTRIM");
    src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+";
    re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
    var caretTrimReplace = "$1^";
    tok("CARET");
    src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$";
    tok("CARETLOOSE");
    src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$";
    tok("COMPARATORLOOSE");
    src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$";
    tok("COMPARATOR");
    src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$";
    tok("COMPARATORTRIM");
    src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")";
    re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
    var comparatorTrimReplace = "$1$2$3";
    tok("HYPHENRANGE");
    src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")\\s+-\\s+(" + src[t.XRANGEPLAIN] + ")\\s*$";
    tok("HYPHENRANGELOOSE");
    src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[t.XRANGEPLAINLOOSE] + ")\\s*$";
    tok("STAR");
    src[t.STAR] = "(<|>)?=?\\s*\\*";
    for (var i = 0; i < R; i++) {
      debug3(i, src[i]);
      if (!re[i]) {
        re[i] = new RegExp(src[i]);
      }
    }
    exports2.parse = parse2;
    function parse2(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      if (version.length > MAX_LENGTH) {
        return null;
      }
      var r = options.loose ? re[t.LOOSE] : re[t.FULL];
      if (!r.test(version)) {
        return null;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        return null;
      }
    }
    exports2.valid = valid;
    function valid(version, options) {
      var v = parse2(version, options);
      return v ? v.version : null;
    }
    exports2.clean = clean;
    function clean(version, options) {
      var s2 = parse2(version.trim().replace(/^[=v]+/, ""), options);
      return s2 ? s2.version : null;
    }
    exports2.SemVer = SemVer;
    function SemVer(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        if (version.loose === options.loose) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError("Invalid Version: " + version);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version, options);
      }
      debug3("SemVer", version, options);
      this.options = options;
      this.loose = !!options.loose;
      var m2 = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
      if (!m2) {
        throw new TypeError("Invalid Version: " + version);
      }
      this.raw = version;
      this.major = +m2[1];
      this.minor = +m2[2];
      this.patch = +m2[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m2[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m2[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m2[5] ? m2[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug3("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i2 = 0;
      do {
        var a = this.prerelease[i2];
        var b = other.prerelease[i2];
        debug3("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.compareBuild = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      var i2 = 0;
      do {
        var a = this.build[i2];
        var b = other.build[i2];
        debug3("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports2.inc = inc;
    function inc(version, release, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports2.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse2(version1);
        var v2 = parse2(version2);
        var prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports2.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports2.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports2.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports2.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports2.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports2.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    exports2.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    exports2.compareBuild = compareBuild;
    function compareBuild(a, b, loose) {
      var versionA = new SemVer(a, loose);
      var versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    }
    exports2.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports2.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.compareBuild(a, b, loose);
      });
    }
    exports2.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.compareBuild(b, a, loose);
      });
    }
    exports2.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports2.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports2.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports2.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports2.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports2.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports2.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports2.Comparator = Comparator;
    function Comparator(comp, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }
      debug3("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug3("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      var m2 = comp.match(r);
      if (!m2) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m2[1] !== void 0 ? m2[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m2[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m2[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version) {
      debug3("Comparator.test", version, this.options.loose);
      if (this.semver === ANY || version === ANY) {
        return true;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        rangeTmp = new Range(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        rangeTmp = new Range(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports2.Range = Range;
    function Range(range, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        return new Range(range.value, options);
      }
      if (!(this instanceof Range)) {
        return new Range(range, options);
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + range);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      range = range.trim();
      var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug3("hyphen replace", range);
      range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
      debug3("comparator trim", range, re[t.COMPARATORTRIM]);
      range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
      range = range.replace(re[t.CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(" ");
      var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      var set = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };
    Range.prototype.intersects = function(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
          return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };
    function isSatisfiable(comparators, options) {
      var result = true;
      var remainingComparators = comparators.slice();
      var testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every(function(otherComparator) {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    }
    exports2.toComparators = toComparators;
    function toComparators(range, options) {
      return new Range(range, options).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options) {
      debug3("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug3("caret", comp);
      comp = replaceTildes(comp, options);
      debug3("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug3("xrange", comp);
      comp = replaceStars(comp, options);
      debug3("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options);
      }).join(" ");
    }
    function replaceTilde(comp, options) {
      var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, function(_2, M, m2, p, pr) {
        debug3("tilde", comp, _2, M, m2, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m2)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret = ">=" + M + "." + m2 + ".0 <" + M + "." + (+m2 + 1) + ".0";
        } else if (pr) {
          debug3("replaceTilde pr", pr);
          ret = ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + M + "." + (+m2 + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m2 + "." + p + " <" + M + "." + (+m2 + 1) + ".0";
        }
        debug3("tilde return", ret);
        return ret;
      });
    }
    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options);
      }).join(" ");
    }
    function replaceCaret(comp, options) {
      debug3("caret", comp, options);
      var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      return comp.replace(r, function(_2, M, m2, p, pr) {
        debug3("caret", comp, _2, M, m2, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m2)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret = ">=" + M + "." + m2 + ".0 <" + M + "." + (+m2 + 1) + ".0";
          } else {
            ret = ">=" + M + "." + m2 + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug3("replaceCaret pr", pr);
          if (M === "0") {
            if (m2 === "0") {
              ret = ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + M + "." + m2 + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + M + "." + (+m2 + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug3("no pr");
          if (M === "0") {
            if (m2 === "0") {
              ret = ">=" + M + "." + m2 + "." + p + " <" + M + "." + m2 + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m2 + "." + p + " <" + M + "." + (+m2 + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m2 + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug3("caret return", ret);
        return ret;
      });
    }
    function replaceXRanges(comp, options) {
      debug3("replaceXRanges", comp, options);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options);
      }).join(" ");
    }
    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m2, p, pr) {
        debug3("xRange", comp, ret, gtlt, M, m2, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m2);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m2 = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m2 = 0;
              p = 0;
            } else {
              m2 = +m2 + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m2 = +m2 + 1;
            }
          }
          ret = gtlt + M + "." + m2 + "." + p + pr;
        } else if (xm) {
          ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr;
        } else if (xp) {
          ret = ">=" + M + "." + m2 + ".0" + pr + " <" + M + "." + (+m2 + 1) + ".0" + pr;
        }
        debug3("xRange return", ret);
        return ret;
      });
    }
    function replaceStars(comp, options) {
      debug3("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range.prototype.test = function(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      for (var i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set, version, options) {
      for (var i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (i2 = 0; i2 < set.length; i2++) {
          debug3(set[i2].semver);
          if (set[i2].semver === ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            var allowed = set[i2].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports2.satisfies = satisfies;
    function satisfies(version, range, options) {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    }
    exports2.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    }
    exports2.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options) {
      var min = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    }
    exports2.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }
    exports2.validRange = validRange;
    function validRange(range, options) {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports2.ltr = ltr;
    function ltr(version, range, options) {
      return outside(version, range, "<", options);
    }
    exports2.gtr = gtr;
    function gtr(version, range, options) {
      return outside(version, range, ">", options);
    }
    exports2.outside = outside;
    function outside(version, range, hilo, options) {
      version = new SemVer(version, options);
      range = new Range(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports2.prerelease = prerelease;
    function prerelease(version, options) {
      var parsed = parse2(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports2.intersects = intersects;
    function intersects(r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    }
    exports2.coerce = coerce;
    function coerce(version, options) {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      var match = null;
      if (!options.rtl) {
        match = version.match(re[t.COERCE]);
      } else {
        var next;
        while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        re[t.COERCERTL].lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      return parse2(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options);
    }
  });
  var {promisify} = util__default["default"];
  var useNativeRecursiveOption = semver.satisfies(process.version, ">=10.12.0");
  var checkPath = (pth) => {
    if (process.platform === "win32") {
      const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path__default["default"].parse(pth).root, ""));
      if (pathHasInvalidWinCharacters) {
        const error = new Error(`Path contains invalid characters: ${pth}`);
        error.code = "EINVAL";
        throw error;
      }
    }
  };
  var processOptions = (options) => {
    const defaults = {
      mode: 511,
      fs: fs__default["default"]
    };
    return {
      ...defaults,
      ...options
    };
  };
  var permissionError = (pth) => {
    const error = new Error(`operation not permitted, mkdir '${pth}'`);
    error.code = "EPERM";
    error.errno = -4048;
    error.path = pth;
    error.syscall = "mkdir";
    return error;
  };
  var makeDir = async (input, options) => {
    checkPath(input);
    options = processOptions(options);
    const mkdir2 = promisify(options.fs.mkdir);
    const stat = promisify(options.fs.stat);
    if (useNativeRecursiveOption && options.fs.mkdir === fs__default["default"].mkdir) {
      const pth = path__default["default"].resolve(input);
      await mkdir2(pth, {
        mode: options.mode,
        recursive: true
      });
      return pth;
    }
    const make = async (pth) => {
      try {
        await mkdir2(pth, options.mode);
        return pth;
      } catch (error) {
        if (error.code === "EPERM") {
          throw error;
        }
        if (error.code === "ENOENT") {
          if (path__default["default"].dirname(pth) === pth) {
            throw permissionError(pth);
          }
          if (error.message.includes("null bytes")) {
            throw error;
          }
          await make(path__default["default"].dirname(pth));
          return make(pth);
        }
        try {
          const stats = await stat(pth);
          if (!stats.isDirectory()) {
            throw new Error("The path is not a directory");
          }
        } catch (_2) {
          throw error;
        }
        return pth;
      }
    };
    return make(path__default["default"].resolve(input));
  };
  var makeDir_1 = makeDir;
  var sync = (input, options) => {
    checkPath(input);
    options = processOptions(options);
    if (useNativeRecursiveOption && options.fs.mkdirSync === fs__default["default"].mkdirSync) {
      const pth = path__default["default"].resolve(input);
      fs__default["default"].mkdirSync(pth, {
        mode: options.mode,
        recursive: true
      });
      return pth;
    }
    const make = (pth) => {
      try {
        options.fs.mkdirSync(pth, options.mode);
      } catch (error) {
        if (error.code === "EPERM") {
          throw error;
        }
        if (error.code === "ENOENT") {
          if (path__default["default"].dirname(pth) === pth) {
            throw permissionError(pth);
          }
          if (error.message.includes("null bytes")) {
            throw error;
          }
          make(path__default["default"].dirname(pth));
          return make(pth);
        }
        try {
          if (!options.fs.statSync(pth).isDirectory()) {
            throw new Error("The path is not a directory");
          }
        } catch (_2) {
          throw error;
        }
      }
      return pth;
    };
    return make(path__default["default"].resolve(input));
  };
  makeDir_1.sync = sync;
  var exists = util.promisify(fs__default["default"].exists);
  var readFile = util.promisify(fs__default["default"].readFile);
  var writeFile = util.promisify(fastWriteAtomic);
  var PRISMA_SIGNATURE = "signature";
  var PRISMA_CACHE_FILE = "prisma";
  async function getSignature(signatureFile, cacheFile) {
    const dirs = envPaths_1(`checkpoint`);
    cacheFile = cacheFile || path__default["default"].join(dirs.cache, PRISMA_CACHE_FILE);
    signatureFile = signatureFile || path__default["default"].join(dirs.cache, PRISMA_SIGNATURE);
    if (await exists(signatureFile)) {
      const signature = await readSignature(signatureFile);
      if (signature) {
        return signature;
      }
    }
    if (await exists(cacheFile)) {
      const signature = await readSignature(cacheFile);
      if (signature) {
        await createSignatureFile(signatureFile, signature);
        return signature;
      }
    }
    return await createSignatureFile(signatureFile);
  }
  function isSignatureValid(signature) {
    return typeof signature === "string" && signature.length === 36;
  }
  async function readSignature(file) {
    try {
      const data = await readFile(file, "utf8");
      const {signature} = JSON.parse(data);
      if (isSignatureValid(signature)) {
        return signature;
      }
      return "";
    } catch (err) {
      return "";
    }
  }
  async function createSignatureFile(signatureFile, signature) {
    const signatureState = {
      signature: signature || v4()
    };
    await makeDir_1(path__default["default"].dirname(signatureFile));
    await writeFile(signatureFile, JSON.stringify(signatureState, null, "  "));
    return signatureState.signature;
  }
  var readdir = util__default["default"].promisify(fs__default["default"].readdir);
  var readFile$1 = util__default["default"].promisify(fs__default["default"].readFile);
  var mkdir = util__default["default"].promisify(fs__default["default"].mkdir);
  async function getInfo() {
    const cachePath = envPaths_1("checkpoint").cache;
    if (!fs__default["default"].existsSync(cachePath)) {
      await mkdir(cachePath, {recursive: true});
    }
    const dir = await readdir(cachePath);
    const cacheItems = [];
    for (const item of dir) {
      if (!item.includes("-")) {
        continue;
      }
      try {
        const jsonData = JSON.parse(await readFile$1(path__default["default"].join(cachePath, item), {encoding: "utf-8"}));
        if (jsonData.output && !jsonData.output.cli_path_hash) {
          jsonData.output.cli_path_hash = item.split("-")[1];
        }
        cacheItems.push(jsonData);
      } catch (e) {
        console.error(e);
      }
    }
    return {
      signature: await getSignature(),
      cachePath,
      cacheItems
    };
  }
  var writeFile$1 = util__default["default"].promisify(fastWriteAtomic);
  var readFile$2 = util__default["default"].promisify(fs__default["default"].readFile);
  var unlink$1 = util__default["default"].promisify(fs__default["default"].unlink);
  var defaultSchema = {
    last_reminder: 0,
    cached_at: 0,
    version: "",
    cli_path: "",
    output: {
      client_event_id: "",
      previous_client_event_id: "",
      product: "",
      cli_path_hash: "",
      local_timestamp: "",
      previous_version: "",
      current_version: "",
      current_release_date: 0,
      current_download_url: "",
      current_changelog_url: "",
      package: "",
      release_tag: "",
      install_command: "",
      project_website: "",
      outdated: false,
      alerts: []
    }
  };
  var Config = class {
    static async new(state, schema = defaultSchema) {
      await makeDir_1(path__default["default"].dirname(state.cache_file));
      return new Config(state, schema);
    }
    constructor(state, defaultSchema3) {
      this.state = state;
      this.defaultSchema = defaultSchema3;
    }
    async checkCache(newState) {
      const now = newState.now();
      const cache = await this.all();
      if (!cache) {
        return {cache: void 0, stale: true};
      }
      if (newState.version !== cache.version) {
        return {cache, stale: true};
      }
      if (now - cache.cached_at > newState.cache_duration) {
        return {cache, stale: true};
      }
      return {cache, stale: false};
    }
    async set(update) {
      const existing = await this.all() || {};
      const schema = Object.assign(existing, update);
      for (let k in this.defaultSchema) {
        if (typeof schema[k] === "undefined") {
          schema[k] = this.defaultSchema[k];
        }
      }
      await writeFile$1(this.state.cache_file, JSON.stringify(schema, null, "  "));
    }
    async all() {
      try {
        const data = await readFile$2(this.state.cache_file, "utf8");
        return JSON.parse(data);
      } catch (err) {
        return;
      }
    }
    async get(key) {
      const schema = await this.all();
      if (typeof schema === "undefined") {
        return;
      }
      return schema[key];
    }
    async reset() {
      await writeFile$1(this.state.cache_file, JSON.stringify(this.defaultSchema, null, "  "));
      return;
    }
    async delete() {
      try {
        await unlink$1(this.state.cache_file);
        return;
      } catch (err) {
        return;
      }
    }
  };
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  var ms = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  var childPath = path__default["default"].join(eval("__dirname"), "child");
  async function check(input) {
    const defaultCache = getCacheFile(input.product, input.cli_path_hash || "default");
    const ci = require_ci_info2();
    const state = {
      product: input.product,
      version: input.version,
      cli_install_type: input.cli_install_type || "",
      information: input.information || "",
      local_timestamp: input.local_timestamp || rfc3339(new Date()),
      project_hash: input.project_hash,
      cli_path: input.cli_path || "",
      cli_path_hash: input.cli_path_hash || "",
      endpoint: input.endpoint || "https://checkpoint.prisma.io",
      disable: typeof input.disable === "undefined" ? false : input.disable,
      arch: input.arch || os__default["default"].arch(),
      os: input.os || os__default["default"].platform(),
      node_version: input.node_version || process.version,
      ci: typeof input.ci !== "undefined" ? input.ci : ci.isCI,
      ci_name: typeof input.ci_name !== "undefined" ? input.ci_name || "" : ci.name || "",
      command: input.command || "",
      schema_providers: input.schema_providers || [],
      schema_preview_features: input.schema_preview_features || [],
      schema_generators_providers: input.schema_generators_providers || [],
      cache_file: input.cache_file || defaultCache,
      cache_duration: typeof input.cache_duration === "undefined" ? ms("12h") : input.cache_duration,
      remind_duration: typeof input.remind_duration === "undefined" ? ms("48h") : input.remind_duration,
      force: typeof input.force === "undefined" ? false : input.force,
      timeout: getTimeout(input.timeout),
      unref: typeof input.unref === "undefined" ? true : input.unref,
      child_path: input.child_path || childPath,
      now: () => Date.now(),
      client_event_id: input.client_event_id || "",
      previous_client_event_id: input.previous_client_event_id || "",
      check_if_update_available: false
    };
    if ((process.env["CHECKPOINT_DISABLE"] || state.disable) && !state.force) {
      return {
        status: "disabled"
      };
    }
    const config = await Config.new(state);
    const cacheResponse = await config.checkCache(state);
    state.check_if_update_available = cacheResponse.stale === true || !cacheResponse.cache;
    const child = spawn(state);
    if (state.unref) {
      child.unref();
      child.disconnect();
    }
    if (cacheResponse.stale === true || !cacheResponse.cache) {
      return {
        status: "waiting",
        data: child
      };
    }
    for (const key of Object.keys(state)) {
      if (state[key]) {
        await config.set({
          [key]: state[key]
        });
      }
    }
    const userReminded = state.now() - cacheResponse.cache.last_reminder < state.remind_duration;
    if (userReminded) {
      return {
        status: "reminded",
        data: cacheResponse.cache.output
      };
    }
    await config.set({
      last_reminder: state.now()
    });
    return {
      status: "ok",
      data: cacheResponse.cache.output
    };
  }
  function getCacheFile(product, cacheIdentifier) {
    const dirs = envPaths_1(`checkpoint`);
    return path__default["default"].join(dirs.cache, `${product}-${cacheIdentifier}`);
  }
  function getTimeout(inputTimeout) {
    if (typeof inputTimeout !== "undefined") {
      return inputTimeout;
    }
    const timeoutString = process.env["CHECKPOINT_TIMEOUT"];
    if (typeof timeoutString === "undefined") {
      return 5e3;
    }
    const timeout = parseInt(timeoutString, 10);
    if (isNaN(timeout)) {
      return 5e3;
    }
    return timeout;
  }
  function getForkOpts(state) {
    if (state.unref === true) {
      return {
        detached: true,
        stdio: process.env.CHECKPOINT_DEBUG_STDOUT ? "inherit" : "ignore",
        env: process.env
      };
    }
    return {detached: false, stdio: "pipe", env: process.env};
  }
  function spawn(state) {
    return child_process.fork(childPath, [JSON.stringify(state)], getForkOpts(state));
  }
  function rfc3339(d2) {
    function pad(n) {
      return n < 10 ? "0" + n : n;
    }
    function timezoneOffset(offset) {
      let sign;
      if (offset === 0) {
        return "Z";
      }
      sign = offset > 0 ? "-" : "+";
      offset = Math.abs(offset);
      return sign + pad(Math.floor(offset / 60)) + ":" + pad(offset % 60);
    }
    return d2.getFullYear() + "-" + pad(d2.getMonth() + 1) + "-" + pad(d2.getDate()) + "T" + pad(d2.getHours()) + ":" + pad(d2.getMinutes()) + ":" + pad(d2.getSeconds()) + timezoneOffset(d2.getTimezoneOffset());
  }
  exports.check = check;
  exports.getInfo = getInfo;
  exports.getSignature = getSignature;
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/utils/maskSchema.js
var require_maskSchema = __commonJS((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    mapScalarValues: () => mapScalarValues,
    maskSchema: () => maskSchema2
  });
  function maskSchema2(schema) {
    const regex = /url\s*=\s*.+/;
    return schema.split("\n").map((line) => {
      const match = regex.exec(line);
      if (match) {
        return `${line.slice(0, match.index)}url = "***"`;
      }
      return line;
    }).join("\n");
  }
  function mapScalarValues(obj, mapper) {
    const result = {};
    for (const key in obj) {
      if (typeof obj[key] === "object") {
        result[key] = mapScalarValues(obj[key], mapper);
      } else {
        result[key] = mapper(obj[key]);
      }
    }
    return result;
  }
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/sendPanic.js
var require_sendPanic = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    ErrorKind: () => ErrorKind,
    createErrorReport: () => createErrorReport,
    makeErrorReportCompleted: () => makeErrorReportCompleted,
    sendPanic: () => sendPanic2
  });
  var import_get_platform3 = __toModule3(require_dist4());
  var import_archiver = __toModule3(require_archiver());
  var import_debug3 = __toModule3(require_dist2());
  var import_fs9 = __toModule3(require("fs"));
  var import_globby = __toModule3(require_globby());
  var import_node_fetch = __toModule3(require_lib4());
  var import_os2 = __toModule3(require("os"));
  var import_path10 = __toModule3(require("path"));
  var import_strip_ansi = __toModule3(require_strip_ansi());
  var import_tmp = __toModule3(require_tmp());
  var checkpoint3 = __toModule3(require_dist11());
  var import_maskSchema = __toModule3(require_maskSchema());
  var import_panic = __toModule3(require_panic());
  var import_fetch_engine2 = __toModule3(require_dist8());
  var import_IntrospectionEngine = __toModule3(require_IntrospectionEngine());
  var debug3 = (0, import_debug3.default)("prisma:sendPanic");
  import_tmp.default.setGracefulCleanup();
  async function sendPanic2(error, cliVersion, binaryVersion) {
    try {
      let schema;
      let maskedSchema;
      if (error.schemaPath) {
        schema = import_fs9.default.readFileSync(error.schemaPath, "utf-8");
      }
      if (error.schema) {
        schema = error.schema;
      }
      if (schema) {
        maskedSchema = (0, import_maskSchema.maskSchema)(schema);
      }
      let sqlDump;
      let dbVersion;
      const schemaOrUrl = error.schema || error.introspectionUrl;
      if (error.area === import_panic.ErrorArea.INTROSPECTION_CLI && schemaOrUrl) {
        let engine;
        try {
          engine = new import_IntrospectionEngine.IntrospectionEngine();
          sqlDump = await engine.getDatabaseDescription(schemaOrUrl);
          dbVersion = await engine.getDatabaseVersion(schemaOrUrl);
          engine.stop();
        } catch (e) {
          debug3(e);
          if (engine && engine.isRunning) {
            engine.stop();
          }
        }
      }
      const migrateRequest = error.request ? JSON.stringify((0, import_maskSchema.mapScalarValues)(error.request, (value) => {
        if (typeof value === "string") {
          return (0, import_maskSchema.maskSchema)(value);
        }
        return value;
      })) : void 0;
      const params = {
        area: error.area,
        kind: ErrorKind.RUST_PANIC,
        cliVersion,
        binaryVersion,
        command: getCommand(),
        jsStackTrace: (0, import_strip_ansi.default)(error.stack || error.message),
        rustStackTrace: error.rustStack,
        operatingSystem: `${import_os2.default.arch()} ${import_os2.default.platform()} ${import_os2.default.release()}`,
        platform: await (0, import_get_platform3.getPlatform)(),
        liftRequest: migrateRequest,
        schemaFile: maskedSchema,
        fingerprint: await checkpoint3.getSignature(),
        sqlDump,
        dbVersion
      };
      const signedUrl = await createErrorReport(params);
      if (error.schemaPath) {
        const zip = await makeErrorZip(error);
        await uploadZip(zip, signedUrl);
      }
      const id = await makeErrorReportCompleted(signedUrl);
      return id;
    } catch (e) {
      debug3(e);
    }
  }
  function getCommand() {
    if (process.argv[2] === "introspect") {
      return "introspect";
    } else if (process.argv[2] === "db" && process.argv[3] === "pull") {
      return "db pull";
    }
    return process.argv.slice(2).join(" ");
  }
  async function uploadZip(zip, url) {
    return await (0, import_node_fetch.default)(url, {
      method: "PUT",
      agent: (0, import_fetch_engine2.getProxyAgent)(url),
      headers: {
        "Content-Length": String(zip.byteLength)
      },
      body: zip
    });
  }
  async function makeErrorZip(error) {
    if (!error.schemaPath) {
      throw new Error(`Can't make zip without schema path`);
    }
    const schemaDir = import_path10.default.dirname(error.schemaPath);
    const tmpFileObj = import_tmp.default.fileSync();
    const outputFile = import_fs9.default.createWriteStream(tmpFileObj.name);
    const zip = (0, import_archiver.default)("zip", {zlib: {level: 9}});
    zip.pipe(outputFile);
    const schemaFile = (0, import_maskSchema.maskSchema)(import_fs9.default.readFileSync(error.schemaPath, "utf-8"));
    zip.append(schemaFile, {name: import_path10.default.basename(error.schemaPath)});
    if (import_fs9.default.existsSync(schemaDir)) {
      const filePaths = await (0, import_globby.default)("migrations/**/*", {
        cwd: schemaDir
      });
      for (const filePath of filePaths) {
        let file = import_fs9.default.readFileSync(import_path10.default.resolve(schemaDir, filePath), "utf-8");
        if (filePath.endsWith("schema.prisma") || filePath.endsWith(import_path10.default.basename(error.schemaPath))) {
          file = (0, import_maskSchema.maskSchema)(file);
        }
        zip.append(file, {name: import_path10.default.basename(filePath)});
      }
    }
    zip.finalize();
    return new Promise((resolve, reject) => {
      outputFile.on("close", () => {
        const buffer = import_fs9.default.readFileSync(tmpFileObj.name);
        resolve(buffer);
      });
      zip.on("error", (err) => {
        reject(err);
      });
    });
  }
  var ErrorKind;
  (function(ErrorKind2) {
    ErrorKind2["JS_ERROR"] = "JS_ERROR";
    ErrorKind2["RUST_PANIC"] = "RUST_PANIC";
  })(ErrorKind || (ErrorKind = {}));
  async function createErrorReport(data) {
    const result = await request(`mutation ($data: CreateErrorReportInput!) {
    createErrorReport(data: $data)
  }`, {data});
    return result.createErrorReport;
  }
  async function makeErrorReportCompleted(signedUrl) {
    const result = await request(`mutation ($signedUrl: String!) {
  markErrorReportCompleted(signedUrl: $signedUrl)
}`, {signedUrl});
    return result.markErrorReportCompleted;
  }
  async function request(query, variables) {
    const url = "https://error-reports.prisma.sh/";
    const body = JSON.stringify({
      query,
      variables
    });
    return await (0, import_node_fetch.default)(url, {
      method: "POST",
      agent: (0, import_fetch_engine2.getProxyAgent)(url),
      body,
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json"
      }
    }).then((res) => res.json()).then((res) => {
      if (res.errors) {
        throw new Error(JSON.stringify(res.errors));
      }
      return res.data;
    });
  }
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/types.js
var require_types4 = __commonJS((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  __markAsModule3(exports2);
});

// ../../node_modules/.pnpm/yocto-queue@0.1.0/node_modules/yocto-queue/index.js
var require_yocto_queue = __commonJS((exports2, module2) => {
  var Node = class {
    constructor(value) {
      this.value = value;
      this.next = void 0;
    }
  };
  var Queue = class {
    constructor() {
      this.clear();
    }
    enqueue(value) {
      const node = new Node(value);
      if (this._head) {
        this._tail.next = node;
        this._tail = node;
      } else {
        this._head = node;
        this._tail = node;
      }
      this._size++;
    }
    dequeue() {
      const current = this._head;
      if (!current) {
        return;
      }
      this._head = this._head.next;
      this._size--;
      return current.value;
    }
    clear() {
      this._head = void 0;
      this._tail = void 0;
      this._size = 0;
    }
    get size() {
      return this._size;
    }
    *[Symbol.iterator]() {
      let current = this._head;
      while (current) {
        yield current.value;
        current = current.next;
      }
    }
  };
  module2.exports = Queue;
});

// ../../node_modules/.pnpm/p-limit@3.1.0/node_modules/p-limit/index.js
var require_p_limit2 = __commonJS((exports2, module2) => {
  "use strict";
  var Queue = require_yocto_queue();
  var pLimit = (concurrency) => {
    if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
      throw new TypeError("Expected `concurrency` to be a number from 1 and up");
    }
    const queue = new Queue();
    let activeCount = 0;
    const next = () => {
      activeCount--;
      if (queue.size > 0) {
        queue.dequeue()();
      }
    };
    const run = async (fn, resolve, ...args2) => {
      activeCount++;
      const result = (async () => fn(...args2))();
      resolve(result);
      try {
        await result;
      } catch (e) {
      }
      next();
    };
    const enqueue = (fn, resolve, ...args2) => {
      queue.enqueue(run.bind(null, fn, resolve, ...args2));
      (async () => {
        await Promise.resolve();
        if (activeCount < concurrency && queue.size > 0) {
          queue.dequeue()();
        }
      })();
    };
    const generator = (fn, ...args2) => new Promise((resolve) => {
      enqueue(fn, resolve, ...args2);
    });
    Object.defineProperties(generator, {
      activeCount: {
        get: () => activeCount
      },
      pendingCount: {
        get: () => queue.size
      },
      clearQueue: {
        value: () => {
          queue.clear();
        }
      }
    });
    return generator;
  };
  module2.exports = pLimit;
});

// ../../node_modules/.pnpm/p-locate@5.0.0/node_modules/p-locate/index.js
var require_p_locate2 = __commonJS((exports2, module2) => {
  "use strict";
  var pLimit = require_p_limit2();
  var EndError = class extends Error {
    constructor(value) {
      super();
      this.value = value;
    }
  };
  var testElement = async (element, tester) => tester(await element);
  var finder = async (element) => {
    const values = await Promise.all(element);
    if (values[1] === true) {
      throw new EndError(values[0]);
    }
    return false;
  };
  var pLocate = async (iterable, tester, options) => {
    options = {
      concurrency: Infinity,
      preserveOrder: true,
      ...options
    };
    const limit = pLimit(options.concurrency);
    const items = [...iterable].map((element) => [element, limit(testElement, element, tester)]);
    const checkLimit = pLimit(options.preserveOrder ? 1 : Infinity);
    try {
      await Promise.all(items.map((element) => checkLimit(finder, element)));
    } catch (error) {
      if (error instanceof EndError) {
        return error.value;
      }
      throw error;
    }
  };
  module2.exports = pLocate;
});

// ../../node_modules/.pnpm/locate-path@6.0.0/node_modules/locate-path/index.js
var require_locate_path2 = __commonJS((exports2, module2) => {
  "use strict";
  var path10 = require("path");
  var fs9 = require("fs");
  var {promisify: promisify4} = require("util");
  var pLocate = require_p_locate2();
  var fsStat = promisify4(fs9.stat);
  var fsLStat = promisify4(fs9.lstat);
  var typeMappings = {
    directory: "isDirectory",
    file: "isFile"
  };
  function checkType({type}) {
    if (type in typeMappings) {
      return;
    }
    throw new Error(`Invalid type specified: ${type}`);
  }
  var matchType = (type, stat) => type === void 0 || stat[typeMappings[type]]();
  module2.exports = async (paths, options) => {
    options = {
      cwd: process.cwd(),
      type: "file",
      allowSymlinks: true,
      ...options
    };
    checkType(options);
    const statFn = options.allowSymlinks ? fsStat : fsLStat;
    return pLocate(paths, async (path_) => {
      try {
        const stat = await statFn(path10.resolve(options.cwd, path_));
        return matchType(options.type, stat);
      } catch (e) {
        return false;
      }
    }, options);
  };
  module2.exports.sync = (paths, options) => {
    options = {
      cwd: process.cwd(),
      allowSymlinks: true,
      type: "file",
      ...options
    };
    checkType(options);
    const statFn = options.allowSymlinks ? fs9.statSync : fs9.lstatSync;
    for (const path_ of paths) {
      try {
        const stat = statFn(path10.resolve(options.cwd, path_));
        if (matchType(options.type, stat)) {
          return path_;
        }
      } catch (e) {
      }
    }
  };
});

// ../../node_modules/.pnpm/find-up@5.0.0/node_modules/find-up/index.js
var require_find_up2 = __commonJS((exports2, module2) => {
  "use strict";
  var path10 = require("path");
  var locatePath = require_locate_path2();
  var pathExists = require_path_exists();
  var stop = Symbol("findUp.stop");
  module2.exports = async (name, options = {}) => {
    let directory = path10.resolve(options.cwd || "");
    const {root} = path10.parse(directory);
    const paths = [].concat(name);
    const runMatcher = async (locateOptions) => {
      if (typeof name !== "function") {
        return locatePath(paths, locateOptions);
      }
      const foundPath = await name(locateOptions.cwd);
      if (typeof foundPath === "string") {
        return locatePath([foundPath], locateOptions);
      }
      return foundPath;
    };
    while (true) {
      const foundPath = await runMatcher({...options, cwd: directory});
      if (foundPath === stop) {
        return;
      }
      if (foundPath) {
        return path10.resolve(directory, foundPath);
      }
      if (directory === root) {
        return;
      }
      directory = path10.dirname(directory);
    }
  };
  module2.exports.sync = (name, options = {}) => {
    let directory = path10.resolve(options.cwd || "");
    const {root} = path10.parse(directory);
    const paths = [].concat(name);
    const runMatcher = (locateOptions) => {
      if (typeof name !== "function") {
        return locatePath.sync(paths, locateOptions);
      }
      const foundPath = name(locateOptions.cwd);
      if (typeof foundPath === "string") {
        return locatePath.sync([foundPath], locateOptions);
      }
      return foundPath;
    };
    while (true) {
      const foundPath = runMatcher({...options, cwd: directory});
      if (foundPath === stop) {
        return;
      }
      if (foundPath) {
        return path10.resolve(directory, foundPath);
      }
      if (directory === root) {
        return;
      }
      directory = path10.dirname(directory);
    }
  };
  module2.exports.exists = pathExists;
  module2.exports.sync.exists = pathExists.sync;
  module2.exports.stop = stop;
});

// ../../node_modules/.pnpm/dotenv@10.0.0/node_modules/dotenv/lib/main.js
var require_main2 = __commonJS((exports2, module2) => {
  var fs9 = require("fs");
  var path10 = require("path");
  var os3 = require("os");
  function log2(message) {
    console.log(`[dotenv][DEBUG] ${message}`);
  }
  var NEWLINE = "\n";
  var RE_INI_KEY_VAL = /^\s*([\w.-]+)\s*=\s*(.*)?\s*$/;
  var RE_NEWLINES = /\\n/g;
  var NEWLINES_MATCH = /\r\n|\n|\r/;
  function parse2(src, options) {
    const debug3 = Boolean(options && options.debug);
    const obj = {};
    src.toString().split(NEWLINES_MATCH).forEach(function(line, idx) {
      const keyValueArr = line.match(RE_INI_KEY_VAL);
      if (keyValueArr != null) {
        const key = keyValueArr[1];
        let val = keyValueArr[2] || "";
        const end = val.length - 1;
        const isDoubleQuoted = val[0] === '"' && val[end] === '"';
        const isSingleQuoted = val[0] === "'" && val[end] === "'";
        if (isSingleQuoted || isDoubleQuoted) {
          val = val.substring(1, end);
          if (isDoubleQuoted) {
            val = val.replace(RE_NEWLINES, NEWLINE);
          }
        } else {
          val = val.trim();
        }
        obj[key] = val;
      } else if (debug3) {
        log2(`did not match key and value when parsing line ${idx + 1}: ${line}`);
      }
    });
    return obj;
  }
  function resolveHome(envPath) {
    return envPath[0] === "~" ? path10.join(os3.homedir(), envPath.slice(1)) : envPath;
  }
  function config(options) {
    let dotenvPath = path10.resolve(process.cwd(), ".env");
    let encoding = "utf8";
    let debug3 = false;
    if (options) {
      if (options.path != null) {
        dotenvPath = resolveHome(options.path);
      }
      if (options.encoding != null) {
        encoding = options.encoding;
      }
      if (options.debug != null) {
        debug3 = true;
      }
    }
    try {
      const parsed = parse2(fs9.readFileSync(dotenvPath, {encoding}), {debug: debug3});
      Object.keys(parsed).forEach(function(key) {
        if (!Object.prototype.hasOwnProperty.call(process.env, key)) {
          process.env[key] = parsed[key];
        } else if (debug3) {
          log2(`"${key}" is already defined in \`process.env\` and will not be overwritten`);
        }
      });
      return {parsed};
    } catch (e) {
      return {error: e};
    }
  }
  module2.exports.config = config;
  module2.exports.parse = parse2;
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/dotenvExpand.js
var require_dotenvExpand = __commonJS((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    dotenvExpand: () => dotenvExpand
  });
  function dotenvExpand(config) {
    const environment = config.ignoreProcessEnv ? {} : process.env;
    const interpolate = (envValue) => {
      const matches = envValue.match(/(.?\${(?:[a-zA-Z0-9_]+)?})/g) || [];
      return matches.reduce(function(newEnv, match) {
        const parts = /(.?)\${([a-zA-Z0-9_]+)?}/g.exec(match);
        if (!parts) {
          return newEnv;
        }
        const prefix = parts[1];
        let value, replacePart;
        if (prefix === "\\") {
          replacePart = parts[0];
          value = replacePart.replace("\\$", "$");
        } else {
          const key = parts[2];
          replacePart = parts[0].substring(prefix.length);
          value = Object.hasOwnProperty.call(environment, key) ? environment[key] : config.parsed[key] || "";
          value = interpolate(value);
        }
        return newEnv.replace(replacePart, value);
      }, envValue);
    };
    for (const configKey in config.parsed) {
      const value = Object.hasOwnProperty.call(environment, configKey) ? environment[configKey] : config.parsed[configKey];
      config.parsed[configKey] = interpolate(value);
    }
    for (const processKey in config.parsed) {
      environment[processKey] = config.parsed[processKey];
    }
    return config;
  }
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/utils/tryLoadEnvs.js
var require_tryLoadEnvs = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    exists: () => exists2,
    loadEnv: () => loadEnv,
    pathsEqual: () => pathsEqual,
    tryLoadEnvs: () => tryLoadEnvs3
  });
  var import_chalk14 = __toModule3(require_source());
  var import_debug3 = __toModule3(require_dist2());
  var import_dotenv2 = __toModule3(require_main2());
  var import_fs9 = __toModule3(require("fs"));
  var import_path10 = __toModule3(require("path"));
  var import_dotenvExpand = __toModule3(require_dotenvExpand());
  var debug3 = (0, import_debug3.default)("prisma:tryLoadEnv");
  function tryLoadEnvs3({
    rootEnvPath,
    schemaEnvPath
  }, opts = {
    conflictCheck: "none"
  }) {
    var _a, _b;
    const rootEnvInfo = loadEnv(rootEnvPath);
    if (opts.conflictCheck !== "none") {
      checkForConflicts(rootEnvInfo, schemaEnvPath, opts.conflictCheck);
    }
    let schemaEnvInfo = null;
    if (!pathsEqual(rootEnvInfo == null ? void 0 : rootEnvInfo.path, schemaEnvPath)) {
      schemaEnvInfo = loadEnv(schemaEnvPath);
    }
    if (!rootEnvInfo && !schemaEnvInfo) {
      debug3("No Environment variables loaded");
    }
    if (schemaEnvInfo == null ? void 0 : schemaEnvInfo.dotenvResult.error) {
      return console.error(import_chalk14.default.redBright.bold("Schema Env Error: ") + schemaEnvInfo.dotenvResult.error);
    }
    const messages = [rootEnvInfo == null ? void 0 : rootEnvInfo.message, schemaEnvInfo == null ? void 0 : schemaEnvInfo.message].filter(Boolean);
    return {
      message: messages.join("\n"),
      parsed: {
        ...(_a = rootEnvInfo == null ? void 0 : rootEnvInfo.dotenvResult) == null ? void 0 : _a.parsed,
        ...(_b = schemaEnvInfo == null ? void 0 : schemaEnvInfo.dotenvResult) == null ? void 0 : _b.parsed
      }
    };
  }
  function checkForConflicts(rootEnvInfo, envPath, type) {
    const parsedRootEnv = rootEnvInfo == null ? void 0 : rootEnvInfo.dotenvResult.parsed;
    const areNotTheSame = !pathsEqual(rootEnvInfo == null ? void 0 : rootEnvInfo.path, envPath);
    if (parsedRootEnv && envPath && areNotTheSame && import_fs9.default.existsSync(envPath)) {
      const envConfig = import_dotenv2.default.parse(import_fs9.default.readFileSync(envPath));
      const conflicts = [];
      for (const k in envConfig) {
        if (parsedRootEnv[k] === envConfig[k]) {
          conflicts.push(k);
        }
      }
      if (conflicts.length > 0) {
        const relativeRootEnvPath = import_path10.default.relative(process.cwd(), rootEnvInfo.path);
        const relativeEnvPath = import_path10.default.relative(process.cwd(), envPath);
        if (type === "error") {
          const message = `There is a conflict between env var${conflicts.length > 1 ? "s" : ""} in ${import_chalk14.default.underline(relativeRootEnvPath)} and ${import_chalk14.default.underline(relativeEnvPath)}
Conflicting env vars:
${conflicts.map((conflict) => `  ${import_chalk14.default.bold(conflict)}`).join("\n")}

We suggest to move the contents of ${import_chalk14.default.underline(relativeEnvPath)} to ${import_chalk14.default.underline(relativeRootEnvPath)} to consolidate your env vars.
`;
          throw new Error(message);
        } else if (type === "warn") {
          const message = `Conflict for env var${conflicts.length > 1 ? "s" : ""} ${conflicts.map((c) => import_chalk14.default.bold(c)).join(", ")} in ${import_chalk14.default.underline(relativeRootEnvPath)} and ${import_chalk14.default.underline(relativeEnvPath)}
Env vars from ${import_chalk14.default.underline(relativeEnvPath)} overwrite the ones from ${import_chalk14.default.underline(relativeRootEnvPath)}
      `;
          console.warn(`${import_chalk14.default.yellow("warn(prisma)")} ${message}`);
        }
      }
    }
  }
  function loadEnv(envPath) {
    if (exists2(envPath)) {
      debug3(`Environment variables loaded from ${envPath}`);
      const debugEnv = process.env.DEBUG;
      let enableDebug = void 0;
      if (debugEnv && (debugEnv.startsWith("prisma") || debugEnv === "*")) {
        enableDebug = true;
      }
      return {
        dotenvResult: (0, import_dotenvExpand.dotenvExpand)(import_dotenv2.default.config({
          path: envPath,
          debug: enableDebug
        })),
        message: import_chalk14.default.dim(`Environment variables loaded from ${import_path10.default.relative(process.cwd(), envPath)}`),
        path: envPath
      };
    } else {
      debug3(`Environment variables not found at ${envPath}`);
    }
    return null;
  }
  function pathsEqual(path1, path22) {
    return path1 && path22 && import_path10.default.resolve(path1) === import_path10.default.resolve(path22);
  }
  function exists2(p) {
    return Boolean(p && import_fs9.default.existsSync(p));
  }
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/utils/getEnvPaths.js
var require_getEnvPaths = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    getEnvPaths: () => getEnvPaths3
  });
  var import_debug3 = __toModule3(require_dist2());
  var import_find_up = __toModule3(require_find_up2());
  var import_path10 = __toModule3(require("path"));
  var import_fs9 = __toModule3(require("fs"));
  var import_getSchema = __toModule3(require_getSchema());
  var import_tryLoadEnvs = __toModule3(require_tryLoadEnvs());
  var debug3 = (0, import_debug3.default)("prisma:loadEnv");
  function getEnvPaths3(schemaPath, opts = {cwd: process.cwd()}) {
    var _a;
    const rootEnvPath = (_a = getProjectRootEnvPath({cwd: opts.cwd})) != null ? _a : null;
    const schemaEnvPathFromArgs = schemaPathToEnvPath(schemaPath);
    const schemaEnvPathFromPkgJson = schemaPathToEnvPath(readSchemaPathFromPkgJson());
    const schemaEnvPaths = [
      schemaEnvPathFromArgs,
      schemaEnvPathFromPkgJson,
      "./prisma/.env",
      "./.env"
    ];
    const schemaEnvPath = schemaEnvPaths.find(import_tryLoadEnvs.exists);
    return {rootEnvPath, schemaEnvPath};
  }
  function readSchemaPathFromPkgJson() {
    try {
      return (0, import_getSchema.getSchemaPathFromPackageJsonSync)(process.cwd());
    } catch (e) {
      return null;
    }
  }
  function getProjectRootEnvPath(opts) {
    const pkgJsonPath = import_find_up.default.sync((dir) => {
      const pkgPath = import_path10.default.join(dir, "package.json");
      if (import_find_up.default.exists(pkgPath)) {
        try {
          const pkg2 = JSON.parse(import_fs9.default.readFileSync(pkgPath, "utf8"));
          if (pkg2["name"] !== ".prisma/client") {
            debug3(`project root found at ${pkgPath}`);
            return pkgPath;
          }
        } catch (e) {
          debug3(`skipping package.json at ${pkgPath}`);
        }
      }
      return void 0;
    }, opts);
    if (!pkgJsonPath) {
      return null;
    }
    const candidate = import_path10.default.join(import_path10.default.dirname(pkgJsonPath), ".env");
    if (!import_fs9.default.existsSync(candidate)) {
      return null;
    }
    return candidate;
  }
  function schemaPathToEnvPath(schemaPath) {
    if (!schemaPath)
      return null;
    return import_path10.default.join(import_path10.default.dirname(schemaPath), ".env");
  }
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/utils/trimBlocksFromSchema.js
var require_trimBlocksFromSchema = __commonJS((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    trimBlocksFromSchema: () => trimBlocksFromSchema2,
    trimNewLine: () => trimNewLine2
  });
  function trimNewLine2(str) {
    if (str === "") {
      return str;
    }
    let newStr = str;
    if (/\r?\n|\r/.exec(newStr[0])) {
      newStr = newStr.slice(1);
    }
    if (newStr.length > 0 && /\r?\n|\r/.exec(newStr[newStr.length - 1])) {
      newStr = newStr.slice(0, newStr.length - 1);
    }
    return newStr;
  }
  function trimBlocksFromSchema2(str, blocks = ["model", "enum", "datasource", "generator"]) {
    const lines = str.split("\n");
    if (lines.length <= 2) {
      return str;
    }
    const modelPositions = [];
    let blockOpen = false;
    let currentStart = -1;
    lines.forEach((line, index) => {
      const trimmed = line.trim();
      if (blocks.some((b) => line.startsWith(b)) && line.endsWith("{")) {
        blockOpen = true;
        currentStart = index;
      }
      if (trimmed.endsWith("}") && currentStart > -1 && blockOpen) {
        modelPositions.push({
          start: currentStart,
          end: index
        });
        blockOpen = false;
        currentStart = -1;
      }
    });
    if (modelPositions.length === 0) {
      return str;
    }
    return trimNewLine2(modelPositions.reduceRight((acc, position) => {
      acc.splice(position.start, position.end - position.start + 1);
      return acc;
    }, lines).join("\n"));
  }
});

// ../../node_modules/.pnpm/@prisma+sdk@2.30.2/node_modules/@prisma/sdk/dist/index.js
var require_dist12 = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    BinaryType: () => import_resolveBinary.BinaryType,
    Command: () => import_types.Command,
    Commands: () => import_types.Commands,
    CompiledGeneratorDefinition: () => import_types.CompiledGeneratorDefinition,
    DatabaseCredentials: () => import_types2.DatabaseCredentials,
    Dictionary: () => import_types.Dictionary,
    ErrorArea: () => import_panic.ErrorArea,
    Generator: () => import_Generator2.Generator,
    GeneratorConfig: () => import_types.GeneratorConfig,
    GeneratorDefinition: () => import_types.GeneratorDefinition,
    GeneratorDefinitionWithPackage: () => import_types.GeneratorDefinitionWithPackage,
    GeneratorFunction: () => import_types.GeneratorFunction,
    GeneratorOptions: () => import_types.GeneratorOptions,
    GeneratorPaths: () => import_predefinedGeneratorResolvers2.GeneratorPaths,
    HelpError: () => import_Help.HelpError,
    IntrospectionEngine: () => import_IntrospectionEngine.IntrospectionEngine,
    IntrospectionSchemaVersion: () => import_IntrospectionEngine.IntrospectionSchemaVersion,
    IntrospectionWarnings: () => import_IntrospectionEngine.IntrospectionWarnings,
    MigrateEngineExitCode: () => import_migrateEngineCommands.MigrateEngineExitCode,
    MigrateEngineLogLine: () => import_migrateEngineCommands.MigrateEngineLogLine,
    Platform: () => import_get_platform3.Platform,
    Position: () => import_trimBlocksFromSchema.Position,
    ProviderAliases: () => import_getGenerators.ProviderAliases,
    RustPanic: () => import_panic.RustPanic,
    arg: () => import_utils.arg,
    canConnectToDatabase: () => import_migrateEngineCommands.canConnectToDatabase,
    createDatabase: () => import_migrateEngineCommands.createDatabase,
    credentialsToUri: () => import_convertCredentials2.credentialsToUri,
    drawBox: () => import_drawBox.drawBox,
    dropDatabase: () => import_migrateEngineCommands.dropDatabase,
    engineEnvVarMap: () => import_resolveBinary.engineEnvVarMap,
    extractPreviewFeatures: () => import_extractPreviewFeatures2.extractPreviewFeatures,
    format: () => import_utils.format,
    getCLIPathHash: () => import_hashes.getCLIPathHash,
    getCommandWithExecutor: () => import_getCommandWithExecutor.getCommandWithExecutor,
    getEnvPaths: () => import_getEnvPaths.getEnvPaths,
    getGenerator: () => import_getGenerators.getGenerator,
    getGenerators: () => import_getGenerators.getGenerators,
    getNodeAPIName: () => import_get_platform3.getNodeAPIName,
    getPackedPackage: () => import_getPackedPackage.getPackedPackage,
    getPlatform: () => import_get_platform3.getPlatform,
    getProjectHash: () => import_hashes.getProjectHash,
    getRelativeSchemaPath: () => import_getSchema.getRelativeSchemaPath,
    getSchema: () => import_getSchema.getSchema,
    getSchemaDir: () => import_getSchema.getSchemaDir,
    getSchemaDirSync: () => import_getSchema.getSchemaDirSync,
    getSchemaPath: () => import_getSchema.getSchemaPath,
    getSchemaPathFromPackageJson: () => import_getSchema.getSchemaPathFromPackageJson,
    getSchemaPathFromPackageJsonSync: () => import_getSchema.getSchemaPathFromPackageJsonSync,
    getSchemaPathSync: () => import_getSchema.getSchemaPathSync,
    getSchemaSync: () => import_getSchema.getSchemaSync,
    highlightDatamodel: () => import_highlight.highlightDatamodel,
    highlightSql: () => import_highlight.highlightSql,
    highlightTS: () => import_highlight.highlightTS,
    isCi: () => import_isCi.isCi,
    isCurrentBinInstalledGlobally: () => import_isCurrentBinInstalledGlobally.isCurrentBinInstalledGlobally,
    isError: () => import_utils.isError,
    keyBy: () => import_keyBy.keyBy,
    link: () => import_link.link,
    load: () => import_load.load,
    logger: () => logger5,
    mapPreviewFeatures: () => import_mapPreviewFeatures2.mapPreviewFeatures,
    maskSchema: () => import_maskSchema.maskSchema,
    missingGeneratorMessage: () => import_missingGeneratorMessage2.missingGeneratorMessage,
    parseBinaryTargetsEnvValue: () => import_parseEnvValue2.parseBinaryTargetsEnvValue,
    parseEnvValue: () => import_parseEnvValue2.parseEnvValue,
    pick: () => import_pick2.pick,
    printConfigWarnings: () => import_printConfigWarnings2.printConfigWarnings,
    resolveBinary: () => import_resolveBinary.resolveBinary,
    sendPanic: () => import_sendPanic.sendPanic,
    trimBlocksFromSchema: () => import_trimBlocksFromSchema.trimBlocksFromSchema,
    trimNewLine: () => import_trimBlocksFromSchema.trimNewLine,
    tryLoadEnvs: () => import_tryLoadEnvs.tryLoadEnvs,
    unknownCommand: () => import_Help.unknownCommand,
    uriToCredentials: () => import_convertCredentials2.uriToCredentials
  });
  var import_getSchema = __toModule3(require_getSchema());
  var import_hashes = __toModule3(require_hashes());
  var import_Help = __toModule3(require_Help());
  var import_types = __toModule3(require_types());
  var import_utils = __toModule3(require_utils());
  var import_convertCredentials2 = __toModule3(require_convertCredentials());
  var import_drawBox = __toModule3(require_drawBox());
  __reExport2(exports2, __toModule3(require_engine_commands()));
  var import_Generator2 = __toModule3(require_Generator());
  var import_getCommandWithExecutor = __toModule3(require_getCommandWithExecutor());
  var import_getGenerators = __toModule3(require_getGenerators());
  var import_getPackedPackage = __toModule3(require_getPackedPackage());
  var import_highlight = __toModule3(require_highlight());
  var import_IntrospectionEngine = __toModule3(require_IntrospectionEngine());
  var import_isCi = __toModule3(require_isCi());
  var import_isCurrentBinInstalledGlobally = __toModule3(require_isCurrentBinInstalledGlobally());
  var import_keyBy = __toModule3(require_keyBy());
  var import_link = __toModule3(require_link());
  var logger5 = __toModule3(require_logger());
  var import_migrateEngineCommands = __toModule3(require_migrateEngineCommands());
  var import_panic = __toModule3(require_panic());
  var import_pick2 = __toModule3(require_pick());
  var import_predefinedGeneratorResolvers2 = __toModule3(require_predefinedGeneratorResolvers());
  var import_resolveBinary = __toModule3(require_resolveBinary());
  var import_sendPanic = __toModule3(require_sendPanic());
  var import_types2 = __toModule3(require_types4());
  var import_extractPreviewFeatures2 = __toModule3(require_extractPreviewFeatures());
  var import_getEnvPaths = __toModule3(require_getEnvPaths());
  var import_mapPreviewFeatures2 = __toModule3(require_mapPreviewFeatures());
  var import_maskSchema = __toModule3(require_maskSchema());
  var import_missingGeneratorMessage2 = __toModule3(require_missingGeneratorMessage());
  var import_parseEnvValue2 = __toModule3(require_parseEnvValue());
  var import_printConfigWarnings2 = __toModule3(require_printConfigWarnings());
  var import_load = __toModule3(require_load());
  var import_trimBlocksFromSchema = __toModule3(require_trimBlocksFromSchema());
  var import_tryLoadEnvs = __toModule3(require_tryLoadEnvs());
  var import_get_platform3 = __toModule3(require_dist4());
});

// ../debug/dist/common.js
var require_common7 = __commonJS((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    setup: () => setup
  });
  function setup(env2) {
    const createDebug = (namespace, logger5) => {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      const debug3 = (...args2) => {
        const self2 = debug3;
        const curr = Number(new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args2[0] = createDebug.coerce(args2[0]);
        if (typeof args2[0] !== "string") {
          args2.unshift("%O");
        }
        let index = 0;
        args2[0] = args2[0].replace(/%([a-zA-Z%])/g, (match, format10) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format10];
          if (typeof formatter === "function") {
            const val = args2[index];
            match = formatter.call(self2, val);
            args2.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args2);
        if (logger5 && typeof logger5 === "function") {
          logger5.apply(self2, args2);
        }
        if (debug3.enabled) {
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args2);
        }
      };
      debug3.namespace = namespace;
      debug3.useColors = createDebug.useColors();
      debug3.color = createDebug.selectColor(namespace);
      debug3.extend = extend;
      debug3.destroy = createDebug.destroy;
      Object.defineProperty(debug3, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug3);
      }
      return debug3;
    };
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms2();
    createDebug.destroy = destroy;
    Object.keys(env2).forEach((key) => {
      createDebug[key] = env2[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
});

// ../debug/dist/node.js
var require_node5 = __commonJS((exports2, module2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    default: () => node_default
  });
  var import_common = __toModule3(require_common7());
  var tty = require("tty");
  var util2 = require("util");
  exports2.init = init;
  exports2.log = log2;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load2;
  exports2.useColors = useColors;
  exports2.destroy = util2.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports2.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require("supports-color");
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports2.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {
  }
  exports2.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_2, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args2) {
    const {namespace: name, useColors: useColors2} = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} [0m`;
      args2[0] = prefix + args2[0].split("\n").join("\n" + prefix);
      args2.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
    } else {
      args2[0] = getDate() + name + " " + args2[0];
    }
  }
  function getDate() {
    if (exports2.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log2(...args2) {
    return process.stderr.write(util2.format(...args2) + "\n");
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load2() {
    return process.env.DEBUG;
  }
  function init(debug3) {
    debug3.inspectOpts = {};
    const keys = Object.keys(exports2.inspectOpts);
    for (let i = 0; i < keys.length; i++) {
      debug3.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
    }
  }
  var mod = (0, import_common.setup)(exports2);
  module2.exports = mod;
  var node_default = mod;
  var {formatters} = mod;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v, this.inspectOpts);
  };
});

// ../debug/dist/index.js
var require_dist13 = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    Debug: () => Debug2,
    default: () => Debug2,
    getLogs: () => getLogs
  });
  var import_debug3 = __toModule3(require_src2());
  var import_node = __toModule3(require_node5());
  var cache = [];
  var MAX_LOGS = 100;
  function Debug2(namespace) {
    const debug3 = (0, import_node.default)(namespace, (...args2) => {
      cache.push(args2);
      if (cache.length > MAX_LOGS) {
        cache.shift();
      }
    });
    return debug3;
  }
  Debug2.enable = (namespace) => {
    import_node.default.enable(namespace);
  };
  Debug2.enabled = (namespace) => import_node.default.enabled(namespace);
  function getLogs(numChars = 7500) {
    const output = cache.map((c) => c.map((item) => {
      if (typeof item === "string") {
        return item;
      }
      return JSON.stringify(item);
    }).join("  ")).join("\n");
    if (output.length < numChars) {
      return output;
    }
    return output.slice(-numChars);
  }
});

// ../../node_modules/.pnpm/restore-cursor@3.1.0/node_modules/restore-cursor/index.js
var require_restore_cursor = __commonJS((exports2, module2) => {
  "use strict";
  var onetime = require_onetime();
  var signalExit = require_signal_exit();
  module2.exports = onetime(() => {
    signalExit(() => {
      process.stderr.write("[?25h");
    }, {alwaysLast: true});
  });
});

// ../../node_modules/.pnpm/cli-cursor@3.1.0/node_modules/cli-cursor/index.js
var require_cli_cursor = __commonJS((exports2) => {
  "use strict";
  var restoreCursor = require_restore_cursor();
  var isHidden = false;
  exports2.show = (writableStream = process.stderr) => {
    if (!writableStream.isTTY) {
      return;
    }
    isHidden = false;
    writableStream.write("[?25h");
  };
  exports2.hide = (writableStream = process.stderr) => {
    if (!writableStream.isTTY) {
      return;
    }
    restoreCursor();
    isHidden = true;
    writableStream.write("[?25l");
  };
  exports2.toggle = (force, writableStream) => {
    if (force !== void 0) {
      isHidden = force;
    }
    if (isHidden) {
      exports2.show(writableStream);
    } else {
      exports2.hide(writableStream);
    }
  };
});

// ../../node_modules/.pnpm/wrap-ansi@6.2.0/node_modules/wrap-ansi/index.js
var require_wrap_ansi = __commonJS((exports2, module2) => {
  "use strict";
  var stringWidth = require_string_width();
  var stripAnsi = require_strip_ansi();
  var ansiStyles = require_ansi_styles();
  var ESCAPES = new Set([
    "",
    "\x9B"
  ]);
  var END_CODE = 39;
  var wrapAnsi = (code) => `${ESCAPES.values().next().value}[${code}m`;
  var wordLengths = (string) => string.split(" ").map((character) => stringWidth(character));
  var wrapWord = (rows, word, columns) => {
    const characters = [...word];
    let isInsideEscape = false;
    let visible = stringWidth(stripAnsi(rows[rows.length - 1]));
    for (const [index, character] of characters.entries()) {
      const characterLength = stringWidth(character);
      if (visible + characterLength <= columns) {
        rows[rows.length - 1] += character;
      } else {
        rows.push(character);
        visible = 0;
      }
      if (ESCAPES.has(character)) {
        isInsideEscape = true;
      } else if (isInsideEscape && character === "m") {
        isInsideEscape = false;
        continue;
      }
      if (isInsideEscape) {
        continue;
      }
      visible += characterLength;
      if (visible === columns && index < characters.length - 1) {
        rows.push("");
        visible = 0;
      }
    }
    if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {
      rows[rows.length - 2] += rows.pop();
    }
  };
  var stringVisibleTrimSpacesRight = (str) => {
    const words = str.split(" ");
    let last = words.length;
    while (last > 0) {
      if (stringWidth(words[last - 1]) > 0) {
        break;
      }
      last--;
    }
    if (last === words.length) {
      return str;
    }
    return words.slice(0, last).join(" ") + words.slice(last).join("");
  };
  var exec = (string, columns, options = {}) => {
    if (options.trim !== false && string.trim() === "") {
      return "";
    }
    let pre = "";
    let ret = "";
    let escapeCode;
    const lengths = wordLengths(string);
    let rows = [""];
    for (const [index, word] of string.split(" ").entries()) {
      if (options.trim !== false) {
        rows[rows.length - 1] = rows[rows.length - 1].trimLeft();
      }
      let rowLength = stringWidth(rows[rows.length - 1]);
      if (index !== 0) {
        if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {
          rows.push("");
          rowLength = 0;
        }
        if (rowLength > 0 || options.trim === false) {
          rows[rows.length - 1] += " ";
          rowLength++;
        }
      }
      if (options.hard && lengths[index] > columns) {
        const remainingColumns = columns - rowLength;
        const breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
        const breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);
        if (breaksStartingNextLine < breaksStartingThisLine) {
          rows.push("");
        }
        wrapWord(rows, word, columns);
        continue;
      }
      if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {
        if (options.wordWrap === false && rowLength < columns) {
          wrapWord(rows, word, columns);
          continue;
        }
        rows.push("");
      }
      if (rowLength + lengths[index] > columns && options.wordWrap === false) {
        wrapWord(rows, word, columns);
        continue;
      }
      rows[rows.length - 1] += word;
    }
    if (options.trim !== false) {
      rows = rows.map(stringVisibleTrimSpacesRight);
    }
    pre = rows.join("\n");
    for (const [index, character] of [...pre].entries()) {
      ret += character;
      if (ESCAPES.has(character)) {
        const code2 = parseFloat(/\d[^m]*/.exec(pre.slice(index, index + 4)));
        escapeCode = code2 === END_CODE ? null : code2;
      }
      const code = ansiStyles.codes.get(Number(escapeCode));
      if (escapeCode && code) {
        if (pre[index + 1] === "\n") {
          ret += wrapAnsi(code);
        } else if (character === "\n") {
          ret += wrapAnsi(escapeCode);
        }
      }
    }
    return ret;
  };
  module2.exports = (string, columns, options) => {
    return String(string).normalize().replace(/\r\n/g, "\n").split("\n").map((line) => exec(line, columns, options)).join("\n");
  };
});

// ../../node_modules/.pnpm/slice-ansi@4.0.0/node_modules/slice-ansi/index.js
var require_slice_ansi2 = __commonJS((exports2, module2) => {
  "use strict";
  var isFullwidthCodePoint = require_is_fullwidth_code_point();
  var astralRegex = require_astral_regex();
  var ansiStyles = require_ansi_styles();
  var ESCAPES = [
    "",
    "\x9B"
  ];
  var wrapAnsi = (code) => `${ESCAPES[0]}[${code}m`;
  var checkAnsi = (ansiCodes, isEscapes, endAnsiCode) => {
    let output = [];
    ansiCodes = [...ansiCodes];
    for (let ansiCode of ansiCodes) {
      const ansiCodeOrigin = ansiCode;
      if (ansiCode.includes(";")) {
        ansiCode = ansiCode.split(";")[0][0] + "0";
      }
      const item = ansiStyles.codes.get(Number.parseInt(ansiCode, 10));
      if (item) {
        const indexEscape = ansiCodes.indexOf(item.toString());
        if (indexEscape === -1) {
          output.push(wrapAnsi(isEscapes ? item : ansiCodeOrigin));
        } else {
          ansiCodes.splice(indexEscape, 1);
        }
      } else if (isEscapes) {
        output.push(wrapAnsi(0));
        break;
      } else {
        output.push(wrapAnsi(ansiCodeOrigin));
      }
    }
    if (isEscapes) {
      output = output.filter((element, index) => output.indexOf(element) === index);
      if (endAnsiCode !== void 0) {
        const fistEscapeCode = wrapAnsi(ansiStyles.codes.get(Number.parseInt(endAnsiCode, 10)));
        output = output.reduce((current, next) => next === fistEscapeCode ? [next, ...current] : [...current, next], []);
      }
    }
    return output.join("");
  };
  module2.exports = (string, begin, end) => {
    const characters = [...string];
    const ansiCodes = [];
    let stringEnd = typeof end === "number" ? end : characters.length;
    let isInsideEscape = false;
    let ansiCode;
    let visible = 0;
    let output = "";
    for (const [index, character] of characters.entries()) {
      let leftEscape = false;
      if (ESCAPES.includes(character)) {
        const code = /\d[^m]*/.exec(string.slice(index, index + 18));
        ansiCode = code && code.length > 0 ? code[0] : void 0;
        if (visible < stringEnd) {
          isInsideEscape = true;
          if (ansiCode !== void 0) {
            ansiCodes.push(ansiCode);
          }
        }
      } else if (isInsideEscape && character === "m") {
        isInsideEscape = false;
        leftEscape = true;
      }
      if (!isInsideEscape && !leftEscape) {
        visible++;
      }
      if (!astralRegex({exact: true}).test(character) && isFullwidthCodePoint(character.codePointAt())) {
        visible++;
        if (typeof end !== "number") {
          stringEnd++;
        }
      }
      if (visible > begin && visible <= stringEnd) {
        output += character;
      } else if (visible === begin && !isInsideEscape && ansiCode !== void 0) {
        output = checkAnsi(ansiCodes);
      } else if (visible >= stringEnd) {
        output += checkAnsi(ansiCodes, true, ansiCode);
        break;
      }
    }
    return output;
  };
});

// ../../node_modules/.pnpm/log-update@4.0.0/node_modules/log-update/index.js
var require_log_update = __commonJS((exports2, module2) => {
  "use strict";
  var ansiEscapes = require_ansi_escapes();
  var cliCursor = require_cli_cursor();
  var wrapAnsi = require_wrap_ansi();
  var sliceAnsi = require_slice_ansi2();
  var defaultTerminalHeight = 24;
  var getWidth = (stream) => {
    const {columns} = stream;
    if (!columns) {
      return 80;
    }
    return columns;
  };
  var fitToTerminalHeight = (stream, text) => {
    const terminalHeight = stream.rows || defaultTerminalHeight;
    const lines = text.split("\n");
    const toRemove = lines.length - terminalHeight;
    if (toRemove <= 0) {
      return text;
    }
    return sliceAnsi(text, lines.slice(0, toRemove).join("\n").length + 1, text.length);
  };
  var main2 = (stream, {showCursor = false} = {}) => {
    let previousLineCount = 0;
    let previousWidth = getWidth(stream);
    let previousOutput = "";
    const render = (...args2) => {
      if (!showCursor) {
        cliCursor.hide();
      }
      let output = args2.join(" ") + "\n";
      output = fitToTerminalHeight(stream, output);
      const width = getWidth(stream);
      if (output === previousOutput && previousWidth === width) {
        return;
      }
      previousOutput = output;
      previousWidth = width;
      output = wrapAnsi(output, width, {
        trim: false,
        hard: true,
        wordWrap: false
      });
      stream.write(ansiEscapes.eraseLines(previousLineCount) + output);
      previousLineCount = output.split("\n").length;
    };
    render.clear = () => {
      stream.write(ansiEscapes.eraseLines(previousLineCount));
      previousOutput = "";
      previousWidth = getWidth(stream);
      previousLineCount = 0;
    };
    render.done = () => {
      previousOutput = "";
      previousWidth = getWidth(stream);
      previousLineCount = 0;
      if (!showCursor) {
        cliCursor.show();
      }
    };
    return render;
  };
  module2.exports = main2(process.stdout);
  module2.exports.stderr = main2(process.stderr);
  module2.exports.create = main2;
});

// ../migrate/dist/utils/byline.js
var require_byline4 = __commonJS((exports2, module2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    createLineStream: () => createLineStream,
    default: () => byline2
  });
  var stream = require("stream");
  var util2 = require("util");
  function byline2(readStream, options) {
    return module2.exports.createStream(readStream, options);
  }
  module2.exports.createStream = function(readStream, options) {
    if (readStream) {
      return createLineStream(readStream, options);
    } else {
      return new LineStream(options);
    }
  };
  function createLineStream(readStream, options) {
    if (!readStream) {
      throw new Error("expected readStream");
    }
    if (!readStream.readable) {
      throw new Error("readStream must be readable");
    }
    var ls = new LineStream(options);
    readStream.pipe(ls);
    return ls;
  }
  module2.exports.LineStream = LineStream;
  function LineStream(options) {
    stream.Transform.call(this, options);
    options = options || {};
    this._readableState.objectMode = true;
    this._lineBuffer = [];
    this._keepEmptyLines = options.keepEmptyLines || false;
    this._lastChunkEndedWithCR = false;
    this.on("pipe", function(src) {
      if (!this.encoding) {
        if (src instanceof stream.Readable) {
          this.encoding = src._readableState.encoding;
        }
      }
    });
  }
  util2.inherits(LineStream, stream.Transform);
  LineStream.prototype._transform = function(chunk, encoding, done) {
    encoding = encoding || "utf8";
    if (Buffer.isBuffer(chunk)) {
      if (encoding == "buffer") {
        chunk = chunk.toString();
        encoding = "utf8";
      } else {
        chunk = chunk.toString(encoding);
      }
    }
    this._chunkEncoding = encoding;
    var lines = chunk.split(/\r\n|\r|\n/g);
    if (this._lastChunkEndedWithCR && chunk[0] == "\n") {
      lines.shift();
    }
    if (this._lineBuffer.length > 0) {
      this._lineBuffer[this._lineBuffer.length - 1] += lines[0];
      lines.shift();
    }
    this._lastChunkEndedWithCR = chunk[chunk.length - 1] == "\r";
    this._lineBuffer = this._lineBuffer.concat(lines);
    this._pushBuffer(encoding, 1, done);
  };
  LineStream.prototype._pushBuffer = function(encoding, keep, done) {
    while (this._lineBuffer.length > keep) {
      var line = this._lineBuffer.shift();
      if (this._keepEmptyLines || line.length > 0) {
        if (!this.push(this._reencode(line, encoding))) {
          var self2 = this;
          setImmediate(function() {
            self2._pushBuffer(encoding, keep, done);
          });
          return;
        }
      }
    }
    done();
  };
  LineStream.prototype._flush = function(done) {
    this._pushBuffer(this._chunkEncoding, 0, done);
  };
  LineStream.prototype._reencode = function(line, chunkEncoding) {
    if (this.encoding && this.encoding != chunkEncoding) {
      return Buffer.from(line, chunkEncoding).toString(this.encoding);
    } else if (this.encoding) {
      return line;
    } else {
      return Buffer.from(line, chunkEncoding);
    }
  };
});

// ../migrate/dist/MigrateEngine.js
var require_MigrateEngine = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    EngineError: () => EngineError,
    MigrateEngine: () => MigrateEngine2
  });
  var import_debug3 = __toModule3(require_dist13());
  var import_sdk18 = __toModule3(require_dist12());
  var import_chalk14 = __toModule3(require_source());
  var import_child_process2 = __toModule3(require("child_process"));
  var import_byline2 = __toModule3(require_byline4());
  var debugRpc = (0, import_debug3.default)("prisma:migrateEngine:rpc");
  var debugStderr = (0, import_debug3.default)("prisma:migrateEngine:stderr");
  var debugStdin = (0, import_debug3.default)("prisma:migrateEngine:stdin");
  var EngineError = class extends Error {
    constructor(message, code) {
      super(message);
      this.code = code;
    }
  };
  var messageId = 1;
  var MigrateEngine2 = class {
    constructor({
      projectDir,
      debug: debug3 = false,
      schemaPath,
      enabledPreviewFeatures
    }) {
      this.listeners = {};
      this.messages = [];
      this.lastError = null;
      this.projectDir = projectDir;
      this.schemaPath = schemaPath;
      if (debug3) {
        import_debug3.default.enable("MigrateEngine*");
      }
      this.debug = debug3;
      this.enabledPreviewFeatures = enabledPreviewFeatures;
    }
    stop() {
      this.child.kill();
    }
    devDiagnostic(args2) {
      return this.runCommand(this.getRPCPayload("devDiagnostic", args2));
    }
    listMigrationDirectories(args2) {
      return this.runCommand(this.getRPCPayload("listMigrationDirectories", args2));
    }
    markMigrationApplied(args2) {
      return this.runCommand(this.getRPCPayload("markMigrationApplied", args2));
    }
    markMigrationRolledBack(args2) {
      return this.runCommand(this.getRPCPayload("markMigrationRolledBack", args2));
    }
    diagnoseMigrationHistory(args2) {
      return this.runCommand(this.getRPCPayload("diagnoseMigrationHistory", args2));
    }
    planMigration(args2) {
      return this.runCommand(this.getRPCPayload("planMigration", args2));
    }
    evaluateDataLoss(args2) {
      return this.runCommand(this.getRPCPayload("evaluateDataLoss", args2));
    }
    createMigration(args2) {
      return this.runCommand(this.getRPCPayload("createMigration", args2));
    }
    applyMigrations(args2) {
      return this.runCommand(this.getRPCPayload("applyMigrations", args2));
    }
    reset() {
      return this.runCommand(this.getRPCPayload("reset", void 0));
    }
    getDatabaseVersion() {
      return this.runCommand(this.getRPCPayload("getDatabaseVersion", void 0));
    }
    schemaPush(args2) {
      return this.runCommand(this.getRPCPayload("schemaPush", args2));
    }
    debugPanic() {
      return this.runCommand(this.getRPCPayload("debugPanic", void 0));
    }
    rejectAll(err) {
      Object.entries(this.listeners).map(([id, listener]) => {
        listener(null, err);
        delete this.listeners[id];
      });
    }
    registerCallback(id, callback) {
      this.listeners[id] = callback;
    }
    handleResponse(response) {
      let result;
      try {
        result = JSON.parse(response);
      } catch (e) {
        console.error(`Could not parse migration engine response: ${response.slice(0, 200)}`);
      }
      if (result) {
        if (result.id) {
          if (!this.listeners[result.id]) {
            console.error(`Got result for unknown id ${result.id}`);
          }
          if (this.listeners[result.id]) {
            this.listeners[result.id](result);
            delete this.listeners[result.id];
          }
        } else {
          if (result.is_panic) {
            throw new Error(`Response: ${result.message}`);
          } else if (result.message) {
            console.error(import_chalk14.default.red(`Response: ${result.message}`));
          } else {
            console.error(import_chalk14.default.red(`Response: ${JSON.stringify(result)}`));
          }
        }
      }
    }
    init() {
      if (!this.initPromise) {
        this.initPromise = this.internalInit();
      }
      return this.initPromise;
    }
    internalInit() {
      return new Promise(async (resolve, reject) => {
        try {
          const {PWD, ...rest} = process.env;
          const binaryPath = await (0, import_sdk18.resolveBinary)(import_sdk18.BinaryType.migrationEngine);
          debugRpc("starting migration engine with binary: " + binaryPath);
          const args2 = ["-d", this.schemaPath];
          if (this.enabledPreviewFeatures && Array.isArray(this.enabledPreviewFeatures) && this.enabledPreviewFeatures.length > 0) {
            args2.push(...[
              "--enabled-preview-features",
              this.enabledPreviewFeatures.join(",")
            ]);
          }
          this.child = (0, import_child_process2.spawn)(binaryPath, args2, {
            cwd: this.projectDir,
            stdio: ["pipe", "pipe", this.debug ? process.stderr : "pipe"],
            env: {
              ...rest,
              SERVER_ROOT: this.projectDir,
              RUST_LOG: "info",
              RUST_BACKTRACE: "1"
            }
          });
          this.child.on("error", (err) => {
            console.error("[migration-engine] error: %s", err);
            this.rejectAll(err);
            reject(err);
          });
          this.child.on("exit", (code) => {
            var _a;
            const exitWithErr = (err) => {
              this.rejectAll(err);
              reject(err);
            };
            const engineMessage = ((_a = this.lastError) == null ? void 0 : _a.message) || this.messages.join("\n");
            const handlePanic3 = () => {
              const stackTrace = this.messages.join("\n");
              exitWithErr(new import_sdk18.RustPanic(serializePanic(engineMessage), stackTrace, this.lastRequest, import_sdk18.ErrorArea.LIFT_CLI, this.schemaPath));
            };
            switch (code) {
              case import_sdk18.MigrateEngineExitCode.Success:
                break;
              case import_sdk18.MigrateEngineExitCode.Error:
                exitWithErr(new Error(`Error in migration engine: ${engineMessage}`));
                break;
              case import_sdk18.MigrateEngineExitCode.Panic:
                handlePanic3();
                break;
              default:
                handlePanic3();
            }
          });
          this.child.stdin.on("error", (err) => {
            debugStdin(err);
          });
          (0, import_byline2.default)(this.child.stderr).on("data", (msg) => {
            var _a;
            const data = String(msg);
            debugStderr(data);
            try {
              const json = JSON.parse(data);
              if (((_a = json.fields) == null ? void 0 : _a.migrate_action) === "log") {
              }
              this.messages.push(json.fields.message);
              if (json.level === "ERROR") {
                this.lastError = json.fields;
              }
            } catch (e) {
            }
          });
          (0, import_byline2.default)(this.child.stdout).on("data", (line) => {
            this.handleResponse(String(line));
          });
          setImmediate(() => {
            resolve();
          });
        } catch (e) {
          reject(e);
        }
      });
    }
    async runCommand(request) {
      var _a;
      if (process.env.FORCE_PANIC_MIGRATION_ENGINE) {
        request = this.getRPCPayload("debugPanic", void 0);
      }
      await this.init();
      if ((_a = this.child) == null ? void 0 : _a.killed) {
        throw new Error(`Can't execute ${JSON.stringify(request)} because migration engine already exited.`);
      }
      return new Promise((resolve, reject) => {
        this.registerCallback(request.id, (response, err) => {
          var _a2, _b, _c, _d, _e, _f;
          if (err) {
            return reject(err);
          }
          if (response.result !== void 0) {
            resolve(response.result);
          } else {
            if (response.error) {
              debugRpc(response);
              if ((_a2 = response.error.data) == null ? void 0 : _a2.is_panic) {
                const message = (_d = (_c = (_b = response.error.data) == null ? void 0 : _b.error) == null ? void 0 : _c.message) != null ? _d : response.error.message;
                reject(new import_sdk18.RustPanic(message, response.error.data.message, this.lastRequest, import_sdk18.ErrorArea.LIFT_CLI, this.schemaPath));
              } else if ((_e = response.error.data) == null ? void 0 : _e.message) {
                let message = `${import_chalk14.default.redBright(response.error.data.message)}
`;
                if ((_f = response.error.data) == null ? void 0 : _f.error_code) {
                  message = import_chalk14.default.redBright(`${response.error.data.error_code}

`) + message;
                  reject(new EngineError(message, response.error.data.error_code));
                } else {
                  reject(new Error(message));
                }
              } else {
                reject(new Error(`${import_chalk14.default.redBright("Error in RPC")}
 Request: ${JSON.stringify(request, null, 2)}
Response: ${JSON.stringify(response, null, 2)}
${response.error.message}
`));
              }
            } else {
              reject(new Error(`Got invalid RPC response without .result property: ${JSON.stringify(response)}`));
            }
          }
        });
        if (this.child.stdin.destroyed) {
          throw new Error(`Can't execute ${JSON.stringify(request)} because migration engine is destroyed.`);
        }
        debugRpc("SENDING RPC CALL", JSON.stringify(request));
        this.child.stdin.write(JSON.stringify(request) + "\n");
        this.lastRequest = request;
      });
    }
    getRPCPayload(method, params) {
      return {
        id: messageId++,
        jsonrpc: "2.0",
        method,
        params: {
          ...params
        }
      };
    }
  };
  function serializePanic(log2) {
    return `${import_chalk14.default.red.bold("Error in migration engine.\nReason: ")}${import_chalk14.default.red(`${log2}`)}

Please create an issue with your \`schema.prisma\` at
${import_chalk14.default.underline("https://github.com/prisma/prisma/issues/new")}
`;
  }
});

// ../migrate/dist/utils/formatms.js
var require_formatms = __commonJS((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    formatms: () => formatms2
  });
  function formatms2(ms2) {
    if (ms2 < 1e3) {
      return `${ms2}ms`;
    }
    return (ms2 / 1e3).toFixed(2) + "s";
  }
});

// ../../node_modules/.pnpm/@prisma+engines-version@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/engines-version/package.json
var require_package = __commonJS((exports2, module2) => {
  module2.exports = {
    name: "@prisma/engines-version",
    version: "2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20",
    main: "index.js",
    types: "index.d.ts",
    license: "Apache-2.0",
    author: "Tim Suchanek <suchanek@prisma.io>",
    prisma: {
      enginesVersion: "b8c35d44de987a9691890b3ddf3e2e7effb9bf20"
    },
    devDependencies: {
      "@types/node": "14.17.11",
      typescript: "4.3.5"
    },
    files: [
      "index.js",
      "index.d.ts"
    ],
    scripts: {
      build: "tsc -d"
    }
  };
});

// ../../node_modules/.pnpm/@prisma+engines-version@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/engines-version/index.js
var require_engines_version = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.enginesVersion = void 0;
  exports2.enginesVersion = require_package().prisma.enginesVersion;
});

// ../migrate/dist/utils/errors.js
var require_errors3 = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    DbNeedsForceError: () => DbNeedsForceError,
    DbPushForceFlagRenamedError: () => DbPushForceFlagRenamedError,
    DbPushIgnoreWarningsWithFlagError: () => DbPushIgnoreWarningsWithFlagError,
    HowToBaselineError: () => HowToBaselineError,
    MigrateDevEnvNonInteractiveError: () => MigrateDevEnvNonInteractiveError,
    MigrateNeedsForceError: () => MigrateNeedsForceError,
    MigrateResetEnvNonInteractiveError: () => MigrateResetEnvNonInteractiveError,
    NoSchemaFoundError: () => NoSchemaFoundError,
    OldMigrateDetectedError: () => OldMigrateDetectedError
  });
  var import_chalk14 = __toModule3(require_source());
  var import_sdk18 = __toModule3(require_dist12());
  var NoSchemaFoundError = class extends Error {
    constructor() {
      super(`Could not find a ${import_chalk14.default.bold("schema.prisma")} file that is required for this command.
You can either provide it with ${import_chalk14.default.greenBright("--schema")}, set it as \`prisma.schema\` in your package.json or put it into the default location ${import_chalk14.default.greenBright("./prisma/schema.prisma")} ${(0, import_sdk18.link)("https://pris.ly/d/prisma-schema-location")}`);
    }
  };
  var OldMigrateDetectedError = class extends Error {
    constructor() {
      super(`The migrations folder contains migration files from an older version of Prisma Migrate which is not compatible.

Read more about how to upgrade to the new version of Migrate:
${(0, import_sdk18.link)("https://pris.ly/d/migrate-upgrade")}`);
    }
  };
  var HowToBaselineError = class extends Error {
    constructor() {
      super(`Read more about how to baseline an existing production database:
${(0, import_sdk18.link)("https://pris.ly/d/migrate-baseline")}`);
    }
  };
  var DbPushForceFlagRenamedError = class extends Error {
    constructor() {
      super(`The --force flag was renamed to --accept-data-loss in 2.17.0, use ${import_chalk14.default.bold.greenBright((0, import_sdk18.getCommandWithExecutor)("prisma db push --accept-data-loss"))}`);
    }
  };
  var DbPushIgnoreWarningsWithFlagError = class extends Error {
    constructor() {
      super(`Use the --accept-data-loss flag to ignore the data loss warnings like ${import_chalk14.default.bold.greenBright((0, import_sdk18.getCommandWithExecutor)("prisma db push --accept-data-loss"))}`);
    }
  };
  var MigrateNeedsForceError = class extends Error {
    constructor(subcommand) {
      super(`Use the --force flag to use the ${subcommand} command in an unnattended environment like ${import_chalk14.default.bold.greenBright((0, import_sdk18.getCommandWithExecutor)(`prisma migrate ${subcommand} --force`))}`);
    }
  };
  var MigrateResetEnvNonInteractiveError = class extends Error {
    constructor() {
      super(`Prisma Migrate has detected that the environment is non-interactive. It is recommended to run this command in an interactive environment.

Use ${import_chalk14.default.bold.greenBright(`--force`)} to run this command without user interaction.
See ${(0, import_sdk18.link)("https://www.prisma.io/docs/reference/api-reference/command-reference#migrate-reset")}`);
    }
  };
  var MigrateDevEnvNonInteractiveError = class extends Error {
    constructor() {
      super(`Prisma Migrate has detected that the environment is non-interactive, which is not supported.

\`prisma migrate dev\` is an interactive command designed to create new migrations and evolve the database in development.
To apply existing migrations in deployments, use ${import_chalk14.default.bold.greenBright(`prisma migrate deploy`)}.
See ${(0, import_sdk18.link)("https://www.prisma.io/docs/reference/api-reference/command-reference#migrate-deploy")}`);
    }
  };
  var DbNeedsForceError = class extends Error {
    constructor(subcommand) {
      super(`Use the --force flag to use the ${subcommand} command in an unnattended environment like ${import_chalk14.default.bold.greenBright((0, import_sdk18.getCommandWithExecutor)(`prisma db ${subcommand} --force --preview-feature`))}`);
    }
  };
});

// ../migrate/dist/Migrate.js
var require_Migrate = __commonJS((exports, module) => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name in all)
      __defProp(target, name, {get: all[name], enumerable: true});
  };
  var __reExport = (target, module2, desc) => {
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
      for (let key of __getOwnPropNames(module2))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule = (module2) => {
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
  };
  __export(exports, {
    Migrate: () => Migrate
  });
  var import_sdk = __toModule(require_dist12());
  var import_sdk2 = __toModule(require_dist12());
  var import_chalk = __toModule(require_source());
  var import_debug = __toModule(require_dist13());
  var import_fs = __toModule(require("fs"));
  var import_log_update = __toModule(require_log_update());
  var import_path = __toModule(require("path"));
  var import_MigrateEngine = __toModule(require_MigrateEngine());
  var import_formatms = __toModule(require_formatms());
  var import_engines_version = __toModule(require_engines_version());
  var import_errors = __toModule(require_errors3());
  var debug = (0, import_debug.default)("prisma:migrate");
  var packageJson = eval(`require('../package.json')`);
  var Migrate = class {
    get devMigrationsDir() {
      return import_path.default.join(import_path.default.dirname(this.schemaPath), "migrations/dev");
    }
    constructor(schemaPath, enabledPreviewFeatures) {
      this.schemaPath = this.getSchemaPath(schemaPath);
      this.migrationsDirectoryPath = import_path.default.join(import_path.default.dirname(this.schemaPath), "migrations");
      this.engine = new import_MigrateEngine.MigrateEngine({
        projectDir: import_path.default.dirname(this.schemaPath),
        schemaPath: this.schemaPath,
        enabledPreviewFeatures
      });
    }
    stop() {
      this.engine.stop();
    }
    getSchemaPath(schemaPathFromOptions) {
      const schemaPath = (0, import_sdk2.getSchemaPathSync)(schemaPathFromOptions);
      if (!schemaPath) {
        throw new import_errors.NoSchemaFoundError();
      }
      return schemaPath;
    }
    getDatamodel() {
      return import_fs.default.readFileSync(this.schemaPath, "utf-8");
    }
    reset() {
      return this.engine.reset();
    }
    createMigration(params) {
      return this.engine.createMigration(params);
    }
    diagnoseMigrationHistory({
      optInToShadowDatabase
    }) {
      return this.engine.diagnoseMigrationHistory({
        migrationsDirectoryPath: this.migrationsDirectoryPath,
        optInToShadowDatabase
      });
    }
    listMigrationDirectories() {
      return this.engine.listMigrationDirectories({
        migrationsDirectoryPath: this.migrationsDirectoryPath
      });
    }
    devDiagnostic() {
      return this.engine.devDiagnostic({
        migrationsDirectoryPath: this.migrationsDirectoryPath
      });
    }
    async markMigrationApplied({
      migrationId
    }) {
      return await this.engine.markMigrationApplied({
        migrationsDirectoryPath: this.migrationsDirectoryPath,
        migrationName: migrationId
      });
    }
    markMigrationRolledBack({
      migrationId
    }) {
      return this.engine.markMigrationRolledBack({
        migrationName: migrationId
      });
    }
    applyMigrations() {
      return this.engine.applyMigrations({
        migrationsDirectoryPath: this.migrationsDirectoryPath
      });
    }
    evaluateDataLoss() {
      const datamodel = this.getDatamodel();
      return this.engine.evaluateDataLoss({
        migrationsDirectoryPath: this.migrationsDirectoryPath,
        prismaSchema: datamodel
      });
    }
    async push({
      force = false
    }) {
      const datamodel = this.getDatamodel();
      const {warnings, unexecutable, executedSteps} = await this.engine.schemaPush({
        force,
        schema: datamodel
      });
      return {
        executedSteps,
        warnings,
        unexecutable
      };
    }
    async tryToRunGenerate() {
      var _a;
      const message = [];
      console.info();
      (0, import_log_update.default)(`Running generate... ${import_chalk.default.dim("(Use --skip-generate to skip the generators)")}`);
      const generators = await (0, import_sdk2.getGenerators)({
        schemaPath: this.schemaPath,
        printDownloadProgress: true,
        version: import_engines_version.enginesVersion,
        cliVersion: packageJson.version
      });
      for (const generator of generators) {
        const toStr = generator.options.generator.output ? import_chalk.default.dim(` to .${import_path.default.sep}${import_path.default.relative(process.cwd(), (0, import_sdk.parseEnvValue)(generator.options.generator.output))}`) : "";
        const name = generator.manifest ? generator.manifest.prettyName : (0, import_sdk.parseEnvValue)(generator.options.generator.provider);
        (0, import_log_update.default)(`Running generate... - ${name}`);
        const before = Date.now();
        try {
          await generator.generate();
          const after = Date.now();
          const version = (_a = generator.manifest) == null ? void 0 : _a.version;
          message.push(`\u2714 Generated ${import_chalk.default.bold(name)}${version ? ` (${version})` : ""}${toStr} in ${(0, import_formatms.formatms)(after - before)}`);
          generator.stop();
        } catch (err) {
          message.push(`${err.message}`);
          generator.stop();
        }
      }
      (0, import_log_update.default)(message.join("\n"));
    }
  };
});

// ../migrate/dist/utils/flagErrors.js
var require_flagErrors = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    EarlyAccessFeatureFlagWithNewMigrateError: () => EarlyAccessFeatureFlagWithNewMigrateError,
    EarlyAcessFlagError: () => EarlyAcessFlagError,
    ExperimentalFlagError: () => ExperimentalFlagError,
    ExperimentalFlagWithNewMigrateError: () => ExperimentalFlagWithNewMigrateError,
    PreviewFlagError: () => PreviewFlagError
  });
  var import_chalk14 = __toModule3(require_source());
  var ExperimentalFlagError = class extends Error {
    constructor() {
      super(`Please provide the ${import_chalk14.default.green("--experimental")} flag to use this command.`);
    }
  };
  var PreviewFlagError = class extends Error {
    constructor() {
      super(`This feature is currently in Preview. There may be bugs and it's not recommended to use it in production environments.
Please provide the ${import_chalk14.default.green("--preview-feature")} flag to use this command.`);
    }
  };
  var EarlyAcessFlagError = class extends Error {
    constructor() {
      super(`This feature is currently in Early Access. There may be bugs and it's not recommended to use it in production environments.
Please provide the ${import_chalk14.default.green("--early-access-feature")} flag to use this command.`);
    }
  };
  var ExperimentalFlagWithNewMigrateError = class extends Error {
    constructor() {
      super(`Prisma Migrate was Experimental and is now Generally Available.
${import_chalk14.default.yellow("WARNING this new version has some breaking changes")} to use it it's recommended to read the documentation first and remove the ${import_chalk14.default.red("--experimental")} flag.`);
    }
  };
  var EarlyAccessFeatureFlagWithNewMigrateError = class extends Error {
    constructor() {
      super(`Prisma Migrate was in Early Access and is now in Preview.
Replace the ${import_chalk14.default.red("--early-access-feature")} flag with ${import_chalk14.default.green("--preview-feature")}.`);
    }
  };
});

// ../migrate/dist/commands/MigrateCommand.js
var require_MigrateCommand = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    MigrateCommand: () => MigrateCommand3
  });
  var import_sdk18 = __toModule3(require_dist12());
  var import_chalk14 = __toModule3(require_source());
  var import_flagErrors = __toModule3(require_flagErrors());
  var _MigrateCommand = class {
    constructor(cmds) {
      this.cmds = cmds;
    }
    static new(cmds) {
      return new _MigrateCommand(cmds);
    }
    async parse(argv) {
      const args2 = (0, import_sdk18.arg)(argv, {
        "--help": Boolean,
        "-h": "--help",
        "--experimental": Boolean,
        "--preview-feature": Boolean,
        "--early-access-feature": Boolean,
        "--telemetry-information": String
      });
      if ((0, import_sdk18.isError)(args2)) {
        return this.help(args2.message);
      }
      if (args2["--experimental"]) {
        throw new import_flagErrors.ExperimentalFlagWithNewMigrateError();
      }
      if (args2._.length === 0 || args2["--help"]) {
        return this.help();
      }
      if (["up", "save", "down"].includes(args2._[0])) {
        throw new Error(`The current command "${args2._[0]}" doesn't exist in the new version of Prisma Migrate.
Read more about how to upgrade: ${(0, import_sdk18.link)("https://pris.ly/d/migrate-upgrade")}`);
      }
      if (args2["--preview-feature"]) {
        import_sdk18.logger.warn(`Prisma Migrate was in Preview and is now Generally Available.
You can now remove the ${import_chalk14.default.red("--preview-feature")} flag.`);
      }
      const filteredArgs = args2._.filter((item) => item !== "--preview-feature");
      const cmd = this.cmds[filteredArgs[0]];
      if (cmd) {
        return cmd.parse(filteredArgs.slice(1));
      }
      return (0, import_sdk18.unknownCommand)(_MigrateCommand.help, args2._[0]);
    }
    help(error) {
      if (error) {
        return new import_sdk18.HelpError(`
${import_chalk14.default.bold.red(`!`)} ${error}
${_MigrateCommand.help}`);
      }
      return _MigrateCommand.help;
    }
  };
  var MigrateCommand3 = _MigrateCommand;
  MigrateCommand3.help = (0, import_sdk18.format)(`
Update the database schema with migrations
  
${import_chalk14.default.bold("Usage")}

  ${import_chalk14.default.dim("$")} prisma migrate [command] [options]

${import_chalk14.default.bold("Commands for development")}

         dev   Create a migration from changes in Prisma schema, apply it to the database
               trigger generators (e.g. Prisma Client)
       reset   Reset your database and apply all migrations, all data will be lost

${import_chalk14.default.bold("Commands for production/staging")}

      deploy   Apply pending migrations to the database 
      status   Check the status of your database migrations
     resolve   Resolve issues with database migrations, i.e. baseline, failed migration, hotfix

${import_chalk14.default.bold("Options")}

  -h, --help   Display this help message
    --schema   Custom path to your Prisma schema

${import_chalk14.default.bold("Examples")}

  Create a migration from changes in Prisma schema, apply it to the database, trigger generators (e.g. Prisma Client)
  ${import_chalk14.default.dim("$")} prisma migrate dev

  Reset your database and apply all migrations
  ${import_chalk14.default.dim("$")} prisma migrate reset

  Apply pending migrations to the database in production/staging
  ${import_chalk14.default.dim("$")} prisma migrate deploy

  Check the status of migrations in the production/staging database
  ${import_chalk14.default.dim("$")} prisma migrate status

  Specify a schema
  ${import_chalk14.default.dim("$")} prisma migrate status --schema=./schema.prisma

`);
});

// ../../node_modules/.pnpm/kleur@3.0.3/node_modules/kleur/index.js
var require_kleur = __commonJS((exports2, module2) => {
  "use strict";
  var {FORCE_COLOR, NODE_DISABLE_COLORS, TERM} = process.env;
  var $ = {
    enabled: !NODE_DISABLE_COLORS && TERM !== "dumb" && FORCE_COLOR !== "0",
    reset: init(0, 0),
    bold: init(1, 22),
    dim: init(2, 22),
    italic: init(3, 23),
    underline: init(4, 24),
    inverse: init(7, 27),
    hidden: init(8, 28),
    strikethrough: init(9, 29),
    black: init(30, 39),
    red: init(31, 39),
    green: init(32, 39),
    yellow: init(33, 39),
    blue: init(34, 39),
    magenta: init(35, 39),
    cyan: init(36, 39),
    white: init(37, 39),
    gray: init(90, 39),
    grey: init(90, 39),
    bgBlack: init(40, 49),
    bgRed: init(41, 49),
    bgGreen: init(42, 49),
    bgYellow: init(43, 49),
    bgBlue: init(44, 49),
    bgMagenta: init(45, 49),
    bgCyan: init(46, 49),
    bgWhite: init(47, 49)
  };
  function run(arr, str) {
    let i = 0, tmp, beg = "", end = "";
    for (; i < arr.length; i++) {
      tmp = arr[i];
      beg += tmp.open;
      end += tmp.close;
      if (str.includes(tmp.close)) {
        str = str.replace(tmp.rgx, tmp.close + tmp.open);
      }
    }
    return beg + str + end;
  }
  function chain(has, keys) {
    let ctx = {has, keys};
    ctx.reset = $.reset.bind(ctx);
    ctx.bold = $.bold.bind(ctx);
    ctx.dim = $.dim.bind(ctx);
    ctx.italic = $.italic.bind(ctx);
    ctx.underline = $.underline.bind(ctx);
    ctx.inverse = $.inverse.bind(ctx);
    ctx.hidden = $.hidden.bind(ctx);
    ctx.strikethrough = $.strikethrough.bind(ctx);
    ctx.black = $.black.bind(ctx);
    ctx.red = $.red.bind(ctx);
    ctx.green = $.green.bind(ctx);
    ctx.yellow = $.yellow.bind(ctx);
    ctx.blue = $.blue.bind(ctx);
    ctx.magenta = $.magenta.bind(ctx);
    ctx.cyan = $.cyan.bind(ctx);
    ctx.white = $.white.bind(ctx);
    ctx.gray = $.gray.bind(ctx);
    ctx.grey = $.grey.bind(ctx);
    ctx.bgBlack = $.bgBlack.bind(ctx);
    ctx.bgRed = $.bgRed.bind(ctx);
    ctx.bgGreen = $.bgGreen.bind(ctx);
    ctx.bgYellow = $.bgYellow.bind(ctx);
    ctx.bgBlue = $.bgBlue.bind(ctx);
    ctx.bgMagenta = $.bgMagenta.bind(ctx);
    ctx.bgCyan = $.bgCyan.bind(ctx);
    ctx.bgWhite = $.bgWhite.bind(ctx);
    return ctx;
  }
  function init(open3, close2) {
    let blk = {
      open: `[${open3}m`,
      close: `[${close2}m`,
      rgx: new RegExp(`\\x1b\\[${close2}m`, "g")
    };
    return function(txt) {
      if (this !== void 0 && this.has !== void 0) {
        this.has.includes(open3) || (this.has.push(open3), this.keys.push(blk));
        return txt === void 0 ? this : $.enabled ? run(this.keys, txt + "") : txt + "";
      }
      return txt === void 0 ? chain([open3], [blk]) : $.enabled ? run([blk], txt + "") : txt + "";
    };
  }
  module2.exports = $;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/dist/util/action.js
var require_action = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (key, isSelect) => {
    if (key.meta && key.name !== "escape")
      return;
    if (key.ctrl) {
      if (key.name === "a")
        return "first";
      if (key.name === "c")
        return "abort";
      if (key.name === "d")
        return "abort";
      if (key.name === "e")
        return "last";
      if (key.name === "g")
        return "reset";
    }
    if (isSelect) {
      if (key.name === "j")
        return "down";
      if (key.name === "k")
        return "up";
    }
    if (key.name === "return")
      return "submit";
    if (key.name === "enter")
      return "submit";
    if (key.name === "backspace")
      return "delete";
    if (key.name === "delete")
      return "deleteForward";
    if (key.name === "abort")
      return "abort";
    if (key.name === "escape")
      return "exit";
    if (key.name === "tab")
      return "next";
    if (key.name === "pagedown")
      return "nextPage";
    if (key.name === "pageup")
      return "prevPage";
    if (key.name === "home")
      return "home";
    if (key.name === "end")
      return "end";
    if (key.name === "up")
      return "up";
    if (key.name === "down")
      return "down";
    if (key.name === "right")
      return "right";
    if (key.name === "left")
      return "left";
    return false;
  };
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/dist/util/strip.js
var require_strip = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (str) => {
    const pattern = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[a-zA-Z\\d]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))"].join("|");
    const RGX = new RegExp(pattern, "g");
    return typeof str === "string" ? str.replace(RGX, "") : str;
  };
});

// ../../node_modules/.pnpm/sisteransi@1.0.5/node_modules/sisteransi/src/index.js
var require_src4 = __commonJS((exports2, module2) => {
  "use strict";
  var ESC = "";
  var CSI = `${ESC}[`;
  var beep = "\x07";
  var cursor = {
    to(x, y2) {
      if (!y2)
        return `${CSI}${x + 1}G`;
      return `${CSI}${y2 + 1};${x + 1}H`;
    },
    move(x, y2) {
      let ret = "";
      if (x < 0)
        ret += `${CSI}${-x}D`;
      else if (x > 0)
        ret += `${CSI}${x}C`;
      if (y2 < 0)
        ret += `${CSI}${-y2}A`;
      else if (y2 > 0)
        ret += `${CSI}${y2}B`;
      return ret;
    },
    up: (count = 1) => `${CSI}${count}A`,
    down: (count = 1) => `${CSI}${count}B`,
    forward: (count = 1) => `${CSI}${count}C`,
    backward: (count = 1) => `${CSI}${count}D`,
    nextLine: (count = 1) => `${CSI}E`.repeat(count),
    prevLine: (count = 1) => `${CSI}F`.repeat(count),
    left: `${CSI}G`,
    hide: `${CSI}?25l`,
    show: `${CSI}?25h`,
    save: `${ESC}7`,
    restore: `${ESC}8`
  };
  var scroll = {
    up: (count = 1) => `${CSI}S`.repeat(count),
    down: (count = 1) => `${CSI}T`.repeat(count)
  };
  var erase = {
    screen: `${CSI}2J`,
    up: (count = 1) => `${CSI}1J`.repeat(count),
    down: (count = 1) => `${CSI}J`.repeat(count),
    line: `${CSI}2K`,
    lineEnd: `${CSI}K`,
    lineStart: `${CSI}1K`,
    lines(count) {
      let clear = "";
      for (let i = 0; i < count; i++)
        clear += this.line + (i < count - 1 ? cursor.up() : "");
      if (count)
        clear += cursor.left;
      return clear;
    }
  };
  module2.exports = {cursor, scroll, erase, beep};
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/dist/util/clear.js
var require_clear = __commonJS((exports2, module2) => {
  "use strict";
  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s2() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++)
      arr2[i] = arr[i];
    return arr2;
  }
  var strip = require_strip();
  var _require = require_src4();
  var erase = _require.erase;
  var cursor = _require.cursor;
  var width = (str) => [...strip(str)].length;
  module2.exports = function(prompt, perLine) {
    if (!perLine)
      return erase.line + cursor.to(0);
    let rows = 0;
    const lines = prompt.split(/\r?\n/);
    var _iterator = _createForOfIteratorHelper(lines), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        let line = _step.value;
        rows += 1 + Math.floor(Math.max(width(line) - 1, 0) / perLine);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return erase.lines(rows);
  };
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/dist/util/figures.js
var require_figures = __commonJS((exports2, module2) => {
  "use strict";
  var main2 = {
    arrowUp: "\u2191",
    arrowDown: "\u2193",
    arrowLeft: "\u2190",
    arrowRight: "\u2192",
    radioOn: "\u25C9",
    radioOff: "\u25EF",
    tick: "\u2714",
    cross: "\u2716",
    ellipsis: "\u2026",
    pointerSmall: "\u203A",
    line: "\u2500",
    pointer: "\u276F"
  };
  var win = {
    arrowUp: main2.arrowUp,
    arrowDown: main2.arrowDown,
    arrowLeft: main2.arrowLeft,
    arrowRight: main2.arrowRight,
    radioOn: "(*)",
    radioOff: "( )",
    tick: "\u221A",
    cross: "\xD7",
    ellipsis: "...",
    pointerSmall: "\xBB",
    line: "\u2500",
    pointer: ">"
  };
  var figures = process.platform === "win32" ? win : main2;
  module2.exports = figures;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/dist/util/style.js
var require_style = __commonJS((exports2, module2) => {
  "use strict";
  var c = require_kleur();
  var figures = require_figures();
  var styles = Object.freeze({
    password: {
      scale: 1,
      render: (input) => "*".repeat(input.length)
    },
    emoji: {
      scale: 2,
      render: (input) => "\u{1F603}".repeat(input.length)
    },
    invisible: {
      scale: 0,
      render: (input) => ""
    },
    default: {
      scale: 1,
      render: (input) => `${input}`
    }
  });
  var render = (type) => styles[type] || styles.default;
  var symbols = Object.freeze({
    aborted: c.red(figures.cross),
    done: c.green(figures.tick),
    exited: c.yellow(figures.cross),
    default: c.cyan("?")
  });
  var symbol = (done, aborted, exited) => aborted ? symbols.aborted : exited ? symbols.exited : done ? symbols.done : symbols.default;
  var delimiter = (completing) => c.gray(completing ? figures.ellipsis : figures.pointerSmall);
  var item = (expandable, expanded) => c.gray(expandable ? expanded ? figures.pointerSmall : "+" : figures.line);
  module2.exports = {
    styles,
    render,
    symbols,
    symbol,
    delimiter,
    item
  };
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/dist/util/lines.js
var require_lines = __commonJS((exports2, module2) => {
  "use strict";
  var strip = require_strip();
  module2.exports = function(msg, perLine) {
    let lines = String(strip(msg) || "").split(/\r?\n/);
    if (!perLine)
      return lines.length;
    return lines.map((l) => Math.ceil(l.length / perLine)).reduce((a, b) => a + b);
  };
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/dist/util/wrap.js
var require_wrap = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (msg, opts = {}) => {
    const tab = Number.isSafeInteger(parseInt(opts.margin)) ? new Array(parseInt(opts.margin)).fill(" ").join("") : opts.margin || "";
    const width = opts.width;
    return (msg || "").split(/\r?\n/g).map((line) => line.split(/\s+/g).reduce((arr, w2) => {
      if (w2.length + tab.length >= width || arr[arr.length - 1].length + w2.length + 1 < width)
        arr[arr.length - 1] += ` ${w2}`;
      else
        arr.push(`${tab}${w2}`);
      return arr;
    }, [tab]).join("\n")).join("\n");
  };
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/dist/util/entriesToDisplay.js
var require_entriesToDisplay = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (cursor, total, maxVisible) => {
    maxVisible = maxVisible || total;
    let startIndex = Math.min(total - maxVisible, cursor - Math.floor(maxVisible / 2));
    if (startIndex < 0)
      startIndex = 0;
    let endIndex = Math.min(startIndex + maxVisible, total);
    return {
      startIndex,
      endIndex
    };
  };
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/dist/util/index.js
var require_util8 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    action: require_action(),
    clear: require_clear(),
    style: require_style(),
    strip: require_strip(),
    figures: require_figures(),
    lines: require_lines(),
    wrap: require_wrap(),
    entriesToDisplay: require_entriesToDisplay()
  };
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/dist/elements/prompt.js
var require_prompt = __commonJS((exports2, module2) => {
  "use strict";
  var readline = require("readline");
  var _require = require_util8();
  var action = _require.action;
  var EventEmitter = require("events");
  var _require2 = require_src4();
  var beep = _require2.beep;
  var cursor = _require2.cursor;
  var color = require_kleur();
  var Prompt = class extends EventEmitter {
    constructor(opts = {}) {
      super();
      this.firstRender = true;
      this.in = opts.stdin || process.stdin;
      this.out = opts.stdout || process.stdout;
      this.onRender = (opts.onRender || (() => void 0)).bind(this);
      const rl = readline.createInterface({
        input: this.in,
        escapeCodeTimeout: 50
      });
      readline.emitKeypressEvents(this.in, rl);
      if (this.in.isTTY)
        this.in.setRawMode(true);
      const isSelect = ["SelectPrompt", "MultiselectPrompt"].indexOf(this.constructor.name) > -1;
      const keypress = (str, key) => {
        let a = action(key, isSelect);
        if (a === false) {
          this._ && this._(str, key);
        } else if (typeof this[a] === "function") {
          this[a](key);
        } else {
          this.bell();
        }
      };
      this.close = () => {
        this.out.write(cursor.show);
        this.in.removeListener("keypress", keypress);
        if (this.in.isTTY)
          this.in.setRawMode(false);
        rl.close();
        this.emit(this.aborted ? "abort" : this.exited ? "exit" : "submit", this.value);
        this.closed = true;
      };
      this.in.on("keypress", keypress);
    }
    fire() {
      this.emit("state", {
        value: this.value,
        aborted: !!this.aborted,
        exited: !!this.exited
      });
    }
    bell() {
      this.out.write(beep);
    }
    render() {
      this.onRender(color);
      if (this.firstRender)
        this.firstRender = false;
    }
  };
  module2.exports = Prompt;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/dist/elements/text.js
var require_text = __commonJS((exports2, module2) => {
  "use strict";
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg10) {
    try {
      var info = gen[key](arg10);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function() {
      var self2 = this, args2 = arguments;
      return new Promise(function(resolve, reject) {
        var gen = fn.apply(self2, args2);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(void 0);
      });
    };
  }
  var color = require_kleur();
  var Prompt = require_prompt();
  var _require = require_src4();
  var erase = _require.erase;
  var cursor = _require.cursor;
  var _require2 = require_util8();
  var style = _require2.style;
  var clear = _require2.clear;
  var lines = _require2.lines;
  var figures = _require2.figures;
  var TextPrompt = class extends Prompt {
    constructor(opts = {}) {
      super(opts);
      this.transform = style.render(opts.style);
      this.scale = this.transform.scale;
      this.msg = opts.message;
      this.initial = opts.initial || ``;
      this.validator = opts.validate || (() => true);
      this.value = ``;
      this.errorMsg = opts.error || `Please Enter A Valid Value`;
      this.cursor = Number(!!this.initial);
      this.cursorOffset = 0;
      this.clear = clear(``, this.out.columns);
      this.render();
    }
    set value(v) {
      if (!v && this.initial) {
        this.placeholder = true;
        this.rendered = color.gray(this.transform.render(this.initial));
      } else {
        this.placeholder = false;
        this.rendered = this.transform.render(v);
      }
      this._value = v;
      this.fire();
    }
    get value() {
      return this._value;
    }
    reset() {
      this.value = ``;
      this.cursor = Number(!!this.initial);
      this.cursorOffset = 0;
      this.fire();
      this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.value = this.value || this.initial;
      this.done = this.aborted = true;
      this.error = false;
      this.red = false;
      this.fire();
      this.render();
      this.out.write("\n");
      this.close();
    }
    validate() {
      var _this = this;
      return _asyncToGenerator(function* () {
        let valid = yield _this.validator(_this.value);
        if (typeof valid === `string`) {
          _this.errorMsg = valid;
          valid = false;
        }
        _this.error = !valid;
      })();
    }
    submit() {
      var _this2 = this;
      return _asyncToGenerator(function* () {
        _this2.value = _this2.value || _this2.initial;
        _this2.cursorOffset = 0;
        _this2.cursor = _this2.rendered.length;
        yield _this2.validate();
        if (_this2.error) {
          _this2.red = true;
          _this2.fire();
          _this2.render();
          return;
        }
        _this2.done = true;
        _this2.aborted = false;
        _this2.fire();
        _this2.render();
        _this2.out.write("\n");
        _this2.close();
      })();
    }
    next() {
      if (!this.placeholder)
        return this.bell();
      this.value = this.initial;
      this.cursor = this.rendered.length;
      this.fire();
      this.render();
    }
    moveCursor(n) {
      if (this.placeholder)
        return;
      this.cursor = this.cursor + n;
      this.cursorOffset += n;
    }
    _(c, key) {
      let s1 = this.value.slice(0, this.cursor);
      let s2 = this.value.slice(this.cursor);
      this.value = `${s1}${c}${s2}`;
      this.red = false;
      this.cursor = this.placeholder ? 0 : s1.length + 1;
      this.render();
    }
    delete() {
      if (this.isCursorAtStart())
        return this.bell();
      let s1 = this.value.slice(0, this.cursor - 1);
      let s2 = this.value.slice(this.cursor);
      this.value = `${s1}${s2}`;
      this.red = false;
      if (this.isCursorAtStart()) {
        this.cursorOffset = 0;
      } else {
        this.cursorOffset++;
        this.moveCursor(-1);
      }
      this.render();
    }
    deleteForward() {
      if (this.cursor * this.scale >= this.rendered.length || this.placeholder)
        return this.bell();
      let s1 = this.value.slice(0, this.cursor);
      let s2 = this.value.slice(this.cursor + 1);
      this.value = `${s1}${s2}`;
      this.red = false;
      if (this.isCursorAtEnd()) {
        this.cursorOffset = 0;
      } else {
        this.cursorOffset++;
      }
      this.render();
    }
    first() {
      this.cursor = 0;
      this.render();
    }
    last() {
      this.cursor = this.value.length;
      this.render();
    }
    left() {
      if (this.cursor <= 0 || this.placeholder)
        return this.bell();
      this.moveCursor(-1);
      this.render();
    }
    right() {
      if (this.cursor * this.scale >= this.rendered.length || this.placeholder)
        return this.bell();
      this.moveCursor(1);
      this.render();
    }
    isCursorAtStart() {
      return this.cursor === 0 || this.placeholder && this.cursor === 1;
    }
    isCursorAtEnd() {
      return this.cursor === this.rendered.length || this.placeholder && this.cursor === this.rendered.length + 1;
    }
    render() {
      if (this.closed)
        return;
      if (!this.firstRender) {
        if (this.outputError)
          this.out.write(cursor.down(lines(this.outputError, this.out.columns) - 1) + clear(this.outputError, this.out.columns));
        this.out.write(clear(this.outputText, this.out.columns));
      }
      super.render();
      this.outputError = "";
      this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), this.red ? color.red(this.rendered) : this.rendered].join(` `);
      if (this.error) {
        this.outputError += this.errorMsg.split(`
`).reduce((a, l, i) => a + `
${i ? " " : figures.pointerSmall} ${color.red().italic(l)}`, ``);
      }
      this.out.write(erase.line + cursor.to(0) + this.outputText + cursor.save + this.outputError + cursor.restore + cursor.move(this.cursorOffset, 0));
    }
  };
  module2.exports = TextPrompt;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/dist/elements/select.js
var require_select = __commonJS((exports2, module2) => {
  "use strict";
  var color = require_kleur();
  var Prompt = require_prompt();
  var _require = require_util8();
  var style = _require.style;
  var clear = _require.clear;
  var figures = _require.figures;
  var wrap = _require.wrap;
  var entriesToDisplay = _require.entriesToDisplay;
  var _require2 = require_src4();
  var cursor = _require2.cursor;
  var SelectPrompt = class extends Prompt {
    constructor(opts = {}) {
      super(opts);
      this.msg = opts.message;
      this.hint = opts.hint || "- Use arrow-keys. Return to submit.";
      this.warn = opts.warn || "- This option is disabled";
      this.cursor = opts.initial || 0;
      this.choices = opts.choices.map((ch, idx) => {
        if (typeof ch === "string")
          ch = {
            title: ch,
            value: idx
          };
        return {
          title: ch && (ch.title || ch.value || ch),
          value: ch && (ch.value === void 0 ? idx : ch.value),
          description: ch && ch.description,
          selected: ch && ch.selected,
          disabled: ch && ch.disabled
        };
      });
      this.optionsPerPage = opts.optionsPerPage || 10;
      this.value = (this.choices[this.cursor] || {}).value;
      this.clear = clear("", this.out.columns);
      this.render();
    }
    moveCursor(n) {
      this.cursor = n;
      this.value = this.choices[n].value;
      this.fire();
    }
    reset() {
      this.moveCursor(0);
      this.fire();
      this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = true;
      this.fire();
      this.render();
      this.out.write("\n");
      this.close();
    }
    submit() {
      if (!this.selection.disabled) {
        this.done = true;
        this.aborted = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      } else
        this.bell();
    }
    first() {
      this.moveCursor(0);
      this.render();
    }
    last() {
      this.moveCursor(this.choices.length - 1);
      this.render();
    }
    up() {
      if (this.cursor === 0) {
        this.moveCursor(this.choices.length - 1);
      } else {
        this.moveCursor(this.cursor - 1);
      }
      this.render();
    }
    down() {
      if (this.cursor === this.choices.length - 1) {
        this.moveCursor(0);
      } else {
        this.moveCursor(this.cursor + 1);
      }
      this.render();
    }
    next() {
      this.moveCursor((this.cursor + 1) % this.choices.length);
      this.render();
    }
    _(c, key) {
      if (c === " ")
        return this.submit();
    }
    get selection() {
      return this.choices[this.cursor];
    }
    render() {
      if (this.closed)
        return;
      if (this.firstRender)
        this.out.write(cursor.hide);
      else
        this.out.write(clear(this.outputText, this.out.columns));
      super.render();
      let _entriesToDisplay = entriesToDisplay(this.cursor, this.choices.length, this.optionsPerPage), startIndex = _entriesToDisplay.startIndex, endIndex = _entriesToDisplay.endIndex;
      this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(false), this.done ? this.selection.title : this.selection.disabled ? color.yellow(this.warn) : color.gray(this.hint)].join(" ");
      if (!this.done) {
        this.outputText += "\n";
        for (let i = startIndex; i < endIndex; i++) {
          let title, prefix, desc = "", v = this.choices[i];
          if (i === startIndex && startIndex > 0) {
            prefix = figures.arrowUp;
          } else if (i === endIndex - 1 && endIndex < this.choices.length) {
            prefix = figures.arrowDown;
          } else {
            prefix = " ";
          }
          if (v.disabled) {
            title = this.cursor === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
            prefix = (this.cursor === i ? color.bold().gray(figures.pointer) + " " : "  ") + prefix;
          } else {
            title = this.cursor === i ? color.cyan().underline(v.title) : v.title;
            prefix = (this.cursor === i ? color.cyan(figures.pointer) + " " : "  ") + prefix;
            if (v.description && this.cursor === i) {
              desc = ` - ${v.description}`;
              if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
                desc = "\n" + wrap(v.description, {
                  margin: 3,
                  width: this.out.columns
                });
              }
            }
          }
          this.outputText += `${prefix} ${title}${color.gray(desc)}
`;
        }
      }
      this.out.write(this.outputText);
    }
  };
  module2.exports = SelectPrompt;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/dist/elements/toggle.js
var require_toggle = __commonJS((exports2, module2) => {
  "use strict";
  var color = require_kleur();
  var Prompt = require_prompt();
  var _require = require_util8();
  var style = _require.style;
  var clear = _require.clear;
  var _require2 = require_src4();
  var cursor = _require2.cursor;
  var erase = _require2.erase;
  var TogglePrompt = class extends Prompt {
    constructor(opts = {}) {
      super(opts);
      this.msg = opts.message;
      this.value = !!opts.initial;
      this.active = opts.active || "on";
      this.inactive = opts.inactive || "off";
      this.initialValue = this.value;
      this.render();
    }
    reset() {
      this.value = this.initialValue;
      this.fire();
      this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = true;
      this.fire();
      this.render();
      this.out.write("\n");
      this.close();
    }
    submit() {
      this.done = true;
      this.aborted = false;
      this.fire();
      this.render();
      this.out.write("\n");
      this.close();
    }
    deactivate() {
      if (this.value === false)
        return this.bell();
      this.value = false;
      this.render();
    }
    activate() {
      if (this.value === true)
        return this.bell();
      this.value = true;
      this.render();
    }
    delete() {
      this.deactivate();
    }
    left() {
      this.deactivate();
    }
    right() {
      this.activate();
    }
    down() {
      this.deactivate();
    }
    up() {
      this.activate();
    }
    next() {
      this.value = !this.value;
      this.fire();
      this.render();
    }
    _(c, key) {
      if (c === " ") {
        this.value = !this.value;
      } else if (c === "1") {
        this.value = true;
      } else if (c === "0") {
        this.value = false;
      } else
        return this.bell();
      this.render();
    }
    render() {
      if (this.closed)
        return;
      if (this.firstRender)
        this.out.write(cursor.hide);
      else
        this.out.write(clear(this.outputText, this.out.columns));
      super.render();
      this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), this.value ? this.inactive : color.cyan().underline(this.inactive), color.gray("/"), this.value ? color.cyan().underline(this.active) : this.active].join(" ");
      this.out.write(erase.line + cursor.to(0) + this.outputText);
    }
  };
  module2.exports = TogglePrompt;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/dist/dateparts/datepart.js
var require_datepart = __commonJS((exports2, module2) => {
  "use strict";
  var DatePart = class {
    constructor({
      token,
      date,
      parts,
      locales
    }) {
      this.token = token;
      this.date = date || new Date();
      this.parts = parts || [this];
      this.locales = locales || {};
    }
    up() {
    }
    down() {
    }
    next() {
      const currentIdx = this.parts.indexOf(this);
      return this.parts.find((part, idx) => idx > currentIdx && part instanceof DatePart);
    }
    setTo(val) {
    }
    prev() {
      let parts = [].concat(this.parts).reverse();
      const currentIdx = parts.indexOf(this);
      return parts.find((part, idx) => idx > currentIdx && part instanceof DatePart);
    }
    toString() {
      return String(this.date);
    }
  };
  module2.exports = DatePart;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/dist/dateparts/meridiem.js
var require_meridiem = __commonJS((exports2, module2) => {
  "use strict";
  var DatePart = require_datepart();
  var Meridiem = class extends DatePart {
    constructor(opts = {}) {
      super(opts);
    }
    up() {
      this.date.setHours((this.date.getHours() + 12) % 24);
    }
    down() {
      this.up();
    }
    toString() {
      let meridiem = this.date.getHours() > 12 ? "pm" : "am";
      return /\A/.test(this.token) ? meridiem.toUpperCase() : meridiem;
    }
  };
  module2.exports = Meridiem;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/dist/dateparts/day.js
var require_day = __commonJS((exports2, module2) => {
  "use strict";
  var DatePart = require_datepart();
  var pos = (n) => {
    n = n % 10;
    return n === 1 ? "st" : n === 2 ? "nd" : n === 3 ? "rd" : "th";
  };
  var Day = class extends DatePart {
    constructor(opts = {}) {
      super(opts);
    }
    up() {
      this.date.setDate(this.date.getDate() + 1);
    }
    down() {
      this.date.setDate(this.date.getDate() - 1);
    }
    setTo(val) {
      this.date.setDate(parseInt(val.substr(-2)));
    }
    toString() {
      let date = this.date.getDate();
      let day = this.date.getDay();
      return this.token === "DD" ? String(date).padStart(2, "0") : this.token === "Do" ? date + pos(date) : this.token === "d" ? day + 1 : this.token === "ddd" ? this.locales.weekdaysShort[day] : this.token === "dddd" ? this.locales.weekdays[day] : date;
    }
  };
  module2.exports = Day;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/dist/dateparts/hours.js
var require_hours = __commonJS((exports2, module2) => {
  "use strict";
  var DatePart = require_datepart();
  var Hours = class extends DatePart {
    constructor(opts = {}) {
      super(opts);
    }
    up() {
      this.date.setHours(this.date.getHours() + 1);
    }
    down() {
      this.date.setHours(this.date.getHours() - 1);
    }
    setTo(val) {
      this.date.setHours(parseInt(val.substr(-2)));
    }
    toString() {
      let hours = this.date.getHours();
      if (/h/.test(this.token))
        hours = hours % 12 || 12;
      return this.token.length > 1 ? String(hours).padStart(2, "0") : hours;
    }
  };
  module2.exports = Hours;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/dist/dateparts/milliseconds.js
var require_milliseconds = __commonJS((exports2, module2) => {
  "use strict";
  var DatePart = require_datepart();
  var Milliseconds = class extends DatePart {
    constructor(opts = {}) {
      super(opts);
    }
    up() {
      this.date.setMilliseconds(this.date.getMilliseconds() + 1);
    }
    down() {
      this.date.setMilliseconds(this.date.getMilliseconds() - 1);
    }
    setTo(val) {
      this.date.setMilliseconds(parseInt(val.substr(-this.token.length)));
    }
    toString() {
      return String(this.date.getMilliseconds()).padStart(4, "0").substr(0, this.token.length);
    }
  };
  module2.exports = Milliseconds;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/dist/dateparts/minutes.js
var require_minutes = __commonJS((exports2, module2) => {
  "use strict";
  var DatePart = require_datepart();
  var Minutes = class extends DatePart {
    constructor(opts = {}) {
      super(opts);
    }
    up() {
      this.date.setMinutes(this.date.getMinutes() + 1);
    }
    down() {
      this.date.setMinutes(this.date.getMinutes() - 1);
    }
    setTo(val) {
      this.date.setMinutes(parseInt(val.substr(-2)));
    }
    toString() {
      let m2 = this.date.getMinutes();
      return this.token.length > 1 ? String(m2).padStart(2, "0") : m2;
    }
  };
  module2.exports = Minutes;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/dist/dateparts/month.js
var require_month = __commonJS((exports2, module2) => {
  "use strict";
  var DatePart = require_datepart();
  var Month = class extends DatePart {
    constructor(opts = {}) {
      super(opts);
    }
    up() {
      this.date.setMonth(this.date.getMonth() + 1);
    }
    down() {
      this.date.setMonth(this.date.getMonth() - 1);
    }
    setTo(val) {
      val = parseInt(val.substr(-2)) - 1;
      this.date.setMonth(val < 0 ? 0 : val);
    }
    toString() {
      let month = this.date.getMonth();
      let tl = this.token.length;
      return tl === 2 ? String(month + 1).padStart(2, "0") : tl === 3 ? this.locales.monthsShort[month] : tl === 4 ? this.locales.months[month] : String(month + 1);
    }
  };
  module2.exports = Month;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/dist/dateparts/seconds.js
var require_seconds = __commonJS((exports2, module2) => {
  "use strict";
  var DatePart = require_datepart();
  var Seconds = class extends DatePart {
    constructor(opts = {}) {
      super(opts);
    }
    up() {
      this.date.setSeconds(this.date.getSeconds() + 1);
    }
    down() {
      this.date.setSeconds(this.date.getSeconds() - 1);
    }
    setTo(val) {
      this.date.setSeconds(parseInt(val.substr(-2)));
    }
    toString() {
      let s2 = this.date.getSeconds();
      return this.token.length > 1 ? String(s2).padStart(2, "0") : s2;
    }
  };
  module2.exports = Seconds;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/dist/dateparts/year.js
var require_year = __commonJS((exports2, module2) => {
  "use strict";
  var DatePart = require_datepart();
  var Year = class extends DatePart {
    constructor(opts = {}) {
      super(opts);
    }
    up() {
      this.date.setFullYear(this.date.getFullYear() + 1);
    }
    down() {
      this.date.setFullYear(this.date.getFullYear() - 1);
    }
    setTo(val) {
      this.date.setFullYear(val.substr(-4));
    }
    toString() {
      let year = String(this.date.getFullYear()).padStart(4, "0");
      return this.token.length === 2 ? year.substr(-2) : year;
    }
  };
  module2.exports = Year;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/dist/dateparts/index.js
var require_dateparts = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    DatePart: require_datepart(),
    Meridiem: require_meridiem(),
    Day: require_day(),
    Hours: require_hours(),
    Milliseconds: require_milliseconds(),
    Minutes: require_minutes(),
    Month: require_month(),
    Seconds: require_seconds(),
    Year: require_year()
  };
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/dist/elements/date.js
var require_date = __commonJS((exports2, module2) => {
  "use strict";
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg10) {
    try {
      var info = gen[key](arg10);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function() {
      var self2 = this, args2 = arguments;
      return new Promise(function(resolve, reject) {
        var gen = fn.apply(self2, args2);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(void 0);
      });
    };
  }
  var color = require_kleur();
  var Prompt = require_prompt();
  var _require = require_util8();
  var style = _require.style;
  var clear = _require.clear;
  var figures = _require.figures;
  var _require2 = require_src4();
  var erase = _require2.erase;
  var cursor = _require2.cursor;
  var _require3 = require_dateparts();
  var DatePart = _require3.DatePart;
  var Meridiem = _require3.Meridiem;
  var Day = _require3.Day;
  var Hours = _require3.Hours;
  var Milliseconds = _require3.Milliseconds;
  var Minutes = _require3.Minutes;
  var Month = _require3.Month;
  var Seconds = _require3.Seconds;
  var Year = _require3.Year;
  var regex = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g;
  var regexGroups = {
    1: ({
      token
    }) => token.replace(/\\(.)/g, "$1"),
    2: (opts) => new Day(opts),
    3: (opts) => new Month(opts),
    4: (opts) => new Year(opts),
    5: (opts) => new Meridiem(opts),
    6: (opts) => new Hours(opts),
    7: (opts) => new Minutes(opts),
    8: (opts) => new Seconds(opts),
    9: (opts) => new Milliseconds(opts)
  };
  var dfltLocales = {
    months: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
    monthsShort: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
    weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
    weekdaysShort: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(",")
  };
  var DatePrompt = class extends Prompt {
    constructor(opts = {}) {
      super(opts);
      this.msg = opts.message;
      this.cursor = 0;
      this.typed = "";
      this.locales = Object.assign(dfltLocales, opts.locales);
      this._date = opts.initial || new Date();
      this.errorMsg = opts.error || "Please Enter A Valid Value";
      this.validator = opts.validate || (() => true);
      this.mask = opts.mask || "YYYY-MM-DD HH:mm:ss";
      this.clear = clear("", this.out.columns);
      this.render();
    }
    get value() {
      return this.date;
    }
    get date() {
      return this._date;
    }
    set date(date) {
      if (date)
        this._date.setTime(date.getTime());
    }
    set mask(mask) {
      let result;
      this.parts = [];
      while (result = regex.exec(mask)) {
        let match = result.shift();
        let idx = result.findIndex((gr) => gr != null);
        this.parts.push(idx in regexGroups ? regexGroups[idx]({
          token: result[idx] || match,
          date: this.date,
          parts: this.parts,
          locales: this.locales
        }) : result[idx] || match);
      }
      let parts = this.parts.reduce((arr, i) => {
        if (typeof i === "string" && typeof arr[arr.length - 1] === "string")
          arr[arr.length - 1] += i;
        else
          arr.push(i);
        return arr;
      }, []);
      this.parts.splice(0);
      this.parts.push(...parts);
      this.reset();
    }
    moveCursor(n) {
      this.typed = "";
      this.cursor = n;
      this.fire();
    }
    reset() {
      this.moveCursor(this.parts.findIndex((p) => p instanceof DatePart));
      this.fire();
      this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = true;
      this.error = false;
      this.fire();
      this.render();
      this.out.write("\n");
      this.close();
    }
    validate() {
      var _this = this;
      return _asyncToGenerator(function* () {
        let valid = yield _this.validator(_this.value);
        if (typeof valid === "string") {
          _this.errorMsg = valid;
          valid = false;
        }
        _this.error = !valid;
      })();
    }
    submit() {
      var _this2 = this;
      return _asyncToGenerator(function* () {
        yield _this2.validate();
        if (_this2.error) {
          _this2.color = "red";
          _this2.fire();
          _this2.render();
          return;
        }
        _this2.done = true;
        _this2.aborted = false;
        _this2.fire();
        _this2.render();
        _this2.out.write("\n");
        _this2.close();
      })();
    }
    up() {
      this.typed = "";
      this.parts[this.cursor].up();
      this.render();
    }
    down() {
      this.typed = "";
      this.parts[this.cursor].down();
      this.render();
    }
    left() {
      let prev = this.parts[this.cursor].prev();
      if (prev == null)
        return this.bell();
      this.moveCursor(this.parts.indexOf(prev));
      this.render();
    }
    right() {
      let next = this.parts[this.cursor].next();
      if (next == null)
        return this.bell();
      this.moveCursor(this.parts.indexOf(next));
      this.render();
    }
    next() {
      let next = this.parts[this.cursor].next();
      this.moveCursor(next ? this.parts.indexOf(next) : this.parts.findIndex((part) => part instanceof DatePart));
      this.render();
    }
    _(c) {
      if (/\d/.test(c)) {
        this.typed += c;
        this.parts[this.cursor].setTo(this.typed);
        this.render();
      }
    }
    render() {
      if (this.closed)
        return;
      if (this.firstRender)
        this.out.write(cursor.hide);
      else
        this.out.write(clear(this.outputText, this.out.columns));
      super.render();
      this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(false), this.parts.reduce((arr, p, idx) => arr.concat(idx === this.cursor && !this.done ? color.cyan().underline(p.toString()) : p), []).join("")].join(" ");
      if (this.error) {
        this.outputText += this.errorMsg.split("\n").reduce((a, l, i) => a + `
${i ? ` ` : figures.pointerSmall} ${color.red().italic(l)}`, ``);
      }
      this.out.write(erase.line + cursor.to(0) + this.outputText);
    }
  };
  module2.exports = DatePrompt;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/dist/elements/number.js
var require_number = __commonJS((exports2, module2) => {
  "use strict";
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg10) {
    try {
      var info = gen[key](arg10);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function() {
      var self2 = this, args2 = arguments;
      return new Promise(function(resolve, reject) {
        var gen = fn.apply(self2, args2);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(void 0);
      });
    };
  }
  var color = require_kleur();
  var Prompt = require_prompt();
  var _require = require_src4();
  var cursor = _require.cursor;
  var erase = _require.erase;
  var _require2 = require_util8();
  var style = _require2.style;
  var figures = _require2.figures;
  var clear = _require2.clear;
  var lines = _require2.lines;
  var isNumber = /[0-9]/;
  var isDef = (any) => any !== void 0;
  var round = (number, precision) => {
    let factor = Math.pow(10, precision);
    return Math.round(number * factor) / factor;
  };
  var NumberPrompt = class extends Prompt {
    constructor(opts = {}) {
      super(opts);
      this.transform = style.render(opts.style);
      this.msg = opts.message;
      this.initial = isDef(opts.initial) ? opts.initial : "";
      this.float = !!opts.float;
      this.round = opts.round || 2;
      this.inc = opts.increment || 1;
      this.min = isDef(opts.min) ? opts.min : -Infinity;
      this.max = isDef(opts.max) ? opts.max : Infinity;
      this.errorMsg = opts.error || `Please Enter A Valid Value`;
      this.validator = opts.validate || (() => true);
      this.color = `cyan`;
      this.value = ``;
      this.typed = ``;
      this.lastHit = 0;
      this.render();
    }
    set value(v) {
      if (!v && v !== 0) {
        this.placeholder = true;
        this.rendered = color.gray(this.transform.render(`${this.initial}`));
        this._value = ``;
      } else {
        this.placeholder = false;
        this.rendered = this.transform.render(`${round(v, this.round)}`);
        this._value = round(v, this.round);
      }
      this.fire();
    }
    get value() {
      return this._value;
    }
    parse(x) {
      return this.float ? parseFloat(x) : parseInt(x);
    }
    valid(c) {
      return c === `-` || c === `.` && this.float || isNumber.test(c);
    }
    reset() {
      this.typed = ``;
      this.value = ``;
      this.fire();
      this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      let x = this.value;
      this.value = x !== `` ? x : this.initial;
      this.done = this.aborted = true;
      this.error = false;
      this.fire();
      this.render();
      this.out.write(`
`);
      this.close();
    }
    validate() {
      var _this = this;
      return _asyncToGenerator(function* () {
        let valid = yield _this.validator(_this.value);
        if (typeof valid === `string`) {
          _this.errorMsg = valid;
          valid = false;
        }
        _this.error = !valid;
      })();
    }
    submit() {
      var _this2 = this;
      return _asyncToGenerator(function* () {
        yield _this2.validate();
        if (_this2.error) {
          _this2.color = `red`;
          _this2.fire();
          _this2.render();
          return;
        }
        let x = _this2.value;
        _this2.value = x !== `` ? x : _this2.initial;
        _this2.done = true;
        _this2.aborted = false;
        _this2.error = false;
        _this2.fire();
        _this2.render();
        _this2.out.write(`
`);
        _this2.close();
      })();
    }
    up() {
      this.typed = ``;
      if (this.value === "") {
        this.value = this.min - this.inc;
      }
      if (this.value >= this.max)
        return this.bell();
      this.value += this.inc;
      this.color = `cyan`;
      this.fire();
      this.render();
    }
    down() {
      this.typed = ``;
      if (this.value === "") {
        this.value = this.min + this.inc;
      }
      if (this.value <= this.min)
        return this.bell();
      this.value -= this.inc;
      this.color = `cyan`;
      this.fire();
      this.render();
    }
    delete() {
      let val = this.value.toString();
      if (val.length === 0)
        return this.bell();
      this.value = this.parse(val = val.slice(0, -1)) || ``;
      if (this.value !== "" && this.value < this.min) {
        this.value = this.min;
      }
      this.color = `cyan`;
      this.fire();
      this.render();
    }
    next() {
      this.value = this.initial;
      this.fire();
      this.render();
    }
    _(c, key) {
      if (!this.valid(c))
        return this.bell();
      const now = Date.now();
      if (now - this.lastHit > 1e3)
        this.typed = ``;
      this.typed += c;
      this.lastHit = now;
      this.color = `cyan`;
      if (c === `.`)
        return this.fire();
      this.value = Math.min(this.parse(this.typed), this.max);
      if (this.value > this.max)
        this.value = this.max;
      if (this.value < this.min)
        this.value = this.min;
      this.fire();
      this.render();
    }
    render() {
      if (this.closed)
        return;
      if (!this.firstRender) {
        if (this.outputError)
          this.out.write(cursor.down(lines(this.outputError, this.out.columns) - 1) + clear(this.outputError, this.out.columns));
        this.out.write(clear(this.outputText, this.out.columns));
      }
      super.render();
      this.outputError = "";
      this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), !this.done || !this.done && !this.placeholder ? color[this.color]().underline(this.rendered) : this.rendered].join(` `);
      if (this.error) {
        this.outputError += this.errorMsg.split(`
`).reduce((a, l, i) => a + `
${i ? ` ` : figures.pointerSmall} ${color.red().italic(l)}`, ``);
      }
      this.out.write(erase.line + cursor.to(0) + this.outputText + cursor.save + this.outputError + cursor.restore);
    }
  };
  module2.exports = NumberPrompt;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/dist/elements/multiselect.js
var require_multiselect = __commonJS((exports2, module2) => {
  "use strict";
  var color = require_kleur();
  var _require = require_src4();
  var cursor = _require.cursor;
  var Prompt = require_prompt();
  var _require2 = require_util8();
  var clear = _require2.clear;
  var figures = _require2.figures;
  var style = _require2.style;
  var wrap = _require2.wrap;
  var entriesToDisplay = _require2.entriesToDisplay;
  var MultiselectPrompt = class extends Prompt {
    constructor(opts = {}) {
      super(opts);
      this.msg = opts.message;
      this.cursor = opts.cursor || 0;
      this.scrollIndex = opts.cursor || 0;
      this.hint = opts.hint || "";
      this.warn = opts.warn || "- This option is disabled -";
      this.minSelected = opts.min;
      this.showMinError = false;
      this.maxChoices = opts.max;
      this.instructions = opts.instructions;
      this.optionsPerPage = opts.optionsPerPage || 10;
      this.value = opts.choices.map((ch, idx) => {
        if (typeof ch === "string")
          ch = {
            title: ch,
            value: idx
          };
        return {
          title: ch && (ch.title || ch.value || ch),
          description: ch && ch.description,
          value: ch && (ch.value === void 0 ? idx : ch.value),
          selected: ch && ch.selected,
          disabled: ch && ch.disabled
        };
      });
      this.clear = clear("", this.out.columns);
      if (!opts.overrideRender) {
        this.render();
      }
    }
    reset() {
      this.value.map((v) => !v.selected);
      this.cursor = 0;
      this.fire();
      this.render();
    }
    selected() {
      return this.value.filter((v) => v.selected);
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = true;
      this.fire();
      this.render();
      this.out.write("\n");
      this.close();
    }
    submit() {
      const selected = this.value.filter((e) => e.selected);
      if (this.minSelected && selected.length < this.minSelected) {
        this.showMinError = true;
        this.render();
      } else {
        this.done = true;
        this.aborted = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
    }
    first() {
      this.cursor = 0;
      this.render();
    }
    last() {
      this.cursor = this.value.length - 1;
      this.render();
    }
    next() {
      this.cursor = (this.cursor + 1) % this.value.length;
      this.render();
    }
    up() {
      if (this.cursor === 0) {
        this.cursor = this.value.length - 1;
      } else {
        this.cursor--;
      }
      this.render();
    }
    down() {
      if (this.cursor === this.value.length - 1) {
        this.cursor = 0;
      } else {
        this.cursor++;
      }
      this.render();
    }
    left() {
      this.value[this.cursor].selected = false;
      this.render();
    }
    right() {
      if (this.value.filter((e) => e.selected).length >= this.maxChoices)
        return this.bell();
      this.value[this.cursor].selected = true;
      this.render();
    }
    handleSpaceToggle() {
      const v = this.value[this.cursor];
      if (v.selected) {
        v.selected = false;
        this.render();
      } else if (v.disabled || this.value.filter((e) => e.selected).length >= this.maxChoices) {
        return this.bell();
      } else {
        v.selected = true;
        this.render();
      }
    }
    toggleAll() {
      if (this.maxChoices !== void 0 || this.value[this.cursor].disabled) {
        return this.bell();
      }
      const newSelected = !this.value[this.cursor].selected;
      this.value.filter((v) => !v.disabled).forEach((v) => v.selected = newSelected);
      this.render();
    }
    _(c, key) {
      if (c === " ") {
        this.handleSpaceToggle();
      } else if (c === "a") {
        this.toggleAll();
      } else {
        return this.bell();
      }
    }
    renderInstructions() {
      if (this.instructions === void 0 || this.instructions) {
        if (typeof this.instructions === "string") {
          return this.instructions;
        }
        return `
Instructions:
    ${figures.arrowUp}/${figures.arrowDown}: Highlight option
    ${figures.arrowLeft}/${figures.arrowRight}/[space]: Toggle selection
` + (this.maxChoices === void 0 ? `    a: Toggle all
` : "") + `    enter/return: Complete answer`;
      }
      return "";
    }
    renderOption(cursor2, v, i, arrowIndicator) {
      const prefix = (v.selected ? color.green(figures.radioOn) : figures.radioOff) + " " + arrowIndicator + " ";
      let title, desc;
      if (v.disabled) {
        title = cursor2 === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
      } else {
        title = cursor2 === i ? color.cyan().underline(v.title) : v.title;
        if (cursor2 === i && v.description) {
          desc = ` - ${v.description}`;
          if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
            desc = "\n" + wrap(v.description, {
              margin: prefix.length,
              width: this.out.columns
            });
          }
        }
      }
      return prefix + title + color.gray(desc || "");
    }
    paginateOptions(options) {
      if (options.length === 0) {
        return color.red("No matches for this query.");
      }
      let _entriesToDisplay = entriesToDisplay(this.cursor, options.length, this.optionsPerPage), startIndex = _entriesToDisplay.startIndex, endIndex = _entriesToDisplay.endIndex;
      let prefix, styledOptions = [];
      for (let i = startIndex; i < endIndex; i++) {
        if (i === startIndex && startIndex > 0) {
          prefix = figures.arrowUp;
        } else if (i === endIndex - 1 && endIndex < options.length) {
          prefix = figures.arrowDown;
        } else {
          prefix = " ";
        }
        styledOptions.push(this.renderOption(this.cursor, options[i], i, prefix));
      }
      return "\n" + styledOptions.join("\n");
    }
    renderOptions(options) {
      if (!this.done) {
        return this.paginateOptions(options);
      }
      return "";
    }
    renderDoneOrInstructions() {
      if (this.done) {
        return this.value.filter((e) => e.selected).map((v) => v.title).join(", ");
      }
      const output = [color.gray(this.hint), this.renderInstructions()];
      if (this.value[this.cursor].disabled) {
        output.push(color.yellow(this.warn));
      }
      return output.join(" ");
    }
    render() {
      if (this.closed)
        return;
      if (this.firstRender)
        this.out.write(cursor.hide);
      super.render();
      let prompt = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(false), this.renderDoneOrInstructions()].join(" ");
      if (this.showMinError) {
        prompt += color.red(`You must select a minimum of ${this.minSelected} choices.`);
        this.showMinError = false;
      }
      prompt += this.renderOptions(this.value);
      this.out.write(this.clear + prompt);
      this.clear = clear(prompt, this.out.columns);
    }
  };
  module2.exports = MultiselectPrompt;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/dist/elements/autocomplete.js
var require_autocomplete = __commonJS((exports2, module2) => {
  "use strict";
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg10) {
    try {
      var info = gen[key](arg10);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function() {
      var self2 = this, args2 = arguments;
      return new Promise(function(resolve, reject) {
        var gen = fn.apply(self2, args2);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(void 0);
      });
    };
  }
  var color = require_kleur();
  var Prompt = require_prompt();
  var _require = require_src4();
  var erase = _require.erase;
  var cursor = _require.cursor;
  var _require2 = require_util8();
  var style = _require2.style;
  var clear = _require2.clear;
  var figures = _require2.figures;
  var wrap = _require2.wrap;
  var entriesToDisplay = _require2.entriesToDisplay;
  var getVal = (arr, i) => arr[i] && (arr[i].value || arr[i].title || arr[i]);
  var getTitle = (arr, i) => arr[i] && (arr[i].title || arr[i].value || arr[i]);
  var getIndex = (arr, valOrTitle) => {
    const index = arr.findIndex((el) => el.value === valOrTitle || el.title === valOrTitle);
    return index > -1 ? index : void 0;
  };
  var AutocompletePrompt = class extends Prompt {
    constructor(opts = {}) {
      super(opts);
      this.msg = opts.message;
      this.suggest = opts.suggest;
      this.choices = opts.choices;
      this.initial = typeof opts.initial === "number" ? opts.initial : getIndex(opts.choices, opts.initial);
      this.select = this.initial || opts.cursor || 0;
      this.i18n = {
        noMatches: opts.noMatches || "no matches found"
      };
      this.fallback = opts.fallback || this.initial;
      this.clearFirst = opts.clearFirst || false;
      this.suggestions = [];
      this.input = "";
      this.limit = opts.limit || 10;
      this.cursor = 0;
      this.transform = style.render(opts.style);
      this.scale = this.transform.scale;
      this.render = this.render.bind(this);
      this.complete = this.complete.bind(this);
      this.clear = clear("", this.out.columns);
      this.complete(this.render);
      this.render();
    }
    set fallback(fb) {
      this._fb = Number.isSafeInteger(parseInt(fb)) ? parseInt(fb) : fb;
    }
    get fallback() {
      let choice;
      if (typeof this._fb === "number")
        choice = this.choices[this._fb];
      else if (typeof this._fb === "string")
        choice = {
          title: this._fb
        };
      return choice || this._fb || {
        title: this.i18n.noMatches
      };
    }
    moveSelect(i) {
      this.select = i;
      if (this.suggestions.length > 0)
        this.value = getVal(this.suggestions, i);
      else
        this.value = this.fallback.value;
      this.fire();
    }
    complete(cb) {
      var _this = this;
      return _asyncToGenerator(function* () {
        const p = _this.completing = _this.suggest(_this.input, _this.choices);
        const suggestions = yield p;
        if (_this.completing !== p)
          return;
        _this.suggestions = suggestions.map((s2, i, arr) => ({
          title: getTitle(arr, i),
          value: getVal(arr, i),
          description: s2.description
        }));
        _this.completing = false;
        const l = Math.max(suggestions.length - 1, 0);
        _this.moveSelect(Math.min(l, _this.select));
        cb && cb();
      })();
    }
    reset() {
      this.input = "";
      this.complete(() => {
        this.moveSelect(this.initial !== void 0 ? this.initial : 0);
        this.render();
      });
      this.render();
    }
    exit() {
      if (this.clearFirst && this.input.length > 0) {
        this.reset();
      } else {
        this.done = this.exited = true;
        this.aborted = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
    }
    abort() {
      this.done = this.aborted = true;
      this.exited = false;
      this.fire();
      this.render();
      this.out.write("\n");
      this.close();
    }
    submit() {
      this.done = true;
      this.aborted = this.exited = false;
      this.fire();
      this.render();
      this.out.write("\n");
      this.close();
    }
    _(c, key) {
      let s1 = this.input.slice(0, this.cursor);
      let s2 = this.input.slice(this.cursor);
      this.input = `${s1}${c}${s2}`;
      this.cursor = s1.length + 1;
      this.complete(this.render);
      this.render();
    }
    delete() {
      if (this.cursor === 0)
        return this.bell();
      let s1 = this.input.slice(0, this.cursor - 1);
      let s2 = this.input.slice(this.cursor);
      this.input = `${s1}${s2}`;
      this.complete(this.render);
      this.cursor = this.cursor - 1;
      this.render();
    }
    deleteForward() {
      if (this.cursor * this.scale >= this.rendered.length)
        return this.bell();
      let s1 = this.input.slice(0, this.cursor);
      let s2 = this.input.slice(this.cursor + 1);
      this.input = `${s1}${s2}`;
      this.complete(this.render);
      this.render();
    }
    first() {
      this.moveSelect(0);
      this.render();
    }
    last() {
      this.moveSelect(this.suggestions.length - 1);
      this.render();
    }
    up() {
      if (this.select === 0) {
        this.moveSelect(this.suggestions.length - 1);
      } else {
        this.moveSelect(this.select - 1);
      }
      this.render();
    }
    down() {
      if (this.select === this.suggestions.length - 1) {
        this.moveSelect(0);
      } else {
        this.moveSelect(this.select + 1);
      }
      this.render();
    }
    next() {
      if (this.select === this.suggestions.length - 1) {
        this.moveSelect(0);
      } else
        this.moveSelect(this.select + 1);
      this.render();
    }
    nextPage() {
      this.moveSelect(Math.min(this.select + this.limit, this.suggestions.length - 1));
      this.render();
    }
    prevPage() {
      this.moveSelect(Math.max(this.select - this.limit, 0));
      this.render();
    }
    left() {
      if (this.cursor <= 0)
        return this.bell();
      this.cursor = this.cursor - 1;
      this.render();
    }
    right() {
      if (this.cursor * this.scale >= this.rendered.length)
        return this.bell();
      this.cursor = this.cursor + 1;
      this.render();
    }
    renderOption(v, hovered, isStart, isEnd) {
      let desc;
      let prefix = isStart ? figures.arrowUp : isEnd ? figures.arrowDown : " ";
      let title = hovered ? color.cyan().underline(v.title) : v.title;
      prefix = (hovered ? color.cyan(figures.pointer) + " " : "  ") + prefix;
      if (v.description) {
        desc = ` - ${v.description}`;
        if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
          desc = "\n" + wrap(v.description, {
            margin: 3,
            width: this.out.columns
          });
        }
      }
      return prefix + " " + title + color.gray(desc || "");
    }
    render() {
      if (this.closed)
        return;
      if (this.firstRender)
        this.out.write(cursor.hide);
      else
        this.out.write(clear(this.outputText, this.out.columns));
      super.render();
      let _entriesToDisplay = entriesToDisplay(this.select, this.choices.length, this.limit), startIndex = _entriesToDisplay.startIndex, endIndex = _entriesToDisplay.endIndex;
      this.outputText = [style.symbol(this.done, this.aborted, this.exited), color.bold(this.msg), style.delimiter(this.completing), this.done && this.suggestions[this.select] ? this.suggestions[this.select].title : this.rendered = this.transform.render(this.input)].join(" ");
      if (!this.done) {
        const suggestions = this.suggestions.slice(startIndex, endIndex).map((item, i) => this.renderOption(item, this.select === i + startIndex, i === 0 && startIndex > 0, i + startIndex === endIndex - 1 && endIndex < this.choices.length)).join("\n");
        this.outputText += `
` + (suggestions || color.gray(this.fallback.title));
      }
      this.out.write(erase.line + cursor.to(0) + this.outputText);
    }
  };
  module2.exports = AutocompletePrompt;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/dist/elements/autocompleteMultiselect.js
var require_autocompleteMultiselect = __commonJS((exports2, module2) => {
  "use strict";
  var color = require_kleur();
  var _require = require_src4();
  var cursor = _require.cursor;
  var MultiselectPrompt = require_multiselect();
  var _require2 = require_util8();
  var clear = _require2.clear;
  var style = _require2.style;
  var figures = _require2.figures;
  var AutocompleteMultiselectPrompt = class extends MultiselectPrompt {
    constructor(opts = {}) {
      opts.overrideRender = true;
      super(opts);
      this.inputValue = "";
      this.clear = clear("", this.out.columns);
      this.filteredOptions = this.value;
      this.render();
    }
    last() {
      this.cursor = this.filteredOptions.length - 1;
      this.render();
    }
    next() {
      this.cursor = (this.cursor + 1) % this.filteredOptions.length;
      this.render();
    }
    up() {
      if (this.cursor === 0) {
        this.cursor = this.filteredOptions.length - 1;
      } else {
        this.cursor--;
      }
      this.render();
    }
    down() {
      if (this.cursor === this.filteredOptions.length - 1) {
        this.cursor = 0;
      } else {
        this.cursor++;
      }
      this.render();
    }
    left() {
      this.filteredOptions[this.cursor].selected = false;
      this.render();
    }
    right() {
      if (this.value.filter((e) => e.selected).length >= this.maxChoices)
        return this.bell();
      this.filteredOptions[this.cursor].selected = true;
      this.render();
    }
    delete() {
      if (this.inputValue.length) {
        this.inputValue = this.inputValue.substr(0, this.inputValue.length - 1);
        this.updateFilteredOptions();
      }
    }
    updateFilteredOptions() {
      const currentHighlight = this.filteredOptions[this.cursor];
      this.filteredOptions = this.value.filter((v) => {
        if (this.inputValue) {
          if (typeof v.title === "string") {
            if (v.title.toLowerCase().includes(this.inputValue.toLowerCase())) {
              return true;
            }
          }
          if (typeof v.value === "string") {
            if (v.value.toLowerCase().includes(this.inputValue.toLowerCase())) {
              return true;
            }
          }
          return false;
        }
        return true;
      });
      const newHighlightIndex = this.filteredOptions.findIndex((v) => v === currentHighlight);
      this.cursor = newHighlightIndex < 0 ? 0 : newHighlightIndex;
      this.render();
    }
    handleSpaceToggle() {
      const v = this.filteredOptions[this.cursor];
      if (v.selected) {
        v.selected = false;
        this.render();
      } else if (v.disabled || this.value.filter((e) => e.selected).length >= this.maxChoices) {
        return this.bell();
      } else {
        v.selected = true;
        this.render();
      }
    }
    handleInputChange(c) {
      this.inputValue = this.inputValue + c;
      this.updateFilteredOptions();
    }
    _(c, key) {
      if (c === " ") {
        this.handleSpaceToggle();
      } else {
        this.handleInputChange(c);
      }
    }
    renderInstructions() {
      if (this.instructions === void 0 || this.instructions) {
        if (typeof this.instructions === "string") {
          return this.instructions;
        }
        return `
Instructions:
    ${figures.arrowUp}/${figures.arrowDown}: Highlight option
    ${figures.arrowLeft}/${figures.arrowRight}/[space]: Toggle selection
    [a,b,c]/delete: Filter choices
    enter/return: Complete answer
`;
      }
      return "";
    }
    renderCurrentInput() {
      return `
Filtered results for: ${this.inputValue ? this.inputValue : color.gray("Enter something to filter")}
`;
    }
    renderOption(cursor2, v, i) {
      let title;
      if (v.disabled)
        title = cursor2 === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
      else
        title = cursor2 === i ? color.cyan().underline(v.title) : v.title;
      return (v.selected ? color.green(figures.radioOn) : figures.radioOff) + "  " + title;
    }
    renderDoneOrInstructions() {
      if (this.done) {
        return this.value.filter((e) => e.selected).map((v) => v.title).join(", ");
      }
      const output = [color.gray(this.hint), this.renderInstructions(), this.renderCurrentInput()];
      if (this.filteredOptions.length && this.filteredOptions[this.cursor].disabled) {
        output.push(color.yellow(this.warn));
      }
      return output.join(" ");
    }
    render() {
      if (this.closed)
        return;
      if (this.firstRender)
        this.out.write(cursor.hide);
      super.render();
      let prompt = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(false), this.renderDoneOrInstructions()].join(" ");
      if (this.showMinError) {
        prompt += color.red(`You must select a minimum of ${this.minSelected} choices.`);
        this.showMinError = false;
      }
      prompt += this.renderOptions(this.filteredOptions);
      this.out.write(this.clear + prompt);
      this.clear = clear(prompt, this.out.columns);
    }
  };
  module2.exports = AutocompleteMultiselectPrompt;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/dist/elements/confirm.js
var require_confirm = __commonJS((exports2, module2) => {
  "use strict";
  var color = require_kleur();
  var Prompt = require_prompt();
  var _require = require_util8();
  var style = _require.style;
  var clear = _require.clear;
  var _require2 = require_src4();
  var erase = _require2.erase;
  var cursor = _require2.cursor;
  var ConfirmPrompt = class extends Prompt {
    constructor(opts = {}) {
      super(opts);
      this.msg = opts.message;
      this.value = opts.initial;
      this.initialValue = !!opts.initial;
      this.yesMsg = opts.yes || "yes";
      this.yesOption = opts.yesOption || "(Y/n)";
      this.noMsg = opts.no || "no";
      this.noOption = opts.noOption || "(y/N)";
      this.render();
    }
    reset() {
      this.value = this.initialValue;
      this.fire();
      this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = true;
      this.fire();
      this.render();
      this.out.write("\n");
      this.close();
    }
    submit() {
      this.value = this.value || false;
      this.done = true;
      this.aborted = false;
      this.fire();
      this.render();
      this.out.write("\n");
      this.close();
    }
    _(c, key) {
      if (c.toLowerCase() === "y") {
        this.value = true;
        return this.submit();
      }
      if (c.toLowerCase() === "n") {
        this.value = false;
        return this.submit();
      }
      return this.bell();
    }
    render() {
      if (this.closed)
        return;
      if (this.firstRender)
        this.out.write(cursor.hide);
      else
        this.out.write(clear(this.outputText, this.out.columns));
      super.render();
      this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), this.done ? this.value ? this.yesMsg : this.noMsg : color.gray(this.initialValue ? this.yesOption : this.noOption)].join(" ");
      this.out.write(erase.line + cursor.to(0) + this.outputText);
    }
  };
  module2.exports = ConfirmPrompt;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/dist/elements/index.js
var require_elements = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    TextPrompt: require_text(),
    SelectPrompt: require_select(),
    TogglePrompt: require_toggle(),
    DatePrompt: require_date(),
    NumberPrompt: require_number(),
    MultiselectPrompt: require_multiselect(),
    AutocompletePrompt: require_autocomplete(),
    AutocompleteMultiselectPrompt: require_autocompleteMultiselect(),
    ConfirmPrompt: require_confirm()
  };
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/dist/prompts.js
var require_prompts = __commonJS((exports2) => {
  "use strict";
  var $ = exports2;
  var el = require_elements();
  var noop = (v) => v;
  function toPrompt(type, args2, opts = {}) {
    return new Promise((res, rej) => {
      const p = new el[type](args2);
      const onAbort = opts.onAbort || noop;
      const onSubmit = opts.onSubmit || noop;
      const onExit = opts.onExit || noop;
      p.on("state", args2.onState || noop);
      p.on("submit", (x) => res(onSubmit(x)));
      p.on("exit", (x) => res(onExit(x)));
      p.on("abort", (x) => rej(onAbort(x)));
    });
  }
  $.text = (args2) => toPrompt("TextPrompt", args2);
  $.password = (args2) => {
    args2.style = "password";
    return $.text(args2);
  };
  $.invisible = (args2) => {
    args2.style = "invisible";
    return $.text(args2);
  };
  $.number = (args2) => toPrompt("NumberPrompt", args2);
  $.date = (args2) => toPrompt("DatePrompt", args2);
  $.confirm = (args2) => toPrompt("ConfirmPrompt", args2);
  $.list = (args2) => {
    const sep = args2.separator || ",";
    return toPrompt("TextPrompt", args2, {
      onSubmit: (str) => str.split(sep).map((s2) => s2.trim())
    });
  };
  $.toggle = (args2) => toPrompt("TogglePrompt", args2);
  $.select = (args2) => toPrompt("SelectPrompt", args2);
  $.multiselect = (args2) => {
    args2.choices = [].concat(args2.choices || []);
    const toSelected = (items) => items.filter((item) => item.selected).map((item) => item.value);
    return toPrompt("MultiselectPrompt", args2, {
      onAbort: toSelected,
      onSubmit: toSelected
    });
  };
  $.autocompleteMultiselect = (args2) => {
    args2.choices = [].concat(args2.choices || []);
    const toSelected = (items) => items.filter((item) => item.selected).map((item) => item.value);
    return toPrompt("AutocompleteMultiselectPrompt", args2, {
      onAbort: toSelected,
      onSubmit: toSelected
    });
  };
  var byTitle = (input, choices) => Promise.resolve(choices.filter((item) => item.title.slice(0, input.length).toLowerCase() === input.toLowerCase()));
  $.autocomplete = (args2) => {
    args2.suggest = args2.suggest || byTitle;
    args2.choices = [].concat(args2.choices || []);
    return toPrompt("AutocompletePrompt", args2);
  };
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/dist/index.js
var require_dist14 = __commonJS((exports2, module2) => {
  "use strict";
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return {s: F, n: function n() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        }, e: function e(_e) {
          throw _e;
        }, f: F};
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function s2() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    }};
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++)
      arr2[i] = arr[i];
    return arr2;
  }
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg10) {
    try {
      var info = gen[key](arg10);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function() {
      var self2 = this, args2 = arguments;
      return new Promise(function(resolve, reject) {
        var gen = fn.apply(self2, args2);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(void 0);
      });
    };
  }
  var prompts = require_prompts();
  var passOn = ["suggest", "format", "onState", "validate", "onRender", "type"];
  var noop = () => {
  };
  function prompt() {
    return _prompt.apply(this, arguments);
  }
  function _prompt() {
    _prompt = _asyncToGenerator(function* (questions = [], {
      onSubmit = noop,
      onCancel = noop
    } = {}) {
      const answers = {};
      const override2 = prompt._override || {};
      questions = [].concat(questions);
      let answer, question, quit, name, type, lastPrompt;
      const getFormattedAnswer = /* @__PURE__ */ function() {
        var _ref = _asyncToGenerator(function* (question2, answer2, skipValidation = false) {
          if (!skipValidation && question2.validate && question2.validate(answer2) !== true) {
            return;
          }
          return question2.format ? yield question2.format(answer2, answers) : answer2;
        });
        return function getFormattedAnswer2(_x, _x2) {
          return _ref.apply(this, arguments);
        };
      }();
      var _iterator = _createForOfIteratorHelper(questions), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          question = _step.value;
          var _question = question;
          name = _question.name;
          type = _question.type;
          if (typeof type === "function") {
            type = yield type(answer, _objectSpread({}, answers), question);
            question["type"] = type;
          }
          if (!type)
            continue;
          for (let key in question) {
            if (passOn.includes(key))
              continue;
            let value = question[key];
            question[key] = typeof value === "function" ? yield value(answer, _objectSpread({}, answers), lastPrompt) : value;
          }
          lastPrompt = question;
          if (typeof question.message !== "string") {
            throw new Error("prompt message is required");
          }
          var _question2 = question;
          name = _question2.name;
          type = _question2.type;
          if (prompts[type] === void 0) {
            throw new Error(`prompt type (${type}) is not defined`);
          }
          if (override2[question.name] !== void 0) {
            answer = yield getFormattedAnswer(question, override2[question.name]);
            if (answer !== void 0) {
              answers[name] = answer;
              continue;
            }
          }
          try {
            answer = prompt._injected ? getInjectedAnswer(prompt._injected, question.initial) : yield prompts[type](question);
            answers[name] = answer = yield getFormattedAnswer(question, answer, true);
            quit = yield onSubmit(question, answer, answers);
          } catch (err) {
            quit = !(yield onCancel(question, answers));
          }
          if (quit)
            return answers;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return answers;
    });
    return _prompt.apply(this, arguments);
  }
  function getInjectedAnswer(injected, deafultValue) {
    const answer = injected.shift();
    if (answer instanceof Error) {
      throw answer;
    }
    return answer === void 0 ? deafultValue : answer;
  }
  function inject(answers) {
    prompt._injected = (prompt._injected || []).concat(answers);
  }
  function override(answers) {
    prompt._override = Object.assign({}, answers);
  }
  module2.exports = Object.assign(prompt, {
    prompt,
    prompts,
    inject,
    override
  });
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/lib/util/action.js
var require_action2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (key, isSelect) => {
    if (key.meta && key.name !== "escape")
      return;
    if (key.ctrl) {
      if (key.name === "a")
        return "first";
      if (key.name === "c")
        return "abort";
      if (key.name === "d")
        return "abort";
      if (key.name === "e")
        return "last";
      if (key.name === "g")
        return "reset";
    }
    if (isSelect) {
      if (key.name === "j")
        return "down";
      if (key.name === "k")
        return "up";
    }
    if (key.name === "return")
      return "submit";
    if (key.name === "enter")
      return "submit";
    if (key.name === "backspace")
      return "delete";
    if (key.name === "delete")
      return "deleteForward";
    if (key.name === "abort")
      return "abort";
    if (key.name === "escape")
      return "exit";
    if (key.name === "tab")
      return "next";
    if (key.name === "pagedown")
      return "nextPage";
    if (key.name === "pageup")
      return "prevPage";
    if (key.name === "home")
      return "home";
    if (key.name === "end")
      return "end";
    if (key.name === "up")
      return "up";
    if (key.name === "down")
      return "down";
    if (key.name === "right")
      return "right";
    if (key.name === "left")
      return "left";
    return false;
  };
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/lib/util/strip.js
var require_strip2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (str) => {
    const pattern = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[a-zA-Z\\d]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))"
    ].join("|");
    const RGX = new RegExp(pattern, "g");
    return typeof str === "string" ? str.replace(RGX, "") : str;
  };
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/lib/util/clear.js
var require_clear2 = __commonJS((exports2, module2) => {
  "use strict";
  var strip = require_strip2();
  var {erase, cursor} = require_src4();
  var width = (str) => [...strip(str)].length;
  module2.exports = function(prompt, perLine) {
    if (!perLine)
      return erase.line + cursor.to(0);
    let rows = 0;
    const lines = prompt.split(/\r?\n/);
    for (let line of lines) {
      rows += 1 + Math.floor(Math.max(width(line) - 1, 0) / perLine);
    }
    return erase.lines(rows);
  };
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/lib/util/figures.js
var require_figures2 = __commonJS((exports2, module2) => {
  "use strict";
  var main2 = {
    arrowUp: "\u2191",
    arrowDown: "\u2193",
    arrowLeft: "\u2190",
    arrowRight: "\u2192",
    radioOn: "\u25C9",
    radioOff: "\u25EF",
    tick: "\u2714",
    cross: "\u2716",
    ellipsis: "\u2026",
    pointerSmall: "\u203A",
    line: "\u2500",
    pointer: "\u276F"
  };
  var win = {
    arrowUp: main2.arrowUp,
    arrowDown: main2.arrowDown,
    arrowLeft: main2.arrowLeft,
    arrowRight: main2.arrowRight,
    radioOn: "(*)",
    radioOff: "( )",
    tick: "\u221A",
    cross: "\xD7",
    ellipsis: "...",
    pointerSmall: "\xBB",
    line: "\u2500",
    pointer: ">"
  };
  var figures = process.platform === "win32" ? win : main2;
  module2.exports = figures;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/lib/util/style.js
var require_style2 = __commonJS((exports2, module2) => {
  "use strict";
  var c = require_kleur();
  var figures = require_figures2();
  var styles = Object.freeze({
    password: {scale: 1, render: (input) => "*".repeat(input.length)},
    emoji: {scale: 2, render: (input) => "\u{1F603}".repeat(input.length)},
    invisible: {scale: 0, render: (input) => ""},
    default: {scale: 1, render: (input) => `${input}`}
  });
  var render = (type) => styles[type] || styles.default;
  var symbols = Object.freeze({
    aborted: c.red(figures.cross),
    done: c.green(figures.tick),
    exited: c.yellow(figures.cross),
    default: c.cyan("?")
  });
  var symbol = (done, aborted, exited) => aborted ? symbols.aborted : exited ? symbols.exited : done ? symbols.done : symbols.default;
  var delimiter = (completing) => c.gray(completing ? figures.ellipsis : figures.pointerSmall);
  var item = (expandable, expanded) => c.gray(expandable ? expanded ? figures.pointerSmall : "+" : figures.line);
  module2.exports = {
    styles,
    render,
    symbols,
    symbol,
    delimiter,
    item
  };
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/lib/util/lines.js
var require_lines2 = __commonJS((exports2, module2) => {
  "use strict";
  var strip = require_strip2();
  module2.exports = function(msg, perLine) {
    let lines = String(strip(msg) || "").split(/\r?\n/);
    if (!perLine)
      return lines.length;
    return lines.map((l) => Math.ceil(l.length / perLine)).reduce((a, b) => a + b);
  };
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/lib/util/wrap.js
var require_wrap2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (msg, opts = {}) => {
    const tab = Number.isSafeInteger(parseInt(opts.margin)) ? new Array(parseInt(opts.margin)).fill(" ").join("") : opts.margin || "";
    const width = opts.width;
    return (msg || "").split(/\r?\n/g).map((line) => line.split(/\s+/g).reduce((arr, w2) => {
      if (w2.length + tab.length >= width || arr[arr.length - 1].length + w2.length + 1 < width)
        arr[arr.length - 1] += ` ${w2}`;
      else
        arr.push(`${tab}${w2}`);
      return arr;
    }, [tab]).join("\n")).join("\n");
  };
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/lib/util/entriesToDisplay.js
var require_entriesToDisplay2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (cursor, total, maxVisible) => {
    maxVisible = maxVisible || total;
    let startIndex = Math.min(total - maxVisible, cursor - Math.floor(maxVisible / 2));
    if (startIndex < 0)
      startIndex = 0;
    let endIndex = Math.min(startIndex + maxVisible, total);
    return {startIndex, endIndex};
  };
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/lib/util/index.js
var require_util9 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    action: require_action2(),
    clear: require_clear2(),
    style: require_style2(),
    strip: require_strip2(),
    figures: require_figures2(),
    lines: require_lines2(),
    wrap: require_wrap2(),
    entriesToDisplay: require_entriesToDisplay2()
  };
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/lib/elements/prompt.js
var require_prompt2 = __commonJS((exports2, module2) => {
  "use strict";
  var readline = require("readline");
  var {action} = require_util9();
  var EventEmitter = require("events");
  var {beep, cursor} = require_src4();
  var color = require_kleur();
  var Prompt = class extends EventEmitter {
    constructor(opts = {}) {
      super();
      this.firstRender = true;
      this.in = opts.stdin || process.stdin;
      this.out = opts.stdout || process.stdout;
      this.onRender = (opts.onRender || (() => void 0)).bind(this);
      const rl = readline.createInterface({input: this.in, escapeCodeTimeout: 50});
      readline.emitKeypressEvents(this.in, rl);
      if (this.in.isTTY)
        this.in.setRawMode(true);
      const isSelect = ["SelectPrompt", "MultiselectPrompt"].indexOf(this.constructor.name) > -1;
      const keypress = (str, key) => {
        let a = action(key, isSelect);
        if (a === false) {
          this._ && this._(str, key);
        } else if (typeof this[a] === "function") {
          this[a](key);
        } else {
          this.bell();
        }
      };
      this.close = () => {
        this.out.write(cursor.show);
        this.in.removeListener("keypress", keypress);
        if (this.in.isTTY)
          this.in.setRawMode(false);
        rl.close();
        this.emit(this.aborted ? "abort" : this.exited ? "exit" : "submit", this.value);
        this.closed = true;
      };
      this.in.on("keypress", keypress);
    }
    fire() {
      this.emit("state", {
        value: this.value,
        aborted: !!this.aborted,
        exited: !!this.exited
      });
    }
    bell() {
      this.out.write(beep);
    }
    render() {
      this.onRender(color);
      if (this.firstRender)
        this.firstRender = false;
    }
  };
  module2.exports = Prompt;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/lib/elements/text.js
var require_text2 = __commonJS((exports2, module2) => {
  var color = require_kleur();
  var Prompt = require_prompt2();
  var {erase, cursor} = require_src4();
  var {style, clear, lines, figures} = require_util9();
  var TextPrompt = class extends Prompt {
    constructor(opts = {}) {
      super(opts);
      this.transform = style.render(opts.style);
      this.scale = this.transform.scale;
      this.msg = opts.message;
      this.initial = opts.initial || ``;
      this.validator = opts.validate || (() => true);
      this.value = ``;
      this.errorMsg = opts.error || `Please Enter A Valid Value`;
      this.cursor = Number(!!this.initial);
      this.cursorOffset = 0;
      this.clear = clear(``, this.out.columns);
      this.render();
    }
    set value(v) {
      if (!v && this.initial) {
        this.placeholder = true;
        this.rendered = color.gray(this.transform.render(this.initial));
      } else {
        this.placeholder = false;
        this.rendered = this.transform.render(v);
      }
      this._value = v;
      this.fire();
    }
    get value() {
      return this._value;
    }
    reset() {
      this.value = ``;
      this.cursor = Number(!!this.initial);
      this.cursorOffset = 0;
      this.fire();
      this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.value = this.value || this.initial;
      this.done = this.aborted = true;
      this.error = false;
      this.red = false;
      this.fire();
      this.render();
      this.out.write("\n");
      this.close();
    }
    async validate() {
      let valid = await this.validator(this.value);
      if (typeof valid === `string`) {
        this.errorMsg = valid;
        valid = false;
      }
      this.error = !valid;
    }
    async submit() {
      this.value = this.value || this.initial;
      this.cursorOffset = 0;
      this.cursor = this.rendered.length;
      await this.validate();
      if (this.error) {
        this.red = true;
        this.fire();
        this.render();
        return;
      }
      this.done = true;
      this.aborted = false;
      this.fire();
      this.render();
      this.out.write("\n");
      this.close();
    }
    next() {
      if (!this.placeholder)
        return this.bell();
      this.value = this.initial;
      this.cursor = this.rendered.length;
      this.fire();
      this.render();
    }
    moveCursor(n) {
      if (this.placeholder)
        return;
      this.cursor = this.cursor + n;
      this.cursorOffset += n;
    }
    _(c, key) {
      let s1 = this.value.slice(0, this.cursor);
      let s2 = this.value.slice(this.cursor);
      this.value = `${s1}${c}${s2}`;
      this.red = false;
      this.cursor = this.placeholder ? 0 : s1.length + 1;
      this.render();
    }
    delete() {
      if (this.isCursorAtStart())
        return this.bell();
      let s1 = this.value.slice(0, this.cursor - 1);
      let s2 = this.value.slice(this.cursor);
      this.value = `${s1}${s2}`;
      this.red = false;
      if (this.isCursorAtStart()) {
        this.cursorOffset = 0;
      } else {
        this.cursorOffset++;
        this.moveCursor(-1);
      }
      this.render();
    }
    deleteForward() {
      if (this.cursor * this.scale >= this.rendered.length || this.placeholder)
        return this.bell();
      let s1 = this.value.slice(0, this.cursor);
      let s2 = this.value.slice(this.cursor + 1);
      this.value = `${s1}${s2}`;
      this.red = false;
      if (this.isCursorAtEnd()) {
        this.cursorOffset = 0;
      } else {
        this.cursorOffset++;
      }
      this.render();
    }
    first() {
      this.cursor = 0;
      this.render();
    }
    last() {
      this.cursor = this.value.length;
      this.render();
    }
    left() {
      if (this.cursor <= 0 || this.placeholder)
        return this.bell();
      this.moveCursor(-1);
      this.render();
    }
    right() {
      if (this.cursor * this.scale >= this.rendered.length || this.placeholder)
        return this.bell();
      this.moveCursor(1);
      this.render();
    }
    isCursorAtStart() {
      return this.cursor === 0 || this.placeholder && this.cursor === 1;
    }
    isCursorAtEnd() {
      return this.cursor === this.rendered.length || this.placeholder && this.cursor === this.rendered.length + 1;
    }
    render() {
      if (this.closed)
        return;
      if (!this.firstRender) {
        if (this.outputError)
          this.out.write(cursor.down(lines(this.outputError, this.out.columns) - 1) + clear(this.outputError, this.out.columns));
        this.out.write(clear(this.outputText, this.out.columns));
      }
      super.render();
      this.outputError = "";
      this.outputText = [
        style.symbol(this.done, this.aborted),
        color.bold(this.msg),
        style.delimiter(this.done),
        this.red ? color.red(this.rendered) : this.rendered
      ].join(` `);
      if (this.error) {
        this.outputError += this.errorMsg.split(`
`).reduce((a, l, i) => a + `
${i ? " " : figures.pointerSmall} ${color.red().italic(l)}`, ``);
      }
      this.out.write(erase.line + cursor.to(0) + this.outputText + cursor.save + this.outputError + cursor.restore + cursor.move(this.cursorOffset, 0));
    }
  };
  module2.exports = TextPrompt;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/lib/elements/select.js
var require_select2 = __commonJS((exports2, module2) => {
  "use strict";
  var color = require_kleur();
  var Prompt = require_prompt2();
  var {style, clear, figures, wrap, entriesToDisplay} = require_util9();
  var {cursor} = require_src4();
  var SelectPrompt = class extends Prompt {
    constructor(opts = {}) {
      super(opts);
      this.msg = opts.message;
      this.hint = opts.hint || "- Use arrow-keys. Return to submit.";
      this.warn = opts.warn || "- This option is disabled";
      this.cursor = opts.initial || 0;
      this.choices = opts.choices.map((ch, idx) => {
        if (typeof ch === "string")
          ch = {title: ch, value: idx};
        return {
          title: ch && (ch.title || ch.value || ch),
          value: ch && (ch.value === void 0 ? idx : ch.value),
          description: ch && ch.description,
          selected: ch && ch.selected,
          disabled: ch && ch.disabled
        };
      });
      this.optionsPerPage = opts.optionsPerPage || 10;
      this.value = (this.choices[this.cursor] || {}).value;
      this.clear = clear("", this.out.columns);
      this.render();
    }
    moveCursor(n) {
      this.cursor = n;
      this.value = this.choices[n].value;
      this.fire();
    }
    reset() {
      this.moveCursor(0);
      this.fire();
      this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = true;
      this.fire();
      this.render();
      this.out.write("\n");
      this.close();
    }
    submit() {
      if (!this.selection.disabled) {
        this.done = true;
        this.aborted = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      } else
        this.bell();
    }
    first() {
      this.moveCursor(0);
      this.render();
    }
    last() {
      this.moveCursor(this.choices.length - 1);
      this.render();
    }
    up() {
      if (this.cursor === 0) {
        this.moveCursor(this.choices.length - 1);
      } else {
        this.moveCursor(this.cursor - 1);
      }
      this.render();
    }
    down() {
      if (this.cursor === this.choices.length - 1) {
        this.moveCursor(0);
      } else {
        this.moveCursor(this.cursor + 1);
      }
      this.render();
    }
    next() {
      this.moveCursor((this.cursor + 1) % this.choices.length);
      this.render();
    }
    _(c, key) {
      if (c === " ")
        return this.submit();
    }
    get selection() {
      return this.choices[this.cursor];
    }
    render() {
      if (this.closed)
        return;
      if (this.firstRender)
        this.out.write(cursor.hide);
      else
        this.out.write(clear(this.outputText, this.out.columns));
      super.render();
      let {startIndex, endIndex} = entriesToDisplay(this.cursor, this.choices.length, this.optionsPerPage);
      this.outputText = [
        style.symbol(this.done, this.aborted),
        color.bold(this.msg),
        style.delimiter(false),
        this.done ? this.selection.title : this.selection.disabled ? color.yellow(this.warn) : color.gray(this.hint)
      ].join(" ");
      if (!this.done) {
        this.outputText += "\n";
        for (let i = startIndex; i < endIndex; i++) {
          let title, prefix, desc = "", v = this.choices[i];
          if (i === startIndex && startIndex > 0) {
            prefix = figures.arrowUp;
          } else if (i === endIndex - 1 && endIndex < this.choices.length) {
            prefix = figures.arrowDown;
          } else {
            prefix = " ";
          }
          if (v.disabled) {
            title = this.cursor === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
            prefix = (this.cursor === i ? color.bold().gray(figures.pointer) + " " : "  ") + prefix;
          } else {
            title = this.cursor === i ? color.cyan().underline(v.title) : v.title;
            prefix = (this.cursor === i ? color.cyan(figures.pointer) + " " : "  ") + prefix;
            if (v.description && this.cursor === i) {
              desc = ` - ${v.description}`;
              if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
                desc = "\n" + wrap(v.description, {margin: 3, width: this.out.columns});
              }
            }
          }
          this.outputText += `${prefix} ${title}${color.gray(desc)}
`;
        }
      }
      this.out.write(this.outputText);
    }
  };
  module2.exports = SelectPrompt;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/lib/elements/toggle.js
var require_toggle2 = __commonJS((exports2, module2) => {
  var color = require_kleur();
  var Prompt = require_prompt2();
  var {style, clear} = require_util9();
  var {cursor, erase} = require_src4();
  var TogglePrompt = class extends Prompt {
    constructor(opts = {}) {
      super(opts);
      this.msg = opts.message;
      this.value = !!opts.initial;
      this.active = opts.active || "on";
      this.inactive = opts.inactive || "off";
      this.initialValue = this.value;
      this.render();
    }
    reset() {
      this.value = this.initialValue;
      this.fire();
      this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = true;
      this.fire();
      this.render();
      this.out.write("\n");
      this.close();
    }
    submit() {
      this.done = true;
      this.aborted = false;
      this.fire();
      this.render();
      this.out.write("\n");
      this.close();
    }
    deactivate() {
      if (this.value === false)
        return this.bell();
      this.value = false;
      this.render();
    }
    activate() {
      if (this.value === true)
        return this.bell();
      this.value = true;
      this.render();
    }
    delete() {
      this.deactivate();
    }
    left() {
      this.deactivate();
    }
    right() {
      this.activate();
    }
    down() {
      this.deactivate();
    }
    up() {
      this.activate();
    }
    next() {
      this.value = !this.value;
      this.fire();
      this.render();
    }
    _(c, key) {
      if (c === " ") {
        this.value = !this.value;
      } else if (c === "1") {
        this.value = true;
      } else if (c === "0") {
        this.value = false;
      } else
        return this.bell();
      this.render();
    }
    render() {
      if (this.closed)
        return;
      if (this.firstRender)
        this.out.write(cursor.hide);
      else
        this.out.write(clear(this.outputText, this.out.columns));
      super.render();
      this.outputText = [
        style.symbol(this.done, this.aborted),
        color.bold(this.msg),
        style.delimiter(this.done),
        this.value ? this.inactive : color.cyan().underline(this.inactive),
        color.gray("/"),
        this.value ? color.cyan().underline(this.active) : this.active
      ].join(" ");
      this.out.write(erase.line + cursor.to(0) + this.outputText);
    }
  };
  module2.exports = TogglePrompt;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/lib/dateparts/datepart.js
var require_datepart2 = __commonJS((exports2, module2) => {
  "use strict";
  var DatePart = class {
    constructor({token, date, parts, locales}) {
      this.token = token;
      this.date = date || new Date();
      this.parts = parts || [this];
      this.locales = locales || {};
    }
    up() {
    }
    down() {
    }
    next() {
      const currentIdx = this.parts.indexOf(this);
      return this.parts.find((part, idx) => idx > currentIdx && part instanceof DatePart);
    }
    setTo(val) {
    }
    prev() {
      let parts = [].concat(this.parts).reverse();
      const currentIdx = parts.indexOf(this);
      return parts.find((part, idx) => idx > currentIdx && part instanceof DatePart);
    }
    toString() {
      return String(this.date);
    }
  };
  module2.exports = DatePart;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/lib/dateparts/meridiem.js
var require_meridiem2 = __commonJS((exports2, module2) => {
  "use strict";
  var DatePart = require_datepart2();
  var Meridiem = class extends DatePart {
    constructor(opts = {}) {
      super(opts);
    }
    up() {
      this.date.setHours((this.date.getHours() + 12) % 24);
    }
    down() {
      this.up();
    }
    toString() {
      let meridiem = this.date.getHours() > 12 ? "pm" : "am";
      return /\A/.test(this.token) ? meridiem.toUpperCase() : meridiem;
    }
  };
  module2.exports = Meridiem;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/lib/dateparts/day.js
var require_day2 = __commonJS((exports2, module2) => {
  "use strict";
  var DatePart = require_datepart2();
  var pos = (n) => {
    n = n % 10;
    return n === 1 ? "st" : n === 2 ? "nd" : n === 3 ? "rd" : "th";
  };
  var Day = class extends DatePart {
    constructor(opts = {}) {
      super(opts);
    }
    up() {
      this.date.setDate(this.date.getDate() + 1);
    }
    down() {
      this.date.setDate(this.date.getDate() - 1);
    }
    setTo(val) {
      this.date.setDate(parseInt(val.substr(-2)));
    }
    toString() {
      let date = this.date.getDate();
      let day = this.date.getDay();
      return this.token === "DD" ? String(date).padStart(2, "0") : this.token === "Do" ? date + pos(date) : this.token === "d" ? day + 1 : this.token === "ddd" ? this.locales.weekdaysShort[day] : this.token === "dddd" ? this.locales.weekdays[day] : date;
    }
  };
  module2.exports = Day;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/lib/dateparts/hours.js
var require_hours2 = __commonJS((exports2, module2) => {
  "use strict";
  var DatePart = require_datepart2();
  var Hours = class extends DatePart {
    constructor(opts = {}) {
      super(opts);
    }
    up() {
      this.date.setHours(this.date.getHours() + 1);
    }
    down() {
      this.date.setHours(this.date.getHours() - 1);
    }
    setTo(val) {
      this.date.setHours(parseInt(val.substr(-2)));
    }
    toString() {
      let hours = this.date.getHours();
      if (/h/.test(this.token))
        hours = hours % 12 || 12;
      return this.token.length > 1 ? String(hours).padStart(2, "0") : hours;
    }
  };
  module2.exports = Hours;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/lib/dateparts/milliseconds.js
var require_milliseconds2 = __commonJS((exports2, module2) => {
  "use strict";
  var DatePart = require_datepart2();
  var Milliseconds = class extends DatePart {
    constructor(opts = {}) {
      super(opts);
    }
    up() {
      this.date.setMilliseconds(this.date.getMilliseconds() + 1);
    }
    down() {
      this.date.setMilliseconds(this.date.getMilliseconds() - 1);
    }
    setTo(val) {
      this.date.setMilliseconds(parseInt(val.substr(-this.token.length)));
    }
    toString() {
      return String(this.date.getMilliseconds()).padStart(4, "0").substr(0, this.token.length);
    }
  };
  module2.exports = Milliseconds;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/lib/dateparts/minutes.js
var require_minutes2 = __commonJS((exports2, module2) => {
  "use strict";
  var DatePart = require_datepart2();
  var Minutes = class extends DatePart {
    constructor(opts = {}) {
      super(opts);
    }
    up() {
      this.date.setMinutes(this.date.getMinutes() + 1);
    }
    down() {
      this.date.setMinutes(this.date.getMinutes() - 1);
    }
    setTo(val) {
      this.date.setMinutes(parseInt(val.substr(-2)));
    }
    toString() {
      let m2 = this.date.getMinutes();
      return this.token.length > 1 ? String(m2).padStart(2, "0") : m2;
    }
  };
  module2.exports = Minutes;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/lib/dateparts/month.js
var require_month2 = __commonJS((exports2, module2) => {
  "use strict";
  var DatePart = require_datepart2();
  var Month = class extends DatePart {
    constructor(opts = {}) {
      super(opts);
    }
    up() {
      this.date.setMonth(this.date.getMonth() + 1);
    }
    down() {
      this.date.setMonth(this.date.getMonth() - 1);
    }
    setTo(val) {
      val = parseInt(val.substr(-2)) - 1;
      this.date.setMonth(val < 0 ? 0 : val);
    }
    toString() {
      let month = this.date.getMonth();
      let tl = this.token.length;
      return tl === 2 ? String(month + 1).padStart(2, "0") : tl === 3 ? this.locales.monthsShort[month] : tl === 4 ? this.locales.months[month] : String(month + 1);
    }
  };
  module2.exports = Month;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/lib/dateparts/seconds.js
var require_seconds2 = __commonJS((exports2, module2) => {
  "use strict";
  var DatePart = require_datepart2();
  var Seconds = class extends DatePart {
    constructor(opts = {}) {
      super(opts);
    }
    up() {
      this.date.setSeconds(this.date.getSeconds() + 1);
    }
    down() {
      this.date.setSeconds(this.date.getSeconds() - 1);
    }
    setTo(val) {
      this.date.setSeconds(parseInt(val.substr(-2)));
    }
    toString() {
      let s2 = this.date.getSeconds();
      return this.token.length > 1 ? String(s2).padStart(2, "0") : s2;
    }
  };
  module2.exports = Seconds;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/lib/dateparts/year.js
var require_year2 = __commonJS((exports2, module2) => {
  "use strict";
  var DatePart = require_datepart2();
  var Year = class extends DatePart {
    constructor(opts = {}) {
      super(opts);
    }
    up() {
      this.date.setFullYear(this.date.getFullYear() + 1);
    }
    down() {
      this.date.setFullYear(this.date.getFullYear() - 1);
    }
    setTo(val) {
      this.date.setFullYear(val.substr(-4));
    }
    toString() {
      let year = String(this.date.getFullYear()).padStart(4, "0");
      return this.token.length === 2 ? year.substr(-2) : year;
    }
  };
  module2.exports = Year;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/lib/dateparts/index.js
var require_dateparts2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    DatePart: require_datepart2(),
    Meridiem: require_meridiem2(),
    Day: require_day2(),
    Hours: require_hours2(),
    Milliseconds: require_milliseconds2(),
    Minutes: require_minutes2(),
    Month: require_month2(),
    Seconds: require_seconds2(),
    Year: require_year2()
  };
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/lib/elements/date.js
var require_date2 = __commonJS((exports2, module2) => {
  "use strict";
  var color = require_kleur();
  var Prompt = require_prompt2();
  var {style, clear, figures} = require_util9();
  var {erase, cursor} = require_src4();
  var {DatePart, Meridiem, Day, Hours, Milliseconds, Minutes, Month, Seconds, Year} = require_dateparts2();
  var regex = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g;
  var regexGroups = {
    1: ({token}) => token.replace(/\\(.)/g, "$1"),
    2: (opts) => new Day(opts),
    3: (opts) => new Month(opts),
    4: (opts) => new Year(opts),
    5: (opts) => new Meridiem(opts),
    6: (opts) => new Hours(opts),
    7: (opts) => new Minutes(opts),
    8: (opts) => new Seconds(opts),
    9: (opts) => new Milliseconds(opts)
  };
  var dfltLocales = {
    months: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
    monthsShort: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
    weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
    weekdaysShort: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(",")
  };
  var DatePrompt = class extends Prompt {
    constructor(opts = {}) {
      super(opts);
      this.msg = opts.message;
      this.cursor = 0;
      this.typed = "";
      this.locales = Object.assign(dfltLocales, opts.locales);
      this._date = opts.initial || new Date();
      this.errorMsg = opts.error || "Please Enter A Valid Value";
      this.validator = opts.validate || (() => true);
      this.mask = opts.mask || "YYYY-MM-DD HH:mm:ss";
      this.clear = clear("", this.out.columns);
      this.render();
    }
    get value() {
      return this.date;
    }
    get date() {
      return this._date;
    }
    set date(date) {
      if (date)
        this._date.setTime(date.getTime());
    }
    set mask(mask) {
      let result;
      this.parts = [];
      while (result = regex.exec(mask)) {
        let match = result.shift();
        let idx = result.findIndex((gr) => gr != null);
        this.parts.push(idx in regexGroups ? regexGroups[idx]({token: result[idx] || match, date: this.date, parts: this.parts, locales: this.locales}) : result[idx] || match);
      }
      let parts = this.parts.reduce((arr, i) => {
        if (typeof i === "string" && typeof arr[arr.length - 1] === "string")
          arr[arr.length - 1] += i;
        else
          arr.push(i);
        return arr;
      }, []);
      this.parts.splice(0);
      this.parts.push(...parts);
      this.reset();
    }
    moveCursor(n) {
      this.typed = "";
      this.cursor = n;
      this.fire();
    }
    reset() {
      this.moveCursor(this.parts.findIndex((p) => p instanceof DatePart));
      this.fire();
      this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = true;
      this.error = false;
      this.fire();
      this.render();
      this.out.write("\n");
      this.close();
    }
    async validate() {
      let valid = await this.validator(this.value);
      if (typeof valid === "string") {
        this.errorMsg = valid;
        valid = false;
      }
      this.error = !valid;
    }
    async submit() {
      await this.validate();
      if (this.error) {
        this.color = "red";
        this.fire();
        this.render();
        return;
      }
      this.done = true;
      this.aborted = false;
      this.fire();
      this.render();
      this.out.write("\n");
      this.close();
    }
    up() {
      this.typed = "";
      this.parts[this.cursor].up();
      this.render();
    }
    down() {
      this.typed = "";
      this.parts[this.cursor].down();
      this.render();
    }
    left() {
      let prev = this.parts[this.cursor].prev();
      if (prev == null)
        return this.bell();
      this.moveCursor(this.parts.indexOf(prev));
      this.render();
    }
    right() {
      let next = this.parts[this.cursor].next();
      if (next == null)
        return this.bell();
      this.moveCursor(this.parts.indexOf(next));
      this.render();
    }
    next() {
      let next = this.parts[this.cursor].next();
      this.moveCursor(next ? this.parts.indexOf(next) : this.parts.findIndex((part) => part instanceof DatePart));
      this.render();
    }
    _(c) {
      if (/\d/.test(c)) {
        this.typed += c;
        this.parts[this.cursor].setTo(this.typed);
        this.render();
      }
    }
    render() {
      if (this.closed)
        return;
      if (this.firstRender)
        this.out.write(cursor.hide);
      else
        this.out.write(clear(this.outputText, this.out.columns));
      super.render();
      this.outputText = [
        style.symbol(this.done, this.aborted),
        color.bold(this.msg),
        style.delimiter(false),
        this.parts.reduce((arr, p, idx) => arr.concat(idx === this.cursor && !this.done ? color.cyan().underline(p.toString()) : p), []).join("")
      ].join(" ");
      if (this.error) {
        this.outputText += this.errorMsg.split("\n").reduce((a, l, i) => a + `
${i ? ` ` : figures.pointerSmall} ${color.red().italic(l)}`, ``);
      }
      this.out.write(erase.line + cursor.to(0) + this.outputText);
    }
  };
  module2.exports = DatePrompt;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/lib/elements/number.js
var require_number2 = __commonJS((exports2, module2) => {
  var color = require_kleur();
  var Prompt = require_prompt2();
  var {cursor, erase} = require_src4();
  var {style, figures, clear, lines} = require_util9();
  var isNumber = /[0-9]/;
  var isDef = (any) => any !== void 0;
  var round = (number, precision) => {
    let factor = Math.pow(10, precision);
    return Math.round(number * factor) / factor;
  };
  var NumberPrompt = class extends Prompt {
    constructor(opts = {}) {
      super(opts);
      this.transform = style.render(opts.style);
      this.msg = opts.message;
      this.initial = isDef(opts.initial) ? opts.initial : "";
      this.float = !!opts.float;
      this.round = opts.round || 2;
      this.inc = opts.increment || 1;
      this.min = isDef(opts.min) ? opts.min : -Infinity;
      this.max = isDef(opts.max) ? opts.max : Infinity;
      this.errorMsg = opts.error || `Please Enter A Valid Value`;
      this.validator = opts.validate || (() => true);
      this.color = `cyan`;
      this.value = ``;
      this.typed = ``;
      this.lastHit = 0;
      this.render();
    }
    set value(v) {
      if (!v && v !== 0) {
        this.placeholder = true;
        this.rendered = color.gray(this.transform.render(`${this.initial}`));
        this._value = ``;
      } else {
        this.placeholder = false;
        this.rendered = this.transform.render(`${round(v, this.round)}`);
        this._value = round(v, this.round);
      }
      this.fire();
    }
    get value() {
      return this._value;
    }
    parse(x) {
      return this.float ? parseFloat(x) : parseInt(x);
    }
    valid(c) {
      return c === `-` || c === `.` && this.float || isNumber.test(c);
    }
    reset() {
      this.typed = ``;
      this.value = ``;
      this.fire();
      this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      let x = this.value;
      this.value = x !== `` ? x : this.initial;
      this.done = this.aborted = true;
      this.error = false;
      this.fire();
      this.render();
      this.out.write(`
`);
      this.close();
    }
    async validate() {
      let valid = await this.validator(this.value);
      if (typeof valid === `string`) {
        this.errorMsg = valid;
        valid = false;
      }
      this.error = !valid;
    }
    async submit() {
      await this.validate();
      if (this.error) {
        this.color = `red`;
        this.fire();
        this.render();
        return;
      }
      let x = this.value;
      this.value = x !== `` ? x : this.initial;
      this.done = true;
      this.aborted = false;
      this.error = false;
      this.fire();
      this.render();
      this.out.write(`
`);
      this.close();
    }
    up() {
      this.typed = ``;
      if (this.value === "") {
        this.value = this.min - this.inc;
      }
      if (this.value >= this.max)
        return this.bell();
      this.value += this.inc;
      this.color = `cyan`;
      this.fire();
      this.render();
    }
    down() {
      this.typed = ``;
      if (this.value === "") {
        this.value = this.min + this.inc;
      }
      if (this.value <= this.min)
        return this.bell();
      this.value -= this.inc;
      this.color = `cyan`;
      this.fire();
      this.render();
    }
    delete() {
      let val = this.value.toString();
      if (val.length === 0)
        return this.bell();
      this.value = this.parse(val = val.slice(0, -1)) || ``;
      if (this.value !== "" && this.value < this.min) {
        this.value = this.min;
      }
      this.color = `cyan`;
      this.fire();
      this.render();
    }
    next() {
      this.value = this.initial;
      this.fire();
      this.render();
    }
    _(c, key) {
      if (!this.valid(c))
        return this.bell();
      const now = Date.now();
      if (now - this.lastHit > 1e3)
        this.typed = ``;
      this.typed += c;
      this.lastHit = now;
      this.color = `cyan`;
      if (c === `.`)
        return this.fire();
      this.value = Math.min(this.parse(this.typed), this.max);
      if (this.value > this.max)
        this.value = this.max;
      if (this.value < this.min)
        this.value = this.min;
      this.fire();
      this.render();
    }
    render() {
      if (this.closed)
        return;
      if (!this.firstRender) {
        if (this.outputError)
          this.out.write(cursor.down(lines(this.outputError, this.out.columns) - 1) + clear(this.outputError, this.out.columns));
        this.out.write(clear(this.outputText, this.out.columns));
      }
      super.render();
      this.outputError = "";
      this.outputText = [
        style.symbol(this.done, this.aborted),
        color.bold(this.msg),
        style.delimiter(this.done),
        !this.done || !this.done && !this.placeholder ? color[this.color]().underline(this.rendered) : this.rendered
      ].join(` `);
      if (this.error) {
        this.outputError += this.errorMsg.split(`
`).reduce((a, l, i) => a + `
${i ? ` ` : figures.pointerSmall} ${color.red().italic(l)}`, ``);
      }
      this.out.write(erase.line + cursor.to(0) + this.outputText + cursor.save + this.outputError + cursor.restore);
    }
  };
  module2.exports = NumberPrompt;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/lib/elements/multiselect.js
var require_multiselect2 = __commonJS((exports2, module2) => {
  "use strict";
  var color = require_kleur();
  var {cursor} = require_src4();
  var Prompt = require_prompt2();
  var {clear, figures, style, wrap, entriesToDisplay} = require_util9();
  var MultiselectPrompt = class extends Prompt {
    constructor(opts = {}) {
      super(opts);
      this.msg = opts.message;
      this.cursor = opts.cursor || 0;
      this.scrollIndex = opts.cursor || 0;
      this.hint = opts.hint || "";
      this.warn = opts.warn || "- This option is disabled -";
      this.minSelected = opts.min;
      this.showMinError = false;
      this.maxChoices = opts.max;
      this.instructions = opts.instructions;
      this.optionsPerPage = opts.optionsPerPage || 10;
      this.value = opts.choices.map((ch, idx) => {
        if (typeof ch === "string")
          ch = {title: ch, value: idx};
        return {
          title: ch && (ch.title || ch.value || ch),
          description: ch && ch.description,
          value: ch && (ch.value === void 0 ? idx : ch.value),
          selected: ch && ch.selected,
          disabled: ch && ch.disabled
        };
      });
      this.clear = clear("", this.out.columns);
      if (!opts.overrideRender) {
        this.render();
      }
    }
    reset() {
      this.value.map((v) => !v.selected);
      this.cursor = 0;
      this.fire();
      this.render();
    }
    selected() {
      return this.value.filter((v) => v.selected);
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = true;
      this.fire();
      this.render();
      this.out.write("\n");
      this.close();
    }
    submit() {
      const selected = this.value.filter((e) => e.selected);
      if (this.minSelected && selected.length < this.minSelected) {
        this.showMinError = true;
        this.render();
      } else {
        this.done = true;
        this.aborted = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
    }
    first() {
      this.cursor = 0;
      this.render();
    }
    last() {
      this.cursor = this.value.length - 1;
      this.render();
    }
    next() {
      this.cursor = (this.cursor + 1) % this.value.length;
      this.render();
    }
    up() {
      if (this.cursor === 0) {
        this.cursor = this.value.length - 1;
      } else {
        this.cursor--;
      }
      this.render();
    }
    down() {
      if (this.cursor === this.value.length - 1) {
        this.cursor = 0;
      } else {
        this.cursor++;
      }
      this.render();
    }
    left() {
      this.value[this.cursor].selected = false;
      this.render();
    }
    right() {
      if (this.value.filter((e) => e.selected).length >= this.maxChoices)
        return this.bell();
      this.value[this.cursor].selected = true;
      this.render();
    }
    handleSpaceToggle() {
      const v = this.value[this.cursor];
      if (v.selected) {
        v.selected = false;
        this.render();
      } else if (v.disabled || this.value.filter((e) => e.selected).length >= this.maxChoices) {
        return this.bell();
      } else {
        v.selected = true;
        this.render();
      }
    }
    toggleAll() {
      if (this.maxChoices !== void 0 || this.value[this.cursor].disabled) {
        return this.bell();
      }
      const newSelected = !this.value[this.cursor].selected;
      this.value.filter((v) => !v.disabled).forEach((v) => v.selected = newSelected);
      this.render();
    }
    _(c, key) {
      if (c === " ") {
        this.handleSpaceToggle();
      } else if (c === "a") {
        this.toggleAll();
      } else {
        return this.bell();
      }
    }
    renderInstructions() {
      if (this.instructions === void 0 || this.instructions) {
        if (typeof this.instructions === "string") {
          return this.instructions;
        }
        return `
Instructions:
    ${figures.arrowUp}/${figures.arrowDown}: Highlight option
    ${figures.arrowLeft}/${figures.arrowRight}/[space]: Toggle selection
` + (this.maxChoices === void 0 ? `    a: Toggle all
` : "") + `    enter/return: Complete answer`;
      }
      return "";
    }
    renderOption(cursor2, v, i, arrowIndicator) {
      const prefix = (v.selected ? color.green(figures.radioOn) : figures.radioOff) + " " + arrowIndicator + " ";
      let title, desc;
      if (v.disabled) {
        title = cursor2 === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
      } else {
        title = cursor2 === i ? color.cyan().underline(v.title) : v.title;
        if (cursor2 === i && v.description) {
          desc = ` - ${v.description}`;
          if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
            desc = "\n" + wrap(v.description, {margin: prefix.length, width: this.out.columns});
          }
        }
      }
      return prefix + title + color.gray(desc || "");
    }
    paginateOptions(options) {
      if (options.length === 0) {
        return color.red("No matches for this query.");
      }
      let {startIndex, endIndex} = entriesToDisplay(this.cursor, options.length, this.optionsPerPage);
      let prefix, styledOptions = [];
      for (let i = startIndex; i < endIndex; i++) {
        if (i === startIndex && startIndex > 0) {
          prefix = figures.arrowUp;
        } else if (i === endIndex - 1 && endIndex < options.length) {
          prefix = figures.arrowDown;
        } else {
          prefix = " ";
        }
        styledOptions.push(this.renderOption(this.cursor, options[i], i, prefix));
      }
      return "\n" + styledOptions.join("\n");
    }
    renderOptions(options) {
      if (!this.done) {
        return this.paginateOptions(options);
      }
      return "";
    }
    renderDoneOrInstructions() {
      if (this.done) {
        return this.value.filter((e) => e.selected).map((v) => v.title).join(", ");
      }
      const output = [color.gray(this.hint), this.renderInstructions()];
      if (this.value[this.cursor].disabled) {
        output.push(color.yellow(this.warn));
      }
      return output.join(" ");
    }
    render() {
      if (this.closed)
        return;
      if (this.firstRender)
        this.out.write(cursor.hide);
      super.render();
      let prompt = [
        style.symbol(this.done, this.aborted),
        color.bold(this.msg),
        style.delimiter(false),
        this.renderDoneOrInstructions()
      ].join(" ");
      if (this.showMinError) {
        prompt += color.red(`You must select a minimum of ${this.minSelected} choices.`);
        this.showMinError = false;
      }
      prompt += this.renderOptions(this.value);
      this.out.write(this.clear + prompt);
      this.clear = clear(prompt, this.out.columns);
    }
  };
  module2.exports = MultiselectPrompt;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/lib/elements/autocomplete.js
var require_autocomplete2 = __commonJS((exports2, module2) => {
  "use strict";
  var color = require_kleur();
  var Prompt = require_prompt2();
  var {erase, cursor} = require_src4();
  var {style, clear, figures, wrap, entriesToDisplay} = require_util9();
  var getVal = (arr, i) => arr[i] && (arr[i].value || arr[i].title || arr[i]);
  var getTitle = (arr, i) => arr[i] && (arr[i].title || arr[i].value || arr[i]);
  var getIndex = (arr, valOrTitle) => {
    const index = arr.findIndex((el) => el.value === valOrTitle || el.title === valOrTitle);
    return index > -1 ? index : void 0;
  };
  var AutocompletePrompt = class extends Prompt {
    constructor(opts = {}) {
      super(opts);
      this.msg = opts.message;
      this.suggest = opts.suggest;
      this.choices = opts.choices;
      this.initial = typeof opts.initial === "number" ? opts.initial : getIndex(opts.choices, opts.initial);
      this.select = this.initial || opts.cursor || 0;
      this.i18n = {noMatches: opts.noMatches || "no matches found"};
      this.fallback = opts.fallback || this.initial;
      this.clearFirst = opts.clearFirst || false;
      this.suggestions = [];
      this.input = "";
      this.limit = opts.limit || 10;
      this.cursor = 0;
      this.transform = style.render(opts.style);
      this.scale = this.transform.scale;
      this.render = this.render.bind(this);
      this.complete = this.complete.bind(this);
      this.clear = clear("", this.out.columns);
      this.complete(this.render);
      this.render();
    }
    set fallback(fb) {
      this._fb = Number.isSafeInteger(parseInt(fb)) ? parseInt(fb) : fb;
    }
    get fallback() {
      let choice;
      if (typeof this._fb === "number")
        choice = this.choices[this._fb];
      else if (typeof this._fb === "string")
        choice = {title: this._fb};
      return choice || this._fb || {title: this.i18n.noMatches};
    }
    moveSelect(i) {
      this.select = i;
      if (this.suggestions.length > 0)
        this.value = getVal(this.suggestions, i);
      else
        this.value = this.fallback.value;
      this.fire();
    }
    async complete(cb) {
      const p = this.completing = this.suggest(this.input, this.choices);
      const suggestions = await p;
      if (this.completing !== p)
        return;
      this.suggestions = suggestions.map((s2, i, arr) => ({title: getTitle(arr, i), value: getVal(arr, i), description: s2.description}));
      this.completing = false;
      const l = Math.max(suggestions.length - 1, 0);
      this.moveSelect(Math.min(l, this.select));
      cb && cb();
    }
    reset() {
      this.input = "";
      this.complete(() => {
        this.moveSelect(this.initial !== void 0 ? this.initial : 0);
        this.render();
      });
      this.render();
    }
    exit() {
      if (this.clearFirst && this.input.length > 0) {
        this.reset();
      } else {
        this.done = this.exited = true;
        this.aborted = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
    }
    abort() {
      this.done = this.aborted = true;
      this.exited = false;
      this.fire();
      this.render();
      this.out.write("\n");
      this.close();
    }
    submit() {
      this.done = true;
      this.aborted = this.exited = false;
      this.fire();
      this.render();
      this.out.write("\n");
      this.close();
    }
    _(c, key) {
      let s1 = this.input.slice(0, this.cursor);
      let s2 = this.input.slice(this.cursor);
      this.input = `${s1}${c}${s2}`;
      this.cursor = s1.length + 1;
      this.complete(this.render);
      this.render();
    }
    delete() {
      if (this.cursor === 0)
        return this.bell();
      let s1 = this.input.slice(0, this.cursor - 1);
      let s2 = this.input.slice(this.cursor);
      this.input = `${s1}${s2}`;
      this.complete(this.render);
      this.cursor = this.cursor - 1;
      this.render();
    }
    deleteForward() {
      if (this.cursor * this.scale >= this.rendered.length)
        return this.bell();
      let s1 = this.input.slice(0, this.cursor);
      let s2 = this.input.slice(this.cursor + 1);
      this.input = `${s1}${s2}`;
      this.complete(this.render);
      this.render();
    }
    first() {
      this.moveSelect(0);
      this.render();
    }
    last() {
      this.moveSelect(this.suggestions.length - 1);
      this.render();
    }
    up() {
      if (this.select === 0) {
        this.moveSelect(this.suggestions.length - 1);
      } else {
        this.moveSelect(this.select - 1);
      }
      this.render();
    }
    down() {
      if (this.select === this.suggestions.length - 1) {
        this.moveSelect(0);
      } else {
        this.moveSelect(this.select + 1);
      }
      this.render();
    }
    next() {
      if (this.select === this.suggestions.length - 1) {
        this.moveSelect(0);
      } else
        this.moveSelect(this.select + 1);
      this.render();
    }
    nextPage() {
      this.moveSelect(Math.min(this.select + this.limit, this.suggestions.length - 1));
      this.render();
    }
    prevPage() {
      this.moveSelect(Math.max(this.select - this.limit, 0));
      this.render();
    }
    left() {
      if (this.cursor <= 0)
        return this.bell();
      this.cursor = this.cursor - 1;
      this.render();
    }
    right() {
      if (this.cursor * this.scale >= this.rendered.length)
        return this.bell();
      this.cursor = this.cursor + 1;
      this.render();
    }
    renderOption(v, hovered, isStart, isEnd) {
      let desc;
      let prefix = isStart ? figures.arrowUp : isEnd ? figures.arrowDown : " ";
      let title = hovered ? color.cyan().underline(v.title) : v.title;
      prefix = (hovered ? color.cyan(figures.pointer) + " " : "  ") + prefix;
      if (v.description) {
        desc = ` - ${v.description}`;
        if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
          desc = "\n" + wrap(v.description, {margin: 3, width: this.out.columns});
        }
      }
      return prefix + " " + title + color.gray(desc || "");
    }
    render() {
      if (this.closed)
        return;
      if (this.firstRender)
        this.out.write(cursor.hide);
      else
        this.out.write(clear(this.outputText, this.out.columns));
      super.render();
      let {startIndex, endIndex} = entriesToDisplay(this.select, this.choices.length, this.limit);
      this.outputText = [
        style.symbol(this.done, this.aborted, this.exited),
        color.bold(this.msg),
        style.delimiter(this.completing),
        this.done && this.suggestions[this.select] ? this.suggestions[this.select].title : this.rendered = this.transform.render(this.input)
      ].join(" ");
      if (!this.done) {
        const suggestions = this.suggestions.slice(startIndex, endIndex).map((item, i) => this.renderOption(item, this.select === i + startIndex, i === 0 && startIndex > 0, i + startIndex === endIndex - 1 && endIndex < this.choices.length)).join("\n");
        this.outputText += `
` + (suggestions || color.gray(this.fallback.title));
      }
      this.out.write(erase.line + cursor.to(0) + this.outputText);
    }
  };
  module2.exports = AutocompletePrompt;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/lib/elements/autocompleteMultiselect.js
var require_autocompleteMultiselect2 = __commonJS((exports2, module2) => {
  "use strict";
  var color = require_kleur();
  var {cursor} = require_src4();
  var MultiselectPrompt = require_multiselect2();
  var {clear, style, figures} = require_util9();
  var AutocompleteMultiselectPrompt = class extends MultiselectPrompt {
    constructor(opts = {}) {
      opts.overrideRender = true;
      super(opts);
      this.inputValue = "";
      this.clear = clear("", this.out.columns);
      this.filteredOptions = this.value;
      this.render();
    }
    last() {
      this.cursor = this.filteredOptions.length - 1;
      this.render();
    }
    next() {
      this.cursor = (this.cursor + 1) % this.filteredOptions.length;
      this.render();
    }
    up() {
      if (this.cursor === 0) {
        this.cursor = this.filteredOptions.length - 1;
      } else {
        this.cursor--;
      }
      this.render();
    }
    down() {
      if (this.cursor === this.filteredOptions.length - 1) {
        this.cursor = 0;
      } else {
        this.cursor++;
      }
      this.render();
    }
    left() {
      this.filteredOptions[this.cursor].selected = false;
      this.render();
    }
    right() {
      if (this.value.filter((e) => e.selected).length >= this.maxChoices)
        return this.bell();
      this.filteredOptions[this.cursor].selected = true;
      this.render();
    }
    delete() {
      if (this.inputValue.length) {
        this.inputValue = this.inputValue.substr(0, this.inputValue.length - 1);
        this.updateFilteredOptions();
      }
    }
    updateFilteredOptions() {
      const currentHighlight = this.filteredOptions[this.cursor];
      this.filteredOptions = this.value.filter((v) => {
        if (this.inputValue) {
          if (typeof v.title === "string") {
            if (v.title.toLowerCase().includes(this.inputValue.toLowerCase())) {
              return true;
            }
          }
          if (typeof v.value === "string") {
            if (v.value.toLowerCase().includes(this.inputValue.toLowerCase())) {
              return true;
            }
          }
          return false;
        }
        return true;
      });
      const newHighlightIndex = this.filteredOptions.findIndex((v) => v === currentHighlight);
      this.cursor = newHighlightIndex < 0 ? 0 : newHighlightIndex;
      this.render();
    }
    handleSpaceToggle() {
      const v = this.filteredOptions[this.cursor];
      if (v.selected) {
        v.selected = false;
        this.render();
      } else if (v.disabled || this.value.filter((e) => e.selected).length >= this.maxChoices) {
        return this.bell();
      } else {
        v.selected = true;
        this.render();
      }
    }
    handleInputChange(c) {
      this.inputValue = this.inputValue + c;
      this.updateFilteredOptions();
    }
    _(c, key) {
      if (c === " ") {
        this.handleSpaceToggle();
      } else {
        this.handleInputChange(c);
      }
    }
    renderInstructions() {
      if (this.instructions === void 0 || this.instructions) {
        if (typeof this.instructions === "string") {
          return this.instructions;
        }
        return `
Instructions:
    ${figures.arrowUp}/${figures.arrowDown}: Highlight option
    ${figures.arrowLeft}/${figures.arrowRight}/[space]: Toggle selection
    [a,b,c]/delete: Filter choices
    enter/return: Complete answer
`;
      }
      return "";
    }
    renderCurrentInput() {
      return `
Filtered results for: ${this.inputValue ? this.inputValue : color.gray("Enter something to filter")}
`;
    }
    renderOption(cursor2, v, i) {
      let title;
      if (v.disabled)
        title = cursor2 === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
      else
        title = cursor2 === i ? color.cyan().underline(v.title) : v.title;
      return (v.selected ? color.green(figures.radioOn) : figures.radioOff) + "  " + title;
    }
    renderDoneOrInstructions() {
      if (this.done) {
        return this.value.filter((e) => e.selected).map((v) => v.title).join(", ");
      }
      const output = [color.gray(this.hint), this.renderInstructions(), this.renderCurrentInput()];
      if (this.filteredOptions.length && this.filteredOptions[this.cursor].disabled) {
        output.push(color.yellow(this.warn));
      }
      return output.join(" ");
    }
    render() {
      if (this.closed)
        return;
      if (this.firstRender)
        this.out.write(cursor.hide);
      super.render();
      let prompt = [
        style.symbol(this.done, this.aborted),
        color.bold(this.msg),
        style.delimiter(false),
        this.renderDoneOrInstructions()
      ].join(" ");
      if (this.showMinError) {
        prompt += color.red(`You must select a minimum of ${this.minSelected} choices.`);
        this.showMinError = false;
      }
      prompt += this.renderOptions(this.filteredOptions);
      this.out.write(this.clear + prompt);
      this.clear = clear(prompt, this.out.columns);
    }
  };
  module2.exports = AutocompleteMultiselectPrompt;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/lib/elements/confirm.js
var require_confirm2 = __commonJS((exports2, module2) => {
  var color = require_kleur();
  var Prompt = require_prompt2();
  var {style, clear} = require_util9();
  var {erase, cursor} = require_src4();
  var ConfirmPrompt = class extends Prompt {
    constructor(opts = {}) {
      super(opts);
      this.msg = opts.message;
      this.value = opts.initial;
      this.initialValue = !!opts.initial;
      this.yesMsg = opts.yes || "yes";
      this.yesOption = opts.yesOption || "(Y/n)";
      this.noMsg = opts.no || "no";
      this.noOption = opts.noOption || "(y/N)";
      this.render();
    }
    reset() {
      this.value = this.initialValue;
      this.fire();
      this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = true;
      this.fire();
      this.render();
      this.out.write("\n");
      this.close();
    }
    submit() {
      this.value = this.value || false;
      this.done = true;
      this.aborted = false;
      this.fire();
      this.render();
      this.out.write("\n");
      this.close();
    }
    _(c, key) {
      if (c.toLowerCase() === "y") {
        this.value = true;
        return this.submit();
      }
      if (c.toLowerCase() === "n") {
        this.value = false;
        return this.submit();
      }
      return this.bell();
    }
    render() {
      if (this.closed)
        return;
      if (this.firstRender)
        this.out.write(cursor.hide);
      else
        this.out.write(clear(this.outputText, this.out.columns));
      super.render();
      this.outputText = [
        style.symbol(this.done, this.aborted),
        color.bold(this.msg),
        style.delimiter(this.done),
        this.done ? this.value ? this.yesMsg : this.noMsg : color.gray(this.initialValue ? this.yesOption : this.noOption)
      ].join(" ");
      this.out.write(erase.line + cursor.to(0) + this.outputText);
    }
  };
  module2.exports = ConfirmPrompt;
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/lib/elements/index.js
var require_elements2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    TextPrompt: require_text2(),
    SelectPrompt: require_select2(),
    TogglePrompt: require_toggle2(),
    DatePrompt: require_date2(),
    NumberPrompt: require_number2(),
    MultiselectPrompt: require_multiselect2(),
    AutocompletePrompt: require_autocomplete2(),
    AutocompleteMultiselectPrompt: require_autocompleteMultiselect2(),
    ConfirmPrompt: require_confirm2()
  };
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/lib/prompts.js
var require_prompts2 = __commonJS((exports2) => {
  "use strict";
  var $ = exports2;
  var el = require_elements2();
  var noop = (v) => v;
  function toPrompt(type, args2, opts = {}) {
    return new Promise((res, rej) => {
      const p = new el[type](args2);
      const onAbort = opts.onAbort || noop;
      const onSubmit = opts.onSubmit || noop;
      const onExit = opts.onExit || noop;
      p.on("state", args2.onState || noop);
      p.on("submit", (x) => res(onSubmit(x)));
      p.on("exit", (x) => res(onExit(x)));
      p.on("abort", (x) => rej(onAbort(x)));
    });
  }
  $.text = (args2) => toPrompt("TextPrompt", args2);
  $.password = (args2) => {
    args2.style = "password";
    return $.text(args2);
  };
  $.invisible = (args2) => {
    args2.style = "invisible";
    return $.text(args2);
  };
  $.number = (args2) => toPrompt("NumberPrompt", args2);
  $.date = (args2) => toPrompt("DatePrompt", args2);
  $.confirm = (args2) => toPrompt("ConfirmPrompt", args2);
  $.list = (args2) => {
    const sep = args2.separator || ",";
    return toPrompt("TextPrompt", args2, {
      onSubmit: (str) => str.split(sep).map((s2) => s2.trim())
    });
  };
  $.toggle = (args2) => toPrompt("TogglePrompt", args2);
  $.select = (args2) => toPrompt("SelectPrompt", args2);
  $.multiselect = (args2) => {
    args2.choices = [].concat(args2.choices || []);
    const toSelected = (items) => items.filter((item) => item.selected).map((item) => item.value);
    return toPrompt("MultiselectPrompt", args2, {
      onAbort: toSelected,
      onSubmit: toSelected
    });
  };
  $.autocompleteMultiselect = (args2) => {
    args2.choices = [].concat(args2.choices || []);
    const toSelected = (items) => items.filter((item) => item.selected).map((item) => item.value);
    return toPrompt("AutocompleteMultiselectPrompt", args2, {
      onAbort: toSelected,
      onSubmit: toSelected
    });
  };
  var byTitle = (input, choices) => Promise.resolve(choices.filter((item) => item.title.slice(0, input.length).toLowerCase() === input.toLowerCase()));
  $.autocomplete = (args2) => {
    args2.suggest = args2.suggest || byTitle;
    args2.choices = [].concat(args2.choices || []);
    return toPrompt("AutocompletePrompt", args2);
  };
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/lib/index.js
var require_lib7 = __commonJS((exports2, module2) => {
  "use strict";
  var prompts = require_prompts2();
  var passOn = ["suggest", "format", "onState", "validate", "onRender", "type"];
  var noop = () => {
  };
  async function prompt(questions = [], {onSubmit = noop, onCancel = noop} = {}) {
    const answers = {};
    const override2 = prompt._override || {};
    questions = [].concat(questions);
    let answer, question, quit, name, type, lastPrompt;
    const getFormattedAnswer = async (question2, answer2, skipValidation = false) => {
      if (!skipValidation && question2.validate && question2.validate(answer2) !== true) {
        return;
      }
      return question2.format ? await question2.format(answer2, answers) : answer2;
    };
    for (question of questions) {
      ({name, type} = question);
      if (typeof type === "function") {
        type = await type(answer, {...answers}, question);
        question["type"] = type;
      }
      if (!type)
        continue;
      for (let key in question) {
        if (passOn.includes(key))
          continue;
        let value = question[key];
        question[key] = typeof value === "function" ? await value(answer, {...answers}, lastPrompt) : value;
      }
      lastPrompt = question;
      if (typeof question.message !== "string") {
        throw new Error("prompt message is required");
      }
      ({name, type} = question);
      if (prompts[type] === void 0) {
        throw new Error(`prompt type (${type}) is not defined`);
      }
      if (override2[question.name] !== void 0) {
        answer = await getFormattedAnswer(question, override2[question.name]);
        if (answer !== void 0) {
          answers[name] = answer;
          continue;
        }
      }
      try {
        answer = prompt._injected ? getInjectedAnswer(prompt._injected, question.initial) : await prompts[type](question);
        answers[name] = answer = await getFormattedAnswer(question, answer, true);
        quit = await onSubmit(question, answer, answers);
      } catch (err) {
        quit = !await onCancel(question, answers);
      }
      if (quit)
        return answers;
    }
    return answers;
  }
  function getInjectedAnswer(injected, deafultValue) {
    const answer = injected.shift();
    if (answer instanceof Error) {
      throw answer;
    }
    return answer === void 0 ? deafultValue : answer;
  }
  function inject(answers) {
    prompt._injected = (prompt._injected || []).concat(answers);
  }
  function override(answers) {
    prompt._override = Object.assign({}, answers);
  }
  module2.exports = Object.assign(prompt, {prompt, prompts, inject, override});
});

// ../../node_modules/.pnpm/prompts@2.4.1/node_modules/prompts/index.js
var require_prompts3 = __commonJS((exports2, module2) => {
  function isNodeLT(tar) {
    tar = (Array.isArray(tar) ? tar : tar.split(".")).map(Number);
    let i = 0, src = process.versions.node.split(".").map(Number);
    for (; i < tar.length; i++) {
      if (src[i] > tar[i])
        return false;
      if (tar[i] > src[i])
        return true;
    }
    return false;
  }
  module2.exports = isNodeLT("8.6.0") ? require_dist14() : require_lib7();
});

// ../migrate/dist/utils/ensureDatabaseExists.js
var require_ensureDatabaseExists = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    askToCreateDb: () => askToCreateDb,
    ensureCanConnectToDatabase: () => ensureCanConnectToDatabase,
    ensureDatabaseExists: () => ensureDatabaseExists,
    getDbInfo: () => getDbInfo,
    getDbLocation: () => getDbLocation,
    getDbinfoFromCredentials: () => getDbinfoFromCredentials,
    interactivelyCreateDatabase: () => interactivelyCreateDatabase
  });
  var import_sdk18 = __toModule3(require_dist12());
  var import_sdk22 = __toModule3(require_dist12());
  var import_chalk14 = __toModule3(require_source());
  var import_sdk32 = __toModule3(require_dist12());
  var import_prompts = __toModule3(require_prompts3());
  async function getDbInfo(schemaPath) {
    const datamodel = await (0, import_sdk18.getSchema)(schemaPath);
    const config = await (0, import_sdk22.getConfig)({datamodel});
    const activeDatasource = config.datasources[0];
    const url = activeDatasource.url.value;
    if (activeDatasource.provider === "sqlserver") {
      return {
        name: activeDatasource.name,
        schemaWord: "database",
        dbType: "SQL Server",
        dbName: void 0,
        dbLocation: void 0,
        url: activeDatasource.url.value
      };
    }
    try {
      const credentials = (0, import_sdk32.uriToCredentials)(url);
      const dbLocation = getDbLocation(credentials);
      const dbinfoFromCredentials = getDbinfoFromCredentials(credentials);
      return {
        name: activeDatasource.name,
        dbLocation,
        ...dbinfoFromCredentials,
        url,
        schema: credentials.schema
      };
    } catch (e) {
      return {
        name: activeDatasource.name,
        schemaWord: "database",
        dbType: void 0,
        dbName: void 0,
        dbLocation: void 0,
        url
      };
    }
  }
  async function ensureCanConnectToDatabase(schemaPath) {
    const datamodel = await (0, import_sdk18.getSchema)(schemaPath);
    const config = await (0, import_sdk22.getConfig)({datamodel});
    const activeDatasource = config.datasources[0];
    if (!activeDatasource) {
      throw new Error(`Couldn't find a datasource in the schema.prisma file`);
    }
    if (activeDatasource.provider === "mongodb") {
      throw new Error(`"mongodb" provider is not supported with this command. For more info see https://www.prisma.io/docs/concepts/database-connectors/mongodb`);
    }
    const schemaDir = await (0, import_sdk18.getSchemaDir)(schemaPath);
    const canConnect = await (0, import_sdk32.canConnectToDatabase)(activeDatasource.url.value, schemaDir);
    if (canConnect === true) {
      return true;
    } else {
      const {code, message} = canConnect;
      throw new Error(`${code}: ${message}`);
    }
  }
  async function ensureDatabaseExists(action, forceCreate = false, schemaPath) {
    const datamodel = await (0, import_sdk18.getSchema)(schemaPath);
    const config = await (0, import_sdk22.getConfig)({datamodel});
    const activeDatasource = config.datasources[0];
    if (!activeDatasource) {
      throw new Error(`Couldn't find a datasource in the schema.prisma file`);
    }
    if (activeDatasource.provider === "mongodb") {
      throw new Error(`"mongodb" provider is not supported with this command. For more info see https://www.prisma.io/docs/concepts/database-connectors/mongodb`);
    }
    const schemaDir = await (0, import_sdk18.getSchemaDir)(schemaPath);
    const canConnect = await (0, import_sdk32.canConnectToDatabase)(activeDatasource.url.value, schemaDir);
    if (canConnect === true) {
      return;
    }
    const {code, message} = canConnect;
    if (code !== "P1003") {
      throw new Error(`${code}: ${message}`);
    }
    if (!schemaDir) {
      throw new Error(`Could not locate ${schemaPath || "schema.prisma"}`);
    }
    if (forceCreate) {
      if (await (0, import_sdk32.createDatabase)(activeDatasource.url.value, schemaDir)) {
        if (activeDatasource.provider === "sqlserver") {
          return `SQL Server database created.
`;
        }
        const credentials = (0, import_sdk32.uriToCredentials)(activeDatasource.url.value);
        const {schemaWord, dbType, dbName} = getDbinfoFromCredentials(credentials);
        if (dbType && dbType !== "SQL Server") {
          return `${dbType} ${schemaWord} ${import_chalk14.default.bold(dbName)} created at ${import_chalk14.default.bold(getDbLocation(credentials))}
`;
        } else {
          return `${schemaWord} created.
`;
        }
      }
    } else {
      await interactivelyCreateDatabase(activeDatasource.url.value, action, schemaDir);
    }
    return void 0;
  }
  async function interactivelyCreateDatabase(connectionString, action, schemaDir) {
    await askToCreateDb(connectionString, action, schemaDir);
  }
  async function askToCreateDb(connectionString, action, schemaDir) {
    const credentials = (0, import_sdk32.uriToCredentials)(connectionString);
    const {schemaWord, dbType, dbName} = getDbinfoFromCredentials(credentials);
    const dbLocation = getDbLocation(credentials);
    let message;
    if (dbName && dbLocation) {
      message = `You are trying to ${action} a migration for ${dbType} ${schemaWord} ${import_chalk14.default.bold(dbName)}.
A ${schemaWord} with that name doesn't exist at ${import_chalk14.default.bold(dbLocation)}.
`;
    } else {
      message = `You are trying to ${action} a migration for ${dbType} ${schemaWord}.
The ${schemaWord} doesn't exist.
`;
    }
    console.info();
    const response = await (0, import_prompts.default)({
      type: "select",
      name: "value",
      message,
      initial: 0,
      choices: [
        {
          title: "Yes",
          value: true,
          description: `Create new ${dbType} ${schemaWord} ${import_chalk14.default.bold(dbName)}`
        },
        {
          title: "No",
          value: false,
          description: `Don't create the ${schemaWord}`
        }
      ]
    });
    if (response.value) {
      await (0, import_sdk32.createDatabase)(connectionString, schemaDir);
    } else {
      process.exit(0);
    }
  }
  function getDbLocation(credentials) {
    if (credentials.type === "sqlite") {
      return credentials.uri;
    }
    if (!credentials.port) {
      switch (credentials.type) {
        case "mysql":
          credentials.port = 3306;
          break;
        case "postgresql":
          credentials.port = 5432;
          break;
        case "sqlserver":
          credentials.port = 1433;
          break;
      }
    }
    return `${credentials.host}:${credentials.port}`;
  }
  function getDbinfoFromCredentials(credentials) {
    const dbName = credentials.database;
    let dbType;
    switch (credentials.type) {
      case "mysql":
        dbType = `MySQL`;
        break;
      case "postgresql":
        dbType = `PostgreSQL`;
        break;
      case "sqlite":
        dbType = `SQLite`;
        break;
      case "sqlserver":
        dbType = `SQL Server`;
        break;
    }
    const schemaWord = "database";
    return {
      dbName,
      dbType,
      schemaWord
    };
  }
});

// ../migrate/dist/utils/printMigrationId.js
var require_printMigrationId = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    printMigrationId: () => printMigrationId,
    printMigrationIds: () => printMigrationIds
  });
  var import_chalk14 = __toModule3(require_source());
  function printMigrationId(migrationId) {
    const words = migrationId.split("_");
    if (words.length === 1) {
      return import_chalk14.default.cyan.bold(migrationId);
    }
    return `${words[0]}_${import_chalk14.default.cyan.bold(words.slice(1).join("_"))}`;
  }
  function printMigrationIds(migrationIds) {
    return migrationIds.reduce((acc, migrationId) => {
      return acc + "- " + printMigrationId(migrationId) + "\n";
    }, "");
  }
});

// ../migrate/dist/utils/printFiles.js
var require_printFiles = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    printFiles: () => printFiles,
    printFilesFromMigrationIds: () => printFilesFromMigrationIds
  });
  var import_indent_string = __toModule3(require_indent_string());
  var import_printMigrationId = __toModule3(require_printMigrationId());
  function printFiles(printPath, files) {
    const fileNames = Object.keys(files);
    const folders = printPath.split("/");
    const deepFolder = folders[1];
    return `${folders[0]}/
  \u2514\u2500 ${`${(0, import_printMigrationId.printMigrationId)(deepFolder)}/`}
${(0, import_indent_string.default)(fileNames.map((f) => `\u2514\u2500 ${f}`).join("\n"), 4)}`;
  }
  function printFilesFromMigrationIds(directory, migrationIds, files) {
    const fileNames = Object.keys(files);
    let message = `${directory}/`;
    migrationIds.forEach((migrationId) => {
      message += `
  \u2514\u2500 ${(0, import_printMigrationId.printMigrationId)(migrationId)}/
${(0, import_indent_string.default)(fileNames.map((f) => `\u2514\u2500 ${f}`).join("\n"), 4)}`;
    });
    return message;
  }
});

// ../migrate/dist/utils/handleEvaluateDataloss.js
var require_handleEvaluateDataloss = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    handleUnexecutableSteps: () => handleUnexecutableSteps
  });
  var import_chalk14 = __toModule3(require_source());
  var import_sdk18 = __toModule3(require_dist12());
  function handleUnexecutableSteps(unexecutableSteps, createOnly = false) {
    if (unexecutableSteps && unexecutableSteps.length > 0) {
      const messages = [];
      messages.push(`${import_chalk14.default.bold.red("\n\u26A0\uFE0F We found changes that cannot be executed:\n")}`);
      for (const item of unexecutableSteps) {
        messages.push(`${(0, import_chalk14.default)(`  \u2022 Step ${item.stepIndex} ${item.message}`)}`);
      }
      console.info();
      if (createOnly) {
        console.error(`${messages.join("\n")}
`);
        return void 0;
      } else {
        return `${messages.join("\n")}

You can use ${(0, import_sdk18.getCommandWithExecutor)("prisma migrate dev --create-only")} to create the migration file, and manually modify it to address the underlying issue(s).
Then run ${(0, import_sdk18.getCommandWithExecutor)("prisma migrate dev")} to apply it and verify it works.
`;
      }
    }
    return void 0;
  }
});

// ../../node_modules/.pnpm/escape-string-regexp@4.0.0/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (string) => {
    if (typeof string !== "string") {
      throw new TypeError("Expected a string");
    }
    return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
  };
});

// ../../node_modules/.pnpm/lodash.deburr@4.1.0/node_modules/lodash.deburr/index.js
var require_lodash6 = __commonJS((exports2, module2) => {
  var INFINITY = 1 / 0;
  var symbolTag = "[object Symbol]";
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
  var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
  var rsComboSymbolsRange = "\\u20d0-\\u20f0";
  var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
  var reComboMark = RegExp(rsCombo, "g");
  var deburredLetters = {
    \u00C0: "A",
    \u00C1: "A",
    \u00C2: "A",
    \u00C3: "A",
    \u00C4: "A",
    \u00C5: "A",
    \u00E0: "a",
    \u00E1: "a",
    \u00E2: "a",
    \u00E3: "a",
    \u00E4: "a",
    \u00E5: "a",
    \u00C7: "C",
    \u00E7: "c",
    \u00D0: "D",
    \u00F0: "d",
    \u00C8: "E",
    \u00C9: "E",
    \u00CA: "E",
    \u00CB: "E",
    \u00E8: "e",
    \u00E9: "e",
    \u00EA: "e",
    \u00EB: "e",
    \u00CC: "I",
    \u00CD: "I",
    \u00CE: "I",
    \u00CF: "I",
    \u00EC: "i",
    \u00ED: "i",
    \u00EE: "i",
    \u00EF: "i",
    \u00D1: "N",
    \u00F1: "n",
    \u00D2: "O",
    \u00D3: "O",
    \u00D4: "O",
    \u00D5: "O",
    \u00D6: "O",
    \u00D8: "O",
    \u00F2: "o",
    \u00F3: "o",
    \u00F4: "o",
    \u00F5: "o",
    \u00F6: "o",
    \u00F8: "o",
    \u00D9: "U",
    \u00DA: "U",
    \u00DB: "U",
    \u00DC: "U",
    \u00F9: "u",
    \u00FA: "u",
    \u00FB: "u",
    \u00FC: "u",
    \u00DD: "Y",
    \u00FD: "y",
    \u00FF: "y",
    \u00C6: "Ae",
    \u00E6: "ae",
    \u00DE: "Th",
    \u00FE: "th",
    \u00DF: "ss",
    \u0100: "A",
    \u0102: "A",
    \u0104: "A",
    \u0101: "a",
    \u0103: "a",
    \u0105: "a",
    \u0106: "C",
    \u0108: "C",
    \u010A: "C",
    \u010C: "C",
    \u0107: "c",
    \u0109: "c",
    \u010B: "c",
    \u010D: "c",
    \u010E: "D",
    \u0110: "D",
    \u010F: "d",
    \u0111: "d",
    \u0112: "E",
    \u0114: "E",
    \u0116: "E",
    \u0118: "E",
    \u011A: "E",
    \u0113: "e",
    \u0115: "e",
    \u0117: "e",
    \u0119: "e",
    \u011B: "e",
    \u011C: "G",
    \u011E: "G",
    \u0120: "G",
    \u0122: "G",
    \u011D: "g",
    \u011F: "g",
    \u0121: "g",
    \u0123: "g",
    \u0124: "H",
    \u0126: "H",
    \u0125: "h",
    \u0127: "h",
    \u0128: "I",
    \u012A: "I",
    \u012C: "I",
    \u012E: "I",
    \u0130: "I",
    \u0129: "i",
    \u012B: "i",
    \u012D: "i",
    \u012F: "i",
    \u0131: "i",
    \u0134: "J",
    \u0135: "j",
    \u0136: "K",
    \u0137: "k",
    \u0138: "k",
    \u0139: "L",
    \u013B: "L",
    \u013D: "L",
    \u013F: "L",
    \u0141: "L",
    \u013A: "l",
    \u013C: "l",
    \u013E: "l",
    \u0140: "l",
    \u0142: "l",
    \u0143: "N",
    \u0145: "N",
    \u0147: "N",
    \u014A: "N",
    \u0144: "n",
    \u0146: "n",
    \u0148: "n",
    \u014B: "n",
    \u014C: "O",
    \u014E: "O",
    \u0150: "O",
    \u014D: "o",
    \u014F: "o",
    \u0151: "o",
    \u0154: "R",
    \u0156: "R",
    \u0158: "R",
    \u0155: "r",
    \u0157: "r",
    \u0159: "r",
    \u015A: "S",
    \u015C: "S",
    \u015E: "S",
    \u0160: "S",
    \u015B: "s",
    \u015D: "s",
    \u015F: "s",
    \u0161: "s",
    \u0162: "T",
    \u0164: "T",
    \u0166: "T",
    \u0163: "t",
    \u0165: "t",
    \u0167: "t",
    \u0168: "U",
    \u016A: "U",
    \u016C: "U",
    \u016E: "U",
    \u0170: "U",
    \u0172: "U",
    \u0169: "u",
    \u016B: "u",
    \u016D: "u",
    \u016F: "u",
    \u0171: "u",
    \u0173: "u",
    \u0174: "W",
    \u0175: "w",
    \u0176: "Y",
    \u0177: "y",
    \u0178: "Y",
    \u0179: "Z",
    \u017B: "Z",
    \u017D: "Z",
    \u017A: "z",
    \u017C: "z",
    \u017E: "z",
    \u0132: "IJ",
    \u0133: "ij",
    \u0152: "Oe",
    \u0153: "oe",
    \u0149: "'n",
    \u017F: "ss"
  };
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? void 0 : object[key];
    };
  }
  var deburrLetter = basePropertyOf(deburredLetters);
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var Symbol2 = root.Symbol;
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
  var symbolToString = symbolProto ? symbolProto.toString : void 0;
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  function toString(value) {
    return value == null ? "" : baseToString(value);
  }
  function deburr(string) {
    string = toString(string);
    return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
  }
  module2.exports = deburr;
});

// ../../node_modules/.pnpm/escape-string-regexp@2.0.0/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp3 = __commonJS((exports2, module2) => {
  "use strict";
  var matchOperatorsRegex = /[|\\{}()[\]^$+*?.-]/g;
  module2.exports = (string) => {
    if (typeof string !== "string") {
      throw new TypeError("Expected a string");
    }
    return string.replace(matchOperatorsRegex, "\\$&");
  };
});

// ../../node_modules/.pnpm/@sindresorhus+transliterate@0.1.2/node_modules/@sindresorhus/transliterate/replacements.js
var require_replacements = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = [
    ["\xDF", "ss"],
    ["\xE4", "ae"],
    ["\xC4", "Ae"],
    ["\xF6", "oe"],
    ["\xD6", "Oe"],
    ["\xFC", "ue"],
    ["\xDC", "Ue"],
    ["\xC0", "A"],
    ["\xC1", "A"],
    ["\xC2", "A"],
    ["\xC3", "A"],
    ["\xC4", "Ae"],
    ["\xC5", "A"],
    ["\xC6", "AE"],
    ["\xC7", "C"],
    ["\xC8", "E"],
    ["\xC9", "E"],
    ["\xCA", "E"],
    ["\xCB", "E"],
    ["\xCC", "I"],
    ["\xCD", "I"],
    ["\xCE", "I"],
    ["\xCF", "I"],
    ["\xD0", "D"],
    ["\xD1", "N"],
    ["\xD2", "O"],
    ["\xD3", "O"],
    ["\xD4", "O"],
    ["\xD5", "O"],
    ["\xD6", "Oe"],
    ["\u0150", "O"],
    ["\xD8", "O"],
    ["\xD9", "U"],
    ["\xDA", "U"],
    ["\xDB", "U"],
    ["\xDC", "Ue"],
    ["\u0170", "U"],
    ["\xDD", "Y"],
    ["\xDE", "TH"],
    ["\xDF", "ss"],
    ["\xE0", "a"],
    ["\xE1", "a"],
    ["\xE2", "a"],
    ["\xE3", "a"],
    ["\xE4", "ae"],
    ["\xE5", "a"],
    ["\xE6", "ae"],
    ["\xE7", "c"],
    ["\xE8", "e"],
    ["\xE9", "e"],
    ["\xEA", "e"],
    ["\xEB", "e"],
    ["\xEC", "i"],
    ["\xED", "i"],
    ["\xEE", "i"],
    ["\xEF", "i"],
    ["\xF0", "d"],
    ["\xF1", "n"],
    ["\xF2", "o"],
    ["\xF3", "o"],
    ["\xF4", "o"],
    ["\xF5", "o"],
    ["\xF6", "oe"],
    ["\u0151", "o"],
    ["\xF8", "o"],
    ["\xF9", "u"],
    ["\xFA", "u"],
    ["\xFB", "u"],
    ["\xFC", "ue"],
    ["\u0171", "u"],
    ["\xFD", "y"],
    ["\xFE", "th"],
    ["\xFF", "y"],
    ["\u1E9E", "SS"],
    ["\xE0", "a"],
    ["\xC0", "A"],
    ["\xE1", "a"],
    ["\xC1", "A"],
    ["\xE2", "a"],
    ["\xC2", "A"],
    ["\xE3", "a"],
    ["\xC3", "A"],
    ["\xE8", "e"],
    ["\xC8", "E"],
    ["\xE9", "e"],
    ["\xC9", "E"],
    ["\xEA", "e"],
    ["\xCA", "E"],
    ["\xEC", "i"],
    ["\xCC", "I"],
    ["\xED", "i"],
    ["\xCD", "I"],
    ["\xF2", "o"],
    ["\xD2", "O"],
    ["\xF3", "o"],
    ["\xD3", "O"],
    ["\xF4", "o"],
    ["\xD4", "O"],
    ["\xF5", "o"],
    ["\xD5", "O"],
    ["\xF9", "u"],
    ["\xD9", "U"],
    ["\xFA", "u"],
    ["\xDA", "U"],
    ["\xFD", "y"],
    ["\xDD", "Y"],
    ["\u0103", "a"],
    ["\u0102", "A"],
    ["\u0110", "D"],
    ["\u0111", "d"],
    ["\u0129", "i"],
    ["\u0128", "I"],
    ["\u0169", "u"],
    ["\u0168", "U"],
    ["\u01A1", "o"],
    ["\u01A0", "O"],
    ["\u01B0", "u"],
    ["\u01AF", "U"],
    ["\u1EA1", "a"],
    ["\u1EA0", "A"],
    ["\u1EA3", "a"],
    ["\u1EA2", "A"],
    ["\u1EA5", "a"],
    ["\u1EA4", "A"],
    ["\u1EA7", "a"],
    ["\u1EA6", "A"],
    ["\u1EA9", "a"],
    ["\u1EA8", "A"],
    ["\u1EAB", "a"],
    ["\u1EAA", "A"],
    ["\u1EAD", "a"],
    ["\u1EAC", "A"],
    ["\u1EAF", "a"],
    ["\u1EAE", "A"],
    ["\u1EB1", "a"],
    ["\u1EB0", "A"],
    ["\u1EB3", "a"],
    ["\u1EB2", "A"],
    ["\u1EB5", "a"],
    ["\u1EB4", "A"],
    ["\u1EB7", "a"],
    ["\u1EB6", "A"],
    ["\u1EB9", "e"],
    ["\u1EB8", "E"],
    ["\u1EBB", "e"],
    ["\u1EBA", "E"],
    ["\u1EBD", "e"],
    ["\u1EBC", "E"],
    ["\u1EBF", "e"],
    ["\u1EBE", "E"],
    ["\u1EC1", "e"],
    ["\u1EC0", "E"],
    ["\u1EC3", "e"],
    ["\u1EC2", "E"],
    ["\u1EC5", "e"],
    ["\u1EC4", "E"],
    ["\u1EC7", "e"],
    ["\u1EC6", "E"],
    ["\u1EC9", "i"],
    ["\u1EC8", "I"],
    ["\u1ECB", "i"],
    ["\u1ECA", "I"],
    ["\u1ECD", "o"],
    ["\u1ECC", "O"],
    ["\u1ECF", "o"],
    ["\u1ECE", "O"],
    ["\u1ED1", "o"],
    ["\u1ED0", "O"],
    ["\u1ED3", "o"],
    ["\u1ED2", "O"],
    ["\u1ED5", "o"],
    ["\u1ED4", "O"],
    ["\u1ED7", "o"],
    ["\u1ED6", "O"],
    ["\u1ED9", "o"],
    ["\u1ED8", "O"],
    ["\u1EDB", "o"],
    ["\u1EDA", "O"],
    ["\u1EDD", "o"],
    ["\u1EDC", "O"],
    ["\u1EDF", "o"],
    ["\u1EDE", "O"],
    ["\u1EE1", "o"],
    ["\u1EE0", "O"],
    ["\u1EE3", "o"],
    ["\u1EE2", "O"],
    ["\u1EE5", "u"],
    ["\u1EE4", "U"],
    ["\u1EE7", "u"],
    ["\u1EE6", "U"],
    ["\u1EE9", "u"],
    ["\u1EE8", "U"],
    ["\u1EEB", "u"],
    ["\u1EEA", "U"],
    ["\u1EED", "u"],
    ["\u1EEC", "U"],
    ["\u1EEF", "u"],
    ["\u1EEE", "U"],
    ["\u1EF1", "u"],
    ["\u1EF0", "U"],
    ["\u1EF3", "y"],
    ["\u1EF2", "Y"],
    ["\u1EF5", "y"],
    ["\u1EF4", "Y"],
    ["\u1EF7", "y"],
    ["\u1EF6", "Y"],
    ["\u1EF9", "y"],
    ["\u1EF8", "Y"],
    ["\u0621", "e"],
    ["\u0622", "a"],
    ["\u0623", "a"],
    ["\u0624", "w"],
    ["\u0625", "i"],
    ["\u0626", "y"],
    ["\u0627", "a"],
    ["\u0628", "b"],
    ["\u0629", "t"],
    ["\u062A", "t"],
    ["\u062B", "th"],
    ["\u062C", "j"],
    ["\u062D", "h"],
    ["\u062E", "kh"],
    ["\u062F", "d"],
    ["\u0630", "dh"],
    ["\u0631", "r"],
    ["\u0632", "z"],
    ["\u0633", "s"],
    ["\u0634", "sh"],
    ["\u0635", "s"],
    ["\u0636", "d"],
    ["\u0637", "t"],
    ["\u0638", "z"],
    ["\u0639", "e"],
    ["\u063A", "gh"],
    ["\u0640", "_"],
    ["\u0641", "f"],
    ["\u0642", "q"],
    ["\u0643", "k"],
    ["\u0644", "l"],
    ["\u0645", "m"],
    ["\u0646", "n"],
    ["\u0647", "h"],
    ["\u0648", "w"],
    ["\u0649", "a"],
    ["\u064A", "y"],
    ["\u064E\u200E", "a"],
    ["\u064F", "u"],
    ["\u0650\u200E", "i"],
    ["\u0660", "0"],
    ["\u0661", "1"],
    ["\u0662", "2"],
    ["\u0663", "3"],
    ["\u0664", "4"],
    ["\u0665", "5"],
    ["\u0666", "6"],
    ["\u0667", "7"],
    ["\u0668", "8"],
    ["\u0669", "9"],
    ["\u0686", "ch"],
    ["\u06A9", "k"],
    ["\u06AF", "g"],
    ["\u067E", "p"],
    ["\u0698", "zh"],
    ["\u06CC", "y"],
    ["\u06F0", "0"],
    ["\u06F1", "1"],
    ["\u06F2", "2"],
    ["\u06F3", "3"],
    ["\u06F4", "4"],
    ["\u06F5", "5"],
    ["\u06F6", "6"],
    ["\u06F7", "7"],
    ["\u06F8", "8"],
    ["\u06F9", "9"],
    ["\u067C", "p"],
    ["\u0681", "z"],
    ["\u0685", "c"],
    ["\u0689", "d"],
    ["\uFEAB", "d"],
    ["\uFEAD", "r"],
    ["\u0693", "r"],
    ["\uFEAF", "z"],
    ["\u0696", "g"],
    ["\u069A", "x"],
    ["\u06AB", "g"],
    ["\u06BC", "n"],
    ["\u06C0", "e"],
    ["\u06D0", "e"],
    ["\u06CD", "ai"],
    ["\u0679", "t"],
    ["\u0688", "d"],
    ["\u0691", "r"],
    ["\u06BA", "n"],
    ["\u06C1", "h"],
    ["\u06BE", "h"],
    ["\u06D2", "e"],
    ["\u0410", "A"],
    ["\u0430", "a"],
    ["\u0411", "B"],
    ["\u0431", "b"],
    ["\u0412", "V"],
    ["\u0432", "v"],
    ["\u0413", "G"],
    ["\u0433", "g"],
    ["\u0414", "D"],
    ["\u0434", "d"],
    ["\u0415", "E"],
    ["\u0435", "e"],
    ["\u0416", "Zh"],
    ["\u0436", "zh"],
    ["\u0417", "Z"],
    ["\u0437", "z"],
    ["\u0418", "I"],
    ["\u0438", "i"],
    ["\u0419", "J"],
    ["\u0439", "j"],
    ["\u041A", "K"],
    ["\u043A", "k"],
    ["\u041B", "L"],
    ["\u043B", "l"],
    ["\u041C", "M"],
    ["\u043C", "m"],
    ["\u041D", "N"],
    ["\u043D", "n"],
    ["\u041E", "O"],
    ["\u043E", "o"],
    ["\u041F", "P"],
    ["\u043F", "p"],
    ["\u0420", "R"],
    ["\u0440", "r"],
    ["\u0421", "S"],
    ["\u0441", "s"],
    ["\u0422", "T"],
    ["\u0442", "t"],
    ["\u0423", "U"],
    ["\u0443", "u"],
    ["\u0424", "F"],
    ["\u0444", "f"],
    ["\u0425", "H"],
    ["\u0445", "h"],
    ["\u0426", "Cz"],
    ["\u0446", "cz"],
    ["\u0427", "Ch"],
    ["\u0447", "ch"],
    ["\u0428", "Sh"],
    ["\u0448", "sh"],
    ["\u0429", "Shh"],
    ["\u0449", "shh"],
    ["\u042A", ""],
    ["\u044A", ""],
    ["\u042B", "Y"],
    ["\u044B", "y"],
    ["\u042C", ""],
    ["\u044C", ""],
    ["\u042D", "E"],
    ["\u044D", "e"],
    ["\u042E", "Yu"],
    ["\u044E", "yu"],
    ["\u042F", "Ya"],
    ["\u044F", "ya"],
    ["\u0401", "Yo"],
    ["\u0451", "yo"],
    ["\u0103", "a"],
    ["\u0102", "A"],
    ["\u0219", "s"],
    ["\u0218", "S"],
    ["\u021B", "t"],
    ["\u021A", "T"],
    ["\u0163", "t"],
    ["\u0162", "T"],
    ["\u015F", "s"],
    ["\u015E", "S"],
    ["\xE7", "c"],
    ["\xC7", "C"],
    ["\u011F", "g"],
    ["\u011E", "G"],
    ["\u0131", "i"],
    ["\u0130", "I"],
    ["\u0561", "a"],
    ["\u0531", "A"],
    ["\u0562", "b"],
    ["\u0532", "B"],
    ["\u0563", "g"],
    ["\u0533", "G"],
    ["\u0564", "d"],
    ["\u0534", "D"],
    ["\u0565", "ye"],
    ["\u0535", "Ye"],
    ["\u0566", "z"],
    ["\u0536", "Z"],
    ["\u0567", "e"],
    ["\u0537", "E"],
    ["\u0568", "y"],
    ["\u0538", "Y"],
    ["\u0569", "t"],
    ["\u0539", "T"],
    ["\u056A", "zh"],
    ["\u053A", "Zh"],
    ["\u056B", "i"],
    ["\u053B", "I"],
    ["\u056C", "l"],
    ["\u053C", "L"],
    ["\u056D", "kh"],
    ["\u053D", "Kh"],
    ["\u056E", "ts"],
    ["\u053E", "Ts"],
    ["\u056F", "k"],
    ["\u053F", "K"],
    ["\u0570", "h"],
    ["\u0540", "H"],
    ["\u0571", "dz"],
    ["\u0541", "Dz"],
    ["\u0572", "gh"],
    ["\u0542", "Gh"],
    ["\u0573", "tch"],
    ["\u0543", "Tch"],
    ["\u0574", "m"],
    ["\u0544", "M"],
    ["\u0575", "y"],
    ["\u0545", "Y"],
    ["\u0576", "n"],
    ["\u0546", "N"],
    ["\u0577", "sh"],
    ["\u0547", "Sh"],
    ["\u0578", "vo"],
    ["\u0548", "Vo"],
    ["\u0579", "ch"],
    ["\u0549", "Ch"],
    ["\u057A", "p"],
    ["\u054A", "P"],
    ["\u057B", "j"],
    ["\u054B", "J"],
    ["\u057C", "r"],
    ["\u054C", "R"],
    ["\u057D", "s"],
    ["\u054D", "S"],
    ["\u057E", "v"],
    ["\u054E", "V"],
    ["\u057F", "t"],
    ["\u054F", "T"],
    ["\u0580", "r"],
    ["\u0550", "R"],
    ["\u0581", "c"],
    ["\u0551", "C"],
    ["\u0578\u0582", "u"],
    ["\u0548\u0552", "U"],
    ["\u0548\u0582", "U"],
    ["\u0583", "p"],
    ["\u0553", "P"],
    ["\u0584", "q"],
    ["\u0554", "Q"],
    ["\u0585", "o"],
    ["\u0555", "O"],
    ["\u0586", "f"],
    ["\u0556", "F"],
    ["\u0587", "yev"],
    ["\u10D0", "a"],
    ["\u10D1", "b"],
    ["\u10D2", "g"],
    ["\u10D3", "d"],
    ["\u10D4", "e"],
    ["\u10D5", "v"],
    ["\u10D6", "z"],
    ["\u10D7", "t"],
    ["\u10D8", "i"],
    ["\u10D9", "k"],
    ["\u10DA", "l"],
    ["\u10DB", "m"],
    ["\u10DC", "n"],
    ["\u10DD", "o"],
    ["\u10DE", "p"],
    ["\u10DF", "zh"],
    ["\u10E0", "r"],
    ["\u10E1", "s"],
    ["\u10E2", "t"],
    ["\u10E3", "u"],
    ["\u10E4", "ph"],
    ["\u10E5", "q"],
    ["\u10E6", "gh"],
    ["\u10E7", "k"],
    ["\u10E8", "sh"],
    ["\u10E9", "ch"],
    ["\u10EA", "ts"],
    ["\u10EB", "dz"],
    ["\u10EC", "ts"],
    ["\u10ED", "tch"],
    ["\u10EE", "kh"],
    ["\u10EF", "j"],
    ["\u10F0", "h"],
    ["\u010D", "c"],
    ["\u010F", "d"],
    ["\u011B", "e"],
    ["\u0148", "n"],
    ["\u0159", "r"],
    ["\u0161", "s"],
    ["\u0165", "t"],
    ["\u016F", "u"],
    ["\u017E", "z"],
    ["\u010C", "C"],
    ["\u010E", "D"],
    ["\u011A", "E"],
    ["\u0147", "N"],
    ["\u0158", "R"],
    ["\u0160", "S"],
    ["\u0164", "T"],
    ["\u016E", "U"],
    ["\u017D", "Z"],
    ["\u0780", "h"],
    ["\u0781", "sh"],
    ["\u0782", "n"],
    ["\u0783", "r"],
    ["\u0784", "b"],
    ["\u0785", "lh"],
    ["\u0786", "k"],
    ["\u0787", "a"],
    ["\u0788", "v"],
    ["\u0789", "m"],
    ["\u078A", "f"],
    ["\u078B", "dh"],
    ["\u078C", "th"],
    ["\u078D", "l"],
    ["\u078E", "g"],
    ["\u078F", "gn"],
    ["\u0790", "s"],
    ["\u0791", "d"],
    ["\u0792", "z"],
    ["\u0793", "t"],
    ["\u0794", "y"],
    ["\u0795", "p"],
    ["\u0796", "j"],
    ["\u0797", "ch"],
    ["\u0798", "tt"],
    ["\u0799", "hh"],
    ["\u079A", "kh"],
    ["\u079B", "th"],
    ["\u079C", "z"],
    ["\u079D", "sh"],
    ["\u079E", "s"],
    ["\u079F", "d"],
    ["\u07A0", "t"],
    ["\u07A1", "z"],
    ["\u07A2", "a"],
    ["\u07A3", "gh"],
    ["\u07A4", "q"],
    ["\u07A5", "w"],
    ["\u07A6", "a"],
    ["\u07A7", "aa"],
    ["\u07A8", "i"],
    ["\u07A9", "ee"],
    ["\u07AA", "u"],
    ["\u07AB", "oo"],
    ["\u07AC", "e"],
    ["\u07AD", "ey"],
    ["\u07AE", "o"],
    ["\u07AF", "oa"],
    ["\u07B0", ""],
    ["\u03B1", "a"],
    ["\u03B2", "v"],
    ["\u03B3", "g"],
    ["\u03B4", "d"],
    ["\u03B5", "e"],
    ["\u03B6", "z"],
    ["\u03B7", "i"],
    ["\u03B8", "th"],
    ["\u03B9", "i"],
    ["\u03BA", "k"],
    ["\u03BB", "l"],
    ["\u03BC", "m"],
    ["\u03BD", "n"],
    ["\u03BE", "ks"],
    ["\u03BF", "o"],
    ["\u03C0", "p"],
    ["\u03C1", "r"],
    ["\u03C3", "s"],
    ["\u03C4", "t"],
    ["\u03C5", "y"],
    ["\u03C6", "f"],
    ["\u03C7", "x"],
    ["\u03C8", "ps"],
    ["\u03C9", "o"],
    ["\u03AC", "a"],
    ["\u03AD", "e"],
    ["\u03AF", "i"],
    ["\u03CC", "o"],
    ["\u03CD", "y"],
    ["\u03AE", "i"],
    ["\u03CE", "o"],
    ["\u03C2", "s"],
    ["\u03CA", "i"],
    ["\u03B0", "y"],
    ["\u03CB", "y"],
    ["\u0390", "i"],
    ["\u0391", "A"],
    ["\u0392", "B"],
    ["\u0393", "G"],
    ["\u0394", "D"],
    ["\u0395", "E"],
    ["\u0396", "Z"],
    ["\u0397", "I"],
    ["\u0398", "TH"],
    ["\u0399", "I"],
    ["\u039A", "K"],
    ["\u039B", "L"],
    ["\u039C", "M"],
    ["\u039D", "N"],
    ["\u039E", "KS"],
    ["\u039F", "O"],
    ["\u03A0", "P"],
    ["\u03A1", "R"],
    ["\u03A3", "S"],
    ["\u03A4", "T"],
    ["\u03A5", "Y"],
    ["\u03A6", "F"],
    ["\u03A7", "X"],
    ["\u03A8", "PS"],
    ["\u03A9", "O"],
    ["\u0386", "A"],
    ["\u0388", "E"],
    ["\u038A", "I"],
    ["\u038C", "O"],
    ["\u038E", "Y"],
    ["\u0389", "I"],
    ["\u038F", "O"],
    ["\u03AA", "I"],
    ["\u03AB", "Y"],
    ["\u0101", "a"],
    ["\u0113", "e"],
    ["\u0123", "g"],
    ["\u012B", "i"],
    ["\u0137", "k"],
    ["\u013C", "l"],
    ["\u0146", "n"],
    ["\u016B", "u"],
    ["\u0100", "A"],
    ["\u0112", "E"],
    ["\u0122", "G"],
    ["\u012A", "I"],
    ["\u0136", "K"],
    ["\u013B", "L"],
    ["\u0145", "N"],
    ["\u016A", "U"],
    ["\u010D", "c"],
    ["\u0161", "s"],
    ["\u017E", "z"],
    ["\u010C", "C"],
    ["\u0160", "S"],
    ["\u017D", "Z"],
    ["\u0105", "a"],
    ["\u010D", "c"],
    ["\u0119", "e"],
    ["\u0117", "e"],
    ["\u012F", "i"],
    ["\u0161", "s"],
    ["\u0173", "u"],
    ["\u016B", "u"],
    ["\u017E", "z"],
    ["\u0104", "A"],
    ["\u010C", "C"],
    ["\u0118", "E"],
    ["\u0116", "E"],
    ["\u012E", "I"],
    ["\u0160", "S"],
    ["\u0172", "U"],
    ["\u016A", "U"],
    ["\u040C", "Kj"],
    ["\u045C", "kj"],
    ["\u0409", "Lj"],
    ["\u0459", "lj"],
    ["\u040A", "Nj"],
    ["\u045A", "nj"],
    ["\u0422\u0441", "Ts"],
    ["\u0442\u0441", "ts"],
    ["\u0105", "a"],
    ["\u0107", "c"],
    ["\u0119", "e"],
    ["\u0142", "l"],
    ["\u0144", "n"],
    ["\u015B", "s"],
    ["\u017A", "z"],
    ["\u017C", "z"],
    ["\u0104", "A"],
    ["\u0106", "C"],
    ["\u0118", "E"],
    ["\u0141", "L"],
    ["\u0143", "N"],
    ["\u015A", "S"],
    ["\u0179", "Z"],
    ["\u017B", "Z"],
    ["\u0404", "Ye"],
    ["\u0406", "I"],
    ["\u0407", "Yi"],
    ["\u0490", "G"],
    ["\u0454", "ye"],
    ["\u0456", "i"],
    ["\u0457", "yi"],
    ["\u0491", "g"]
  ];
});

// ../../node_modules/.pnpm/@sindresorhus+transliterate@0.1.2/node_modules/@sindresorhus/transliterate/index.js
var require_transliterate = __commonJS((exports2, module2) => {
  "use strict";
  var deburr = require_lodash6();
  var escapeStringRegexp = require_escape_string_regexp3();
  var builtinReplacements = require_replacements();
  var doCustomReplacements = (string, replacements) => {
    for (const [key, value] of replacements) {
      string = string.replace(new RegExp(escapeStringRegexp(key), "g"), value);
    }
    return string;
  };
  module2.exports = (string, options) => {
    if (typeof string !== "string") {
      throw new TypeError(`Expected a string, got \`${typeof string}\``);
    }
    options = {
      customReplacements: [],
      ...options
    };
    const customReplacements = new Map([
      ...builtinReplacements,
      ...options.customReplacements
    ]);
    string = string.normalize();
    string = doCustomReplacements(string, customReplacements);
    string = deburr(string);
    return string;
  };
});

// ../../node_modules/.pnpm/@sindresorhus+slugify@1.1.2/node_modules/@sindresorhus/slugify/overridable-replacements.js
var require_overridable_replacements = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = [
    ["&", " and "],
    ["\u{1F984}", " unicorn "],
    ["\u2665", " love "]
  ];
});

// ../../node_modules/.pnpm/@sindresorhus+slugify@1.1.2/node_modules/@sindresorhus/slugify/index.js
var require_slugify = __commonJS((exports2, module2) => {
  "use strict";
  var escapeStringRegexp = require_escape_string_regexp2();
  var transliterate = require_transliterate();
  var builtinOverridableReplacements = require_overridable_replacements();
  var decamelize = (string) => {
    return string.replace(/([A-Z]{2,})(\d+)/g, "$1 $2").replace(/([a-z\d]+)([A-Z]{2,})/g, "$1 $2").replace(/([a-z\d])([A-Z])/g, "$1 $2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1 $2");
  };
  var removeMootSeparators = (string, separator) => {
    const escapedSeparator = escapeStringRegexp(separator);
    return string.replace(new RegExp(`${escapedSeparator}{2,}`, "g"), separator).replace(new RegExp(`^${escapedSeparator}|${escapedSeparator}$`, "g"), "");
  };
  var slugify2 = (string, options) => {
    if (typeof string !== "string") {
      throw new TypeError(`Expected a string, got \`${typeof string}\``);
    }
    options = {
      separator: "-",
      lowercase: true,
      decamelize: true,
      customReplacements: [],
      preserveLeadingUnderscore: false,
      ...options
    };
    const shouldPrependUnderscore = options.preserveLeadingUnderscore && string.startsWith("_");
    const customReplacements = new Map([
      ...builtinOverridableReplacements,
      ...options.customReplacements
    ]);
    string = transliterate(string, {customReplacements});
    if (options.decamelize) {
      string = decamelize(string);
    }
    let patternSlug = /[^a-zA-Z\d]+/g;
    if (options.lowercase) {
      string = string.toLowerCase();
      patternSlug = /[^a-z\d]+/g;
    }
    string = string.replace(patternSlug, options.separator);
    string = string.replace(/\\/g, "");
    if (options.separator) {
      string = removeMootSeparators(string, options.separator);
    }
    if (shouldPrependUnderscore) {
      string = `_${string}`;
    }
    return string;
  };
  var counter2 = () => {
    const occurrences = new Map();
    const countable = (string, options) => {
      string = slugify2(string, options);
      if (!string) {
        return "";
      }
      const stringLower = string.toLowerCase();
      const numberless = occurrences.get(stringLower.replace(/(?:-\d+?)+?$/, "")) || 0;
      const counter3 = occurrences.get(stringLower);
      occurrences.set(stringLower, typeof counter3 === "number" ? counter3 + 1 : 1);
      const newCounter = occurrences.get(stringLower) || 2;
      if (newCounter >= 2 || numberless > 2) {
        string = `${string}-${newCounter}`;
      }
      return string;
    };
    countable.reset = () => {
      occurrences.clear();
    };
    return countable;
  };
  module2.exports = slugify2;
  module2.exports.counter = counter2;
});

// ../migrate/dist/utils/promptForMigrationName.js
var require_promptForMigrationName = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    getMigrationName: () => getMigrationName
  });
  var import_prompts = __toModule3(require_prompts3());
  var import_sdk18 = __toModule3(require_dist12());
  var import_slugify = __toModule3(require_slugify());
  async function getMigrationName(name) {
    var _a;
    const maxMigrationNameLength = 200;
    if (name) {
      return {
        name: (0, import_slugify.default)(name, {separator: "_"}).substring(0, maxMigrationNameLength)
      };
    } else if ((0, import_sdk18.isCi)() && Boolean((_a = import_prompts.prompt._injected) == null ? void 0 : _a.length) === false) {
      return {
        name: ""
      };
    }
    const response = await (0, import_prompts.prompt)({
      type: "text",
      name: "name",
      message: `Enter a name for the new migration:`
    });
    if (!("name" in response)) {
      return {
        userCancelled: "Canceled by user."
      };
    }
    return {
      name: (0, import_slugify.default)(response.name, {separator: "_"}).substring(0, maxMigrationNameLength) || ""
    };
  }
});

// ../migrate/dist/utils/detectOldMigrate.js
var require_detectOldMigrate = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    isOldMigrate: () => isOldMigrate,
    throwUpgradeErrorIfOldMigrate: () => throwUpgradeErrorIfOldMigrate
  });
  var import_fs9 = __toModule3(require("fs"));
  var import_path10 = __toModule3(require("path"));
  var import_errors2 = __toModule3(require_errors3());
  function isOldMigrate(migrationDirPath) {
    return import_fs9.default.existsSync(import_path10.default.join(migrationDirPath, "migrate.lock"));
  }
  function throwUpgradeErrorIfOldMigrate(schemaPath) {
    if (!schemaPath) {
      return;
    }
    const migrationDirPath = import_path10.default.join(import_path10.default.dirname(schemaPath), "migrations");
    if (isOldMigrate(migrationDirPath)) {
      throw new import_errors2.OldMigrateDetectedError();
    }
  }
});

// ../migrate/dist/utils/printDatasource.js
var require_printDatasource = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    printDatasource: () => printDatasource
  });
  var import_ensureDatabaseExists = __toModule3(require_ensureDatabaseExists());
  var import_chalk14 = __toModule3(require_source());
  async function printDatasource(schemaPath) {
    const dbInfo = await (0, import_ensureDatabaseExists.getDbInfo)(schemaPath);
    if (dbInfo.dbType) {
      if (dbInfo.dbType === "PostgreSQL" && dbInfo.dbName === void 0) {
        dbInfo.dbName = "postgres";
      }
      if (dbInfo.dbType === "SQL Server") {
        console.info(import_chalk14.default.dim(`Datasource "${dbInfo.name}" - SQL Server`));
      } else {
        console.info(import_chalk14.default.dim(`Datasource "${dbInfo.name}": ${dbInfo.dbType} ${dbInfo.schemaWord} "${dbInfo.dbName}"${dbInfo.schema ? `, schema "${dbInfo.schema}"` : ""} at "${dbInfo.dbLocation}"`));
      }
    } else {
      console.info(import_chalk14.default.dim(`Datasource "${dbInfo.name}"`));
    }
  }
});

// ../../node_modules/.pnpm/resolve-from@5.0.0/node_modules/resolve-from/index.js
var require_resolve_from = __commonJS((exports2, module2) => {
  "use strict";
  var path10 = require("path");
  var Module2 = require("module");
  var fs9 = require("fs");
  var resolveFrom = (fromDirectory, moduleId, silent) => {
    if (typeof fromDirectory !== "string") {
      throw new TypeError(`Expected \`fromDir\` to be of type \`string\`, got \`${typeof fromDirectory}\``);
    }
    if (typeof moduleId !== "string") {
      throw new TypeError(`Expected \`moduleId\` to be of type \`string\`, got \`${typeof moduleId}\``);
    }
    try {
      fromDirectory = fs9.realpathSync(fromDirectory);
    } catch (error) {
      if (error.code === "ENOENT") {
        fromDirectory = path10.resolve(fromDirectory);
      } else if (silent) {
        return;
      } else {
        throw error;
      }
    }
    const fromFile = path10.join(fromDirectory, "noop.js");
    const resolveFileName = () => Module2._resolveFilename(moduleId, {
      id: fromFile,
      filename: fromFile,
      paths: Module2._nodeModulePaths(fromDirectory)
    });
    if (silent) {
      try {
        return resolveFileName();
      } catch (error) {
        return;
      }
    }
    return resolveFileName();
  };
  module2.exports = (fromDirectory, moduleId) => resolveFrom(fromDirectory, moduleId);
  module2.exports.silent = (fromDirectory, moduleId) => resolveFrom(fromDirectory, moduleId, true);
});

// ../../node_modules/.pnpm/resolve-pkg@2.0.0/node_modules/resolve-pkg/index.js
var require_resolve_pkg = __commonJS((exports2, module2) => {
  "use strict";
  var path10 = require("path");
  var resolveFrom = require_resolve_from();
  module2.exports = (moduleId, options = {}) => {
    const parts = moduleId.replace(/\\/g, "/").split("/");
    let packageName = "";
    if (parts.length > 0 && parts[0][0] === "@") {
      packageName += parts.shift() + "/";
    }
    packageName += parts.shift();
    const packageJson5 = path10.join(packageName, "package.json");
    const resolved = resolveFrom.silent(options.cwd || process.cwd(), packageJson5);
    if (!resolved) {
      return;
    }
    return path10.join(path10.dirname(resolved), parts.join("/"));
  };
});

// ../../node_modules/.pnpm/path-exists@3.0.0/node_modules/path-exists/index.js
var require_path_exists2 = __commonJS((exports2, module2) => {
  "use strict";
  var fs9 = require("fs");
  module2.exports = (fp) => new Promise((resolve) => {
    fs9.access(fp, (err) => {
      resolve(!err);
    });
  });
  module2.exports.sync = (fp) => {
    try {
      fs9.accessSync(fp);
      return true;
    } catch (err) {
      return false;
    }
  };
});

// ../../node_modules/.pnpm/p-locate@3.0.0/node_modules/p-locate/index.js
var require_p_locate3 = __commonJS((exports2, module2) => {
  "use strict";
  var pLimit = require_p_limit();
  var EndError = class extends Error {
    constructor(value) {
      super();
      this.value = value;
    }
  };
  var testElement = (el, tester) => Promise.resolve(el).then(tester);
  var finder = (el) => Promise.all(el).then((val) => val[1] === true && Promise.reject(new EndError(val[0])));
  module2.exports = (iterable, tester, opts) => {
    opts = Object.assign({
      concurrency: Infinity,
      preserveOrder: true
    }, opts);
    const limit = pLimit(opts.concurrency);
    const items = [...iterable].map((el) => [el, limit(testElement, el, tester)]);
    const checkLimit = pLimit(opts.preserveOrder ? 1 : Infinity);
    return Promise.all(items.map((el) => checkLimit(finder, el))).then(() => {
    }).catch((err) => err instanceof EndError ? err.value : Promise.reject(err));
  };
});

// ../../node_modules/.pnpm/locate-path@3.0.0/node_modules/locate-path/index.js
var require_locate_path3 = __commonJS((exports2, module2) => {
  "use strict";
  var path10 = require("path");
  var pathExists = require_path_exists2();
  var pLocate = require_p_locate3();
  module2.exports = (iterable, options) => {
    options = Object.assign({
      cwd: process.cwd()
    }, options);
    return pLocate(iterable, (el) => pathExists(path10.resolve(options.cwd, el)), options);
  };
  module2.exports.sync = (iterable, options) => {
    options = Object.assign({
      cwd: process.cwd()
    }, options);
    for (const el of iterable) {
      if (pathExists.sync(path10.resolve(options.cwd, el))) {
        return el;
      }
    }
  };
});

// ../../node_modules/.pnpm/find-up@3.0.0/node_modules/find-up/index.js
var require_find_up3 = __commonJS((exports2, module2) => {
  "use strict";
  var path10 = require("path");
  var locatePath = require_locate_path3();
  module2.exports = (filename, opts = {}) => {
    const startDir = path10.resolve(opts.cwd || "");
    const {root} = path10.parse(startDir);
    const filenames = [].concat(filename);
    return new Promise((resolve) => {
      (function find(dir) {
        locatePath(filenames, {cwd: dir}).then((file) => {
          if (file) {
            resolve(path10.join(dir, file));
          } else if (dir === root) {
            resolve(null);
          } else {
            find(path10.dirname(dir));
          }
        });
      })(startDir);
    });
  };
  module2.exports.sync = (filename, opts = {}) => {
    let dir = path10.resolve(opts.cwd || "");
    const {root} = path10.parse(dir);
    const filenames = [].concat(filename);
    while (true) {
      const file = locatePath.sync(filenames, {cwd: dir});
      if (file) {
        return path10.join(dir, file);
      }
      if (dir === root) {
        return null;
      }
      dir = path10.dirname(dir);
    }
  };
});

// ../../node_modules/.pnpm/pkg-up@3.1.0/node_modules/pkg-up/index.js
var require_pkg_up = __commonJS((exports2, module2) => {
  "use strict";
  var findUp = require_find_up3();
  module2.exports = async ({cwd} = {}) => findUp("package.json", {cwd});
  module2.exports.sync = ({cwd} = {}) => findUp.sync("package.json", {cwd});
});

// ../migrate/dist/utils/seed.js
var require_seed = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    detectSeedFiles: () => detectSeedFiles,
    getScriptsFromPackageJson: () => getScriptsFromPackageJson,
    isPackageInstalledGlobally: () => isPackageInstalledGlobally,
    tryToRunSeed: () => tryToRunSeed
  });
  var import_fs9 = __toModule3(require("fs"));
  var import_path10 = __toModule3(require("path"));
  var import_execa2 = __toModule3(require_execa());
  var import_resolve_pkg = __toModule3(require_resolve_pkg());
  var import_has_yarn = __toModule3(require_has_yarn());
  var import_chalk14 = __toModule3(require_source());
  var import_global_dirs = __toModule3(require_global_dirs());
  var import_pkg_up2 = __toModule3(require_pkg_up());
  var import_util6 = __toModule3(require("util"));
  var readFileAsync2 = (0, import_util6.promisify)(import_fs9.default.readFile);
  function isPackageInstalledGlobally(packageName) {
    try {
      const usingGlobalYarn = import_fs9.default.existsSync(import_path10.default.join(import_global_dirs.default.yarn.packages, packageName));
      const usingGlobalNpm = import_fs9.default.existsSync(import_path10.default.join(import_global_dirs.default.npm.packages, packageName));
      if (usingGlobalNpm) {
        return "npm";
      }
      if (usingGlobalYarn) {
        return "yarn";
      } else {
        false;
      }
    } catch (e) {
    }
    return false;
  }
  function detectSeedFiles(schemaPath) {
    let parentDirectory = import_path10.default.relative(process.cwd(), import_path10.default.join(process.cwd(), "prisma"));
    if (schemaPath) {
      parentDirectory = import_path10.default.relative(process.cwd(), import_path10.default.dirname(schemaPath));
    }
    const seedPath = import_path10.default.join(parentDirectory, "seed.");
    const detected = {
      seedPath,
      numberOfSeedFiles: 0,
      js: "",
      ts: "",
      sh: ""
    };
    const extensions = ["js", "ts", "sh"];
    for (const extension of extensions) {
      const fullPath = seedPath + extension;
      if (!import_fs9.default.existsSync(fullPath)) {
        continue;
      }
      detected[extension] = fullPath;
      detected.numberOfSeedFiles++;
    }
    return detected;
  }
  function getSeedScript(type, seedFilepath) {
    let script = `
console.info('Result:')

const __seed = require('./${seedFilepath}')
const __keys = Object.keys(__seed)

async function runSeed() {
  // Execute "seed" named export or default export
  if (__keys && __keys.length) {
    if (__keys.indexOf('seed') !== -1) {
      return __seed.seed()
    } else if (__keys.indexOf('default') !== -1) {
      return __seed.default()
    }
  }
}

runSeed()
  .then(function (result) {
    if (result) {
      console.log(result)
    }
  })
  .catch(function (e) {
    console.error('Error from seed:')
    throw e
  })
`;
    if (type === "TS") {
      script = `
// @ts-ignore
declare const require: any

${script}

export {}
`;
    }
    return script;
  }
  async function tryToRunSeed(schemaPath) {
    const detected = detectSeedFiles(schemaPath);
    if (detected.numberOfSeedFiles === 0) {
      throw new Error(`No seed file found.
Create a \`seed.ts\`, \`.js\` or \`.sh\` file in the prisma directory.`);
    } else if (detected.numberOfSeedFiles > 1) {
      throw new Error(`More than one seed file was found in \`${import_path10.default.relative(process.cwd(), import_path10.default.dirname(detected.seedPath))}\` directory.
This command only supports one seed file: Use \`seed.ts\`, \`.js\` or \`.sh\`.`);
    } else {
      if (detected.js) {
        console.info(`Running seed from ${import_chalk14.default.bold(`"${detected.js}"`)} ...`);
        return await (0, import_execa2.default)("node", [`-e "${getSeedScript("JS", detected.js)}"`], {
          shell: true,
          stdio: "inherit"
        });
      } else if (detected.ts) {
        const hasTypescriptPkg = (0, import_resolve_pkg.default)("typescript") || isPackageInstalledGlobally("typescript");
        const hasTsNodePkg = (0, import_resolve_pkg.default)("ts-node") || isPackageInstalledGlobally("ts-node");
        const hasTypesNodePkg = (0, import_resolve_pkg.default)("@types/node");
        const missingPkgs = [];
        if (!hasTypescriptPkg) {
          missingPkgs.push("typescript");
        }
        if (!hasTsNodePkg) {
          missingPkgs.push("ts-node");
        }
        if (!hasTypesNodePkg) {
          missingPkgs.push("@types/node");
        }
        if (missingPkgs.length > 0) {
          const packageManager = (0, import_has_yarn.default)() ? "yarn add -D" : "npm i -D";
          console.info(`We detected a seed file at \`${detected.ts}\` but it seems that you do not have the following dependencies installed:
${missingPkgs.map((name) => `- ${name}`).join("\n")}

To install them run: ${import_chalk14.default.green(`${packageManager} ${missingPkgs.join(" ")}`)}
`);
        }
        const scripts = await getScriptsFromPackageJson();
        let tsNodeCommand = "ts-node";
        let tsNodeArgs = `--eval "${getSeedScript("TS", detected.ts)}"`;
        if (scripts == null ? void 0 : scripts["ts-node"]) {
          tsNodeCommand = scripts["ts-node"];
          tsNodeArgs = `"${detected.ts}"`;
          console.info(`Running seed: ${import_chalk14.default.bold(`${tsNodeCommand} ${tsNodeArgs}`)} ...`);
        } else {
          console.info(`Running seed from ${import_chalk14.default.bold(`${detected.ts}`)} ...`);
        }
        return await (0, import_execa2.default)(tsNodeCommand, [tsNodeArgs], {
          shell: true,
          stdio: "inherit"
        });
      } else if (detected.sh) {
        console.info(`Running seed: ${import_chalk14.default.bold(`sh "${detected.sh}"`)} ...`);
        return await (0, import_execa2.default)("sh", [`"${detected.sh}"`], {
          shell: true,
          stdio: "inherit"
        });
      }
    }
    return void 0;
  }
  async function getScriptsFromPackageJson(cwd = process.cwd()) {
    try {
      const pkgJsonPath = await (0, import_pkg_up2.default)({cwd});
      if (!pkgJsonPath) {
        return null;
      }
      const pkgJsonString = await readFileAsync2(pkgJsonPath, "utf-8");
      const pkgJson = JSON.parse(pkgJsonString);
      const {"ts-node": tsnode} = pkgJson.scripts;
      return {"ts-node": tsnode};
    } catch (e) {
      return null;
    }
  }
});

// ../migrate/dist/commands/MigrateDev.js
var require_MigrateDev = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    MigrateDev: () => MigrateDev3
  });
  var import_sdk18 = __toModule3(require_dist12());
  var import_debug3 = __toModule3(require_dist13());
  var import_chalk14 = __toModule3(require_source());
  var import_prompts = __toModule3(require_prompts3());
  var import_fs9 = __toModule3(require("fs"));
  var import_path10 = __toModule3(require("path"));
  var import_Migrate = __toModule3(require_Migrate());
  var import_ensureDatabaseExists = __toModule3(require_ensureDatabaseExists());
  var import_flagErrors = __toModule3(require_flagErrors());
  var import_errors2 = __toModule3(require_errors3());
  var import_printMigrationId = __toModule3(require_printMigrationId());
  var import_printFiles = __toModule3(require_printFiles());
  var import_handleEvaluateDataloss = __toModule3(require_handleEvaluateDataloss());
  var import_promptForMigrationName = __toModule3(require_promptForMigrationName());
  var import_detectOldMigrate = __toModule3(require_detectOldMigrate());
  var import_printDatasource = __toModule3(require_printDatasource());
  var import_seed = __toModule3(require_seed());
  var debug3 = (0, import_debug3.default)("prisma:migrate:dev");
  var _MigrateDev = class {
    static new() {
      return new _MigrateDev();
    }
    async parse(argv) {
      var _a, _b;
      const args2 = (0, import_sdk18.arg)(argv, {
        "--help": Boolean,
        "-h": "--help",
        "--name": String,
        "-n": "--name",
        "--create-only": Boolean,
        "--schema": String,
        "--skip-generate": Boolean,
        "--skip-seed": Boolean,
        "--experimental": Boolean,
        "--early-access-feature": Boolean,
        "--telemetry-information": String
      });
      if ((0, import_sdk18.isError)(args2)) {
        return this.help(args2.message);
      }
      if (args2["--help"]) {
        return this.help();
      }
      if (args2["--experimental"]) {
        throw new import_flagErrors.ExperimentalFlagWithNewMigrateError();
      }
      if (args2["--early-access-feature"]) {
        throw new import_flagErrors.EarlyAccessFeatureFlagWithNewMigrateError();
      }
      const schemaPath = await (0, import_sdk18.getSchemaPath)(args2["--schema"]);
      if (!schemaPath) {
        throw new import_errors2.NoSchemaFoundError();
      }
      console.info(import_chalk14.default.dim(`Prisma schema loaded from ${import_path10.default.relative(process.cwd(), schemaPath)}`));
      await (0, import_printDatasource.printDatasource)(schemaPath);
      console.info();
      (0, import_detectOldMigrate.throwUpgradeErrorIfOldMigrate)(schemaPath);
      const schema = import_fs9.default.readFileSync(schemaPath, "utf-8");
      await (0, import_sdk18.getDMMF)({
        datamodel: schema
      });
      await (0, import_sdk18.getConfig)({
        datamodel: schema
      });
      const wasDbCreated = await (0, import_ensureDatabaseExists.ensureDatabaseExists)("create", true, schemaPath);
      if (wasDbCreated) {
        console.info(wasDbCreated);
      }
      const migrate = new import_Migrate.Migrate(schemaPath);
      let devDiagnostic;
      try {
        devDiagnostic = await migrate.devDiagnostic();
        debug3({devDiagnostic: JSON.stringify(devDiagnostic, null, 2)});
      } catch (e) {
        migrate.stop();
        throw e;
      }
      const migrationIdsApplied = [];
      if (devDiagnostic.action.tag === "reset") {
        if (!args2["--force"]) {
          if ((0, import_sdk18.isCi)() && Boolean((_a = import_prompts.default._injected) == null ? void 0 : _a.length) === false) {
            migrate.stop();
            throw new import_errors2.MigrateDevEnvNonInteractiveError();
          }
          const dbInfo = await (0, import_ensureDatabaseExists.getDbInfo)(schemaPath);
          const confirmedReset = await this.confirmReset(dbInfo, devDiagnostic.action.reason);
          console.info();
          if (!confirmedReset) {
            console.info("Reset cancelled.");
            migrate.stop();
            process.exit(0);
            return ``;
          }
        }
        try {
          await migrate.reset();
        } catch (e) {
          migrate.stop();
          throw e;
        }
      }
      try {
        const {appliedMigrationNames} = await migrate.applyMigrations();
        migrationIdsApplied.push(...appliedMigrationNames);
        if (appliedMigrationNames.length > 0) {
          console.info(`The following migration(s) have been applied:

${(0, import_chalk14.default)((0, import_printFiles.printFilesFromMigrationIds)("migrations", appliedMigrationNames, {
            "migration.sql": ""
          }))}`);
        }
      } catch (e) {
        migrate.stop();
        throw e;
      }
      if (devDiagnostic.action.tag === "reset" && !process.env.PRISMA_MIGRATE_SKIP_SEED && !args2["--skip-seed"]) {
        try {
          const detected = (0, import_seed.detectSeedFiles)(schemaPath);
          if (detected.numberOfSeedFiles > 0) {
            console.info();
            await (0, import_seed.tryToRunSeed)(schemaPath);
          }
        } catch (e) {
          console.error(e);
        }
      }
      let evaluateDataLossResult;
      try {
        evaluateDataLossResult = await migrate.evaluateDataLoss();
        debug3({evaluateDataLossResult});
      } catch (e) {
        migrate.stop();
        throw e;
      }
      const unexecutableStepsError = (0, import_handleEvaluateDataloss.handleUnexecutableSteps)(evaluateDataLossResult.unexecutableSteps, args2["--create-only"]);
      if (unexecutableStepsError) {
        migrate.stop();
        throw new Error(unexecutableStepsError);
      }
      if (evaluateDataLossResult.warnings && evaluateDataLossResult.warnings.length > 0) {
        console.log(import_chalk14.default.bold(`
\u26A0\uFE0F  Warnings for the current datasource:
`));
        for (const warning of evaluateDataLossResult.warnings) {
          console.log((0, import_chalk14.default)(`  \u2022 ${warning.message}`));
        }
        console.info();
        if (!args2["--force"]) {
          if ((0, import_sdk18.isCi)() && Boolean((_b = import_prompts.default._injected) == null ? void 0 : _b.length) === false) {
            migrate.stop();
            throw new import_errors2.MigrateDevEnvNonInteractiveError();
          }
          const message = args2["--create-only"] ? "Are you sure you want create this migration?" : "Are you sure you want create and apply this migration?";
          const confirmation = await (0, import_prompts.default)({
            type: "confirm",
            name: "value",
            message
          });
          if (!confirmation.value) {
            migrate.stop();
            return `Migration cancelled.`;
          }
        }
      }
      let migrationName = void 0;
      if (evaluateDataLossResult.migrationSteps > 0 || args2["--create-only"]) {
        const getMigrationNameResult = await (0, import_promptForMigrationName.getMigrationName)(args2["--name"]);
        if (getMigrationNameResult.userCancelled) {
          migrate.stop();
          return getMigrationNameResult.userCancelled;
        } else {
          migrationName = getMigrationNameResult.name;
        }
      }
      let migrationIds;
      try {
        const createMigrationResult = await migrate.createMigration({
          migrationsDirectoryPath: migrate.migrationsDirectoryPath,
          migrationName: migrationName || "",
          draft: args2["--create-only"] ? true : false,
          prismaSchema: migrate.getDatamodel()
        });
        debug3({createMigrationResult});
        if (args2["--create-only"]) {
          migrate.stop();
          return `Prisma Migrate created the following migration without applying it ${(0, import_printMigrationId.printMigrationId)(createMigrationResult.generatedMigrationName)}

You can now edit it and apply it by running ${import_chalk14.default.greenBright((0, import_sdk18.getCommandWithExecutor)("prisma migrate dev"))}.`;
        }
        const {appliedMigrationNames} = await migrate.applyMigrations();
        migrationIds = appliedMigrationNames;
      } finally {
        migrate.stop();
      }
      migrationIdsApplied.length > 0 && console.info();
      if (migrationIds.length === 0) {
        if (migrationIdsApplied.length > 0) {
          console.info(`${import_chalk14.default.green("Your database is now in sync with your schema.")}`);
        } else {
          console.info(`Already in sync, no schema change or pending migration was found.`);
        }
      } else {
        console.info(`The following migration(s) have been created and applied from new schema changes:

${(0, import_chalk14.default)((0, import_printFiles.printFilesFromMigrationIds)("migrations", migrationIds, {
          "migration.sql": ""
        }))}

${import_chalk14.default.green("Your database is now in sync with your schema.")}`);
      }
      if (!process.env.PRISMA_MIGRATE_SKIP_GENERATE && !args2["--skip-generate"]) {
        await migrate.tryToRunGenerate();
        console.info();
      }
      return "";
    }
    async confirmReset({
      schemaWord,
      dbType,
      dbName,
      dbLocation
    }, reason) {
      const mssqlMessage = `${reason}

We need to reset the database.
Do you want to continue? ${import_chalk14.default.red("All data will be lost")}.`;
      const message = `${reason}

We need to reset the ${dbType} ${schemaWord} "${dbName}" at "${dbLocation}".
Do you want to continue? ${import_chalk14.default.red("All data will be lost")}.`;
      const confirmation = await (0, import_prompts.default)({
        type: "confirm",
        name: "value",
        message: dbType === "SQL Server" ? mssqlMessage : message
      });
      return confirmation.value;
    }
    help(error) {
      if (error) {
        return new import_sdk18.HelpError(`
${import_chalk14.default.bold.red(`!`)} ${error}
${_MigrateDev.help}`);
      }
      return _MigrateDev.help;
    }
  };
  var MigrateDev3 = _MigrateDev;
  MigrateDev3.help = (0, import_sdk18.format)(`
${process.platform === "win32" ? "" : import_chalk14.default.bold("\u{1F3CB}\uFE0F  ")}Create a migration from changes in Prisma schema, apply it to the database, trigger generators (e.g. Prisma Client)
 
${import_chalk14.default.bold("Usage")}

  ${import_chalk14.default.dim("$")} prisma migrate dev [options]

${import_chalk14.default.bold("Options")}

       -h, --help   Display this help message
         --schema   Custom path to your Prisma schema
       -n, --name   Name the migration
    --create-only   Create a new migration but do not apply it
                    The migration will be empty if there are no changes in Prisma schema
  --skip-generate   Skip triggering generators (e.g. Prisma Client)
      --skip-seed   Skip triggering seed

${import_chalk14.default.bold("Examples")}

  Create a migration from changes in Prisma schema, apply it to the database, trigger generators (e.g. Prisma Client)
  ${import_chalk14.default.dim("$")} prisma migrate dev

  Specify a schema
  ${import_chalk14.default.dim("$")} prisma migrate dev --schema=./schema.prisma

  Create a migration without applying it
  ${import_chalk14.default.dim("$")} prisma migrate dev --create-only
  `);
});

// ../migrate/dist/commands/MigrateResolve.js
var require_MigrateResolve = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    MigrateResolve: () => MigrateResolve3
  });
  var import_sdk18 = __toModule3(require_dist12());
  var import_chalk14 = __toModule3(require_source());
  var import_path10 = __toModule3(require("path"));
  var import_ensureDatabaseExists = __toModule3(require_ensureDatabaseExists());
  var import_Migrate = __toModule3(require_Migrate());
  var import_flagErrors = __toModule3(require_flagErrors());
  var import_errors2 = __toModule3(require_errors3());
  var import_detectOldMigrate = __toModule3(require_detectOldMigrate());
  var import_printDatasource = __toModule3(require_printDatasource());
  var _MigrateResolve = class {
    static new() {
      return new _MigrateResolve();
    }
    async parse(argv) {
      const args2 = (0, import_sdk18.arg)(argv, {
        "--help": Boolean,
        "-h": "--help",
        "--applied": String,
        "--rolled-back": String,
        "--experimental": Boolean,
        "--early-access-feature": Boolean,
        "--schema": String,
        "--telemetry-information": String
      }, false);
      if ((0, import_sdk18.isError)(args2)) {
        return this.help(args2.message);
      }
      if (args2["--help"]) {
        return this.help();
      }
      if (args2["--experimental"]) {
        throw new import_flagErrors.ExperimentalFlagWithNewMigrateError();
      }
      if (args2["--early-access-feature"]) {
        throw new import_flagErrors.EarlyAccessFeatureFlagWithNewMigrateError();
      }
      const schemaPath = await (0, import_sdk18.getSchemaPath)(args2["--schema"]);
      if (!schemaPath) {
        throw new import_errors2.NoSchemaFoundError();
      }
      console.info(import_chalk14.default.dim(`Prisma schema loaded from ${import_path10.default.relative(process.cwd(), schemaPath)}`));
      await (0, import_printDatasource.printDatasource)(schemaPath);
      (0, import_detectOldMigrate.throwUpgradeErrorIfOldMigrate)(schemaPath);
      if (!args2["--applied"] && !args2["--rolled-back"]) {
        throw new Error(`--applied or --rolled-back must be part of the command like:
${import_chalk14.default.bold.green((0, import_sdk18.getCommandWithExecutor)("prisma migrate resolve --applied 20201231000000_example"))}
${import_chalk14.default.bold.green((0, import_sdk18.getCommandWithExecutor)("prisma migrate resolve --rolled-back 20201231000000_example"))}`);
      } else if (args2["--applied"] && args2["--rolled-back"]) {
        throw new Error("Pass either --applied or --rolled-back, not both.");
      }
      if (args2["--applied"]) {
        if (typeof args2["--applied"] !== "string" || args2["--applied"].length === 0) {
          throw new Error(`--applied value must be a string like ${import_chalk14.default.bold.green((0, import_sdk18.getCommandWithExecutor)("prisma migrate resolve --applied 20201231000000_example"))}`);
        }
        await (0, import_ensureDatabaseExists.ensureCanConnectToDatabase)(schemaPath);
        const migrate = new import_Migrate.Migrate(schemaPath);
        try {
          await migrate.markMigrationApplied({
            migrationId: args2["--applied"]
          });
        } finally {
          migrate.stop();
        }
        return `Migration ${args2["--applied"]} marked as applied.`;
      } else {
        if (typeof args2["--rolled-back"] !== "string" || args2["--rolled-back"].length === 0) {
          throw new Error(`--rolled-back value must be a string like ${import_chalk14.default.bold.green((0, import_sdk18.getCommandWithExecutor)("prisma migrate resolve --rolled-back 20201231000000_example"))}`);
        }
        await (0, import_ensureDatabaseExists.ensureCanConnectToDatabase)(schemaPath);
        const migrate = new import_Migrate.Migrate(schemaPath);
        try {
          await migrate.markMigrationRolledBack({
            migrationId: args2["--rolled-back"]
          });
        } finally {
          migrate.stop();
        }
        return `Migration ${args2["--rolled-back"]} marked as rolled back.`;
      }
    }
    help(error) {
      if (error) {
        return new import_sdk18.HelpError(`
${import_chalk14.default.bold.red(`!`)} ${error}
${_MigrateResolve.help}`);
      }
      return _MigrateResolve.help;
    }
  };
  var MigrateResolve3 = _MigrateResolve;
  MigrateResolve3.help = (0, import_sdk18.format)(`
Resolve issues with database migrations in deployment databases: 
- recover from failed migrations
- baseline databases when starting to use Prisma Migrate on existing databases
- reconcile hotfixes done manually on databases with your migration history

Run "prisma migrate status" to identify if you need to use resolve.

Read more about resolving migration history issues: ${(0, import_sdk18.link)("https://pris.ly/d/migrate-resolve")}
 
${import_chalk14.default.bold("Usage")}

  ${import_chalk14.default.dim("$")} prisma migrate resolve [options]
  
${import_chalk14.default.bold("Options")}

    -h, --help   Display this help message
      --schema   Custom path to your Prisma schema
     --applied   Record a specific migration as applied
 --rolled-back   Record a specific migration as rolled back

${import_chalk14.default.bold("Examples")}

  Update migrations table, recording a specific migration as applied 
  ${import_chalk14.default.dim("$")} prisma migrate resolve --applied 20201231000000_add_users_table

  Update migrations table, recording a specific migration as rolled back
  ${import_chalk14.default.dim("$")} prisma migrate resolve --rolled-back 20201231000000_add_users_table

  Specify a schema
  ${import_chalk14.default.dim("$")} prisma migrate resolve --rolled-back 20201231000000_add_users_table --schema=./schema.prisma
`);
});

// ../migrate/dist/commands/MigrateStatus.js
var require_MigrateStatus = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    MigrateStatus: () => MigrateStatus3
  });
  var import_sdk18 = __toModule3(require_dist12());
  var import_chalk14 = __toModule3(require_source());
  var import_path10 = __toModule3(require("path"));
  var import_ensureDatabaseExists = __toModule3(require_ensureDatabaseExists());
  var import_Migrate = __toModule3(require_Migrate());
  var import_flagErrors = __toModule3(require_flagErrors());
  var import_errors2 = __toModule3(require_errors3());
  var import_debug3 = __toModule3(require_dist13());
  var import_detectOldMigrate = __toModule3(require_detectOldMigrate());
  var import_printDatasource = __toModule3(require_printDatasource());
  var debug3 = (0, import_debug3.default)("prisma:migrate:status");
  var _MigrateStatus = class {
    static new() {
      return new _MigrateStatus();
    }
    async parse(argv) {
      var _a, _b;
      const args2 = (0, import_sdk18.arg)(argv, {
        "--help": Boolean,
        "-h": "--help",
        "--experimental": Boolean,
        "--early-access-feature": Boolean,
        "--schema": String,
        "--telemetry-information": String
      }, false);
      if ((0, import_sdk18.isError)(args2)) {
        return this.help(args2.message);
      }
      if (args2["--help"]) {
        return this.help();
      }
      if (args2["--experimental"]) {
        throw new import_flagErrors.ExperimentalFlagWithNewMigrateError();
      }
      if (args2["--early-access-feature"]) {
        throw new import_flagErrors.EarlyAccessFeatureFlagWithNewMigrateError();
      }
      const schemaPath = await (0, import_sdk18.getSchemaPath)(args2["--schema"]);
      if (!schemaPath) {
        throw new import_errors2.NoSchemaFoundError();
      }
      console.info(import_chalk14.default.dim(`Prisma schema loaded from ${import_path10.default.relative(process.cwd(), schemaPath)}`));
      await (0, import_printDatasource.printDatasource)(schemaPath);
      (0, import_detectOldMigrate.throwUpgradeErrorIfOldMigrate)(schemaPath);
      const migrate = new import_Migrate.Migrate(schemaPath);
      try {
        await (0, import_ensureDatabaseExists.ensureCanConnectToDatabase)(schemaPath);
      } catch (e) {
        console.info();
        return import_chalk14.default.red(`Database connection error:

${e.message}`);
      }
      let diagnoseResult;
      let listMigrationDirectoriesResult;
      try {
        diagnoseResult = await migrate.diagnoseMigrationHistory({
          optInToShadowDatabase: false
        });
        debug3({diagnoseResult: JSON.stringify(diagnoseResult, null, 2)});
        listMigrationDirectoriesResult = await migrate.listMigrationDirectories();
        debug3({listMigrationDirectoriesResult});
      } finally {
        migrate.stop();
      }
      console.log();
      if (listMigrationDirectoriesResult.migrations.length > 0) {
        const migrations = listMigrationDirectoriesResult.migrations;
        console.info(`${migrations.length} migration${migrations.length > 1 ? "s" : ""} found in prisma/migrations
`);
      } else {
        console.info(`No migration found in prisma/migrations
`);
      }
      let unappliedMigrations = [];
      if (((_a = diagnoseResult.history) == null ? void 0 : _a.diagnostic) === "databaseIsBehind") {
        unappliedMigrations = diagnoseResult.history.unappliedMigrationNames;
        console.info(`Following migration${unappliedMigrations.length > 1 ? "s" : ""} have not yet been applied:
${unappliedMigrations.join("\n")}

To apply migrations in development run ${import_chalk14.default.bold.greenBright((0, import_sdk18.getCommandWithExecutor)(`prisma migrate dev`))}.
To apply migrations in production run ${import_chalk14.default.bold.greenBright((0, import_sdk18.getCommandWithExecutor)(`prisma migrate deploy`))}.`);
      } else if (((_b = diagnoseResult.history) == null ? void 0 : _b.diagnostic) === "historiesDiverge") {
        return `Your local migration history and the migrations table from your database are different:

The last common migration is: ${diagnoseResult.history.lastCommonMigrationName}

The migration${diagnoseResult.history.unappliedMigrationNames.length > 1 ? "s" : ""} have not yet been applied:
${diagnoseResult.history.unappliedMigrationNames.join("\n")}

The migration${diagnoseResult.history.unpersistedMigrationNames.length > 1 ? "s" : ""} from the database are not found locally in prisma/migrations:
${diagnoseResult.history.unpersistedMigrationNames.join("\n")}`;
      }
      if (!diagnoseResult.hasMigrationsTable) {
        if (listMigrationDirectoriesResult.migrations.length === 0) {
          return new import_errors2.HowToBaselineError().message;
        } else {
          const migrationId = listMigrationDirectoriesResult.migrations.shift();
          return `The current database is not managed by Prisma Migrate.

If you want to keep the current database structure and data and create new migrations, baseline this database with the migration "${migrationId}":
${import_chalk14.default.bold.greenBright((0, import_sdk18.getCommandWithExecutor)(`prisma migrate resolve --applied "${migrationId}"`))}

Read more about how to baseline an existing production database:
https://pris.ly/d/migrate-baseline`;
        }
      } else if (diagnoseResult.failedMigrationNames.length > 0) {
        const failedMigrations = diagnoseResult.failedMigrationNames;
        console.info(`Following migration${failedMigrations.length > 1 ? "s" : ""} have failed:
${failedMigrations.join("\n")}

During development if the failed migration(s) have not been deployed to a production database you can then fix the migration(s) and run ${import_chalk14.default.bold.greenBright((0, import_sdk18.getCommandWithExecutor)(`prisma migrate dev`))}.
`);
        return `The failed migration(s) can be marked as rolled back or applied:
      
- If you rolled back the migration(s) manually:
${import_chalk14.default.bold.greenBright((0, import_sdk18.getCommandWithExecutor)(`prisma migrate resolve --rolled-back "${failedMigrations[0]}"`))}

- If you fixed the database manually (hotfix):
${import_chalk14.default.bold.greenBright((0, import_sdk18.getCommandWithExecutor)(`prisma migrate resolve --applied "${failedMigrations[0]}"`))}

Read more about how to resolve migration issues in a production database:
https://pris.ly/d/migrate-resolve`;
      } else {
        console.info();
        if (unappliedMigrations.length > 0) {
          return ``;
        } else {
          return `Database schema is up to date!`;
        }
      }
    }
    help(error) {
      if (error) {
        return new import_sdk18.HelpError(`
${import_chalk14.default.bold.red(`!`)} ${error}
${_MigrateStatus.help}`);
      }
      return _MigrateStatus.help;
    }
  };
  var MigrateStatus3 = _MigrateStatus;
  MigrateStatus3.help = (0, import_sdk18.format)(`
Check the status of your database migrations

  ${import_chalk14.default.bold("Usage")}

    ${import_chalk14.default.dim("$")} prisma migrate status [options]
    
  ${import_chalk14.default.bold("Options")}

  -h, --help   Display this help message
    --schema   Custom path to your Prisma schema

  ${import_chalk14.default.bold("Examples")}

  Check the status of your database migrations
  ${import_chalk14.default.dim("$")} prisma migrate status

  Specify a schema
  ${import_chalk14.default.dim("$")} prisma migrate status --schema=./schema.prisma
`);
});

// ../migrate/dist/commands/MigrateReset.js
var require_MigrateReset = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    MigrateReset: () => MigrateReset3
  });
  var import_sdk18 = __toModule3(require_dist12());
  var import_chalk14 = __toModule3(require_source());
  var import_path10 = __toModule3(require("path"));
  var import_prompts = __toModule3(require_prompts3());
  var import_Migrate = __toModule3(require_Migrate());
  var import_flagErrors = __toModule3(require_flagErrors());
  var import_errors2 = __toModule3(require_errors3());
  var import_printFiles = __toModule3(require_printFiles());
  var import_detectOldMigrate = __toModule3(require_detectOldMigrate());
  var import_ensureDatabaseExists = __toModule3(require_ensureDatabaseExists());
  var import_printDatasource = __toModule3(require_printDatasource());
  var import_seed = __toModule3(require_seed());
  var _MigrateReset = class {
    static new() {
      return new _MigrateReset();
    }
    async parse(argv) {
      var _a;
      const args2 = (0, import_sdk18.arg)(argv, {
        "--help": Boolean,
        "-h": "--help",
        "--force": Boolean,
        "-f": "--force",
        "--skip-generate": Boolean,
        "--skip-seed": Boolean,
        "--experimental": Boolean,
        "--early-access-feature": Boolean,
        "--schema": String,
        "--telemetry-information": String
      });
      if ((0, import_sdk18.isError)(args2)) {
        return this.help(args2.message);
      }
      if (args2["--help"]) {
        return this.help();
      }
      if (args2["--experimental"]) {
        throw new import_flagErrors.ExperimentalFlagWithNewMigrateError();
      }
      if (args2["--early-access-feature"]) {
        throw new import_flagErrors.EarlyAccessFeatureFlagWithNewMigrateError();
      }
      const schemaPath = await (0, import_sdk18.getSchemaPath)(args2["--schema"]);
      if (!schemaPath) {
        throw new import_errors2.NoSchemaFoundError();
      }
      console.info(import_chalk14.default.dim(`Prisma schema loaded from ${import_path10.default.relative(process.cwd(), schemaPath)}`));
      await (0, import_printDatasource.printDatasource)(schemaPath);
      console.info();
      (0, import_detectOldMigrate.throwUpgradeErrorIfOldMigrate)(schemaPath);
      const wasDbCreated = await (0, import_ensureDatabaseExists.ensureDatabaseExists)("create", true, schemaPath);
      if (wasDbCreated) {
        console.info(wasDbCreated);
      }
      if (!args2["--force"]) {
        if ((0, import_sdk18.isCi)() && Boolean((_a = import_prompts.default._injected) == null ? void 0 : _a.length) === false) {
          throw new import_errors2.MigrateResetEnvNonInteractiveError();
        }
        console.info();
        const confirmation = await (0, import_prompts.default)({
          type: "confirm",
          name: "value",
          message: `Are you sure you want to reset your database? ${import_chalk14.default.red("All data will be lost")}.`
        });
        if (!confirmation.value) {
          console.info("Reset cancelled.");
          process.exit(0);
          return ``;
        }
      }
      const migrate = new import_Migrate.Migrate(schemaPath);
      let migrationIds;
      try {
        await migrate.reset();
        const {appliedMigrationNames} = await migrate.applyMigrations();
        migrationIds = appliedMigrationNames;
      } finally {
        migrate.stop();
      }
      if (migrationIds.length === 0) {
        console.info(`${import_chalk14.default.green("Database reset successful")}`);
      } else {
        console.info(`${import_chalk14.default.green("Database reset successful")}

The following migration(s) have been applied:

${(0, import_chalk14.default)((0, import_printFiles.printFilesFromMigrationIds)("migrations", migrationIds, {
          "migration.sql": ""
        }))}`);
      }
      if (!process.env.PRISMA_MIGRATE_SKIP_GENERATE && !args2["--skip-generate"]) {
        await migrate.tryToRunGenerate();
      }
      if (!process.env.PRISMA_MIGRATE_SKIP_SEED && !args2["--skip-seed"]) {
        const detected = (0, import_seed.detectSeedFiles)(schemaPath);
        if (detected.numberOfSeedFiles > 0) {
          await (0, import_seed.tryToRunSeed)(schemaPath);
        }
      }
      return ``;
    }
    help(error) {
      if (error) {
        return new import_sdk18.HelpError(`
${import_chalk14.default.bold.red(`!`)} ${error}
${_MigrateReset.help}`);
      }
      return _MigrateReset.help;
    }
  };
  var MigrateReset3 = _MigrateReset;
  MigrateReset3.help = (0, import_sdk18.format)(`
Reset your database and apply all migrations, all data will be lost

${import_chalk14.default.bold("Usage")}

  ${import_chalk14.default.dim("$")} prisma migrate reset [options]

${import_chalk14.default.bold("Options")}

       -h, --help   Display this help message
         --schema   Custom path to your Prisma schema
  --skip-generate   Skip triggering generators (e.g. Prisma Client)
      --skip-seed   Skip triggering seed
      -f, --force   Skip the confirmation prompt

${import_chalk14.default.bold("Examples")}

  Reset your database and apply all migrations, all data will be lost
  ${import_chalk14.default.dim("$")} prisma migrate reset

  Specify a schema
  ${import_chalk14.default.dim("$")} prisma migrate reset --schema=./schema.prisma 

  Use --force to skip the confirmation prompt
  ${import_chalk14.default.dim("$")} prisma migrate reset --force
  `);
});

// ../migrate/dist/commands/MigrateDeploy.js
var require_MigrateDeploy = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    MigrateDeploy: () => MigrateDeploy3
  });
  var import_sdk18 = __toModule3(require_dist12());
  var import_chalk14 = __toModule3(require_source());
  var import_path10 = __toModule3(require("path"));
  var import_Migrate = __toModule3(require_Migrate());
  var import_ensureDatabaseExists = __toModule3(require_ensureDatabaseExists());
  var import_flagErrors = __toModule3(require_flagErrors());
  var import_errors2 = __toModule3(require_errors3());
  var import_printFiles = __toModule3(require_printFiles());
  var import_detectOldMigrate = __toModule3(require_detectOldMigrate());
  var import_printDatasource = __toModule3(require_printDatasource());
  var import_debug3 = __toModule3(require_dist13());
  var debug3 = (0, import_debug3.default)("prisma:migrate:deploy");
  var _MigrateDeploy = class {
    static new() {
      return new _MigrateDeploy();
    }
    async parse(argv) {
      const args2 = (0, import_sdk18.arg)(argv, {
        "--help": Boolean,
        "-h": "--help",
        "--experimental": Boolean,
        "--early-access-feature": Boolean,
        "--schema": String,
        "--telemetry-information": String
      }, false);
      if ((0, import_sdk18.isError)(args2)) {
        return this.help(args2.message);
      }
      if (args2["--help"]) {
        return this.help();
      }
      if (args2["--experimental"]) {
        throw new import_flagErrors.ExperimentalFlagWithNewMigrateError();
      }
      if (args2["--early-access-feature"]) {
        throw new import_flagErrors.EarlyAccessFeatureFlagWithNewMigrateError();
      }
      const schemaPath = await (0, import_sdk18.getSchemaPath)(args2["--schema"]);
      if (!schemaPath) {
        throw new import_errors2.NoSchemaFoundError();
      }
      console.info(import_chalk14.default.dim(`Prisma schema loaded from ${import_path10.default.relative(process.cwd(), schemaPath)}`));
      await (0, import_printDatasource.printDatasource)(schemaPath);
      (0, import_detectOldMigrate.throwUpgradeErrorIfOldMigrate)(schemaPath);
      const migrate = new import_Migrate.Migrate(schemaPath);
      const wasDbCreated = await (0, import_ensureDatabaseExists.ensureDatabaseExists)("apply", true, schemaPath);
      if (wasDbCreated) {
        console.info();
        console.info(wasDbCreated);
      }
      const diagnoseResult = await migrate.diagnoseMigrationHistory({
        optInToShadowDatabase: false
      });
      debug3({diagnoseResult: JSON.stringify(diagnoseResult, null, 2)});
      const listMigrationDirectoriesResult = await migrate.listMigrationDirectories();
      debug3({listMigrationDirectoriesResult});
      console.info();
      if (listMigrationDirectoriesResult.migrations.length > 0) {
        const migrations = listMigrationDirectoriesResult.migrations;
        console.info(`${migrations.length} migration${migrations.length > 1 ? "s" : ""} found in prisma/migrations`);
      } else {
        console.info(`No migration found in prisma/migrations`);
      }
      const editedMigrationNames = diagnoseResult.editedMigrationNames;
      if (editedMigrationNames.length > 0) {
        console.info(`${import_chalk14.default.yellow("WARNING The following migrations have been modified since they were applied:")}
${editedMigrationNames.join("\n")}`);
      }
      let migrationIds;
      try {
        const {appliedMigrationNames} = await migrate.applyMigrations();
        migrationIds = appliedMigrationNames;
      } finally {
        migrate.stop();
      }
      console.info();
      if (migrationIds.length === 0) {
        return import_chalk14.default.greenBright(`No pending migrations to apply.`);
      } else {
        return `The following migration${migrationIds.length > 1 ? "s" : ""} have been applied:

${(0, import_chalk14.default)((0, import_printFiles.printFilesFromMigrationIds)("migrations", migrationIds, {
          "migration.sql": ""
        }))}
      
${import_chalk14.default.greenBright("All migrations have been successfully applied.")}`;
      }
    }
    help(error) {
      if (error) {
        return new import_sdk18.HelpError(`
${import_chalk14.default.bold.red(`!`)} ${error}
${_MigrateDeploy.help}`);
      }
      return _MigrateDeploy.help;
    }
  };
  var MigrateDeploy3 = _MigrateDeploy;
  MigrateDeploy3.help = (0, import_sdk18.format)(`
Apply pending migrations to update the database schema in production/staging

${import_chalk14.default.bold("Usage")}

  ${import_chalk14.default.dim("$")} prisma migrate deploy [options]

${import_chalk14.default.bold("Options")}

  -h, --help   Display this help message
    --schema   Custom path to your Prisma schema

${import_chalk14.default.bold("Examples")}

  Deploy your pending migrations to your production/staging database
  ${import_chalk14.default.dim("$")} prisma migrate deploy

  Specify a schema
  ${import_chalk14.default.dim("$")} prisma migrate deploy --schema=./schema.prisma

`);
});

// ../migrate/dist/commands/DbCommand.js
var require_DbCommand = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    DbCommand: () => DbCommand3
  });
  var import_sdk18 = __toModule3(require_dist12());
  var import_chalk14 = __toModule3(require_source());
  var _DbCommand = class {
    constructor(cmds) {
      this.cmds = cmds;
    }
    static new(cmds) {
      return new _DbCommand(cmds);
    }
    async parse(argv) {
      const args2 = (0, import_sdk18.arg)(argv, {
        "--help": Boolean,
        "-h": "--help",
        "--preview-feature": Boolean,
        "--telemetry-information": String
      });
      if ((0, import_sdk18.isError)(args2)) {
        return this.help(args2.message);
      }
      if (args2._.length === 0 || args2["--help"]) {
        return this.help();
      }
      const cmd = this.cmds[args2._[0]];
      if (cmd) {
        const argsForCmd = args2["--preview-feature"] ? [...args2._.slice(1), `--preview-feature`] : args2._.slice(1);
        return cmd.parse(argsForCmd);
      }
      return (0, import_sdk18.unknownCommand)(_DbCommand.help, args2._[0]);
    }
    help(error) {
      if (error) {
        return new import_sdk18.HelpError(`
${import_chalk14.default.bold.red(`!`)} ${error}
${_DbCommand.help}`);
      }
      return _DbCommand.help;
    }
  };
  var DbCommand3 = _DbCommand;
  DbCommand3.help = (0, import_sdk18.format)(`
${process.platform === "win32" ? "" : import_chalk14.default.bold("\u{1F3CB}\uFE0F  ")}Manage your database schema and lifecycle during development.

${import_chalk14.default.bold("Usage")}

  ${import_chalk14.default.dim("$")} prisma db [command] [options]

${import_chalk14.default.bold("Options")}

  -h, --help   Display this help message
    --schema   Custom path to your Prisma schema

${import_chalk14.default.bold("Commands")}
        pull   Pull the state from the database to the Prisma schema using introspection
        push   Push the state from Prisma schema to the database during prototyping
        seed   Seed your database ${import_chalk14.default.dim("(preview)")} 

${import_chalk14.default.bold("Examples")}

  Using prisma db pull
  ${import_chalk14.default.dim("$")} prisma db pull

  Using prisma db push
  ${import_chalk14.default.dim("$")} prisma db push

  Using prisma db seed
  ${import_chalk14.default.dim("$")} prisma db seed --preview-feature
`);
});

// ../migrate/dist/utils/printDatasources.js
var require_printDatasources = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    printDatamodelObject: () => printDatamodelObject,
    printDatasources: () => printDatasources
  });
  var import_indent_string = __toModule3(require_indent_string());
  function printDatasources(internalDatasources) {
    return internalDatasources.map((d2) => String(new InternalDataSourceClass(d2))).join("\n\n");
  }
  var tab = 2;
  var InternalDataSourceClass = class {
    constructor(dataSource) {
      this.dataSource = dataSource;
    }
    toString() {
      const {dataSource} = this;
      const obj = {
        provider: dataSource.provider,
        url: dataSource.url
      };
      if (dataSource.config && typeof dataSource.config === "object") {
        Object.assign(obj, dataSource.config);
      }
      return `datasource ${dataSource.name} {
${(0, import_indent_string.default)(printDatamodelObject(obj), tab)}
}`;
    }
  };
  function printDatamodelObject(obj) {
    const maxLength = Object.keys(obj).reduce((max, curr) => Math.max(max, curr.length), 0);
    return Object.entries(obj).map(([key, value]) => `${key.padEnd(maxLength)} = ${typeof value === "object" && value && value.value ? JSON.stringify(value.value) : JSON.stringify(value)}`).join("\n");
  }
});

// ../migrate/dist/utils/removeDatasource.js
var require_removeDatasource = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    removeDatasource: () => removeDatasource
  });
  var import_sdk18 = __toModule3(require_dist12());
  function removeDatasource(schema) {
    return (0, import_sdk18.trimBlocksFromSchema)(schema, ["datasource"]).trim();
  }
});

// ../migrate/dist/commands/DbPull.js
var require_DbPull = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    DbPull: () => DbPull3
  });
  var import_sdk18 = __toModule3(require_dist12());
  var import_chalk14 = __toModule3(require_source());
  var import_path10 = __toModule3(require("path"));
  var import_sdk22 = __toModule3(require_dist12());
  var import_formatms3 = __toModule3(require_formatms());
  var import_fs9 = __toModule3(require("fs"));
  var import_convertCredentials2 = __toModule3(require_convertCredentials());
  var import_printDatasources = __toModule3(require_printDatasources());
  var import_removeDatasource = __toModule3(require_removeDatasource());
  var import_errors2 = __toModule3(require_errors3());
  var import_printDatasource = __toModule3(require_printDatasource());
  var _DbPull = class {
    static new() {
      return new _DbPull();
    }
    printUrlAsDatasource(url) {
      const provider = (0, import_convertCredentials2.protocolToConnectorType)(`${url.split(":")[0]}:`);
      return (0, import_printDatasources.printDatasources)([
        {
          config: {},
          provider,
          name: "db",
          url
        }
      ]);
    }
    async parse(argv) {
      const args2 = (0, import_sdk18.arg)(argv, {
        "--help": Boolean,
        "-h": "--help",
        "--url": String,
        "--print": Boolean,
        "--schema": String,
        "--force": Boolean,
        "--experimental-reintrospection": Boolean,
        "--clean": Boolean
      });
      const log2 = (...messages) => {
        if (!args2["--print"]) {
          console.info(...messages);
        }
      };
      if (args2 instanceof Error) {
        return this.help(args2.message);
      }
      if (args2["--help"]) {
        return this.help();
      }
      if (args2["--clean"] || args2["--experimental-reintrospection"]) {
        const renamedMessages = [];
        if (args2["--experimental-reintrospection"]) {
          renamedMessages.push(`The ${import_chalk14.default.redBright("--experimental-reintrospection")} flag has been removed and is now the default behavior of ${import_chalk14.default.greenBright("prisma db pull")}.`);
        }
        if (args2["--clean"]) {
          renamedMessages.push(`The ${import_chalk14.default.redBright("--clean")} flag has been renamed to ${import_chalk14.default.greenBright("--force")}.`);
        }
        console.error(`
${renamedMessages.join("\n")}
`);
        process.exit(1);
      }
      const url = args2["--url"];
      let schemaPath = await (0, import_sdk18.getSchemaPath)(args2["--schema"]);
      if (schemaPath && !args2["--print"]) {
        console.info(import_chalk14.default.dim(`Prisma schema loaded from ${import_path10.default.relative(process.cwd(), schemaPath)}`));
        await (0, import_printDatasource.printDatasource)(schemaPath);
      }
      if (!url && !schemaPath) {
        throw new import_errors2.NoSchemaFoundError();
      }
      let schema = null;
      if (url && schemaPath) {
        schema = this.printUrlAsDatasource(url);
        const rawSchema = import_fs9.default.readFileSync(schemaPath, "utf-8");
        schema += (0, import_removeDatasource.removeDatasource)(rawSchema);
      } else if (url) {
        schema = this.printUrlAsDatasource(url);
      } else if (schemaPath) {
        schema = import_fs9.default.readFileSync(schemaPath, "utf-8");
      } else {
        throw new Error("Could not find a `schema.prisma` file");
      }
      const engine = new import_sdk22.IntrospectionEngine({
        cwd: schemaPath ? import_path10.default.dirname(schemaPath) : void 0
      });
      const basedOn = !args2["--url"] && schemaPath ? ` based on datasource defined in ${import_chalk14.default.underline(import_path10.default.relative(process.cwd(), schemaPath))}` : "";
      log2(`
Introspecting${basedOn} \u2026`);
      const before = Date.now();
      let introspectionSchema = "";
      let introspectionWarnings;
      let introspectionSchemaVersion;
      try {
        const introspectionResult = await engine.introspect(schema, args2["--force"]);
        introspectionSchema = introspectionResult.datamodel;
        introspectionWarnings = introspectionResult.warnings;
        introspectionSchemaVersion = introspectionResult.version;
      } catch (e) {
        if (e.code === "P4001") {
          if (introspectionSchema.trim() === "") {
            throw new Error(`
${import_chalk14.default.red.bold("P4001 ")}${import_chalk14.default.red("The introspected database was empty:")} ${url ? import_chalk14.default.underline(url) : ""}

${import_chalk14.default.bold("prisma db pull")} could not create any models in your ${import_chalk14.default.bold("schema.prisma")} file and you will not be able to generate Prisma Client with the ${import_chalk14.default.bold((0, import_sdk18.getCommandWithExecutor)("prisma generate"))} command.

${import_chalk14.default.bold("To fix this, you have two options:")}

- manually create a table in your database (using SQL).
- make sure the database connection URL inside the ${import_chalk14.default.bold("datasource")} block in ${import_chalk14.default.bold("schema.prisma")} points to a database that is not empty (it must contain at least one table).

Then you can run ${import_chalk14.default.green((0, import_sdk18.getCommandWithExecutor)("prisma db pull"))} again. 
`);
          }
        } else if (e.code === "P1012") {
          console.info();
          throw new Error(`${import_chalk14.default.red(`${e.code} Introspection failed as your current Prisma schema file is invalid`)}

Please fix your current schema manually, use ${import_chalk14.default.green((0, import_sdk18.getCommandWithExecutor)("prisma validate"))} to confirm it is valid and then run this command again.
Or run this command with the ${import_chalk14.default.green("--force")} flag to ignore your current schema and overwrite it. All local modifications will be lost.
`);
        }
        throw e;
      }
      function getWarningMessage(warnings) {
        if (warnings.length > 0) {
          let message = `
*** WARNING ***
`;
          for (const warning of warnings) {
            message += `
${warning.message}
`;
            if (warning.code === 0) {
            } else if (warning.code === 1) {
              message += warning.affected.map((it) => `- "${it.model}"`).join("\n");
            } else if (warning.code === 2) {
              const modelsGrouped = warning.affected.reduce((acc, it) => {
                if (!acc[it.model]) {
                  acc[it.model] = [];
                }
                acc[it.model].push(it.field);
                return acc;
              }, {});
              message += Object.entries(modelsGrouped).map(([model, fields]) => `- Model: "${model}"
  Field(s): "${fields.join('", "')}"`).join("\n");
            } else if (warning.code === 3) {
              message += warning.affected.map((it) => `- Model "${it.model}", field: "${it.field}", original data type: "${it.tpe}"`).join("\n");
            } else if (warning.code === 4) {
              message += warning.affected.map((it) => `- Enum "${it.enm}", value: "${it.value}"`).join("\n");
            } else if (warning.code === 5 || warning.code === 6 || warning.code === 8 || warning.code === 11 || warning.code === 12 || warning.code === 13) {
              message += warning.affected.map((it) => `- Model "${it.model}", field: "${it.field}"`).join("\n");
            } else if (warning.code === 7) {
              message += warning.affected.map((it) => `- Model "${it.model}"`).join("\n");
            } else if (warning.code === 9 || warning.code === 10) {
              message += warning.affected.map((it) => `- Enum "${it.enm}"`).join("\n");
            } else if (warning.affected) {
              message += `Code ${warning.code}
${JSON.stringify(warning.affected, null, 2)}`;
            }
            message += `
`;
          }
          return message;
        }
        return void 0;
      }
      const introspectionWarningsMessage = getWarningMessage(introspectionWarnings) || "";
      const prisma1UpgradeMessage = introspectionSchemaVersion.includes("Prisma1") ? `
${import_chalk14.default.bold("Upgrading from Prisma 1 to Prisma 2?")}
      
The database you introspected could belong to a Prisma 1 project.

Please run the following command to upgrade to Prisma 2.0:
${import_chalk14.default.green("npx prisma-upgrade [path-to-prisma-yml] [path-to-schema-prisma]")}

Note: \`prisma.yml\` and \`schema.prisma\` paths are optional.
 
Learn more about the upgrade process in the docs:
${(0, import_sdk18.link)("https://pris.ly/d/upgrading-to-prisma2")}
` : "";
      if (args2["--print"]) {
        console.log(introspectionSchema);
        introspectionSchemaVersion && console.log(`
// introspectionSchemaVersion: ${introspectionSchemaVersion}`, prisma1UpgradeMessage.replace(/(\n)/gm, "\n// "));
        if (introspectionWarningsMessage.trim().length > 0) {
          console.error(introspectionWarningsMessage.replace(/(\n)/gm, "\n// "));
        }
      } else {
        schemaPath = schemaPath || "schema.prisma";
        import_fs9.default.writeFileSync(schemaPath, introspectionSchema);
        const modelsCount = (introspectionSchema.match(/^model\s+/gm) || []).length;
        const prisma1UpgradeMessageBox = prisma1UpgradeMessage ? "\n\n" + (0, import_sdk18.drawBox)({
          height: 16,
          width: 74,
          str: prisma1UpgradeMessage + "\nOnce you upgraded your database schema to Prisma 2.0, \ncontinue with the instructions below.\n",
          horizontalPadding: 2
        }) : "";
        log2(`
\u2714 Introspected ${modelsCount} ${modelsCount > 1 ? "models and wrote them" : "model and wrote it"} into ${import_chalk14.default.underline(import_path10.default.relative(process.cwd(), schemaPath))} in ${import_chalk14.default.bold((0, import_formatms3.formatms)(Date.now() - before))}${prisma1UpgradeMessageBox}
      ${import_chalk14.default.keyword("orange")(introspectionWarningsMessage)}
${`Run ${import_chalk14.default.green((0, import_sdk18.getCommandWithExecutor)("prisma generate"))} to generate Prisma Client.`}`);
      }
      engine.stop();
      return "";
    }
    help(error) {
      if (error) {
        return new import_sdk18.HelpError(`
${import_chalk14.default.bold.red(`!`)} ${error}
${_DbPull.help}`);
      }
      return _DbPull.help;
    }
  };
  var DbPull3 = _DbPull;
  DbPull3.help = (0, import_sdk18.format)(`
Pull the state from the database to the Prisma schema using introspection

${import_chalk14.default.bold("Usage")}

  ${import_chalk14.default.dim("$")} prisma db pull [options]

${import_chalk14.default.bold("Options")}

  -h, --help   Display this help message
    --schema   Custom path to your Prisma schema
     --force   Ignore current Prisma schema file
     --print   Print the introspected Prisma schema to stdout

${import_chalk14.default.bold("Examples")}

With an existing Prisma schema
  ${import_chalk14.default.dim("$")} prisma db pull

Or specify a Prisma schema path
  ${import_chalk14.default.dim("$")} prisma db pull --schema=./schema.prisma

Instead of saving the result to the filesystem, you can also print it to stdout
  ${import_chalk14.default.dim("$")} prisma db pull --print

`);
});

// ../migrate/dist/commands/DbPush.js
var require_DbPush = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    DbPush: () => DbPush3
  });
  var import_sdk18 = __toModule3(require_dist12());
  var import_path10 = __toModule3(require("path"));
  var import_chalk14 = __toModule3(require_source());
  var import_prompts = __toModule3(require_prompts3());
  var import_Migrate = __toModule3(require_Migrate());
  var import_ensureDatabaseExists = __toModule3(require_ensureDatabaseExists());
  var import_formatms3 = __toModule3(require_formatms());
  var import_errors2 = __toModule3(require_errors3());
  var import_printDatasource = __toModule3(require_printDatasource());
  var _DbPush = class {
    static new() {
      return new _DbPush();
    }
    async parse(argv) {
      var _a, _b;
      const args2 = (0, import_sdk18.arg)(argv, {
        "--help": Boolean,
        "-h": "--help",
        "--preview-feature": Boolean,
        "--accept-data-loss": Boolean,
        "--force-reset": Boolean,
        "--skip-generate": Boolean,
        "--schema": String,
        "--telemetry-information": String,
        "--force": Boolean,
        "-f": "--force"
      }, false);
      if ((0, import_sdk18.isError)(args2)) {
        return this.help(args2.message);
      }
      if (args2["--help"]) {
        return this.help();
      }
      if (args2["--preview-feature"]) {
        import_sdk18.logger.warn(`Prisma "db push" was in Preview and is now Generally Available.
You can now remove the ${import_chalk14.default.red("--preview-feature")} flag.`);
      }
      if (args2["--force"]) {
        throw new import_errors2.DbPushForceFlagRenamedError();
      }
      const schemaPath = await (0, import_sdk18.getSchemaPath)(args2["--schema"]);
      if (!schemaPath) {
        throw new import_errors2.NoSchemaFoundError();
      }
      console.info(import_chalk14.default.dim(`Prisma schema loaded from ${import_path10.default.relative(process.cwd(), schemaPath)}`));
      await (0, import_printDatasource.printDatasource)(schemaPath);
      const dbInfo = await (0, import_ensureDatabaseExists.getDbInfo)(schemaPath);
      const migrate = new import_Migrate.Migrate(schemaPath);
      const wasDbCreated = await (0, import_ensureDatabaseExists.ensureDatabaseExists)("push", true, schemaPath);
      if (wasDbCreated) {
        console.info();
        console.info(wasDbCreated);
      }
      let wasDatabaseReset = false;
      if (args2["--force-reset"]) {
        console.info();
        try {
          await migrate.reset();
        } catch (e) {
          migrate.stop();
          throw e;
        }
        if (dbInfo.dbName && dbInfo.dbLocation) {
          console.info(`The ${dbInfo.dbType} ${dbInfo.schemaWord} "${dbInfo.dbName}" from "${dbInfo.dbLocation}" was successfully reset.`);
        } else {
          console.info(`The ${dbInfo.dbType} ${dbInfo.schemaWord} was successfully reset.`);
        }
        wasDatabaseReset = true;
      }
      const before = Date.now();
      let migration;
      try {
        migration = await migrate.push({
          force: args2["--accept-data-loss"]
        });
      } catch (e) {
        migrate.stop();
        throw e;
      }
      if (migration.unexecutable && migration.unexecutable.length > 0) {
        const messages = [];
        messages.push(`${import_chalk14.default.bold.red("\n\u26A0\uFE0F We found changes that cannot be executed:\n")}`);
        for (const item of migration.unexecutable) {
          messages.push(`${(0, import_chalk14.default)(`  \u2022 ${item}`)}`);
        }
        console.info();
        if ((0, import_sdk18.isCi)() && Boolean((_a = import_prompts.default._injected) == null ? void 0 : _a.length) === false) {
          migrate.stop();
          throw new Error(`${messages.join("\n")}

Use the --force-reset flag to drop the database before push like ${import_chalk14.default.bold.greenBright((0, import_sdk18.getCommandWithExecutor)("prisma db push --force-reset"))}
${import_chalk14.default.bold.redBright("All data will be lost.")}
        `);
        } else {
          console.info(`${messages.join("\n")}
`);
        }
        console.info();
        const confirmation = await (0, import_prompts.default)({
          type: "confirm",
          name: "value",
          message: `To apply this change we need to reset the database, do you want to continue? ${import_chalk14.default.red("All data will be lost")}.`
        });
        if (!confirmation.value) {
          console.info("Reset cancelled.");
          migrate.stop();
          process.exit(0);
          return ``;
        }
        try {
          await migrate.reset();
          if (dbInfo.dbName && dbInfo.dbLocation) {
            console.info(`The ${dbInfo.dbType} ${dbInfo.schemaWord} "${dbInfo.dbName}" from "${dbInfo.dbLocation}" was successfully reset.`);
          } else {
            console.info(`The ${dbInfo.dbType} ${dbInfo.schemaWord} was successfully reset.`);
          }
          wasDatabaseReset = true;
          await migrate.push({});
        } catch (e) {
          migrate.stop();
          throw e;
        }
      }
      if (migration.warnings && migration.warnings.length > 0) {
        console.info(import_chalk14.default.bold.yellow(`
\u26A0\uFE0F  There might be data loss when applying the changes:
`));
        for (const warning of migration.warnings) {
          console.info((0, import_chalk14.default)(`  \u2022 ${warning}`));
        }
        console.info();
        if (!args2["--accept-data-loss"]) {
          if ((0, import_sdk18.isCi)() && Boolean((_b = import_prompts.default._injected) == null ? void 0 : _b.length) === false) {
            migrate.stop();
            throw new import_errors2.DbPushIgnoreWarningsWithFlagError();
          }
          console.info();
          const confirmation = await (0, import_prompts.default)({
            type: "confirm",
            name: "value",
            message: `Do you want to ignore the warning(s)?`
          });
          if (!confirmation.value) {
            console.info("Push cancelled.");
            migrate.stop();
            process.exit(0);
            return ``;
          }
          try {
            await migrate.push({
              force: true
            });
          } catch (e) {
            migrate.stop();
            throw e;
          }
        }
      }
      migrate.stop();
      if (!wasDatabaseReset && migration.warnings.length === 0 && migration.executedSteps === 0) {
        console.info(`
The database is already in sync with the Prisma schema.`);
      } else {
        console.info(`
${process.platform === "win32" ? "" : "\u{1F680}  "}Your database is now in sync with your schema. Done in ${(0, import_formatms3.formatms)(Date.now() - before)}`);
      }
      if (!process.env.PRISMA_MIGRATE_SKIP_GENERATE && !args2["--skip-generate"]) {
        await migrate.tryToRunGenerate();
      }
      return ``;
    }
    help(error) {
      if (error) {
        return new import_sdk18.HelpError(`
${import_chalk14.default.bold.red(`!`)} ${error}
${_DbPush.help}`);
      }
      return _DbPush.help;
    }
  };
  var DbPush3 = _DbPush;
  DbPush3.help = (0, import_sdk18.format)(`
${process.platform === "win32" ? "" : import_chalk14.default.bold("\u{1F64C}  ")}Push the state from your Prisma schema to your database

${import_chalk14.default.bold("Usage")}

  ${import_chalk14.default.dim("$")} prisma db push [options]

${import_chalk14.default.bold("Options")}

           -h, --help   Display this help message
             --schema   Custom path to your Prisma schema
   --accept-data-loss   Ignore data loss warnings
        --force-reset   Force a reset of the database before push 
      --skip-generate   Skip triggering generators (e.g. Prisma Client)

${import_chalk14.default.bold("Examples")}

  Push the Prisma schema state to the database
  ${import_chalk14.default.dim("$")} prisma db push

  Specify a schema
  ${import_chalk14.default.dim("$")} prisma db push --schema=./schema.prisma

  Ignore data loss warnings
  ${import_chalk14.default.dim("$")} prisma db push --accept-data-loss
`);
});

// ../migrate/dist/commands/DbDrop.js
var require_DbDrop = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    DbDrop: () => DbDrop2
  });
  var import_sdk18 = __toModule3(require_dist12());
  var import_path10 = __toModule3(require("path"));
  var import_chalk14 = __toModule3(require_source());
  var import_prompts = __toModule3(require_prompts3());
  var import_ensureDatabaseExists = __toModule3(require_ensureDatabaseExists());
  var import_flagErrors = __toModule3(require_flagErrors());
  var import_errors2 = __toModule3(require_errors3());
  var import_printDatasource = __toModule3(require_printDatasource());
  var _DbDrop = class {
    static new() {
      return new _DbDrop();
    }
    async parse(argv) {
      var _a;
      const args2 = (0, import_sdk18.arg)(argv, {
        "--help": Boolean,
        "-h": "--help",
        "--preview-feature": Boolean,
        "--force": Boolean,
        "-f": "--force",
        "--schema": String,
        "--telemetry-information": String
      });
      if ((0, import_sdk18.isError)(args2)) {
        return this.help(args2.message);
      }
      if (args2["--help"]) {
        return this.help();
      }
      if (!args2["--preview-feature"]) {
        throw new import_flagErrors.PreviewFlagError();
      }
      const schemaPath = await (0, import_sdk18.getSchemaPath)(args2["--schema"]);
      if (!schemaPath) {
        throw new import_errors2.NoSchemaFoundError();
      }
      console.info(import_chalk14.default.dim(`Prisma schema loaded from ${import_path10.default.relative(process.cwd(), schemaPath)}`));
      await (0, import_printDatasource.printDatasource)(schemaPath);
      const dbInfo = await (0, import_ensureDatabaseExists.getDbInfo)(schemaPath);
      const schemaDir = await (0, import_sdk18.getSchemaDir)(schemaPath);
      console.info();
      if (!args2["--force"]) {
        if ((0, import_sdk18.isCi)() && Boolean((_a = import_prompts.default._injected) == null ? void 0 : _a.length) === false) {
          throw new import_errors2.DbNeedsForceError("drop");
        }
        const confirmation = await (0, import_prompts.default)({
          type: "text",
          name: "value",
          message: `Enter the ${dbInfo.dbType} ${dbInfo.schemaWord} name "${dbInfo.dbName}" to drop it.
Location: "${dbInfo.dbLocation}".
${import_chalk14.default.red("All data will be lost")}.`
        });
        console.info();
        if (!confirmation.value) {
          console.info("Drop cancelled.");
          process.exit(0);
        } else if (confirmation.value !== dbInfo.dbName) {
          throw Error(`The ${dbInfo.schemaWord} name entered "${confirmation.value}" doesn't match "${dbInfo.dbName}".`);
        }
      }
      if (await (0, import_sdk18.dropDatabase)(dbInfo.url, schemaDir)) {
        return `${process.platform === "win32" ? "" : "\u{1F680}  "}The ${dbInfo.dbType} ${dbInfo.schemaWord} "${dbInfo.dbName}" from "${dbInfo.dbLocation}" was successfully dropped.
`;
      } else {
        return "";
      }
    }
    help(error) {
      if (error) {
        return new import_sdk18.HelpError(`
${import_chalk14.default.bold.red(`!`)} ${error}
${_DbDrop.help}`);
      }
      return _DbDrop.help;
    }
  };
  var DbDrop2 = _DbDrop;
  DbDrop2.help = (0, import_sdk18.format)(`
${process.platform === "win32" ? "" : import_chalk14.default.bold("\u{1F4A3}  ")}Drop the database

${import_chalk14.default.bold.yellow("WARNING")} ${import_chalk14.default.bold(`Prisma db drop is currently in Preview (${(0, import_sdk18.link)("https://pris.ly/d/preview")}).
There may be bugs and it's not recommended to use it in production environments.`)}
${import_chalk14.default.dim("When using any of the subcommands below you need to explicitly opt-in via the --preview-feature flag.")}

${import_chalk14.default.bold("Usage")}

  ${import_chalk14.default.dim("$")} prisma db drop [options] --preview-feature

${import_chalk14.default.bold("Options")}

   -h, --help   Display this help message
     --schema   Custom path to your Prisma schema
  -f, --force   Skip the confirmation prompt

${import_chalk14.default.bold("Examples")}

  Drop the database
  ${import_chalk14.default.dim("$")} prisma db drop --preview-feature

  Specify a schema
  ${import_chalk14.default.dim("$")} prisma db drop --preview-feature --schema=./schema.prisma

  Use --force to skip the confirmation prompt
  ${import_chalk14.default.dim("$")} prisma db drop --preview-feature --force
`);
});

// ../migrate/dist/commands/DbSeed.js
var require_DbSeed = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    DbSeed: () => DbSeed3
  });
  var import_sdk18 = __toModule3(require_dist12());
  var import_path10 = __toModule3(require("path"));
  var import_chalk14 = __toModule3(require_source());
  var import_flagErrors = __toModule3(require_flagErrors());
  var import_errors2 = __toModule3(require_errors3());
  var import_seed = __toModule3(require_seed());
  var _DbSeed = class {
    static new() {
      return new _DbSeed();
    }
    async parse(argv) {
      const args2 = (0, import_sdk18.arg)(argv, {
        "--help": Boolean,
        "-h": "--help",
        "--preview-feature": Boolean,
        "--schema": String,
        "--telemetry-information": String
      }, false);
      if ((0, import_sdk18.isError)(args2)) {
        return this.help(args2.message);
      }
      if (args2["--help"]) {
        return this.help();
      }
      if (!args2["--preview-feature"]) {
        throw new import_flagErrors.PreviewFlagError();
      }
      const schemaPath = await (0, import_sdk18.getSchemaPath)(args2["--schema"]);
      if (!schemaPath) {
        throw new import_errors2.NoSchemaFoundError();
      }
      console.log(import_chalk14.default.dim(`Prisma schema loaded from ${import_path10.default.relative(process.cwd(), schemaPath)}`));
      await (0, import_seed.tryToRunSeed)(schemaPath);
      return `
${process.platform === "win32" ? "" : "\u{1F331}  "}Your database has been seeded.`;
    }
    help(error) {
      if (error) {
        return new import_sdk18.HelpError(`
${import_chalk14.default.bold.red(`!`)} ${error}
${_DbSeed.help}`);
      }
      return _DbSeed.help;
    }
  };
  var DbSeed3 = _DbSeed;
  DbSeed3.help = (0, import_sdk18.format)(`
${process.platform === "win32" ? "" : import_chalk14.default.bold("\u{1F64C}  ")}Seed your database

${import_chalk14.default.bold.yellow("WARNING")} ${import_chalk14.default.bold(`Prisma db seed is currently in Preview (${(0, import_sdk18.link)("https://pris.ly/d/preview")}).
There may be bugs and it's not recommended to use it in production environments.`)}
${import_chalk14.default.dim("When using any of the subcommands below you need to explicitly opt-in via the --preview-feature flag.")}

${import_chalk14.default.bold("Usage")}

  ${import_chalk14.default.dim("$")} prisma db seed [options] --preview-feature

${import_chalk14.default.bold("Options")}

    -h, --help   Display this help message
      --schema   Custom path to your Prisma schema

${import_chalk14.default.bold("Examples")}

  Specify a schema
  ${import_chalk14.default.dim("$")} prisma db seed --preview-feature --schema=./schema.prisma
`);
});

// ../../node_modules/.pnpm/is-docker@2.2.1/node_modules/is-docker/index.js
var require_is_docker = __commonJS((exports2, module2) => {
  "use strict";
  var fs9 = require("fs");
  var isDocker;
  function hasDockerEnv() {
    try {
      fs9.statSync("/.dockerenv");
      return true;
    } catch (_2) {
      return false;
    }
  }
  function hasDockerCGroup() {
    try {
      return fs9.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
    } catch (_2) {
      return false;
    }
  }
  module2.exports = () => {
    if (isDocker === void 0) {
      isDocker = hasDockerEnv() || hasDockerCGroup();
    }
    return isDocker;
  };
});

// ../../node_modules/.pnpm/is-wsl@2.2.0/node_modules/is-wsl/index.js
var require_is_wsl = __commonJS((exports2, module2) => {
  "use strict";
  var os3 = require("os");
  var fs9 = require("fs");
  var isDocker = require_is_docker();
  var isWsl = () => {
    if (process.platform !== "linux") {
      return false;
    }
    if (os3.release().toLowerCase().includes("microsoft")) {
      if (isDocker()) {
        return false;
      }
      return true;
    }
    try {
      return fs9.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !isDocker() : false;
    } catch (_2) {
      return false;
    }
  };
  if (process.env.__IS_WSL_TEST__) {
    module2.exports = isWsl;
  } else {
    module2.exports = isWsl();
  }
});

// ../../node_modules/.pnpm/open@7.4.2/node_modules/open/index.js
var require_open = __commonJS((exports2, module2) => {
  "use strict";
  var {promisify: promisify4} = require("util");
  var path10 = require("path");
  var childProcess = require("child_process");
  var fs9 = require("fs");
  var isWsl = require_is_wsl();
  var isDocker = require_is_docker();
  var pAccess = promisify4(fs9.access);
  var pReadFile = promisify4(fs9.readFile);
  var localXdgOpenPath = path10.join(__dirname, "xdg-open");
  var getWslDrivesMountPoint = (() => {
    const defaultMountPoint = "/mnt/";
    let mountPoint;
    return async function() {
      if (mountPoint) {
        return mountPoint;
      }
      const configFilePath = "/etc/wsl.conf";
      let isConfigFileExists = false;
      try {
        await pAccess(configFilePath, fs9.constants.F_OK);
        isConfigFileExists = true;
      } catch (_2) {
      }
      if (!isConfigFileExists) {
        return defaultMountPoint;
      }
      const configContent = await pReadFile(configFilePath, {encoding: "utf8"});
      const configMountPoint = /root\s*=\s*(.*)/g.exec(configContent);
      if (!configMountPoint) {
        return defaultMountPoint;
      }
      mountPoint = configMountPoint[1].trim();
      mountPoint = mountPoint.endsWith("/") ? mountPoint : mountPoint + "/";
      return mountPoint;
    };
  })();
  module2.exports = async (target, options) => {
    if (typeof target !== "string") {
      throw new TypeError("Expected a `target`");
    }
    options = {
      wait: false,
      background: false,
      allowNonzeroExitCode: false,
      ...options
    };
    let command;
    let {app} = options;
    let appArguments = [];
    const cliArguments = [];
    const childProcessOptions = {};
    if (Array.isArray(app)) {
      appArguments = app.slice(1);
      app = app[0];
    }
    if (process.platform === "darwin") {
      command = "open";
      if (options.wait) {
        cliArguments.push("--wait-apps");
      }
      if (options.background) {
        cliArguments.push("--background");
      }
      if (app) {
        cliArguments.push("-a", app);
      }
    } else if (process.platform === "win32" || isWsl && !isDocker()) {
      const mountPoint = await getWslDrivesMountPoint();
      command = isWsl ? `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe` : `${process.env.SYSTEMROOT}\\System32\\WindowsPowerShell\\v1.0\\powershell`;
      cliArguments.push("-NoProfile", "-NonInteractive", "\u2013ExecutionPolicy", "Bypass", "-EncodedCommand");
      if (!isWsl) {
        childProcessOptions.windowsVerbatimArguments = true;
      }
      const encodedArguments = ["Start"];
      if (options.wait) {
        encodedArguments.push("-Wait");
      }
      if (app) {
        encodedArguments.push(`"\`"${app}\`""`, "-ArgumentList");
        appArguments.unshift(target);
      } else {
        encodedArguments.push(`"${target}"`);
      }
      if (appArguments.length > 0) {
        appArguments = appArguments.map((arg10) => `"\`"${arg10}\`""`);
        encodedArguments.push(appArguments.join(","));
      }
      target = Buffer.from(encodedArguments.join(" "), "utf16le").toString("base64");
    } else {
      if (app) {
        command = app;
      } else {
        const isBundled = !__dirname || __dirname === "/";
        let exeLocalXdgOpen = false;
        try {
          await pAccess(localXdgOpenPath, fs9.constants.X_OK);
          exeLocalXdgOpen = true;
        } catch (_2) {
        }
        const useSystemXdgOpen = process.versions.electron || process.platform === "android" || isBundled || !exeLocalXdgOpen;
        command = useSystemXdgOpen ? "xdg-open" : localXdgOpenPath;
      }
      if (appArguments.length > 0) {
        cliArguments.push(...appArguments);
      }
      if (!options.wait) {
        childProcessOptions.stdio = "ignore";
        childProcessOptions.detached = true;
      }
    }
    cliArguments.push(target);
    if (process.platform === "darwin" && appArguments.length > 0) {
      cliArguments.push("--args", ...appArguments);
    }
    const subprocess = childProcess.spawn(command, cliArguments, childProcessOptions);
    if (options.wait) {
      return new Promise((resolve, reject) => {
        subprocess.once("error", reject);
        subprocess.once("close", (exitCode) => {
          if (options.allowNonzeroExitCode && exitCode > 0) {
            reject(new Error(`Exited with code ${exitCode}`));
            return;
          }
          resolve(subprocess);
        });
      });
    }
    subprocess.unref();
    return subprocess;
  };
});

// ../migrate/dist/utils/getGithubIssueUrl.js
var require_getGithubIssueUrl = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    getGithubIssueUrl: () => getGithubIssueUrl,
    wouldYouLikeToCreateANewIssue: () => wouldYouLikeToCreateANewIssue
  });
  var import_new_github_issue_url = __toModule3(require_new_github_issue_url());
  var import_open2 = __toModule3(require_open());
  var import_prompts = __toModule3(require_prompts3());
  var import_strip_ansi = __toModule3(require_strip_ansi());
  var import_get_platform3 = __toModule3(require_dist4());
  function getGithubIssueUrl({
    title,
    user = "prisma",
    repo = "prisma",
    template = "bug_report.md",
    body
  }) {
    return (0, import_new_github_issue_url.default)({
      user,
      repo,
      template,
      title,
      body
    });
  }
  async function wouldYouLikeToCreateANewIssue(options) {
    var _a;
    let shouldCreateNewIssue;
    if (options.prompt) {
      shouldCreateNewIssue = await (0, import_prompts.default)({
        type: "select",
        name: "value",
        message: "Would you like to create a Github issue?",
        initial: 0,
        choices: [
          {
            title: "Yes",
            value: true,
            description: `Create a new GitHub issue`
          },
          {
            title: "No",
            value: false,
            description: `Don't create a new GitHub issue`
          }
        ]
      });
    } else {
      shouldCreateNewIssue = {value: true};
    }
    if (shouldCreateNewIssue.value) {
      const platform = await (0, import_get_platform3.getPlatform)();
      const url = getGithubIssueUrl({
        title: (_a = options.title) != null ? _a : "",
        body: issueTemplate(platform, options)
      });
      await (0, import_open2.default)(url);
    }
  }
  var issueTemplate = (platform, options) => {
    return (0, import_strip_ansi.default)(`
Hi Prisma Team! Prisma Migrate just crashed. ${options.reportId ? `This is the report:
  Report Id: ${options.reportId}` : ""}

## Command

\`${options.command}\`

## Versions
      
| Name        | Version            |
|-------------|--------------------|
| Platform    | ${platform.padEnd(19)}| 
| Node        | ${process.version.padEnd(19)}| 
| Prisma CLI  | ${options.cliVersion.padEnd(19)}| 
| Binary      | ${options.binaryVersion.padEnd(19)}| 

## Error
\`\`\`
${options.error}
\`\`\`

`);
  };
});

// ../migrate/dist/utils/handlePanic.js
var require_handlePanic = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    handlePanic: () => handlePanic3
  });
  var import_chalk14 = __toModule3(require_source());
  var import_sdk18 = __toModule3(require_dist12());
  var import_prompts = __toModule3(require_prompts3());
  var import_getGithubIssueUrl = __toModule3(require_getGithubIssueUrl());
  async function handlePanic3(error, cliVersion, binaryVersion, command) {
    var _a;
    if ((0, import_sdk18.isCi)() && Boolean((_a = import_prompts.default._injected) == null ? void 0 : _a.length) === false) {
      throw error;
    }
    await panicDialog(error, cliVersion, binaryVersion, command);
  }
  async function panicDialog(error, cliVersion, binaryVersion, command) {
    const errorMessage = error.message.split("\n").slice(0, Math.max(20, process.stdout.rows)).join("\n");
    console.log(`${import_chalk14.default.red("Oops, an unexpected error occured!")}
${import_chalk14.default.red(errorMessage)}

${import_chalk14.default.bold("Please help us improve Prisma by submitting an error report.")}
${import_chalk14.default.bold("Error reports never contain personal or other sensitive information.")}
${import_chalk14.default.dim(`Learn more: ${(0, import_sdk18.link)("https://pris.ly/d/telemetry")}`)}
`);
    const response = await (0, import_prompts.default)({
      type: "select",
      name: "value",
      message: "Submit error report",
      initial: 0,
      choices: [
        {
          title: "Yes",
          value: true,
          description: `Send error report once`
        },
        {
          title: "No",
          value: false,
          description: `Don't send error report`
        }
      ]
    });
    const reportFailedMessage = `${import_chalk14.default.bold.red("Oops. We could not send the error report.")}`;
    if (response.value) {
      let reportId;
      try {
        console.log("Submitting...");
        reportId = await (0, import_sdk18.sendPanic)(error, cliVersion, binaryVersion);
      } catch (error2) {
        console.log(reportFailedMessage);
      }
      if (reportId) {
        console.log(`
${import_chalk14.default.bold(`We successfully received the error report id: ${reportId}`)}`);
        console.log(`
${import_chalk14.default.bold("Thanks a lot for your help! \u{1F64F}")}`);
      }
    }
    await (0, import_getGithubIssueUrl.wouldYouLikeToCreateANewIssue)({
      prompt: !response.value,
      error,
      cliVersion,
      binaryVersion,
      command
    });
  }
});

// ../migrate/dist/types.js
var require_types5 = __commonJS((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  __markAsModule3(exports2);
});

// ../migrate/dist/index.js
var require_dist15 = __commonJS((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    DbCommand: () => import_DbCommand.DbCommand,
    DbDrop: () => import_DbDrop.DbDrop,
    DbPull: () => import_DbPull.DbPull,
    DbPush: () => import_DbPush.DbPush,
    DbSeed: () => import_DbSeed.DbSeed,
    Migrate: () => import_Migrate.Migrate,
    MigrateCommand: () => import_MigrateCommand.MigrateCommand,
    MigrateDeploy: () => import_MigrateDeploy.MigrateDeploy,
    MigrateDev: () => import_MigrateDev.MigrateDev,
    MigrateEngine: () => import_MigrateEngine2.MigrateEngine,
    MigrateReset: () => import_MigrateReset.MigrateReset,
    MigrateResolve: () => import_MigrateResolve.MigrateResolve,
    MigrateStatus: () => import_MigrateStatus.MigrateStatus,
    byline: () => import_byline2.default,
    handlePanic: () => import_handlePanic.handlePanic
  });
  var import_Migrate = __toModule3(require_Migrate());
  var import_MigrateEngine2 = __toModule3(require_MigrateEngine());
  var import_MigrateCommand = __toModule3(require_MigrateCommand());
  var import_MigrateDev = __toModule3(require_MigrateDev());
  var import_MigrateResolve = __toModule3(require_MigrateResolve());
  var import_MigrateStatus = __toModule3(require_MigrateStatus());
  var import_MigrateReset = __toModule3(require_MigrateReset());
  var import_MigrateDeploy = __toModule3(require_MigrateDeploy());
  var import_DbCommand = __toModule3(require_DbCommand());
  var import_DbPull = __toModule3(require_DbPull());
  var import_DbPush = __toModule3(require_DbPush());
  var import_DbDrop = __toModule3(require_DbDrop());
  var import_DbSeed = __toModule3(require_DbSeed());
  var import_byline2 = __toModule3(require_byline4());
  var import_handlePanic = __toModule3(require_handlePanic());
  __reExport2(exports2, __toModule3(require_types5()));
});

// package.json
var require_package2 = __commonJS((exports2, module2) => {
  module2.exports = {
    version: "2.30.3",
    name: "prisma",
    description: "Prisma is an open-source database toolkit. It includes a JavaScript/TypeScript ORM for Node.js, migrations and a modern GUI to view and edit the data in your database. You can use Prisma in new projects or add it to an existing one.",
    keywords: [
      "orm",
      "prisma2",
      "prisma",
      "cli",
      "database",
      "sql",
      "postgresql",
      "mysql",
      "sqlite",
      "mariadb",
      "mssql",
      "typescript",
      "query-builder"
    ],
    main: "build/index.js",
    repository: "git@github.com:prisma/prisma.git",
    homepage: "https://www.prisma.io",
    author: "Tim Suchanek <suchanek@prisma.io>",
    maintainers: [
      "Tim Suchanek <suchanek@prisma.io>",
      "Jo\xEBl Galeran <galeran@prisma.io>",
      "William Luke <luke@prisma.io>"
    ],
    bugs: "https://github.com/prisma/prisma/issues",
    license: "Apache-2.0",
    engines: {
      node: ">=12.2"
    },
    prisma: {
      prismaCommit: "698ce54d3d5e6d4635263d5709bfcc7d32a146a5"
    },
    files: [
      "README.md",
      "build",
      "install",
      "runtime/*.js",
      "runtime/*.d.ts",
      "runtime/utils",
      "runtime/dist",
      "prisma-client",
      "preinstall",
      "scripts/preinstall-entry.js",
      "scripts/install-entry.js"
    ],
    pkg: {
      assets: [
        "build/**/*",
        "runtime/**/*",
        "prisma-client/**/*",
        "node_modules/@prisma/engines/**/*",
        "node_modules/@prisma/engines/*"
      ]
    },
    bin: {
      prisma: "build/index.js",
      prisma2: "build/index.js"
    },
    devDependencies: {
      "@prisma/client": "2.30.2",
      "@prisma/debug": "workspace:*",
      "@prisma/fetch-engine": "2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20",
      "@prisma/generator-helper": "workspace:*",
      "@prisma/get-platform": "2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20",
      "@prisma/migrate": "workspace:*",
      "@prisma/sdk": "2.30.2",
      "@prisma/studio-server": "0.423.0",
      "@timsuchanek/copy": "1.4.5",
      "@types/jest": "27.0.1",
      "@types/rimraf": "3.0.1",
      "@types/ws": "7.4.7",
      "@typescript-eslint/eslint-plugin": "4.29.2",
      "@typescript-eslint/parser": "4.29.2",
      chalk: "4.1.2",
      "checkpoint-client": "1.1.20",
      dotenv: "10.0.0",
      esbuild: "0.8.53",
      "escape-string-regexp": "4.0.0",
      eslint: "7.32.0",
      "eslint-config-prettier": "8.3.0",
      "eslint-plugin-eslint-comments": "3.2.0",
      "eslint-plugin-jest": "24.4.0",
      "eslint-plugin-prettier": "3.4.0",
      execa: "5.1.1",
      "fast-deep-equal": "3.1.3",
      "fs-jetpack": "4.1.1",
      "get-port": "5.1.1",
      "global-dirs": "3.0.0",
      "indent-string": "4.0.0",
      "is-installed-globally": "0.4.0",
      jest: "27.0.6",
      "line-replace": "2.0.1",
      "lint-staged": "11.1.2",
      "log-update": "4.0.0",
      "make-dir": "3.1.0",
      "node-fetch": "2.6.1",
      open: "7.4.2",
      pg: "8.7.1",
      "pkg-up": "3.1.0",
      prettier: "2.3.2",
      "replace-string": "3.1.0",
      "resolve-pkg": "2.0.0",
      rimraf: "3.0.2",
      "strip-ansi": "6.0.0",
      tempy: "1.0.1",
      "ts-jest": "27.0.5",
      typescript: "4.3.5"
    },
    scripts: {
      dev: "DEV=true node helpers/build.js",
      build: "node helpers/build.js",
      test: "jest --maxConcurrency=1 --verbose",
      install: "node scripts/install-entry.js",
      format: "prettier --write .",
      lint: "eslint --cache --fix --ext .ts .",
      "lint-ci": "eslint --ext .ts .",
      tsc: "tsc -d -p tsconfig.build.json && bash scripts/copy-runtime-dist.sh",
      prepublishOnly: "pnpm run build",
      preinstall: "node scripts/preinstall-entry.js",
      precommit: "lint-staged"
    },
    dependencies: {
      "@prisma/engines": "2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20"
    },
    "lint-staged": {
      "*.ts": [
        "eslint",
        "prettier --write"
      ]
    }
  };
});

// src/Generate.ts
var require_Generate = __commonJS((exports, module) => {
  __markAsModule2(exports);
  __export2(exports, {
    Generate: () => Generate
  });
  var import_engines6 = __toModule2(require("@prisma/engines"));
  var import_sdk18 = __toModule2(require_dist12());
  var import_chalk14 = __toModule2(require_source());
  var import_fs9 = __toModule2(require("fs"));
  var import_log_update2 = __toModule2(require_log_update());
  var import_path10 = __toModule2(require("path"));
  var import_resolve_pkg = __toModule2(require_resolve_pkg());
  var pkg = eval(`require('../package.json')`);
  var _Generate = class {
    constructor() {
      this.logText = "";
      this.hasGeneratorErrored = false;
      this.runGenerate = simpleDebounce(async ({generators}) => {
        var _a;
        const message = [];
        for (const generator of generators) {
          const toStr = generator.options.generator.output ? import_chalk14.default.dim(` to .${import_path10.default.sep}${import_path10.default.relative(process.cwd(), import_sdk18.parseEnvValue(generator.options.generator.output))}`) : "";
          const name = generator.manifest ? generator.manifest.prettyName : generator.options.generator.provider;
          const before = Date.now();
          try {
            await generator.generate();
            const after = Date.now();
            const version = (_a = generator.manifest) == null ? void 0 : _a.version;
            message.push(`\u2714 Generated ${import_chalk14.default.bold(name)}${version ? ` (${version})` : ""}${toStr} in ${formatms(after - before)}
`);
            generator.stop();
          } catch (err) {
            this.hasGeneratorErrored = true;
            generator.stop();
            if (err.message.includes("outputDir.endsWith is not a function")) {
              message.push(`This combination of Prisma CLI (>= 2.20) and Prisma Client (< 2.20) is not supported. Please update \`@prisma/client\` to ${pkg.version}   

`);
            } else {
              message.push(`${err.message}

`);
            }
          }
        }
        this.logText += message.join("\n");
      });
    }
    static new() {
      return new _Generate();
    }
    async parse(argv) {
      var _a, _b, _c, _d;
      const args2 = import_sdk18.arg(argv, {
        "--help": Boolean,
        "-h": "--help",
        "--watch": Boolean,
        "--schema": String,
        "--postinstall": String,
        "--telemetry-information": String
      });
      const isPostinstall = process.env.PRISMA_GENERATE_IN_POSTINSTALL;
      let cwd = process.cwd();
      if (isPostinstall && isPostinstall !== "true") {
        cwd = isPostinstall;
      }
      if (import_sdk18.isError(args2)) {
        return this.help(args2.message);
      }
      if (args2["--help"]) {
        return this.help();
      }
      const watchMode = args2["--watch"] || false;
      const schemaPath = await import_sdk18.getSchemaPath(args2["--schema"], {cwd});
      if (!schemaPath) {
        if (isPostinstall) {
          import_sdk18.logger.warn(`The postinstall script automatically ran \`prisma generate\` and did not find your \`prisma/schema.prisma\`.
If you have a Prisma schema file in a custom path, you will need to run
\`prisma generate --schema=./path/to/your/schema.prisma\` to generate Prisma Client.
If you do not have a Prisma schema file yet, you can ignore this message.`);
          return "";
        }
        throw new Error(`Could not find a ${import_chalk14.default.bold("schema.prisma")} file that is required for this command.
You can either provide it with ${import_chalk14.default.greenBright("--schema")}, set it as \`prisma.schema\` in your package.json or put it into the default location ${import_chalk14.default.greenBright("./prisma/schema.prisma")} https://pris.ly/d/prisma-schema-location`);
      }
      import_sdk18.logger.log(import_chalk14.default.dim(`Prisma schema loaded from ${import_path10.default.relative(process.cwd(), schemaPath)}`));
      let hasJsClient;
      let generators;
      let clientGeneratorVersion = null;
      try {
        generators = await import_sdk18.getGenerators({
          schemaPath,
          printDownloadProgress: !watchMode,
          version: import_engines6.enginesVersion,
          cliVersion: pkg.version
        });
        if (!generators || generators.length === 0) {
          this.logText += `${import_sdk18.missingGeneratorMessage}
`;
        } else {
          const jsClient = generators.find((g) => g.options && import_sdk18.parseEnvValue(g.options.generator.provider) === "prisma-client-js");
          clientGeneratorVersion = (_b = (_a = jsClient == null ? void 0 : jsClient.manifest) == null ? void 0 : _a.version) != null ? _b : null;
          hasJsClient = Boolean(jsClient);
          try {
            await this.runGenerate({generators});
          } catch (errRunGenerate) {
            this.logText += `${errRunGenerate.message}

`;
          }
        }
      } catch (errGetGenerators) {
        if (isPostinstall) {
          console.error(`${import_chalk14.default.blueBright("info")} The postinstall script automatically ran \`prisma generate\`, which failed.
The postinstall script still succeeds but won't generate the Prisma Client.
Please run \`${import_sdk18.getCommandWithExecutor("prisma generate")}\` to see the errors.`);
          return "";
        }
        if (watchMode) {
          this.logText += `${errGetGenerators.message}

`;
        } else {
          throw errGetGenerators;
        }
      }
      let printBreakingChangesMessage = false;
      if (hasJsClient) {
        try {
          const clientVersionBeforeGenerate = getCurrentClientVersion();
          if (clientVersionBeforeGenerate && typeof clientVersionBeforeGenerate === "string") {
            const minor = clientVersionBeforeGenerate.split(".")[1];
            if (parseInt(minor, 10) < 12) {
              printBreakingChangesMessage = true;
            }
          }
        } catch (e) {
        }
      }
      if (isPostinstall && printBreakingChangesMessage && import_sdk18.logger.should.warn) {
        return `There have been breaking changes in Prisma Client since you updated last time.
Please run \`prisma generate\` manually.`;
      }
      const watchingText = `
${import_chalk14.default.green("Watching...")} ${import_chalk14.default.dim(schemaPath)}
`;
      if (!watchMode) {
        const prismaClientJSGenerator = generators == null ? void 0 : generators.find((g) => {
          var _a2, _b2;
          return ((_a2 = g.options) == null ? void 0 : _a2.generator.provider) && import_sdk18.parseEnvValue((_b2 = g.options) == null ? void 0 : _b2.generator.provider) === "prisma-client-js";
        });
        let hint = "";
        if (prismaClientJSGenerator) {
          const importPath = ((_d = (_c = prismaClientJSGenerator.options) == null ? void 0 : _c.generator) == null ? void 0 : _d.isCustomOutput) ? prefixRelativePathIfNecessary(import_path10.default.relative(process.cwd(), import_sdk18.parseEnvValue(prismaClientJSGenerator.options.generator.output))) : "@prisma/client";
          const breakingChangesStr = printBreakingChangesMessage ? `

${breakingChangesMessage}` : "";
          const versionsOutOfSync = clientGeneratorVersion && pkg.version !== clientGeneratorVersion;
          const versionsWarning = versionsOutOfSync && import_sdk18.logger.should.warn ? `

${import_chalk14.default.yellow.bold("warn")} Versions of ${import_chalk14.default.bold(`prisma@${pkg.version}`)} and ${import_chalk14.default.bold(`@prisma/client@${clientGeneratorVersion}`)} don't match.
This might lead to unexpected behavior.
Please make sure they have the same version.` : "";
          hint = `You can now start using Prisma Client in your code. Reference: ${import_sdk18.link("https://pris.ly/d/client")}
${import_chalk14.default.dim("```")}
${import_sdk18.highlightTS(`import { PrismaClient } from '${importPath}'
const prisma = new PrismaClient()`)}
${import_chalk14.default.dim("```")}${breakingChangesStr}${versionsWarning}`;
        }
        const message = "\n" + this.logText + (hasJsClient && !this.hasGeneratorErrored ? hint : "");
        if (this.hasGeneratorErrored) {
          if (isPostinstall) {
            import_sdk18.logger.info(`The postinstall script automatically ran \`prisma generate\`, which failed.
The postinstall script still succeeds but won't generate the Prisma Client.
Please run \`${import_sdk18.getCommandWithExecutor("prisma generate")}\` to see the errors.`);
            return "";
          }
          throw new Error(message);
        } else {
          return message;
        }
      } else {
        import_log_update2.default(watchingText + "\n" + this.logText);
        import_fs9.default.watch(schemaPath, async (eventType) => {
          if (eventType === "change") {
            let generatorsWatch;
            try {
              generatorsWatch = await import_sdk18.getGenerators({
                schemaPath,
                printDownloadProgress: !watchMode,
                version: import_engines6.enginesVersion,
                cliVersion: pkg.version
              });
              if (!generatorsWatch || generatorsWatch.length === 0) {
                this.logText += `${import_sdk18.missingGeneratorMessage}
`;
              } else {
                import_log_update2.default(`
${import_chalk14.default.green("Building...")}

${this.logText}`);
                try {
                  await this.runGenerate({
                    generators: generatorsWatch
                  });
                  import_log_update2.default(watchingText + "\n" + this.logText);
                } catch (errRunGenerate) {
                  this.logText += `${errRunGenerate.message}

`;
                  import_log_update2.default(watchingText + "\n" + this.logText);
                }
              }
            } catch (errGetGenerators) {
              this.logText += `${errGetGenerators.message}

`;
              import_log_update2.default(watchingText + "\n" + this.logText);
            }
          }
        });
        await new Promise((_2) => null);
      }
      return "";
    }
    help(error) {
      if (error) {
        return new import_sdk18.HelpError(`
${import_chalk14.default.bold.red(`!`)} ${error}
${_Generate.help}`);
      }
      return _Generate.help;
    }
  };
  var Generate = _Generate;
  Generate.help = import_sdk18.format(`
Generate artifacts (e.g. Prisma Client)

${import_chalk14.default.bold("Usage")}

  ${import_chalk14.default.dim("$")} prisma generate [options]

${import_chalk14.default.bold("Options")}

  -h, --help   Display this help message
    --schema   Custom path to your Prisma schema
     --watch   Watch the Prisma schema and rerun after a change

${import_chalk14.default.bold("Examples")}

  With an existing Prisma schema
    ${import_chalk14.default.dim("$")} prisma generate

  Or specify a schema
    ${import_chalk14.default.dim("$")} prisma generate --schema=./schema.prisma

  Watch Prisma schema file and rerun after each change
    ${import_chalk14.default.dim("$")} prisma generate --watch

`);
  function prefixRelativePathIfNecessary(relativePath) {
    if (relativePath.startsWith("..")) {
      return relativePath;
    }
    return `./${relativePath}`;
  }
  function getCurrentClientVersion() {
    var _a, _b, _c, _d;
    try {
      let pkgPath = import_resolve_pkg.default(".prisma/client", {cwd: process.cwd()});
      if (!pkgPath) {
        const potentialPkgPath = import_path10.default.join(process.cwd(), "node_modules/.prisma/client");
        if (import_fs9.default.existsSync(potentialPkgPath)) {
          pkgPath = potentialPkgPath;
        }
      }
      if (pkgPath) {
        const indexPath = import_path10.default.join(pkgPath, "index.js");
        if (import_fs9.default.existsSync(indexPath)) {
          const program = require(indexPath);
          return (_d = (_a = program == null ? void 0 : program.prismaVersion) == null ? void 0 : _a.client) != null ? _d : (_c = (_b = program == null ? void 0 : program.Prisma) == null ? void 0 : _b.prismaVersion) == null ? void 0 : _c.client;
        }
      }
    } catch (e) {
      return null;
    }
    return null;
  }
});

// ../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function equal2(a, b) {
    if (a === b)
      return true;
    if (a && b && typeof a == "object" && typeof b == "object") {
      if (a.constructor !== b.constructor)
        return false;
      var length, i, keys;
      if (Array.isArray(a)) {
        length = a.length;
        if (length != b.length)
          return false;
        for (i = length; i-- !== 0; )
          if (!equal2(a[i], b[i]))
            return false;
        return true;
      }
      if (a.constructor === RegExp)
        return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf)
        return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString)
        return a.toString() === b.toString();
      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length)
        return false;
      for (i = length; i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
          return false;
      for (i = length; i-- !== 0; ) {
        var key = keys[i];
        if (!equal2(a[key], b[key]))
          return false;
      }
      return true;
    }
    return a !== a && b !== b;
  };
});

// ../../node_modules/.pnpm/tslib@1.14.1/node_modules/tslib/tslib.js
var require_tslib = __commonJS((exports2, module2) => {
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar2;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault2;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __createBinding;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports3) {
        factory(createExporter(root, createExporter(exports3)));
      });
    } else if (typeof module2 === "object" && typeof module2.exports === "object") {
      factory(createExporter(root, createExporter(module2.exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports3, previous) {
      if (exports3 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports3, "__esModule", {value: true});
        } else {
          exports3.__esModule = true;
        }
      }
      return function(id, v) {
        return exports3[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b) {
      d2.__proto__ = b;
    } || function(d2, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d2[p] = b[p];
    };
    __extends = function(d2, b) {
      extendStatics(d2, b);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    __assign = Object.assign || function(t) {
      for (var s2, i = 1, n = arguments.length; i < n; i++) {
        s2 = arguments[i];
        for (var p in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p))
            t[p] = s2[p];
      }
      return t;
    };
    __rest = function(s2, e) {
      var t = {};
      for (var p in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0)
          t[p] = s2[p];
      if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s2); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]))
            t[p[i]] = s2[p[i]];
        }
      return t;
    };
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d2 = decorators[i])
            r = (c < 3 ? d2(r) : c > 3 ? d2(target, key, r) : d2(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _2 = {label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: []}, f, y2, t, g;
      return g = {next: verb(0), throw: verb(1), return: verb(2)}, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_2)
          try {
            if (f = 1, y2 && (t = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t = y2["return"]) && t.call(y2), 0) : y2.next) && !(t = t.call(y2, op[1])).done)
              return t;
            if (y2 = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _2.label++;
                return {value: op[1], done: false};
              case 5:
                _2.label++;
                y2 = op[1];
                op = [0];
                continue;
              case 7:
                op = _2.ops.pop();
                _2.trys.pop();
                continue;
              default:
                if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _2 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _2.label = op[1];
                  break;
                }
                if (op[0] === 6 && _2.label < t[1]) {
                  _2.label = t[1];
                  t = op;
                  break;
                }
                if (t && _2.label < t[2]) {
                  _2.label = t[2];
                  _2.ops.push(op);
                  break;
                }
                if (t[2])
                  _2.ops.pop();
                _2.trys.pop();
                continue;
            }
            op = body.call(thisArg, _2);
          } catch (e) {
            op = [6, e];
            y2 = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {value: op[0] ? op[1] : void 0, done: true};
      }
    };
    __createBinding = function(o, m2, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m2[k];
    };
    __exportStar2 = function(m2, exports3) {
      for (var p in m2)
        if (p !== "default" && !exports3.hasOwnProperty(p))
          exports3[p] = m2[p];
    };
    __values = function(o) {
      var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o[s2], i = 0;
      if (m2)
        return m2.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return {value: o && o[i++], done: !o};
          }
        };
      throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m2 = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m2)
        return o;
      var i = m2.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = {error};
      } finally {
        try {
          if (r && !r.done && (m2 = i["return"]))
            m2.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s2 = 0, i = 0, il = arguments.length; i < il; i++)
        s2 += arguments[i].length;
      for (var r = Array(s2), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function verb(n) {
        if (g[n])
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? {value: __await(o[n](v)), done: n === "return"} : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m2 = o[Symbol.asyncIterator], i;
      return m2 ? m2.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d2, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({value: v2, done: d2});
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", {value: raw});
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (Object.hasOwnProperty.call(mod, k))
            result[k] = mod[k];
      }
      result["default"] = mod;
      return result;
    };
    __importDefault2 = function(mod) {
      return mod && mod.__esModule ? mod : {default: mod};
    };
    __classPrivateFieldGet = function(receiver, privateMap) {
      if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
      }
      return privateMap.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, privateMap, value) {
      if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
      }
      privateMap.set(receiver, value);
      return value;
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar2);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault2);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
  });
});

// ../../node_modules/.pnpm/@sentry+types@6.2.5/node_modules/@sentry/types/dist/loglevel.js
var require_loglevel = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var LogLevel;
  (function(LogLevel2) {
    LogLevel2[LogLevel2["None"] = 0] = "None";
    LogLevel2[LogLevel2["Error"] = 1] = "Error";
    LogLevel2[LogLevel2["Debug"] = 2] = "Debug";
    LogLevel2[LogLevel2["Verbose"] = 3] = "Verbose";
  })(LogLevel = exports2.LogLevel || (exports2.LogLevel = {}));
});

// ../../node_modules/.pnpm/@sentry+types@6.2.5/node_modules/@sentry/types/dist/session.js
var require_session = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var SessionStatus;
  (function(SessionStatus2) {
    SessionStatus2["Ok"] = "ok";
    SessionStatus2["Exited"] = "exited";
    SessionStatus2["Crashed"] = "crashed";
    SessionStatus2["Abnormal"] = "abnormal";
  })(SessionStatus = exports2.SessionStatus || (exports2.SessionStatus = {}));
});

// ../../node_modules/.pnpm/@sentry+types@6.2.5/node_modules/@sentry/types/dist/severity.js
var require_severity = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var Severity;
  (function(Severity2) {
    Severity2["Fatal"] = "fatal";
    Severity2["Error"] = "error";
    Severity2["Warning"] = "warning";
    Severity2["Log"] = "log";
    Severity2["Info"] = "info";
    Severity2["Debug"] = "debug";
    Severity2["Critical"] = "critical";
  })(Severity = exports2.Severity || (exports2.Severity = {}));
  (function(Severity2) {
    function fromString(level) {
      switch (level) {
        case "debug":
          return Severity2.Debug;
        case "info":
          return Severity2.Info;
        case "warn":
        case "warning":
          return Severity2.Warning;
        case "error":
          return Severity2.Error;
        case "fatal":
          return Severity2.Fatal;
        case "critical":
          return Severity2.Critical;
        case "log":
        default:
          return Severity2.Log;
      }
    }
    Severity2.fromString = fromString;
  })(Severity = exports2.Severity || (exports2.Severity = {}));
});

// ../../node_modules/.pnpm/@sentry+types@6.2.5/node_modules/@sentry/types/dist/status.js
var require_status = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var Status;
  (function(Status2) {
    Status2["Unknown"] = "unknown";
    Status2["Skipped"] = "skipped";
    Status2["Success"] = "success";
    Status2["RateLimit"] = "rate_limit";
    Status2["Invalid"] = "invalid";
    Status2["Failed"] = "failed";
  })(Status = exports2.Status || (exports2.Status = {}));
  (function(Status2) {
    function fromHttpCode(code) {
      if (code >= 200 && code < 300) {
        return Status2.Success;
      }
      if (code === 429) {
        return Status2.RateLimit;
      }
      if (code >= 400 && code < 500) {
        return Status2.Invalid;
      }
      if (code >= 500) {
        return Status2.Failed;
      }
      return Status2.Unknown;
    }
    Status2.fromHttpCode = fromHttpCode;
  })(Status = exports2.Status || (exports2.Status = {}));
});

// ../../node_modules/.pnpm/@sentry+types@6.2.5/node_modules/@sentry/types/dist/transaction.js
var require_transaction = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var TransactionSamplingMethod;
  (function(TransactionSamplingMethod2) {
    TransactionSamplingMethod2["Explicit"] = "explicitly_set";
    TransactionSamplingMethod2["Sampler"] = "client_sampler";
    TransactionSamplingMethod2["Rate"] = "client_rate";
    TransactionSamplingMethod2["Inheritance"] = "inheritance";
  })(TransactionSamplingMethod = exports2.TransactionSamplingMethod || (exports2.TransactionSamplingMethod = {}));
});

// ../../node_modules/.pnpm/@sentry+types@6.2.5/node_modules/@sentry/types/dist/index.js
var require_dist16 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var loglevel_1 = require_loglevel();
  exports2.LogLevel = loglevel_1.LogLevel;
  var session_1 = require_session();
  exports2.SessionStatus = session_1.SessionStatus;
  var severity_1 = require_severity();
  exports2.Severity = severity_1.Severity;
  var status_1 = require_status();
  exports2.Status = status_1.Status;
  var transaction_1 = require_transaction();
  exports2.TransactionSamplingMethod = transaction_1.TransactionSamplingMethod;
});

// ../../node_modules/.pnpm/@sentry+utils@6.2.5/node_modules/@sentry/utils/dist/async.js
var require_async8 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  function forget(promise) {
    promise.then(null, function(e) {
      console.error(e);
    });
  }
  exports2.forget = forget;
});

// ../../node_modules/.pnpm/@sentry+utils@6.2.5/node_modules/@sentry/utils/dist/is.js
var require_is = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  function isError7(wat) {
    switch (Object.prototype.toString.call(wat)) {
      case "[object Error]":
        return true;
      case "[object Exception]":
        return true;
      case "[object DOMException]":
        return true;
      default:
        return isInstanceOf(wat, Error);
    }
  }
  exports2.isError = isError7;
  function isErrorEvent(wat) {
    return Object.prototype.toString.call(wat) === "[object ErrorEvent]";
  }
  exports2.isErrorEvent = isErrorEvent;
  function isDOMError(wat) {
    return Object.prototype.toString.call(wat) === "[object DOMError]";
  }
  exports2.isDOMError = isDOMError;
  function isDOMException(wat) {
    return Object.prototype.toString.call(wat) === "[object DOMException]";
  }
  exports2.isDOMException = isDOMException;
  function isString(wat) {
    return Object.prototype.toString.call(wat) === "[object String]";
  }
  exports2.isString = isString;
  function isPrimitive(wat) {
    return wat === null || typeof wat !== "object" && typeof wat !== "function";
  }
  exports2.isPrimitive = isPrimitive;
  function isPlainObject(wat) {
    return Object.prototype.toString.call(wat) === "[object Object]";
  }
  exports2.isPlainObject = isPlainObject;
  function isEvent(wat) {
    return typeof Event !== "undefined" && isInstanceOf(wat, Event);
  }
  exports2.isEvent = isEvent;
  function isElement(wat) {
    return typeof Element !== "undefined" && isInstanceOf(wat, Element);
  }
  exports2.isElement = isElement;
  function isRegExp(wat) {
    return Object.prototype.toString.call(wat) === "[object RegExp]";
  }
  exports2.isRegExp = isRegExp;
  function isThenable(wat) {
    return Boolean(wat && wat.then && typeof wat.then === "function");
  }
  exports2.isThenable = isThenable;
  function isSyntheticEvent(wat) {
    return isPlainObject(wat) && "nativeEvent" in wat && "preventDefault" in wat && "stopPropagation" in wat;
  }
  exports2.isSyntheticEvent = isSyntheticEvent;
  function isInstanceOf(wat, base) {
    try {
      return wat instanceof base;
    } catch (_e) {
      return false;
    }
  }
  exports2.isInstanceOf = isInstanceOf;
});

// ../../node_modules/.pnpm/@sentry+utils@6.2.5/node_modules/@sentry/utils/dist/browser.js
var require_browser2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var is_1 = require_is();
  function htmlTreeAsString(elem) {
    try {
      var currentElem = elem;
      var MAX_TRAVERSE_HEIGHT = 5;
      var MAX_OUTPUT_LEN = 80;
      var out = [];
      var height = 0;
      var len = 0;
      var separator = " > ";
      var sepLength = separator.length;
      var nextStr = void 0;
      while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {
        nextStr = _htmlElementAsString(currentElem);
        if (nextStr === "html" || height > 1 && len + out.length * sepLength + nextStr.length >= MAX_OUTPUT_LEN) {
          break;
        }
        out.push(nextStr);
        len += nextStr.length;
        currentElem = currentElem.parentNode;
      }
      return out.reverse().join(separator);
    } catch (_oO) {
      return "<unknown>";
    }
  }
  exports2.htmlTreeAsString = htmlTreeAsString;
  function _htmlElementAsString(el) {
    var elem = el;
    var out = [];
    var className;
    var classes;
    var key;
    var attr;
    var i;
    if (!elem || !elem.tagName) {
      return "";
    }
    out.push(elem.tagName.toLowerCase());
    if (elem.id) {
      out.push("#" + elem.id);
    }
    className = elem.className;
    if (className && is_1.isString(className)) {
      classes = className.split(/\s+/);
      for (i = 0; i < classes.length; i++) {
        out.push("." + classes[i]);
      }
    }
    var allowedAttrs = ["type", "name", "title", "alt"];
    for (i = 0; i < allowedAttrs.length; i++) {
      key = allowedAttrs[i];
      attr = elem.getAttribute(key);
      if (attr) {
        out.push("[" + key + '="' + attr + '"]');
      }
    }
    return out.join("");
  }
});

// ../../node_modules/.pnpm/@sentry+utils@6.2.5/node_modules/@sentry/utils/dist/polyfill.js
var require_polyfill = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.setPrototypeOf = Object.setPrototypeOf || ({__proto__: []} instanceof Array ? setProtoOf : mixinProperties);
  function setProtoOf(obj, proto) {
    obj.__proto__ = proto;
    return obj;
  }
  function mixinProperties(obj, proto) {
    for (var prop in proto) {
      if (!obj.hasOwnProperty(prop)) {
        obj[prop] = proto[prop];
      }
    }
    return obj;
  }
});

// ../../node_modules/.pnpm/@sentry+utils@6.2.5/node_modules/@sentry/utils/dist/error.js
var require_error4 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib_1 = require_tslib();
  var polyfill_1 = require_polyfill();
  var SentryError = function(_super) {
    tslib_1.__extends(SentryError2, _super);
    function SentryError2(message) {
      var _newTarget = this.constructor;
      var _this = _super.call(this, message) || this;
      _this.message = message;
      _this.name = _newTarget.prototype.constructor.name;
      polyfill_1.setPrototypeOf(_this, _newTarget.prototype);
      return _this;
    }
    return SentryError2;
  }(Error);
  exports2.SentryError = SentryError;
});

// ../../node_modules/.pnpm/@sentry+utils@6.2.5/node_modules/@sentry/utils/dist/dsn.js
var require_dsn = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib_1 = require_tslib();
  var error_1 = require_error4();
  var DSN_REGEX = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+))?@)([\w.-]+)(?::(\d+))?\/(.+)/;
  var ERROR_MESSAGE = "Invalid Dsn";
  var Dsn = function() {
    function Dsn2(from) {
      if (typeof from === "string") {
        this._fromString(from);
      } else {
        this._fromComponents(from);
      }
      this._validate();
    }
    Dsn2.prototype.toString = function(withPassword) {
      if (withPassword === void 0) {
        withPassword = false;
      }
      var _a = this, host = _a.host, path10 = _a.path, pass = _a.pass, port = _a.port, projectId = _a.projectId, protocol = _a.protocol, publicKey = _a.publicKey;
      return protocol + "://" + publicKey + (withPassword && pass ? ":" + pass : "") + ("@" + host + (port ? ":" + port : "") + "/" + (path10 ? path10 + "/" : path10) + projectId);
    };
    Dsn2.prototype._fromString = function(str) {
      var match = DSN_REGEX.exec(str);
      if (!match) {
        throw new error_1.SentryError(ERROR_MESSAGE);
      }
      var _a = tslib_1.__read(match.slice(1), 6), protocol = _a[0], publicKey = _a[1], _b = _a[2], pass = _b === void 0 ? "" : _b, host = _a[3], _c = _a[4], port = _c === void 0 ? "" : _c, lastPath = _a[5];
      var path10 = "";
      var projectId = lastPath;
      var split = projectId.split("/");
      if (split.length > 1) {
        path10 = split.slice(0, -1).join("/");
        projectId = split.pop();
      }
      if (projectId) {
        var projectMatch = projectId.match(/^\d+/);
        if (projectMatch) {
          projectId = projectMatch[0];
        }
      }
      this._fromComponents({host, pass, path: path10, projectId, port, protocol, publicKey});
    };
    Dsn2.prototype._fromComponents = function(components) {
      if ("user" in components && !("publicKey" in components)) {
        components.publicKey = components.user;
      }
      this.user = components.publicKey || "";
      this.protocol = components.protocol;
      this.publicKey = components.publicKey || "";
      this.pass = components.pass || "";
      this.host = components.host;
      this.port = components.port || "";
      this.path = components.path || "";
      this.projectId = components.projectId;
    };
    Dsn2.prototype._validate = function() {
      var _this = this;
      ["protocol", "publicKey", "host", "projectId"].forEach(function(component) {
        if (!_this[component]) {
          throw new error_1.SentryError(ERROR_MESSAGE + ": " + component + " missing");
        }
      });
      if (!this.projectId.match(/^\d+$/)) {
        throw new error_1.SentryError(ERROR_MESSAGE + ": Invalid projectId " + this.projectId);
      }
      if (this.protocol !== "http" && this.protocol !== "https") {
        throw new error_1.SentryError(ERROR_MESSAGE + ": Invalid protocol " + this.protocol);
      }
      if (this.port && isNaN(parseInt(this.port, 10))) {
        throw new error_1.SentryError(ERROR_MESSAGE + ": Invalid port " + this.port);
      }
    };
    return Dsn2;
  }();
  exports2.Dsn = Dsn;
});

// ../../node_modules/.pnpm/@sentry+utils@6.2.5/node_modules/@sentry/utils/dist/node.js
var require_node6 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  function isNodeEnv() {
    return Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
  }
  exports2.isNodeEnv = isNodeEnv;
  function dynamicRequire(mod, request) {
    return mod.require(request);
  }
  exports2.dynamicRequire = dynamicRequire;
});

// ../../node_modules/.pnpm/@sentry+utils@6.2.5/node_modules/@sentry/utils/dist/string.js
var require_string2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var is_1 = require_is();
  function truncate(str, max) {
    if (max === void 0) {
      max = 0;
    }
    if (typeof str !== "string" || max === 0) {
      return str;
    }
    return str.length <= max ? str : str.substr(0, max) + "...";
  }
  exports2.truncate = truncate;
  function snipLine(line, colno) {
    var newLine = line;
    var ll = newLine.length;
    if (ll <= 150) {
      return newLine;
    }
    if (colno > ll) {
      colno = ll;
    }
    var start = Math.max(colno - 60, 0);
    if (start < 5) {
      start = 0;
    }
    var end = Math.min(start + 140, ll);
    if (end > ll - 5) {
      end = ll;
    }
    if (end === ll) {
      start = Math.max(end - 140, 0);
    }
    newLine = newLine.slice(start, end);
    if (start > 0) {
      newLine = "'{snip} " + newLine;
    }
    if (end < ll) {
      newLine += " {snip}";
    }
    return newLine;
  }
  exports2.snipLine = snipLine;
  function safeJoin(input, delimiter) {
    if (!Array.isArray(input)) {
      return "";
    }
    var output = [];
    for (var i = 0; i < input.length; i++) {
      var value = input[i];
      try {
        output.push(String(value));
      } catch (e) {
        output.push("[value cannot be serialized]");
      }
    }
    return output.join(delimiter);
  }
  exports2.safeJoin = safeJoin;
  function isMatchingPattern(value, pattern) {
    if (!is_1.isString(value)) {
      return false;
    }
    if (is_1.isRegExp(pattern)) {
      return pattern.test(value);
    }
    if (typeof pattern === "string") {
      return value.indexOf(pattern) !== -1;
    }
    return false;
  }
  exports2.isMatchingPattern = isMatchingPattern;
});

// ../../node_modules/.pnpm/@sentry+utils@6.2.5/node_modules/@sentry/utils/dist/misc.js
var require_misc = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var node_1 = require_node6();
  var string_1 = require_string2();
  var fallbackGlobalObject = {};
  function getGlobalObject() {
    return node_1.isNodeEnv() ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : fallbackGlobalObject;
  }
  exports2.getGlobalObject = getGlobalObject;
  function uuid4() {
    var global2 = getGlobalObject();
    var crypto2 = global2.crypto || global2.msCrypto;
    if (!(crypto2 === void 0) && crypto2.getRandomValues) {
      var arr = new Uint16Array(8);
      crypto2.getRandomValues(arr);
      arr[3] = arr[3] & 4095 | 16384;
      arr[4] = arr[4] & 16383 | 32768;
      var pad = function(num) {
        var v = num.toString(16);
        while (v.length < 4) {
          v = "0" + v;
        }
        return v;
      };
      return pad(arr[0]) + pad(arr[1]) + pad(arr[2]) + pad(arr[3]) + pad(arr[4]) + pad(arr[5]) + pad(arr[6]) + pad(arr[7]);
    }
    return "xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx".replace(/[xy]/g, function(c) {
      var r = Math.random() * 16 | 0;
      var v = c === "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  }
  exports2.uuid4 = uuid4;
  function parseUrl(url) {
    if (!url) {
      return {};
    }
    var match = url.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
    if (!match) {
      return {};
    }
    var query = match[6] || "";
    var fragment = match[8] || "";
    return {
      host: match[4],
      path: match[5],
      protocol: match[2],
      relative: match[5] + query + fragment
    };
  }
  exports2.parseUrl = parseUrl;
  function getEventDescription(event) {
    if (event.message) {
      return event.message;
    }
    if (event.exception && event.exception.values && event.exception.values[0]) {
      var exception = event.exception.values[0];
      if (exception.type && exception.value) {
        return exception.type + ": " + exception.value;
      }
      return exception.type || exception.value || event.event_id || "<unknown>";
    }
    return event.event_id || "<unknown>";
  }
  exports2.getEventDescription = getEventDescription;
  function consoleSandbox(callback) {
    var global2 = getGlobalObject();
    var levels = ["debug", "info", "warn", "error", "log", "assert"];
    if (!("console" in global2)) {
      return callback();
    }
    var originalConsole = global2.console;
    var wrappedLevels = {};
    levels.forEach(function(level) {
      if (level in global2.console && originalConsole[level].__sentry_original__) {
        wrappedLevels[level] = originalConsole[level];
        originalConsole[level] = originalConsole[level].__sentry_original__;
      }
    });
    var result = callback();
    Object.keys(wrappedLevels).forEach(function(level) {
      originalConsole[level] = wrappedLevels[level];
    });
    return result;
  }
  exports2.consoleSandbox = consoleSandbox;
  function addExceptionTypeValue(event, value, type) {
    event.exception = event.exception || {};
    event.exception.values = event.exception.values || [];
    event.exception.values[0] = event.exception.values[0] || {};
    event.exception.values[0].value = event.exception.values[0].value || value || "";
    event.exception.values[0].type = event.exception.values[0].type || type || "Error";
  }
  exports2.addExceptionTypeValue = addExceptionTypeValue;
  function addExceptionMechanism(event, mechanism) {
    if (mechanism === void 0) {
      mechanism = {};
    }
    try {
      event.exception.values[0].mechanism = event.exception.values[0].mechanism || {};
      Object.keys(mechanism).forEach(function(key) {
        event.exception.values[0].mechanism[key] = mechanism[key];
      });
    } catch (_oO) {
    }
  }
  exports2.addExceptionMechanism = addExceptionMechanism;
  function getLocationHref() {
    try {
      return document.location.href;
    } catch (oO) {
      return "";
    }
  }
  exports2.getLocationHref = getLocationHref;
  var SEMVER_REGEXP = /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
  function parseSemver(input) {
    var match = input.match(SEMVER_REGEXP) || [];
    var major = parseInt(match[1], 10);
    var minor = parseInt(match[2], 10);
    var patch = parseInt(match[3], 10);
    return {
      buildmetadata: match[5],
      major: isNaN(major) ? void 0 : major,
      minor: isNaN(minor) ? void 0 : minor,
      patch: isNaN(patch) ? void 0 : patch,
      prerelease: match[4]
    };
  }
  exports2.parseSemver = parseSemver;
  var defaultRetryAfter = 60 * 1e3;
  function parseRetryAfterHeader(now, header) {
    if (!header) {
      return defaultRetryAfter;
    }
    var headerDelay = parseInt("" + header, 10);
    if (!isNaN(headerDelay)) {
      return headerDelay * 1e3;
    }
    var headerDate = Date.parse("" + header);
    if (!isNaN(headerDate)) {
      return headerDate - now;
    }
    return defaultRetryAfter;
  }
  exports2.parseRetryAfterHeader = parseRetryAfterHeader;
  function addContextToFrame(lines, frame, linesOfContext) {
    if (linesOfContext === void 0) {
      linesOfContext = 5;
    }
    var lineno = frame.lineno || 0;
    var maxLines = lines.length;
    var sourceLine = Math.max(Math.min(maxLines, lineno - 1), 0);
    frame.pre_context = lines.slice(Math.max(0, sourceLine - linesOfContext), sourceLine).map(function(line) {
      return string_1.snipLine(line, 0);
    });
    frame.context_line = string_1.snipLine(lines[Math.min(maxLines - 1, sourceLine)], frame.colno || 0);
    frame.post_context = lines.slice(Math.min(sourceLine + 1, maxLines), sourceLine + 1 + linesOfContext).map(function(line) {
      return string_1.snipLine(line, 0);
    });
  }
  exports2.addContextToFrame = addContextToFrame;
  function stripUrlQueryAndFragment(urlPath) {
    return urlPath.split(/[\?#]/, 1)[0];
  }
  exports2.stripUrlQueryAndFragment = stripUrlQueryAndFragment;
});

// ../../node_modules/.pnpm/@sentry+utils@6.2.5/node_modules/@sentry/utils/dist/logger.js
var require_logger2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var misc_1 = require_misc();
  var global2 = misc_1.getGlobalObject();
  var PREFIX = "Sentry Logger ";
  var Logger = function() {
    function Logger2() {
      this._enabled = false;
    }
    Logger2.prototype.disable = function() {
      this._enabled = false;
    };
    Logger2.prototype.enable = function() {
      this._enabled = true;
    };
    Logger2.prototype.log = function() {
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      if (!this._enabled) {
        return;
      }
      misc_1.consoleSandbox(function() {
        global2.console.log(PREFIX + "[Log]: " + args2.join(" "));
      });
    };
    Logger2.prototype.warn = function() {
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      if (!this._enabled) {
        return;
      }
      misc_1.consoleSandbox(function() {
        global2.console.warn(PREFIX + "[Warn]: " + args2.join(" "));
      });
    };
    Logger2.prototype.error = function() {
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      if (!this._enabled) {
        return;
      }
      misc_1.consoleSandbox(function() {
        global2.console.error(PREFIX + "[Error]: " + args2.join(" "));
      });
    };
    return Logger2;
  }();
  global2.__SENTRY__ = global2.__SENTRY__ || {};
  var logger5 = global2.__SENTRY__.logger || (global2.__SENTRY__.logger = new Logger());
  exports2.logger = logger5;
});

// ../../node_modules/.pnpm/@sentry+utils@6.2.5/node_modules/@sentry/utils/dist/memo.js
var require_memo = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var Memo = function() {
    function Memo2() {
      this._hasWeakSet = typeof WeakSet === "function";
      this._inner = this._hasWeakSet ? new WeakSet() : [];
    }
    Memo2.prototype.memoize = function(obj) {
      if (this._hasWeakSet) {
        if (this._inner.has(obj)) {
          return true;
        }
        this._inner.add(obj);
        return false;
      }
      for (var i = 0; i < this._inner.length; i++) {
        var value = this._inner[i];
        if (value === obj) {
          return true;
        }
      }
      this._inner.push(obj);
      return false;
    };
    Memo2.prototype.unmemoize = function(obj) {
      if (this._hasWeakSet) {
        this._inner.delete(obj);
      } else {
        for (var i = 0; i < this._inner.length; i++) {
          if (this._inner[i] === obj) {
            this._inner.splice(i, 1);
            break;
          }
        }
      }
    };
    return Memo2;
  }();
  exports2.Memo = Memo;
});

// ../../node_modules/.pnpm/@sentry+utils@6.2.5/node_modules/@sentry/utils/dist/stacktrace.js
var require_stacktrace = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var defaultFunctionName = "<anonymous>";
  function getFunctionName(fn) {
    try {
      if (!fn || typeof fn !== "function") {
        return defaultFunctionName;
      }
      return fn.name || defaultFunctionName;
    } catch (e) {
      return defaultFunctionName;
    }
  }
  exports2.getFunctionName = getFunctionName;
});

// ../../node_modules/.pnpm/@sentry+utils@6.2.5/node_modules/@sentry/utils/dist/object.js
var require_object = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib_1 = require_tslib();
  var browser_1 = require_browser2();
  var is_1 = require_is();
  var memo_1 = require_memo();
  var stacktrace_1 = require_stacktrace();
  var string_1 = require_string2();
  function fill(source, name, replacementFactory) {
    if (!(name in source)) {
      return;
    }
    var original = source[name];
    var wrapped = replacementFactory(original);
    if (typeof wrapped === "function") {
      try {
        wrapped.prototype = wrapped.prototype || {};
        Object.defineProperties(wrapped, {
          __sentry_original__: {
            enumerable: false,
            value: original
          }
        });
      } catch (_Oo) {
      }
    }
    source[name] = wrapped;
  }
  exports2.fill = fill;
  function urlEncode(object) {
    return Object.keys(object).map(function(key) {
      return encodeURIComponent(key) + "=" + encodeURIComponent(object[key]);
    }).join("&");
  }
  exports2.urlEncode = urlEncode;
  function getWalkSource(value) {
    if (is_1.isError(value)) {
      var error = value;
      var err = {
        message: error.message,
        name: error.name,
        stack: error.stack
      };
      for (var i in error) {
        if (Object.prototype.hasOwnProperty.call(error, i)) {
          err[i] = error[i];
        }
      }
      return err;
    }
    if (is_1.isEvent(value)) {
      var event_1 = value;
      var source = {};
      source.type = event_1.type;
      try {
        source.target = is_1.isElement(event_1.target) ? browser_1.htmlTreeAsString(event_1.target) : Object.prototype.toString.call(event_1.target);
      } catch (_oO) {
        source.target = "<unknown>";
      }
      try {
        source.currentTarget = is_1.isElement(event_1.currentTarget) ? browser_1.htmlTreeAsString(event_1.currentTarget) : Object.prototype.toString.call(event_1.currentTarget);
      } catch (_oO) {
        source.currentTarget = "<unknown>";
      }
      if (typeof CustomEvent !== "undefined" && is_1.isInstanceOf(value, CustomEvent)) {
        source.detail = event_1.detail;
      }
      for (var i in event_1) {
        if (Object.prototype.hasOwnProperty.call(event_1, i)) {
          source[i] = event_1;
        }
      }
      return source;
    }
    return value;
  }
  function utf8Length(value) {
    return ~-encodeURI(value).split(/%..|./).length;
  }
  function jsonSize(value) {
    return utf8Length(JSON.stringify(value));
  }
  function normalizeToSize(object, depth, maxSize) {
    if (depth === void 0) {
      depth = 3;
    }
    if (maxSize === void 0) {
      maxSize = 100 * 1024;
    }
    var serialized = normalize(object, depth);
    if (jsonSize(serialized) > maxSize) {
      return normalizeToSize(object, depth - 1, maxSize);
    }
    return serialized;
  }
  exports2.normalizeToSize = normalizeToSize;
  function serializeValue(value) {
    var type = Object.prototype.toString.call(value);
    if (typeof value === "string") {
      return value;
    }
    if (type === "[object Object]") {
      return "[Object]";
    }
    if (type === "[object Array]") {
      return "[Array]";
    }
    var normalized = normalizeValue(value);
    return is_1.isPrimitive(normalized) ? normalized : type;
  }
  function normalizeValue(value, key) {
    if (key === "domain" && value && typeof value === "object" && value._events) {
      return "[Domain]";
    }
    if (key === "domainEmitter") {
      return "[DomainEmitter]";
    }
    if (typeof global !== "undefined" && value === global) {
      return "[Global]";
    }
    if (typeof window !== "undefined" && value === window) {
      return "[Window]";
    }
    if (typeof document !== "undefined" && value === document) {
      return "[Document]";
    }
    if (is_1.isSyntheticEvent(value)) {
      return "[SyntheticEvent]";
    }
    if (typeof value === "number" && value !== value) {
      return "[NaN]";
    }
    if (value === void 0) {
      return "[undefined]";
    }
    if (typeof value === "function") {
      return "[Function: " + stacktrace_1.getFunctionName(value) + "]";
    }
    if (typeof value === "symbol") {
      return "[" + String(value) + "]";
    }
    if (typeof value === "bigint") {
      return "[BigInt: " + String(value) + "]";
    }
    return value;
  }
  function walk(key, value, depth, memo) {
    if (depth === void 0) {
      depth = Infinity;
    }
    if (memo === void 0) {
      memo = new memo_1.Memo();
    }
    if (depth === 0) {
      return serializeValue(value);
    }
    if (value !== null && value !== void 0 && typeof value.toJSON === "function") {
      return value.toJSON();
    }
    var normalized = normalizeValue(value, key);
    if (is_1.isPrimitive(normalized)) {
      return normalized;
    }
    var source = getWalkSource(value);
    var acc = Array.isArray(value) ? [] : {};
    if (memo.memoize(value)) {
      return "[Circular ~]";
    }
    for (var innerKey in source) {
      if (!Object.prototype.hasOwnProperty.call(source, innerKey)) {
        continue;
      }
      acc[innerKey] = walk(innerKey, source[innerKey], depth - 1, memo);
    }
    memo.unmemoize(value);
    return acc;
  }
  exports2.walk = walk;
  function normalize(input, depth) {
    try {
      return JSON.parse(JSON.stringify(input, function(key, value) {
        return walk(key, value, depth);
      }));
    } catch (_oO) {
      return "**non-serializable**";
    }
  }
  exports2.normalize = normalize;
  function extractExceptionKeysForMessage(exception, maxLength) {
    if (maxLength === void 0) {
      maxLength = 40;
    }
    var keys = Object.keys(getWalkSource(exception));
    keys.sort();
    if (!keys.length) {
      return "[object has no keys]";
    }
    if (keys[0].length >= maxLength) {
      return string_1.truncate(keys[0], maxLength);
    }
    for (var includedKeys = keys.length; includedKeys > 0; includedKeys--) {
      var serialized = keys.slice(0, includedKeys).join(", ");
      if (serialized.length > maxLength) {
        continue;
      }
      if (includedKeys === keys.length) {
        return serialized;
      }
      return string_1.truncate(serialized, maxLength);
    }
    return "";
  }
  exports2.extractExceptionKeysForMessage = extractExceptionKeysForMessage;
  function dropUndefinedKeys(val) {
    var e_1, _a;
    if (is_1.isPlainObject(val)) {
      var obj = val;
      var rv = {};
      try {
        for (var _b = tslib_1.__values(Object.keys(obj)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var key = _c.value;
          if (typeof obj[key] !== "undefined") {
            rv[key] = dropUndefinedKeys(obj[key]);
          }
        }
      } catch (e_1_1) {
        e_1 = {error: e_1_1};
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return rv;
    }
    if (Array.isArray(val)) {
      return val.map(dropUndefinedKeys);
    }
    return val;
  }
  exports2.dropUndefinedKeys = dropUndefinedKeys;
});

// ../../node_modules/.pnpm/@sentry+utils@6.2.5/node_modules/@sentry/utils/dist/supports.js
var require_supports = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var logger_1 = require_logger2();
  var misc_1 = require_misc();
  function supportsErrorEvent() {
    try {
      new ErrorEvent("");
      return true;
    } catch (e) {
      return false;
    }
  }
  exports2.supportsErrorEvent = supportsErrorEvent;
  function supportsDOMError() {
    try {
      new DOMError("");
      return true;
    } catch (e) {
      return false;
    }
  }
  exports2.supportsDOMError = supportsDOMError;
  function supportsDOMException() {
    try {
      new DOMException("");
      return true;
    } catch (e) {
      return false;
    }
  }
  exports2.supportsDOMException = supportsDOMException;
  function supportsFetch() {
    if (!("fetch" in misc_1.getGlobalObject())) {
      return false;
    }
    try {
      new Headers();
      new Request("");
      new Response();
      return true;
    } catch (e) {
      return false;
    }
  }
  exports2.supportsFetch = supportsFetch;
  function isNativeFetch(func) {
    return func && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(func.toString());
  }
  exports2.isNativeFetch = isNativeFetch;
  function supportsNativeFetch() {
    if (!supportsFetch()) {
      return false;
    }
    var global2 = misc_1.getGlobalObject();
    if (isNativeFetch(global2.fetch)) {
      return true;
    }
    var result = false;
    var doc = global2.document;
    if (doc && typeof doc.createElement === "function") {
      try {
        var sandbox = doc.createElement("iframe");
        sandbox.hidden = true;
        doc.head.appendChild(sandbox);
        if (sandbox.contentWindow && sandbox.contentWindow.fetch) {
          result = isNativeFetch(sandbox.contentWindow.fetch);
        }
        doc.head.removeChild(sandbox);
      } catch (err) {
        logger_1.logger.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", err);
      }
    }
    return result;
  }
  exports2.supportsNativeFetch = supportsNativeFetch;
  function supportsReportingObserver() {
    return "ReportingObserver" in misc_1.getGlobalObject();
  }
  exports2.supportsReportingObserver = supportsReportingObserver;
  function supportsReferrerPolicy() {
    if (!supportsFetch()) {
      return false;
    }
    try {
      new Request("_", {
        referrerPolicy: "origin"
      });
      return true;
    } catch (e) {
      return false;
    }
  }
  exports2.supportsReferrerPolicy = supportsReferrerPolicy;
  function supportsHistory() {
    var global2 = misc_1.getGlobalObject();
    var chrome2 = global2.chrome;
    var isChromePackagedApp = chrome2 && chrome2.app && chrome2.app.runtime;
    var hasHistoryApi = "history" in global2 && !!global2.history.pushState && !!global2.history.replaceState;
    return !isChromePackagedApp && hasHistoryApi;
  }
  exports2.supportsHistory = supportsHistory;
});

// ../../node_modules/.pnpm/@sentry+utils@6.2.5/node_modules/@sentry/utils/dist/instrument.js
var require_instrument = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib_1 = require_tslib();
  var is_1 = require_is();
  var logger_1 = require_logger2();
  var misc_1 = require_misc();
  var object_1 = require_object();
  var stacktrace_1 = require_stacktrace();
  var supports_1 = require_supports();
  var global2 = misc_1.getGlobalObject();
  var handlers = {};
  var instrumented = {};
  function instrument(type) {
    if (instrumented[type]) {
      return;
    }
    instrumented[type] = true;
    switch (type) {
      case "console":
        instrumentConsole();
        break;
      case "dom":
        instrumentDOM();
        break;
      case "xhr":
        instrumentXHR();
        break;
      case "fetch":
        instrumentFetch();
        break;
      case "history":
        instrumentHistory();
        break;
      case "error":
        instrumentError();
        break;
      case "unhandledrejection":
        instrumentUnhandledRejection();
        break;
      default:
        logger_1.logger.warn("unknown instrumentation type:", type);
    }
  }
  function addInstrumentationHandler(handler) {
    if (!handler || typeof handler.type !== "string" || typeof handler.callback !== "function") {
      return;
    }
    handlers[handler.type] = handlers[handler.type] || [];
    handlers[handler.type].push(handler.callback);
    instrument(handler.type);
  }
  exports2.addInstrumentationHandler = addInstrumentationHandler;
  function triggerHandlers(type, data) {
    var e_1, _a;
    if (!type || !handlers[type]) {
      return;
    }
    try {
      for (var _b = tslib_1.__values(handlers[type] || []), _c = _b.next(); !_c.done; _c = _b.next()) {
        var handler = _c.value;
        try {
          handler(data);
        } catch (e) {
          logger_1.logger.error("Error while triggering instrumentation handler.\nType: " + type + "\nName: " + stacktrace_1.getFunctionName(handler) + "\nError: " + e);
        }
      }
    } catch (e_1_1) {
      e_1 = {error: e_1_1};
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  }
  function instrumentConsole() {
    if (!("console" in global2)) {
      return;
    }
    ["debug", "info", "warn", "error", "log", "assert"].forEach(function(level) {
      if (!(level in global2.console)) {
        return;
      }
      object_1.fill(global2.console, level, function(originalConsoleLevel) {
        return function() {
          var args2 = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args2[_i] = arguments[_i];
          }
          triggerHandlers("console", {args: args2, level});
          if (originalConsoleLevel) {
            Function.prototype.apply.call(originalConsoleLevel, global2.console, args2);
          }
        };
      });
    });
  }
  function instrumentFetch() {
    if (!supports_1.supportsNativeFetch()) {
      return;
    }
    object_1.fill(global2, "fetch", function(originalFetch) {
      return function() {
        var args2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args2[_i] = arguments[_i];
        }
        var handlerData = {
          args: args2,
          fetchData: {
            method: getFetchMethod(args2),
            url: getFetchUrl(args2)
          },
          startTimestamp: Date.now()
        };
        triggerHandlers("fetch", tslib_1.__assign({}, handlerData));
        return originalFetch.apply(global2, args2).then(function(response) {
          triggerHandlers("fetch", tslib_1.__assign(tslib_1.__assign({}, handlerData), {endTimestamp: Date.now(), response}));
          return response;
        }, function(error) {
          triggerHandlers("fetch", tslib_1.__assign(tslib_1.__assign({}, handlerData), {endTimestamp: Date.now(), error}));
          throw error;
        });
      };
    });
  }
  function getFetchMethod(fetchArgs) {
    if (fetchArgs === void 0) {
      fetchArgs = [];
    }
    if ("Request" in global2 && is_1.isInstanceOf(fetchArgs[0], Request) && fetchArgs[0].method) {
      return String(fetchArgs[0].method).toUpperCase();
    }
    if (fetchArgs[1] && fetchArgs[1].method) {
      return String(fetchArgs[1].method).toUpperCase();
    }
    return "GET";
  }
  function getFetchUrl(fetchArgs) {
    if (fetchArgs === void 0) {
      fetchArgs = [];
    }
    if (typeof fetchArgs[0] === "string") {
      return fetchArgs[0];
    }
    if ("Request" in global2 && is_1.isInstanceOf(fetchArgs[0], Request)) {
      return fetchArgs[0].url;
    }
    return String(fetchArgs[0]);
  }
  function instrumentXHR() {
    if (!("XMLHttpRequest" in global2)) {
      return;
    }
    var requestKeys = [];
    var requestValues = [];
    var xhrproto = XMLHttpRequest.prototype;
    object_1.fill(xhrproto, "open", function(originalOpen) {
      return function() {
        var args2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args2[_i] = arguments[_i];
        }
        var xhr = this;
        var url = args2[1];
        xhr.__sentry_xhr__ = {
          method: is_1.isString(args2[0]) ? args2[0].toUpperCase() : args2[0],
          url: args2[1]
        };
        if (is_1.isString(url) && xhr.__sentry_xhr__.method === "POST" && url.match(/sentry_key/)) {
          xhr.__sentry_own_request__ = true;
        }
        var onreadystatechangeHandler = function() {
          if (xhr.readyState === 4) {
            try {
              if (xhr.__sentry_xhr__) {
                xhr.__sentry_xhr__.status_code = xhr.status;
              }
            } catch (e) {
            }
            try {
              var requestPos = requestKeys.indexOf(xhr);
              if (requestPos !== -1) {
                requestKeys.splice(requestPos);
                var args_1 = requestValues.splice(requestPos)[0];
                if (xhr.__sentry_xhr__ && args_1[0] !== void 0) {
                  xhr.__sentry_xhr__.body = args_1[0];
                }
              }
            } catch (e) {
            }
            triggerHandlers("xhr", {
              args: args2,
              endTimestamp: Date.now(),
              startTimestamp: Date.now(),
              xhr
            });
          }
        };
        if ("onreadystatechange" in xhr && typeof xhr.onreadystatechange === "function") {
          object_1.fill(xhr, "onreadystatechange", function(original) {
            return function() {
              var readyStateArgs = [];
              for (var _i2 = 0; _i2 < arguments.length; _i2++) {
                readyStateArgs[_i2] = arguments[_i2];
              }
              onreadystatechangeHandler();
              return original.apply(xhr, readyStateArgs);
            };
          });
        } else {
          xhr.addEventListener("readystatechange", onreadystatechangeHandler);
        }
        return originalOpen.apply(xhr, args2);
      };
    });
    object_1.fill(xhrproto, "send", function(originalSend) {
      return function() {
        var args2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args2[_i] = arguments[_i];
        }
        requestKeys.push(this);
        requestValues.push(args2);
        triggerHandlers("xhr", {
          args: args2,
          startTimestamp: Date.now(),
          xhr: this
        });
        return originalSend.apply(this, args2);
      };
    });
  }
  var lastHref;
  function instrumentHistory() {
    if (!supports_1.supportsHistory()) {
      return;
    }
    var oldOnPopState = global2.onpopstate;
    global2.onpopstate = function() {
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      var to = global2.location.href;
      var from = lastHref;
      lastHref = to;
      triggerHandlers("history", {
        from,
        to
      });
      if (oldOnPopState) {
        return oldOnPopState.apply(this, args2);
      }
    };
    function historyReplacementFunction(originalHistoryFunction) {
      return function() {
        var args2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args2[_i] = arguments[_i];
        }
        var url = args2.length > 2 ? args2[2] : void 0;
        if (url) {
          var from = lastHref;
          var to = String(url);
          lastHref = to;
          triggerHandlers("history", {
            from,
            to
          });
        }
        return originalHistoryFunction.apply(this, args2);
      };
    }
    object_1.fill(global2.history, "pushState", historyReplacementFunction);
    object_1.fill(global2.history, "replaceState", historyReplacementFunction);
  }
  var debounceDuration = 1e3;
  var debounceTimerID;
  var lastCapturedEvent;
  function shouldShortcircuitPreviousDebounce(previous, current) {
    if (!previous) {
      return true;
    }
    if (previous.type !== current.type) {
      return true;
    }
    try {
      if (previous.target !== current.target) {
        return true;
      }
    } catch (e) {
    }
    return false;
  }
  function shouldSkipDOMEvent(event) {
    if (event.type !== "keypress") {
      return false;
    }
    try {
      var target = event.target;
      if (!target || !target.tagName) {
        return true;
      }
      if (target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.isContentEditable) {
        return false;
      }
    } catch (e) {
    }
    return true;
  }
  function makeDOMEventHandler(handler, globalListener) {
    if (globalListener === void 0) {
      globalListener = false;
    }
    return function(event) {
      if (!event || lastCapturedEvent === event) {
        return;
      }
      if (shouldSkipDOMEvent(event)) {
        return;
      }
      var name = event.type === "keypress" ? "input" : event.type;
      if (debounceTimerID === void 0) {
        handler({
          event,
          name,
          global: globalListener
        });
        lastCapturedEvent = event;
      } else if (shouldShortcircuitPreviousDebounce(lastCapturedEvent, event)) {
        handler({
          event,
          name,
          global: globalListener
        });
        lastCapturedEvent = event;
      }
      clearTimeout(debounceTimerID);
      debounceTimerID = global2.setTimeout(function() {
        debounceTimerID = void 0;
      }, debounceDuration);
    };
  }
  function instrumentDOM() {
    if (!("document" in global2)) {
      return;
    }
    var triggerDOMHandler = triggerHandlers.bind(null, "dom");
    var globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);
    global2.document.addEventListener("click", globalDOMEventHandler, false);
    global2.document.addEventListener("keypress", globalDOMEventHandler, false);
    ["EventTarget", "Node"].forEach(function(target) {
      var proto = global2[target] && global2[target].prototype;
      if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty("addEventListener")) {
        return;
      }
      object_1.fill(proto, "addEventListener", function(originalAddEventListener) {
        return function(type, listener, options) {
          if (type === "click" || type == "keypress") {
            try {
              var el = this;
              var handlers_1 = el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {};
              var handlerForType = handlers_1[type] = handlers_1[type] || {refCount: 0};
              if (!handlerForType.handler) {
                var handler = makeDOMEventHandler(triggerDOMHandler);
                handlerForType.handler = handler;
                originalAddEventListener.call(this, type, handler, options);
              }
              handlerForType.refCount += 1;
            } catch (e) {
            }
          }
          return originalAddEventListener.call(this, type, listener, options);
        };
      });
      object_1.fill(proto, "removeEventListener", function(originalRemoveEventListener) {
        return function(type, listener, options) {
          if (type === "click" || type == "keypress") {
            try {
              var el = this;
              var handlers_2 = el.__sentry_instrumentation_handlers__ || {};
              var handlerForType = handlers_2[type];
              if (handlerForType) {
                handlerForType.refCount -= 1;
                if (handlerForType.refCount <= 0) {
                  originalRemoveEventListener.call(this, type, handlerForType.handler, options);
                  handlerForType.handler = void 0;
                  delete handlers_2[type];
                }
                if (Object.keys(handlers_2).length === 0) {
                  delete el.__sentry_instrumentation_handlers__;
                }
              }
            } catch (e) {
            }
          }
          return originalRemoveEventListener.call(this, type, listener, options);
        };
      });
    });
  }
  var _oldOnErrorHandler = null;
  function instrumentError() {
    _oldOnErrorHandler = global2.onerror;
    global2.onerror = function(msg, url, line, column, error) {
      triggerHandlers("error", {
        column,
        error,
        line,
        msg,
        url
      });
      if (_oldOnErrorHandler) {
        return _oldOnErrorHandler.apply(this, arguments);
      }
      return false;
    };
  }
  var _oldOnUnhandledRejectionHandler = null;
  function instrumentUnhandledRejection() {
    _oldOnUnhandledRejectionHandler = global2.onunhandledrejection;
    global2.onunhandledrejection = function(e) {
      triggerHandlers("unhandledrejection", e);
      if (_oldOnUnhandledRejectionHandler) {
        return _oldOnUnhandledRejectionHandler.apply(this, arguments);
      }
      return true;
    };
  }
});

// ../../node_modules/.pnpm/@sentry+utils@6.2.5/node_modules/@sentry/utils/dist/path.js
var require_path2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  function normalizeArray(parts, allowAboveRoot) {
    var up = 0;
    for (var i = parts.length - 1; i >= 0; i--) {
      var last = parts[i];
      if (last === ".") {
        parts.splice(i, 1);
      } else if (last === "..") {
        parts.splice(i, 1);
        up++;
      } else if (up) {
        parts.splice(i, 1);
        up--;
      }
    }
    if (allowAboveRoot) {
      for (; up--; up) {
        parts.unshift("..");
      }
    }
    return parts;
  }
  var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^/]+?|)(\.[^./]*|))(?:[/]*)$/;
  function splitPath(filename) {
    var parts = splitPathRe.exec(filename);
    return parts ? parts.slice(1) : [];
  }
  function resolve() {
    var args2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args2[_i] = arguments[_i];
    }
    var resolvedPath = "";
    var resolvedAbsolute = false;
    for (var i = args2.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path10 = i >= 0 ? args2[i] : "/";
      if (!path10) {
        continue;
      }
      resolvedPath = path10 + "/" + resolvedPath;
      resolvedAbsolute = path10.charAt(0) === "/";
    }
    resolvedPath = normalizeArray(resolvedPath.split("/").filter(function(p) {
      return !!p;
    }), !resolvedAbsolute).join("/");
    return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
  }
  exports2.resolve = resolve;
  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== "") {
        break;
      }
    }
    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== "") {
        break;
      }
    }
    if (start > end) {
      return [];
    }
    return arr.slice(start, end - start + 1);
  }
  function relative2(from, to) {
    from = resolve(from).substr(1);
    to = resolve(to).substr(1);
    var fromParts = trim(from.split("/"));
    var toParts = trim(to.split("/"));
    var length = Math.min(fromParts.length, toParts.length);
    var samePartsLength = length;
    for (var i = 0; i < length; i++) {
      if (fromParts[i] !== toParts[i]) {
        samePartsLength = i;
        break;
      }
    }
    var outputParts = [];
    for (var i = samePartsLength; i < fromParts.length; i++) {
      outputParts.push("..");
    }
    outputParts = outputParts.concat(toParts.slice(samePartsLength));
    return outputParts.join("/");
  }
  exports2.relative = relative2;
  function normalizePath(path10) {
    var isPathAbsolute = isAbsolute(path10);
    var trailingSlash = path10.substr(-1) === "/";
    var normalizedPath = normalizeArray(path10.split("/").filter(function(p) {
      return !!p;
    }), !isPathAbsolute).join("/");
    if (!normalizedPath && !isPathAbsolute) {
      normalizedPath = ".";
    }
    if (normalizedPath && trailingSlash) {
      normalizedPath += "/";
    }
    return (isPathAbsolute ? "/" : "") + normalizedPath;
  }
  exports2.normalizePath = normalizePath;
  function isAbsolute(path10) {
    return path10.charAt(0) === "/";
  }
  exports2.isAbsolute = isAbsolute;
  function join2() {
    var args2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args2[_i] = arguments[_i];
    }
    return normalizePath(args2.join("/"));
  }
  exports2.join = join2;
  function dirname2(path10) {
    var result = splitPath(path10);
    var root = result[0];
    var dir = result[1];
    if (!root && !dir) {
      return ".";
    }
    if (dir) {
      dir = dir.substr(0, dir.length - 1);
    }
    return root + dir;
  }
  exports2.dirname = dirname2;
  function basename(path10, ext) {
    var f = splitPath(path10)[2];
    if (ext && f.substr(ext.length * -1) === ext) {
      f = f.substr(0, f.length - ext.length);
    }
    return f;
  }
  exports2.basename = basename;
});

// ../../node_modules/.pnpm/@sentry+utils@6.2.5/node_modules/@sentry/utils/dist/syncpromise.js
var require_syncpromise = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var is_1 = require_is();
  var States;
  (function(States2) {
    States2["PENDING"] = "PENDING";
    States2["RESOLVED"] = "RESOLVED";
    States2["REJECTED"] = "REJECTED";
  })(States || (States = {}));
  var SyncPromise = function() {
    function SyncPromise2(executor) {
      var _this = this;
      this._state = States.PENDING;
      this._handlers = [];
      this._resolve = function(value) {
        _this._setResult(States.RESOLVED, value);
      };
      this._reject = function(reason) {
        _this._setResult(States.REJECTED, reason);
      };
      this._setResult = function(state, value) {
        if (_this._state !== States.PENDING) {
          return;
        }
        if (is_1.isThenable(value)) {
          value.then(_this._resolve, _this._reject);
          return;
        }
        _this._state = state;
        _this._value = value;
        _this._executeHandlers();
      };
      this._attachHandler = function(handler) {
        _this._handlers = _this._handlers.concat(handler);
        _this._executeHandlers();
      };
      this._executeHandlers = function() {
        if (_this._state === States.PENDING) {
          return;
        }
        var cachedHandlers = _this._handlers.slice();
        _this._handlers = [];
        cachedHandlers.forEach(function(handler) {
          if (handler.done) {
            return;
          }
          if (_this._state === States.RESOLVED) {
            if (handler.onfulfilled) {
              handler.onfulfilled(_this._value);
            }
          }
          if (_this._state === States.REJECTED) {
            if (handler.onrejected) {
              handler.onrejected(_this._value);
            }
          }
          handler.done = true;
        });
      };
      try {
        executor(this._resolve, this._reject);
      } catch (e) {
        this._reject(e);
      }
    }
    SyncPromise2.resolve = function(value) {
      return new SyncPromise2(function(resolve) {
        resolve(value);
      });
    };
    SyncPromise2.reject = function(reason) {
      return new SyncPromise2(function(_2, reject) {
        reject(reason);
      });
    };
    SyncPromise2.all = function(collection) {
      return new SyncPromise2(function(resolve, reject) {
        if (!Array.isArray(collection)) {
          reject(new TypeError("Promise.all requires an array as input."));
          return;
        }
        if (collection.length === 0) {
          resolve([]);
          return;
        }
        var counter2 = collection.length;
        var resolvedCollection = [];
        collection.forEach(function(item, index) {
          SyncPromise2.resolve(item).then(function(value) {
            resolvedCollection[index] = value;
            counter2 -= 1;
            if (counter2 !== 0) {
              return;
            }
            resolve(resolvedCollection);
          }).then(null, reject);
        });
      });
    };
    SyncPromise2.prototype.then = function(onfulfilled, onrejected) {
      var _this = this;
      return new SyncPromise2(function(resolve, reject) {
        _this._attachHandler({
          done: false,
          onfulfilled: function(result) {
            if (!onfulfilled) {
              resolve(result);
              return;
            }
            try {
              resolve(onfulfilled(result));
              return;
            } catch (e) {
              reject(e);
              return;
            }
          },
          onrejected: function(reason) {
            if (!onrejected) {
              reject(reason);
              return;
            }
            try {
              resolve(onrejected(reason));
              return;
            } catch (e) {
              reject(e);
              return;
            }
          }
        });
      });
    };
    SyncPromise2.prototype.catch = function(onrejected) {
      return this.then(function(val) {
        return val;
      }, onrejected);
    };
    SyncPromise2.prototype.finally = function(onfinally) {
      var _this = this;
      return new SyncPromise2(function(resolve, reject) {
        var val;
        var isRejected;
        return _this.then(function(value) {
          isRejected = false;
          val = value;
          if (onfinally) {
            onfinally();
          }
        }, function(reason) {
          isRejected = true;
          val = reason;
          if (onfinally) {
            onfinally();
          }
        }).then(function() {
          if (isRejected) {
            reject(val);
            return;
          }
          resolve(val);
        });
      });
    };
    SyncPromise2.prototype.toString = function() {
      return "[object SyncPromise]";
    };
    return SyncPromise2;
  }();
  exports2.SyncPromise = SyncPromise;
});

// ../../node_modules/.pnpm/@sentry+utils@6.2.5/node_modules/@sentry/utils/dist/promisebuffer.js
var require_promisebuffer = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var error_1 = require_error4();
  var syncpromise_1 = require_syncpromise();
  var PromiseBuffer = function() {
    function PromiseBuffer2(_limit) {
      this._limit = _limit;
      this._buffer = [];
    }
    PromiseBuffer2.prototype.isReady = function() {
      return this._limit === void 0 || this.length() < this._limit;
    };
    PromiseBuffer2.prototype.add = function(task) {
      var _this = this;
      if (!this.isReady()) {
        return syncpromise_1.SyncPromise.reject(new error_1.SentryError("Not adding Promise due to buffer limit reached."));
      }
      if (this._buffer.indexOf(task) === -1) {
        this._buffer.push(task);
      }
      task.then(function() {
        return _this.remove(task);
      }).then(null, function() {
        return _this.remove(task).then(null, function() {
        });
      });
      return task;
    };
    PromiseBuffer2.prototype.remove = function(task) {
      var removedTask = this._buffer.splice(this._buffer.indexOf(task), 1)[0];
      return removedTask;
    };
    PromiseBuffer2.prototype.length = function() {
      return this._buffer.length;
    };
    PromiseBuffer2.prototype.drain = function(timeout) {
      var _this = this;
      return new syncpromise_1.SyncPromise(function(resolve) {
        var capturedSetTimeout = setTimeout(function() {
          if (timeout && timeout > 0) {
            resolve(false);
          }
        }, timeout);
        syncpromise_1.SyncPromise.all(_this._buffer).then(function() {
          clearTimeout(capturedSetTimeout);
          resolve(true);
        }).then(null, function() {
          resolve(true);
        });
      });
    };
    return PromiseBuffer2;
  }();
  exports2.PromiseBuffer = PromiseBuffer;
});

// ../../node_modules/.pnpm/@sentry+utils@6.2.5/node_modules/@sentry/utils/dist/time.js
var require_time = __commonJS((exports2, module2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var misc_1 = require_misc();
  var node_1 = require_node6();
  var dateTimestampSource = {
    nowSeconds: function() {
      return Date.now() / 1e3;
    }
  };
  function getBrowserPerformance() {
    var performance2 = misc_1.getGlobalObject().performance;
    if (!performance2 || !performance2.now) {
      return void 0;
    }
    var timeOrigin = Date.now() - performance2.now();
    return {
      now: function() {
        return performance2.now();
      },
      timeOrigin
    };
  }
  function getNodePerformance() {
    try {
      var perfHooks = node_1.dynamicRequire(module2, "perf_hooks");
      return perfHooks.performance;
    } catch (_2) {
      return void 0;
    }
  }
  var platformPerformance = node_1.isNodeEnv() ? getNodePerformance() : getBrowserPerformance();
  var timestampSource = platformPerformance === void 0 ? dateTimestampSource : {
    nowSeconds: function() {
      return (platformPerformance.timeOrigin + platformPerformance.now()) / 1e3;
    }
  };
  exports2.dateTimestampInSeconds = dateTimestampSource.nowSeconds.bind(dateTimestampSource);
  exports2.timestampInSeconds = timestampSource.nowSeconds.bind(timestampSource);
  exports2.timestampWithMs = exports2.timestampInSeconds;
  exports2.usingPerformanceAPI = platformPerformance !== void 0;
  exports2.browserPerformanceTimeOrigin = function() {
    var performance2 = misc_1.getGlobalObject().performance;
    if (!performance2) {
      exports2._browserPerformanceTimeOriginMode = "none";
      return void 0;
    }
    var threshold = 3600 * 1e3;
    var timeOriginIsReliable = performance2.timeOrigin && Math.abs(performance2.timeOrigin + performance2.now() - Date.now()) < threshold;
    if (timeOriginIsReliable) {
      exports2._browserPerformanceTimeOriginMode = "timeOrigin";
      return performance2.timeOrigin;
    }
    var navigationStart = performance2.timing && performance2.timing.navigationStart;
    var hasNavigationStart = typeof navigationStart === "number";
    var navigationStartIsReliable = hasNavigationStart && Math.abs(navigationStart + performance2.now() - Date.now()) < threshold;
    if (navigationStartIsReliable) {
      exports2._browserPerformanceTimeOriginMode = "navigationStart";
      return navigationStart;
    }
    exports2._browserPerformanceTimeOriginMode = "dateNow";
    return Date.now();
  }();
});

// ../../node_modules/.pnpm/@sentry+utils@6.2.5/node_modules/@sentry/utils/dist/index.js
var require_dist17 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_async8(), exports2);
  tslib_1.__exportStar(require_browser2(), exports2);
  tslib_1.__exportStar(require_dsn(), exports2);
  tslib_1.__exportStar(require_error4(), exports2);
  tslib_1.__exportStar(require_instrument(), exports2);
  tslib_1.__exportStar(require_is(), exports2);
  tslib_1.__exportStar(require_logger2(), exports2);
  tslib_1.__exportStar(require_memo(), exports2);
  tslib_1.__exportStar(require_misc(), exports2);
  tslib_1.__exportStar(require_node6(), exports2);
  tslib_1.__exportStar(require_object(), exports2);
  tslib_1.__exportStar(require_path2(), exports2);
  tslib_1.__exportStar(require_promisebuffer(), exports2);
  tslib_1.__exportStar(require_stacktrace(), exports2);
  tslib_1.__exportStar(require_string2(), exports2);
  tslib_1.__exportStar(require_supports(), exports2);
  tslib_1.__exportStar(require_syncpromise(), exports2);
  tslib_1.__exportStar(require_time(), exports2);
});

// ../../node_modules/.pnpm/@sentry+hub@6.2.5/node_modules/@sentry/hub/dist/scope.js
var require_scope = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib_1 = require_tslib();
  var utils_1 = require_dist17();
  var Scope = function() {
    function Scope2() {
      this._notifyingListeners = false;
      this._scopeListeners = [];
      this._eventProcessors = [];
      this._breadcrumbs = [];
      this._user = {};
      this._tags = {};
      this._extra = {};
      this._contexts = {};
    }
    Scope2.clone = function(scope) {
      var newScope = new Scope2();
      if (scope) {
        newScope._breadcrumbs = tslib_1.__spread(scope._breadcrumbs);
        newScope._tags = tslib_1.__assign({}, scope._tags);
        newScope._extra = tslib_1.__assign({}, scope._extra);
        newScope._contexts = tslib_1.__assign({}, scope._contexts);
        newScope._user = scope._user;
        newScope._level = scope._level;
        newScope._span = scope._span;
        newScope._session = scope._session;
        newScope._transactionName = scope._transactionName;
        newScope._fingerprint = scope._fingerprint;
        newScope._eventProcessors = tslib_1.__spread(scope._eventProcessors);
      }
      return newScope;
    };
    Scope2.prototype.addScopeListener = function(callback) {
      this._scopeListeners.push(callback);
    };
    Scope2.prototype.addEventProcessor = function(callback) {
      this._eventProcessors.push(callback);
      return this;
    };
    Scope2.prototype.setUser = function(user) {
      this._user = user || {};
      if (this._session) {
        this._session.update({user});
      }
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.getUser = function() {
      return this._user;
    };
    Scope2.prototype.setTags = function(tags) {
      this._tags = tslib_1.__assign(tslib_1.__assign({}, this._tags), tags);
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setTag = function(key, value) {
      var _a;
      this._tags = tslib_1.__assign(tslib_1.__assign({}, this._tags), (_a = {}, _a[key] = value, _a));
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setExtras = function(extras) {
      this._extra = tslib_1.__assign(tslib_1.__assign({}, this._extra), extras);
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setExtra = function(key, extra) {
      var _a;
      this._extra = tslib_1.__assign(tslib_1.__assign({}, this._extra), (_a = {}, _a[key] = extra, _a));
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setFingerprint = function(fingerprint) {
      this._fingerprint = fingerprint;
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setLevel = function(level) {
      this._level = level;
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setTransactionName = function(name) {
      this._transactionName = name;
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setTransaction = function(name) {
      return this.setTransactionName(name);
    };
    Scope2.prototype.setContext = function(key, context) {
      var _a;
      if (context === null) {
        delete this._contexts[key];
      } else {
        this._contexts = tslib_1.__assign(tslib_1.__assign({}, this._contexts), (_a = {}, _a[key] = context, _a));
      }
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setSpan = function(span) {
      this._span = span;
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.getSpan = function() {
      return this._span;
    };
    Scope2.prototype.getTransaction = function() {
      var _a, _b, _c, _d;
      var span = this.getSpan();
      if ((_a = span) === null || _a === void 0 ? void 0 : _a.transaction) {
        return (_b = span) === null || _b === void 0 ? void 0 : _b.transaction;
      }
      if ((_d = (_c = span) === null || _c === void 0 ? void 0 : _c.spanRecorder) === null || _d === void 0 ? void 0 : _d.spans[0]) {
        return span.spanRecorder.spans[0];
      }
      return void 0;
    };
    Scope2.prototype.setSession = function(session) {
      if (!session) {
        delete this._session;
      } else {
        this._session = session;
      }
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.getSession = function() {
      return this._session;
    };
    Scope2.prototype.update = function(captureContext) {
      if (!captureContext) {
        return this;
      }
      if (typeof captureContext === "function") {
        var updatedScope = captureContext(this);
        return updatedScope instanceof Scope2 ? updatedScope : this;
      }
      if (captureContext instanceof Scope2) {
        this._tags = tslib_1.__assign(tslib_1.__assign({}, this._tags), captureContext._tags);
        this._extra = tslib_1.__assign(tslib_1.__assign({}, this._extra), captureContext._extra);
        this._contexts = tslib_1.__assign(tslib_1.__assign({}, this._contexts), captureContext._contexts);
        if (captureContext._user && Object.keys(captureContext._user).length) {
          this._user = captureContext._user;
        }
        if (captureContext._level) {
          this._level = captureContext._level;
        }
        if (captureContext._fingerprint) {
          this._fingerprint = captureContext._fingerprint;
        }
      } else if (utils_1.isPlainObject(captureContext)) {
        captureContext = captureContext;
        this._tags = tslib_1.__assign(tslib_1.__assign({}, this._tags), captureContext.tags);
        this._extra = tslib_1.__assign(tslib_1.__assign({}, this._extra), captureContext.extra);
        this._contexts = tslib_1.__assign(tslib_1.__assign({}, this._contexts), captureContext.contexts);
        if (captureContext.user) {
          this._user = captureContext.user;
        }
        if (captureContext.level) {
          this._level = captureContext.level;
        }
        if (captureContext.fingerprint) {
          this._fingerprint = captureContext.fingerprint;
        }
      }
      return this;
    };
    Scope2.prototype.clear = function() {
      this._breadcrumbs = [];
      this._tags = {};
      this._extra = {};
      this._user = {};
      this._contexts = {};
      this._level = void 0;
      this._transactionName = void 0;
      this._fingerprint = void 0;
      this._span = void 0;
      this._session = void 0;
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.addBreadcrumb = function(breadcrumb, maxBreadcrumbs) {
      var mergedBreadcrumb = tslib_1.__assign({timestamp: utils_1.dateTimestampInSeconds()}, breadcrumb);
      this._breadcrumbs = maxBreadcrumbs !== void 0 && maxBreadcrumbs >= 0 ? tslib_1.__spread(this._breadcrumbs, [mergedBreadcrumb]).slice(-maxBreadcrumbs) : tslib_1.__spread(this._breadcrumbs, [mergedBreadcrumb]);
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.clearBreadcrumbs = function() {
      this._breadcrumbs = [];
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.applyToEvent = function(event, hint) {
      var _a;
      if (this._extra && Object.keys(this._extra).length) {
        event.extra = tslib_1.__assign(tslib_1.__assign({}, this._extra), event.extra);
      }
      if (this._tags && Object.keys(this._tags).length) {
        event.tags = tslib_1.__assign(tslib_1.__assign({}, this._tags), event.tags);
      }
      if (this._user && Object.keys(this._user).length) {
        event.user = tslib_1.__assign(tslib_1.__assign({}, this._user), event.user);
      }
      if (this._contexts && Object.keys(this._contexts).length) {
        event.contexts = tslib_1.__assign(tslib_1.__assign({}, this._contexts), event.contexts);
      }
      if (this._level) {
        event.level = this._level;
      }
      if (this._transactionName) {
        event.transaction = this._transactionName;
      }
      if (this._span) {
        event.contexts = tslib_1.__assign({trace: this._span.getTraceContext()}, event.contexts);
        var transactionName = (_a = this._span.transaction) === null || _a === void 0 ? void 0 : _a.name;
        if (transactionName) {
          event.tags = tslib_1.__assign({transaction: transactionName}, event.tags);
        }
      }
      this._applyFingerprint(event);
      event.breadcrumbs = tslib_1.__spread(event.breadcrumbs || [], this._breadcrumbs);
      event.breadcrumbs = event.breadcrumbs.length > 0 ? event.breadcrumbs : void 0;
      return this._notifyEventProcessors(tslib_1.__spread(getGlobalEventProcessors(), this._eventProcessors), event, hint);
    };
    Scope2.prototype._notifyEventProcessors = function(processors, event, hint, index) {
      var _this = this;
      if (index === void 0) {
        index = 0;
      }
      return new utils_1.SyncPromise(function(resolve, reject) {
        var processor = processors[index];
        if (event === null || typeof processor !== "function") {
          resolve(event);
        } else {
          var result = processor(tslib_1.__assign({}, event), hint);
          if (utils_1.isThenable(result)) {
            result.then(function(final) {
              return _this._notifyEventProcessors(processors, final, hint, index + 1).then(resolve);
            }).then(null, reject);
          } else {
            _this._notifyEventProcessors(processors, result, hint, index + 1).then(resolve).then(null, reject);
          }
        }
      });
    };
    Scope2.prototype._notifyScopeListeners = function() {
      var _this = this;
      if (!this._notifyingListeners) {
        this._notifyingListeners = true;
        this._scopeListeners.forEach(function(callback) {
          callback(_this);
        });
        this._notifyingListeners = false;
      }
    };
    Scope2.prototype._applyFingerprint = function(event) {
      event.fingerprint = event.fingerprint ? Array.isArray(event.fingerprint) ? event.fingerprint : [event.fingerprint] : [];
      if (this._fingerprint) {
        event.fingerprint = event.fingerprint.concat(this._fingerprint);
      }
      if (event.fingerprint && !event.fingerprint.length) {
        delete event.fingerprint;
      }
    };
    return Scope2;
  }();
  exports2.Scope = Scope;
  function getGlobalEventProcessors() {
    var global2 = utils_1.getGlobalObject();
    global2.__SENTRY__ = global2.__SENTRY__ || {};
    global2.__SENTRY__.globalEventProcessors = global2.__SENTRY__.globalEventProcessors || [];
    return global2.__SENTRY__.globalEventProcessors;
  }
  function addGlobalEventProcessor(callback) {
    getGlobalEventProcessors().push(callback);
  }
  exports2.addGlobalEventProcessor = addGlobalEventProcessor;
});

// ../../node_modules/.pnpm/@sentry+hub@6.2.5/node_modules/@sentry/hub/dist/session.js
var require_session2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var types_1 = require_dist16();
  var utils_1 = require_dist17();
  var Session = function() {
    function Session2(context) {
      this.errors = 0;
      this.sid = utils_1.uuid4();
      this.timestamp = Date.now();
      this.started = Date.now();
      this.duration = 0;
      this.status = types_1.SessionStatus.Ok;
      this.init = true;
      if (context) {
        this.update(context);
      }
    }
    Session2.prototype.update = function(context) {
      if (context === void 0) {
        context = {};
      }
      if (context.user) {
        if (context.user.ip_address) {
          this.ipAddress = context.user.ip_address;
        }
        if (!context.did) {
          this.did = context.user.id || context.user.email || context.user.username;
        }
      }
      this.timestamp = context.timestamp || Date.now();
      if (context.sid) {
        this.sid = context.sid.length === 32 ? context.sid : utils_1.uuid4();
      }
      if (context.init !== void 0) {
        this.init = context.init;
      }
      if (context.did) {
        this.did = "" + context.did;
      }
      if (typeof context.started === "number") {
        this.started = context.started;
      }
      if (typeof context.duration === "number") {
        this.duration = context.duration;
      } else {
        this.duration = this.timestamp - this.started;
      }
      if (context.release) {
        this.release = context.release;
      }
      if (context.environment) {
        this.environment = context.environment;
      }
      if (context.ipAddress) {
        this.ipAddress = context.ipAddress;
      }
      if (context.userAgent) {
        this.userAgent = context.userAgent;
      }
      if (typeof context.errors === "number") {
        this.errors = context.errors;
      }
      if (context.status) {
        this.status = context.status;
      }
    };
    Session2.prototype.close = function(status) {
      if (status) {
        this.update({status});
      } else if (this.status === types_1.SessionStatus.Ok) {
        this.update({status: types_1.SessionStatus.Exited});
      } else {
        this.update();
      }
    };
    Session2.prototype.toJSON = function() {
      return utils_1.dropUndefinedKeys({
        sid: "" + this.sid,
        init: this.init,
        started: new Date(this.started).toISOString(),
        timestamp: new Date(this.timestamp).toISOString(),
        status: this.status,
        errors: this.errors,
        did: typeof this.did === "number" || typeof this.did === "string" ? "" + this.did : void 0,
        duration: this.duration,
        attrs: utils_1.dropUndefinedKeys({
          release: this.release,
          environment: this.environment,
          ip_address: this.ipAddress,
          user_agent: this.userAgent
        })
      });
    };
    return Session2;
  }();
  exports2.Session = Session;
});

// ../../node_modules/.pnpm/@sentry+hub@6.2.5/node_modules/@sentry/hub/dist/hub.js
var require_hub = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib_1 = require_tslib();
  var types_1 = require_dist16();
  var utils_1 = require_dist17();
  var scope_1 = require_scope();
  var session_1 = require_session2();
  exports2.API_VERSION = 3;
  var DEFAULT_BREADCRUMBS = 100;
  var MAX_BREADCRUMBS = 100;
  var Hub = function() {
    function Hub2(client, scope, _version) {
      if (scope === void 0) {
        scope = new scope_1.Scope();
      }
      if (_version === void 0) {
        _version = exports2.API_VERSION;
      }
      this._version = _version;
      this._stack = [{}];
      this.getStackTop().scope = scope;
      this.bindClient(client);
    }
    Hub2.prototype.isOlderThan = function(version) {
      return this._version < version;
    };
    Hub2.prototype.bindClient = function(client) {
      var top = this.getStackTop();
      top.client = client;
      if (client && client.setupIntegrations) {
        client.setupIntegrations();
      }
    };
    Hub2.prototype.pushScope = function() {
      var scope = scope_1.Scope.clone(this.getScope());
      this.getStack().push({
        client: this.getClient(),
        scope
      });
      return scope;
    };
    Hub2.prototype.popScope = function() {
      if (this.getStack().length <= 1)
        return false;
      return !!this.getStack().pop();
    };
    Hub2.prototype.withScope = function(callback) {
      var scope = this.pushScope();
      try {
        callback(scope);
      } finally {
        this.popScope();
      }
    };
    Hub2.prototype.getClient = function() {
      return this.getStackTop().client;
    };
    Hub2.prototype.getScope = function() {
      return this.getStackTop().scope;
    };
    Hub2.prototype.getStack = function() {
      return this._stack;
    };
    Hub2.prototype.getStackTop = function() {
      return this._stack[this._stack.length - 1];
    };
    Hub2.prototype.captureException = function(exception, hint) {
      var eventId = this._lastEventId = utils_1.uuid4();
      var finalHint = hint;
      if (!hint) {
        var syntheticException = void 0;
        try {
          throw new Error("Sentry syntheticException");
        } catch (exception2) {
          syntheticException = exception2;
        }
        finalHint = {
          originalException: exception,
          syntheticException
        };
      }
      this._invokeClient("captureException", exception, tslib_1.__assign(tslib_1.__assign({}, finalHint), {event_id: eventId}));
      return eventId;
    };
    Hub2.prototype.captureMessage = function(message, level, hint) {
      var eventId = this._lastEventId = utils_1.uuid4();
      var finalHint = hint;
      if (!hint) {
        var syntheticException = void 0;
        try {
          throw new Error(message);
        } catch (exception) {
          syntheticException = exception;
        }
        finalHint = {
          originalException: message,
          syntheticException
        };
      }
      this._invokeClient("captureMessage", message, level, tslib_1.__assign(tslib_1.__assign({}, finalHint), {event_id: eventId}));
      return eventId;
    };
    Hub2.prototype.captureEvent = function(event, hint) {
      var eventId = this._lastEventId = utils_1.uuid4();
      this._invokeClient("captureEvent", event, tslib_1.__assign(tslib_1.__assign({}, hint), {event_id: eventId}));
      return eventId;
    };
    Hub2.prototype.lastEventId = function() {
      return this._lastEventId;
    };
    Hub2.prototype.addBreadcrumb = function(breadcrumb, hint) {
      var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
      if (!scope || !client)
        return;
      var _b = client.getOptions && client.getOptions() || {}, _c = _b.beforeBreadcrumb, beforeBreadcrumb = _c === void 0 ? null : _c, _d = _b.maxBreadcrumbs, maxBreadcrumbs = _d === void 0 ? DEFAULT_BREADCRUMBS : _d;
      if (maxBreadcrumbs <= 0)
        return;
      var timestamp = utils_1.dateTimestampInSeconds();
      var mergedBreadcrumb = tslib_1.__assign({timestamp}, breadcrumb);
      var finalBreadcrumb = beforeBreadcrumb ? utils_1.consoleSandbox(function() {
        return beforeBreadcrumb(mergedBreadcrumb, hint);
      }) : mergedBreadcrumb;
      if (finalBreadcrumb === null)
        return;
      scope.addBreadcrumb(finalBreadcrumb, Math.min(maxBreadcrumbs, MAX_BREADCRUMBS));
    };
    Hub2.prototype.setUser = function(user) {
      var scope = this.getScope();
      if (scope)
        scope.setUser(user);
    };
    Hub2.prototype.setTags = function(tags) {
      var scope = this.getScope();
      if (scope)
        scope.setTags(tags);
    };
    Hub2.prototype.setExtras = function(extras) {
      var scope = this.getScope();
      if (scope)
        scope.setExtras(extras);
    };
    Hub2.prototype.setTag = function(key, value) {
      var scope = this.getScope();
      if (scope)
        scope.setTag(key, value);
    };
    Hub2.prototype.setExtra = function(key, extra) {
      var scope = this.getScope();
      if (scope)
        scope.setExtra(key, extra);
    };
    Hub2.prototype.setContext = function(name, context) {
      var scope = this.getScope();
      if (scope)
        scope.setContext(name, context);
    };
    Hub2.prototype.configureScope = function(callback) {
      var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
      if (scope && client) {
        callback(scope);
      }
    };
    Hub2.prototype.run = function(callback) {
      var oldHub = makeMain(this);
      try {
        callback(this);
      } finally {
        makeMain(oldHub);
      }
    };
    Hub2.prototype.getIntegration = function(integration) {
      var client = this.getClient();
      if (!client)
        return null;
      try {
        return client.getIntegration(integration);
      } catch (_oO) {
        utils_1.logger.warn("Cannot retrieve integration " + integration.id + " from the current Hub");
        return null;
      }
    };
    Hub2.prototype.startSpan = function(context) {
      return this._callExtensionMethod("startSpan", context);
    };
    Hub2.prototype.startTransaction = function(context, customSamplingContext) {
      return this._callExtensionMethod("startTransaction", context, customSamplingContext);
    };
    Hub2.prototype.traceHeaders = function() {
      return this._callExtensionMethod("traceHeaders");
    };
    Hub2.prototype.captureSession = function(endSession) {
      if (endSession === void 0) {
        endSession = false;
      }
      if (endSession) {
        return this.endSession();
      }
      this._sendSessionUpdate();
    };
    Hub2.prototype.endSession = function() {
      var _a, _b, _c, _d, _e;
      (_c = (_b = (_a = this.getStackTop()) === null || _a === void 0 ? void 0 : _a.scope) === null || _b === void 0 ? void 0 : _b.getSession()) === null || _c === void 0 ? void 0 : _c.close();
      this._sendSessionUpdate();
      (_e = (_d = this.getStackTop()) === null || _d === void 0 ? void 0 : _d.scope) === null || _e === void 0 ? void 0 : _e.setSession();
    };
    Hub2.prototype.startSession = function(context) {
      var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
      var _b = client && client.getOptions() || {}, release = _b.release, environment = _b.environment;
      var session = new session_1.Session(tslib_1.__assign(tslib_1.__assign({
        release,
        environment
      }, scope && {user: scope.getUser()}), context));
      if (scope) {
        var currentSession = scope.getSession && scope.getSession();
        if (currentSession && currentSession.status === types_1.SessionStatus.Ok) {
          currentSession.update({status: types_1.SessionStatus.Exited});
        }
        this.endSession();
        scope.setSession(session);
      }
      return session;
    };
    Hub2.prototype._sendSessionUpdate = function() {
      var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
      if (!scope)
        return;
      var session = scope.getSession && scope.getSession();
      if (session) {
        if (client && client.captureSession) {
          client.captureSession(session);
        }
      }
    };
    Hub2.prototype._invokeClient = function(method) {
      var _a;
      var args2 = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args2[_i - 1] = arguments[_i];
      }
      var _b = this.getStackTop(), scope = _b.scope, client = _b.client;
      if (client && client[method]) {
        (_a = client)[method].apply(_a, tslib_1.__spread(args2, [scope]));
      }
    };
    Hub2.prototype._callExtensionMethod = function(method) {
      var args2 = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args2[_i - 1] = arguments[_i];
      }
      var carrier = getMainCarrier();
      var sentry = carrier.__SENTRY__;
      if (sentry && sentry.extensions && typeof sentry.extensions[method] === "function") {
        return sentry.extensions[method].apply(this, args2);
      }
      utils_1.logger.warn("Extension method " + method + " couldn't be found, doing nothing.");
    };
    return Hub2;
  }();
  exports2.Hub = Hub;
  function getMainCarrier() {
    var carrier = utils_1.getGlobalObject();
    carrier.__SENTRY__ = carrier.__SENTRY__ || {
      extensions: {},
      hub: void 0
    };
    return carrier;
  }
  exports2.getMainCarrier = getMainCarrier;
  function makeMain(hub) {
    var registry = getMainCarrier();
    var oldHub = getHubFromCarrier(registry);
    setHubOnCarrier(registry, hub);
    return oldHub;
  }
  exports2.makeMain = makeMain;
  function getCurrentHub() {
    var registry = getMainCarrier();
    if (!hasHubOnCarrier(registry) || getHubFromCarrier(registry).isOlderThan(exports2.API_VERSION)) {
      setHubOnCarrier(registry, new Hub());
    }
    if (utils_1.isNodeEnv()) {
      return getHubFromActiveDomain(registry);
    }
    return getHubFromCarrier(registry);
  }
  exports2.getCurrentHub = getCurrentHub;
  function getActiveDomain() {
    utils_1.logger.warn("Function `getActiveDomain` is deprecated and will be removed in a future version.");
    var sentry = getMainCarrier().__SENTRY__;
    return sentry && sentry.extensions && sentry.extensions.domain && sentry.extensions.domain.active;
  }
  exports2.getActiveDomain = getActiveDomain;
  function getHubFromActiveDomain(registry) {
    var _a, _b, _c;
    try {
      var activeDomain = (_c = (_b = (_a = getMainCarrier().__SENTRY__) === null || _a === void 0 ? void 0 : _a.extensions) === null || _b === void 0 ? void 0 : _b.domain) === null || _c === void 0 ? void 0 : _c.active;
      if (!activeDomain) {
        return getHubFromCarrier(registry);
      }
      if (!hasHubOnCarrier(activeDomain) || getHubFromCarrier(activeDomain).isOlderThan(exports2.API_VERSION)) {
        var registryHubTopStack = getHubFromCarrier(registry).getStackTop();
        setHubOnCarrier(activeDomain, new Hub(registryHubTopStack.client, scope_1.Scope.clone(registryHubTopStack.scope)));
      }
      return getHubFromCarrier(activeDomain);
    } catch (_Oo) {
      return getHubFromCarrier(registry);
    }
  }
  function hasHubOnCarrier(carrier) {
    return !!(carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub);
  }
  function getHubFromCarrier(carrier) {
    if (carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub)
      return carrier.__SENTRY__.hub;
    carrier.__SENTRY__ = carrier.__SENTRY__ || {};
    carrier.__SENTRY__.hub = new Hub();
    return carrier.__SENTRY__.hub;
  }
  exports2.getHubFromCarrier = getHubFromCarrier;
  function setHubOnCarrier(carrier, hub) {
    if (!carrier)
      return false;
    carrier.__SENTRY__ = carrier.__SENTRY__ || {};
    carrier.__SENTRY__.hub = hub;
    return true;
  }
  exports2.setHubOnCarrier = setHubOnCarrier;
});

// ../../node_modules/.pnpm/@sentry+hub@6.2.5/node_modules/@sentry/hub/dist/index.js
var require_dist18 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var scope_1 = require_scope();
  exports2.addGlobalEventProcessor = scope_1.addGlobalEventProcessor;
  exports2.Scope = scope_1.Scope;
  var session_1 = require_session2();
  exports2.Session = session_1.Session;
  var hub_1 = require_hub();
  exports2.getActiveDomain = hub_1.getActiveDomain;
  exports2.getCurrentHub = hub_1.getCurrentHub;
  exports2.getHubFromCarrier = hub_1.getHubFromCarrier;
  exports2.getMainCarrier = hub_1.getMainCarrier;
  exports2.Hub = hub_1.Hub;
  exports2.makeMain = hub_1.makeMain;
  exports2.setHubOnCarrier = hub_1.setHubOnCarrier;
});

// ../../node_modules/.pnpm/@sentry+minimal@6.2.5/node_modules/@sentry/minimal/dist/index.js
var require_dist19 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib_1 = require_tslib();
  var hub_1 = require_dist18();
  function callOnHub(method) {
    var args2 = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args2[_i - 1] = arguments[_i];
    }
    var hub = hub_1.getCurrentHub();
    if (hub && hub[method]) {
      return hub[method].apply(hub, tslib_1.__spread(args2));
    }
    throw new Error("No hub defined or " + method + " was not found on the hub, please open a bug report.");
  }
  function captureException(exception, captureContext) {
    var syntheticException;
    try {
      throw new Error("Sentry syntheticException");
    } catch (exception2) {
      syntheticException = exception2;
    }
    return callOnHub("captureException", exception, {
      captureContext,
      originalException: exception,
      syntheticException
    });
  }
  exports2.captureException = captureException;
  function captureMessage(message, captureContext) {
    var syntheticException;
    try {
      throw new Error(message);
    } catch (exception) {
      syntheticException = exception;
    }
    var level = typeof captureContext === "string" ? captureContext : void 0;
    var context = typeof captureContext !== "string" ? {captureContext} : void 0;
    return callOnHub("captureMessage", message, level, tslib_1.__assign({originalException: message, syntheticException}, context));
  }
  exports2.captureMessage = captureMessage;
  function captureEvent(event) {
    return callOnHub("captureEvent", event);
  }
  exports2.captureEvent = captureEvent;
  function configureScope(callback) {
    callOnHub("configureScope", callback);
  }
  exports2.configureScope = configureScope;
  function addBreadcrumb(breadcrumb) {
    callOnHub("addBreadcrumb", breadcrumb);
  }
  exports2.addBreadcrumb = addBreadcrumb;
  function setContext(name, context) {
    callOnHub("setContext", name, context);
  }
  exports2.setContext = setContext;
  function setExtras(extras) {
    callOnHub("setExtras", extras);
  }
  exports2.setExtras = setExtras;
  function setTags(tags) {
    callOnHub("setTags", tags);
  }
  exports2.setTags = setTags;
  function setExtra(key, extra) {
    callOnHub("setExtra", key, extra);
  }
  exports2.setExtra = setExtra;
  function setTag(key, value) {
    callOnHub("setTag", key, value);
  }
  exports2.setTag = setTag;
  function setUser(user) {
    callOnHub("setUser", user);
  }
  exports2.setUser = setUser;
  function withScope(callback) {
    callOnHub("withScope", callback);
  }
  exports2.withScope = withScope;
  function _callOnClient(method) {
    var args2 = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args2[_i - 1] = arguments[_i];
    }
    callOnHub.apply(void 0, tslib_1.__spread(["_invokeClient", method], args2));
  }
  exports2._callOnClient = _callOnClient;
  function startTransaction(context, customSamplingContext) {
    return callOnHub("startTransaction", tslib_1.__assign({}, context), customSamplingContext);
  }
  exports2.startTransaction = startTransaction;
});

// ../../node_modules/.pnpm/@sentry+core@6.2.5/node_modules/@sentry/core/dist/api.js
var require_api = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var utils_1 = require_dist17();
  var SENTRY_API_VERSION = "7";
  var API = function() {
    function API2(dsn, metadata) {
      if (metadata === void 0) {
        metadata = {};
      }
      this.dsn = dsn;
      this._dsnObject = new utils_1.Dsn(dsn);
      this.metadata = metadata;
    }
    API2.prototype.getDsn = function() {
      return this._dsnObject;
    };
    API2.prototype.getBaseApiEndpoint = function() {
      var dsn = this._dsnObject;
      var protocol = dsn.protocol ? dsn.protocol + ":" : "";
      var port = dsn.port ? ":" + dsn.port : "";
      return protocol + "//" + dsn.host + port + (dsn.path ? "/" + dsn.path : "") + "/api/";
    };
    API2.prototype.getStoreEndpoint = function() {
      return this._getIngestEndpoint("store");
    };
    API2.prototype.getStoreEndpointWithUrlEncodedAuth = function() {
      return this.getStoreEndpoint() + "?" + this._encodedAuth();
    };
    API2.prototype.getEnvelopeEndpointWithUrlEncodedAuth = function() {
      return this._getEnvelopeEndpoint() + "?" + this._encodedAuth();
    };
    API2.prototype.getStoreEndpointPath = function() {
      var dsn = this._dsnObject;
      return (dsn.path ? "/" + dsn.path : "") + "/api/" + dsn.projectId + "/store/";
    };
    API2.prototype.getRequestHeaders = function(clientName, clientVersion) {
      var dsn = this._dsnObject;
      var header = ["Sentry sentry_version=" + SENTRY_API_VERSION];
      header.push("sentry_client=" + clientName + "/" + clientVersion);
      header.push("sentry_key=" + dsn.publicKey);
      if (dsn.pass) {
        header.push("sentry_secret=" + dsn.pass);
      }
      return {
        "Content-Type": "application/json",
        "X-Sentry-Auth": header.join(", ")
      };
    };
    API2.prototype.getReportDialogEndpoint = function(dialogOptions) {
      if (dialogOptions === void 0) {
        dialogOptions = {};
      }
      var dsn = this._dsnObject;
      var endpoint = this.getBaseApiEndpoint() + "embed/error-page/";
      var encodedOptions = [];
      encodedOptions.push("dsn=" + dsn.toString());
      for (var key in dialogOptions) {
        if (key === "dsn") {
          continue;
        }
        if (key === "user") {
          if (!dialogOptions.user) {
            continue;
          }
          if (dialogOptions.user.name) {
            encodedOptions.push("name=" + encodeURIComponent(dialogOptions.user.name));
          }
          if (dialogOptions.user.email) {
            encodedOptions.push("email=" + encodeURIComponent(dialogOptions.user.email));
          }
        } else {
          encodedOptions.push(encodeURIComponent(key) + "=" + encodeURIComponent(dialogOptions[key]));
        }
      }
      if (encodedOptions.length) {
        return endpoint + "?" + encodedOptions.join("&");
      }
      return endpoint;
    };
    API2.prototype._getEnvelopeEndpoint = function() {
      return this._getIngestEndpoint("envelope");
    };
    API2.prototype._getIngestEndpoint = function(target) {
      var base = this.getBaseApiEndpoint();
      var dsn = this._dsnObject;
      return "" + base + dsn.projectId + "/" + target + "/";
    };
    API2.prototype._encodedAuth = function() {
      var dsn = this._dsnObject;
      var auth = {
        sentry_key: dsn.publicKey,
        sentry_version: SENTRY_API_VERSION
      };
      return utils_1.urlEncode(auth);
    };
    return API2;
  }();
  exports2.API = API;
});

// ../../node_modules/.pnpm/@sentry+core@6.2.5/node_modules/@sentry/core/dist/integration.js
var require_integration = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib_1 = require_tslib();
  var hub_1 = require_dist18();
  var utils_1 = require_dist17();
  exports2.installedIntegrations = [];
  function getIntegrationsToSetup(options) {
    var defaultIntegrations = options.defaultIntegrations && tslib_1.__spread(options.defaultIntegrations) || [];
    var userIntegrations = options.integrations;
    var integrations = [];
    if (Array.isArray(userIntegrations)) {
      var userIntegrationsNames_1 = userIntegrations.map(function(i) {
        return i.name;
      });
      var pickedIntegrationsNames_1 = [];
      defaultIntegrations.forEach(function(defaultIntegration) {
        if (userIntegrationsNames_1.indexOf(defaultIntegration.name) === -1 && pickedIntegrationsNames_1.indexOf(defaultIntegration.name) === -1) {
          integrations.push(defaultIntegration);
          pickedIntegrationsNames_1.push(defaultIntegration.name);
        }
      });
      userIntegrations.forEach(function(userIntegration) {
        if (pickedIntegrationsNames_1.indexOf(userIntegration.name) === -1) {
          integrations.push(userIntegration);
          pickedIntegrationsNames_1.push(userIntegration.name);
        }
      });
    } else if (typeof userIntegrations === "function") {
      integrations = userIntegrations(defaultIntegrations);
      integrations = Array.isArray(integrations) ? integrations : [integrations];
    } else {
      integrations = tslib_1.__spread(defaultIntegrations);
    }
    var integrationsNames = integrations.map(function(i) {
      return i.name;
    });
    var alwaysLastToRun = "Debug";
    if (integrationsNames.indexOf(alwaysLastToRun) !== -1) {
      integrations.push.apply(integrations, tslib_1.__spread(integrations.splice(integrationsNames.indexOf(alwaysLastToRun), 1)));
    }
    return integrations;
  }
  exports2.getIntegrationsToSetup = getIntegrationsToSetup;
  function setupIntegration(integration) {
    if (exports2.installedIntegrations.indexOf(integration.name) !== -1) {
      return;
    }
    integration.setupOnce(hub_1.addGlobalEventProcessor, hub_1.getCurrentHub);
    exports2.installedIntegrations.push(integration.name);
    utils_1.logger.log("Integration installed: " + integration.name);
  }
  exports2.setupIntegration = setupIntegration;
  function setupIntegrations(options) {
    var integrations = {};
    getIntegrationsToSetup(options).forEach(function(integration) {
      integrations[integration.name] = integration;
      setupIntegration(integration);
    });
    return integrations;
  }
  exports2.setupIntegrations = setupIntegrations;
});

// ../../node_modules/.pnpm/@sentry+core@6.2.5/node_modules/@sentry/core/dist/baseclient.js
var require_baseclient = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib_1 = require_tslib();
  var hub_1 = require_dist18();
  var types_1 = require_dist16();
  var utils_1 = require_dist17();
  var integration_1 = require_integration();
  var BaseClient = function() {
    function BaseClient2(backendClass, options) {
      this._integrations = {};
      this._processing = 0;
      this._backend = new backendClass(options);
      this._options = options;
      if (options.dsn) {
        this._dsn = new utils_1.Dsn(options.dsn);
      }
    }
    BaseClient2.prototype.captureException = function(exception, hint, scope) {
      var _this = this;
      var eventId = hint && hint.event_id;
      this._process(this._getBackend().eventFromException(exception, hint).then(function(event) {
        return _this._captureEvent(event, hint, scope);
      }).then(function(result) {
        eventId = result;
      }));
      return eventId;
    };
    BaseClient2.prototype.captureMessage = function(message, level, hint, scope) {
      var _this = this;
      var eventId = hint && hint.event_id;
      var promisedEvent = utils_1.isPrimitive(message) ? this._getBackend().eventFromMessage(String(message), level, hint) : this._getBackend().eventFromException(message, hint);
      this._process(promisedEvent.then(function(event) {
        return _this._captureEvent(event, hint, scope);
      }).then(function(result) {
        eventId = result;
      }));
      return eventId;
    };
    BaseClient2.prototype.captureEvent = function(event, hint, scope) {
      var eventId = hint && hint.event_id;
      this._process(this._captureEvent(event, hint, scope).then(function(result) {
        eventId = result;
      }));
      return eventId;
    };
    BaseClient2.prototype.captureSession = function(session) {
      if (!session.release) {
        utils_1.logger.warn("Discarded session because of missing release");
      } else {
        this._sendSession(session);
        session.update({init: false});
      }
    };
    BaseClient2.prototype.getDsn = function() {
      return this._dsn;
    };
    BaseClient2.prototype.getOptions = function() {
      return this._options;
    };
    BaseClient2.prototype.flush = function(timeout) {
      var _this = this;
      return this._isClientProcessing(timeout).then(function(ready) {
        return _this._getBackend().getTransport().close(timeout).then(function(transportFlushed) {
          return ready && transportFlushed;
        });
      });
    };
    BaseClient2.prototype.close = function(timeout) {
      var _this = this;
      return this.flush(timeout).then(function(result) {
        _this.getOptions().enabled = false;
        return result;
      });
    };
    BaseClient2.prototype.setupIntegrations = function() {
      if (this._isEnabled()) {
        this._integrations = integration_1.setupIntegrations(this._options);
      }
    };
    BaseClient2.prototype.getIntegration = function(integration) {
      try {
        return this._integrations[integration.id] || null;
      } catch (_oO) {
        utils_1.logger.warn("Cannot retrieve integration " + integration.id + " from the current Client");
        return null;
      }
    };
    BaseClient2.prototype._updateSessionFromEvent = function(session, event) {
      var e_1, _a;
      var crashed = false;
      var errored = false;
      var userAgent;
      var exceptions = event.exception && event.exception.values;
      if (exceptions) {
        errored = true;
        try {
          for (var exceptions_1 = tslib_1.__values(exceptions), exceptions_1_1 = exceptions_1.next(); !exceptions_1_1.done; exceptions_1_1 = exceptions_1.next()) {
            var ex = exceptions_1_1.value;
            var mechanism = ex.mechanism;
            if (mechanism && mechanism.handled === false) {
              crashed = true;
              break;
            }
          }
        } catch (e_1_1) {
          e_1 = {error: e_1_1};
        } finally {
          try {
            if (exceptions_1_1 && !exceptions_1_1.done && (_a = exceptions_1.return))
              _a.call(exceptions_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
      var user = event.user;
      if (!session.userAgent) {
        var headers = event.request ? event.request.headers : {};
        for (var key in headers) {
          if (key.toLowerCase() === "user-agent") {
            userAgent = headers[key];
            break;
          }
        }
      }
      session.update(tslib_1.__assign(tslib_1.__assign({}, crashed && {status: types_1.SessionStatus.Crashed}), {
        user,
        userAgent,
        errors: session.errors + Number(errored || crashed)
      }));
      this.captureSession(session);
    };
    BaseClient2.prototype._sendSession = function(session) {
      this._getBackend().sendSession(session);
    };
    BaseClient2.prototype._isClientProcessing = function(timeout) {
      var _this = this;
      return new utils_1.SyncPromise(function(resolve) {
        var ticked = 0;
        var tick = 1;
        var interval = setInterval(function() {
          if (_this._processing == 0) {
            clearInterval(interval);
            resolve(true);
          } else {
            ticked += tick;
            if (timeout && ticked >= timeout) {
              clearInterval(interval);
              resolve(false);
            }
          }
        }, tick);
      });
    };
    BaseClient2.prototype._getBackend = function() {
      return this._backend;
    };
    BaseClient2.prototype._isEnabled = function() {
      return this.getOptions().enabled !== false && this._dsn !== void 0;
    };
    BaseClient2.prototype._prepareEvent = function(event, scope, hint) {
      var _this = this;
      var _a = this.getOptions().normalizeDepth, normalizeDepth = _a === void 0 ? 3 : _a;
      var prepared = tslib_1.__assign(tslib_1.__assign({}, event), {event_id: event.event_id || (hint && hint.event_id ? hint.event_id : utils_1.uuid4()), timestamp: event.timestamp || utils_1.dateTimestampInSeconds()});
      this._applyClientOptions(prepared);
      this._applyIntegrationsMetadata(prepared);
      var finalScope = scope;
      if (hint && hint.captureContext) {
        finalScope = hub_1.Scope.clone(finalScope).update(hint.captureContext);
      }
      var result = utils_1.SyncPromise.resolve(prepared);
      if (finalScope) {
        result = finalScope.applyToEvent(prepared, hint);
      }
      return result.then(function(evt) {
        if (typeof normalizeDepth === "number" && normalizeDepth > 0) {
          return _this._normalizeEvent(evt, normalizeDepth);
        }
        return evt;
      });
    };
    BaseClient2.prototype._normalizeEvent = function(event, depth) {
      if (!event) {
        return null;
      }
      var normalized = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, event), event.breadcrumbs && {
        breadcrumbs: event.breadcrumbs.map(function(b) {
          return tslib_1.__assign(tslib_1.__assign({}, b), b.data && {
            data: utils_1.normalize(b.data, depth)
          });
        })
      }), event.user && {
        user: utils_1.normalize(event.user, depth)
      }), event.contexts && {
        contexts: utils_1.normalize(event.contexts, depth)
      }), event.extra && {
        extra: utils_1.normalize(event.extra, depth)
      });
      if (event.contexts && event.contexts.trace) {
        normalized.contexts.trace = event.contexts.trace;
      }
      return normalized;
    };
    BaseClient2.prototype._applyClientOptions = function(event) {
      var options = this.getOptions();
      var environment = options.environment, release = options.release, dist = options.dist, _a = options.maxValueLength, maxValueLength = _a === void 0 ? 250 : _a;
      if (!("environment" in event)) {
        event.environment = "environment" in options ? environment : "production";
      }
      if (event.release === void 0 && release !== void 0) {
        event.release = release;
      }
      if (event.dist === void 0 && dist !== void 0) {
        event.dist = dist;
      }
      if (event.message) {
        event.message = utils_1.truncate(event.message, maxValueLength);
      }
      var exception = event.exception && event.exception.values && event.exception.values[0];
      if (exception && exception.value) {
        exception.value = utils_1.truncate(exception.value, maxValueLength);
      }
      var request = event.request;
      if (request && request.url) {
        request.url = utils_1.truncate(request.url, maxValueLength);
      }
    };
    BaseClient2.prototype._applyIntegrationsMetadata = function(event) {
      var sdkInfo = event.sdk;
      var integrationsArray = Object.keys(this._integrations);
      if (sdkInfo && integrationsArray.length > 0) {
        sdkInfo.integrations = integrationsArray;
      }
    };
    BaseClient2.prototype._sendEvent = function(event) {
      this._getBackend().sendEvent(event);
    };
    BaseClient2.prototype._captureEvent = function(event, hint, scope) {
      return this._processEvent(event, hint, scope).then(function(finalEvent) {
        return finalEvent.event_id;
      }, function(reason) {
        utils_1.logger.error(reason);
        return void 0;
      });
    };
    BaseClient2.prototype._processEvent = function(event, hint, scope) {
      var _this = this;
      var _a = this.getOptions(), beforeSend = _a.beforeSend, sampleRate = _a.sampleRate;
      if (!this._isEnabled()) {
        return utils_1.SyncPromise.reject(new utils_1.SentryError("SDK not enabled, will not send event."));
      }
      var isTransaction = event.type === "transaction";
      if (!isTransaction && typeof sampleRate === "number" && Math.random() > sampleRate) {
        return utils_1.SyncPromise.reject(new utils_1.SentryError("Discarding event because it's not included in the random sample (sampling rate = " + sampleRate + ")"));
      }
      return this._prepareEvent(event, scope, hint).then(function(prepared) {
        if (prepared === null) {
          throw new utils_1.SentryError("An event processor returned null, will not send event.");
        }
        var isInternalException = hint && hint.data && hint.data.__sentry__ === true;
        if (isInternalException || isTransaction || !beforeSend) {
          return prepared;
        }
        var beforeSendResult = beforeSend(prepared, hint);
        if (typeof beforeSendResult === "undefined") {
          throw new utils_1.SentryError("`beforeSend` method has to return `null` or a valid event.");
        } else if (utils_1.isThenable(beforeSendResult)) {
          return beforeSendResult.then(function(event2) {
            return event2;
          }, function(e) {
            throw new utils_1.SentryError("beforeSend rejected with " + e);
          });
        }
        return beforeSendResult;
      }).then(function(processedEvent) {
        if (processedEvent === null) {
          throw new utils_1.SentryError("`beforeSend` returned `null`, will not send event.");
        }
        var session = scope && scope.getSession && scope.getSession();
        if (!isTransaction && session) {
          _this._updateSessionFromEvent(session, processedEvent);
        }
        _this._sendEvent(processedEvent);
        return processedEvent;
      }).then(null, function(reason) {
        if (reason instanceof utils_1.SentryError) {
          throw reason;
        }
        _this.captureException(reason, {
          data: {
            __sentry__: true
          },
          originalException: reason
        });
        throw new utils_1.SentryError("Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\nReason: " + reason);
      });
    };
    BaseClient2.prototype._process = function(promise) {
      var _this = this;
      this._processing += 1;
      promise.then(function(value) {
        _this._processing -= 1;
        return value;
      }, function(reason) {
        _this._processing -= 1;
        return reason;
      });
    };
    return BaseClient2;
  }();
  exports2.BaseClient = BaseClient;
});

// ../../node_modules/.pnpm/@sentry+core@6.2.5/node_modules/@sentry/core/dist/transports/noop.js
var require_noop = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var types_1 = require_dist16();
  var utils_1 = require_dist17();
  var NoopTransport = function() {
    function NoopTransport2() {
    }
    NoopTransport2.prototype.sendEvent = function(_2) {
      return utils_1.SyncPromise.resolve({
        reason: "NoopTransport: Event has been skipped because no Dsn is configured.",
        status: types_1.Status.Skipped
      });
    };
    NoopTransport2.prototype.close = function(_2) {
      return utils_1.SyncPromise.resolve(true);
    };
    return NoopTransport2;
  }();
  exports2.NoopTransport = NoopTransport;
});

// ../../node_modules/.pnpm/@sentry+core@6.2.5/node_modules/@sentry/core/dist/basebackend.js
var require_basebackend = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var utils_1 = require_dist17();
  var noop_1 = require_noop();
  var BaseBackend = function() {
    function BaseBackend2(options) {
      this._options = options;
      if (!this._options.dsn) {
        utils_1.logger.warn("No DSN provided, backend will not do anything.");
      }
      this._transport = this._setupTransport();
    }
    BaseBackend2.prototype.eventFromException = function(_exception, _hint) {
      throw new utils_1.SentryError("Backend has to implement `eventFromException` method");
    };
    BaseBackend2.prototype.eventFromMessage = function(_message, _level, _hint) {
      throw new utils_1.SentryError("Backend has to implement `eventFromMessage` method");
    };
    BaseBackend2.prototype.sendEvent = function(event) {
      this._transport.sendEvent(event).then(null, function(reason) {
        utils_1.logger.error("Error while sending event: " + reason);
      });
    };
    BaseBackend2.prototype.sendSession = function(session) {
      if (!this._transport.sendSession) {
        utils_1.logger.warn("Dropping session because custom transport doesn't implement sendSession");
        return;
      }
      this._transport.sendSession(session).then(null, function(reason) {
        utils_1.logger.error("Error while sending session: " + reason);
      });
    };
    BaseBackend2.prototype.getTransport = function() {
      return this._transport;
    };
    BaseBackend2.prototype._setupTransport = function() {
      return new noop_1.NoopTransport();
    };
    return BaseBackend2;
  }();
  exports2.BaseBackend = BaseBackend;
});

// ../../node_modules/.pnpm/@sentry+core@6.2.5/node_modules/@sentry/core/dist/request.js
var require_request2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib_1 = require_tslib();
  function getSdkMetadataForEnvelopeHeader(api) {
    if (!api.metadata || !api.metadata.sdk) {
      return;
    }
    var _a = api.metadata.sdk, name = _a.name, version = _a.version;
    return {name, version};
  }
  function enhanceEventWithSdkInfo(event, sdkInfo) {
    if (!sdkInfo) {
      return event;
    }
    event.sdk = event.sdk || {
      name: sdkInfo.name,
      version: sdkInfo.version
    };
    event.sdk.name = event.sdk.name || sdkInfo.name;
    event.sdk.version = event.sdk.version || sdkInfo.version;
    event.sdk.integrations = tslib_1.__spread(event.sdk.integrations || [], sdkInfo.integrations || []);
    event.sdk.packages = tslib_1.__spread(event.sdk.packages || [], sdkInfo.packages || []);
    return event;
  }
  function sessionToSentryRequest(session, api) {
    var sdkInfo = getSdkMetadataForEnvelopeHeader(api);
    var envelopeHeaders = JSON.stringify(tslib_1.__assign({sent_at: new Date().toISOString()}, sdkInfo && {sdk: sdkInfo}));
    var itemHeaders = JSON.stringify({
      type: "session"
    });
    return {
      body: envelopeHeaders + "\n" + itemHeaders + "\n" + JSON.stringify(session),
      type: "session",
      url: api.getEnvelopeEndpointWithUrlEncodedAuth()
    };
  }
  exports2.sessionToSentryRequest = sessionToSentryRequest;
  function eventToSentryRequest(event, api) {
    var sdkInfo = getSdkMetadataForEnvelopeHeader(api);
    var eventType = event.type || "event";
    var useEnvelope = eventType === "transaction";
    var _a = event.debug_meta || {}, transactionSampling = _a.transactionSampling, metadata = tslib_1.__rest(_a, ["transactionSampling"]);
    var _b = transactionSampling || {}, samplingMethod = _b.method, sampleRate = _b.rate;
    if (Object.keys(metadata).length === 0) {
      delete event.debug_meta;
    } else {
      event.debug_meta = metadata;
    }
    var req = {
      body: JSON.stringify(sdkInfo ? enhanceEventWithSdkInfo(event, api.metadata.sdk) : event),
      type: eventType,
      url: useEnvelope ? api.getEnvelopeEndpointWithUrlEncodedAuth() : api.getStoreEndpointWithUrlEncodedAuth()
    };
    if (useEnvelope) {
      var envelopeHeaders = JSON.stringify(tslib_1.__assign({event_id: event.event_id, sent_at: new Date().toISOString()}, sdkInfo && {sdk: sdkInfo}));
      var itemHeaders = JSON.stringify({
        type: event.type,
        sample_rates: [{id: samplingMethod, rate: sampleRate}]
      });
      var envelope = envelopeHeaders + "\n" + itemHeaders + "\n" + req.body;
      req.body = envelope;
    }
    return req;
  }
  exports2.eventToSentryRequest = eventToSentryRequest;
});

// ../../node_modules/.pnpm/@sentry+core@6.2.5/node_modules/@sentry/core/dist/sdk.js
var require_sdk = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var hub_1 = require_dist18();
  var utils_1 = require_dist17();
  function initAndBind(clientClass, options) {
    if (options.debug === true) {
      utils_1.logger.enable();
    }
    var hub = hub_1.getCurrentHub();
    var client = new clientClass(options);
    hub.bindClient(client);
  }
  exports2.initAndBind = initAndBind;
});

// ../../node_modules/.pnpm/@sentry+core@6.2.5/node_modules/@sentry/core/dist/version.js
var require_version = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.SDK_VERSION = "6.2.5";
});

// ../../node_modules/.pnpm/@sentry+core@6.2.5/node_modules/@sentry/core/dist/integrations/functiontostring.js
var require_functiontostring = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var originalFunctionToString;
  var FunctionToString = function() {
    function FunctionToString2() {
      this.name = FunctionToString2.id;
    }
    FunctionToString2.prototype.setupOnce = function() {
      originalFunctionToString = Function.prototype.toString;
      Function.prototype.toString = function() {
        var args2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args2[_i] = arguments[_i];
        }
        var context = this.__sentry_original__ || this;
        return originalFunctionToString.apply(context, args2);
      };
    };
    FunctionToString2.id = "FunctionToString";
    return FunctionToString2;
  }();
  exports2.FunctionToString = FunctionToString;
});

// ../../node_modules/.pnpm/@sentry+core@6.2.5/node_modules/@sentry/core/dist/integrations/inboundfilters.js
var require_inboundfilters = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib_1 = require_tslib();
  var hub_1 = require_dist18();
  var utils_1 = require_dist17();
  var DEFAULT_IGNORE_ERRORS = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/];
  var InboundFilters = function() {
    function InboundFilters2(_options) {
      if (_options === void 0) {
        _options = {};
      }
      this._options = _options;
      this.name = InboundFilters2.id;
    }
    InboundFilters2.prototype.setupOnce = function() {
      hub_1.addGlobalEventProcessor(function(event) {
        var hub = hub_1.getCurrentHub();
        if (!hub) {
          return event;
        }
        var self2 = hub.getIntegration(InboundFilters2);
        if (self2) {
          var client = hub.getClient();
          var clientOptions = client ? client.getOptions() : {};
          var options = self2._mergeOptions(clientOptions);
          if (self2._shouldDropEvent(event, options)) {
            return null;
          }
        }
        return event;
      });
    };
    InboundFilters2.prototype._shouldDropEvent = function(event, options) {
      if (this._isSentryError(event, options)) {
        utils_1.logger.warn("Event dropped due to being internal Sentry Error.\nEvent: " + utils_1.getEventDescription(event));
        return true;
      }
      if (this._isIgnoredError(event, options)) {
        utils_1.logger.warn("Event dropped due to being matched by `ignoreErrors` option.\nEvent: " + utils_1.getEventDescription(event));
        return true;
      }
      if (this._isDeniedUrl(event, options)) {
        utils_1.logger.warn("Event dropped due to being matched by `denyUrls` option.\nEvent: " + utils_1.getEventDescription(event) + ".\nUrl: " + this._getEventFilterUrl(event));
        return true;
      }
      if (!this._isAllowedUrl(event, options)) {
        utils_1.logger.warn("Event dropped due to not being matched by `allowUrls` option.\nEvent: " + utils_1.getEventDescription(event) + ".\nUrl: " + this._getEventFilterUrl(event));
        return true;
      }
      return false;
    };
    InboundFilters2.prototype._isSentryError = function(event, options) {
      if (!options.ignoreInternal) {
        return false;
      }
      try {
        return event && event.exception && event.exception.values && event.exception.values[0] && event.exception.values[0].type === "SentryError" || false;
      } catch (_oO) {
        return false;
      }
    };
    InboundFilters2.prototype._isIgnoredError = function(event, options) {
      if (!options.ignoreErrors || !options.ignoreErrors.length) {
        return false;
      }
      return this._getPossibleEventMessages(event).some(function(message) {
        return options.ignoreErrors.some(function(pattern) {
          return utils_1.isMatchingPattern(message, pattern);
        });
      });
    };
    InboundFilters2.prototype._isDeniedUrl = function(event, options) {
      if (!options.denyUrls || !options.denyUrls.length) {
        return false;
      }
      var url = this._getEventFilterUrl(event);
      return !url ? false : options.denyUrls.some(function(pattern) {
        return utils_1.isMatchingPattern(url, pattern);
      });
    };
    InboundFilters2.prototype._isAllowedUrl = function(event, options) {
      if (!options.allowUrls || !options.allowUrls.length) {
        return true;
      }
      var url = this._getEventFilterUrl(event);
      return !url ? true : options.allowUrls.some(function(pattern) {
        return utils_1.isMatchingPattern(url, pattern);
      });
    };
    InboundFilters2.prototype._mergeOptions = function(clientOptions) {
      if (clientOptions === void 0) {
        clientOptions = {};
      }
      return {
        allowUrls: tslib_1.__spread(this._options.whitelistUrls || [], this._options.allowUrls || [], clientOptions.whitelistUrls || [], clientOptions.allowUrls || []),
        denyUrls: tslib_1.__spread(this._options.blacklistUrls || [], this._options.denyUrls || [], clientOptions.blacklistUrls || [], clientOptions.denyUrls || []),
        ignoreErrors: tslib_1.__spread(this._options.ignoreErrors || [], clientOptions.ignoreErrors || [], DEFAULT_IGNORE_ERRORS),
        ignoreInternal: typeof this._options.ignoreInternal !== "undefined" ? this._options.ignoreInternal : true
      };
    };
    InboundFilters2.prototype._getPossibleEventMessages = function(event) {
      if (event.message) {
        return [event.message];
      }
      if (event.exception) {
        try {
          var _a = event.exception.values && event.exception.values[0] || {}, _b = _a.type, type = _b === void 0 ? "" : _b, _c = _a.value, value = _c === void 0 ? "" : _c;
          return ["" + value, type + ": " + value];
        } catch (oO) {
          utils_1.logger.error("Cannot extract message for event " + utils_1.getEventDescription(event));
          return [];
        }
      }
      return [];
    };
    InboundFilters2.prototype._getEventFilterUrl = function(event) {
      try {
        if (event.stacktrace) {
          var frames_1 = event.stacktrace.frames;
          return frames_1 && frames_1[frames_1.length - 1].filename || null;
        }
        if (event.exception) {
          var frames_2 = event.exception.values && event.exception.values[0].stacktrace && event.exception.values[0].stacktrace.frames;
          return frames_2 && frames_2[frames_2.length - 1].filename || null;
        }
        return null;
      } catch (oO) {
        utils_1.logger.error("Cannot extract url for event " + utils_1.getEventDescription(event));
        return null;
      }
    };
    InboundFilters2.id = "InboundFilters";
    return InboundFilters2;
  }();
  exports2.InboundFilters = InboundFilters;
});

// ../../node_modules/.pnpm/@sentry+core@6.2.5/node_modules/@sentry/core/dist/integrations/index.js
var require_integrations = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var functiontostring_1 = require_functiontostring();
  exports2.FunctionToString = functiontostring_1.FunctionToString;
  var inboundfilters_1 = require_inboundfilters();
  exports2.InboundFilters = inboundfilters_1.InboundFilters;
});

// ../../node_modules/.pnpm/@sentry+core@6.2.5/node_modules/@sentry/core/dist/index.js
var require_dist20 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var minimal_1 = require_dist19();
  exports2.addBreadcrumb = minimal_1.addBreadcrumb;
  exports2.captureException = minimal_1.captureException;
  exports2.captureEvent = minimal_1.captureEvent;
  exports2.captureMessage = minimal_1.captureMessage;
  exports2.configureScope = minimal_1.configureScope;
  exports2.startTransaction = minimal_1.startTransaction;
  exports2.setContext = minimal_1.setContext;
  exports2.setExtra = minimal_1.setExtra;
  exports2.setExtras = minimal_1.setExtras;
  exports2.setTag = minimal_1.setTag;
  exports2.setTags = minimal_1.setTags;
  exports2.setUser = minimal_1.setUser;
  exports2.withScope = minimal_1.withScope;
  var hub_1 = require_dist18();
  exports2.addGlobalEventProcessor = hub_1.addGlobalEventProcessor;
  exports2.getCurrentHub = hub_1.getCurrentHub;
  exports2.getHubFromCarrier = hub_1.getHubFromCarrier;
  exports2.Hub = hub_1.Hub;
  exports2.makeMain = hub_1.makeMain;
  exports2.Scope = hub_1.Scope;
  var api_1 = require_api();
  exports2.API = api_1.API;
  var baseclient_1 = require_baseclient();
  exports2.BaseClient = baseclient_1.BaseClient;
  var basebackend_1 = require_basebackend();
  exports2.BaseBackend = basebackend_1.BaseBackend;
  var request_1 = require_request2();
  exports2.eventToSentryRequest = request_1.eventToSentryRequest;
  exports2.sessionToSentryRequest = request_1.sessionToSentryRequest;
  var sdk_1 = require_sdk();
  exports2.initAndBind = sdk_1.initAndBind;
  var noop_1 = require_noop();
  exports2.NoopTransport = noop_1.NoopTransport;
  var version_1 = require_version();
  exports2.SDK_VERSION = version_1.SDK_VERSION;
  var Integrations = require_integrations();
  exports2.Integrations = Integrations;
});

// ../../node_modules/.pnpm/lru_map@0.3.3/node_modules/lru_map/lru.js
var require_lru = __commonJS((exports2) => {
  (function(g, f) {
    const e = typeof exports2 == "object" ? exports2 : typeof g == "object" ? g : {};
    f(e);
    if (typeof define == "function" && define.amd) {
      define("lru", e);
    }
  })(exports2, function(exports3) {
    const NEWER = Symbol("newer");
    const OLDER = Symbol("older");
    function LRUMap(limit, entries) {
      if (typeof limit !== "number") {
        entries = limit;
        limit = 0;
      }
      this.size = 0;
      this.limit = limit;
      this.oldest = this.newest = void 0;
      this._keymap = new Map();
      if (entries) {
        this.assign(entries);
        if (limit < 1) {
          this.limit = this.size;
        }
      }
    }
    exports3.LRUMap = LRUMap;
    function Entry(key, value) {
      this.key = key;
      this.value = value;
      this[NEWER] = void 0;
      this[OLDER] = void 0;
    }
    LRUMap.prototype._markEntryAsUsed = function(entry) {
      if (entry === this.newest) {
        return;
      }
      if (entry[NEWER]) {
        if (entry === this.oldest) {
          this.oldest = entry[NEWER];
        }
        entry[NEWER][OLDER] = entry[OLDER];
      }
      if (entry[OLDER]) {
        entry[OLDER][NEWER] = entry[NEWER];
      }
      entry[NEWER] = void 0;
      entry[OLDER] = this.newest;
      if (this.newest) {
        this.newest[NEWER] = entry;
      }
      this.newest = entry;
    };
    LRUMap.prototype.assign = function(entries) {
      let entry, limit = this.limit || Number.MAX_VALUE;
      this._keymap.clear();
      let it = entries[Symbol.iterator]();
      for (let itv = it.next(); !itv.done; itv = it.next()) {
        let e = new Entry(itv.value[0], itv.value[1]);
        this._keymap.set(e.key, e);
        if (!entry) {
          this.oldest = e;
        } else {
          entry[NEWER] = e;
          e[OLDER] = entry;
        }
        entry = e;
        if (limit-- == 0) {
          throw new Error("overflow");
        }
      }
      this.newest = entry;
      this.size = this._keymap.size;
    };
    LRUMap.prototype.get = function(key) {
      var entry = this._keymap.get(key);
      if (!entry)
        return;
      this._markEntryAsUsed(entry);
      return entry.value;
    };
    LRUMap.prototype.set = function(key, value) {
      var entry = this._keymap.get(key);
      if (entry) {
        entry.value = value;
        this._markEntryAsUsed(entry);
        return this;
      }
      this._keymap.set(key, entry = new Entry(key, value));
      if (this.newest) {
        this.newest[NEWER] = entry;
        entry[OLDER] = this.newest;
      } else {
        this.oldest = entry;
      }
      this.newest = entry;
      ++this.size;
      if (this.size > this.limit) {
        this.shift();
      }
      return this;
    };
    LRUMap.prototype.shift = function() {
      var entry = this.oldest;
      if (entry) {
        if (this.oldest[NEWER]) {
          this.oldest = this.oldest[NEWER];
          this.oldest[OLDER] = void 0;
        } else {
          this.oldest = void 0;
          this.newest = void 0;
        }
        entry[NEWER] = entry[OLDER] = void 0;
        this._keymap.delete(entry.key);
        --this.size;
        return [entry.key, entry.value];
      }
    };
    LRUMap.prototype.find = function(key) {
      let e = this._keymap.get(key);
      return e ? e.value : void 0;
    };
    LRUMap.prototype.has = function(key) {
      return this._keymap.has(key);
    };
    LRUMap.prototype["delete"] = function(key) {
      var entry = this._keymap.get(key);
      if (!entry)
        return;
      this._keymap.delete(entry.key);
      if (entry[NEWER] && entry[OLDER]) {
        entry[OLDER][NEWER] = entry[NEWER];
        entry[NEWER][OLDER] = entry[OLDER];
      } else if (entry[NEWER]) {
        entry[NEWER][OLDER] = void 0;
        this.oldest = entry[NEWER];
      } else if (entry[OLDER]) {
        entry[OLDER][NEWER] = void 0;
        this.newest = entry[OLDER];
      } else {
        this.oldest = this.newest = void 0;
      }
      this.size--;
      return entry.value;
    };
    LRUMap.prototype.clear = function() {
      this.oldest = this.newest = void 0;
      this.size = 0;
      this._keymap.clear();
    };
    function EntryIterator(oldestEntry) {
      this.entry = oldestEntry;
    }
    EntryIterator.prototype[Symbol.iterator] = function() {
      return this;
    };
    EntryIterator.prototype.next = function() {
      let ent = this.entry;
      if (ent) {
        this.entry = ent[NEWER];
        return {done: false, value: [ent.key, ent.value]};
      } else {
        return {done: true, value: void 0};
      }
    };
    function KeyIterator(oldestEntry) {
      this.entry = oldestEntry;
    }
    KeyIterator.prototype[Symbol.iterator] = function() {
      return this;
    };
    KeyIterator.prototype.next = function() {
      let ent = this.entry;
      if (ent) {
        this.entry = ent[NEWER];
        return {done: false, value: ent.key};
      } else {
        return {done: true, value: void 0};
      }
    };
    function ValueIterator(oldestEntry) {
      this.entry = oldestEntry;
    }
    ValueIterator.prototype[Symbol.iterator] = function() {
      return this;
    };
    ValueIterator.prototype.next = function() {
      let ent = this.entry;
      if (ent) {
        this.entry = ent[NEWER];
        return {done: false, value: ent.value};
      } else {
        return {done: true, value: void 0};
      }
    };
    LRUMap.prototype.keys = function() {
      return new KeyIterator(this.oldest);
    };
    LRUMap.prototype.values = function() {
      return new ValueIterator(this.oldest);
    };
    LRUMap.prototype.entries = function() {
      return this;
    };
    LRUMap.prototype[Symbol.iterator] = function() {
      return new EntryIterator(this.oldest);
    };
    LRUMap.prototype.forEach = function(fun, thisObj) {
      if (typeof thisObj !== "object") {
        thisObj = this;
      }
      let entry = this.oldest;
      while (entry) {
        fun.call(thisObj, entry.value, entry.key, this);
        entry = entry[NEWER];
      }
    };
    LRUMap.prototype.toJSON = function() {
      var s2 = new Array(this.size), i = 0, entry = this.oldest;
      while (entry) {
        s2[i++] = {key: entry.key, value: entry.value};
        entry = entry[NEWER];
      }
      return s2;
    };
    LRUMap.prototype.toString = function() {
      var s2 = "", entry = this.oldest;
      while (entry) {
        s2 += String(entry.key) + ":" + entry.value;
        entry = entry[NEWER];
        if (entry) {
          s2 += " < ";
        }
      }
      return s2;
    };
  });
});

// ../../node_modules/.pnpm/@sentry+node@6.2.5/node_modules/@sentry/node/dist/stacktrace.js
var require_stacktrace2 = __commonJS((exports2) => {
  /**
   * stack-trace - Parses node.js stack traces
   *
   * This was originally forked to fix this issue:
   * https://github.com/felixge/node-stack-trace/issues/31
   *
   * Mar 19,2019 - #4fd379e
   *
   * https://github.com/felixge/node-stack-trace/
   * @license MIT
   */
  Object.defineProperty(exports2, "__esModule", {value: true});
  function parse2(err) {
    if (!err.stack) {
      return [];
    }
    var lines = err.stack.split("\n").slice(1);
    return lines.map(function(line) {
      if (line.match(/^\s*[-]{4,}$/)) {
        return {
          columnNumber: null,
          fileName: line,
          functionName: null,
          lineNumber: null,
          methodName: null,
          native: null,
          typeName: null
        };
      }
      var lineMatch = line.match(/at (?:(.+?)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/);
      if (!lineMatch) {
        return void 0;
      }
      var object = null;
      var method = null;
      var functionName = null;
      var typeName = null;
      var methodName = null;
      var isNative = lineMatch[5] === "native";
      if (lineMatch[1]) {
        functionName = lineMatch[1];
        var methodStart = functionName.lastIndexOf(".");
        if (functionName[methodStart - 1] === ".") {
          methodStart--;
        }
        if (methodStart > 0) {
          object = functionName.substr(0, methodStart);
          method = functionName.substr(methodStart + 1);
          var objectEnd = object.indexOf(".Module");
          if (objectEnd > 0) {
            functionName = functionName.substr(objectEnd + 1);
            object = object.substr(0, objectEnd);
          }
        }
        typeName = null;
      }
      if (method) {
        typeName = object;
        methodName = method;
      }
      if (method === "<anonymous>") {
        methodName = null;
        functionName = null;
      }
      var properties = {
        columnNumber: parseInt(lineMatch[4], 10) || null,
        fileName: lineMatch[2] || null,
        functionName,
        lineNumber: parseInt(lineMatch[3], 10) || null,
        methodName,
        native: isNative,
        typeName
      };
      return properties;
    }).filter(function(callSite) {
      return !!callSite;
    });
  }
  exports2.parse = parse2;
});

// ../../node_modules/.pnpm/@sentry+node@6.2.5/node_modules/@sentry/node/dist/parsers.js
var require_parsers = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var utils_1 = require_dist17();
  var fs_12 = require("fs");
  var lru_map_1 = require_lru();
  var stacktrace = require_stacktrace2();
  var DEFAULT_LINES_OF_CONTEXT = 7;
  var FILE_CONTENT_CACHE = new lru_map_1.LRUMap(100);
  function resetFileContentCache() {
    FILE_CONTENT_CACHE.clear();
  }
  exports2.resetFileContentCache = resetFileContentCache;
  function getFunction(frame) {
    try {
      return frame.functionName || frame.typeName + "." + (frame.methodName || "<anonymous>");
    } catch (e) {
      return "<anonymous>";
    }
  }
  var mainModule = (require.main && require.main.filename && utils_1.dirname(require.main.filename) || global.process.cwd()) + "/";
  function getModule(filename, base) {
    if (!base) {
      base = mainModule;
    }
    var file = utils_1.basename(filename, ".js");
    filename = utils_1.dirname(filename);
    var n = filename.lastIndexOf("/node_modules/");
    if (n > -1) {
      return filename.substr(n + 14).replace(/\//g, ".") + ":" + file;
    }
    n = (filename + "/").lastIndexOf(base, 0);
    if (n === 0) {
      var moduleName = filename.substr(base.length).replace(/\//g, ".");
      if (moduleName) {
        moduleName += ":";
      }
      moduleName += file;
      return moduleName;
    }
    return file;
  }
  function readSourceFiles(filenames) {
    if (filenames.length === 0) {
      return utils_1.SyncPromise.resolve({});
    }
    return new utils_1.SyncPromise(function(resolve) {
      var sourceFiles = {};
      var count = 0;
      var _loop_1 = function(i2) {
        var filename = filenames[i2];
        var cache = FILE_CONTENT_CACHE.get(filename);
        if (cache !== void 0) {
          if (cache !== null) {
            sourceFiles[filename] = cache;
          }
          count++;
          if (count === filenames.length) {
            resolve(sourceFiles);
          }
          return "continue";
        }
        fs_12.readFile(filename, function(err, data) {
          var content = err ? null : data.toString();
          sourceFiles[filename] = content;
          FILE_CONTENT_CACHE.set(filename, content);
          count++;
          if (count === filenames.length) {
            resolve(sourceFiles);
          }
        });
      };
      for (var i = 0; i < filenames.length; i++) {
        _loop_1(i);
      }
    });
  }
  function extractStackFromError(error) {
    var stack = stacktrace.parse(error);
    if (!stack) {
      return [];
    }
    return stack;
  }
  exports2.extractStackFromError = extractStackFromError;
  function parseStack(stack, options) {
    var filesToRead = [];
    var linesOfContext = options && options.frameContextLines !== void 0 ? options.frameContextLines : DEFAULT_LINES_OF_CONTEXT;
    var frames = stack.map(function(frame) {
      var _a;
      var parsedFrame = {
        colno: frame.columnNumber,
        filename: ((_a = frame.fileName) === null || _a === void 0 ? void 0 : _a.startsWith("file://")) ? frame.fileName.substr(7) : frame.fileName || "",
        function: getFunction(frame),
        lineno: frame.lineNumber
      };
      var isInternal = frame.native || parsedFrame.filename && !parsedFrame.filename.startsWith("/") && !parsedFrame.filename.startsWith(".") && parsedFrame.filename.indexOf(":\\") !== 1;
      parsedFrame.in_app = !isInternal && parsedFrame.filename !== void 0 && parsedFrame.filename.indexOf("node_modules/") === -1;
      if (parsedFrame.filename) {
        parsedFrame.module = getModule(parsedFrame.filename);
        if (!isInternal && linesOfContext > 0 && filesToRead.indexOf(parsedFrame.filename) === -1) {
          filesToRead.push(parsedFrame.filename);
        }
      }
      return parsedFrame;
    });
    if (linesOfContext <= 0) {
      return utils_1.SyncPromise.resolve(frames);
    }
    try {
      return addPrePostContext(filesToRead, frames, linesOfContext);
    } catch (_2) {
      return utils_1.SyncPromise.resolve(frames);
    }
  }
  exports2.parseStack = parseStack;
  function addPrePostContext(filesToRead, frames, linesOfContext) {
    return new utils_1.SyncPromise(function(resolve) {
      return readSourceFiles(filesToRead).then(function(sourceFiles) {
        var result = frames.map(function(frame) {
          if (frame.filename && sourceFiles[frame.filename]) {
            try {
              var lines = sourceFiles[frame.filename].split("\n");
              utils_1.addContextToFrame(lines, frame, linesOfContext);
            } catch (e) {
            }
          }
          return frame;
        });
        resolve(result);
      });
    });
  }
  function getExceptionFromError(error, options) {
    var name = error.name || error.constructor.name;
    var stack = extractStackFromError(error);
    return new utils_1.SyncPromise(function(resolve) {
      return parseStack(stack, options).then(function(frames) {
        var result = {
          stacktrace: {
            frames: prepareFramesForEvent(frames)
          },
          type: name,
          value: error.message
        };
        resolve(result);
      });
    });
  }
  exports2.getExceptionFromError = getExceptionFromError;
  function parseError(error, options) {
    return new utils_1.SyncPromise(function(resolve) {
      return getExceptionFromError(error, options).then(function(exception) {
        resolve({
          exception: {
            values: [exception]
          }
        });
      });
    });
  }
  exports2.parseError = parseError;
  function prepareFramesForEvent(stack) {
    if (!stack || !stack.length) {
      return [];
    }
    var localStack = stack;
    var firstFrameFunction = localStack[0].function || "";
    if (firstFrameFunction.indexOf("captureMessage") !== -1 || firstFrameFunction.indexOf("captureException") !== -1) {
      localStack = localStack.slice(1);
    }
    return localStack.reverse();
  }
  exports2.prepareFramesForEvent = prepareFramesForEvent;
});

// ../../node_modules/.pnpm/@sentry+node@6.2.5/node_modules/@sentry/node/dist/version.js
var require_version2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.SDK_NAME = "sentry.javascript.node";
});

// ../../node_modules/.pnpm/@sentry+node@6.2.5/node_modules/@sentry/node/dist/transports/base.js
var require_base = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib_1 = require_tslib();
  var core_1 = require_dist20();
  var types_1 = require_dist16();
  var utils_1 = require_dist17();
  var fs9 = require("fs");
  var url = require("url");
  var version_1 = require_version2();
  var BaseTransport = function() {
    function BaseTransport2(options) {
      this.options = options;
      this._buffer = new utils_1.PromiseBuffer(30);
      this._disabledUntil = new Date(Date.now());
      this._api = new core_1.API(options.dsn, options._metadata);
    }
    BaseTransport2.prototype.sendEvent = function(_2) {
      throw new utils_1.SentryError("Transport Class has to implement `sendEvent` method.");
    };
    BaseTransport2.prototype.close = function(timeout) {
      return this._buffer.drain(timeout);
    };
    BaseTransport2.prototype._getRequestOptions = function(uri) {
      var headers = tslib_1.__assign(tslib_1.__assign({}, this._api.getRequestHeaders(version_1.SDK_NAME, core_1.SDK_VERSION)), this.options.headers);
      var hostname = uri.hostname, pathname = uri.pathname, port = uri.port, protocol = uri.protocol;
      var path10 = "" + pathname;
      return tslib_1.__assign({
        agent: this.client,
        headers,
        hostname,
        method: "POST",
        path: path10,
        port,
        protocol
      }, this.options.caCerts && {
        ca: fs9.readFileSync(this.options.caCerts)
      });
    };
    BaseTransport2.prototype._sendWithModule = function(httpModule, event) {
      return tslib_1.__awaiter(this, void 0, void 0, function() {
        var _this = this;
        return tslib_1.__generator(this, function(_a) {
          if (new Date(Date.now()) < this._disabledUntil) {
            return [2, Promise.reject(new utils_1.SentryError("Transport locked till " + this._disabledUntil + " due to too many requests."))];
          }
          if (!this._buffer.isReady()) {
            return [2, Promise.reject(new utils_1.SentryError("Not adding Promise due to buffer limit reached."))];
          }
          return [2, this._buffer.add(new Promise(function(resolve, reject) {
            var sentryReq = core_1.eventToSentryRequest(event, _this._api);
            var options = _this._getRequestOptions(new url.URL(sentryReq.url));
            var req = httpModule.request(options, function(res) {
              var statusCode = res.statusCode || 500;
              var status = types_1.Status.fromHttpCode(statusCode);
              res.setEncoding("utf8");
              if (status === types_1.Status.Success) {
                resolve({status});
              } else {
                if (status === types_1.Status.RateLimit) {
                  var now = Date.now();
                  var retryAfterHeader = res.headers ? res.headers["retry-after"] : "";
                  retryAfterHeader = Array.isArray(retryAfterHeader) ? retryAfterHeader[0] : retryAfterHeader;
                  _this._disabledUntil = new Date(now + utils_1.parseRetryAfterHeader(now, retryAfterHeader));
                  utils_1.logger.warn("Too many requests, backing off till: " + _this._disabledUntil);
                }
                var rejectionMessage = "HTTP Error (" + statusCode + ")";
                if (res.headers && res.headers["x-sentry-error"]) {
                  rejectionMessage += ": " + res.headers["x-sentry-error"];
                }
                reject(new utils_1.SentryError(rejectionMessage));
              }
              res.on("data", function() {
              });
              res.on("end", function() {
              });
            });
            req.on("error", reject);
            req.end(sentryReq.body);
          }))];
        });
      });
    };
    return BaseTransport2;
  }();
  exports2.BaseTransport = BaseTransport;
});

// ../../node_modules/.pnpm/@sentry+node@6.2.5/node_modules/@sentry/node/dist/transports/http.js
var require_http = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib_1 = require_tslib();
  var utils_1 = require_dist17();
  var http = require("http");
  var base_1 = require_base();
  var HTTPTransport = function(_super) {
    tslib_1.__extends(HTTPTransport2, _super);
    function HTTPTransport2(options) {
      var _this = _super.call(this, options) || this;
      _this.options = options;
      var proxy = options.httpProxy || process.env.http_proxy;
      _this.module = http;
      _this.client = proxy ? new (require_dist5())(proxy) : new http.Agent({keepAlive: false, maxSockets: 30, timeout: 2e3});
      return _this;
    }
    HTTPTransport2.prototype.sendEvent = function(event) {
      if (!this.module) {
        throw new utils_1.SentryError("No module available in HTTPTransport");
      }
      return this._sendWithModule(this.module, event);
    };
    return HTTPTransport2;
  }(base_1.BaseTransport);
  exports2.HTTPTransport = HTTPTransport;
});

// ../../node_modules/.pnpm/@sentry+node@6.2.5/node_modules/@sentry/node/dist/transports/https.js
var require_https = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib_1 = require_tslib();
  var utils_1 = require_dist17();
  var https = require("https");
  var base_1 = require_base();
  var HTTPSTransport = function(_super) {
    tslib_1.__extends(HTTPSTransport2, _super);
    function HTTPSTransport2(options) {
      var _this = _super.call(this, options) || this;
      _this.options = options;
      var proxy = options.httpsProxy || options.httpProxy || process.env.https_proxy || process.env.http_proxy;
      _this.module = https;
      _this.client = proxy ? new (require_dist5())(proxy) : new https.Agent({keepAlive: false, maxSockets: 30, timeout: 2e3});
      return _this;
    }
    HTTPSTransport2.prototype.sendEvent = function(event) {
      if (!this.module) {
        throw new utils_1.SentryError("No module available in HTTPSTransport");
      }
      return this._sendWithModule(this.module, event);
    };
    return HTTPSTransport2;
  }(base_1.BaseTransport);
  exports2.HTTPSTransport = HTTPSTransport;
});

// ../../node_modules/.pnpm/@sentry+node@6.2.5/node_modules/@sentry/node/dist/transports/index.js
var require_transports = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var base_1 = require_base();
  exports2.BaseTransport = base_1.BaseTransport;
  var http_1 = require_http();
  exports2.HTTPTransport = http_1.HTTPTransport;
  var https_1 = require_https();
  exports2.HTTPSTransport = https_1.HTTPSTransport;
});

// ../../node_modules/.pnpm/@sentry+node@6.2.5/node_modules/@sentry/node/dist/backend.js
var require_backend = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib_1 = require_tslib();
  var core_1 = require_dist20();
  var types_1 = require_dist16();
  var utils_1 = require_dist17();
  var parsers_1 = require_parsers();
  var transports_1 = require_transports();
  var NodeBackend = function(_super) {
    tslib_1.__extends(NodeBackend2, _super);
    function NodeBackend2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    NodeBackend2.prototype.eventFromException = function(exception, hint) {
      var _this = this;
      var ex = exception;
      var mechanism = {
        handled: true,
        type: "generic"
      };
      if (!utils_1.isError(exception)) {
        if (utils_1.isPlainObject(exception)) {
          var message = "Non-Error exception captured with keys: " + utils_1.extractExceptionKeysForMessage(exception);
          core_1.getCurrentHub().configureScope(function(scope) {
            scope.setExtra("__serialized__", utils_1.normalizeToSize(exception));
          });
          ex = hint && hint.syntheticException || new Error(message);
          ex.message = message;
        } else {
          ex = hint && hint.syntheticException || new Error(exception);
          ex.message = exception;
        }
        mechanism.synthetic = true;
      }
      return new utils_1.SyncPromise(function(resolve, reject) {
        return parsers_1.parseError(ex, _this._options).then(function(event) {
          utils_1.addExceptionTypeValue(event, void 0, void 0);
          utils_1.addExceptionMechanism(event, mechanism);
          resolve(tslib_1.__assign(tslib_1.__assign({}, event), {event_id: hint && hint.event_id}));
        }).then(null, reject);
      });
    };
    NodeBackend2.prototype.eventFromMessage = function(message, level, hint) {
      var _this = this;
      if (level === void 0) {
        level = types_1.Severity.Info;
      }
      var event = {
        event_id: hint && hint.event_id,
        level,
        message
      };
      return new utils_1.SyncPromise(function(resolve) {
        if (_this._options.attachStacktrace && hint && hint.syntheticException) {
          var stack = hint.syntheticException ? parsers_1.extractStackFromError(hint.syntheticException) : [];
          parsers_1.parseStack(stack, _this._options).then(function(frames) {
            event.stacktrace = {
              frames: parsers_1.prepareFramesForEvent(frames)
            };
            resolve(event);
          }).then(null, function() {
            resolve(event);
          });
        } else {
          resolve(event);
        }
      });
    };
    NodeBackend2.prototype._setupTransport = function() {
      if (!this._options.dsn) {
        return _super.prototype._setupTransport.call(this);
      }
      var dsn = new utils_1.Dsn(this._options.dsn);
      var transportOptions = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, this._options.transportOptions), this._options.httpProxy && {httpProxy: this._options.httpProxy}), this._options.httpsProxy && {httpsProxy: this._options.httpsProxy}), this._options.caCerts && {caCerts: this._options.caCerts}), {dsn: this._options.dsn, _metadata: this._options._metadata});
      if (this._options.transport) {
        return new this._options.transport(transportOptions);
      }
      if (dsn.protocol === "http") {
        return new transports_1.HTTPTransport(transportOptions);
      }
      return new transports_1.HTTPSTransport(transportOptions);
    };
    return NodeBackend2;
  }(core_1.BaseBackend);
  exports2.NodeBackend = NodeBackend;
});

// ../../node_modules/.pnpm/@sentry+node@6.2.5/node_modules/@sentry/node/dist/client.js
var require_client2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib_1 = require_tslib();
  var core_1 = require_dist20();
  var backend_1 = require_backend();
  var NodeClient = function(_super) {
    tslib_1.__extends(NodeClient2, _super);
    function NodeClient2(options) {
      var _this = this;
      options._metadata = options._metadata || {};
      options._metadata.sdk = options._metadata.sdk || {
        name: "sentry.javascript.node",
        packages: [
          {
            name: "npm:@sentry/node",
            version: core_1.SDK_VERSION
          }
        ],
        version: core_1.SDK_VERSION
      };
      _this = _super.call(this, backend_1.NodeBackend, options) || this;
      return _this;
    }
    NodeClient2.prototype._prepareEvent = function(event, scope, hint) {
      event.platform = event.platform || "node";
      if (this.getOptions().serverName) {
        event.server_name = this.getOptions().serverName;
      }
      return _super.prototype._prepareEvent.call(this, event, scope, hint);
    };
    return NodeClient2;
  }(core_1.BaseClient);
  exports2.NodeClient = NodeClient;
});

// ../../node_modules/.pnpm/@sentry+node@6.2.5/node_modules/@sentry/node/dist/integrations/console.js
var require_console = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib_1 = require_tslib();
  var core_1 = require_dist20();
  var types_1 = require_dist16();
  var utils_1 = require_dist17();
  var util2 = require("util");
  var Console = function() {
    function Console2() {
      this.name = Console2.id;
    }
    Console2.prototype.setupOnce = function() {
      var e_1, _a;
      var consoleModule = require("console");
      try {
        for (var _b = tslib_1.__values(["debug", "info", "warn", "error", "log"]), _c = _b.next(); !_c.done; _c = _b.next()) {
          var level = _c.value;
          utils_1.fill(consoleModule, level, createConsoleWrapper(level));
        }
      } catch (e_1_1) {
        e_1 = {error: e_1_1};
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    };
    Console2.id = "Console";
    return Console2;
  }();
  exports2.Console = Console;
  function createConsoleWrapper(level) {
    return function consoleWrapper(originalConsoleMethod) {
      var sentryLevel;
      switch (level) {
        case "debug":
          sentryLevel = types_1.Severity.Debug;
          break;
        case "error":
          sentryLevel = types_1.Severity.Error;
          break;
        case "info":
          sentryLevel = types_1.Severity.Info;
          break;
        case "warn":
          sentryLevel = types_1.Severity.Warning;
          break;
        default:
          sentryLevel = types_1.Severity.Log;
      }
      return function() {
        if (core_1.getCurrentHub().getIntegration(Console)) {
          core_1.getCurrentHub().addBreadcrumb({
            category: "console",
            level: sentryLevel,
            message: util2.format.apply(void 0, arguments)
          }, {
            input: tslib_1.__spread(arguments),
            level
          });
        }
        originalConsoleMethod.apply(this, arguments);
      };
    };
  }
});

// ../../node_modules/.pnpm/@sentry+node@6.2.5/node_modules/@sentry/node/dist/integrations/utils/http.js
var require_http2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib_1 = require_tslib();
  var core_1 = require_dist20();
  var url_1 = require("url");
  function isSentryRequest(url) {
    var _a;
    var dsn = (_a = core_1.getCurrentHub().getClient()) === null || _a === void 0 ? void 0 : _a.getDsn();
    return dsn ? url.includes(dsn.host) : false;
  }
  exports2.isSentryRequest = isSentryRequest;
  function extractUrl(requestOptions) {
    var protocol = requestOptions.protocol || "";
    var hostname = requestOptions.hostname || requestOptions.host || "";
    var port = !requestOptions.port || requestOptions.port === 80 || requestOptions.port === 443 ? "" : ":" + requestOptions.port;
    var path10 = requestOptions.path ? requestOptions.path : "/";
    return protocol + "//" + hostname + port + path10;
  }
  exports2.extractUrl = extractUrl;
  function cleanSpanDescription(description, requestOptions, request) {
    var _a, _b, _c;
    if (!description) {
      return description;
    }
    var _d = tslib_1.__read(description.split(" "), 2), method = _d[0], requestUrl = _d[1];
    if (requestOptions.host && !requestOptions.protocol) {
      requestOptions.protocol = (_b = (_a = request) === null || _a === void 0 ? void 0 : _a.agent) === null || _b === void 0 ? void 0 : _b.protocol;
      requestUrl = extractUrl(requestOptions);
    }
    if ((_c = requestUrl) === null || _c === void 0 ? void 0 : _c.startsWith("///")) {
      requestUrl = requestUrl.slice(2);
    }
    return method + " " + requestUrl;
  }
  exports2.cleanSpanDescription = cleanSpanDescription;
  function urlToOptions(url) {
    var options = {
      protocol: url.protocol,
      hostname: typeof url.hostname === "string" && url.hostname.startsWith("[") ? url.hostname.slice(1, -1) : url.hostname,
      hash: url.hash,
      search: url.search,
      pathname: url.pathname,
      path: "" + (url.pathname || "") + (url.search || ""),
      href: url.href
    };
    if (url.port !== "") {
      options.port = Number(url.port);
    }
    if (url.username || url.password) {
      options.auth = url.username + ":" + url.password;
    }
    return options;
  }
  exports2.urlToOptions = urlToOptions;
  function normalizeRequestArgs(requestArgs) {
    var callback, requestOptions;
    if (typeof requestArgs[requestArgs.length - 1] === "function") {
      callback = requestArgs.pop();
    }
    if (typeof requestArgs[0] === "string") {
      requestOptions = urlToOptions(new url_1.URL(requestArgs[0]));
    } else if (requestArgs[0] instanceof url_1.URL) {
      requestOptions = urlToOptions(requestArgs[0]);
    } else {
      requestOptions = requestArgs[0];
    }
    if (requestArgs.length === 2) {
      requestOptions = tslib_1.__assign(tslib_1.__assign({}, requestOptions), requestArgs[1]);
    }
    if (callback) {
      return [requestOptions, callback];
    } else {
      return [requestOptions];
    }
  }
  exports2.normalizeRequestArgs = normalizeRequestArgs;
});

// ../../node_modules/.pnpm/@sentry+node@6.2.5/node_modules/@sentry/node/dist/integrations/http.js
var require_http3 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib_1 = require_tslib();
  var core_1 = require_dist20();
  var utils_1 = require_dist17();
  var http_1 = require_http2();
  var NODE_VERSION = utils_1.parseSemver(process.versions.node);
  var Http = function() {
    function Http2(options) {
      if (options === void 0) {
        options = {};
      }
      this.name = Http2.id;
      this._breadcrumbs = typeof options.breadcrumbs === "undefined" ? true : options.breadcrumbs;
      this._tracing = typeof options.tracing === "undefined" ? false : options.tracing;
    }
    Http2.prototype.setupOnce = function() {
      if (!this._breadcrumbs && !this._tracing) {
        return;
      }
      var wrappedHandlerMaker = _createWrappedRequestMethodFactory(this._breadcrumbs, this._tracing);
      var httpModule = require("http");
      utils_1.fill(httpModule, "get", wrappedHandlerMaker);
      utils_1.fill(httpModule, "request", wrappedHandlerMaker);
      if (NODE_VERSION.major && NODE_VERSION.major > 8) {
        var httpsModule = require("https");
        utils_1.fill(httpsModule, "get", wrappedHandlerMaker);
        utils_1.fill(httpsModule, "request", wrappedHandlerMaker);
      }
    };
    Http2.id = "Http";
    return Http2;
  }();
  exports2.Http = Http;
  function _createWrappedRequestMethodFactory(breadcrumbsEnabled, tracingEnabled) {
    return function wrappedRequestMethodFactory(originalRequestMethod) {
      return function wrappedMethod() {
        var args2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args2[_i] = arguments[_i];
        }
        var httpModule = this;
        var requestArgs = http_1.normalizeRequestArgs(args2);
        var requestOptions = requestArgs[0];
        var requestUrl = http_1.extractUrl(requestOptions);
        if (http_1.isSentryRequest(requestUrl)) {
          return originalRequestMethod.apply(httpModule, requestArgs);
        }
        var span;
        var parentSpan;
        var scope = core_1.getCurrentHub().getScope();
        if (scope && tracingEnabled) {
          parentSpan = scope.getSpan();
          if (parentSpan) {
            span = parentSpan.startChild({
              description: (requestOptions.method || "GET") + " " + requestUrl,
              op: "request"
            });
            var sentryTraceHeader = span.toTraceparent();
            utils_1.logger.log("[Tracing] Adding sentry-trace header to outgoing request: " + sentryTraceHeader);
            requestOptions.headers = tslib_1.__assign(tslib_1.__assign({}, requestOptions.headers), {"sentry-trace": sentryTraceHeader});
          }
        }
        return originalRequestMethod.apply(httpModule, requestArgs).once("response", function(res) {
          var req = this;
          if (breadcrumbsEnabled) {
            addRequestBreadcrumb("response", requestUrl, req, res);
          }
          if (tracingEnabled && span) {
            if (res.statusCode) {
              span.setHttpStatus(res.statusCode);
            }
            span.description = http_1.cleanSpanDescription(span.description, requestOptions, req);
            span.finish();
          }
        }).once("error", function() {
          var req = this;
          if (breadcrumbsEnabled) {
            addRequestBreadcrumb("error", requestUrl, req);
          }
          if (tracingEnabled && span) {
            span.setHttpStatus(500);
            span.description = http_1.cleanSpanDescription(span.description, requestOptions, req);
            span.finish();
          }
        });
      };
    };
  }
  function addRequestBreadcrumb(event, url, req, res) {
    if (!core_1.getCurrentHub().getIntegration(Http)) {
      return;
    }
    core_1.getCurrentHub().addBreadcrumb({
      category: "http",
      data: {
        method: req.method,
        status_code: res && res.statusCode,
        url
      },
      type: "http"
    }, {
      event,
      request: req,
      response: res
    });
  }
});

// ../../node_modules/.pnpm/@sentry+node@6.2.5/node_modules/@sentry/node/dist/integrations/utils/errorhandling.js
var require_errorhandling = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var core_1 = require_dist20();
  var utils_1 = require_dist17();
  var DEFAULT_SHUTDOWN_TIMEOUT = 2e3;
  function logAndExitProcess(error) {
    console.error(error && error.stack ? error.stack : error);
    var client = core_1.getCurrentHub().getClient();
    if (client === void 0) {
      utils_1.logger.warn("No NodeClient was defined, we are exiting the process now.");
      global.process.exit(1);
      return;
    }
    var options = client.getOptions();
    var timeout = options && options.shutdownTimeout && options.shutdownTimeout > 0 && options.shutdownTimeout || DEFAULT_SHUTDOWN_TIMEOUT;
    utils_1.forget(client.close(timeout).then(function(result) {
      if (!result) {
        utils_1.logger.warn("We reached the timeout for emptying the request buffer, still exiting now!");
      }
      global.process.exit(1);
    }));
  }
  exports2.logAndExitProcess = logAndExitProcess;
});

// ../../node_modules/.pnpm/@sentry+node@6.2.5/node_modules/@sentry/node/dist/integrations/onuncaughtexception.js
var require_onuncaughtexception = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var core_1 = require_dist20();
  var types_1 = require_dist16();
  var utils_1 = require_dist17();
  var errorhandling_1 = require_errorhandling();
  var OnUncaughtException = function() {
    function OnUncaughtException2(_options) {
      if (_options === void 0) {
        _options = {};
      }
      this._options = _options;
      this.name = OnUncaughtException2.id;
      this.handler = this._makeErrorHandler();
    }
    OnUncaughtException2.prototype.setupOnce = function() {
      global.process.on("uncaughtException", this.handler.bind(this));
    };
    OnUncaughtException2.prototype._makeErrorHandler = function() {
      var _this = this;
      var timeout = 2e3;
      var caughtFirstError = false;
      var caughtSecondError = false;
      var calledFatalError = false;
      var firstError;
      return function(error) {
        var onFatalError = errorhandling_1.logAndExitProcess;
        var client = core_1.getCurrentHub().getClient();
        if (_this._options.onFatalError) {
          onFatalError = _this._options.onFatalError;
        } else if (client && client.getOptions().onFatalError) {
          onFatalError = client.getOptions().onFatalError;
        }
        if (!caughtFirstError) {
          var hub_1 = core_1.getCurrentHub();
          firstError = error;
          caughtFirstError = true;
          if (hub_1.getIntegration(OnUncaughtException2)) {
            hub_1.withScope(function(scope) {
              scope.setLevel(types_1.Severity.Fatal);
              hub_1.captureException(error, {originalException: error});
              if (!calledFatalError) {
                calledFatalError = true;
                onFatalError(error);
              }
            });
          } else {
            if (!calledFatalError) {
              calledFatalError = true;
              onFatalError(error);
            }
          }
        } else if (calledFatalError) {
          utils_1.logger.warn("uncaught exception after calling fatal error shutdown callback - this is bad! forcing shutdown");
          errorhandling_1.logAndExitProcess(error);
        } else if (!caughtSecondError) {
          caughtSecondError = true;
          setTimeout(function() {
            if (!calledFatalError) {
              calledFatalError = true;
              onFatalError(firstError, error);
            } else {
            }
          }, timeout);
        }
      };
    };
    OnUncaughtException2.id = "OnUncaughtException";
    return OnUncaughtException2;
  }();
  exports2.OnUncaughtException = OnUncaughtException;
});

// ../../node_modules/.pnpm/@sentry+node@6.2.5/node_modules/@sentry/node/dist/integrations/onunhandledrejection.js
var require_onunhandledrejection = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var core_1 = require_dist20();
  var utils_1 = require_dist17();
  var errorhandling_1 = require_errorhandling();
  var OnUnhandledRejection = function() {
    function OnUnhandledRejection2(_options) {
      if (_options === void 0) {
        _options = {mode: "warn"};
      }
      this._options = _options;
      this.name = OnUnhandledRejection2.id;
    }
    OnUnhandledRejection2.prototype.setupOnce = function() {
      global.process.on("unhandledRejection", this.sendUnhandledPromise.bind(this));
    };
    OnUnhandledRejection2.prototype.sendUnhandledPromise = function(reason, promise) {
      var hub = core_1.getCurrentHub();
      if (!hub.getIntegration(OnUnhandledRejection2)) {
        this._handleRejection(reason);
        return;
      }
      var context = promise.domain && promise.domain.sentryContext || {};
      hub.withScope(function(scope) {
        scope.setExtra("unhandledPromiseRejection", true);
        if (context.user) {
          scope.setUser(context.user);
        }
        if (context.tags) {
          scope.setTags(context.tags);
        }
        if (context.extra) {
          scope.setExtras(context.extra);
        }
        hub.captureException(reason, {originalException: promise});
      });
      this._handleRejection(reason);
    };
    OnUnhandledRejection2.prototype._handleRejection = function(reason) {
      var rejectionWarning = "This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason:";
      if (this._options.mode === "warn") {
        utils_1.consoleSandbox(function() {
          console.warn(rejectionWarning);
          console.error(reason && reason.stack ? reason.stack : reason);
        });
      } else if (this._options.mode === "strict") {
        utils_1.consoleSandbox(function() {
          console.warn(rejectionWarning);
        });
        errorhandling_1.logAndExitProcess(reason);
      }
    };
    OnUnhandledRejection2.id = "OnUnhandledRejection";
    return OnUnhandledRejection2;
  }();
  exports2.OnUnhandledRejection = OnUnhandledRejection;
});

// ../../node_modules/.pnpm/@sentry+node@6.2.5/node_modules/@sentry/node/dist/integrations/linkederrors.js
var require_linkederrors = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib_1 = require_tslib();
  var core_1 = require_dist20();
  var utils_1 = require_dist17();
  var parsers_1 = require_parsers();
  var DEFAULT_KEY = "cause";
  var DEFAULT_LIMIT = 5;
  var LinkedErrors = function() {
    function LinkedErrors2(options) {
      if (options === void 0) {
        options = {};
      }
      this.name = LinkedErrors2.id;
      this._key = options.key || DEFAULT_KEY;
      this._limit = options.limit || DEFAULT_LIMIT;
    }
    LinkedErrors2.prototype.setupOnce = function() {
      core_1.addGlobalEventProcessor(function(event, hint) {
        var self2 = core_1.getCurrentHub().getIntegration(LinkedErrors2);
        if (self2) {
          var handler = self2._handler && self2._handler.bind(self2);
          return typeof handler === "function" ? handler(event, hint) : event;
        }
        return event;
      });
    };
    LinkedErrors2.prototype._handler = function(event, hint) {
      var _this = this;
      if (!event.exception || !event.exception.values || !hint || !utils_1.isInstanceOf(hint.originalException, Error)) {
        return utils_1.SyncPromise.resolve(event);
      }
      return new utils_1.SyncPromise(function(resolve) {
        _this._walkErrorTree(hint.originalException, _this._key).then(function(linkedErrors) {
          if (event && event.exception && event.exception.values) {
            event.exception.values = tslib_1.__spread(linkedErrors, event.exception.values);
          }
          resolve(event);
        }).then(null, function() {
          resolve(event);
        });
      });
    };
    LinkedErrors2.prototype._walkErrorTree = function(error, key, stack) {
      var _this = this;
      if (stack === void 0) {
        stack = [];
      }
      if (!utils_1.isInstanceOf(error[key], Error) || stack.length + 1 >= this._limit) {
        return utils_1.SyncPromise.resolve(stack);
      }
      return new utils_1.SyncPromise(function(resolve, reject) {
        parsers_1.getExceptionFromError(error[key]).then(function(exception) {
          _this._walkErrorTree(error[key], key, tslib_1.__spread([exception], stack)).then(resolve).then(null, function() {
            reject();
          });
        }).then(null, function() {
          reject();
        });
      });
    };
    LinkedErrors2.id = "LinkedErrors";
    return LinkedErrors2;
  }();
  exports2.LinkedErrors = LinkedErrors;
});

// ../../node_modules/.pnpm/@sentry+node@6.2.5/node_modules/@sentry/node/dist/integrations/modules.js
var require_modules = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib_1 = require_tslib();
  var fs_12 = require("fs");
  var path_12 = require("path");
  var moduleCache;
  function getPaths() {
    try {
      return require.cache ? Object.keys(require.cache) : [];
    } catch (e) {
      return [];
    }
  }
  function collectModules() {
    var mainPaths = require.main && require.main.paths || [];
    var paths = getPaths();
    var infos = {};
    var seen = {};
    paths.forEach(function(path10) {
      var dir = path10;
      var updir = function() {
        var orig = dir;
        dir = path_12.dirname(orig);
        if (!dir || orig === dir || seen[orig]) {
          return void 0;
        }
        if (mainPaths.indexOf(dir) < 0) {
          return updir();
        }
        var pkgfile = path_12.join(orig, "package.json");
        seen[orig] = true;
        if (!fs_12.existsSync(pkgfile)) {
          return updir();
        }
        try {
          var info = JSON.parse(fs_12.readFileSync(pkgfile, "utf8"));
          infos[info.name] = info.version;
        } catch (_oO) {
        }
      };
      updir();
    });
    return infos;
  }
  var Modules = function() {
    function Modules2() {
      this.name = Modules2.id;
    }
    Modules2.prototype.setupOnce = function(addGlobalEventProcessor, getCurrentHub) {
      var _this = this;
      addGlobalEventProcessor(function(event) {
        if (!getCurrentHub().getIntegration(Modules2)) {
          return event;
        }
        return tslib_1.__assign(tslib_1.__assign({}, event), {modules: _this._getModules()});
      });
    };
    Modules2.prototype._getModules = function() {
      if (!moduleCache) {
        moduleCache = collectModules();
      }
      return moduleCache;
    };
    Modules2.id = "Modules";
    return Modules2;
  }();
  exports2.Modules = Modules;
});

// ../../node_modules/.pnpm/@sentry+node@6.2.5/node_modules/@sentry/node/dist/integrations/index.js
var require_integrations2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var console_1 = require_console();
  exports2.Console = console_1.Console;
  var http_1 = require_http3();
  exports2.Http = http_1.Http;
  var onuncaughtexception_1 = require_onuncaughtexception();
  exports2.OnUncaughtException = onuncaughtexception_1.OnUncaughtException;
  var onunhandledrejection_1 = require_onunhandledrejection();
  exports2.OnUnhandledRejection = onunhandledrejection_1.OnUnhandledRejection;
  var linkederrors_1 = require_linkederrors();
  exports2.LinkedErrors = linkederrors_1.LinkedErrors;
  var modules_1 = require_modules();
  exports2.Modules = modules_1.Modules;
});

// ../../node_modules/.pnpm/@sentry+node@6.2.5/node_modules/@sentry/node/dist/sdk.js
var require_sdk2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib_1 = require_tslib();
  var core_1 = require_dist20();
  var hub_1 = require_dist18();
  var utils_1 = require_dist17();
  var domain = require("domain");
  var client_1 = require_client2();
  var integrations_1 = require_integrations2();
  exports2.defaultIntegrations = [
    new core_1.Integrations.InboundFilters(),
    new core_1.Integrations.FunctionToString(),
    new integrations_1.Console(),
    new integrations_1.Http(),
    new integrations_1.OnUncaughtException(),
    new integrations_1.OnUnhandledRejection(),
    new integrations_1.LinkedErrors()
  ];
  function init(options) {
    if (options === void 0) {
      options = {};
    }
    if (options.defaultIntegrations === void 0) {
      options.defaultIntegrations = exports2.defaultIntegrations;
    }
    if (options.dsn === void 0 && process.env.SENTRY_DSN) {
      options.dsn = process.env.SENTRY_DSN;
    }
    if (options.tracesSampleRate === void 0 && process.env.SENTRY_TRACES_SAMPLE_RATE) {
      var tracesSampleRate = parseFloat(process.env.SENTRY_TRACES_SAMPLE_RATE);
      if (isFinite(tracesSampleRate)) {
        options.tracesSampleRate = tracesSampleRate;
      }
    }
    if (options.release === void 0) {
      var global_1 = utils_1.getGlobalObject();
      if (process.env.SENTRY_RELEASE) {
        options.release = process.env.SENTRY_RELEASE;
      } else if (global_1.SENTRY_RELEASE && global_1.SENTRY_RELEASE.id) {
        options.release = global_1.SENTRY_RELEASE.id;
      }
    }
    if (options.environment === void 0 && process.env.SENTRY_ENVIRONMENT) {
      options.environment = process.env.SENTRY_ENVIRONMENT;
    }
    if (domain.active) {
      hub_1.setHubOnCarrier(hub_1.getMainCarrier(), core_1.getCurrentHub());
    }
    core_1.initAndBind(client_1.NodeClient, options);
  }
  exports2.init = init;
  function lastEventId() {
    return core_1.getCurrentHub().lastEventId();
  }
  exports2.lastEventId = lastEventId;
  function flush(timeout) {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var client;
      return tslib_1.__generator(this, function(_a) {
        client = core_1.getCurrentHub().getClient();
        if (client) {
          return [2, client.flush(timeout)];
        }
        return [2, Promise.reject(false)];
      });
    });
  }
  exports2.flush = flush;
  function close2(timeout) {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var client;
      return tslib_1.__generator(this, function(_a) {
        client = core_1.getCurrentHub().getClient();
        if (client) {
          return [2, client.close(timeout)];
        }
        return [2, Promise.reject(false)];
      });
    });
  }
  exports2.close = close2;
});

// ../../node_modules/.pnpm/@sentry+tracing@6.2.5/node_modules/@sentry/tracing/dist/spanstatus.js
var require_spanstatus = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var SpanStatus;
  (function(SpanStatus2) {
    SpanStatus2["Ok"] = "ok";
    SpanStatus2["DeadlineExceeded"] = "deadline_exceeded";
    SpanStatus2["Unauthenticated"] = "unauthenticated";
    SpanStatus2["PermissionDenied"] = "permission_denied";
    SpanStatus2["NotFound"] = "not_found";
    SpanStatus2["ResourceExhausted"] = "resource_exhausted";
    SpanStatus2["InvalidArgument"] = "invalid_argument";
    SpanStatus2["Unimplemented"] = "unimplemented";
    SpanStatus2["Unavailable"] = "unavailable";
    SpanStatus2["InternalError"] = "internal_error";
    SpanStatus2["UnknownError"] = "unknown_error";
    SpanStatus2["Cancelled"] = "cancelled";
    SpanStatus2["AlreadyExists"] = "already_exists";
    SpanStatus2["FailedPrecondition"] = "failed_precondition";
    SpanStatus2["Aborted"] = "aborted";
    SpanStatus2["OutOfRange"] = "out_of_range";
    SpanStatus2["DataLoss"] = "data_loss";
  })(SpanStatus = exports2.SpanStatus || (exports2.SpanStatus = {}));
  (function(SpanStatus2) {
    function fromHttpCode(httpStatus) {
      if (httpStatus < 400) {
        return SpanStatus2.Ok;
      }
      if (httpStatus >= 400 && httpStatus < 500) {
        switch (httpStatus) {
          case 401:
            return SpanStatus2.Unauthenticated;
          case 403:
            return SpanStatus2.PermissionDenied;
          case 404:
            return SpanStatus2.NotFound;
          case 409:
            return SpanStatus2.AlreadyExists;
          case 413:
            return SpanStatus2.FailedPrecondition;
          case 429:
            return SpanStatus2.ResourceExhausted;
          default:
            return SpanStatus2.InvalidArgument;
        }
      }
      if (httpStatus >= 500 && httpStatus < 600) {
        switch (httpStatus) {
          case 501:
            return SpanStatus2.Unimplemented;
          case 503:
            return SpanStatus2.Unavailable;
          case 504:
            return SpanStatus2.DeadlineExceeded;
          default:
            return SpanStatus2.InternalError;
        }
      }
      return SpanStatus2.UnknownError;
    }
    SpanStatus2.fromHttpCode = fromHttpCode;
  })(SpanStatus = exports2.SpanStatus || (exports2.SpanStatus = {}));
});

// ../../node_modules/.pnpm/@sentry+tracing@6.2.5/node_modules/@sentry/tracing/dist/utils.js
var require_utils6 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var hub_1 = require_dist18();
  exports2.TRACEPARENT_REGEXP = new RegExp("^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$");
  function hasTracingEnabled(options) {
    return "tracesSampleRate" in options || "tracesSampler" in options;
  }
  exports2.hasTracingEnabled = hasTracingEnabled;
  function extractTraceparentData(traceparent) {
    var matches = traceparent.match(exports2.TRACEPARENT_REGEXP);
    if (matches) {
      var parentSampled = void 0;
      if (matches[3] === "1") {
        parentSampled = true;
      } else if (matches[3] === "0") {
        parentSampled = false;
      }
      return {
        traceId: matches[1],
        parentSampled,
        parentSpanId: matches[2]
      };
    }
    return void 0;
  }
  exports2.extractTraceparentData = extractTraceparentData;
  function getActiveTransaction(hub) {
    if (hub === void 0) {
      hub = hub_1.getCurrentHub();
    }
    var _a, _b;
    return (_b = (_a = hub) === null || _a === void 0 ? void 0 : _a.getScope()) === null || _b === void 0 ? void 0 : _b.getTransaction();
  }
  exports2.getActiveTransaction = getActiveTransaction;
  function msToSec(time) {
    return time / 1e3;
  }
  exports2.msToSec = msToSec;
  function secToMs(time) {
    return time * 1e3;
  }
  exports2.secToMs = secToMs;
  var utils_1 = require_dist17();
  exports2.stripUrlQueryAndFragment = utils_1.stripUrlQueryAndFragment;
});

// ../../node_modules/.pnpm/@sentry+tracing@6.2.5/node_modules/@sentry/tracing/dist/errors.js
var require_errors4 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var utils_1 = require_dist17();
  var spanstatus_1 = require_spanstatus();
  var utils_2 = require_utils6();
  function registerErrorInstrumentation() {
    utils_1.addInstrumentationHandler({
      callback: errorCallback,
      type: "error"
    });
    utils_1.addInstrumentationHandler({
      callback: errorCallback,
      type: "unhandledrejection"
    });
  }
  exports2.registerErrorInstrumentation = registerErrorInstrumentation;
  function errorCallback() {
    var activeTransaction = utils_2.getActiveTransaction();
    if (activeTransaction) {
      utils_1.logger.log("[Tracing] Transaction: " + spanstatus_1.SpanStatus.InternalError + " -> Global error occured");
      activeTransaction.setStatus(spanstatus_1.SpanStatus.InternalError);
    }
  }
});

// ../../node_modules/.pnpm/@sentry+tracing@6.2.5/node_modules/@sentry/tracing/dist/span.js
var require_span = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib_1 = require_tslib();
  var utils_1 = require_dist17();
  var spanstatus_1 = require_spanstatus();
  var SpanRecorder = function() {
    function SpanRecorder2(maxlen) {
      if (maxlen === void 0) {
        maxlen = 1e3;
      }
      this.spans = [];
      this._maxlen = maxlen;
    }
    SpanRecorder2.prototype.add = function(span) {
      if (this.spans.length > this._maxlen) {
        span.spanRecorder = void 0;
      } else {
        this.spans.push(span);
      }
    };
    return SpanRecorder2;
  }();
  exports2.SpanRecorder = SpanRecorder;
  var Span = function() {
    function Span2(spanContext) {
      this.traceId = utils_1.uuid4();
      this.spanId = utils_1.uuid4().substring(16);
      this.startTimestamp = utils_1.timestampWithMs();
      this.tags = {};
      this.data = {};
      if (!spanContext) {
        return this;
      }
      if (spanContext.traceId) {
        this.traceId = spanContext.traceId;
      }
      if (spanContext.spanId) {
        this.spanId = spanContext.spanId;
      }
      if (spanContext.parentSpanId) {
        this.parentSpanId = spanContext.parentSpanId;
      }
      if ("sampled" in spanContext) {
        this.sampled = spanContext.sampled;
      }
      if (spanContext.op) {
        this.op = spanContext.op;
      }
      if (spanContext.description) {
        this.description = spanContext.description;
      }
      if (spanContext.data) {
        this.data = spanContext.data;
      }
      if (spanContext.tags) {
        this.tags = spanContext.tags;
      }
      if (spanContext.status) {
        this.status = spanContext.status;
      }
      if (spanContext.startTimestamp) {
        this.startTimestamp = spanContext.startTimestamp;
      }
      if (spanContext.endTimestamp) {
        this.endTimestamp = spanContext.endTimestamp;
      }
    }
    Span2.prototype.child = function(spanContext) {
      return this.startChild(spanContext);
    };
    Span2.prototype.startChild = function(spanContext) {
      var childSpan = new Span2(tslib_1.__assign(tslib_1.__assign({}, spanContext), {parentSpanId: this.spanId, sampled: this.sampled, traceId: this.traceId}));
      childSpan.spanRecorder = this.spanRecorder;
      if (childSpan.spanRecorder) {
        childSpan.spanRecorder.add(childSpan);
      }
      childSpan.transaction = this.transaction;
      return childSpan;
    };
    Span2.prototype.setTag = function(key, value) {
      var _a;
      this.tags = tslib_1.__assign(tslib_1.__assign({}, this.tags), (_a = {}, _a[key] = value, _a));
      return this;
    };
    Span2.prototype.setData = function(key, value) {
      var _a;
      this.data = tslib_1.__assign(tslib_1.__assign({}, this.data), (_a = {}, _a[key] = value, _a));
      return this;
    };
    Span2.prototype.setStatus = function(value) {
      this.status = value;
      return this;
    };
    Span2.prototype.setHttpStatus = function(httpStatus) {
      this.setTag("http.status_code", String(httpStatus));
      var spanStatus = spanstatus_1.SpanStatus.fromHttpCode(httpStatus);
      if (spanStatus !== spanstatus_1.SpanStatus.UnknownError) {
        this.setStatus(spanStatus);
      }
      return this;
    };
    Span2.prototype.isSuccess = function() {
      return this.status === spanstatus_1.SpanStatus.Ok;
    };
    Span2.prototype.finish = function(endTimestamp) {
      this.endTimestamp = typeof endTimestamp === "number" ? endTimestamp : utils_1.timestampWithMs();
    };
    Span2.prototype.toTraceparent = function() {
      var sampledString = "";
      if (this.sampled !== void 0) {
        sampledString = this.sampled ? "-1" : "-0";
      }
      return this.traceId + "-" + this.spanId + sampledString;
    };
    Span2.prototype.toContext = function() {
      return utils_1.dropUndefinedKeys({
        data: this.data,
        description: this.description,
        endTimestamp: this.endTimestamp,
        op: this.op,
        parentSpanId: this.parentSpanId,
        sampled: this.sampled,
        spanId: this.spanId,
        startTimestamp: this.startTimestamp,
        status: this.status,
        tags: this.tags,
        traceId: this.traceId
      });
    };
    Span2.prototype.updateWithContext = function(spanContext) {
      var _a, _b, _c, _d, _e;
      this.data = (_a = spanContext.data, _a !== null && _a !== void 0 ? _a : {});
      this.description = spanContext.description;
      this.endTimestamp = spanContext.endTimestamp;
      this.op = spanContext.op;
      this.parentSpanId = spanContext.parentSpanId;
      this.sampled = spanContext.sampled;
      this.spanId = (_b = spanContext.spanId, _b !== null && _b !== void 0 ? _b : this.spanId);
      this.startTimestamp = (_c = spanContext.startTimestamp, _c !== null && _c !== void 0 ? _c : this.startTimestamp);
      this.status = spanContext.status;
      this.tags = (_d = spanContext.tags, _d !== null && _d !== void 0 ? _d : {});
      this.traceId = (_e = spanContext.traceId, _e !== null && _e !== void 0 ? _e : this.traceId);
      return this;
    };
    Span2.prototype.getTraceContext = function() {
      return utils_1.dropUndefinedKeys({
        data: Object.keys(this.data).length > 0 ? this.data : void 0,
        description: this.description,
        op: this.op,
        parent_span_id: this.parentSpanId,
        span_id: this.spanId,
        status: this.status,
        tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
        trace_id: this.traceId
      });
    };
    Span2.prototype.toJSON = function() {
      return utils_1.dropUndefinedKeys({
        data: Object.keys(this.data).length > 0 ? this.data : void 0,
        description: this.description,
        op: this.op,
        parent_span_id: this.parentSpanId,
        span_id: this.spanId,
        start_timestamp: this.startTimestamp,
        status: this.status,
        tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
        timestamp: this.endTimestamp,
        trace_id: this.traceId
      });
    };
    return Span2;
  }();
  exports2.Span = Span;
});

// ../../node_modules/.pnpm/@sentry+tracing@6.2.5/node_modules/@sentry/tracing/dist/transaction.js
var require_transaction2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib_1 = require_tslib();
  var hub_1 = require_dist18();
  var utils_1 = require_dist17();
  var span_1 = require_span();
  var Transaction = function(_super) {
    tslib_1.__extends(Transaction2, _super);
    function Transaction2(transactionContext, hub) {
      var _this = _super.call(this, transactionContext) || this;
      _this._metadata = {};
      _this._measurements = {};
      _this._hub = hub_1.getCurrentHub();
      if (utils_1.isInstanceOf(hub, hub_1.Hub)) {
        _this._hub = hub;
      }
      _this.name = transactionContext.name || "";
      _this._trimEnd = transactionContext.trimEnd;
      _this.transaction = _this;
      return _this;
    }
    Transaction2.prototype.setName = function(name) {
      this.name = name;
    };
    Transaction2.prototype.initSpanRecorder = function(maxlen) {
      if (maxlen === void 0) {
        maxlen = 1e3;
      }
      if (!this.spanRecorder) {
        this.spanRecorder = new span_1.SpanRecorder(maxlen);
      }
      this.spanRecorder.add(this);
    };
    Transaction2.prototype.setMeasurements = function(measurements) {
      this._measurements = tslib_1.__assign({}, measurements);
    };
    Transaction2.prototype.setMetadata = function(newMetadata) {
      this._metadata = tslib_1.__assign(tslib_1.__assign({}, this._metadata), newMetadata);
    };
    Transaction2.prototype.finish = function(endTimestamp) {
      var _this = this;
      if (this.endTimestamp !== void 0) {
        return void 0;
      }
      if (!this.name) {
        utils_1.logger.warn("Transaction has no name, falling back to `<unlabeled transaction>`.");
        this.name = "<unlabeled transaction>";
      }
      _super.prototype.finish.call(this, endTimestamp);
      if (this.sampled !== true) {
        utils_1.logger.log("[Tracing] Discarding transaction because its trace was not chosen to be sampled.");
        return void 0;
      }
      var finishedSpans = this.spanRecorder ? this.spanRecorder.spans.filter(function(s2) {
        return s2 !== _this && s2.endTimestamp;
      }) : [];
      if (this._trimEnd && finishedSpans.length > 0) {
        this.endTimestamp = finishedSpans.reduce(function(prev, current) {
          if (prev.endTimestamp && current.endTimestamp) {
            return prev.endTimestamp > current.endTimestamp ? prev : current;
          }
          return prev;
        }).endTimestamp;
      }
      var transaction = {
        contexts: {
          trace: this.getTraceContext()
        },
        spans: finishedSpans,
        start_timestamp: this.startTimestamp,
        tags: this.tags,
        timestamp: this.endTimestamp,
        transaction: this.name,
        type: "transaction",
        debug_meta: this._metadata
      };
      var hasMeasurements = Object.keys(this._measurements).length > 0;
      if (hasMeasurements) {
        utils_1.logger.log("[Measurements] Adding measurements to transaction", JSON.stringify(this._measurements, void 0, 2));
        transaction.measurements = this._measurements;
      }
      return this._hub.captureEvent(transaction);
    };
    Transaction2.prototype.toContext = function() {
      var spanContext = _super.prototype.toContext.call(this);
      return utils_1.dropUndefinedKeys(tslib_1.__assign(tslib_1.__assign({}, spanContext), {name: this.name, trimEnd: this._trimEnd}));
    };
    Transaction2.prototype.updateWithContext = function(transactionContext) {
      var _a;
      _super.prototype.updateWithContext.call(this, transactionContext);
      this.name = (_a = transactionContext.name, _a !== null && _a !== void 0 ? _a : "");
      this._trimEnd = transactionContext.trimEnd;
      return this;
    };
    return Transaction2;
  }(span_1.Span);
  exports2.Transaction = Transaction;
});

// ../../node_modules/.pnpm/@sentry+tracing@6.2.5/node_modules/@sentry/tracing/dist/idletransaction.js
var require_idletransaction = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib_1 = require_tslib();
  var utils_1 = require_dist17();
  var span_1 = require_span();
  var spanstatus_1 = require_spanstatus();
  var transaction_1 = require_transaction2();
  exports2.DEFAULT_IDLE_TIMEOUT = 1e3;
  var IdleTransactionSpanRecorder = function(_super) {
    tslib_1.__extends(IdleTransactionSpanRecorder2, _super);
    function IdleTransactionSpanRecorder2(_pushActivity, _popActivity, transactionSpanId, maxlen) {
      if (transactionSpanId === void 0) {
        transactionSpanId = "";
      }
      var _this = _super.call(this, maxlen) || this;
      _this._pushActivity = _pushActivity;
      _this._popActivity = _popActivity;
      _this.transactionSpanId = transactionSpanId;
      return _this;
    }
    IdleTransactionSpanRecorder2.prototype.add = function(span) {
      var _this = this;
      if (span.spanId !== this.transactionSpanId) {
        span.finish = function(endTimestamp) {
          span.endTimestamp = typeof endTimestamp === "number" ? endTimestamp : utils_1.timestampWithMs();
          _this._popActivity(span.spanId);
        };
        if (span.endTimestamp === void 0) {
          this._pushActivity(span.spanId);
        }
      }
      _super.prototype.add.call(this, span);
    };
    return IdleTransactionSpanRecorder2;
  }(span_1.SpanRecorder);
  exports2.IdleTransactionSpanRecorder = IdleTransactionSpanRecorder;
  var IdleTransaction = function(_super) {
    tslib_1.__extends(IdleTransaction2, _super);
    function IdleTransaction2(transactionContext, _idleHub, _idleTimeout, _onScope) {
      if (_idleTimeout === void 0) {
        _idleTimeout = exports2.DEFAULT_IDLE_TIMEOUT;
      }
      if (_onScope === void 0) {
        _onScope = false;
      }
      var _this = _super.call(this, transactionContext, _idleHub) || this;
      _this._idleHub = _idleHub;
      _this._idleTimeout = _idleTimeout;
      _this._onScope = _onScope;
      _this.activities = {};
      _this._heartbeatTimer = 0;
      _this._heartbeatCounter = 0;
      _this._finished = false;
      _this._beforeFinishCallbacks = [];
      if (_idleHub && _onScope) {
        clearActiveTransaction(_idleHub);
        utils_1.logger.log("Setting idle transaction on scope. Span ID: " + _this.spanId);
        _idleHub.configureScope(function(scope) {
          return scope.setSpan(_this);
        });
      }
      _this._initTimeout = setTimeout(function() {
        if (!_this._finished) {
          _this.finish();
        }
      }, _this._idleTimeout);
      return _this;
    }
    IdleTransaction2.prototype.finish = function(endTimestamp) {
      var e_1, _a;
      var _this = this;
      if (endTimestamp === void 0) {
        endTimestamp = utils_1.timestampWithMs();
      }
      this._finished = true;
      this.activities = {};
      if (this.spanRecorder) {
        utils_1.logger.log("[Tracing] finishing IdleTransaction", new Date(endTimestamp * 1e3).toISOString(), this.op);
        try {
          for (var _b = tslib_1.__values(this._beforeFinishCallbacks), _c = _b.next(); !_c.done; _c = _b.next()) {
            var callback = _c.value;
            callback(this, endTimestamp);
          }
        } catch (e_1_1) {
          e_1 = {error: e_1_1};
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        this.spanRecorder.spans = this.spanRecorder.spans.filter(function(span) {
          if (span.spanId === _this.spanId) {
            return true;
          }
          if (!span.endTimestamp) {
            span.endTimestamp = endTimestamp;
            span.setStatus(spanstatus_1.SpanStatus.Cancelled);
            utils_1.logger.log("[Tracing] cancelling span since transaction ended early", JSON.stringify(span, void 0, 2));
          }
          var keepSpan = span.startTimestamp < endTimestamp;
          if (!keepSpan) {
            utils_1.logger.log("[Tracing] discarding Span since it happened after Transaction was finished", JSON.stringify(span, void 0, 2));
          }
          return keepSpan;
        });
        utils_1.logger.log("[Tracing] flushing IdleTransaction");
      } else {
        utils_1.logger.log("[Tracing] No active IdleTransaction");
      }
      if (this._onScope) {
        clearActiveTransaction(this._idleHub);
      }
      return _super.prototype.finish.call(this, endTimestamp);
    };
    IdleTransaction2.prototype.registerBeforeFinishCallback = function(callback) {
      this._beforeFinishCallbacks.push(callback);
    };
    IdleTransaction2.prototype.initSpanRecorder = function(maxlen) {
      var _this = this;
      if (!this.spanRecorder) {
        var pushActivity = function(id) {
          if (_this._finished) {
            return;
          }
          _this._pushActivity(id);
        };
        var popActivity = function(id) {
          if (_this._finished) {
            return;
          }
          _this._popActivity(id);
        };
        this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanId, maxlen);
        utils_1.logger.log("Starting heartbeat");
        this._pingHeartbeat();
      }
      this.spanRecorder.add(this);
    };
    IdleTransaction2.prototype._pushActivity = function(spanId) {
      if (this._initTimeout) {
        clearTimeout(this._initTimeout);
        this._initTimeout = void 0;
      }
      utils_1.logger.log("[Tracing] pushActivity: " + spanId);
      this.activities[spanId] = true;
      utils_1.logger.log("[Tracing] new activities count", Object.keys(this.activities).length);
    };
    IdleTransaction2.prototype._popActivity = function(spanId) {
      var _this = this;
      if (this.activities[spanId]) {
        utils_1.logger.log("[Tracing] popActivity " + spanId);
        delete this.activities[spanId];
        utils_1.logger.log("[Tracing] new activities count", Object.keys(this.activities).length);
      }
      if (Object.keys(this.activities).length === 0) {
        var timeout = this._idleTimeout;
        var end_1 = utils_1.timestampWithMs() + timeout / 1e3;
        setTimeout(function() {
          if (!_this._finished) {
            _this.finish(end_1);
          }
        }, timeout);
      }
    };
    IdleTransaction2.prototype._beat = function() {
      clearTimeout(this._heartbeatTimer);
      if (this._finished) {
        return;
      }
      var keys = Object.keys(this.activities);
      var heartbeatString = keys.length ? keys.reduce(function(prev, current) {
        return prev + current;
      }) : "";
      if (heartbeatString === this._prevHeartbeatString) {
        this._heartbeatCounter += 1;
      } else {
        this._heartbeatCounter = 1;
      }
      this._prevHeartbeatString = heartbeatString;
      if (this._heartbeatCounter >= 3) {
        utils_1.logger.log("[Tracing] Transaction finished because of no change for 3 heart beats");
        this.setStatus(spanstatus_1.SpanStatus.DeadlineExceeded);
        this.setTag("heartbeat", "failed");
        this.finish();
      } else {
        this._pingHeartbeat();
      }
    };
    IdleTransaction2.prototype._pingHeartbeat = function() {
      var _this = this;
      utils_1.logger.log("pinging Heartbeat -> current counter: " + this._heartbeatCounter);
      this._heartbeatTimer = setTimeout(function() {
        _this._beat();
      }, 5e3);
    };
    return IdleTransaction2;
  }(transaction_1.Transaction);
  exports2.IdleTransaction = IdleTransaction;
  function clearActiveTransaction(hub) {
    if (hub) {
      var scope = hub.getScope();
      if (scope) {
        var transaction = scope.getTransaction();
        if (transaction) {
          scope.setSpan(void 0);
        }
      }
    }
  }
});

// ../../node_modules/.pnpm/@sentry+tracing@6.2.5/node_modules/@sentry/tracing/dist/hubextensions.js
var require_hubextensions = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib_1 = require_tslib();
  var hub_1 = require_dist18();
  var types_1 = require_dist16();
  var utils_1 = require_dist17();
  var errors_1 = require_errors4();
  var idletransaction_1 = require_idletransaction();
  var transaction_1 = require_transaction2();
  var utils_2 = require_utils6();
  function traceHeaders() {
    var scope = this.getScope();
    if (scope) {
      var span = scope.getSpan();
      if (span) {
        return {
          "sentry-trace": span.toTraceparent()
        };
      }
    }
    return {};
  }
  function sample(transaction, options, samplingContext) {
    if (!utils_2.hasTracingEnabled(options)) {
      transaction.sampled = false;
      return transaction;
    }
    if (transaction.sampled !== void 0) {
      transaction.setMetadata({
        transactionSampling: {method: types_1.TransactionSamplingMethod.Explicit}
      });
      return transaction;
    }
    var sampleRate;
    if (typeof options.tracesSampler === "function") {
      sampleRate = options.tracesSampler(samplingContext);
      transaction.setMetadata({
        transactionSampling: {
          method: types_1.TransactionSamplingMethod.Sampler,
          rate: Number(sampleRate)
        }
      });
    } else if (samplingContext.parentSampled !== void 0) {
      sampleRate = samplingContext.parentSampled;
      transaction.setMetadata({
        transactionSampling: {method: types_1.TransactionSamplingMethod.Inheritance}
      });
    } else {
      sampleRate = options.tracesSampleRate;
      transaction.setMetadata({
        transactionSampling: {
          method: types_1.TransactionSamplingMethod.Rate,
          rate: Number(sampleRate)
        }
      });
    }
    if (!isValidSampleRate(sampleRate)) {
      utils_1.logger.warn("[Tracing] Discarding transaction because of invalid sample rate.");
      transaction.sampled = false;
      return transaction;
    }
    if (!sampleRate) {
      utils_1.logger.log("[Tracing] Discarding transaction because " + (typeof options.tracesSampler === "function" ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0"));
      transaction.sampled = false;
      return transaction;
    }
    transaction.sampled = Math.random() < sampleRate;
    if (!transaction.sampled) {
      utils_1.logger.log("[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = " + Number(sampleRate) + ")");
      return transaction;
    }
    utils_1.logger.log("[Tracing] starting " + transaction.op + " transaction - " + transaction.name);
    return transaction;
  }
  function isValidSampleRate(rate) {
    if (isNaN(rate) || !(typeof rate === "number" || typeof rate === "boolean")) {
      utils_1.logger.warn("[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got " + JSON.stringify(rate) + " of type " + JSON.stringify(typeof rate) + ".");
      return false;
    }
    if (rate < 0 || rate > 1) {
      utils_1.logger.warn("[Tracing] Given sample rate is invalid. Sample rate must be between 0 and 1. Got " + rate + ".");
      return false;
    }
    return true;
  }
  function _startTransaction(transactionContext, customSamplingContext) {
    var _a, _b;
    var options = ((_a = this.getClient()) === null || _a === void 0 ? void 0 : _a.getOptions()) || {};
    var transaction = new transaction_1.Transaction(transactionContext, this);
    transaction = sample(transaction, options, tslib_1.__assign({parentSampled: transactionContext.parentSampled, transactionContext}, customSamplingContext));
    if (transaction.sampled) {
      transaction.initSpanRecorder((_b = options._experiments) === null || _b === void 0 ? void 0 : _b.maxSpans);
    }
    return transaction;
  }
  function startIdleTransaction(hub, transactionContext, idleTimeout, onScope, customSamplingContext) {
    var _a, _b;
    var options = ((_a = hub.getClient()) === null || _a === void 0 ? void 0 : _a.getOptions()) || {};
    var transaction = new idletransaction_1.IdleTransaction(transactionContext, hub, idleTimeout, onScope);
    transaction = sample(transaction, options, tslib_1.__assign({parentSampled: transactionContext.parentSampled, transactionContext}, customSamplingContext));
    if (transaction.sampled) {
      transaction.initSpanRecorder((_b = options._experiments) === null || _b === void 0 ? void 0 : _b.maxSpans);
    }
    return transaction;
  }
  exports2.startIdleTransaction = startIdleTransaction;
  function _addTracingExtensions() {
    var carrier = hub_1.getMainCarrier();
    if (carrier.__SENTRY__) {
      carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};
      if (!carrier.__SENTRY__.extensions.startTransaction) {
        carrier.__SENTRY__.extensions.startTransaction = _startTransaction;
      }
      if (!carrier.__SENTRY__.extensions.traceHeaders) {
        carrier.__SENTRY__.extensions.traceHeaders = traceHeaders;
      }
    }
  }
  exports2._addTracingExtensions = _addTracingExtensions;
  function addExtensionMethods() {
    _addTracingExtensions();
    errors_1.registerErrorInstrumentation();
  }
  exports2.addExtensionMethods = addExtensionMethods;
});

// ../../node_modules/.pnpm/@sentry+tracing@6.2.5/node_modules/@sentry/tracing/dist/browser/backgroundtab.js
var require_backgroundtab = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var utils_1 = require_dist17();
  var spanstatus_1 = require_spanstatus();
  var utils_2 = require_utils6();
  var global2 = utils_1.getGlobalObject();
  function registerBackgroundTabDetection() {
    if (global2 && global2.document) {
      global2.document.addEventListener("visibilitychange", function() {
        var activeTransaction = utils_2.getActiveTransaction();
        if (global2.document.hidden && activeTransaction) {
          utils_1.logger.log("[Tracing] Transaction: " + spanstatus_1.SpanStatus.Cancelled + " -> since tab moved to the background, op: " + activeTransaction.op);
          if (!activeTransaction.status) {
            activeTransaction.setStatus(spanstatus_1.SpanStatus.Cancelled);
          }
          activeTransaction.setTag("visibilitychange", "document.hidden");
          activeTransaction.finish();
        }
      });
    } else {
      utils_1.logger.warn("[Tracing] Could not set up background tab detection due to lack of global document");
    }
  }
  exports2.registerBackgroundTabDetection = registerBackgroundTabDetection;
});

// ../../node_modules/.pnpm/@sentry+tracing@6.2.5/node_modules/@sentry/tracing/dist/browser/web-vitals/lib/bindReporter.js
var require_bindReporter = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.bindReporter = function(callback, metric, po, observeAllUpdates) {
    var prevValue;
    return function() {
      if (po && metric.isFinal) {
        po.disconnect();
      }
      if (metric.value >= 0) {
        if (observeAllUpdates || metric.isFinal || document.visibilityState === "hidden") {
          metric.delta = metric.value - (prevValue || 0);
          if (metric.delta || metric.isFinal || prevValue === void 0) {
            callback(metric);
            prevValue = metric.value;
          }
        }
      }
    };
  };
});

// ../../node_modules/.pnpm/@sentry+tracing@6.2.5/node_modules/@sentry/tracing/dist/browser/web-vitals/lib/generateUniqueID.js
var require_generateUniqueID = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.generateUniqueID = function() {
    return Date.now() + "-" + (Math.floor(Math.random() * (9e12 - 1)) + 1e12);
  };
});

// ../../node_modules/.pnpm/@sentry+tracing@6.2.5/node_modules/@sentry/tracing/dist/browser/web-vitals/lib/initMetric.js
var require_initMetric = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var generateUniqueID_1 = require_generateUniqueID();
  exports2.initMetric = function(name, value) {
    if (value === void 0) {
      value = -1;
    }
    return {
      name,
      value,
      delta: 0,
      entries: [],
      id: generateUniqueID_1.generateUniqueID(),
      isFinal: false
    };
  };
});

// ../../node_modules/.pnpm/@sentry+tracing@6.2.5/node_modules/@sentry/tracing/dist/browser/web-vitals/lib/observe.js
var require_observe = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.observe = function(type, callback) {
    try {
      if (PerformanceObserver.supportedEntryTypes.includes(type)) {
        var po = new PerformanceObserver(function(l) {
          return l.getEntries().map(callback);
        });
        po.observe({type, buffered: true});
        return po;
      }
    } catch (e) {
    }
    return;
  };
});

// ../../node_modules/.pnpm/@sentry+tracing@6.2.5/node_modules/@sentry/tracing/dist/browser/web-vitals/lib/onHidden.js
var require_onHidden = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var isUnloading = false;
  var listenersAdded = false;
  var onPageHide = function(event) {
    isUnloading = !event.persisted;
  };
  var addListeners = function() {
    addEventListener("pagehide", onPageHide);
    addEventListener("beforeunload", function() {
    });
  };
  exports2.onHidden = function(cb, once) {
    if (once === void 0) {
      once = false;
    }
    if (!listenersAdded) {
      addListeners();
      listenersAdded = true;
    }
    addEventListener("visibilitychange", function(_a) {
      var timeStamp = _a.timeStamp;
      if (document.visibilityState === "hidden") {
        cb({timeStamp, isUnloading});
      }
    }, {capture: true, once});
  };
});

// ../../node_modules/.pnpm/@sentry+tracing@6.2.5/node_modules/@sentry/tracing/dist/browser/web-vitals/getCLS.js
var require_getCLS = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var bindReporter_1 = require_bindReporter();
  var initMetric_1 = require_initMetric();
  var observe_1 = require_observe();
  var onHidden_1 = require_onHidden();
  exports2.getCLS = function(onReport, reportAllChanges) {
    if (reportAllChanges === void 0) {
      reportAllChanges = false;
    }
    var metric = initMetric_1.initMetric("CLS", 0);
    var report;
    var entryHandler = function(entry) {
      if (!entry.hadRecentInput) {
        metric.value += entry.value;
        metric.entries.push(entry);
        report();
      }
    };
    var po = observe_1.observe("layout-shift", entryHandler);
    if (po) {
      report = bindReporter_1.bindReporter(onReport, metric, po, reportAllChanges);
      onHidden_1.onHidden(function(_a) {
        var isUnloading = _a.isUnloading;
        po.takeRecords().map(entryHandler);
        if (isUnloading) {
          metric.isFinal = true;
        }
        report();
      });
    }
  };
});

// ../../node_modules/.pnpm/@sentry+tracing@6.2.5/node_modules/@sentry/tracing/dist/browser/web-vitals/lib/getFirstHidden.js
var require_getFirstHidden = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var onHidden_1 = require_onHidden();
  var firstHiddenTime;
  exports2.getFirstHidden = function() {
    if (firstHiddenTime === void 0) {
      firstHiddenTime = document.visibilityState === "hidden" ? 0 : Infinity;
      onHidden_1.onHidden(function(_a) {
        var timeStamp = _a.timeStamp;
        return firstHiddenTime = timeStamp;
      }, true);
    }
    return {
      get timeStamp() {
        return firstHiddenTime;
      }
    };
  };
});

// ../../node_modules/.pnpm/@sentry+tracing@6.2.5/node_modules/@sentry/tracing/dist/browser/web-vitals/getFID.js
var require_getFID = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var bindReporter_1 = require_bindReporter();
  var getFirstHidden_1 = require_getFirstHidden();
  var initMetric_1 = require_initMetric();
  var observe_1 = require_observe();
  var onHidden_1 = require_onHidden();
  exports2.getFID = function(onReport) {
    var metric = initMetric_1.initMetric("FID");
    var firstHidden = getFirstHidden_1.getFirstHidden();
    var entryHandler = function(entry) {
      if (entry.startTime < firstHidden.timeStamp) {
        metric.value = entry.processingStart - entry.startTime;
        metric.entries.push(entry);
        metric.isFinal = true;
        report();
      }
    };
    var po = observe_1.observe("first-input", entryHandler);
    var report = bindReporter_1.bindReporter(onReport, metric, po);
    if (po) {
      onHidden_1.onHidden(function() {
        po.takeRecords().map(entryHandler);
        po.disconnect();
      }, true);
    } else {
      if (window.perfMetrics && window.perfMetrics.onFirstInputDelay) {
        window.perfMetrics.onFirstInputDelay(function(value, event) {
          if (event.timeStamp < firstHidden.timeStamp) {
            metric.value = value;
            metric.isFinal = true;
            metric.entries = [
              {
                entryType: "first-input",
                name: event.type,
                target: event.target,
                cancelable: event.cancelable,
                startTime: event.timeStamp,
                processingStart: event.timeStamp + value
              }
            ];
            report();
          }
        });
      }
    }
  };
});

// ../../node_modules/.pnpm/@sentry+tracing@6.2.5/node_modules/@sentry/tracing/dist/browser/web-vitals/lib/whenInput.js
var require_whenInput = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var inputPromise;
  exports2.whenInput = function() {
    if (!inputPromise) {
      inputPromise = new Promise(function(r) {
        return ["scroll", "keydown", "pointerdown"].map(function(type) {
          addEventListener(type, r, {
            once: true,
            passive: true,
            capture: true
          });
        });
      });
    }
    return inputPromise;
  };
});

// ../../node_modules/.pnpm/@sentry+tracing@6.2.5/node_modules/@sentry/tracing/dist/browser/web-vitals/getLCP.js
var require_getLCP = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var bindReporter_1 = require_bindReporter();
  var getFirstHidden_1 = require_getFirstHidden();
  var initMetric_1 = require_initMetric();
  var observe_1 = require_observe();
  var onHidden_1 = require_onHidden();
  var whenInput_1 = require_whenInput();
  exports2.getLCP = function(onReport, reportAllChanges) {
    if (reportAllChanges === void 0) {
      reportAllChanges = false;
    }
    var metric = initMetric_1.initMetric("LCP");
    var firstHidden = getFirstHidden_1.getFirstHidden();
    var report;
    var entryHandler = function(entry) {
      var value = entry.startTime;
      if (value < firstHidden.timeStamp) {
        metric.value = value;
        metric.entries.push(entry);
      } else {
        metric.isFinal = true;
      }
      report();
    };
    var po = observe_1.observe("largest-contentful-paint", entryHandler);
    if (po) {
      report = bindReporter_1.bindReporter(onReport, metric, po, reportAllChanges);
      var onFinal = function() {
        if (!metric.isFinal) {
          po.takeRecords().map(entryHandler);
          metric.isFinal = true;
          report();
        }
      };
      void whenInput_1.whenInput().then(onFinal);
      onHidden_1.onHidden(onFinal, true);
    }
  };
});

// ../../node_modules/.pnpm/@sentry+tracing@6.2.5/node_modules/@sentry/tracing/dist/browser/web-vitals/getTTFB.js
var require_getTTFB = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var utils_1 = require_dist17();
  var initMetric_1 = require_initMetric();
  var global2 = utils_1.getGlobalObject();
  var afterLoad = function(callback) {
    if (document.readyState === "complete") {
      setTimeout(callback, 0);
    } else {
      addEventListener("pageshow", callback);
    }
  };
  var getNavigationEntryFromPerformanceTiming = function() {
    var timing = global2.performance.timing;
    var navigationEntry = {
      entryType: "navigation",
      startTime: 0
    };
    for (var key in timing) {
      if (key !== "navigationStart" && key !== "toJSON") {
        navigationEntry[key] = Math.max(timing[key] - timing.navigationStart, 0);
      }
    }
    return navigationEntry;
  };
  exports2.getTTFB = function(onReport) {
    var metric = initMetric_1.initMetric("TTFB");
    afterLoad(function() {
      try {
        var navigationEntry = global2.performance.getEntriesByType("navigation")[0] || getNavigationEntryFromPerformanceTiming();
        metric.value = metric.delta = navigationEntry.responseStart;
        metric.entries = [navigationEntry];
        onReport(metric);
      } catch (error) {
      }
    });
  };
});

// ../../node_modules/.pnpm/@sentry+tracing@6.2.5/node_modules/@sentry/tracing/dist/browser/metrics.js
var require_metrics = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib_1 = require_tslib();
  var utils_1 = require_dist17();
  var utils_2 = require_utils6();
  var getCLS_1 = require_getCLS();
  var getFID_1 = require_getFID();
  var getLCP_1 = require_getLCP();
  var getTTFB_1 = require_getTTFB();
  var getFirstHidden_1 = require_getFirstHidden();
  var global2 = utils_1.getGlobalObject();
  var MetricsInstrumentation = function() {
    function MetricsInstrumentation2() {
      this._measurements = {};
      this._performanceCursor = 0;
      if (global2 && global2.performance) {
        if (global2.performance.mark) {
          global2.performance.mark("sentry-tracing-init");
        }
        this._trackCLS();
        this._trackLCP();
        this._trackFID();
        this._trackTTFB();
      }
    }
    MetricsInstrumentation2.prototype.addPerformanceEntries = function(transaction) {
      var _this = this;
      if (!global2 || !global2.performance || !global2.performance.getEntries || !utils_1.browserPerformanceTimeOrigin) {
        return;
      }
      utils_1.logger.log("[Tracing] Adding & adjusting spans using Performance API");
      var timeOrigin = utils_2.msToSec(utils_1.browserPerformanceTimeOrigin);
      var entryScriptSrc;
      if (global2.document) {
        for (var i = 0; i < document.scripts.length; i++) {
          if (document.scripts[i].dataset.entry === "true") {
            entryScriptSrc = document.scripts[i].src;
            break;
          }
        }
      }
      var entryScriptStartTimestamp;
      var tracingInitMarkStartTime;
      global2.performance.getEntries().slice(this._performanceCursor).forEach(function(entry) {
        var startTime = utils_2.msToSec(entry.startTime);
        var duration = utils_2.msToSec(entry.duration);
        if (transaction.op === "navigation" && timeOrigin + startTime < transaction.startTimestamp) {
          return;
        }
        switch (entry.entryType) {
          case "navigation":
            addNavigationSpans(transaction, entry, timeOrigin);
            break;
          case "mark":
          case "paint":
          case "measure": {
            var startTimestamp = addMeasureSpans(transaction, entry, startTime, duration, timeOrigin);
            if (tracingInitMarkStartTime === void 0 && entry.name === "sentry-tracing-init") {
              tracingInitMarkStartTime = startTimestamp;
            }
            var firstHidden = getFirstHidden_1.getFirstHidden();
            var shouldRecord = entry.startTime < firstHidden.timeStamp;
            if (entry.name === "first-paint" && shouldRecord) {
              utils_1.logger.log("[Measurements] Adding FP");
              _this._measurements["fp"] = {value: entry.startTime};
              _this._measurements["mark.fp"] = {value: startTimestamp};
            }
            if (entry.name === "first-contentful-paint" && shouldRecord) {
              utils_1.logger.log("[Measurements] Adding FCP");
              _this._measurements["fcp"] = {value: entry.startTime};
              _this._measurements["mark.fcp"] = {value: startTimestamp};
            }
            break;
          }
          case "resource": {
            var resourceName = entry.name.replace(window.location.origin, "");
            var endTimestamp = addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin);
            if (entryScriptStartTimestamp === void 0 && (entryScriptSrc || "").indexOf(resourceName) > -1) {
              entryScriptStartTimestamp = endTimestamp;
            }
            break;
          }
          default:
        }
      });
      if (entryScriptStartTimestamp !== void 0 && tracingInitMarkStartTime !== void 0) {
        _startChild(transaction, {
          description: "evaluation",
          endTimestamp: tracingInitMarkStartTime,
          op: "script",
          startTimestamp: entryScriptStartTimestamp
        });
      }
      this._performanceCursor = Math.max(performance.getEntries().length - 1, 0);
      this._trackNavigator(transaction);
      if (transaction.op === "pageload") {
        var timeOrigin_1 = utils_2.msToSec(utils_1.browserPerformanceTimeOrigin);
        ["fcp", "fp", "lcp", "ttfb"].forEach(function(name) {
          if (!_this._measurements[name] || timeOrigin_1 >= transaction.startTimestamp) {
            return;
          }
          var oldValue = _this._measurements[name].value;
          var measurementTimestamp = timeOrigin_1 + utils_2.msToSec(oldValue);
          var normalizedValue = Math.abs((measurementTimestamp - transaction.startTimestamp) * 1e3);
          var delta = normalizedValue - oldValue;
          utils_1.logger.log("[Measurements] Normalized " + name + " from " + oldValue + " to " + normalizedValue + " (" + delta + ")");
          _this._measurements[name].value = normalizedValue;
        });
        if (this._measurements["mark.fid"] && this._measurements["fid"]) {
          _startChild(transaction, {
            description: "first input delay",
            endTimestamp: this._measurements["mark.fid"].value + utils_2.msToSec(this._measurements["fid"].value),
            op: "web.vitals",
            startTimestamp: this._measurements["mark.fid"].value
          });
        }
        transaction.setMeasurements(this._measurements);
      }
    };
    MetricsInstrumentation2.prototype._trackCLS = function() {
      var _this = this;
      getCLS_1.getCLS(function(metric) {
        var entry = metric.entries.pop();
        if (!entry) {
          return;
        }
        utils_1.logger.log("[Measurements] Adding CLS");
        _this._measurements["cls"] = {value: metric.value};
      });
    };
    MetricsInstrumentation2.prototype._trackNavigator = function(transaction) {
      var navigator2 = global2.navigator;
      if (!navigator2) {
        return;
      }
      var connection = navigator2.connection;
      if (connection) {
        if (connection.effectiveType) {
          transaction.setTag("effectiveConnectionType", connection.effectiveType);
        }
        if (connection.type) {
          transaction.setTag("connectionType", connection.type);
        }
        if (isMeasurementValue(connection.rtt)) {
          this._measurements["connection.rtt"] = {value: connection.rtt};
        }
        if (isMeasurementValue(connection.downlink)) {
          this._measurements["connection.downlink"] = {value: connection.downlink};
        }
      }
      if (isMeasurementValue(navigator2.deviceMemory)) {
        transaction.setTag("deviceMemory", String(navigator2.deviceMemory));
      }
      if (isMeasurementValue(navigator2.hardwareConcurrency)) {
        transaction.setTag("hardwareConcurrency", String(navigator2.hardwareConcurrency));
      }
    };
    MetricsInstrumentation2.prototype._trackLCP = function() {
      var _this = this;
      getLCP_1.getLCP(function(metric) {
        var entry = metric.entries.pop();
        if (!entry) {
          return;
        }
        var timeOrigin = utils_2.msToSec(performance.timeOrigin);
        var startTime = utils_2.msToSec(entry.startTime);
        utils_1.logger.log("[Measurements] Adding LCP");
        _this._measurements["lcp"] = {value: metric.value};
        _this._measurements["mark.lcp"] = {value: timeOrigin + startTime};
      });
    };
    MetricsInstrumentation2.prototype._trackFID = function() {
      var _this = this;
      getFID_1.getFID(function(metric) {
        var entry = metric.entries.pop();
        if (!entry) {
          return;
        }
        var timeOrigin = utils_2.msToSec(performance.timeOrigin);
        var startTime = utils_2.msToSec(entry.startTime);
        utils_1.logger.log("[Measurements] Adding FID");
        _this._measurements["fid"] = {value: metric.value};
        _this._measurements["mark.fid"] = {value: timeOrigin + startTime};
      });
    };
    MetricsInstrumentation2.prototype._trackTTFB = function() {
      var _this = this;
      getTTFB_1.getTTFB(function(metric) {
        var _a;
        var entry = metric.entries.pop();
        if (!entry) {
          return;
        }
        utils_1.logger.log("[Measurements] Adding TTFB");
        _this._measurements["ttfb"] = {value: metric.value};
        var requestTime = metric.value - (_a = metric.entries[0], _a !== null && _a !== void 0 ? _a : entry).requestStart;
        _this._measurements["ttfb.requestTime"] = {value: requestTime};
      });
    };
    return MetricsInstrumentation2;
  }();
  exports2.MetricsInstrumentation = MetricsInstrumentation;
  function addNavigationSpans(transaction, entry, timeOrigin) {
    addPerformanceNavigationTiming(transaction, entry, "unloadEvent", timeOrigin);
    addPerformanceNavigationTiming(transaction, entry, "redirect", timeOrigin);
    addPerformanceNavigationTiming(transaction, entry, "domContentLoadedEvent", timeOrigin);
    addPerformanceNavigationTiming(transaction, entry, "loadEvent", timeOrigin);
    addPerformanceNavigationTiming(transaction, entry, "connect", timeOrigin);
    addPerformanceNavigationTiming(transaction, entry, "secureConnection", timeOrigin, "connectEnd");
    addPerformanceNavigationTiming(transaction, entry, "fetch", timeOrigin, "domainLookupStart");
    addPerformanceNavigationTiming(transaction, entry, "domainLookup", timeOrigin);
    addRequest(transaction, entry, timeOrigin);
  }
  function addMeasureSpans(transaction, entry, startTime, duration, timeOrigin) {
    var measureStartTimestamp = timeOrigin + startTime;
    var measureEndTimestamp = measureStartTimestamp + duration;
    _startChild(transaction, {
      description: entry.name,
      endTimestamp: measureEndTimestamp,
      op: entry.entryType,
      startTimestamp: measureStartTimestamp
    });
    return measureStartTimestamp;
  }
  function addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin) {
    if (entry.initiatorType === "xmlhttprequest" || entry.initiatorType === "fetch") {
      return void 0;
    }
    var data = {};
    if ("transferSize" in entry) {
      data["Transfer Size"] = entry.transferSize;
    }
    if ("encodedBodySize" in entry) {
      data["Encoded Body Size"] = entry.encodedBodySize;
    }
    if ("decodedBodySize" in entry) {
      data["Decoded Body Size"] = entry.decodedBodySize;
    }
    var startTimestamp = timeOrigin + startTime;
    var endTimestamp = startTimestamp + duration;
    _startChild(transaction, {
      description: resourceName,
      endTimestamp,
      op: entry.initiatorType ? "resource." + entry.initiatorType : "resource",
      startTimestamp,
      data
    });
    return endTimestamp;
  }
  exports2.addResourceSpans = addResourceSpans;
  function addPerformanceNavigationTiming(transaction, entry, event, timeOrigin, eventEnd) {
    var end = eventEnd ? entry[eventEnd] : entry[event + "End"];
    var start = entry[event + "Start"];
    if (!start || !end) {
      return;
    }
    _startChild(transaction, {
      op: "browser",
      description: event,
      startTimestamp: timeOrigin + utils_2.msToSec(start),
      endTimestamp: timeOrigin + utils_2.msToSec(end)
    });
  }
  function addRequest(transaction, entry, timeOrigin) {
    _startChild(transaction, {
      op: "browser",
      description: "request",
      startTimestamp: timeOrigin + utils_2.msToSec(entry.requestStart),
      endTimestamp: timeOrigin + utils_2.msToSec(entry.responseEnd)
    });
    _startChild(transaction, {
      op: "browser",
      description: "response",
      startTimestamp: timeOrigin + utils_2.msToSec(entry.responseStart),
      endTimestamp: timeOrigin + utils_2.msToSec(entry.responseEnd)
    });
  }
  function _startChild(transaction, _a) {
    var startTimestamp = _a.startTimestamp, ctx = tslib_1.__rest(_a, ["startTimestamp"]);
    if (startTimestamp && transaction.startTimestamp > startTimestamp) {
      transaction.startTimestamp = startTimestamp;
    }
    return transaction.startChild(tslib_1.__assign({startTimestamp}, ctx));
  }
  exports2._startChild = _startChild;
  function isMeasurementValue(value) {
    return typeof value === "number" && isFinite(value);
  }
});

// ../../node_modules/.pnpm/@sentry+tracing@6.2.5/node_modules/@sentry/tracing/dist/browser/request.js
var require_request3 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib_1 = require_tslib();
  var hub_1 = require_dist18();
  var utils_1 = require_dist17();
  var utils_2 = require_utils6();
  exports2.DEFAULT_TRACING_ORIGINS = ["localhost", /^\//];
  exports2.defaultRequestInstrumentationOptions = {
    traceFetch: true,
    traceXHR: true,
    tracingOrigins: exports2.DEFAULT_TRACING_ORIGINS
  };
  function instrumentOutgoingRequests(_options) {
    var _a = tslib_1.__assign(tslib_1.__assign({}, exports2.defaultRequestInstrumentationOptions), _options), traceFetch = _a.traceFetch, traceXHR = _a.traceXHR, tracingOrigins = _a.tracingOrigins, shouldCreateSpanForRequest = _a.shouldCreateSpanForRequest;
    var urlMap = {};
    var defaultShouldCreateSpan = function(url) {
      if (urlMap[url]) {
        return urlMap[url];
      }
      var origins = tracingOrigins;
      urlMap[url] = origins.some(function(origin) {
        return utils_1.isMatchingPattern(url, origin);
      }) && !utils_1.isMatchingPattern(url, "sentry_key");
      return urlMap[url];
    };
    var shouldCreateSpan = defaultShouldCreateSpan;
    if (typeof shouldCreateSpanForRequest === "function") {
      shouldCreateSpan = function(url) {
        return defaultShouldCreateSpan(url) && shouldCreateSpanForRequest(url);
      };
    }
    var spans = {};
    if (traceFetch) {
      utils_1.addInstrumentationHandler({
        callback: function(handlerData) {
          fetchCallback(handlerData, shouldCreateSpan, spans);
        },
        type: "fetch"
      });
    }
    if (traceXHR) {
      utils_1.addInstrumentationHandler({
        callback: function(handlerData) {
          xhrCallback(handlerData, shouldCreateSpan, spans);
        },
        type: "xhr"
      });
    }
  }
  exports2.instrumentOutgoingRequests = instrumentOutgoingRequests;
  function fetchCallback(handlerData, shouldCreateSpan, spans) {
    var _a;
    var currentClientOptions = (_a = hub_1.getCurrentHub().getClient()) === null || _a === void 0 ? void 0 : _a.getOptions();
    if (!(currentClientOptions && utils_2.hasTracingEnabled(currentClientOptions)) || !(handlerData.fetchData && shouldCreateSpan(handlerData.fetchData.url))) {
      return;
    }
    if (handlerData.endTimestamp && handlerData.fetchData.__span) {
      var span = spans[handlerData.fetchData.__span];
      if (span) {
        var response = handlerData.response;
        if (response) {
          span.setHttpStatus(response.status);
        }
        span.finish();
        delete spans[handlerData.fetchData.__span];
      }
      return;
    }
    var activeTransaction = utils_2.getActiveTransaction();
    if (activeTransaction) {
      var span = activeTransaction.startChild({
        data: tslib_1.__assign(tslib_1.__assign({}, handlerData.fetchData), {type: "fetch"}),
        description: handlerData.fetchData.method + " " + handlerData.fetchData.url,
        op: "http"
      });
      handlerData.fetchData.__span = span.spanId;
      spans[span.spanId] = span;
      var request = handlerData.args[0] = handlerData.args[0];
      var options = handlerData.args[1] = handlerData.args[1] || {};
      var headers = options.headers;
      if (utils_1.isInstanceOf(request, Request)) {
        headers = request.headers;
      }
      if (headers) {
        if (typeof headers.append === "function") {
          headers.append("sentry-trace", span.toTraceparent());
        } else if (Array.isArray(headers)) {
          headers = tslib_1.__spread(headers, [["sentry-trace", span.toTraceparent()]]);
        } else {
          headers = tslib_1.__assign(tslib_1.__assign({}, headers), {"sentry-trace": span.toTraceparent()});
        }
      } else {
        headers = {"sentry-trace": span.toTraceparent()};
      }
      options.headers = headers;
    }
  }
  exports2.fetchCallback = fetchCallback;
  function xhrCallback(handlerData, shouldCreateSpan, spans) {
    var _a;
    var currentClientOptions = (_a = hub_1.getCurrentHub().getClient()) === null || _a === void 0 ? void 0 : _a.getOptions();
    if (!(currentClientOptions && utils_2.hasTracingEnabled(currentClientOptions)) || !(handlerData.xhr && handlerData.xhr.__sentry_xhr__ && shouldCreateSpan(handlerData.xhr.__sentry_xhr__.url)) || handlerData.xhr.__sentry_own_request__) {
      return;
    }
    var xhr = handlerData.xhr.__sentry_xhr__;
    if (handlerData.endTimestamp && handlerData.xhr.__sentry_xhr_span_id__) {
      var span = spans[handlerData.xhr.__sentry_xhr_span_id__];
      if (span) {
        span.setHttpStatus(xhr.status_code);
        span.finish();
        delete spans[handlerData.xhr.__sentry_xhr_span_id__];
      }
      return;
    }
    var activeTransaction = utils_2.getActiveTransaction();
    if (activeTransaction) {
      var span = activeTransaction.startChild({
        data: tslib_1.__assign(tslib_1.__assign({}, xhr.data), {type: "xhr", method: xhr.method, url: xhr.url}),
        description: xhr.method + " " + xhr.url,
        op: "http"
      });
      handlerData.xhr.__sentry_xhr_span_id__ = span.spanId;
      spans[handlerData.xhr.__sentry_xhr_span_id__] = span;
      if (handlerData.xhr.setRequestHeader) {
        try {
          handlerData.xhr.setRequestHeader("sentry-trace", span.toTraceparent());
        } catch (_2) {
        }
      }
    }
  }
  exports2.xhrCallback = xhrCallback;
});

// ../../node_modules/.pnpm/@sentry+tracing@6.2.5/node_modules/@sentry/tracing/dist/browser/router.js
var require_router = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var utils_1 = require_dist17();
  var global2 = utils_1.getGlobalObject();
  function instrumentRoutingWithDefaults(customStartTransaction, startTransactionOnPageLoad, startTransactionOnLocationChange) {
    if (startTransactionOnPageLoad === void 0) {
      startTransactionOnPageLoad = true;
    }
    if (startTransactionOnLocationChange === void 0) {
      startTransactionOnLocationChange = true;
    }
    if (!global2 || !global2.location) {
      utils_1.logger.warn("Could not initialize routing instrumentation due to invalid location");
      return;
    }
    var startingUrl = global2.location.href;
    var activeTransaction;
    if (startTransactionOnPageLoad) {
      activeTransaction = customStartTransaction({name: global2.location.pathname, op: "pageload"});
    }
    if (startTransactionOnLocationChange) {
      utils_1.addInstrumentationHandler({
        callback: function(_a) {
          var to = _a.to, from = _a.from;
          if (from === void 0 && startingUrl && startingUrl.indexOf(to) !== -1) {
            startingUrl = void 0;
            return;
          }
          if (from !== to) {
            startingUrl = void 0;
            if (activeTransaction) {
              utils_1.logger.log("[Tracing] Finishing current transaction with op: " + activeTransaction.op);
              activeTransaction.finish();
            }
            activeTransaction = customStartTransaction({name: global2.location.pathname, op: "navigation"});
          }
        },
        type: "history"
      });
    }
  }
  exports2.instrumentRoutingWithDefaults = instrumentRoutingWithDefaults;
});

// ../../node_modules/.pnpm/@sentry+tracing@6.2.5/node_modules/@sentry/tracing/dist/browser/browsertracing.js
var require_browsertracing = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib_1 = require_tslib();
  var utils_1 = require_dist17();
  var hubextensions_1 = require_hubextensions();
  var idletransaction_1 = require_idletransaction();
  var spanstatus_1 = require_spanstatus();
  var utils_2 = require_utils6();
  var backgroundtab_1 = require_backgroundtab();
  var metrics_1 = require_metrics();
  var request_1 = require_request3();
  var router_1 = require_router();
  exports2.DEFAULT_MAX_TRANSACTION_DURATION_SECONDS = 600;
  var DEFAULT_BROWSER_TRACING_OPTIONS = tslib_1.__assign({idleTimeout: idletransaction_1.DEFAULT_IDLE_TIMEOUT, markBackgroundTransactions: true, maxTransactionDuration: exports2.DEFAULT_MAX_TRANSACTION_DURATION_SECONDS, routingInstrumentation: router_1.instrumentRoutingWithDefaults, startTransactionOnLocationChange: true, startTransactionOnPageLoad: true}, request_1.defaultRequestInstrumentationOptions);
  var BrowserTracing = function() {
    function BrowserTracing2(_options) {
      this.name = BrowserTracing2.id;
      this._metrics = new metrics_1.MetricsInstrumentation();
      this._emitOptionsWarning = false;
      var tracingOrigins = request_1.defaultRequestInstrumentationOptions.tracingOrigins;
      if (_options && _options.tracingOrigins && Array.isArray(_options.tracingOrigins) && _options.tracingOrigins.length !== 0) {
        tracingOrigins = _options.tracingOrigins;
      } else {
        this._emitOptionsWarning = true;
      }
      this.options = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, DEFAULT_BROWSER_TRACING_OPTIONS), _options), {tracingOrigins});
    }
    BrowserTracing2.prototype.setupOnce = function(_2, getCurrentHub) {
      var _this = this;
      this._getCurrentHub = getCurrentHub;
      if (this._emitOptionsWarning) {
        utils_1.logger.warn("[Tracing] You need to define `tracingOrigins` in the options. Set an array of urls or patterns to trace.");
        utils_1.logger.warn("[Tracing] We added a reasonable default for you: " + request_1.defaultRequestInstrumentationOptions.tracingOrigins);
      }
      var _a = this.options, instrumentRouting = _a.routingInstrumentation, startTransactionOnLocationChange = _a.startTransactionOnLocationChange, startTransactionOnPageLoad = _a.startTransactionOnPageLoad, markBackgroundTransactions = _a.markBackgroundTransactions, traceFetch = _a.traceFetch, traceXHR = _a.traceXHR, tracingOrigins = _a.tracingOrigins, shouldCreateSpanForRequest = _a.shouldCreateSpanForRequest;
      instrumentRouting(function(context) {
        return _this._createRouteTransaction(context);
      }, startTransactionOnPageLoad, startTransactionOnLocationChange);
      if (markBackgroundTransactions) {
        backgroundtab_1.registerBackgroundTabDetection();
      }
      request_1.instrumentOutgoingRequests({traceFetch, traceXHR, tracingOrigins, shouldCreateSpanForRequest});
    };
    BrowserTracing2.prototype._createRouteTransaction = function(context) {
      var _this = this;
      if (!this._getCurrentHub) {
        utils_1.logger.warn("[Tracing] Did not create " + context.op + " transaction because _getCurrentHub is invalid.");
        return void 0;
      }
      var _a = this.options, beforeNavigate = _a.beforeNavigate, idleTimeout = _a.idleTimeout, maxTransactionDuration = _a.maxTransactionDuration;
      var parentContextFromHeader = context.op === "pageload" ? getHeaderContext() : void 0;
      var expandedContext = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, context), parentContextFromHeader), {trimEnd: true});
      var modifiedContext = typeof beforeNavigate === "function" ? beforeNavigate(expandedContext) : expandedContext;
      var finalContext = modifiedContext === void 0 ? tslib_1.__assign(tslib_1.__assign({}, expandedContext), {sampled: false}) : modifiedContext;
      if (finalContext.sampled === false) {
        utils_1.logger.log("[Tracing] Will not send " + finalContext.op + " transaction because of beforeNavigate.");
      }
      utils_1.logger.log("[Tracing] Starting " + finalContext.op + " transaction on scope");
      var hub = this._getCurrentHub();
      var location = utils_1.getGlobalObject().location;
      var idleTransaction = hubextensions_1.startIdleTransaction(hub, finalContext, idleTimeout, true, {location});
      idleTransaction.registerBeforeFinishCallback(function(transaction, endTimestamp) {
        _this._metrics.addPerformanceEntries(transaction);
        adjustTransactionDuration(utils_2.secToMs(maxTransactionDuration), transaction, endTimestamp);
      });
      return idleTransaction;
    };
    BrowserTracing2.id = "BrowserTracing";
    return BrowserTracing2;
  }();
  exports2.BrowserTracing = BrowserTracing;
  function getHeaderContext() {
    var header = getMetaContent("sentry-trace");
    if (header) {
      return utils_2.extractTraceparentData(header);
    }
    return void 0;
  }
  exports2.getHeaderContext = getHeaderContext;
  function getMetaContent(metaName) {
    var el = document.querySelector("meta[name=" + metaName + "]");
    return el ? el.getAttribute("content") : null;
  }
  exports2.getMetaContent = getMetaContent;
  function adjustTransactionDuration(maxDuration, transaction, endTimestamp) {
    var diff = endTimestamp - transaction.startTimestamp;
    var isOutdatedTransaction = endTimestamp && (diff > maxDuration || diff < 0);
    if (isOutdatedTransaction) {
      transaction.setStatus(spanstatus_1.SpanStatus.DeadlineExceeded);
      transaction.setTag("maxTransactionDurationExceeded", "true");
    }
  }
});

// ../../node_modules/.pnpm/@sentry+tracing@6.2.5/node_modules/@sentry/tracing/dist/browser/index.js
var require_browser3 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var browsertracing_1 = require_browsertracing();
  exports2.BrowserTracing = browsertracing_1.BrowserTracing;
  var request_1 = require_request3();
  exports2.instrumentOutgoingRequests = request_1.instrumentOutgoingRequests;
  exports2.defaultRequestInstrumentationOptions = request_1.defaultRequestInstrumentationOptions;
});

// ../../node_modules/.pnpm/@sentry+tracing@6.2.5/node_modules/@sentry/tracing/dist/integrations/express.js
var require_express = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib_1 = require_tslib();
  var utils_1 = require_dist17();
  var Express = function() {
    function Express2(options) {
      if (options === void 0) {
        options = {};
      }
      this.name = Express2.id;
      this._router = options.router || options.app;
      this._methods = (Array.isArray(options.methods) ? options.methods : []).concat("use");
    }
    Express2.prototype.setupOnce = function() {
      if (!this._router) {
        utils_1.logger.error("ExpressIntegration is missing an Express instance");
        return;
      }
      instrumentMiddlewares(this._router, this._methods);
    };
    Express2.id = "Express";
    return Express2;
  }();
  exports2.Express = Express;
  function wrap(fn, method) {
    var arity = fn.length;
    switch (arity) {
      case 2: {
        return function(req, res) {
          var transaction = res.__sentry_transaction;
          if (transaction) {
            var span_1 = transaction.startChild({
              description: fn.name,
              op: "middleware." + method
            });
            res.once("finish", function() {
              span_1.finish();
            });
          }
          return fn.call(this, req, res);
        };
      }
      case 3: {
        return function(req, res, next) {
          var _a;
          var transaction = res.__sentry_transaction;
          var span = (_a = transaction) === null || _a === void 0 ? void 0 : _a.startChild({
            description: fn.name,
            op: "middleware." + method
          });
          fn.call(this, req, res, function() {
            var args2 = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args2[_i] = arguments[_i];
            }
            var _a2;
            (_a2 = span) === null || _a2 === void 0 ? void 0 : _a2.finish();
            next.call.apply(next, tslib_1.__spread([this], args2));
          });
        };
      }
      case 4: {
        return function(err, req, res, next) {
          var _a;
          var transaction = res.__sentry_transaction;
          var span = (_a = transaction) === null || _a === void 0 ? void 0 : _a.startChild({
            description: fn.name,
            op: "middleware." + method
          });
          fn.call(this, err, req, res, function() {
            var args2 = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args2[_i] = arguments[_i];
            }
            var _a2;
            (_a2 = span) === null || _a2 === void 0 ? void 0 : _a2.finish();
            next.call.apply(next, tslib_1.__spread([this], args2));
          });
        };
      }
      default: {
        throw new Error("Express middleware takes 2-4 arguments. Got: " + arity);
      }
    }
  }
  function wrapMiddlewareArgs(args2, method) {
    return args2.map(function(arg10) {
      if (typeof arg10 === "function") {
        return wrap(arg10, method);
      }
      if (Array.isArray(arg10)) {
        return arg10.map(function(a) {
          if (typeof a === "function") {
            return wrap(a, method);
          }
          return a;
        });
      }
      return arg10;
    });
  }
  function patchMiddleware(router, method) {
    var originalCallback = router[method];
    router[method] = function() {
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      return originalCallback.call.apply(originalCallback, tslib_1.__spread([this], wrapMiddlewareArgs(args2, method)));
    };
    return router;
  }
  function instrumentMiddlewares(router, methods) {
    if (methods === void 0) {
      methods = [];
    }
    methods.forEach(function(method) {
      return patchMiddleware(router, method);
    });
  }
});

// ../../node_modules/.pnpm/@sentry+tracing@6.2.5/node_modules/@sentry/tracing/dist/integrations/postgres.js
var require_postgres = __commonJS((exports2, module2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var utils_1 = require_dist17();
  var Postgres = function() {
    function Postgres2() {
      this.name = Postgres2.id;
    }
    Postgres2.prototype.setupOnce = function(_2, getCurrentHub) {
      var client;
      try {
        var pgModule = utils_1.dynamicRequire(module2, "pg");
        client = pgModule.Client;
      } catch (e) {
        utils_1.logger.error("Postgres Integration was unable to require `pg` package.");
        return;
      }
      utils_1.fill(client.prototype, "query", function(orig) {
        return function(config, values, callback) {
          var _a, _b;
          var scope = getCurrentHub().getScope();
          var parentSpan = (_a = scope) === null || _a === void 0 ? void 0 : _a.getSpan();
          var span = (_b = parentSpan) === null || _b === void 0 ? void 0 : _b.startChild({
            description: typeof config === "string" ? config : config.text,
            op: "db"
          });
          if (typeof callback === "function") {
            return orig.call(this, config, values, function(err, result) {
              var _a2;
              (_a2 = span) === null || _a2 === void 0 ? void 0 : _a2.finish();
              callback(err, result);
            });
          }
          if (typeof values === "function") {
            return orig.call(this, config, function(err, result) {
              var _a2;
              (_a2 = span) === null || _a2 === void 0 ? void 0 : _a2.finish();
              values(err, result);
            });
          }
          return orig.call(this, config, values).then(function(res) {
            var _a2;
            (_a2 = span) === null || _a2 === void 0 ? void 0 : _a2.finish();
            return res;
          });
        };
      });
    };
    Postgres2.id = "Postgres";
    return Postgres2;
  }();
  exports2.Postgres = Postgres;
});

// ../../node_modules/.pnpm/@sentry+tracing@6.2.5/node_modules/@sentry/tracing/dist/integrations/mysql.js
var require_mysql = __commonJS((exports2, module2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var utils_1 = require_dist17();
  var Mysql = function() {
    function Mysql2() {
      this.name = Mysql2.id;
    }
    Mysql2.prototype.setupOnce = function(_2, getCurrentHub) {
      var connection;
      try {
        connection = utils_1.dynamicRequire(module2, "mysql/lib/Connection.js");
      } catch (e) {
        utils_1.logger.error("Mysql Integration was unable to require `mysql` package.");
        return;
      }
      utils_1.fill(connection, "createQuery", function(orig) {
        return function(options, values, callback) {
          var _a, _b;
          var scope = getCurrentHub().getScope();
          var parentSpan = (_a = scope) === null || _a === void 0 ? void 0 : _a.getSpan();
          var span = (_b = parentSpan) === null || _b === void 0 ? void 0 : _b.startChild({
            description: typeof options === "string" ? options : options.sql,
            op: "db"
          });
          if (typeof callback === "function") {
            return orig.call(this, options, values, function(err, result, fields) {
              var _a2;
              (_a2 = span) === null || _a2 === void 0 ? void 0 : _a2.finish();
              callback(err, result, fields);
            });
          }
          if (typeof values === "function") {
            return orig.call(this, options, function(err, result, fields) {
              var _a2;
              (_a2 = span) === null || _a2 === void 0 ? void 0 : _a2.finish();
              values(err, result, fields);
            });
          }
          return orig.call(this, options, values, callback);
        };
      });
    };
    Mysql2.id = "Mysql";
    return Mysql2;
  }();
  exports2.Mysql = Mysql;
});

// ../../node_modules/.pnpm/@sentry+tracing@6.2.5/node_modules/@sentry/tracing/dist/integrations/mongo.js
var require_mongo = __commonJS((exports2, module2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib_1 = require_tslib();
  var utils_1 = require_dist17();
  var OPERATIONS = [
    "aggregate",
    "bulkWrite",
    "countDocuments",
    "createIndex",
    "createIndexes",
    "deleteMany",
    "deleteOne",
    "distinct",
    "drop",
    "dropIndex",
    "dropIndexes",
    "estimatedDocumentCount",
    "find",
    "findOne",
    "findOneAndDelete",
    "findOneAndReplace",
    "findOneAndUpdate",
    "indexes",
    "indexExists",
    "indexInformation",
    "initializeOrderedBulkOp",
    "insertMany",
    "insertOne",
    "isCapped",
    "mapReduce",
    "options",
    "parallelCollectionScan",
    "rename",
    "replaceOne",
    "stats",
    "updateMany",
    "updateOne"
  ];
  var OPERATION_SIGNATURES = {
    bulkWrite: ["operations"],
    countDocuments: ["query"],
    createIndex: ["fieldOrSpec"],
    createIndexes: ["indexSpecs"],
    deleteMany: ["filter"],
    deleteOne: ["filter"],
    distinct: ["key", "query"],
    dropIndex: ["indexName"],
    find: ["query"],
    findOne: ["query"],
    findOneAndDelete: ["filter"],
    findOneAndReplace: ["filter", "replacement"],
    findOneAndUpdate: ["filter", "update"],
    indexExists: ["indexes"],
    insertMany: ["docs"],
    insertOne: ["doc"],
    mapReduce: ["map", "reduce"],
    rename: ["newName"],
    replaceOne: ["filter", "doc"],
    updateMany: ["filter", "update"],
    updateOne: ["filter", "update"]
  };
  var Mongo = function() {
    function Mongo2(options) {
      if (options === void 0) {
        options = {};
      }
      this.name = Mongo2.id;
      this._operations = Array.isArray(options.operations) ? options.operations : OPERATIONS;
      this._describeOperations = "describeOperations" in options ? options.describeOperations : true;
      this._useMongoose = !!options.useMongoose;
    }
    Mongo2.prototype.setupOnce = function(_2, getCurrentHub) {
      var collection;
      var moduleName = this._useMongoose ? "mongoose" : "mongodb";
      try {
        var mongodbModule = utils_1.dynamicRequire(module2, moduleName);
        collection = mongodbModule.Collection;
      } catch (e) {
        utils_1.logger.error("Mongo Integration was unable to require `" + moduleName + "` package.");
        return;
      }
      this._instrumentOperations(collection, this._operations, getCurrentHub);
    };
    Mongo2.prototype._instrumentOperations = function(collection, operations, getCurrentHub) {
      var _this = this;
      operations.forEach(function(operation) {
        return _this._patchOperation(collection, operation, getCurrentHub);
      });
    };
    Mongo2.prototype._patchOperation = function(collection, operation, getCurrentHub) {
      if (!(operation in collection.prototype))
        return;
      var getSpanContext = this._getSpanContextFromOperationArguments.bind(this);
      utils_1.fill(collection.prototype, operation, function(orig) {
        return function() {
          var args2 = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args2[_i] = arguments[_i];
          }
          var _a, _b, _c, _d;
          var lastArg = args2[args2.length - 1];
          var scope = getCurrentHub().getScope();
          var parentSpan = (_a = scope) === null || _a === void 0 ? void 0 : _a.getSpan();
          if (typeof lastArg !== "function" || operation === "mapReduce" && args2.length === 2) {
            var span_1 = (_b = parentSpan) === null || _b === void 0 ? void 0 : _b.startChild(getSpanContext(this, operation, args2));
            var maybePromise = orig.call.apply(orig, tslib_1.__spread([this], args2));
            if (utils_1.isThenable(maybePromise)) {
              return maybePromise.then(function(res) {
                var _a2;
                (_a2 = span_1) === null || _a2 === void 0 ? void 0 : _a2.finish();
                return res;
              });
            } else {
              (_c = span_1) === null || _c === void 0 ? void 0 : _c.finish();
              return maybePromise;
            }
          }
          var span = (_d = parentSpan) === null || _d === void 0 ? void 0 : _d.startChild(getSpanContext(this, operation, args2.slice(0, -1)));
          return orig.call.apply(orig, tslib_1.__spread([this], args2.slice(0, -1), [function(err, result) {
            var _a2;
            (_a2 = span) === null || _a2 === void 0 ? void 0 : _a2.finish();
            lastArg(err, result);
          }]));
        };
      });
    };
    Mongo2.prototype._getSpanContextFromOperationArguments = function(collection, operation, args2) {
      var data = {
        collectionName: collection.collectionName,
        dbName: collection.dbName,
        namespace: collection.namespace
      };
      var spanContext = {
        op: "db",
        description: operation,
        data
      };
      var signature = OPERATION_SIGNATURES[operation];
      var shouldDescribe = Array.isArray(this._describeOperations) ? this._describeOperations.includes(operation) : this._describeOperations;
      if (!signature || !shouldDescribe) {
        return spanContext;
      }
      try {
        if (operation === "mapReduce") {
          var _a = tslib_1.__read(args2, 2), map = _a[0], reduce = _a[1];
          data[signature[0]] = typeof map === "string" ? map : map.name || "<anonymous>";
          data[signature[1]] = typeof reduce === "string" ? reduce : reduce.name || "<anonymous>";
        } else {
          for (var i = 0; i < signature.length; i++) {
            data[signature[i]] = JSON.stringify(args2[i]);
          }
        }
      } catch (_oO) {
      }
      return spanContext;
    };
    Mongo2.id = "Mongo";
    return Mongo2;
  }();
  exports2.Mongo = Mongo;
});

// ../../node_modules/.pnpm/@sentry+tracing@6.2.5/node_modules/@sentry/tracing/dist/integrations/index.js
var require_integrations3 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var express_1 = require_express();
  exports2.Express = express_1.Express;
  var postgres_1 = require_postgres();
  exports2.Postgres = postgres_1.Postgres;
  var mysql_1 = require_mysql();
  exports2.Mysql = mysql_1.Mysql;
  var mongo_1 = require_mongo();
  exports2.Mongo = mongo_1.Mongo;
});

// ../../node_modules/.pnpm/@sentry+tracing@6.2.5/node_modules/@sentry/tracing/dist/index.js
var require_dist21 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib_1 = require_tslib();
  var browser_1 = require_browser3();
  var hubextensions_1 = require_hubextensions();
  exports2.addExtensionMethods = hubextensions_1.addExtensionMethods;
  var TracingIntegrations = require_integrations3();
  var Integrations = tslib_1.__assign(tslib_1.__assign({}, TracingIntegrations), {BrowserTracing: browser_1.BrowserTracing});
  exports2.Integrations = Integrations;
  var span_1 = require_span();
  exports2.Span = span_1.Span;
  var transaction_1 = require_transaction2();
  exports2.Transaction = transaction_1.Transaction;
  var browser_2 = require_browser3();
  exports2.registerRequestInstrumentation = browser_2.instrumentOutgoingRequests;
  exports2.defaultRequestInstrumentationOptions = browser_2.defaultRequestInstrumentationOptions;
  var spanstatus_1 = require_spanstatus();
  exports2.SpanStatus = spanstatus_1.SpanStatus;
  var idletransaction_1 = require_idletransaction();
  exports2.IdleTransaction = idletransaction_1.IdleTransaction;
  var hubextensions_2 = require_hubextensions();
  exports2.startIdleTransaction = hubextensions_2.startIdleTransaction;
  hubextensions_1.addExtensionMethods();
  var utils_1 = require_utils6();
  exports2.extractTraceparentData = utils_1.extractTraceparentData;
  exports2.getActiveTransaction = utils_1.getActiveTransaction;
  exports2.hasTracingEnabled = utils_1.hasTracingEnabled;
  exports2.stripUrlQueryAndFragment = utils_1.stripUrlQueryAndFragment;
  exports2.TRACEPARENT_REGEXP = utils_1.TRACEPARENT_REGEXP;
});

// ../../node_modules/.pnpm/cookie@0.4.1/node_modules/cookie/index.js
var require_cookie = __commonJS((exports2) => {
  /*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  exports2.parse = parse2;
  exports2.serialize = serialize;
  var decode = decodeURIComponent;
  var encode = encodeURIComponent;
  var pairSplitRegExp = /; */;
  var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
  function parse2(str, options) {
    if (typeof str !== "string") {
      throw new TypeError("argument str must be a string");
    }
    var obj = {};
    var opt = options || {};
    var pairs = str.split(pairSplitRegExp);
    var dec = opt.decode || decode;
    for (var i = 0; i < pairs.length; i++) {
      var pair = pairs[i];
      var eq_idx = pair.indexOf("=");
      if (eq_idx < 0) {
        continue;
      }
      var key = pair.substr(0, eq_idx).trim();
      var val = pair.substr(++eq_idx, pair.length).trim();
      if (val[0] == '"') {
        val = val.slice(1, -1);
      }
      if (obj[key] == void 0) {
        obj[key] = tryDecode(val, dec);
      }
    }
    return obj;
  }
  function serialize(name, val, options) {
    var opt = options || {};
    var enc = opt.encode || encode;
    if (typeof enc !== "function") {
      throw new TypeError("option encode is invalid");
    }
    if (!fieldContentRegExp.test(name)) {
      throw new TypeError("argument name is invalid");
    }
    var value = enc(val);
    if (value && !fieldContentRegExp.test(value)) {
      throw new TypeError("argument val is invalid");
    }
    var str = name + "=" + value;
    if (opt.maxAge != null) {
      var maxAge = opt.maxAge - 0;
      if (isNaN(maxAge) || !isFinite(maxAge)) {
        throw new TypeError("option maxAge is invalid");
      }
      str += "; Max-Age=" + Math.floor(maxAge);
    }
    if (opt.domain) {
      if (!fieldContentRegExp.test(opt.domain)) {
        throw new TypeError("option domain is invalid");
      }
      str += "; Domain=" + opt.domain;
    }
    if (opt.path) {
      if (!fieldContentRegExp.test(opt.path)) {
        throw new TypeError("option path is invalid");
      }
      str += "; Path=" + opt.path;
    }
    if (opt.expires) {
      if (typeof opt.expires.toUTCString !== "function") {
        throw new TypeError("option expires is invalid");
      }
      str += "; Expires=" + opt.expires.toUTCString();
    }
    if (opt.httpOnly) {
      str += "; HttpOnly";
    }
    if (opt.secure) {
      str += "; Secure";
    }
    if (opt.sameSite) {
      var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
      switch (sameSite) {
        case true:
          str += "; SameSite=Strict";
          break;
        case "lax":
          str += "; SameSite=Lax";
          break;
        case "strict":
          str += "; SameSite=Strict";
          break;
        case "none":
          str += "; SameSite=None";
          break;
        default:
          throw new TypeError("option sameSite is invalid");
      }
    }
    return str;
  }
  function tryDecode(str, decode2) {
    try {
      return decode2(str);
    } catch (e) {
      return str;
    }
  }
});

// ../../node_modules/.pnpm/@sentry+node@6.2.5/node_modules/@sentry/node/dist/handlers.js
var require_handlers = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib_1 = require_tslib();
  var core_1 = require_dist20();
  var tracing_1 = require_dist21();
  var utils_1 = require_dist17();
  var cookie = require_cookie();
  var domain = require("domain");
  var os3 = require("os");
  var url = require("url");
  var sdk_1 = require_sdk2();
  function tracingHandler() {
    return function sentryTracingMiddleware(req, res, next) {
      var traceparentData;
      if (req.headers && utils_1.isString(req.headers["sentry-trace"])) {
        traceparentData = tracing_1.extractTraceparentData(req.headers["sentry-trace"]);
      }
      var transaction = core_1.startTransaction(tslib_1.__assign({name: extractExpressTransactionName(req, {path: true, method: true}), op: "http.server"}, traceparentData), {request: extractRequestData(req)});
      core_1.getCurrentHub().configureScope(function(scope) {
        scope.setSpan(transaction);
      });
      res.__sentry_transaction = transaction;
      res.once("finish", function() {
        setImmediate(function() {
          addExpressReqToTransaction(transaction, req);
          transaction.setHttpStatus(res.statusCode);
          transaction.finish();
        });
      });
      next();
    };
  }
  exports2.tracingHandler = tracingHandler;
  function addExpressReqToTransaction(transaction, req) {
    if (!transaction)
      return;
    transaction.name = extractExpressTransactionName(req, {path: true, method: true});
    transaction.setData("url", req.originalUrl);
    transaction.setData("baseUrl", req.baseUrl);
    transaction.setData("query", req.query);
  }
  function extractExpressTransactionName(req, options) {
    if (options === void 0) {
      options = {};
    }
    var _a;
    var method = (_a = req.method) === null || _a === void 0 ? void 0 : _a.toUpperCase();
    var path10 = "";
    if (req.route) {
      path10 = "" + (req.baseUrl || "") + req.route.path;
    } else if (req.originalUrl || req.url) {
      path10 = utils_1.stripUrlQueryAndFragment(req.originalUrl || req.url || "");
    }
    var info = "";
    if (options.method && method) {
      info += method;
    }
    if (options.method && options.path) {
      info += " ";
    }
    if (options.path && path10) {
      info += path10;
    }
    return info;
  }
  function extractTransaction(req, type) {
    var _a;
    switch (type) {
      case "path": {
        return extractExpressTransactionName(req, {path: true});
      }
      case "handler": {
        return ((_a = req.route) === null || _a === void 0 ? void 0 : _a.stack[0].name) || "<anonymous>";
      }
      case "methodPath":
      default: {
        return extractExpressTransactionName(req, {path: true, method: true});
      }
    }
  }
  var DEFAULT_USER_KEYS = ["id", "username", "email"];
  function extractUserData(user, keys) {
    var extractedUser = {};
    var attributes = Array.isArray(keys) ? keys : DEFAULT_USER_KEYS;
    attributes.forEach(function(key) {
      if (user && key in user) {
        extractedUser[key] = user[key];
      }
    });
    return extractedUser;
  }
  var DEFAULT_REQUEST_KEYS = ["cookies", "data", "headers", "method", "query_string", "url"];
  function extractRequestData(req, keys) {
    if (keys === void 0) {
      keys = DEFAULT_REQUEST_KEYS;
    }
    var requestData = {};
    var headers = req.headers || req.header || {};
    var method = req.method;
    var host = req.hostname || req.host || headers.host || "<no host>";
    var protocol = req.protocol === "https" || req.secure || (req.socket || {}).encrypted ? "https" : "http";
    var originalUrl = req.originalUrl || req.url || "";
    var absoluteUrl = protocol + "://" + host + originalUrl;
    keys.forEach(function(key) {
      switch (key) {
        case "headers":
          requestData.headers = headers;
          break;
        case "method":
          requestData.method = method;
          break;
        case "url":
          requestData.url = absoluteUrl;
          break;
        case "cookies":
          requestData.cookies = req.cookies || cookie.parse(headers.cookie || "");
          break;
        case "query_string":
          requestData.query_string = url.parse(originalUrl || "", false).query;
          break;
        case "data":
          if (method === "GET" || method === "HEAD") {
            break;
          }
          if (req.body !== void 0) {
            requestData.data = utils_1.isString(req.body) ? req.body : JSON.stringify(utils_1.normalize(req.body));
          }
          break;
        default:
          if ({}.hasOwnProperty.call(req, key)) {
            requestData[key] = req[key];
          }
      }
    });
    return requestData;
  }
  exports2.extractRequestData = extractRequestData;
  function parseRequest(event, req, options) {
    options = tslib_1.__assign({ip: false, request: true, serverName: true, transaction: true, user: true, version: true}, options);
    if (options.version) {
      event.contexts = tslib_1.__assign(tslib_1.__assign({}, event.contexts), {runtime: {
        name: "node",
        version: global.process.version
      }});
    }
    if (options.request) {
      var extractedRequestData = Array.isArray(options.request) ? extractRequestData(req, options.request) : extractRequestData(req);
      event.request = tslib_1.__assign(tslib_1.__assign({}, event.request), extractedRequestData);
    }
    if (options.serverName && !event.server_name) {
      event.server_name = global.process.env.SENTRY_NAME || os3.hostname();
    }
    if (options.user) {
      var extractedUser = req.user && utils_1.isPlainObject(req.user) ? extractUserData(req.user, options.user) : {};
      if (Object.keys(extractedUser)) {
        event.user = tslib_1.__assign(tslib_1.__assign({}, event.user), extractedUser);
      }
    }
    if (options.ip) {
      var ip = req.ip || req.connection && req.connection.remoteAddress;
      if (ip) {
        event.user = tslib_1.__assign(tslib_1.__assign({}, event.user), {ip_address: ip});
      }
    }
    if (options.transaction && !event.transaction) {
      event.transaction = extractTransaction(req, options.transaction);
    }
    return event;
  }
  exports2.parseRequest = parseRequest;
  function requestHandler(options) {
    return function sentryRequestMiddleware(req, res, next) {
      if (options && options.flushTimeout && options.flushTimeout > 0) {
        var _end_1 = res.end;
        res.end = function(chunk, encoding, cb) {
          var _this = this;
          sdk_1.flush(options.flushTimeout).then(function() {
            _end_1.call(_this, chunk, encoding, cb);
          }).then(null, function(e) {
            utils_1.logger.error(e);
          });
        };
      }
      var local = domain.create();
      local.add(req);
      local.add(res);
      local.on("error", next);
      local.run(function() {
        core_1.getCurrentHub().configureScope(function(scope) {
          return scope.addEventProcessor(function(event) {
            return parseRequest(event, req, options);
          });
        });
        next();
      });
    };
  }
  exports2.requestHandler = requestHandler;
  function getStatusCodeFromResponse(error) {
    var statusCode = error.status || error.statusCode || error.status_code || error.output && error.output.statusCode;
    return statusCode ? parseInt(statusCode, 10) : 500;
  }
  function defaultShouldHandleError(error) {
    var status = getStatusCodeFromResponse(error);
    return status >= 500;
  }
  function errorHandler(options) {
    return function sentryErrorMiddleware(error, _req, res, next) {
      var shouldHandleError = options && options.shouldHandleError || defaultShouldHandleError;
      if (shouldHandleError(error)) {
        core_1.withScope(function(_scope) {
          var transaction = res.__sentry_transaction;
          if (transaction && _scope.getSpan() === void 0) {
            _scope.setSpan(transaction);
          }
          var eventId = core_1.captureException(error);
          res.sentry = eventId;
          next(error);
        });
        return;
      }
      next(error);
    };
  }
  exports2.errorHandler = errorHandler;
});

// ../../node_modules/.pnpm/@sentry+node@6.2.5/node_modules/@sentry/node/dist/index.js
var require_dist22 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib_1 = require_tslib();
  var types_1 = require_dist16();
  exports2.Severity = types_1.Severity;
  exports2.Status = types_1.Status;
  var core_1 = require_dist20();
  exports2.addGlobalEventProcessor = core_1.addGlobalEventProcessor;
  exports2.addBreadcrumb = core_1.addBreadcrumb;
  exports2.captureException = core_1.captureException;
  exports2.captureEvent = core_1.captureEvent;
  exports2.captureMessage = core_1.captureMessage;
  exports2.configureScope = core_1.configureScope;
  exports2.getHubFromCarrier = core_1.getHubFromCarrier;
  exports2.getCurrentHub = core_1.getCurrentHub;
  exports2.Hub = core_1.Hub;
  exports2.makeMain = core_1.makeMain;
  exports2.Scope = core_1.Scope;
  exports2.startTransaction = core_1.startTransaction;
  exports2.SDK_VERSION = core_1.SDK_VERSION;
  exports2.setContext = core_1.setContext;
  exports2.setExtra = core_1.setExtra;
  exports2.setExtras = core_1.setExtras;
  exports2.setTag = core_1.setTag;
  exports2.setTags = core_1.setTags;
  exports2.setUser = core_1.setUser;
  exports2.withScope = core_1.withScope;
  var backend_1 = require_backend();
  exports2.NodeBackend = backend_1.NodeBackend;
  var client_1 = require_client2();
  exports2.NodeClient = client_1.NodeClient;
  var sdk_1 = require_sdk2();
  exports2.defaultIntegrations = sdk_1.defaultIntegrations;
  exports2.init = sdk_1.init;
  exports2.lastEventId = sdk_1.lastEventId;
  exports2.flush = sdk_1.flush;
  exports2.close = sdk_1.close;
  var version_1 = require_version2();
  exports2.SDK_NAME = version_1.SDK_NAME;
  var core_2 = require_dist20();
  var hub_1 = require_dist18();
  var domain = require("domain");
  var Handlers = require_handlers();
  exports2.Handlers = Handlers;
  var NodeIntegrations = require_integrations2();
  var Transports = require_transports();
  exports2.Transports = Transports;
  var INTEGRATIONS = tslib_1.__assign(tslib_1.__assign({}, core_2.Integrations), NodeIntegrations);
  exports2.Integrations = INTEGRATIONS;
  var carrier = hub_1.getMainCarrier();
  if (carrier.__SENTRY__) {
    carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};
    carrier.__SENTRY__.extensions.domain = carrier.__SENTRY__.extensions.domain || domain;
  }
});

// ../../node_modules/.pnpm/untildify@4.0.0/node_modules/untildify/index.js
var require_untildify = __commonJS((exports2, module2) => {
  "use strict";
  var os3 = require("os");
  var homeDirectory = os3.homedir();
  module2.exports = (pathWithTilde) => {
    if (typeof pathWithTilde !== "string") {
      throw new TypeError(`Expected a string, got ${typeof pathWithTilde}`);
    }
    return homeDirectory ? pathWithTilde.replace(/^~(?=$|\/|\\)/, homeDirectory) : pathWithTilde;
  };
});

// ../../node_modules/.pnpm/@prisma+studio-server@0.423.0_@prisma+client@2.30.2/node_modules/@prisma/studio-server/dist/services/ProjectService.js
var require_ProjectService = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var ProjectService = class {
    init(options) {
      this.project = {
        name: options.name,
        schemaPath: options.schemaPath
      };
    }
    get() {
      return this.project;
    }
    getAll() {
      return [this.project];
    }
    respond(action, _payload) {
      const responsePayload = {
        error: null,
        data: null
      };
      switch (action) {
        case "get":
          responsePayload.data = this.get();
          break;
        case "getAll":
          responsePayload.data = this.getAll();
          break;
      }
      return Promise.resolve(responsePayload);
    }
  };
  exports2.default = new ProjectService();
});

// ../../node_modules/.pnpm/depd@1.1.2/node_modules/depd/lib/compat/callsite-tostring.js
var require_callsite_tostring = __commonJS((exports2, module2) => {
  /*!
   * depd
   * Copyright(c) 2014 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  module2.exports = callSiteToString2;
  function callSiteFileLocation(callSite) {
    var fileName;
    var fileLocation = "";
    if (callSite.isNative()) {
      fileLocation = "native";
    } else if (callSite.isEval()) {
      fileName = callSite.getScriptNameOrSourceURL();
      if (!fileName) {
        fileLocation = callSite.getEvalOrigin();
      }
    } else {
      fileName = callSite.getFileName();
    }
    if (fileName) {
      fileLocation += fileName;
      var lineNumber = callSite.getLineNumber();
      if (lineNumber != null) {
        fileLocation += ":" + lineNumber;
        var columnNumber = callSite.getColumnNumber();
        if (columnNumber) {
          fileLocation += ":" + columnNumber;
        }
      }
    }
    return fileLocation || "unknown source";
  }
  function callSiteToString2(callSite) {
    var addSuffix = true;
    var fileLocation = callSiteFileLocation(callSite);
    var functionName = callSite.getFunctionName();
    var isConstructor = callSite.isConstructor();
    var isMethodCall = !(callSite.isToplevel() || isConstructor);
    var line = "";
    if (isMethodCall) {
      var methodName = callSite.getMethodName();
      var typeName = getConstructorName(callSite);
      if (functionName) {
        if (typeName && functionName.indexOf(typeName) !== 0) {
          line += typeName + ".";
        }
        line += functionName;
        if (methodName && functionName.lastIndexOf("." + methodName) !== functionName.length - methodName.length - 1) {
          line += " [as " + methodName + "]";
        }
      } else {
        line += typeName + "." + (methodName || "<anonymous>");
      }
    } else if (isConstructor) {
      line += "new " + (functionName || "<anonymous>");
    } else if (functionName) {
      line += functionName;
    } else {
      addSuffix = false;
      line += fileLocation;
    }
    if (addSuffix) {
      line += " (" + fileLocation + ")";
    }
    return line;
  }
  function getConstructorName(obj) {
    var receiver = obj.receiver;
    return receiver.constructor && receiver.constructor.name || null;
  }
});

// ../../node_modules/.pnpm/depd@1.1.2/node_modules/depd/lib/compat/event-listener-count.js
var require_event_listener_count = __commonJS((exports2, module2) => {
  /*!
   * depd
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  module2.exports = eventListenerCount2;
  function eventListenerCount2(emitter, type) {
    return emitter.listeners(type).length;
  }
});

// ../../node_modules/.pnpm/depd@1.1.2/node_modules/depd/lib/compat/index.js
var require_compat = __commonJS((exports2, module2) => {
  /*!
   * depd
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var EventEmitter = require("events").EventEmitter;
  lazyProperty(module2.exports, "callSiteToString", function callSiteToString2() {
    var limit = Error.stackTraceLimit;
    var obj = {};
    var prep = Error.prepareStackTrace;
    function prepareObjectStackTrace2(obj2, stack2) {
      return stack2;
    }
    Error.prepareStackTrace = prepareObjectStackTrace2;
    Error.stackTraceLimit = 2;
    Error.captureStackTrace(obj);
    var stack = obj.stack.slice();
    Error.prepareStackTrace = prep;
    Error.stackTraceLimit = limit;
    return stack[0].toString ? toString : require_callsite_tostring();
  });
  lazyProperty(module2.exports, "eventListenerCount", function eventListenerCount2() {
    return EventEmitter.listenerCount || require_event_listener_count();
  });
  function lazyProperty(obj, prop, getter) {
    function get() {
      var val = getter();
      Object.defineProperty(obj, prop, {
        configurable: true,
        enumerable: true,
        value: val
      });
      return val;
    }
    Object.defineProperty(obj, prop, {
      configurable: true,
      enumerable: true,
      get
    });
  }
  function toString(obj) {
    return obj.toString();
  }
});

// ../../node_modules/.pnpm/depd@1.1.2/node_modules/depd/index.js
var require_depd = __commonJS((exports, module) => {
  /*!
   * depd
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   */
  var callSiteToString = require_compat().callSiteToString;
  var eventListenerCount = require_compat().eventListenerCount;
  var relative = require("path").relative;
  module.exports = depd;
  var basePath = process.cwd();
  function containsNamespace(str, namespace) {
    var vals = str.split(/[ ,]+/);
    var ns = String(namespace).toLowerCase();
    for (var i = 0; i < vals.length; i++) {
      var val = vals[i];
      if (val && (val === "*" || val.toLowerCase() === ns)) {
        return true;
      }
    }
    return false;
  }
  function convertDataDescriptorToAccessor(obj, prop, message) {
    var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
    var value = descriptor.value;
    descriptor.get = function getter() {
      return value;
    };
    if (descriptor.writable) {
      descriptor.set = function setter(val) {
        return value = val;
      };
    }
    delete descriptor.value;
    delete descriptor.writable;
    Object.defineProperty(obj, prop, descriptor);
    return descriptor;
  }
  function createArgumentsString(arity) {
    var str = "";
    for (var i = 0; i < arity; i++) {
      str += ", arg" + i;
    }
    return str.substr(2);
  }
  function createStackString(stack) {
    var str = this.name + ": " + this.namespace;
    if (this.message) {
      str += " deprecated " + this.message;
    }
    for (var i = 0; i < stack.length; i++) {
      str += "\n    at " + callSiteToString(stack[i]);
    }
    return str;
  }
  function depd(namespace) {
    if (!namespace) {
      throw new TypeError("argument namespace is required");
    }
    var stack = getStack();
    var site = callSiteLocation(stack[1]);
    var file = site[0];
    function deprecate(message) {
      log.call(deprecate, message);
    }
    deprecate._file = file;
    deprecate._ignored = isignored(namespace);
    deprecate._namespace = namespace;
    deprecate._traced = istraced(namespace);
    deprecate._warned = Object.create(null);
    deprecate.function = wrapfunction;
    deprecate.property = wrapproperty;
    return deprecate;
  }
  function isignored(namespace) {
    if (process.noDeprecation) {
      return true;
    }
    var str = process.env.NO_DEPRECATION || "";
    return containsNamespace(str, namespace);
  }
  function istraced(namespace) {
    if (process.traceDeprecation) {
      return true;
    }
    var str = process.env.TRACE_DEPRECATION || "";
    return containsNamespace(str, namespace);
  }
  function log(message, site) {
    var haslisteners = eventListenerCount(process, "deprecation") !== 0;
    if (!haslisteners && this._ignored) {
      return;
    }
    var caller;
    var callFile;
    var callSite;
    var depSite;
    var i = 0;
    var seen = false;
    var stack = getStack();
    var file = this._file;
    if (site) {
      depSite = site;
      callSite = callSiteLocation(stack[1]);
      callSite.name = depSite.name;
      file = callSite[0];
    } else {
      i = 2;
      depSite = callSiteLocation(stack[i]);
      callSite = depSite;
    }
    for (; i < stack.length; i++) {
      caller = callSiteLocation(stack[i]);
      callFile = caller[0];
      if (callFile === file) {
        seen = true;
      } else if (callFile === this._file) {
        file = this._file;
      } else if (seen) {
        break;
      }
    }
    var key = caller ? depSite.join(":") + "__" + caller.join(":") : void 0;
    if (key !== void 0 && key in this._warned) {
      return;
    }
    this._warned[key] = true;
    var msg = message;
    if (!msg) {
      msg = callSite === depSite || !callSite.name ? defaultMessage(depSite) : defaultMessage(callSite);
    }
    if (haslisteners) {
      var err = DeprecationError(this._namespace, msg, stack.slice(i));
      process.emit("deprecation", err);
      return;
    }
    var format10 = process.stderr.isTTY ? formatColor : formatPlain;
    var output = format10.call(this, msg, caller, stack.slice(i));
    process.stderr.write(output + "\n", "utf8");
  }
  function callSiteLocation(callSite) {
    var file = callSite.getFileName() || "<anonymous>";
    var line = callSite.getLineNumber();
    var colm = callSite.getColumnNumber();
    if (callSite.isEval()) {
      file = callSite.getEvalOrigin() + ", " + file;
    }
    var site = [file, line, colm];
    site.callSite = callSite;
    site.name = callSite.getFunctionName();
    return site;
  }
  function defaultMessage(site) {
    var callSite = site.callSite;
    var funcName = site.name;
    if (!funcName) {
      funcName = "<anonymous@" + formatLocation(site) + ">";
    }
    var context = callSite.getThis();
    var typeName = context && callSite.getTypeName();
    if (typeName === "Object") {
      typeName = void 0;
    }
    if (typeName === "Function") {
      typeName = context.name || typeName;
    }
    return typeName && callSite.getMethodName() ? typeName + "." + funcName : funcName;
  }
  function formatPlain(msg, caller, stack) {
    var timestamp = new Date().toUTCString();
    var formatted = timestamp + " " + this._namespace + " deprecated " + msg;
    if (this._traced) {
      for (var i = 0; i < stack.length; i++) {
        formatted += "\n    at " + callSiteToString(stack[i]);
      }
      return formatted;
    }
    if (caller) {
      formatted += " at " + formatLocation(caller);
    }
    return formatted;
  }
  function formatColor(msg, caller, stack) {
    var formatted = "[36;1m" + this._namespace + "[22;39m [33;1mdeprecated[22;39m [0m" + msg + "[39m";
    if (this._traced) {
      for (var i = 0; i < stack.length; i++) {
        formatted += "\n    [36mat " + callSiteToString(stack[i]) + "[39m";
      }
      return formatted;
    }
    if (caller) {
      formatted += " [36m" + formatLocation(caller) + "[39m";
    }
    return formatted;
  }
  function formatLocation(callSite) {
    return relative(basePath, callSite[0]) + ":" + callSite[1] + ":" + callSite[2];
  }
  function getStack() {
    var limit = Error.stackTraceLimit;
    var obj = {};
    var prep = Error.prepareStackTrace;
    Error.prepareStackTrace = prepareObjectStackTrace;
    Error.stackTraceLimit = Math.max(10, limit);
    Error.captureStackTrace(obj);
    var stack = obj.stack.slice(1);
    Error.prepareStackTrace = prep;
    Error.stackTraceLimit = limit;
    return stack;
  }
  function prepareObjectStackTrace(obj, stack) {
    return stack;
  }
  function wrapfunction(fn, message) {
    if (typeof fn !== "function") {
      throw new TypeError("argument fn must be a function");
    }
    var args = createArgumentsString(fn.length);
    var deprecate = this;
    var stack = getStack();
    var site = callSiteLocation(stack[1]);
    site.name = fn.name;
    var deprecatedfn = eval("(function (" + args + ') {\n"use strict"\nlog.call(deprecate, message, site)\nreturn fn.apply(this, arguments)\n})');
    return deprecatedfn;
  }
  function wrapproperty(obj, prop, message) {
    if (!obj || typeof obj !== "object" && typeof obj !== "function") {
      throw new TypeError("argument obj must be object");
    }
    var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
    if (!descriptor) {
      throw new TypeError("must call property on owner object");
    }
    if (!descriptor.configurable) {
      throw new TypeError("property must be configurable");
    }
    var deprecate = this;
    var stack = getStack();
    var site = callSiteLocation(stack[1]);
    site.name = prop;
    if ("value" in descriptor) {
      descriptor = convertDataDescriptorToAccessor(obj, prop, message);
    }
    var get = descriptor.get;
    var set = descriptor.set;
    if (typeof get === "function") {
      descriptor.get = function getter() {
        log.call(deprecate, message, site);
        return get.apply(this, arguments);
      };
    }
    if (typeof set === "function") {
      descriptor.set = function setter() {
        log.call(deprecate, message, site);
        return set.apply(this, arguments);
      };
    }
    Object.defineProperty(obj, prop, descriptor);
  }
  function DeprecationError(namespace, message, stack) {
    var error = new Error();
    var stackString;
    Object.defineProperty(error, "constructor", {
      value: DeprecationError
    });
    Object.defineProperty(error, "message", {
      configurable: true,
      enumerable: false,
      value: message,
      writable: true
    });
    Object.defineProperty(error, "name", {
      enumerable: false,
      configurable: true,
      value: "DeprecationError",
      writable: true
    });
    Object.defineProperty(error, "namespace", {
      configurable: true,
      enumerable: false,
      value: namespace,
      writable: true
    });
    Object.defineProperty(error, "stack", {
      configurable: true,
      enumerable: false,
      get: function() {
        if (stackString !== void 0) {
          return stackString;
        }
        return stackString = createStackString.call(this, stack);
      },
      set: function setter(val) {
        stackString = val;
      }
    });
    return error;
  }
});

// ../../node_modules/.pnpm/bytes@3.1.0/node_modules/bytes/index.js
var require_bytes = __commonJS((exports2, module2) => {
  /*!
   * bytes
   * Copyright(c) 2012-2014 TJ Holowaychuk
   * Copyright(c) 2015 Jed Watson
   * MIT Licensed
   */
  "use strict";
  module2.exports = bytes;
  module2.exports.format = format10;
  module2.exports.parse = parse2;
  var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
  var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
  var map = {
    b: 1,
    kb: 1 << 10,
    mb: 1 << 20,
    gb: 1 << 30,
    tb: Math.pow(1024, 4),
    pb: Math.pow(1024, 5)
  };
  var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
  function bytes(value, options) {
    if (typeof value === "string") {
      return parse2(value);
    }
    if (typeof value === "number") {
      return format10(value, options);
    }
    return null;
  }
  function format10(value, options) {
    if (!Number.isFinite(value)) {
      return null;
    }
    var mag = Math.abs(value);
    var thousandsSeparator = options && options.thousandsSeparator || "";
    var unitSeparator = options && options.unitSeparator || "";
    var decimalPlaces = options && options.decimalPlaces !== void 0 ? options.decimalPlaces : 2;
    var fixedDecimals = Boolean(options && options.fixedDecimals);
    var unit = options && options.unit || "";
    if (!unit || !map[unit.toLowerCase()]) {
      if (mag >= map.pb) {
        unit = "PB";
      } else if (mag >= map.tb) {
        unit = "TB";
      } else if (mag >= map.gb) {
        unit = "GB";
      } else if (mag >= map.mb) {
        unit = "MB";
      } else if (mag >= map.kb) {
        unit = "KB";
      } else {
        unit = "B";
      }
    }
    var val = value / map[unit.toLowerCase()];
    var str = val.toFixed(decimalPlaces);
    if (!fixedDecimals) {
      str = str.replace(formatDecimalsRegExp, "$1");
    }
    if (thousandsSeparator) {
      str = str.replace(formatThousandsRegExp, thousandsSeparator);
    }
    return str + unitSeparator + unit;
  }
  function parse2(val) {
    if (typeof val === "number" && !isNaN(val)) {
      return val;
    }
    if (typeof val !== "string") {
      return null;
    }
    var results = parseRegExp.exec(val);
    var floatValue;
    var unit = "b";
    if (!results) {
      floatValue = parseInt(val, 10);
      unit = "b";
    } else {
      floatValue = parseFloat(results[1]);
      unit = results[4].toLowerCase();
    }
    return Math.floor(map[unit] * floatValue);
  }
});

// ../../node_modules/.pnpm/content-type@1.0.4/node_modules/content-type/index.js
var require_content_type = __commonJS((exports2) => {
  /*!
   * content-type
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;
  var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/;
  var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
  var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g;
  var QUOTE_REGEXP = /([\\"])/g;
  var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
  exports2.format = format10;
  exports2.parse = parse2;
  function format10(obj) {
    if (!obj || typeof obj !== "object") {
      throw new TypeError("argument obj is required");
    }
    var parameters = obj.parameters;
    var type = obj.type;
    if (!type || !TYPE_REGEXP.test(type)) {
      throw new TypeError("invalid type");
    }
    var string = type;
    if (parameters && typeof parameters === "object") {
      var param;
      var params = Object.keys(parameters).sort();
      for (var i = 0; i < params.length; i++) {
        param = params[i];
        if (!TOKEN_REGEXP.test(param)) {
          throw new TypeError("invalid parameter name");
        }
        string += "; " + param + "=" + qstring(parameters[param]);
      }
    }
    return string;
  }
  function parse2(string) {
    if (!string) {
      throw new TypeError("argument string is required");
    }
    var header = typeof string === "object" ? getcontenttype(string) : string;
    if (typeof header !== "string") {
      throw new TypeError("argument string is required to be a string");
    }
    var index = header.indexOf(";");
    var type = index !== -1 ? header.substr(0, index).trim() : header.trim();
    if (!TYPE_REGEXP.test(type)) {
      throw new TypeError("invalid media type");
    }
    var obj = new ContentType(type.toLowerCase());
    if (index !== -1) {
      var key;
      var match;
      var value;
      PARAM_REGEXP.lastIndex = index;
      while (match = PARAM_REGEXP.exec(header)) {
        if (match.index !== index) {
          throw new TypeError("invalid parameter format");
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (value[0] === '"') {
          value = value.substr(1, value.length - 2).replace(QESC_REGEXP, "$1");
        }
        obj.parameters[key] = value;
      }
      if (index !== header.length) {
        throw new TypeError("invalid parameter format");
      }
    }
    return obj;
  }
  function getcontenttype(obj) {
    var header;
    if (typeof obj.getHeader === "function") {
      header = obj.getHeader("content-type");
    } else if (typeof obj.headers === "object") {
      header = obj.headers && obj.headers["content-type"];
    }
    if (typeof header !== "string") {
      throw new TypeError("content-type header is missing from object");
    }
    return header;
  }
  function qstring(val) {
    var str = String(val);
    if (TOKEN_REGEXP.test(str)) {
      return str;
    }
    if (str.length > 0 && !TEXT_REGEXP.test(str)) {
      throw new TypeError("invalid parameter value");
    }
    return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
  }
  function ContentType(type) {
    this.parameters = Object.create(null);
    this.type = type;
  }
});

// ../../node_modules/.pnpm/setprototypeof@1.1.1/node_modules/setprototypeof/index.js
var require_setprototypeof = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Object.setPrototypeOf || ({__proto__: []} instanceof Array ? setProtoOf : mixinProperties);
  function setProtoOf(obj, proto) {
    obj.__proto__ = proto;
    return obj;
  }
  function mixinProperties(obj, proto) {
    for (var prop in proto) {
      if (!obj.hasOwnProperty(prop)) {
        obj[prop] = proto[prop];
      }
    }
    return obj;
  }
});

// ../../node_modules/.pnpm/statuses@1.5.0/node_modules/statuses/codes.json
var require_codes = __commonJS((exports2, module2) => {
  module2.exports = {
    "100": "Continue",
    "101": "Switching Protocols",
    "102": "Processing",
    "103": "Early Hints",
    "200": "OK",
    "201": "Created",
    "202": "Accepted",
    "203": "Non-Authoritative Information",
    "204": "No Content",
    "205": "Reset Content",
    "206": "Partial Content",
    "207": "Multi-Status",
    "208": "Already Reported",
    "226": "IM Used",
    "300": "Multiple Choices",
    "301": "Moved Permanently",
    "302": "Found",
    "303": "See Other",
    "304": "Not Modified",
    "305": "Use Proxy",
    "306": "(Unused)",
    "307": "Temporary Redirect",
    "308": "Permanent Redirect",
    "400": "Bad Request",
    "401": "Unauthorized",
    "402": "Payment Required",
    "403": "Forbidden",
    "404": "Not Found",
    "405": "Method Not Allowed",
    "406": "Not Acceptable",
    "407": "Proxy Authentication Required",
    "408": "Request Timeout",
    "409": "Conflict",
    "410": "Gone",
    "411": "Length Required",
    "412": "Precondition Failed",
    "413": "Payload Too Large",
    "414": "URI Too Long",
    "415": "Unsupported Media Type",
    "416": "Range Not Satisfiable",
    "417": "Expectation Failed",
    "418": "I'm a teapot",
    "421": "Misdirected Request",
    "422": "Unprocessable Entity",
    "423": "Locked",
    "424": "Failed Dependency",
    "425": "Unordered Collection",
    "426": "Upgrade Required",
    "428": "Precondition Required",
    "429": "Too Many Requests",
    "431": "Request Header Fields Too Large",
    "451": "Unavailable For Legal Reasons",
    "500": "Internal Server Error",
    "501": "Not Implemented",
    "502": "Bad Gateway",
    "503": "Service Unavailable",
    "504": "Gateway Timeout",
    "505": "HTTP Version Not Supported",
    "506": "Variant Also Negotiates",
    "507": "Insufficient Storage",
    "508": "Loop Detected",
    "509": "Bandwidth Limit Exceeded",
    "510": "Not Extended",
    "511": "Network Authentication Required"
  };
});

// ../../node_modules/.pnpm/statuses@1.5.0/node_modules/statuses/index.js
var require_statuses = __commonJS((exports2, module2) => {
  /*!
   * statuses
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var codes = require_codes();
  module2.exports = status;
  status.STATUS_CODES = codes;
  status.codes = populateStatusesMap(status, codes);
  status.redirect = {
    300: true,
    301: true,
    302: true,
    303: true,
    305: true,
    307: true,
    308: true
  };
  status.empty = {
    204: true,
    205: true,
    304: true
  };
  status.retry = {
    502: true,
    503: true,
    504: true
  };
  function populateStatusesMap(statuses, codes2) {
    var arr = [];
    Object.keys(codes2).forEach(function forEachCode(code) {
      var message = codes2[code];
      var status2 = Number(code);
      statuses[status2] = message;
      statuses[message] = status2;
      statuses[message.toLowerCase()] = status2;
      arr.push(status2);
    });
    return arr;
  }
  function status(code) {
    if (typeof code === "number") {
      if (!status[code])
        throw new Error("invalid status code: " + code);
      return code;
    }
    if (typeof code !== "string") {
      throw new TypeError("code must be a number or string");
    }
    var n = parseInt(code, 10);
    if (!isNaN(n)) {
      if (!status[n])
        throw new Error("invalid status code: " + n);
      return n;
    }
    n = status[code.toLowerCase()];
    if (!n)
      throw new Error('invalid status message: "' + code + '"');
    return n;
  }
});

// ../../node_modules/.pnpm/inherits@2.0.3/node_modules/inherits/inherits_browser.js
var require_inherits_browser2 = __commonJS((exports2, module2) => {
  if (typeof Object.create === "function") {
    module2.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    };
  } else {
    module2.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    };
  }
});

// ../../node_modules/.pnpm/inherits@2.0.3/node_modules/inherits/inherits.js
var require_inherits2 = __commonJS((exports2, module2) => {
  try {
    util2 = require("util");
    if (typeof util2.inherits !== "function")
      throw "";
    module2.exports = util2.inherits;
  } catch (e) {
    module2.exports = require_inherits_browser2();
  }
  var util2;
});

// ../../node_modules/.pnpm/toidentifier@1.0.0/node_modules/toidentifier/index.js
var require_toidentifier = __commonJS((exports2, module2) => {
  /*!
   * toidentifier
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  module2.exports = toIdentifier;
  function toIdentifier(str) {
    return str.split(" ").map(function(token) {
      return token.slice(0, 1).toUpperCase() + token.slice(1);
    }).join("").replace(/[^ _0-9a-z]/gi, "");
  }
});

// ../../node_modules/.pnpm/http-errors@1.7.2/node_modules/http-errors/index.js
var require_http_errors = __commonJS((exports2, module2) => {
  /*!
   * http-errors
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var deprecate = require_depd()("http-errors");
  var setPrototypeOf = require_setprototypeof();
  var statuses = require_statuses();
  var inherits = require_inherits2();
  var toIdentifier = require_toidentifier();
  module2.exports = createError;
  module2.exports.HttpError = createHttpErrorConstructor();
  populateConstructorExports(module2.exports, statuses.codes, module2.exports.HttpError);
  function codeClass(status) {
    return Number(String(status).charAt(0) + "00");
  }
  function createError() {
    var err;
    var msg;
    var status = 500;
    var props = {};
    for (var i = 0; i < arguments.length; i++) {
      var arg10 = arguments[i];
      if (arg10 instanceof Error) {
        err = arg10;
        status = err.status || err.statusCode || status;
        continue;
      }
      switch (typeof arg10) {
        case "string":
          msg = arg10;
          break;
        case "number":
          status = arg10;
          if (i !== 0) {
            deprecate("non-first-argument status code; replace with createError(" + arg10 + ", ...)");
          }
          break;
        case "object":
          props = arg10;
          break;
      }
    }
    if (typeof status === "number" && (status < 400 || status >= 600)) {
      deprecate("non-error status code; use only 4xx or 5xx status codes");
    }
    if (typeof status !== "number" || !statuses[status] && (status < 400 || status >= 600)) {
      status = 500;
    }
    var HttpError = createError[status] || createError[codeClass(status)];
    if (!err) {
      err = HttpError ? new HttpError(msg) : new Error(msg || statuses[status]);
      Error.captureStackTrace(err, createError);
    }
    if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
      err.expose = status < 500;
      err.status = err.statusCode = status;
    }
    for (var key in props) {
      if (key !== "status" && key !== "statusCode") {
        err[key] = props[key];
      }
    }
    return err;
  }
  function createHttpErrorConstructor() {
    function HttpError() {
      throw new TypeError("cannot construct abstract class");
    }
    inherits(HttpError, Error);
    return HttpError;
  }
  function createClientErrorConstructor(HttpError, name, code) {
    var className = name.match(/Error$/) ? name : name + "Error";
    function ClientError(message) {
      var msg = message != null ? message : statuses[code];
      var err = new Error(msg);
      Error.captureStackTrace(err, ClientError);
      setPrototypeOf(err, ClientError.prototype);
      Object.defineProperty(err, "message", {
        enumerable: true,
        configurable: true,
        value: msg,
        writable: true
      });
      Object.defineProperty(err, "name", {
        enumerable: false,
        configurable: true,
        value: className,
        writable: true
      });
      return err;
    }
    inherits(ClientError, HttpError);
    nameFunc(ClientError, className);
    ClientError.prototype.status = code;
    ClientError.prototype.statusCode = code;
    ClientError.prototype.expose = true;
    return ClientError;
  }
  function createServerErrorConstructor(HttpError, name, code) {
    var className = name.match(/Error$/) ? name : name + "Error";
    function ServerError(message) {
      var msg = message != null ? message : statuses[code];
      var err = new Error(msg);
      Error.captureStackTrace(err, ServerError);
      setPrototypeOf(err, ServerError.prototype);
      Object.defineProperty(err, "message", {
        enumerable: true,
        configurable: true,
        value: msg,
        writable: true
      });
      Object.defineProperty(err, "name", {
        enumerable: false,
        configurable: true,
        value: className,
        writable: true
      });
      return err;
    }
    inherits(ServerError, HttpError);
    nameFunc(ServerError, className);
    ServerError.prototype.status = code;
    ServerError.prototype.statusCode = code;
    ServerError.prototype.expose = false;
    return ServerError;
  }
  function nameFunc(func, name) {
    var desc = Object.getOwnPropertyDescriptor(func, "name");
    if (desc && desc.configurable) {
      desc.value = name;
      Object.defineProperty(func, "name", desc);
    }
  }
  function populateConstructorExports(exports3, codes, HttpError) {
    codes.forEach(function forEachCode(code) {
      var CodeError;
      var name = toIdentifier(statuses[code]);
      switch (codeClass(code)) {
        case 400:
          CodeError = createClientErrorConstructor(HttpError, name, code);
          break;
        case 500:
          CodeError = createServerErrorConstructor(HttpError, name, code);
          break;
      }
      if (CodeError) {
        exports3[code] = CodeError;
        exports3[name] = CodeError;
      }
    });
    exports3["I'mateapot"] = deprecate.function(exports3.ImATeapot, `"I'mateapot"; use "ImATeapot" instead`);
  }
});

// ../../node_modules/.pnpm/ms@2.0.0/node_modules/ms/index.js
var require_ms3 = __commonJS((exports2, module2) => {
  var s2 = 1e3;
  var m2 = s2 * 60;
  var h2 = m2 * 60;
  var d2 = h2 * 24;
  var y2 = d2 * 365.25;
  module2.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse2(val);
    } else if (type === "number" && isNaN(val) === false) {
      return options.long ? fmtLong2(val) : fmtShort2(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y2;
      case "days":
      case "day":
      case "d":
        return n * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort2(ms2) {
    if (ms2 >= d2) {
      return Math.round(ms2 / d2) + "d";
    }
    if (ms2 >= h2) {
      return Math.round(ms2 / h2) + "h";
    }
    if (ms2 >= m2) {
      return Math.round(ms2 / m2) + "m";
    }
    if (ms2 >= s2) {
      return Math.round(ms2 / s2) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong2(ms2) {
    return plural2(ms2, d2, "day") || plural2(ms2, h2, "hour") || plural2(ms2, m2, "minute") || plural2(ms2, s2, "second") || ms2 + " ms";
  }
  function plural2(ms2, n, name) {
    if (ms2 < n) {
      return;
    }
    if (ms2 < n * 1.5) {
      return Math.floor(ms2 / n) + " " + name;
    }
    return Math.ceil(ms2 / n) + " " + name + "s";
  }
});

// ../../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/debug.js
var require_debug = __commonJS((exports2, module2) => {
  exports2 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
  exports2.coerce = coerce;
  exports2.disable = disable;
  exports2.enable = enable;
  exports2.enabled = enabled;
  exports2.humanize = require_ms3();
  exports2.names = [];
  exports2.skips = [];
  exports2.formatters = {};
  var prevTime;
  function selectColor(namespace) {
    var hash = 0, i;
    for (i in namespace) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0;
    }
    return exports2.colors[Math.abs(hash) % exports2.colors.length];
  }
  function createDebug(namespace) {
    function debug3() {
      if (!debug3.enabled)
        return;
      var self2 = debug3;
      var curr = +new Date();
      var ms2 = curr - (prevTime || curr);
      self2.diff = ms2;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      var args2 = new Array(arguments.length);
      for (var i = 0; i < args2.length; i++) {
        args2[i] = arguments[i];
      }
      args2[0] = exports2.coerce(args2[0]);
      if (typeof args2[0] !== "string") {
        args2.unshift("%O");
      }
      var index = 0;
      args2[0] = args2[0].replace(/%([a-zA-Z%])/g, function(match, format10) {
        if (match === "%%")
          return match;
        index++;
        var formatter = exports2.formatters[format10];
        if (typeof formatter === "function") {
          var val = args2[index];
          match = formatter.call(self2, val);
          args2.splice(index, 1);
          index--;
        }
        return match;
      });
      exports2.formatArgs.call(self2, args2);
      var logFn = debug3.log || exports2.log || console.log.bind(console);
      logFn.apply(self2, args2);
    }
    debug3.namespace = namespace;
    debug3.enabled = exports2.enabled(namespace);
    debug3.useColors = exports2.useColors();
    debug3.color = selectColor(namespace);
    if (typeof exports2.init === "function") {
      exports2.init(debug3);
    }
    return debug3;
  }
  function enable(namespaces) {
    exports2.save(namespaces);
    exports2.names = [];
    exports2.skips = [];
    var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    var len = split.length;
    for (var i = 0; i < len; i++) {
      if (!split[i])
        continue;
      namespaces = split[i].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
      } else {
        exports2.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable() {
    exports2.enable("");
  }
  function enabled(name) {
    var i, len;
    for (i = 0, len = exports2.skips.length; i < len; i++) {
      if (exports2.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = exports2.names.length; i < len; i++) {
      if (exports2.names[i].test(name)) {
        return true;
      }
    }
    return false;
  }
  function coerce(val) {
    if (val instanceof Error)
      return val.stack || val.message;
    return val;
  }
});

// ../../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/browser.js
var require_browser4 = __commonJS((exports2, module2) => {
  exports2 = module2.exports = require_debug();
  exports2.log = log2;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load2;
  exports2.useColors = useColors;
  exports2.storage = typeof chrome != "undefined" && typeof chrome.storage != "undefined" ? chrome.storage.local : localstorage();
  exports2.colors = [
    "lightseagreen",
    "forestgreen",
    "goldenrod",
    "dodgerblue",
    "darkorchid",
    "crimson"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
      return true;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  exports2.formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (err) {
      return "[UnexpectedJSONParseError]: " + err.message;
    }
  };
  function formatArgs(args2) {
    var useColors2 = this.useColors;
    args2[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args2[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
    if (!useColors2)
      return;
    var c = "color: " + this.color;
    args2.splice(1, 0, c, "color: inherit");
    var index = 0;
    var lastC = 0;
    args2[0].replace(/%[a-zA-Z%]/g, function(match) {
      if (match === "%%")
        return;
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args2.splice(lastC, 0, c);
  }
  function log2() {
    return typeof console === "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
  }
  function save(namespaces) {
    try {
      if (namespaces == null) {
        exports2.storage.removeItem("debug");
      } else {
        exports2.storage.debug = namespaces;
      }
    } catch (e) {
    }
  }
  function load2() {
    var r;
    try {
      r = exports2.storage.debug;
    } catch (e) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  exports2.enable(load2());
  function localstorage() {
    try {
      return window.localStorage;
    } catch (e) {
    }
  }
});

// ../../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/node.js
var require_node7 = __commonJS((exports2, module2) => {
  var tty = require("tty");
  var util2 = require("util");
  exports2 = module2.exports = require_debug();
  exports2.init = init;
  exports2.log = log2;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load2;
  exports2.useColors = useColors;
  exports2.colors = [6, 2, 3, 4, 5, 1];
  exports2.inspectOpts = Object.keys(process.env).filter(function(key) {
    return /^debug_/i.test(key);
  }).reduce(function(obj, key) {
    var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_2, k) {
      return k.toUpperCase();
    });
    var val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val))
      val = true;
    else if (/^(no|off|false|disabled)$/i.test(val))
      val = false;
    else if (val === "null")
      val = null;
    else
      val = Number(val);
    obj[prop] = val;
    return obj;
  }, {});
  var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
  if (fd !== 1 && fd !== 2) {
    util2.deprecate(function() {
    }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
  }
  var stream = fd === 1 ? process.stdout : fd === 2 ? process.stderr : createWritableStdioStream(fd);
  function useColors() {
    return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(fd);
  }
  exports2.formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v, this.inspectOpts).split("\n").map(function(str) {
      return str.trim();
    }).join(" ");
  };
  exports2.formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v, this.inspectOpts);
  };
  function formatArgs(args2) {
    var name = this.namespace;
    var useColors2 = this.useColors;
    if (useColors2) {
      var c = this.color;
      var prefix = "  [3" + c + ";1m" + name + " [0m";
      args2[0] = prefix + args2[0].split("\n").join("\n" + prefix);
      args2.push("[3" + c + "m+" + exports2.humanize(this.diff) + "[0m");
    } else {
      args2[0] = new Date().toUTCString() + " " + name + " " + args2[0];
    }
  }
  function log2() {
    return stream.write(util2.format.apply(util2, arguments) + "\n");
  }
  function save(namespaces) {
    if (namespaces == null) {
      delete process.env.DEBUG;
    } else {
      process.env.DEBUG = namespaces;
    }
  }
  function load2() {
    return process.env.DEBUG;
  }
  function createWritableStdioStream(fd2) {
    var stream2;
    var tty_wrap = process.binding("tty_wrap");
    switch (tty_wrap.guessHandleType(fd2)) {
      case "TTY":
        stream2 = new tty.WriteStream(fd2);
        stream2._type = "tty";
        if (stream2._handle && stream2._handle.unref) {
          stream2._handle.unref();
        }
        break;
      case "FILE":
        var fs9 = require("fs");
        stream2 = new fs9.SyncWriteStream(fd2, {autoClose: false});
        stream2._type = "fs";
        break;
      case "PIPE":
      case "TCP":
        var net = require("net");
        stream2 = new net.Socket({
          fd: fd2,
          readable: false,
          writable: true
        });
        stream2.readable = false;
        stream2.read = null;
        stream2._type = "pipe";
        if (stream2._handle && stream2._handle.unref) {
          stream2._handle.unref();
        }
        break;
      default:
        throw new Error("Implement me. Unknown stream file type!");
    }
    stream2.fd = fd2;
    stream2._isStdio = true;
    return stream2;
  }
  function init(debug3) {
    debug3.inspectOpts = {};
    var keys = Object.keys(exports2.inspectOpts);
    for (var i = 0; i < keys.length; i++) {
      debug3.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
    }
  }
  exports2.enable(load2());
});

// ../../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/index.js
var require_src5 = __commonJS((exports2, module2) => {
  if (typeof process !== "undefined" && process.type === "renderer") {
    module2.exports = require_browser4();
  } else {
    module2.exports = require_node7();
  }
});

// ../../node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js
var require_safer = __commonJS((exports2, module2) => {
  "use strict";
  var buffer = require("buffer");
  var Buffer2 = buffer.Buffer;
  var safer = {};
  var key;
  for (key in buffer) {
    if (!buffer.hasOwnProperty(key))
      continue;
    if (key === "SlowBuffer" || key === "Buffer")
      continue;
    safer[key] = buffer[key];
  }
  var Safer = safer.Buffer = {};
  for (key in Buffer2) {
    if (!Buffer2.hasOwnProperty(key))
      continue;
    if (key === "allocUnsafe" || key === "allocUnsafeSlow")
      continue;
    Safer[key] = Buffer2[key];
  }
  safer.Buffer.prototype = Buffer2.prototype;
  if (!Safer.from || Safer.from === Uint8Array.from) {
    Safer.from = function(value, encodingOrOffset, length) {
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
      }
      if (value && typeof value.length === "undefined") {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      return Buffer2(value, encodingOrOffset, length);
    };
  }
  if (!Safer.alloc) {
    Safer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
      }
      if (size < 0 || size >= 2 * (1 << 30)) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
      var buf = Buffer2(size);
      if (!fill || fill.length === 0) {
        buf.fill(0);
      } else if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
      return buf;
    };
  }
  if (!safer.kStringMaxLength) {
    try {
      safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
    } catch (e) {
    }
  }
  if (!safer.constants) {
    safer.constants = {
      MAX_LENGTH: safer.kMaxLength
    };
    if (safer.kStringMaxLength) {
      safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
    }
  }
  module2.exports = safer;
});

// ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/lib/bom-handling.js
var require_bom_handling = __commonJS((exports2) => {
  "use strict";
  var BOMChar = "\uFEFF";
  exports2.PrependBOM = PrependBOMWrapper;
  function PrependBOMWrapper(encoder, options) {
    this.encoder = encoder;
    this.addBOM = true;
  }
  PrependBOMWrapper.prototype.write = function(str) {
    if (this.addBOM) {
      str = BOMChar + str;
      this.addBOM = false;
    }
    return this.encoder.write(str);
  };
  PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
  };
  exports2.StripBOM = StripBOMWrapper;
  function StripBOMWrapper(decoder, options) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options || {};
  }
  StripBOMWrapper.prototype.write = function(buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res)
      return res;
    if (res[0] === BOMChar) {
      res = res.slice(1);
      if (typeof this.options.stripBOM === "function")
        this.options.stripBOM();
    }
    this.pass = true;
    return res;
  };
  StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
  };
});

// ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/internal.js
var require_internal = __commonJS((exports2, module2) => {
  "use strict";
  var Buffer2 = require_safer().Buffer;
  module2.exports = {
    utf8: {type: "_internal", bomAware: true},
    cesu8: {type: "_internal", bomAware: true},
    unicode11utf8: "utf8",
    ucs2: {type: "_internal", bomAware: true},
    utf16le: "ucs2",
    binary: {type: "_internal"},
    base64: {type: "_internal"},
    hex: {type: "_internal"},
    _internal: InternalCodec
  };
  function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;
    if (this.enc === "base64")
      this.encoder = InternalEncoderBase64;
    else if (this.enc === "cesu8") {
      this.enc = "utf8";
      this.encoder = InternalEncoderCesu8;
      if (Buffer2.from("eda0bdedb2a9", "hex").toString() !== "\u{1F4A9}") {
        this.decoder = InternalDecoderCesu8;
        this.defaultCharUnicode = iconv.defaultCharUnicode;
      }
    }
  }
  InternalCodec.prototype.encoder = InternalEncoder;
  InternalCodec.prototype.decoder = InternalDecoder;
  var StringDecoder = require("string_decoder").StringDecoder;
  if (!StringDecoder.prototype.end)
    StringDecoder.prototype.end = function() {
    };
  function InternalDecoder(options, codec) {
    StringDecoder.call(this, codec.enc);
  }
  InternalDecoder.prototype = StringDecoder.prototype;
  function InternalEncoder(options, codec) {
    this.enc = codec.enc;
  }
  InternalEncoder.prototype.write = function(str) {
    return Buffer2.from(str, this.enc);
  };
  InternalEncoder.prototype.end = function() {
  };
  function InternalEncoderBase64(options, codec) {
    this.prevStr = "";
  }
  InternalEncoderBase64.prototype.write = function(str) {
    str = this.prevStr + str;
    var completeQuads = str.length - str.length % 4;
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);
    return Buffer2.from(str, "base64");
  };
  InternalEncoderBase64.prototype.end = function() {
    return Buffer2.from(this.prevStr, "base64");
  };
  function InternalEncoderCesu8(options, codec) {
  }
  InternalEncoderCesu8.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length * 3), bufIdx = 0;
    for (var i = 0; i < str.length; i++) {
      var charCode = str.charCodeAt(i);
      if (charCode < 128)
        buf[bufIdx++] = charCode;
      else if (charCode < 2048) {
        buf[bufIdx++] = 192 + (charCode >>> 6);
        buf[bufIdx++] = 128 + (charCode & 63);
      } else {
        buf[bufIdx++] = 224 + (charCode >>> 12);
        buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
        buf[bufIdx++] = 128 + (charCode & 63);
      }
    }
    return buf.slice(0, bufIdx);
  };
  InternalEncoderCesu8.prototype.end = function() {
  };
  function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
  }
  InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "";
    for (var i = 0; i < buf.length; i++) {
      var curByte = buf[i];
      if ((curByte & 192) !== 128) {
        if (contBytes > 0) {
          res += this.defaultCharUnicode;
          contBytes = 0;
        }
        if (curByte < 128) {
          res += String.fromCharCode(curByte);
        } else if (curByte < 224) {
          acc = curByte & 31;
          contBytes = 1;
          accBytes = 1;
        } else if (curByte < 240) {
          acc = curByte & 15;
          contBytes = 2;
          accBytes = 1;
        } else {
          res += this.defaultCharUnicode;
        }
      } else {
        if (contBytes > 0) {
          acc = acc << 6 | curByte & 63;
          contBytes--;
          accBytes++;
          if (contBytes === 0) {
            if (accBytes === 2 && acc < 128 && acc > 0)
              res += this.defaultCharUnicode;
            else if (accBytes === 3 && acc < 2048)
              res += this.defaultCharUnicode;
            else
              res += String.fromCharCode(acc);
          }
        } else {
          res += this.defaultCharUnicode;
        }
      }
    }
    this.acc = acc;
    this.contBytes = contBytes;
    this.accBytes = accBytes;
    return res;
  };
  InternalDecoderCesu8.prototype.end = function() {
    var res = 0;
    if (this.contBytes > 0)
      res += this.defaultCharUnicode;
    return res;
  };
});

// ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/utf16.js
var require_utf16 = __commonJS((exports2) => {
  "use strict";
  var Buffer2 = require_safer().Buffer;
  exports2.utf16be = Utf16BECodec;
  function Utf16BECodec() {
  }
  Utf16BECodec.prototype.encoder = Utf16BEEncoder;
  Utf16BECodec.prototype.decoder = Utf16BEDecoder;
  Utf16BECodec.prototype.bomAware = true;
  function Utf16BEEncoder() {
  }
  Utf16BEEncoder.prototype.write = function(str) {
    var buf = Buffer2.from(str, "ucs2");
    for (var i = 0; i < buf.length; i += 2) {
      var tmp = buf[i];
      buf[i] = buf[i + 1];
      buf[i + 1] = tmp;
    }
    return buf;
  };
  Utf16BEEncoder.prototype.end = function() {
  };
  function Utf16BEDecoder() {
    this.overflowByte = -1;
  }
  Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0)
      return "";
    var buf2 = Buffer2.alloc(buf.length + 1), i = 0, j = 0;
    if (this.overflowByte !== -1) {
      buf2[0] = buf[0];
      buf2[1] = this.overflowByte;
      i = 1;
      j = 2;
    }
    for (; i < buf.length - 1; i += 2, j += 2) {
      buf2[j] = buf[i + 1];
      buf2[j + 1] = buf[i];
    }
    this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
    return buf2.slice(0, j).toString("ucs2");
  };
  Utf16BEDecoder.prototype.end = function() {
  };
  exports2.utf16 = Utf16Codec;
  function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf16Codec.prototype.encoder = Utf16Encoder;
  Utf16Codec.prototype.decoder = Utf16Decoder;
  function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === void 0)
      options.addBOM = true;
    this.encoder = codec.iconv.getEncoder("utf-16le", options);
  }
  Utf16Encoder.prototype.write = function(str) {
    return this.encoder.write(str);
  };
  Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBytes = [];
    this.initialBytesLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBytes.push(buf);
      this.initialBytesLen += buf.length;
      if (this.initialBytesLen < 16)
        return "";
      var buf = Buffer2.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      this.initialBytes.length = this.initialBytesLen = 0;
    }
    return this.decoder.write(buf);
  };
  Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
      var buf = Buffer2.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var res = this.decoder.write(buf), trail = this.decoder.end();
      return trail ? res + trail : res;
    }
    return this.decoder.end();
  };
  function detectEncoding(buf, defaultEncoding) {
    var enc = defaultEncoding || "utf-16le";
    if (buf.length >= 2) {
      if (buf[0] == 254 && buf[1] == 255)
        enc = "utf-16be";
      else if (buf[0] == 255 && buf[1] == 254)
        enc = "utf-16le";
      else {
        var asciiCharsLE = 0, asciiCharsBE = 0, _len = Math.min(buf.length - buf.length % 2, 64);
        for (var i = 0; i < _len; i += 2) {
          if (buf[i] === 0 && buf[i + 1] !== 0)
            asciiCharsBE++;
          if (buf[i] !== 0 && buf[i + 1] === 0)
            asciiCharsLE++;
        }
        if (asciiCharsBE > asciiCharsLE)
          enc = "utf-16be";
        else if (asciiCharsBE < asciiCharsLE)
          enc = "utf-16le";
      }
    }
    return enc;
  }
});

// ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/utf7.js
var require_utf7 = __commonJS((exports2) => {
  "use strict";
  var Buffer2 = require_safer().Buffer;
  exports2.utf7 = Utf7Codec;
  exports2.unicode11utf7 = "utf7";
  function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7Codec.prototype.encoder = Utf7Encoder;
  Utf7Codec.prototype.decoder = Utf7Decoder;
  Utf7Codec.prototype.bomAware = true;
  var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
  }
  Utf7Encoder.prototype.write = function(str) {
    return Buffer2.from(str.replace(nonDirectChars, function(chunk) {
      return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
    }.bind(this)));
  };
  Utf7Encoder.prototype.end = function() {
  };
  function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64Regex = /[A-Za-z0-9\/+]/;
  var base64Chars = [];
  for (var i = 0; i < 256; i++)
    base64Chars[i] = base64Regex.test(String.fromCharCode(i));
  var plusChar = "+".charCodeAt(0);
  var minusChar = "-".charCodeAt(0);
  var andChar = "&".charCodeAt(0);
  Utf7Decoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0; i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == plusChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64Chars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "+";
          } else {
            var b64str = base64Accum + buf.slice(lastI, i2).toString();
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + buf.slice(lastI).toString();
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7Decoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
  exports2.utf7imap = Utf7IMAPCodec;
  function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
  Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
  Utf7IMAPCodec.prototype.bomAware = true;
  function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer2.alloc(6);
    this.base64AccumIdx = 0;
  }
  Utf7IMAPEncoder.prototype.write = function(str) {
    var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer2.alloc(str.length * 5 + 10), bufIdx = 0;
    for (var i2 = 0; i2 < str.length; i2++) {
      var uChar = str.charCodeAt(i2);
      if (32 <= uChar && uChar <= 126) {
        if (inBase64) {
          if (base64AccumIdx > 0) {
            bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
            base64AccumIdx = 0;
          }
          buf[bufIdx++] = minusChar;
          inBase64 = false;
        }
        if (!inBase64) {
          buf[bufIdx++] = uChar;
          if (uChar === andChar)
            buf[bufIdx++] = minusChar;
        }
      } else {
        if (!inBase64) {
          buf[bufIdx++] = andChar;
          inBase64 = true;
        }
        if (inBase64) {
          base64Accum[base64AccumIdx++] = uChar >> 8;
          base64Accum[base64AccumIdx++] = uChar & 255;
          if (base64AccumIdx == base64Accum.length) {
            bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
            base64AccumIdx = 0;
          }
        }
      }
    }
    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;
    return buf.slice(0, bufIdx);
  };
  Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer2.alloc(10), bufIdx = 0;
    if (this.inBase64) {
      if (this.base64AccumIdx > 0) {
        bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
        this.base64AccumIdx = 0;
      }
      buf[bufIdx++] = minusChar;
      this.inBase64 = false;
    }
    return buf.slice(0, bufIdx);
  };
  function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64IMAPChars = base64Chars.slice();
  base64IMAPChars[",".charCodeAt(0)] = true;
  Utf7IMAPDecoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0; i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == andChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64IMAPChars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "&";
          } else {
            var b64str = base64Accum + buf.slice(lastI, i2).toString().replace(/,/g, "/");
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, "/");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
});

// ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/sbcs-codec.js
var require_sbcs_codec = __commonJS((exports2) => {
  "use strict";
  var Buffer2 = require_safer().Buffer;
  exports2._sbcs = SBCSCodec;
  function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions)
      throw new Error("SBCS codec is called without the data.");
    if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)
      throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    if (codecOptions.chars.length === 128) {
      var asciiString = "";
      for (var i = 0; i < 128; i++)
        asciiString += String.fromCharCode(i);
      codecOptions.chars = asciiString + codecOptions.chars;
    }
    this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
    var encodeBuf = Buffer2.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
    for (var i = 0; i < codecOptions.chars.length; i++)
      encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
    this.encodeBuf = encodeBuf;
  }
  SBCSCodec.prototype.encoder = SBCSEncoder;
  SBCSCodec.prototype.decoder = SBCSDecoder;
  function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
  }
  SBCSEncoder.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length);
    for (var i = 0; i < str.length; i++)
      buf[i] = this.encodeBuf[str.charCodeAt(i)];
    return buf;
  };
  SBCSEncoder.prototype.end = function() {
  };
  function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
  }
  SBCSDecoder.prototype.write = function(buf) {
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer2.alloc(buf.length * 2);
    var idx1 = 0, idx2 = 0;
    for (var i = 0; i < buf.length; i++) {
      idx1 = buf[i] * 2;
      idx2 = i * 2;
      newBuf[idx2] = decodeBuf[idx1];
      newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
    }
    return newBuf.toString("ucs2");
  };
  SBCSDecoder.prototype.end = function() {
  };
});

// ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/sbcs-data.js
var require_sbcs_data = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    "10029": "maccenteuro",
    maccenteuro: {
      type: "_sbcs",
      chars: "\xC4\u0100\u0101\xC9\u0104\xD6\xDC\xE1\u0105\u010C\xE4\u010D\u0106\u0107\xE9\u0179\u017A\u010E\xED\u010F\u0112\u0113\u0116\xF3\u0117\xF4\xF6\xF5\xFA\u011A\u011B\xFC\u2020\xB0\u0118\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\u0119\xA8\u2260\u0123\u012E\u012F\u012A\u2264\u2265\u012B\u0136\u2202\u2211\u0142\u013B\u013C\u013D\u013E\u0139\u013A\u0145\u0146\u0143\xAC\u221A\u0144\u0147\u2206\xAB\xBB\u2026\xA0\u0148\u0150\xD5\u0151\u014C\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\u014D\u0154\u0155\u0158\u2039\u203A\u0159\u0156\u0157\u0160\u201A\u201E\u0161\u015A\u015B\xC1\u0164\u0165\xCD\u017D\u017E\u016A\xD3\xD4\u016B\u016E\xDA\u016F\u0170\u0171\u0172\u0173\xDD\xFD\u0137\u017B\u0141\u017C\u0122\u02C7"
    },
    "808": "cp808",
    ibm808: "cp808",
    cp808: {
      type: "_sbcs",
      chars: "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u0401\u0451\u0404\u0454\u0407\u0457\u040E\u045E\xB0\u2219\xB7\u221A\u2116\u20AC\u25A0\xA0"
    },
    mik: {
      type: "_sbcs",
      chars: "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u2514\u2534\u252C\u251C\u2500\u253C\u2563\u2551\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2510\u2591\u2592\u2593\u2502\u2524\u2116\xA7\u2557\u255D\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
    },
    ascii8bit: "ascii",
    usascii: "ascii",
    ansix34: "ascii",
    ansix341968: "ascii",
    ansix341986: "ascii",
    csascii: "ascii",
    cp367: "ascii",
    ibm367: "ascii",
    isoir6: "ascii",
    iso646us: "ascii",
    iso646irv: "ascii",
    us: "ascii",
    latin1: "iso88591",
    latin2: "iso88592",
    latin3: "iso88593",
    latin4: "iso88594",
    latin5: "iso88599",
    latin6: "iso885910",
    latin7: "iso885913",
    latin8: "iso885914",
    latin9: "iso885915",
    latin10: "iso885916",
    csisolatin1: "iso88591",
    csisolatin2: "iso88592",
    csisolatin3: "iso88593",
    csisolatin4: "iso88594",
    csisolatincyrillic: "iso88595",
    csisolatinarabic: "iso88596",
    csisolatingreek: "iso88597",
    csisolatinhebrew: "iso88598",
    csisolatin5: "iso88599",
    csisolatin6: "iso885910",
    l1: "iso88591",
    l2: "iso88592",
    l3: "iso88593",
    l4: "iso88594",
    l5: "iso88599",
    l6: "iso885910",
    l7: "iso885913",
    l8: "iso885914",
    l9: "iso885915",
    l10: "iso885916",
    isoir14: "iso646jp",
    isoir57: "iso646cn",
    isoir100: "iso88591",
    isoir101: "iso88592",
    isoir109: "iso88593",
    isoir110: "iso88594",
    isoir144: "iso88595",
    isoir127: "iso88596",
    isoir126: "iso88597",
    isoir138: "iso88598",
    isoir148: "iso88599",
    isoir157: "iso885910",
    isoir166: "tis620",
    isoir179: "iso885913",
    isoir199: "iso885914",
    isoir203: "iso885915",
    isoir226: "iso885916",
    cp819: "iso88591",
    ibm819: "iso88591",
    cyrillic: "iso88595",
    arabic: "iso88596",
    arabic8: "iso88596",
    ecma114: "iso88596",
    asmo708: "iso88596",
    greek: "iso88597",
    greek8: "iso88597",
    ecma118: "iso88597",
    elot928: "iso88597",
    hebrew: "iso88598",
    hebrew8: "iso88598",
    turkish: "iso88599",
    turkish8: "iso88599",
    thai: "iso885911",
    thai8: "iso885911",
    celtic: "iso885914",
    celtic8: "iso885914",
    isoceltic: "iso885914",
    tis6200: "tis620",
    tis62025291: "tis620",
    tis62025330: "tis620",
    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",
    cspc8codepage437: "cp437",
    cspc775baltic: "cp775",
    cspc850multilingual: "cp850",
    cspcp852: "cp852",
    cspc862latinhebrew: "cp862",
    cpgr: "cp869",
    msee: "cp1250",
    mscyrl: "cp1251",
    msansi: "cp1252",
    msgreek: "cp1253",
    msturk: "cp1254",
    mshebr: "cp1255",
    msarab: "cp1256",
    winbaltrim: "cp1257",
    cp20866: "koi8r",
    "20866": "koi8r",
    ibm878: "koi8r",
    cskoi8r: "koi8r",
    cp21866: "koi8u",
    "21866": "koi8u",
    ibm1168: "koi8u",
    strk10482002: "rk1048",
    tcvn5712: "tcvn",
    tcvn57121: "tcvn",
    gb198880: "iso646cn",
    cn: "iso646cn",
    csiso14jisc6220ro: "iso646jp",
    jisc62201969ro: "iso646jp",
    jp: "iso646jp",
    cshproman8: "hproman8",
    r8: "hproman8",
    roman8: "hproman8",
    xroman8: "hproman8",
    ibm1051: "hproman8",
    mac: "macintosh",
    csmacintosh: "macintosh"
  };
});

// ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/sbcs-data-generated.js
var require_sbcs_data_generated = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    "437": "cp437",
    "737": "cp737",
    "775": "cp775",
    "850": "cp850",
    "852": "cp852",
    "855": "cp855",
    "856": "cp856",
    "857": "cp857",
    "858": "cp858",
    "860": "cp860",
    "861": "cp861",
    "862": "cp862",
    "863": "cp863",
    "864": "cp864",
    "865": "cp865",
    "866": "cp866",
    "869": "cp869",
    "874": "windows874",
    "922": "cp922",
    "1046": "cp1046",
    "1124": "cp1124",
    "1125": "cp1125",
    "1129": "cp1129",
    "1133": "cp1133",
    "1161": "cp1161",
    "1162": "cp1162",
    "1163": "cp1163",
    "1250": "windows1250",
    "1251": "windows1251",
    "1252": "windows1252",
    "1253": "windows1253",
    "1254": "windows1254",
    "1255": "windows1255",
    "1256": "windows1256",
    "1257": "windows1257",
    "1258": "windows1258",
    "28591": "iso88591",
    "28592": "iso88592",
    "28593": "iso88593",
    "28594": "iso88594",
    "28595": "iso88595",
    "28596": "iso88596",
    "28597": "iso88597",
    "28598": "iso88598",
    "28599": "iso88599",
    "28600": "iso885910",
    "28601": "iso885911",
    "28603": "iso885913",
    "28604": "iso885914",
    "28605": "iso885915",
    "28606": "iso885916",
    windows874: {
      type: "_sbcs",
      chars: "\u20AC\uFFFD\uFFFD\uFFFD\uFFFD\u2026\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
    },
    win874: "windows874",
    cp874: "windows874",
    windows1250: {
      type: "_sbcs",
      chars: "\u20AC\uFFFD\u201A\uFFFD\u201E\u2026\u2020\u2021\uFFFD\u2030\u0160\u2039\u015A\u0164\u017D\u0179\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\u0161\u203A\u015B\u0165\u017E\u017A\xA0\u02C7\u02D8\u0141\xA4\u0104\xA6\xA7\xA8\xA9\u015E\xAB\xAC\xAD\xAE\u017B\xB0\xB1\u02DB\u0142\xB4\xB5\xB6\xB7\xB8\u0105\u015F\xBB\u013D\u02DD\u013E\u017C\u0154\xC1\xC2\u0102\xC4\u0139\u0106\xC7\u010C\xC9\u0118\xCB\u011A\xCD\xCE\u010E\u0110\u0143\u0147\xD3\xD4\u0150\xD6\xD7\u0158\u016E\xDA\u0170\xDC\xDD\u0162\xDF\u0155\xE1\xE2\u0103\xE4\u013A\u0107\xE7\u010D\xE9\u0119\xEB\u011B\xED\xEE\u010F\u0111\u0144\u0148\xF3\xF4\u0151\xF6\xF7\u0159\u016F\xFA\u0171\xFC\xFD\u0163\u02D9"
    },
    win1250: "windows1250",
    cp1250: "windows1250",
    windows1251: {
      type: "_sbcs",
      chars: "\u0402\u0403\u201A\u0453\u201E\u2026\u2020\u2021\u20AC\u2030\u0409\u2039\u040A\u040C\u040B\u040F\u0452\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\u0459\u203A\u045A\u045C\u045B\u045F\xA0\u040E\u045E\u0408\xA4\u0490\xA6\xA7\u0401\xA9\u0404\xAB\xAC\xAD\xAE\u0407\xB0\xB1\u0406\u0456\u0491\xB5\xB6\xB7\u0451\u2116\u0454\xBB\u0458\u0405\u0455\u0457\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F"
    },
    win1251: "windows1251",
    cp1251: "windows1251",
    windows1252: {
      type: "_sbcs",
      chars: "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\uFFFD\u017D\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\uFFFD\u017E\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
    },
    win1252: "windows1252",
    cp1252: "windows1252",
    windows1253: {
      type: "_sbcs",
      chars: "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\uFFFD\u2030\uFFFD\u2039\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\uFFFD\u203A\uFFFD\uFFFD\uFFFD\uFFFD\xA0\u0385\u0386\xA3\xA4\xA5\xA6\xA7\xA8\xA9\uFFFD\xAB\xAC\xAD\xAE\u2015\xB0\xB1\xB2\xB3\u0384\xB5\xB6\xB7\u0388\u0389\u038A\xBB\u038C\xBD\u038E\u038F\u0390\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039A\u039B\u039C\u039D\u039E\u039F\u03A0\u03A1\uFFFD\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03AA\u03AB\u03AC\u03AD\u03AE\u03AF\u03B0\u03B1\u03B2\u03B3\u03B4\u03B5\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C2\u03C3\u03C4\u03C5\u03C6\u03C7\u03C8\u03C9\u03CA\u03CB\u03CC\u03CD\u03CE\uFFFD"
    },
    win1253: "windows1253",
    cp1253: "windows1253",
    windows1254: {
      type: "_sbcs",
      chars: "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\uFFFD\uFFFD\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u011E\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u0130\u015E\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u011F\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u0131\u015F\xFF"
    },
    win1254: "windows1254",
    cp1254: "windows1254",
    windows1255: {
      type: "_sbcs",
      chars: "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\uFFFD\u2039\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\uFFFD\u203A\uFFFD\uFFFD\uFFFD\uFFFD\xA0\xA1\xA2\xA3\u20AA\xA5\xA6\xA7\xA8\xA9\xD7\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xF7\xBB\xBC\xBD\xBE\xBF\u05B0\u05B1\u05B2\u05B3\u05B4\u05B5\u05B6\u05B7\u05B8\u05B9\u05BA\u05BB\u05BC\u05BD\u05BE\u05BF\u05C0\u05C1\u05C2\u05C3\u05F0\u05F1\u05F2\u05F3\u05F4\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\uFFFD\uFFFD\u200E\u200F\uFFFD"
    },
    win1255: "windows1255",
    cp1255: "windows1255",
    windows1256: {
      type: "_sbcs",
      chars: "\u20AC\u067E\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0679\u2039\u0152\u0686\u0698\u0688\u06AF\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u06A9\u2122\u0691\u203A\u0153\u200C\u200D\u06BA\xA0\u060C\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\u06BE\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\u061B\xBB\xBC\xBD\xBE\u061F\u06C1\u0621\u0622\u0623\u0624\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\u0636\xD7\u0637\u0638\u0639\u063A\u0640\u0641\u0642\u0643\xE0\u0644\xE2\u0645\u0646\u0647\u0648\xE7\xE8\xE9\xEA\xEB\u0649\u064A\xEE\xEF\u064B\u064C\u064D\u064E\xF4\u064F\u0650\xF7\u0651\xF9\u0652\xFB\xFC\u200E\u200F\u06D2"
    },
    win1256: "windows1256",
    cp1256: "windows1256",
    windows1257: {
      type: "_sbcs",
      chars: "\u20AC\uFFFD\u201A\uFFFD\u201E\u2026\u2020\u2021\uFFFD\u2030\uFFFD\u2039\uFFFD\xA8\u02C7\xB8\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\uFFFD\u203A\uFFFD\xAF\u02DB\uFFFD\xA0\uFFFD\xA2\xA3\xA4\uFFFD\xA6\xA7\xD8\xA9\u0156\xAB\xAC\xAD\xAE\xC6\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xF8\xB9\u0157\xBB\xBC\xBD\xBE\xE6\u0104\u012E\u0100\u0106\xC4\xC5\u0118\u0112\u010C\xC9\u0179\u0116\u0122\u0136\u012A\u013B\u0160\u0143\u0145\xD3\u014C\xD5\xD6\xD7\u0172\u0141\u015A\u016A\xDC\u017B\u017D\xDF\u0105\u012F\u0101\u0107\xE4\xE5\u0119\u0113\u010D\xE9\u017A\u0117\u0123\u0137\u012B\u013C\u0161\u0144\u0146\xF3\u014D\xF5\xF6\xF7\u0173\u0142\u015B\u016B\xFC\u017C\u017E\u02D9"
    },
    win1257: "windows1257",
    cp1257: "windows1257",
    windows1258: {
      type: "_sbcs",
      chars: "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\uFFFD\u2039\u0152\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\uFFFD\u203A\u0153\uFFFD\uFFFD\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\u0102\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\u0300\xCD\xCE\xCF\u0110\xD1\u0309\xD3\xD4\u01A0\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u01AF\u0303\xDF\xE0\xE1\xE2\u0103\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\u0301\xED\xEE\xEF\u0111\xF1\u0323\xF3\xF4\u01A1\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u01B0\u20AB\xFF"
    },
    win1258: "windows1258",
    cp1258: "windows1258",
    iso88591: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
    },
    cp28591: "iso88591",
    iso88592: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u02D8\u0141\xA4\u013D\u015A\xA7\xA8\u0160\u015E\u0164\u0179\xAD\u017D\u017B\xB0\u0105\u02DB\u0142\xB4\u013E\u015B\u02C7\xB8\u0161\u015F\u0165\u017A\u02DD\u017E\u017C\u0154\xC1\xC2\u0102\xC4\u0139\u0106\xC7\u010C\xC9\u0118\xCB\u011A\xCD\xCE\u010E\u0110\u0143\u0147\xD3\xD4\u0150\xD6\xD7\u0158\u016E\xDA\u0170\xDC\xDD\u0162\xDF\u0155\xE1\xE2\u0103\xE4\u013A\u0107\xE7\u010D\xE9\u0119\xEB\u011B\xED\xEE\u010F\u0111\u0144\u0148\xF3\xF4\u0151\xF6\xF7\u0159\u016F\xFA\u0171\xFC\xFD\u0163\u02D9"
    },
    cp28592: "iso88592",
    iso88593: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0126\u02D8\xA3\xA4\uFFFD\u0124\xA7\xA8\u0130\u015E\u011E\u0134\xAD\uFFFD\u017B\xB0\u0127\xB2\xB3\xB4\xB5\u0125\xB7\xB8\u0131\u015F\u011F\u0135\xBD\uFFFD\u017C\xC0\xC1\xC2\uFFFD\xC4\u010A\u0108\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\uFFFD\xD1\xD2\xD3\xD4\u0120\xD6\xD7\u011C\xD9\xDA\xDB\xDC\u016C\u015C\xDF\xE0\xE1\xE2\uFFFD\xE4\u010B\u0109\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\uFFFD\xF1\xF2\xF3\xF4\u0121\xF6\xF7\u011D\xF9\xFA\xFB\xFC\u016D\u015D\u02D9"
    },
    cp28593: "iso88593",
    iso88594: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u0138\u0156\xA4\u0128\u013B\xA7\xA8\u0160\u0112\u0122\u0166\xAD\u017D\xAF\xB0\u0105\u02DB\u0157\xB4\u0129\u013C\u02C7\xB8\u0161\u0113\u0123\u0167\u014A\u017E\u014B\u0100\xC1\xC2\xC3\xC4\xC5\xC6\u012E\u010C\xC9\u0118\xCB\u0116\xCD\xCE\u012A\u0110\u0145\u014C\u0136\xD4\xD5\xD6\xD7\xD8\u0172\xDA\xDB\xDC\u0168\u016A\xDF\u0101\xE1\xE2\xE3\xE4\xE5\xE6\u012F\u010D\xE9\u0119\xEB\u0117\xED\xEE\u012B\u0111\u0146\u014D\u0137\xF4\xF5\xF6\xF7\xF8\u0173\xFA\xFB\xFC\u0169\u016B\u02D9"
    },
    cp28594: "iso88594",
    iso88595: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0401\u0402\u0403\u0404\u0405\u0406\u0407\u0408\u0409\u040A\u040B\u040C\xAD\u040E\u040F\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u2116\u0451\u0452\u0453\u0454\u0455\u0456\u0457\u0458\u0459\u045A\u045B\u045C\xA7\u045E\u045F"
    },
    cp28595: "iso88595",
    iso88596: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\uFFFD\uFFFD\uFFFD\xA4\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u060C\xAD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u061B\uFFFD\uFFFD\uFFFD\u061F\uFFFD\u0621\u0622\u0623\u0624\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\u0636\u0637\u0638\u0639\u063A\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0640\u0641\u0642\u0643\u0644\u0645\u0646\u0647\u0648\u0649\u064A\u064B\u064C\u064D\u064E\u064F\u0650\u0651\u0652\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD"
    },
    cp28596: "iso88596",
    iso88597: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u2018\u2019\xA3\u20AC\u20AF\xA6\xA7\xA8\xA9\u037A\xAB\xAC\xAD\uFFFD\u2015\xB0\xB1\xB2\xB3\u0384\u0385\u0386\xB7\u0388\u0389\u038A\xBB\u038C\xBD\u038E\u038F\u0390\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039A\u039B\u039C\u039D\u039E\u039F\u03A0\u03A1\uFFFD\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03AA\u03AB\u03AC\u03AD\u03AE\u03AF\u03B0\u03B1\u03B2\u03B3\u03B4\u03B5\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C2\u03C3\u03C4\u03C5\u03C6\u03C7\u03C8\u03C9\u03CA\u03CB\u03CC\u03CD\u03CE\uFFFD"
    },
    cp28597: "iso88597",
    iso88598: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\uFFFD\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xD7\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xF7\xBB\xBC\xBD\xBE\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2017\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\uFFFD\uFFFD\u200E\u200F\uFFFD"
    },
    cp28598: "iso88598",
    iso88599: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u011E\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u0130\u015E\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u011F\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u0131\u015F\xFF"
    },
    cp28599: "iso88599",
    iso885910: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u0112\u0122\u012A\u0128\u0136\xA7\u013B\u0110\u0160\u0166\u017D\xAD\u016A\u014A\xB0\u0105\u0113\u0123\u012B\u0129\u0137\xB7\u013C\u0111\u0161\u0167\u017E\u2015\u016B\u014B\u0100\xC1\xC2\xC3\xC4\xC5\xC6\u012E\u010C\xC9\u0118\xCB\u0116\xCD\xCE\xCF\xD0\u0145\u014C\xD3\xD4\xD5\xD6\u0168\xD8\u0172\xDA\xDB\xDC\xDD\xDE\xDF\u0101\xE1\xE2\xE3\xE4\xE5\xE6\u012F\u010D\xE9\u0119\xEB\u0117\xED\xEE\xEF\xF0\u0146\u014D\xF3\xF4\xF5\xF6\u0169\xF8\u0173\xFA\xFB\xFC\xFD\xFE\u0138"
    },
    cp28600: "iso885910",
    iso885911: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
    },
    cp28601: "iso885911",
    iso885913: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u201D\xA2\xA3\xA4\u201E\xA6\xA7\xD8\xA9\u0156\xAB\xAC\xAD\xAE\xC6\xB0\xB1\xB2\xB3\u201C\xB5\xB6\xB7\xF8\xB9\u0157\xBB\xBC\xBD\xBE\xE6\u0104\u012E\u0100\u0106\xC4\xC5\u0118\u0112\u010C\xC9\u0179\u0116\u0122\u0136\u012A\u013B\u0160\u0143\u0145\xD3\u014C\xD5\xD6\xD7\u0172\u0141\u015A\u016A\xDC\u017B\u017D\xDF\u0105\u012F\u0101\u0107\xE4\xE5\u0119\u0113\u010D\xE9\u017A\u0117\u0123\u0137\u012B\u013C\u0161\u0144\u0146\xF3\u014D\xF5\xF6\xF7\u0173\u0142\u015B\u016B\xFC\u017C\u017E\u2019"
    },
    cp28603: "iso885913",
    iso885914: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u1E02\u1E03\xA3\u010A\u010B\u1E0A\xA7\u1E80\xA9\u1E82\u1E0B\u1EF2\xAD\xAE\u0178\u1E1E\u1E1F\u0120\u0121\u1E40\u1E41\xB6\u1E56\u1E81\u1E57\u1E83\u1E60\u1EF3\u1E84\u1E85\u1E61\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u0174\xD1\xD2\xD3\xD4\xD5\xD6\u1E6A\xD8\xD9\xDA\xDB\xDC\xDD\u0176\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u0175\xF1\xF2\xF3\xF4\xF5\xF6\u1E6B\xF8\xF9\xFA\xFB\xFC\xFD\u0177\xFF"
    },
    cp28604: "iso885914",
    iso885915: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\u20AC\xA5\u0160\xA7\u0161\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\u017D\xB5\xB6\xB7\u017E\xB9\xBA\xBB\u0152\u0153\u0178\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
    },
    cp28605: "iso885915",
    iso885916: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u0105\u0141\u20AC\u201E\u0160\xA7\u0161\xA9\u0218\xAB\u0179\xAD\u017A\u017B\xB0\xB1\u010C\u0142\u017D\u201D\xB6\xB7\u017E\u010D\u0219\xBB\u0152\u0153\u0178\u017C\xC0\xC1\xC2\u0102\xC4\u0106\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u0110\u0143\xD2\xD3\xD4\u0150\xD6\u015A\u0170\xD9\xDA\xDB\xDC\u0118\u021A\xDF\xE0\xE1\xE2\u0103\xE4\u0107\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u0111\u0144\xF2\xF3\xF4\u0151\xF6\u015B\u0171\xF9\xFA\xFB\xFC\u0119\u021B\xFF"
    },
    cp28606: "iso885916",
    cp437: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
    },
    ibm437: "cp437",
    csibm437: "cp437",
    cp737: {
      type: "_sbcs",
      chars: "\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039A\u039B\u039C\u039D\u039E\u039F\u03A0\u03A1\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03B1\u03B2\u03B3\u03B4\u03B5\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C3\u03C2\u03C4\u03C5\u03C6\u03C7\u03C8\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03C9\u03AC\u03AD\u03AE\u03CA\u03AF\u03CC\u03CD\u03CB\u03CE\u0386\u0388\u0389\u038A\u038C\u038E\u038F\xB1\u2265\u2264\u03AA\u03AB\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
    },
    ibm737: "cp737",
    csibm737: "cp737",
    cp775: {
      type: "_sbcs",
      chars: "\u0106\xFC\xE9\u0101\xE4\u0123\xE5\u0107\u0142\u0113\u0156\u0157\u012B\u0179\xC4\xC5\xC9\xE6\xC6\u014D\xF6\u0122\xA2\u015A\u015B\xD6\xDC\xF8\xA3\xD8\xD7\xA4\u0100\u012A\xF3\u017B\u017C\u017A\u201D\xA6\xA9\xAE\xAC\xBD\xBC\u0141\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u0104\u010C\u0118\u0116\u2563\u2551\u2557\u255D\u012E\u0160\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u0172\u016A\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u017D\u0105\u010D\u0119\u0117\u012F\u0161\u0173\u016B\u017E\u2518\u250C\u2588\u2584\u258C\u2590\u2580\xD3\xDF\u014C\u0143\xF5\xD5\xB5\u0144\u0136\u0137\u013B\u013C\u0146\u0112\u0145\u2019\xAD\xB1\u201C\xBE\xB6\xA7\xF7\u201E\xB0\u2219\xB7\xB9\xB3\xB2\u25A0\xA0"
    },
    ibm775: "cp775",
    csibm775: "cp775",
    cp850: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xF8\xA3\xD8\xD7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\xAE\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\xC0\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\xE3\xC3\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\xF0\xD0\xCA\xCB\xC8\u0131\xCD\xCE\xCF\u2518\u250C\u2588\u2584\xA6\xCC\u2580\xD3\xDF\xD4\xD2\xF5\xD5\xB5\xFE\xDE\xDA\xDB\xD9\xFD\xDD\xAF\xB4\xAD\xB1\u2017\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
    },
    ibm850: "cp850",
    csibm850: "cp850",
    cp852: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xE4\u016F\u0107\xE7\u0142\xEB\u0150\u0151\xEE\u0179\xC4\u0106\xC9\u0139\u013A\xF4\xF6\u013D\u013E\u015A\u015B\xD6\xDC\u0164\u0165\u0141\xD7\u010D\xE1\xED\xF3\xFA\u0104\u0105\u017D\u017E\u0118\u0119\xAC\u017A\u010C\u015F\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\u011A\u015E\u2563\u2551\u2557\u255D\u017B\u017C\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u0102\u0103\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\u0111\u0110\u010E\xCB\u010F\u0147\xCD\xCE\u011B\u2518\u250C\u2588\u2584\u0162\u016E\u2580\xD3\xDF\xD4\u0143\u0144\u0148\u0160\u0161\u0154\xDA\u0155\u0170\xFD\xDD\u0163\xB4\xAD\u02DD\u02DB\u02C7\u02D8\xA7\xF7\xB8\xB0\xA8\u02D9\u0171\u0158\u0159\u25A0\xA0"
    },
    ibm852: "cp852",
    csibm852: "cp852",
    cp855: {
      type: "_sbcs",
      chars: "\u0452\u0402\u0453\u0403\u0451\u0401\u0454\u0404\u0455\u0405\u0456\u0406\u0457\u0407\u0458\u0408\u0459\u0409\u045A\u040A\u045B\u040B\u045C\u040C\u045E\u040E\u045F\u040F\u044E\u042E\u044A\u042A\u0430\u0410\u0431\u0411\u0446\u0426\u0434\u0414\u0435\u0415\u0444\u0424\u0433\u0413\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u0445\u0425\u0438\u0418\u2563\u2551\u2557\u255D\u0439\u0419\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u043A\u041A\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\u043B\u041B\u043C\u041C\u043D\u041D\u043E\u041E\u043F\u2518\u250C\u2588\u2584\u041F\u044F\u2580\u042F\u0440\u0420\u0441\u0421\u0442\u0422\u0443\u0423\u0436\u0416\u0432\u0412\u044C\u042C\u2116\xAD\u044B\u042B\u0437\u0417\u0448\u0428\u044D\u042D\u0449\u0429\u0447\u0427\xA7\u25A0\xA0"
    },
    ibm855: "cp855",
    csibm855: "cp855",
    cp856: {
      type: "_sbcs",
      chars: "\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\uFFFD\xA3\uFFFD\xD7\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xAE\xAC\xBD\xBC\uFFFD\xAB\xBB\u2591\u2592\u2593\u2502\u2524\uFFFD\uFFFD\uFFFD\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\uFFFD\uFFFD\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2518\u250C\u2588\u2584\xA6\uFFFD\u2580\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xB5\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xAF\xB4\xAD\xB1\u2017\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
    },
    ibm856: "cp856",
    csibm856: "cp856",
    cp857: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\u0131\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\u0130\xD6\xDC\xF8\xA3\xD8\u015E\u015F\xE1\xED\xF3\xFA\xF1\xD1\u011E\u011F\xBF\xAE\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\xC0\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\xE3\xC3\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\xBA\xAA\xCA\xCB\xC8\uFFFD\xCD\xCE\xCF\u2518\u250C\u2588\u2584\xA6\xCC\u2580\xD3\xDF\xD4\xD2\xF5\xD5\xB5\uFFFD\xD7\xDA\xDB\xD9\xEC\xFF\xAF\xB4\xAD\xB1\uFFFD\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
    },
    ibm857: "cp857",
    csibm857: "cp857",
    cp858: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xF8\xA3\xD8\xD7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\xAE\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\xC0\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\xE3\xC3\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\xF0\xD0\xCA\xCB\xC8\u20AC\xCD\xCE\xCF\u2518\u250C\u2588\u2584\xA6\xCC\u2580\xD3\xDF\xD4\xD2\xF5\xD5\xB5\xFE\xDE\xDA\xDB\xD9\xFD\xDD\xAF\xB4\xAD\xB1\u2017\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
    },
    ibm858: "cp858",
    csibm858: "cp858",
    cp860: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xE3\xE0\xC1\xE7\xEA\xCA\xE8\xCD\xD4\xEC\xC3\xC2\xC9\xC0\xC8\xF4\xF5\xF2\xDA\xF9\xCC\xD5\xDC\xA2\xA3\xD9\u20A7\xD3\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\xD2\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
    },
    ibm860: "cp860",
    csibm860: "cp860",
    cp861: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xD0\xF0\xDE\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xFE\xFB\xDD\xFD\xD6\xDC\xF8\xA3\xD8\u20A7\u0192\xE1\xED\xF3\xFA\xC1\xCD\xD3\xDA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
    },
    ibm861: "cp861",
    csibm861: "cp861",
    cp862: {
      type: "_sbcs",
      chars: "\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
    },
    ibm862: "cp862",
    csibm862: "cp862",
    cp863: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xC2\xE0\xB6\xE7\xEA\xEB\xE8\xEF\xEE\u2017\xC0\xA7\xC9\xC8\xCA\xF4\xCB\xCF\xFB\xF9\xA4\xD4\xDC\xA2\xA3\xD9\xDB\u0192\xA6\xB4\xF3\xFA\xA8\xB8\xB3\xAF\xCE\u2310\xAC\xBD\xBC\xBE\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
    },
    ibm863: "cp863",
    csibm863: "cp863",
    cp864: {
      type: "_sbcs",
      chars: "\0\x07\b	\n\v\f\r !\"#$\u066A&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7F\xB0\xB7\u2219\u221A\u2592\u2500\u2502\u253C\u2524\u252C\u251C\u2534\u2510\u250C\u2514\u2518\u03B2\u221E\u03C6\xB1\xBD\xBC\u2248\xAB\xBB\uFEF7\uFEF8\uFFFD\uFFFD\uFEFB\uFEFC\uFFFD\xA0\xAD\uFE82\xA3\xA4\uFE84\uFFFD\uFFFD\uFE8E\uFE8F\uFE95\uFE99\u060C\uFE9D\uFEA1\uFEA5\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\uFED1\u061B\uFEB1\uFEB5\uFEB9\u061F\xA2\uFE80\uFE81\uFE83\uFE85\uFECA\uFE8B\uFE8D\uFE91\uFE93\uFE97\uFE9B\uFE9F\uFEA3\uFEA7\uFEA9\uFEAB\uFEAD\uFEAF\uFEB3\uFEB7\uFEBB\uFEBF\uFEC1\uFEC5\uFECB\uFECF\xA6\xAC\xF7\xD7\uFEC9\u0640\uFED3\uFED7\uFEDB\uFEDF\uFEE3\uFEE7\uFEEB\uFEED\uFEEF\uFEF3\uFEBD\uFECC\uFECE\uFECD\uFEE1\uFE7D\u0651\uFEE5\uFEE9\uFEEC\uFEF0\uFEF2\uFED0\uFED5\uFEF5\uFEF6\uFEDD\uFED9\uFEF1\u25A0\uFFFD"
    },
    ibm864: "cp864",
    csibm864: "cp864",
    cp865: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xF8\xA3\xD8\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xA4\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
    },
    ibm865: "cp865",
    csibm865: "cp865",
    cp866: {
      type: "_sbcs",
      chars: "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u0401\u0451\u0404\u0454\u0407\u0457\u040E\u045E\xB0\u2219\xB7\u221A\u2116\xA4\u25A0\xA0"
    },
    ibm866: "cp866",
    csibm866: "cp866",
    cp869: {
      type: "_sbcs",
      chars: "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0386\uFFFD\xB7\xAC\xA6\u2018\u2019\u0388\u2015\u0389\u038A\u03AA\u038C\uFFFD\uFFFD\u038E\u03AB\xA9\u038F\xB2\xB3\u03AC\xA3\u03AD\u03AE\u03AF\u03CA\u0390\u03CC\u03CD\u0391\u0392\u0393\u0394\u0395\u0396\u0397\xBD\u0398\u0399\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u039A\u039B\u039C\u039D\u2563\u2551\u2557\u255D\u039E\u039F\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u03A0\u03A1\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03B1\u03B2\u03B3\u2518\u250C\u2588\u2584\u03B4\u03B5\u2580\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C3\u03C2\u03C4\u0384\xAD\xB1\u03C5\u03C6\u03C7\xA7\u03C8\u0385\xB0\xA8\u03C9\u03CB\u03B0\u03CE\u25A0\xA0"
    },
    ibm869: "cp869",
    csibm869: "cp869",
    cp922: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\u203E\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u0160\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\u017D\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u0161\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\u017E\xFF"
    },
    ibm922: "cp922",
    csibm922: "cp922",
    cp1046: {
      type: "_sbcs",
      chars: "\uFE88\xD7\xF7\uF8F6\uF8F5\uF8F4\uF8F7\uFE71\x88\u25A0\u2502\u2500\u2510\u250C\u2514\u2518\uFE79\uFE7B\uFE7D\uFE7F\uFE77\uFE8A\uFEF0\uFEF3\uFEF2\uFECE\uFECF\uFED0\uFEF6\uFEF8\uFEFA\uFEFC\xA0\uF8FA\uF8F9\uF8F8\xA4\uF8FB\uFE8B\uFE91\uFE97\uFE9B\uFE9F\uFEA3\u060C\xAD\uFEA7\uFEB3\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\uFEB7\u061B\uFEBB\uFEBF\uFECA\u061F\uFECB\u0621\u0622\u0623\u0624\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\u0636\u0637\uFEC7\u0639\u063A\uFECC\uFE82\uFE84\uFE8E\uFED3\u0640\u0641\u0642\u0643\u0644\u0645\u0646\u0647\u0648\u0649\u064A\u064B\u064C\u064D\u064E\u064F\u0650\u0651\u0652\uFED7\uFEDB\uFEDF\uF8FC\uFEF5\uFEF7\uFEF9\uFEFB\uFEE3\uFEE7\uFEEC\uFEE9\uFFFD"
    },
    ibm1046: "cp1046",
    csibm1046: "cp1046",
    cp1124: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0401\u0402\u0490\u0404\u0405\u0406\u0407\u0408\u0409\u040A\u040B\u040C\xAD\u040E\u040F\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u2116\u0451\u0452\u0491\u0454\u0455\u0456\u0457\u0458\u0459\u045A\u045B\u045C\xA7\u045E\u045F"
    },
    ibm1124: "cp1124",
    csibm1124: "cp1124",
    cp1125: {
      type: "_sbcs",
      chars: "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u0401\u0451\u0490\u0491\u0404\u0454\u0406\u0456\u0407\u0457\xB7\u221A\u2116\xA4\u25A0\xA0"
    },
    ibm1125: "cp1125",
    csibm1125: "cp1125",
    cp1129: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\u0153\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\u0178\xB5\xB6\xB7\u0152\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\u0102\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\u0300\xCD\xCE\xCF\u0110\xD1\u0309\xD3\xD4\u01A0\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u01AF\u0303\xDF\xE0\xE1\xE2\u0103\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\u0301\xED\xEE\xEF\u0111\xF1\u0323\xF3\xF4\u01A1\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u01B0\u20AB\xFF"
    },
    ibm1129: "cp1129",
    csibm1129: "cp1129",
    cp1133: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0E81\u0E82\u0E84\u0E87\u0E88\u0EAA\u0E8A\u0E8D\u0E94\u0E95\u0E96\u0E97\u0E99\u0E9A\u0E9B\u0E9C\u0E9D\u0E9E\u0E9F\u0EA1\u0EA2\u0EA3\u0EA5\u0EA7\u0EAB\u0EAD\u0EAE\uFFFD\uFFFD\uFFFD\u0EAF\u0EB0\u0EB2\u0EB3\u0EB4\u0EB5\u0EB6\u0EB7\u0EB8\u0EB9\u0EBC\u0EB1\u0EBB\u0EBD\uFFFD\uFFFD\uFFFD\u0EC0\u0EC1\u0EC2\u0EC3\u0EC4\u0EC8\u0EC9\u0ECA\u0ECB\u0ECC\u0ECD\u0EC6\uFFFD\u0EDC\u0EDD\u20AD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0ED0\u0ED1\u0ED2\u0ED3\u0ED4\u0ED5\u0ED6\u0ED7\u0ED8\u0ED9\uFFFD\uFFFD\xA2\xAC\xA6\uFFFD"
    },
    ibm1133: "cp1133",
    csibm1133: "cp1133",
    cp1161: {
      type: "_sbcs",
      chars: "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0E48\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\u0E49\u0E4A\u0E4B\u20AC\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\xA2\xAC\xA6\xA0"
    },
    ibm1161: "cp1161",
    csibm1161: "cp1161",
    cp1162: {
      type: "_sbcs",
      chars: "\u20AC\x81\x82\x83\x84\u2026\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\u2018\u2019\u201C\u201D\u2022\u2013\u2014\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
    },
    ibm1162: "cp1162",
    csibm1162: "cp1162",
    cp1163: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\u20AC\xA5\xA6\xA7\u0153\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\u0178\xB5\xB6\xB7\u0152\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\u0102\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\u0300\xCD\xCE\xCF\u0110\xD1\u0309\xD3\xD4\u01A0\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u01AF\u0303\xDF\xE0\xE1\xE2\u0103\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\u0301\xED\xEE\xEF\u0111\xF1\u0323\xF3\xF4\u01A1\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u01B0\u20AB\xFF"
    },
    ibm1163: "cp1163",
    csibm1163: "cp1163",
    maccroatian: {
      type: "_sbcs",
      chars: "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\u0160\u2122\xB4\xA8\u2260\u017D\xD8\u221E\xB1\u2264\u2265\u2206\xB5\u2202\u2211\u220F\u0161\u222B\xAA\xBA\u2126\u017E\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u0106\xAB\u010C\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u0110\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\uFFFD\xA9\u2044\xA4\u2039\u203A\xC6\xBB\u2013\xB7\u201A\u201E\u2030\xC2\u0107\xC1\u010D\xC8\xCD\xCE\xCF\xCC\xD3\xD4\u0111\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u03C0\xCB\u02DA\xB8\xCA\xE6\u02C7"
    },
    maccyrillic: {
      type: "_sbcs",
      chars: "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u2020\xB0\xA2\xA3\xA7\u2022\xB6\u0406\xAE\xA9\u2122\u0402\u0452\u2260\u0403\u0453\u221E\xB1\u2264\u2265\u0456\xB5\u2202\u0408\u0404\u0454\u0407\u0457\u0409\u0459\u040A\u045A\u0458\u0405\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\u040B\u045B\u040C\u045C\u0455\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u201E\u040E\u045E\u040F\u045F\u2116\u0401\u0451\u044F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\xA4"
    },
    macgreek: {
      type: "_sbcs",
      chars: "\xC4\xB9\xB2\xC9\xB3\xD6\xDC\u0385\xE0\xE2\xE4\u0384\xA8\xE7\xE9\xE8\xEA\xEB\xA3\u2122\xEE\xEF\u2022\xBD\u2030\xF4\xF6\xA6\xAD\xF9\xFB\xFC\u2020\u0393\u0394\u0398\u039B\u039E\u03A0\xDF\xAE\xA9\u03A3\u03AA\xA7\u2260\xB0\u0387\u0391\xB1\u2264\u2265\xA5\u0392\u0395\u0396\u0397\u0399\u039A\u039C\u03A6\u03AB\u03A8\u03A9\u03AC\u039D\xAC\u039F\u03A1\u2248\u03A4\xAB\xBB\u2026\xA0\u03A5\u03A7\u0386\u0388\u0153\u2013\u2015\u201C\u201D\u2018\u2019\xF7\u0389\u038A\u038C\u038E\u03AD\u03AE\u03AF\u03CC\u038F\u03CD\u03B1\u03B2\u03C8\u03B4\u03B5\u03C6\u03B3\u03B7\u03B9\u03BE\u03BA\u03BB\u03BC\u03BD\u03BF\u03C0\u03CE\u03C1\u03C3\u03C4\u03B8\u03C9\u03C2\u03C7\u03C5\u03B6\u03CA\u03CB\u0390\u03B0\uFFFD"
    },
    maciceland: {
      type: "_sbcs",
      chars: "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\xDD\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\xD0\xF0\xDE\xFE\xFD\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
    },
    macroman: {
      type: "_sbcs",
      chars: "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\u2039\u203A\uFB01\uFB02\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
    },
    macromania: {
      type: "_sbcs",
      chars: "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\u0102\u015E\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\u0103\u015F\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\u2039\u203A\u0162\u0163\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
    },
    macthai: {
      type: "_sbcs",
      chars: "\xAB\xBB\u2026\uF88C\uF88F\uF892\uF895\uF898\uF88B\uF88E\uF891\uF894\uF897\u201C\u201D\uF899\uFFFD\u2022\uF884\uF889\uF885\uF886\uF887\uF888\uF88A\uF88D\uF890\uF893\uF896\u2018\u2019\uFFFD\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFEFF\u200B\u2013\u2014\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u2122\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\xAE\xA9\uFFFD\uFFFD\uFFFD\uFFFD"
    },
    macturkish: {
      type: "_sbcs",
      chars: "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u011E\u011F\u0130\u0131\u015E\u015F\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\uFFFD\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
    },
    macukraine: {
      type: "_sbcs",
      chars: "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u2020\xB0\u0490\xA3\xA7\u2022\xB6\u0406\xAE\xA9\u2122\u0402\u0452\u2260\u0403\u0453\u221E\xB1\u2264\u2265\u0456\xB5\u0491\u0408\u0404\u0454\u0407\u0457\u0409\u0459\u040A\u045A\u0458\u0405\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\u040B\u045B\u040C\u045C\u0455\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u201E\u040E\u045E\u040F\u045F\u2116\u0401\u0451\u044F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\xA4"
    },
    koi8r: {
      type: "_sbcs",
      chars: "\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2580\u2584\u2588\u258C\u2590\u2591\u2592\u2593\u2320\u25A0\u2219\u221A\u2248\u2264\u2265\xA0\u2321\xB0\xB2\xB7\xF7\u2550\u2551\u2552\u0451\u2553\u2554\u2555\u2556\u2557\u2558\u2559\u255A\u255B\u255C\u255D\u255E\u255F\u2560\u2561\u0401\u2562\u2563\u2564\u2565\u2566\u2567\u2568\u2569\u256A\u256B\u256C\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
    },
    koi8u: {
      type: "_sbcs",
      chars: "\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2580\u2584\u2588\u258C\u2590\u2591\u2592\u2593\u2320\u25A0\u2219\u221A\u2248\u2264\u2265\xA0\u2321\xB0\xB2\xB7\xF7\u2550\u2551\u2552\u0451\u0454\u2554\u0456\u0457\u2557\u2558\u2559\u255A\u255B\u0491\u255D\u255E\u255F\u2560\u2561\u0401\u0404\u2563\u0406\u0407\u2566\u2567\u2568\u2569\u256A\u0490\u256C\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
    },
    koi8ru: {
      type: "_sbcs",
      chars: "\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2580\u2584\u2588\u258C\u2590\u2591\u2592\u2593\u2320\u25A0\u2219\u221A\u2248\u2264\u2265\xA0\u2321\xB0\xB2\xB7\xF7\u2550\u2551\u2552\u0451\u0454\u2554\u0456\u0457\u2557\u2558\u2559\u255A\u255B\u0491\u045E\u255E\u255F\u2560\u2561\u0401\u0404\u2563\u0406\u0407\u2566\u2567\u2568\u2569\u256A\u0490\u040E\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
    },
    koi8t: {
      type: "_sbcs",
      chars: "\u049B\u0493\u201A\u0492\u201E\u2026\u2020\u2021\uFFFD\u2030\u04B3\u2039\u04B2\u04B7\u04B6\uFFFD\u049A\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\uFFFD\u203A\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u04EF\u04EE\u0451\xA4\u04E3\xA6\xA7\uFFFD\uFFFD\uFFFD\xAB\xAC\xAD\xAE\uFFFD\xB0\xB1\xB2\u0401\uFFFD\u04E2\xB6\xB7\uFFFD\u2116\uFFFD\xBB\uFFFD\uFFFD\uFFFD\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
    },
    armscii8: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\uFFFD\u0587\u0589)(\xBB\xAB\u2014.\u055D,-\u058A\u2026\u055C\u055B\u055E\u0531\u0561\u0532\u0562\u0533\u0563\u0534\u0564\u0535\u0565\u0536\u0566\u0537\u0567\u0538\u0568\u0539\u0569\u053A\u056A\u053B\u056B\u053C\u056C\u053D\u056D\u053E\u056E\u053F\u056F\u0540\u0570\u0541\u0571\u0542\u0572\u0543\u0573\u0544\u0574\u0545\u0575\u0546\u0576\u0547\u0577\u0548\u0578\u0549\u0579\u054A\u057A\u054B\u057B\u054C\u057C\u054D\u057D\u054E\u057E\u054F\u057F\u0550\u0580\u0551\u0581\u0552\u0582\u0553\u0583\u0554\u0584\u0555\u0585\u0556\u0586\u055A\uFFFD"
    },
    rk1048: {
      type: "_sbcs",
      chars: "\u0402\u0403\u201A\u0453\u201E\u2026\u2020\u2021\u20AC\u2030\u0409\u2039\u040A\u049A\u04BA\u040F\u0452\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\u0459\u203A\u045A\u049B\u04BB\u045F\xA0\u04B0\u04B1\u04D8\xA4\u04E8\xA6\xA7\u0401\xA9\u0492\xAB\xAC\xAD\xAE\u04AE\xB0\xB1\u0406\u0456\u04E9\xB5\xB6\xB7\u0451\u2116\u0493\xBB\u04D9\u04A2\u04A3\u04AF\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F"
    },
    tcvn: {
      type: "_sbcs",
      chars: "\0\xDA\u1EE4\u1EEA\u1EEC\u1EEE\x07\b	\n\v\f\r\u1EE8\u1EF0\u1EF2\u1EF6\u1EF8\xDD\u1EF4 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7F\xC0\u1EA2\xC3\xC1\u1EA0\u1EB6\u1EAC\xC8\u1EBA\u1EBC\xC9\u1EB8\u1EC6\xCC\u1EC8\u0128\xCD\u1ECA\xD2\u1ECE\xD5\xD3\u1ECC\u1ED8\u1EDC\u1EDE\u1EE0\u1EDA\u1EE2\xD9\u1EE6\u0168\xA0\u0102\xC2\xCA\xD4\u01A0\u01AF\u0110\u0103\xE2\xEA\xF4\u01A1\u01B0\u0111\u1EB0\u0300\u0309\u0303\u0301\u0323\xE0\u1EA3\xE3\xE1\u1EA1\u1EB2\u1EB1\u1EB3\u1EB5\u1EAF\u1EB4\u1EAE\u1EA6\u1EA8\u1EAA\u1EA4\u1EC0\u1EB7\u1EA7\u1EA9\u1EAB\u1EA5\u1EAD\xE8\u1EC2\u1EBB\u1EBD\xE9\u1EB9\u1EC1\u1EC3\u1EC5\u1EBF\u1EC7\xEC\u1EC9\u1EC4\u1EBE\u1ED2\u0129\xED\u1ECB\xF2\u1ED4\u1ECF\xF5\xF3\u1ECD\u1ED3\u1ED5\u1ED7\u1ED1\u1ED9\u1EDD\u1EDF\u1EE1\u1EDB\u1EE3\xF9\u1ED6\u1EE7\u0169\xFA\u1EE5\u1EEB\u1EED\u1EEF\u1EE9\u1EF1\u1EF3\u1EF7\u1EF9\xFD\u1EF5\u1ED0"
    },
    georgianacademy: {
      type: "_sbcs",
      chars: "\x80\x81\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\x8D\x8E\x8F\x90\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\x9D\x9E\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\u10D0\u10D1\u10D2\u10D3\u10D4\u10D5\u10D6\u10D7\u10D8\u10D9\u10DA\u10DB\u10DC\u10DD\u10DE\u10DF\u10E0\u10E1\u10E2\u10E3\u10E4\u10E5\u10E6\u10E7\u10E8\u10E9\u10EA\u10EB\u10EC\u10ED\u10EE\u10EF\u10F0\u10F1\u10F2\u10F3\u10F4\u10F5\u10F6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
    },
    georgianps: {
      type: "_sbcs",
      chars: "\x80\x81\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\x8D\x8E\x8F\x90\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\x9D\x9E\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\u10D0\u10D1\u10D2\u10D3\u10D4\u10D5\u10D6\u10F1\u10D7\u10D8\u10D9\u10DA\u10DB\u10DC\u10F2\u10DD\u10DE\u10DF\u10E0\u10E1\u10E2\u10F3\u10E3\u10E4\u10E5\u10E6\u10E7\u10E8\u10E9\u10EA\u10EB\u10EC\u10ED\u10EE\u10F4\u10EF\u10F0\u10F5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
    },
    pt154: {
      type: "_sbcs",
      chars: "\u0496\u0492\u04EE\u0493\u201E\u2026\u04B6\u04AE\u04B2\u04AF\u04A0\u04E2\u04A2\u049A\u04BA\u04B8\u0497\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u04B3\u04B7\u04A1\u04E3\u04A3\u049B\u04BB\u04B9\xA0\u040E\u045E\u0408\u04E8\u0498\u04B0\xA7\u0401\xA9\u04D8\xAB\xAC\u04EF\xAE\u049C\xB0\u04B1\u0406\u0456\u0499\u04E9\xB6\xB7\u0451\u2116\u04D9\xBB\u0458\u04AA\u04AB\u049D\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F"
    },
    viscii: {
      type: "_sbcs",
      chars: "\0\u1EB2\u1EB4\u1EAA\x07\b	\n\v\f\r\u1EF6\u1EF8\u1EF4 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7F\u1EA0\u1EAE\u1EB0\u1EB6\u1EA4\u1EA6\u1EA8\u1EAC\u1EBC\u1EB8\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EE2\u1EDA\u1EDC\u1EDE\u1ECA\u1ECE\u1ECC\u1EC8\u1EE6\u0168\u1EE4\u1EF2\xD5\u1EAF\u1EB1\u1EB7\u1EA5\u1EA7\u1EA9\u1EAD\u1EBD\u1EB9\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1ED1\u1ED3\u1ED5\u1ED7\u1EE0\u01A0\u1ED9\u1EDD\u1EDF\u1ECB\u1EF0\u1EE8\u1EEA\u1EEC\u01A1\u1EDB\u01AF\xC0\xC1\xC2\xC3\u1EA2\u0102\u1EB3\u1EB5\xC8\xC9\xCA\u1EBA\xCC\xCD\u0128\u1EF3\u0110\u1EE9\xD2\xD3\xD4\u1EA1\u1EF7\u1EEB\u1EED\xD9\xDA\u1EF9\u1EF5\xDD\u1EE1\u01B0\xE0\xE1\xE2\xE3\u1EA3\u0103\u1EEF\u1EAB\xE8\xE9\xEA\u1EBB\xEC\xED\u0129\u1EC9\u0111\u1EF1\xF2\xF3\xF4\xF5\u1ECF\u1ECD\u1EE5\xF9\xFA\u0169\u1EE7\xFD\u1EE3\u1EEE"
    },
    iso646cn: {
      type: "_sbcs",
      chars: "\0\x07\b	\n\v\f\r !\"#\xA5%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}\u203E\x7F\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD"
    },
    iso646jp: {
      type: "_sbcs",
      chars: "\0\x07\b	\n\v\f\r !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\xA5]^_`abcdefghijklmnopqrstuvwxyz{|}\u203E\x7F\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD"
    },
    hproman8: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xC0\xC2\xC8\xCA\xCB\xCE\xCF\xB4\u02CB\u02C6\xA8\u02DC\xD9\xDB\u20A4\xAF\xDD\xFD\xB0\xC7\xE7\xD1\xF1\xA1\xBF\xA4\xA3\xA5\xA7\u0192\xA2\xE2\xEA\xF4\xFB\xE1\xE9\xF3\xFA\xE0\xE8\xF2\xF9\xE4\xEB\xF6\xFC\xC5\xEE\xD8\xC6\xE5\xED\xF8\xE6\xC4\xEC\xD6\xDC\xC9\xEF\xDF\xD4\xC1\xC3\xE3\xD0\xF0\xCD\xCC\xD3\xD2\xD5\xF5\u0160\u0161\xDA\u0178\xFF\xDE\xFE\xB7\xB5\xB6\xBE\u2014\xBC\xBD\xAA\xBA\xAB\u25A0\xBB\xB1\uFFFD"
    },
    macintosh: {
      type: "_sbcs",
      chars: "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\u2039\u203A\uFB01\uFB02\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
    },
    ascii: {
      type: "_sbcs",
      chars: "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD"
    },
    tis620: {
      type: "_sbcs",
      chars: "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
    }
  };
});

// ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/dbcs-codec.js
var require_dbcs_codec = __commonJS((exports2) => {
  "use strict";
  var Buffer2 = require_safer().Buffer;
  exports2._dbcs = DBCSCodec;
  var UNASSIGNED = -1;
  var GB18030_CODE = -2;
  var SEQ_START = -10;
  var NODE_START = -1e3;
  var UNASSIGNED_NODE = new Array(256);
  var DEF_CHAR = -1;
  for (var i = 0; i < 256; i++)
    UNASSIGNED_NODE[i] = UNASSIGNED;
  function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions)
      throw new Error("DBCS codec is called without the data.");
    if (!codecOptions.table)
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    var mappingTable = codecOptions.table();
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
    this.decodeTableSeq = [];
    for (var i2 = 0; i2 < mappingTable.length; i2++)
      this._addDecodeChunk(mappingTable[i2]);
    this.defaultCharUnicode = iconv.defaultCharUnicode;
    this.encodeTable = [];
    this.encodeTableSeq = [];
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
      for (var i2 = 0; i2 < codecOptions.encodeSkipVals.length; i2++) {
        var val = codecOptions.encodeSkipVals[i2];
        if (typeof val === "number")
          skipEncodeChars[val] = true;
        else
          for (var j = val.from; j <= val.to; j++)
            skipEncodeChars[j] = true;
      }
    this._fillEncodeTable(0, 0, skipEncodeChars);
    if (codecOptions.encodeAdd) {
      for (var uChar in codecOptions.encodeAdd)
        if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
          this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }
    this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED)
      this.defCharSB = this.encodeTable[0]["?"];
    if (this.defCharSB === UNASSIGNED)
      this.defCharSB = "?".charCodeAt(0);
    if (typeof codecOptions.gb18030 === "function") {
      this.gb18030 = codecOptions.gb18030();
      var thirdByteNodeIdx = this.decodeTables.length;
      var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);
      var fourthByteNodeIdx = this.decodeTables.length;
      var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);
      for (var i2 = 129; i2 <= 254; i2++) {
        var secondByteNodeIdx = NODE_START - this.decodeTables[0][i2];
        var secondByteNode = this.decodeTables[secondByteNodeIdx];
        for (var j = 48; j <= 57; j++)
          secondByteNode[j] = NODE_START - thirdByteNodeIdx;
      }
      for (var i2 = 129; i2 <= 254; i2++)
        thirdByteNode[i2] = NODE_START - fourthByteNodeIdx;
      for (var i2 = 48; i2 <= 57; i2++)
        fourthByteNode[i2] = GB18030_CODE;
    }
  }
  DBCSCodec.prototype.encoder = DBCSEncoder;
  DBCSCodec.prototype.decoder = DBCSDecoder;
  DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes = [];
    for (; addr > 0; addr >>= 8)
      bytes.push(addr & 255);
    if (bytes.length == 0)
      bytes.push(0);
    var node = this.decodeTables[0];
    for (var i2 = bytes.length - 1; i2 > 0; i2--) {
      var val = node[bytes[i2]];
      if (val == UNASSIGNED) {
        node[bytes[i2]] = NODE_START - this.decodeTables.length;
        this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
      } else if (val <= NODE_START) {
        node = this.decodeTables[NODE_START - val];
      } else
        throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node;
  };
  DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    var curAddr = parseInt(chunk[0], 16);
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 255;
    for (var k = 1; k < chunk.length; k++) {
      var part = chunk[k];
      if (typeof part === "string") {
        for (var l = 0; l < part.length; ) {
          var code = part.charCodeAt(l++);
          if (55296 <= code && code < 56320) {
            var codeTrail = part.charCodeAt(l++);
            if (56320 <= codeTrail && codeTrail < 57344)
              writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
            else
              throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
          } else if (4080 < code && code <= 4095) {
            var len = 4095 - code + 2;
            var seq = [];
            for (var m2 = 0; m2 < len; m2++)
              seq.push(part.charCodeAt(l++));
            writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
            this.decodeTableSeq.push(seq);
          } else
            writeTable[curAddr++] = code;
        }
      } else if (typeof part === "number") {
        var charCode = writeTable[curAddr - 1] + 1;
        for (var l = 0; l < part; l++)
          writeTable[curAddr++] = charCode++;
      } else
        throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 255)
      throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
  };
  DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8;
    if (this.encodeTable[high] === void 0)
      this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
    return this.encodeTable[high];
  };
  DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    if (bucket[low] <= SEQ_START)
      this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
    else if (bucket[low] == UNASSIGNED)
      bucket[low] = dbcsCode;
  };
  DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    var node;
    if (bucket[low] <= SEQ_START) {
      node = this.encodeTableSeq[SEQ_START - bucket[low]];
    } else {
      node = {};
      if (bucket[low] !== UNASSIGNED)
        node[DEF_CHAR] = bucket[low];
      bucket[low] = SEQ_START - this.encodeTableSeq.length;
      this.encodeTableSeq.push(node);
    }
    for (var j = 1; j < seq.length - 1; j++) {
      var oldVal = node[uCode];
      if (typeof oldVal === "object")
        node = oldVal;
      else {
        node = node[uCode] = {};
        if (oldVal !== void 0)
          node[DEF_CHAR] = oldVal;
      }
    }
    uCode = seq[seq.length - 1];
    node[uCode] = dbcsCode;
  };
  DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node = this.decodeTables[nodeIdx];
    for (var i2 = 0; i2 < 256; i2++) {
      var uCode = node[i2];
      var mbCode = prefix + i2;
      if (skipEncodeChars[mbCode])
        continue;
      if (uCode >= 0)
        this._setEncodeChar(uCode, mbCode);
      else if (uCode <= NODE_START)
        this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
      else if (uCode <= SEQ_START)
        this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
    }
  };
  function DBCSEncoder(options, codec) {
    this.leadSurrogate = -1;
    this.seqObj = void 0;
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
  }
  DBCSEncoder.prototype.write = function(str) {
    var newBuf = Buffer2.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i2 = 0, j = 0;
    while (true) {
      if (nextChar === -1) {
        if (i2 == str.length)
          break;
        var uCode = str.charCodeAt(i2++);
      } else {
        var uCode = nextChar;
        nextChar = -1;
      }
      if (55296 <= uCode && uCode < 57344) {
        if (uCode < 56320) {
          if (leadSurrogate === -1) {
            leadSurrogate = uCode;
            continue;
          } else {
            leadSurrogate = uCode;
            uCode = UNASSIGNED;
          }
        } else {
          if (leadSurrogate !== -1) {
            uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
            leadSurrogate = -1;
          } else {
            uCode = UNASSIGNED;
          }
        }
      } else if (leadSurrogate !== -1) {
        nextChar = uCode;
        uCode = UNASSIGNED;
        leadSurrogate = -1;
      }
      var dbcsCode = UNASSIGNED;
      if (seqObj !== void 0 && uCode != UNASSIGNED) {
        var resCode = seqObj[uCode];
        if (typeof resCode === "object") {
          seqObj = resCode;
          continue;
        } else if (typeof resCode == "number") {
          dbcsCode = resCode;
        } else if (resCode == void 0) {
          resCode = seqObj[DEF_CHAR];
          if (resCode !== void 0) {
            dbcsCode = resCode;
            nextChar = uCode;
          } else {
          }
        }
        seqObj = void 0;
      } else if (uCode >= 0) {
        var subtable = this.encodeTable[uCode >> 8];
        if (subtable !== void 0)
          dbcsCode = subtable[uCode & 255];
        if (dbcsCode <= SEQ_START) {
          seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
          continue;
        }
        if (dbcsCode == UNASSIGNED && this.gb18030) {
          var idx = findIdx(this.gb18030.uChars, uCode);
          if (idx != -1) {
            var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
            newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
            dbcsCode = dbcsCode % 12600;
            newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
            dbcsCode = dbcsCode % 1260;
            newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
            dbcsCode = dbcsCode % 10;
            newBuf[j++] = 48 + dbcsCode;
            continue;
          }
        }
      }
      if (dbcsCode === UNASSIGNED)
        dbcsCode = this.defaultCharSingleByte;
      if (dbcsCode < 256) {
        newBuf[j++] = dbcsCode;
      } else if (dbcsCode < 65536) {
        newBuf[j++] = dbcsCode >> 8;
        newBuf[j++] = dbcsCode & 255;
      } else {
        newBuf[j++] = dbcsCode >> 16;
        newBuf[j++] = dbcsCode >> 8 & 255;
        newBuf[j++] = dbcsCode & 255;
      }
    }
    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === void 0)
      return;
    var newBuf = Buffer2.alloc(10), j = 0;
    if (this.seqObj) {
      var dbcsCode = this.seqObj[DEF_CHAR];
      if (dbcsCode !== void 0) {
        if (dbcsCode < 256) {
          newBuf[j++] = dbcsCode;
        } else {
          newBuf[j++] = dbcsCode >> 8;
          newBuf[j++] = dbcsCode & 255;
        }
      } else {
      }
      this.seqObj = void 0;
    }
    if (this.leadSurrogate !== -1) {
      newBuf[j++] = this.defaultCharSingleByte;
      this.leadSurrogate = -1;
    }
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.findIdx = findIdx;
  function DBCSDecoder(options, codec) {
    this.nodeIdx = 0;
    this.prevBuf = Buffer2.alloc(0);
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
  }
  DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer2.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length, seqStart = -this.prevBuf.length, uCode;
    if (prevBufOffset > 0)
      prevBuf = Buffer2.concat([prevBuf, buf.slice(0, 10)]);
    for (var i2 = 0, j = 0; i2 < buf.length; i2++) {
      var curByte = i2 >= 0 ? buf[i2] : prevBuf[i2 + prevBufOffset];
      var uCode = this.decodeTables[nodeIdx][curByte];
      if (uCode >= 0) {
      } else if (uCode === UNASSIGNED) {
        i2 = seqStart;
        uCode = this.defaultCharUnicode.charCodeAt(0);
      } else if (uCode === GB18030_CODE) {
        var curSeq = seqStart >= 0 ? buf.slice(seqStart, i2 + 1) : prevBuf.slice(seqStart + prevBufOffset, i2 + 1 + prevBufOffset);
        var ptr = (curSeq[0] - 129) * 12600 + (curSeq[1] - 48) * 1260 + (curSeq[2] - 129) * 10 + (curSeq[3] - 48);
        var idx = findIdx(this.gb18030.gbChars, ptr);
        uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
      } else if (uCode <= NODE_START) {
        nodeIdx = NODE_START - uCode;
        continue;
      } else if (uCode <= SEQ_START) {
        var seq = this.decodeTableSeq[SEQ_START - uCode];
        for (var k = 0; k < seq.length - 1; k++) {
          uCode = seq[k];
          newBuf[j++] = uCode & 255;
          newBuf[j++] = uCode >> 8;
        }
        uCode = seq[seq.length - 1];
      } else
        throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
      if (uCode > 65535) {
        uCode -= 65536;
        var uCodeLead = 55296 + Math.floor(uCode / 1024);
        newBuf[j++] = uCodeLead & 255;
        newBuf[j++] = uCodeLead >> 8;
        uCode = 56320 + uCode % 1024;
      }
      newBuf[j++] = uCode & 255;
      newBuf[j++] = uCode >> 8;
      nodeIdx = 0;
      seqStart = i2 + 1;
    }
    this.nodeIdx = nodeIdx;
    this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
    return newBuf.slice(0, j).toString("ucs2");
  };
  DBCSDecoder.prototype.end = function() {
    var ret = "";
    while (this.prevBuf.length > 0) {
      ret += this.defaultCharUnicode;
      var buf = this.prevBuf.slice(1);
      this.prevBuf = Buffer2.alloc(0);
      this.nodeIdx = 0;
      if (buf.length > 0)
        ret += this.write(buf);
    }
    this.nodeIdx = 0;
    return ret;
  };
  function findIdx(table, val) {
    if (table[0] > val)
      return -1;
    var l = 0, r = table.length;
    while (l < r - 1) {
      var mid = l + Math.floor((r - l + 1) / 2);
      if (table[mid] <= val)
        l = mid;
      else
        r = mid;
    }
    return l;
  }
});

// ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/shiftjis.json
var require_shiftjis = __commonJS((exports2, module2) => {
  module2.exports = [
    ["0", "\0", 128],
    ["a1", "\uFF61", 62],
    ["8140", "\u3000\u3001\u3002\uFF0C\uFF0E\u30FB\uFF1A\uFF1B\uFF1F\uFF01\u309B\u309C\xB4\uFF40\xA8\uFF3E\uFFE3\uFF3F\u30FD\u30FE\u309D\u309E\u3003\u4EDD\u3005\u3006\u3007\u30FC\u2015\u2010\uFF0F\uFF3C\uFF5E\u2225\uFF5C\u2026\u2025\u2018\u2019\u201C\u201D\uFF08\uFF09\u3014\u3015\uFF3B\uFF3D\uFF5B\uFF5D\u3008", 9, "\uFF0B\uFF0D\xB1\xD7"],
    ["8180", "\xF7\uFF1D\u2260\uFF1C\uFF1E\u2266\u2267\u221E\u2234\u2642\u2640\xB0\u2032\u2033\u2103\uFFE5\uFF04\uFFE0\uFFE1\uFF05\uFF03\uFF06\uFF0A\uFF20\xA7\u2606\u2605\u25CB\u25CF\u25CE\u25C7\u25C6\u25A1\u25A0\u25B3\u25B2\u25BD\u25BC\u203B\u3012\u2192\u2190\u2191\u2193\u3013"],
    ["81b8", "\u2208\u220B\u2286\u2287\u2282\u2283\u222A\u2229"],
    ["81c8", "\u2227\u2228\uFFE2\u21D2\u21D4\u2200\u2203"],
    ["81da", "\u2220\u22A5\u2312\u2202\u2207\u2261\u2252\u226A\u226B\u221A\u223D\u221D\u2235\u222B\u222C"],
    ["81f0", "\u212B\u2030\u266F\u266D\u266A\u2020\u2021\xB6"],
    ["81fc", "\u25EF"],
    ["824f", "\uFF10", 9],
    ["8260", "\uFF21", 25],
    ["8281", "\uFF41", 25],
    ["829f", "\u3041", 82],
    ["8340", "\u30A1", 62],
    ["8380", "\u30E0", 22],
    ["839f", "\u0391", 16, "\u03A3", 6],
    ["83bf", "\u03B1", 16, "\u03C3", 6],
    ["8440", "\u0410", 5, "\u0401\u0416", 25],
    ["8470", "\u0430", 5, "\u0451\u0436", 7],
    ["8480", "\u043E", 17],
    ["849f", "\u2500\u2502\u250C\u2510\u2518\u2514\u251C\u252C\u2524\u2534\u253C\u2501\u2503\u250F\u2513\u251B\u2517\u2523\u2533\u252B\u253B\u254B\u2520\u252F\u2528\u2537\u253F\u251D\u2530\u2525\u2538\u2542"],
    ["8740", "\u2460", 19, "\u2160", 9],
    ["875f", "\u3349\u3314\u3322\u334D\u3318\u3327\u3303\u3336\u3351\u3357\u330D\u3326\u3323\u332B\u334A\u333B\u339C\u339D\u339E\u338E\u338F\u33C4\u33A1"],
    ["877e", "\u337B"],
    ["8780", "\u301D\u301F\u2116\u33CD\u2121\u32A4", 4, "\u3231\u3232\u3239\u337E\u337D\u337C\u2252\u2261\u222B\u222E\u2211\u221A\u22A5\u2220\u221F\u22BF\u2235\u2229\u222A"],
    ["889f", "\u4E9C\u5516\u5A03\u963F\u54C0\u611B\u6328\u59F6\u9022\u8475\u831C\u7A50\u60AA\u63E1\u6E25\u65ED\u8466\u82A6\u9BF5\u6893\u5727\u65A1\u6271\u5B9B\u59D0\u867B\u98F4\u7D62\u7DBE\u9B8E\u6216\u7C9F\u88B7\u5B89\u5EB5\u6309\u6697\u6848\u95C7\u978D\u674F\u4EE5\u4F0A\u4F4D\u4F9D\u5049\u56F2\u5937\u59D4\u5A01\u5C09\u60DF\u610F\u6170\u6613\u6905\u70BA\u754F\u7570\u79FB\u7DAD\u7DEF\u80C3\u840E\u8863\u8B02\u9055\u907A\u533B\u4E95\u4EA5\u57DF\u80B2\u90C1\u78EF\u4E00\u58F1\u6EA2\u9038\u7A32\u8328\u828B\u9C2F\u5141\u5370\u54BD\u54E1\u56E0\u59FB\u5F15\u98F2\u6DEB\u80E4\u852D"],
    ["8940", "\u9662\u9670\u96A0\u97FB\u540B\u53F3\u5B87\u70CF\u7FBD\u8FC2\u96E8\u536F\u9D5C\u7ABA\u4E11\u7893\u81FC\u6E26\u5618\u5504\u6B1D\u851A\u9C3B\u59E5\u53A9\u6D66\u74DC\u958F\u5642\u4E91\u904B\u96F2\u834F\u990C\u53E1\u55B6\u5B30\u5F71\u6620\u66F3\u6804\u6C38\u6CF3\u6D29\u745B\u76C8\u7A4E\u9834\u82F1\u885B\u8A60\u92ED\u6DB2\u75AB\u76CA\u99C5\u60A6\u8B01\u8D8A\u95B2\u698E\u53AD\u5186"],
    ["8980", "\u5712\u5830\u5944\u5BB4\u5EF6\u6028\u63A9\u63F4\u6CBF\u6F14\u708E\u7114\u7159\u71D5\u733F\u7E01\u8276\u82D1\u8597\u9060\u925B\u9D1B\u5869\u65BC\u6C5A\u7525\u51F9\u592E\u5965\u5F80\u5FDC\u62BC\u65FA\u6A2A\u6B27\u6BB4\u738B\u7FC1\u8956\u9D2C\u9D0E\u9EC4\u5CA1\u6C96\u837B\u5104\u5C4B\u61B6\u81C6\u6876\u7261\u4E59\u4FFA\u5378\u6069\u6E29\u7A4F\u97F3\u4E0B\u5316\u4EEE\u4F55\u4F3D\u4FA1\u4F73\u52A0\u53EF\u5609\u590F\u5AC1\u5BB6\u5BE1\u79D1\u6687\u679C\u67B6\u6B4C\u6CB3\u706B\u73C2\u798D\u79BE\u7A3C\u7B87\u82B1\u82DB\u8304\u8377\u83EF\u83D3\u8766\u8AB2\u5629\u8CA8\u8FE6\u904E\u971E\u868A\u4FC4\u5CE8\u6211\u7259\u753B\u81E5\u82BD\u86FE\u8CC0\u96C5\u9913\u99D5\u4ECB\u4F1A\u89E3\u56DE\u584A\u58CA\u5EFB\u5FEB\u602A\u6094\u6062\u61D0\u6212\u62D0\u6539"],
    ["8a40", "\u9B41\u6666\u68B0\u6D77\u7070\u754C\u7686\u7D75\u82A5\u87F9\u958B\u968E\u8C9D\u51F1\u52BE\u5916\u54B3\u5BB3\u5D16\u6168\u6982\u6DAF\u788D\u84CB\u8857\u8A72\u93A7\u9AB8\u6D6C\u99A8\u86D9\u57A3\u67FF\u86CE\u920E\u5283\u5687\u5404\u5ED3\u62E1\u64B9\u683C\u6838\u6BBB\u7372\u78BA\u7A6B\u899A\u89D2\u8D6B\u8F03\u90ED\u95A3\u9694\u9769\u5B66\u5CB3\u697D\u984D\u984E\u639B\u7B20\u6A2B"],
    ["8a80", "\u6A7F\u68B6\u9C0D\u6F5F\u5272\u559D\u6070\u62EC\u6D3B\u6E07\u6ED1\u845B\u8910\u8F44\u4E14\u9C39\u53F6\u691B\u6A3A\u9784\u682A\u515C\u7AC3\u84B2\u91DC\u938C\u565B\u9D28\u6822\u8305\u8431\u7CA5\u5208\u82C5\u74E6\u4E7E\u4F83\u51A0\u5BD2\u520A\u52D8\u52E7\u5DFB\u559A\u582A\u59E6\u5B8C\u5B98\u5BDB\u5E72\u5E79\u60A3\u611F\u6163\u61BE\u63DB\u6562\u67D1\u6853\u68FA\u6B3E\u6B53\u6C57\u6F22\u6F97\u6F45\u74B0\u7518\u76E3\u770B\u7AFF\u7BA1\u7C21\u7DE9\u7F36\u7FF0\u809D\u8266\u839E\u89B3\u8ACC\u8CAB\u9084\u9451\u9593\u9591\u95A2\u9665\u97D3\u9928\u8218\u4E38\u542B\u5CB8\u5DCC\u73A9\u764C\u773C\u5CA9\u7FEB\u8D0B\u96C1\u9811\u9854\u9858\u4F01\u4F0E\u5371\u559C\u5668\u57FA\u5947\u5B09\u5BC4\u5C90\u5E0C\u5E7E\u5FCC\u63EE\u673A\u65D7\u65E2\u671F\u68CB\u68C4"],
    ["8b40", "\u6A5F\u5E30\u6BC5\u6C17\u6C7D\u757F\u7948\u5B63\u7A00\u7D00\u5FBD\u898F\u8A18\u8CB4\u8D77\u8ECC\u8F1D\u98E2\u9A0E\u9B3C\u4E80\u507D\u5100\u5993\u5B9C\u622F\u6280\u64EC\u6B3A\u72A0\u7591\u7947\u7FA9\u87FB\u8ABC\u8B70\u63AC\u83CA\u97A0\u5409\u5403\u55AB\u6854\u6A58\u8A70\u7827\u6775\u9ECD\u5374\u5BA2\u811A\u8650\u9006\u4E18\u4E45\u4EC7\u4F11\u53CA\u5438\u5BAE\u5F13\u6025\u6551"],
    ["8b80", "\u673D\u6C42\u6C72\u6CE3\u7078\u7403\u7A76\u7AAE\u7B08\u7D1A\u7CFE\u7D66\u65E7\u725B\u53BB\u5C45\u5DE8\u62D2\u62E0\u6319\u6E20\u865A\u8A31\u8DDD\u92F8\u6F01\u79A6\u9B5A\u4EA8\u4EAB\u4EAC\u4F9B\u4FA0\u50D1\u5147\u7AF6\u5171\u51F6\u5354\u5321\u537F\u53EB\u55AC\u5883\u5CE1\u5F37\u5F4A\u602F\u6050\u606D\u631F\u6559\u6A4B\u6CC1\u72C2\u72ED\u77EF\u80F8\u8105\u8208\u854E\u90F7\u93E1\u97FF\u9957\u9A5A\u4EF0\u51DD\u5C2D\u6681\u696D\u5C40\u66F2\u6975\u7389\u6850\u7C81\u50C5\u52E4\u5747\u5DFE\u9326\u65A4\u6B23\u6B3D\u7434\u7981\u79BD\u7B4B\u7DCA\u82B9\u83CC\u887F\u895F\u8B39\u8FD1\u91D1\u541F\u9280\u4E5D\u5036\u53E5\u533A\u72D7\u7396\u77E9\u82E6\u8EAF\u99C6\u99C8\u99D2\u5177\u611A\u865E\u55B0\u7A7A\u5076\u5BD3\u9047\u9685\u4E32\u6ADB\u91E7\u5C51\u5C48"],
    ["8c40", "\u6398\u7A9F\u6C93\u9774\u8F61\u7AAA\u718A\u9688\u7C82\u6817\u7E70\u6851\u936C\u52F2\u541B\u85AB\u8A13\u7FA4\u8ECD\u90E1\u5366\u8888\u7941\u4FC2\u50BE\u5211\u5144\u5553\u572D\u73EA\u578B\u5951\u5F62\u5F84\u6075\u6176\u6167\u61A9\u63B2\u643A\u656C\u666F\u6842\u6E13\u7566\u7A3D\u7CFB\u7D4C\u7D99\u7E4B\u7F6B\u830E\u834A\u86CD\u8A08\u8A63\u8B66\u8EFD\u981A\u9D8F\u82B8\u8FCE\u9BE8"],
    ["8c80", "\u5287\u621F\u6483\u6FC0\u9699\u6841\u5091\u6B20\u6C7A\u6F54\u7A74\u7D50\u8840\u8A23\u6708\u4EF6\u5039\u5026\u5065\u517C\u5238\u5263\u55A7\u570F\u5805\u5ACC\u5EFA\u61B2\u61F8\u62F3\u6372\u691C\u6A29\u727D\u72AC\u732E\u7814\u786F\u7D79\u770C\u80A9\u898B\u8B19\u8CE2\u8ED2\u9063\u9375\u967A\u9855\u9A13\u9E78\u5143\u539F\u53B3\u5E7B\u5F26\u6E1B\u6E90\u7384\u73FE\u7D43\u8237\u8A00\u8AFA\u9650\u4E4E\u500B\u53E4\u547C\u56FA\u59D1\u5B64\u5DF1\u5EAB\u5F27\u6238\u6545\u67AF\u6E56\u72D0\u7CCA\u88B4\u80A1\u80E1\u83F0\u864E\u8A87\u8DE8\u9237\u96C7\u9867\u9F13\u4E94\u4E92\u4F0D\u5348\u5449\u543E\u5A2F\u5F8C\u5FA1\u609F\u68A7\u6A8E\u745A\u7881\u8A9E\u8AA4\u8B77\u9190\u4E5E\u9BC9\u4EA4\u4F7C\u4FAF\u5019\u5016\u5149\u516C\u529F\u52B9\u52FE\u539A\u53E3\u5411"],
    ["8d40", "\u540E\u5589\u5751\u57A2\u597D\u5B54\u5B5D\u5B8F\u5DE5\u5DE7\u5DF7\u5E78\u5E83\u5E9A\u5EB7\u5F18\u6052\u614C\u6297\u62D8\u63A7\u653B\u6602\u6643\u66F4\u676D\u6821\u6897\u69CB\u6C5F\u6D2A\u6D69\u6E2F\u6E9D\u7532\u7687\u786C\u7A3F\u7CE0\u7D05\u7D18\u7D5E\u7DB1\u8015\u8003\u80AF\u80B1\u8154\u818F\u822A\u8352\u884C\u8861\u8B1B\u8CA2\u8CFC\u90CA\u9175\u9271\u783F\u92FC\u95A4\u964D"],
    ["8d80", "\u9805\u9999\u9AD8\u9D3B\u525B\u52AB\u53F7\u5408\u58D5\u62F7\u6FE0\u8C6A\u8F5F\u9EB9\u514B\u523B\u544A\u56FD\u7A40\u9177\u9D60\u9ED2\u7344\u6F09\u8170\u7511\u5FFD\u60DA\u9AA8\u72DB\u8FBC\u6B64\u9803\u4ECA\u56F0\u5764\u58BE\u5A5A\u6068\u61C7\u660F\u6606\u6839\u68B1\u6DF7\u75D5\u7D3A\u826E\u9B42\u4E9B\u4F50\u53C9\u5506\u5D6F\u5DE6\u5DEE\u67FB\u6C99\u7473\u7802\u8A50\u9396\u88DF\u5750\u5EA7\u632B\u50B5\u50AC\u518D\u6700\u54C9\u585E\u59BB\u5BB0\u5F69\u624D\u63A1\u683D\u6B73\u6E08\u707D\u91C7\u7280\u7815\u7826\u796D\u658E\u7D30\u83DC\u88C1\u8F09\u969B\u5264\u5728\u6750\u7F6A\u8CA1\u51B4\u5742\u962A\u583A\u698A\u80B4\u54B2\u5D0E\u57FC\u7895\u9DFA\u4F5C\u524A\u548B\u643E\u6628\u6714\u67F5\u7A84\u7B56\u7D22\u932F\u685C\u9BAD\u7B39\u5319\u518A\u5237"],
    ["8e40", "\u5BDF\u62F6\u64AE\u64E6\u672D\u6BBA\u85A9\u96D1\u7690\u9BD6\u634C\u9306\u9BAB\u76BF\u6652\u4E09\u5098\u53C2\u5C71\u60E8\u6492\u6563\u685F\u71E6\u73CA\u7523\u7B97\u7E82\u8695\u8B83\u8CDB\u9178\u9910\u65AC\u66AB\u6B8B\u4ED5\u4ED4\u4F3A\u4F7F\u523A\u53F8\u53F2\u55E3\u56DB\u58EB\u59CB\u59C9\u59FF\u5B50\u5C4D\u5E02\u5E2B\u5FD7\u601D\u6307\u652F\u5B5C\u65AF\u65BD\u65E8\u679D\u6B62"],
    ["8e80", "\u6B7B\u6C0F\u7345\u7949\u79C1\u7CF8\u7D19\u7D2B\u80A2\u8102\u81F3\u8996\u8A5E\u8A69\u8A66\u8A8C\u8AEE\u8CC7\u8CDC\u96CC\u98FC\u6B6F\u4E8B\u4F3C\u4F8D\u5150\u5B57\u5BFA\u6148\u6301\u6642\u6B21\u6ECB\u6CBB\u723E\u74BD\u75D4\u78C1\u793A\u800C\u8033\u81EA\u8494\u8F9E\u6C50\u9E7F\u5F0F\u8B58\u9D2B\u7AFA\u8EF8\u5B8D\u96EB\u4E03\u53F1\u57F7\u5931\u5AC9\u5BA4\u6089\u6E7F\u6F06\u75BE\u8CEA\u5B9F\u8500\u7BE0\u5072\u67F4\u829D\u5C61\u854A\u7E1E\u820E\u5199\u5C04\u6368\u8D66\u659C\u716E\u793E\u7D17\u8005\u8B1D\u8ECA\u906E\u86C7\u90AA\u501F\u52FA\u5C3A\u6753\u707C\u7235\u914C\u91C8\u932B\u82E5\u5BC2\u5F31\u60F9\u4E3B\u53D6\u5B88\u624B\u6731\u6B8A\u72E9\u73E0\u7A2E\u816B\u8DA3\u9152\u9996\u5112\u53D7\u546A\u5BFF\u6388\u6A39\u7DAC\u9700\u56DA\u53CE\u5468"],
    ["8f40", "\u5B97\u5C31\u5DDE\u4FEE\u6101\u62FE\u6D32\u79C0\u79CB\u7D42\u7E4D\u7FD2\u81ED\u821F\u8490\u8846\u8972\u8B90\u8E74\u8F2F\u9031\u914B\u916C\u96C6\u919C\u4EC0\u4F4F\u5145\u5341\u5F93\u620E\u67D4\u6C41\u6E0B\u7363\u7E26\u91CD\u9283\u53D4\u5919\u5BBF\u6DD1\u795D\u7E2E\u7C9B\u587E\u719F\u51FA\u8853\u8FF0\u4FCA\u5CFB\u6625\u77AC\u7AE3\u821C\u99FF\u51C6\u5FAA\u65EC\u696F\u6B89\u6DF3"],
    ["8f80", "\u6E96\u6F64\u76FE\u7D14\u5DE1\u9075\u9187\u9806\u51E6\u521D\u6240\u6691\u66D9\u6E1A\u5EB6\u7DD2\u7F72\u66F8\u85AF\u85F7\u8AF8\u52A9\u53D9\u5973\u5E8F\u5F90\u6055\u92E4\u9664\u50B7\u511F\u52DD\u5320\u5347\u53EC\u54E8\u5546\u5531\u5617\u5968\u59BE\u5A3C\u5BB5\u5C06\u5C0F\u5C11\u5C1A\u5E84\u5E8A\u5EE0\u5F70\u627F\u6284\u62DB\u638C\u6377\u6607\u660C\u662D\u6676\u677E\u68A2\u6A1F\u6A35\u6CBC\u6D88\u6E09\u6E58\u713C\u7126\u7167\u75C7\u7701\u785D\u7901\u7965\u79F0\u7AE0\u7B11\u7CA7\u7D39\u8096\u83D6\u848B\u8549\u885D\u88F3\u8A1F\u8A3C\u8A54\u8A73\u8C61\u8CDE\u91A4\u9266\u937E\u9418\u969C\u9798\u4E0A\u4E08\u4E1E\u4E57\u5197\u5270\u57CE\u5834\u58CC\u5B22\u5E38\u60C5\u64FE\u6761\u6756\u6D44\u72B6\u7573\u7A63\u84B8\u8B72\u91B8\u9320\u5631\u57F4\u98FE"],
    ["9040", "\u62ED\u690D\u6B96\u71ED\u7E54\u8077\u8272\u89E6\u98DF\u8755\u8FB1\u5C3B\u4F38\u4FE1\u4FB5\u5507\u5A20\u5BDD\u5BE9\u5FC3\u614E\u632F\u65B0\u664B\u68EE\u699B\u6D78\u6DF1\u7533\u75B9\u771F\u795E\u79E6\u7D33\u81E3\u82AF\u85AA\u89AA\u8A3A\u8EAB\u8F9B\u9032\u91DD\u9707\u4EBA\u4EC1\u5203\u5875\u58EC\u5C0B\u751A\u5C3D\u814E\u8A0A\u8FC5\u9663\u976D\u7B25\u8ACF\u9808\u9162\u56F3\u53A8"],
    ["9080", "\u9017\u5439\u5782\u5E25\u63A8\u6C34\u708A\u7761\u7C8B\u7FE0\u8870\u9042\u9154\u9310\u9318\u968F\u745E\u9AC4\u5D07\u5D69\u6570\u67A2\u8DA8\u96DB\u636E\u6749\u6919\u83C5\u9817\u96C0\u88FE\u6F84\u647A\u5BF8\u4E16\u702C\u755D\u662F\u51C4\u5236\u52E2\u59D3\u5F81\u6027\u6210\u653F\u6574\u661F\u6674\u68F2\u6816\u6B63\u6E05\u7272\u751F\u76DB\u7CBE\u8056\u58F0\u88FD\u897F\u8AA0\u8A93\u8ACB\u901D\u9192\u9752\u9759\u6589\u7A0E\u8106\u96BB\u5E2D\u60DC\u621A\u65A5\u6614\u6790\u77F3\u7A4D\u7C4D\u7E3E\u810A\u8CAC\u8D64\u8DE1\u8E5F\u78A9\u5207\u62D9\u63A5\u6442\u6298\u8A2D\u7A83\u7BC0\u8AAC\u96EA\u7D76\u820C\u8749\u4ED9\u5148\u5343\u5360\u5BA3\u5C02\u5C16\u5DDD\u6226\u6247\u64B0\u6813\u6834\u6CC9\u6D45\u6D17\u67D3\u6F5C\u714E\u717D\u65CB\u7A7F\u7BAD\u7DDA"],
    ["9140", "\u7E4A\u7FA8\u817A\u821B\u8239\u85A6\u8A6E\u8CCE\u8DF5\u9078\u9077\u92AD\u9291\u9583\u9BAE\u524D\u5584\u6F38\u7136\u5168\u7985\u7E55\u81B3\u7CCE\u564C\u5851\u5CA8\u63AA\u66FE\u66FD\u695A\u72D9\u758F\u758E\u790E\u7956\u79DF\u7C97\u7D20\u7D44\u8607\u8A34\u963B\u9061\u9F20\u50E7\u5275\u53CC\u53E2\u5009\u55AA\u58EE\u594F\u723D\u5B8B\u5C64\u531D\u60E3\u60F3\u635C\u6383\u633F\u63BB"],
    ["9180", "\u64CD\u65E9\u66F9\u5DE3\u69CD\u69FD\u6F15\u71E5\u4E89\u75E9\u76F8\u7A93\u7CDF\u7DCF\u7D9C\u8061\u8349\u8358\u846C\u84BC\u85FB\u88C5\u8D70\u9001\u906D\u9397\u971C\u9A12\u50CF\u5897\u618E\u81D3\u8535\u8D08\u9020\u4FC3\u5074\u5247\u5373\u606F\u6349\u675F\u6E2C\u8DB3\u901F\u4FD7\u5C5E\u8CCA\u65CF\u7D9A\u5352\u8896\u5176\u63C3\u5B58\u5B6B\u5C0A\u640D\u6751\u905C\u4ED6\u591A\u592A\u6C70\u8A51\u553E\u5815\u59A5\u60F0\u6253\u67C1\u8235\u6955\u9640\u99C4\u9A28\u4F53\u5806\u5BFE\u8010\u5CB1\u5E2F\u5F85\u6020\u614B\u6234\u66FF\u6CF0\u6EDE\u80CE\u817F\u82D4\u888B\u8CB8\u9000\u902E\u968A\u9EDB\u9BDB\u4EE3\u53F0\u5927\u7B2C\u918D\u984C\u9DF9\u6EDD\u7027\u5353\u5544\u5B85\u6258\u629E\u62D3\u6CA2\u6FEF\u7422\u8A17\u9438\u6FC1\u8AFE\u8338\u51E7\u86F8\u53EA"],
    ["9240", "\u53E9\u4F46\u9054\u8FB0\u596A\u8131\u5DFD\u7AEA\u8FBF\u68DA\u8C37\u72F8\u9C48\u6A3D\u8AB0\u4E39\u5358\u5606\u5766\u62C5\u63A2\u65E6\u6B4E\u6DE1\u6E5B\u70AD\u77ED\u7AEF\u7BAA\u7DBB\u803D\u80C6\u86CB\u8A95\u935B\u56E3\u58C7\u5F3E\u65AD\u6696\u6A80\u6BB5\u7537\u8AC7\u5024\u77E5\u5730\u5F1B\u6065\u667A\u6C60\u75F4\u7A1A\u7F6E\u81F4\u8718\u9045\u99B3\u7BC9\u755C\u7AF9\u7B51\u84C4"],
    ["9280", "\u9010\u79E9\u7A92\u8336\u5AE1\u7740\u4E2D\u4EF2\u5B99\u5FE0\u62BD\u663C\u67F1\u6CE8\u866B\u8877\u8A3B\u914E\u92F3\u99D0\u6A17\u7026\u732A\u82E7\u8457\u8CAF\u4E01\u5146\u51CB\u558B\u5BF5\u5E16\u5E33\u5E81\u5F14\u5F35\u5F6B\u5FB4\u61F2\u6311\u66A2\u671D\u6F6E\u7252\u753A\u773A\u8074\u8139\u8178\u8776\u8ABF\u8ADC\u8D85\u8DF3\u929A\u9577\u9802\u9CE5\u52C5\u6357\u76F4\u6715\u6C88\u73CD\u8CC3\u93AE\u9673\u6D25\u589C\u690E\u69CC\u8FFD\u939A\u75DB\u901A\u585A\u6802\u63B4\u69FB\u4F43\u6F2C\u67D8\u8FBB\u8526\u7DB4\u9354\u693F\u6F70\u576A\u58F7\u5B2C\u7D2C\u722A\u540A\u91E3\u9DB4\u4EAD\u4F4E\u505C\u5075\u5243\u8C9E\u5448\u5824\u5B9A\u5E1D\u5E95\u5EAD\u5EF7\u5F1F\u608C\u62B5\u633A\u63D0\u68AF\u6C40\u7887\u798E\u7A0B\u7DE0\u8247\u8A02\u8AE6\u8E44\u9013"],
    ["9340", "\u90B8\u912D\u91D8\u9F0E\u6CE5\u6458\u64E2\u6575\u6EF4\u7684\u7B1B\u9069\u93D1\u6EBA\u54F2\u5FB9\u64A4\u8F4D\u8FED\u9244\u5178\u586B\u5929\u5C55\u5E97\u6DFB\u7E8F\u751C\u8CBC\u8EE2\u985B\u70B9\u4F1D\u6BBF\u6FB1\u7530\u96FB\u514E\u5410\u5835\u5857\u59AC\u5C60\u5F92\u6597\u675C\u6E21\u767B\u83DF\u8CED\u9014\u90FD\u934D\u7825\u783A\u52AA\u5EA6\u571F\u5974\u6012\u5012\u515A\u51AC"],
    ["9380", "\u51CD\u5200\u5510\u5854\u5858\u5957\u5B95\u5CF6\u5D8B\u60BC\u6295\u642D\u6771\u6843\u68BC\u68DF\u76D7\u6DD8\u6E6F\u6D9B\u706F\u71C8\u5F53\u75D8\u7977\u7B49\u7B54\u7B52\u7CD6\u7D71\u5230\u8463\u8569\u85E4\u8A0E\u8B04\u8C46\u8E0F\u9003\u900F\u9419\u9676\u982D\u9A30\u95D8\u50CD\u52D5\u540C\u5802\u5C0E\u61A7\u649E\u6D1E\u77B3\u7AE5\u80F4\u8404\u9053\u9285\u5CE0\u9D07\u533F\u5F97\u5FB3\u6D9C\u7279\u7763\u79BF\u7BE4\u6BD2\u72EC\u8AAD\u6803\u6A61\u51F8\u7A81\u6934\u5C4A\u9CF6\u82EB\u5BC5\u9149\u701E\u5678\u5C6F\u60C7\u6566\u6C8C\u8C5A\u9041\u9813\u5451\u66C7\u920D\u5948\u90A3\u5185\u4E4D\u51EA\u8599\u8B0E\u7058\u637A\u934B\u6962\u99B4\u7E04\u7577\u5357\u6960\u8EDF\u96E3\u6C5D\u4E8C\u5C3C\u5F10\u8FE9\u5302\u8CD1\u8089\u8679\u5EFF\u65E5\u4E73\u5165"],
    ["9440", "\u5982\u5C3F\u97EE\u4EFB\u598A\u5FCD\u8A8D\u6FE1\u79B0\u7962\u5BE7\u8471\u732B\u71B1\u5E74\u5FF5\u637B\u649A\u71C3\u7C98\u4E43\u5EFC\u4E4B\u57DC\u56A2\u60A9\u6FC3\u7D0D\u80FD\u8133\u81BF\u8FB2\u8997\u86A4\u5DF4\u628A\u64AD\u8987\u6777\u6CE2\u6D3E\u7436\u7834\u5A46\u7F75\u82AD\u99AC\u4FF3\u5EC3\u62DD\u6392\u6557\u676F\u76C3\u724C\u80CC\u80BA\u8F29\u914D\u500D\u57F9\u5A92\u6885"],
    ["9480", "\u6973\u7164\u72FD\u8CB7\u58F2\u8CE0\u966A\u9019\u877F\u79E4\u77E7\u8429\u4F2F\u5265\u535A\u62CD\u67CF\u6CCA\u767D\u7B94\u7C95\u8236\u8584\u8FEB\u66DD\u6F20\u7206\u7E1B\u83AB\u99C1\u9EA6\u51FD\u7BB1\u7872\u7BB8\u8087\u7B48\u6AE8\u5E61\u808C\u7551\u7560\u516B\u9262\u6E8C\u767A\u9197\u9AEA\u4F10\u7F70\u629C\u7B4F\u95A5\u9CE9\u567A\u5859\u86E4\u96BC\u4F34\u5224\u534A\u53CD\u53DB\u5E06\u642C\u6591\u677F\u6C3E\u6C4E\u7248\u72AF\u73ED\u7554\u7E41\u822C\u85E9\u8CA9\u7BC4\u91C6\u7169\u9812\u98EF\u633D\u6669\u756A\u76E4\u78D0\u8543\u86EE\u532A\u5351\u5426\u5983\u5E87\u5F7C\u60B2\u6249\u6279\u62AB\u6590\u6BD4\u6CCC\u75B2\u76AE\u7891\u79D8\u7DCB\u7F77\u80A5\u88AB\u8AB9\u8CBB\u907F\u975E\u98DB\u6A0B\u7C38\u5099\u5C3E\u5FAE\u6787\u6BD8\u7435\u7709\u7F8E"],
    ["9540", "\u9F3B\u67CA\u7A17\u5339\u758B\u9AED\u5F66\u819D\u83F1\u8098\u5F3C\u5FC5\u7562\u7B46\u903C\u6867\u59EB\u5A9B\u7D10\u767E\u8B2C\u4FF5\u5F6A\u6A19\u6C37\u6F02\u74E2\u7968\u8868\u8A55\u8C79\u5EDF\u63CF\u75C5\u79D2\u82D7\u9328\u92F2\u849C\u86ED\u9C2D\u54C1\u5F6C\u658C\u6D5C\u7015\u8CA7\u8CD3\u983B\u654F\u74F6\u4E0D\u4ED8\u57E0\u592B\u5A66\u5BCC\u51A8\u5E03\u5E9C\u6016\u6276\u6577"],
    ["9580", "\u65A7\u666E\u6D6E\u7236\u7B26\u8150\u819A\u8299\u8B5C\u8CA0\u8CE6\u8D74\u961C\u9644\u4FAE\u64AB\u6B66\u821E\u8461\u856A\u90E8\u5C01\u6953\u98A8\u847A\u8557\u4F0F\u526F\u5FA9\u5E45\u670D\u798F\u8179\u8907\u8986\u6DF5\u5F17\u6255\u6CB8\u4ECF\u7269\u9B92\u5206\u543B\u5674\u58B3\u61A4\u626E\u711A\u596E\u7C89\u7CDE\u7D1B\u96F0\u6587\u805E\u4E19\u4F75\u5175\u5840\u5E63\u5E73\u5F0A\u67C4\u4E26\u853D\u9589\u965B\u7C73\u9801\u50FB\u58C1\u7656\u78A7\u5225\u77A5\u8511\u7B86\u504F\u5909\u7247\u7BC7\u7DE8\u8FBA\u8FD4\u904D\u4FBF\u52C9\u5A29\u5F01\u97AD\u4FDD\u8217\u92EA\u5703\u6355\u6B69\u752B\u88DC\u8F14\u7A42\u52DF\u5893\u6155\u620A\u66AE\u6BCD\u7C3F\u83E9\u5023\u4FF8\u5305\u5446\u5831\u5949\u5B9D\u5CF0\u5CEF\u5D29\u5E96\u62B1\u6367\u653E\u65B9\u670B"],
    ["9640", "\u6CD5\u6CE1\u70F9\u7832\u7E2B\u80DE\u82B3\u840C\u84EC\u8702\u8912\u8A2A\u8C4A\u90A6\u92D2\u98FD\u9CF3\u9D6C\u4E4F\u4EA1\u508D\u5256\u574A\u59A8\u5E3D\u5FD8\u5FD9\u623F\u66B4\u671B\u67D0\u68D2\u5192\u7D21\u80AA\u81A8\u8B00\u8C8C\u8CBF\u927E\u9632\u5420\u982C\u5317\u50D5\u535C\u58A8\u64B2\u6734\u7267\u7766\u7A46\u91E6\u52C3\u6CA1\u6B86\u5800\u5E4C\u5954\u672C\u7FFB\u51E1\u76C6"],
    ["9680", "\u6469\u78E8\u9B54\u9EBB\u57CB\u59B9\u6627\u679A\u6BCE\u54E9\u69D9\u5E55\u819C\u6795\u9BAA\u67FE\u9C52\u685D\u4EA6\u4FE3\u53C8\u62B9\u672B\u6CAB\u8FC4\u4FAD\u7E6D\u9EBF\u4E07\u6162\u6E80\u6F2B\u8513\u5473\u672A\u9B45\u5DF3\u7B95\u5CAC\u5BC6\u871C\u6E4A\u84D1\u7A14\u8108\u5999\u7C8D\u6C11\u7720\u52D9\u5922\u7121\u725F\u77DB\u9727\u9D61\u690B\u5A7F\u5A18\u51A5\u540D\u547D\u660E\u76DF\u8FF7\u9298\u9CF4\u59EA\u725D\u6EC5\u514D\u68C9\u7DBF\u7DEC\u9762\u9EBA\u6478\u6A21\u8302\u5984\u5B5F\u6BDB\u731B\u76F2\u7DB2\u8017\u8499\u5132\u6728\u9ED9\u76EE\u6762\u52FF\u9905\u5C24\u623B\u7C7E\u8CB0\u554F\u60B6\u7D0B\u9580\u5301\u4E5F\u51B6\u591C\u723A\u8036\u91CE\u5F25\u77E2\u5384\u5F79\u7D04\u85AC\u8A33\u8E8D\u9756\u67F3\u85AE\u9453\u6109\u6108\u6CB9\u7652"],
    ["9740", "\u8AED\u8F38\u552F\u4F51\u512A\u52C7\u53CB\u5BA5\u5E7D\u60A0\u6182\u63D6\u6709\u67DA\u6E67\u6D8C\u7336\u7337\u7531\u7950\u88D5\u8A98\u904A\u9091\u90F5\u96C4\u878D\u5915\u4E88\u4F59\u4E0E\u8A89\u8F3F\u9810\u50AD\u5E7C\u5996\u5BB9\u5EB8\u63DA\u63FA\u64C1\u66DC\u694A\u69D8\u6D0B\u6EB6\u7194\u7528\u7AAF\u7F8A\u8000\u8449\u84C9\u8981\u8B21\u8E0A\u9065\u967D\u990A\u617E\u6291\u6B32"],
    ["9780", "\u6C83\u6D74\u7FCC\u7FFC\u6DC0\u7F85\u87BA\u88F8\u6765\u83B1\u983C\u96F7\u6D1B\u7D61\u843D\u916A\u4E71\u5375\u5D50\u6B04\u6FEB\u85CD\u862D\u89A7\u5229\u540F\u5C65\u674E\u68A8\u7406\u7483\u75E2\u88CF\u88E1\u91CC\u96E2\u9678\u5F8B\u7387\u7ACB\u844E\u63A0\u7565\u5289\u6D41\u6E9C\u7409\u7559\u786B\u7C92\u9686\u7ADC\u9F8D\u4FB6\u616E\u65C5\u865C\u4E86\u4EAE\u50DA\u4E21\u51CC\u5BEE\u6599\u6881\u6DBC\u731F\u7642\u77AD\u7A1C\u7CE7\u826F\u8AD2\u907C\u91CF\u9675\u9818\u529B\u7DD1\u502B\u5398\u6797\u6DCB\u71D0\u7433\u81E8\u8F2A\u96A3\u9C57\u9E9F\u7460\u5841\u6D99\u7D2F\u985E\u4EE4\u4F36\u4F8B\u51B7\u52B1\u5DBA\u601C\u73B2\u793C\u82D3\u9234\u96B7\u96F6\u970A\u9E97\u9F62\u66A6\u6B74\u5217\u52A3\u70C8\u88C2\u5EC9\u604B\u6190\u6F23\u7149\u7C3E\u7DF4\u806F"],
    ["9840", "\u84EE\u9023\u932C\u5442\u9B6F\u6AD3\u7089\u8CC2\u8DEF\u9732\u52B4\u5A41\u5ECA\u5F04\u6717\u697C\u6994\u6D6A\u6F0F\u7262\u72FC\u7BED\u8001\u807E\u874B\u90CE\u516D\u9E93\u7984\u808B\u9332\u8AD6\u502D\u548C\u8A71\u6B6A\u8CC4\u8107\u60D1\u67A0\u9DF2\u4E99\u4E98\u9C10\u8A6B\u85C1\u8568\u6900\u6E7E\u7897\u8155"],
    ["989f", "\u5F0C\u4E10\u4E15\u4E2A\u4E31\u4E36\u4E3C\u4E3F\u4E42\u4E56\u4E58\u4E82\u4E85\u8C6B\u4E8A\u8212\u5F0D\u4E8E\u4E9E\u4E9F\u4EA0\u4EA2\u4EB0\u4EB3\u4EB6\u4ECE\u4ECD\u4EC4\u4EC6\u4EC2\u4ED7\u4EDE\u4EED\u4EDF\u4EF7\u4F09\u4F5A\u4F30\u4F5B\u4F5D\u4F57\u4F47\u4F76\u4F88\u4F8F\u4F98\u4F7B\u4F69\u4F70\u4F91\u4F6F\u4F86\u4F96\u5118\u4FD4\u4FDF\u4FCE\u4FD8\u4FDB\u4FD1\u4FDA\u4FD0\u4FE4\u4FE5\u501A\u5028\u5014\u502A\u5025\u5005\u4F1C\u4FF6\u5021\u5029\u502C\u4FFE\u4FEF\u5011\u5006\u5043\u5047\u6703\u5055\u5050\u5048\u505A\u5056\u506C\u5078\u5080\u509A\u5085\u50B4\u50B2"],
    ["9940", "\u50C9\u50CA\u50B3\u50C2\u50D6\u50DE\u50E5\u50ED\u50E3\u50EE\u50F9\u50F5\u5109\u5101\u5102\u5116\u5115\u5114\u511A\u5121\u513A\u5137\u513C\u513B\u513F\u5140\u5152\u514C\u5154\u5162\u7AF8\u5169\u516A\u516E\u5180\u5182\u56D8\u518C\u5189\u518F\u5191\u5193\u5195\u5196\u51A4\u51A6\u51A2\u51A9\u51AA\u51AB\u51B3\u51B1\u51B2\u51B0\u51B5\u51BD\u51C5\u51C9\u51DB\u51E0\u8655\u51E9\u51ED"],
    ["9980", "\u51F0\u51F5\u51FE\u5204\u520B\u5214\u520E\u5227\u522A\u522E\u5233\u5239\u524F\u5244\u524B\u524C\u525E\u5254\u526A\u5274\u5269\u5273\u527F\u527D\u528D\u5294\u5292\u5271\u5288\u5291\u8FA8\u8FA7\u52AC\u52AD\u52BC\u52B5\u52C1\u52CD\u52D7\u52DE\u52E3\u52E6\u98ED\u52E0\u52F3\u52F5\u52F8\u52F9\u5306\u5308\u7538\u530D\u5310\u530F\u5315\u531A\u5323\u532F\u5331\u5333\u5338\u5340\u5346\u5345\u4E17\u5349\u534D\u51D6\u535E\u5369\u536E\u5918\u537B\u5377\u5382\u5396\u53A0\u53A6\u53A5\u53AE\u53B0\u53B6\u53C3\u7C12\u96D9\u53DF\u66FC\u71EE\u53EE\u53E8\u53ED\u53FA\u5401\u543D\u5440\u542C\u542D\u543C\u542E\u5436\u5429\u541D\u544E\u548F\u5475\u548E\u545F\u5471\u5477\u5470\u5492\u547B\u5480\u5476\u5484\u5490\u5486\u54C7\u54A2\u54B8\u54A5\u54AC\u54C4\u54C8\u54A8"],
    ["9a40", "\u54AB\u54C2\u54A4\u54BE\u54BC\u54D8\u54E5\u54E6\u550F\u5514\u54FD\u54EE\u54ED\u54FA\u54E2\u5539\u5540\u5563\u554C\u552E\u555C\u5545\u5556\u5557\u5538\u5533\u555D\u5599\u5580\u54AF\u558A\u559F\u557B\u557E\u5598\u559E\u55AE\u557C\u5583\u55A9\u5587\u55A8\u55DA\u55C5\u55DF\u55C4\u55DC\u55E4\u55D4\u5614\u55F7\u5616\u55FE\u55FD\u561B\u55F9\u564E\u5650\u71DF\u5634\u5636\u5632\u5638"],
    ["9a80", "\u566B\u5664\u562F\u566C\u566A\u5686\u5680\u568A\u56A0\u5694\u568F\u56A5\u56AE\u56B6\u56B4\u56C2\u56BC\u56C1\u56C3\u56C0\u56C8\u56CE\u56D1\u56D3\u56D7\u56EE\u56F9\u5700\u56FF\u5704\u5709\u5708\u570B\u570D\u5713\u5718\u5716\u55C7\u571C\u5726\u5737\u5738\u574E\u573B\u5740\u574F\u5769\u57C0\u5788\u5761\u577F\u5789\u5793\u57A0\u57B3\u57A4\u57AA\u57B0\u57C3\u57C6\u57D4\u57D2\u57D3\u580A\u57D6\u57E3\u580B\u5819\u581D\u5872\u5821\u5862\u584B\u5870\u6BC0\u5852\u583D\u5879\u5885\u58B9\u589F\u58AB\u58BA\u58DE\u58BB\u58B8\u58AE\u58C5\u58D3\u58D1\u58D7\u58D9\u58D8\u58E5\u58DC\u58E4\u58DF\u58EF\u58FA\u58F9\u58FB\u58FC\u58FD\u5902\u590A\u5910\u591B\u68A6\u5925\u592C\u592D\u5932\u5938\u593E\u7AD2\u5955\u5950\u594E\u595A\u5958\u5962\u5960\u5967\u596C\u5969"],
    ["9b40", "\u5978\u5981\u599D\u4F5E\u4FAB\u59A3\u59B2\u59C6\u59E8\u59DC\u598D\u59D9\u59DA\u5A25\u5A1F\u5A11\u5A1C\u5A09\u5A1A\u5A40\u5A6C\u5A49\u5A35\u5A36\u5A62\u5A6A\u5A9A\u5ABC\u5ABE\u5ACB\u5AC2\u5ABD\u5AE3\u5AD7\u5AE6\u5AE9\u5AD6\u5AFA\u5AFB\u5B0C\u5B0B\u5B16\u5B32\u5AD0\u5B2A\u5B36\u5B3E\u5B43\u5B45\u5B40\u5B51\u5B55\u5B5A\u5B5B\u5B65\u5B69\u5B70\u5B73\u5B75\u5B78\u6588\u5B7A\u5B80"],
    ["9b80", "\u5B83\u5BA6\u5BB8\u5BC3\u5BC7\u5BC9\u5BD4\u5BD0\u5BE4\u5BE6\u5BE2\u5BDE\u5BE5\u5BEB\u5BF0\u5BF6\u5BF3\u5C05\u5C07\u5C08\u5C0D\u5C13\u5C20\u5C22\u5C28\u5C38\u5C39\u5C41\u5C46\u5C4E\u5C53\u5C50\u5C4F\u5B71\u5C6C\u5C6E\u4E62\u5C76\u5C79\u5C8C\u5C91\u5C94\u599B\u5CAB\u5CBB\u5CB6\u5CBC\u5CB7\u5CC5\u5CBE\u5CC7\u5CD9\u5CE9\u5CFD\u5CFA\u5CED\u5D8C\u5CEA\u5D0B\u5D15\u5D17\u5D5C\u5D1F\u5D1B\u5D11\u5D14\u5D22\u5D1A\u5D19\u5D18\u5D4C\u5D52\u5D4E\u5D4B\u5D6C\u5D73\u5D76\u5D87\u5D84\u5D82\u5DA2\u5D9D\u5DAC\u5DAE\u5DBD\u5D90\u5DB7\u5DBC\u5DC9\u5DCD\u5DD3\u5DD2\u5DD6\u5DDB\u5DEB\u5DF2\u5DF5\u5E0B\u5E1A\u5E19\u5E11\u5E1B\u5E36\u5E37\u5E44\u5E43\u5E40\u5E4E\u5E57\u5E54\u5E5F\u5E62\u5E64\u5E47\u5E75\u5E76\u5E7A\u9EBC\u5E7F\u5EA0\u5EC1\u5EC2\u5EC8\u5ED0\u5ECF"],
    ["9c40", "\u5ED6\u5EE3\u5EDD\u5EDA\u5EDB\u5EE2\u5EE1\u5EE8\u5EE9\u5EEC\u5EF1\u5EF3\u5EF0\u5EF4\u5EF8\u5EFE\u5F03\u5F09\u5F5D\u5F5C\u5F0B\u5F11\u5F16\u5F29\u5F2D\u5F38\u5F41\u5F48\u5F4C\u5F4E\u5F2F\u5F51\u5F56\u5F57\u5F59\u5F61\u5F6D\u5F73\u5F77\u5F83\u5F82\u5F7F\u5F8A\u5F88\u5F91\u5F87\u5F9E\u5F99\u5F98\u5FA0\u5FA8\u5FAD\u5FBC\u5FD6\u5FFB\u5FE4\u5FF8\u5FF1\u5FDD\u60B3\u5FFF\u6021\u6060"],
    ["9c80", "\u6019\u6010\u6029\u600E\u6031\u601B\u6015\u602B\u6026\u600F\u603A\u605A\u6041\u606A\u6077\u605F\u604A\u6046\u604D\u6063\u6043\u6064\u6042\u606C\u606B\u6059\u6081\u608D\u60E7\u6083\u609A\u6084\u609B\u6096\u6097\u6092\u60A7\u608B\u60E1\u60B8\u60E0\u60D3\u60B4\u5FF0\u60BD\u60C6\u60B5\u60D8\u614D\u6115\u6106\u60F6\u60F7\u6100\u60F4\u60FA\u6103\u6121\u60FB\u60F1\u610D\u610E\u6147\u613E\u6128\u6127\u614A\u613F\u613C\u612C\u6134\u613D\u6142\u6144\u6173\u6177\u6158\u6159\u615A\u616B\u6174\u616F\u6165\u6171\u615F\u615D\u6153\u6175\u6199\u6196\u6187\u61AC\u6194\u619A\u618A\u6191\u61AB\u61AE\u61CC\u61CA\u61C9\u61F7\u61C8\u61C3\u61C6\u61BA\u61CB\u7F79\u61CD\u61E6\u61E3\u61F6\u61FA\u61F4\u61FF\u61FD\u61FC\u61FE\u6200\u6208\u6209\u620D\u620C\u6214\u621B"],
    ["9d40", "\u621E\u6221\u622A\u622E\u6230\u6232\u6233\u6241\u624E\u625E\u6263\u625B\u6260\u6268\u627C\u6282\u6289\u627E\u6292\u6293\u6296\u62D4\u6283\u6294\u62D7\u62D1\u62BB\u62CF\u62FF\u62C6\u64D4\u62C8\u62DC\u62CC\u62CA\u62C2\u62C7\u629B\u62C9\u630C\u62EE\u62F1\u6327\u6302\u6308\u62EF\u62F5\u6350\u633E\u634D\u641C\u634F\u6396\u638E\u6380\u63AB\u6376\u63A3\u638F\u6389\u639F\u63B5\u636B"],
    ["9d80", "\u6369\u63BE\u63E9\u63C0\u63C6\u63E3\u63C9\u63D2\u63F6\u63C4\u6416\u6434\u6406\u6413\u6426\u6436\u651D\u6417\u6428\u640F\u6467\u646F\u6476\u644E\u652A\u6495\u6493\u64A5\u64A9\u6488\u64BC\u64DA\u64D2\u64C5\u64C7\u64BB\u64D8\u64C2\u64F1\u64E7\u8209\u64E0\u64E1\u62AC\u64E3\u64EF\u652C\u64F6\u64F4\u64F2\u64FA\u6500\u64FD\u6518\u651C\u6505\u6524\u6523\u652B\u6534\u6535\u6537\u6536\u6538\u754B\u6548\u6556\u6555\u654D\u6558\u655E\u655D\u6572\u6578\u6582\u6583\u8B8A\u659B\u659F\u65AB\u65B7\u65C3\u65C6\u65C1\u65C4\u65CC\u65D2\u65DB\u65D9\u65E0\u65E1\u65F1\u6772\u660A\u6603\u65FB\u6773\u6635\u6636\u6634\u661C\u664F\u6644\u6649\u6641\u665E\u665D\u6664\u6667\u6668\u665F\u6662\u6670\u6683\u6688\u668E\u6689\u6684\u6698\u669D\u66C1\u66B9\u66C9\u66BE\u66BC"],
    ["9e40", "\u66C4\u66B8\u66D6\u66DA\u66E0\u663F\u66E6\u66E9\u66F0\u66F5\u66F7\u670F\u6716\u671E\u6726\u6727\u9738\u672E\u673F\u6736\u6741\u6738\u6737\u6746\u675E\u6760\u6759\u6763\u6764\u6789\u6770\u67A9\u677C\u676A\u678C\u678B\u67A6\u67A1\u6785\u67B7\u67EF\u67B4\u67EC\u67B3\u67E9\u67B8\u67E4\u67DE\u67DD\u67E2\u67EE\u67B9\u67CE\u67C6\u67E7\u6A9C\u681E\u6846\u6829\u6840\u684D\u6832\u684E"],
    ["9e80", "\u68B3\u682B\u6859\u6863\u6877\u687F\u689F\u688F\u68AD\u6894\u689D\u689B\u6883\u6AAE\u68B9\u6874\u68B5\u68A0\u68BA\u690F\u688D\u687E\u6901\u68CA\u6908\u68D8\u6922\u6926\u68E1\u690C\u68CD\u68D4\u68E7\u68D5\u6936\u6912\u6904\u68D7\u68E3\u6925\u68F9\u68E0\u68EF\u6928\u692A\u691A\u6923\u6921\u68C6\u6979\u6977\u695C\u6978\u696B\u6954\u697E\u696E\u6939\u6974\u693D\u6959\u6930\u6961\u695E\u695D\u6981\u696A\u69B2\u69AE\u69D0\u69BF\u69C1\u69D3\u69BE\u69CE\u5BE8\u69CA\u69DD\u69BB\u69C3\u69A7\u6A2E\u6991\u69A0\u699C\u6995\u69B4\u69DE\u69E8\u6A02\u6A1B\u69FF\u6B0A\u69F9\u69F2\u69E7\u6A05\u69B1\u6A1E\u69ED\u6A14\u69EB\u6A0A\u6A12\u6AC1\u6A23\u6A13\u6A44\u6A0C\u6A72\u6A36\u6A78\u6A47\u6A62\u6A59\u6A66\u6A48\u6A38\u6A22\u6A90\u6A8D\u6AA0\u6A84\u6AA2\u6AA3"],
    ["9f40", "\u6A97\u8617\u6ABB\u6AC3\u6AC2\u6AB8\u6AB3\u6AAC\u6ADE\u6AD1\u6ADF\u6AAA\u6ADA\u6AEA\u6AFB\u6B05\u8616\u6AFA\u6B12\u6B16\u9B31\u6B1F\u6B38\u6B37\u76DC\u6B39\u98EE\u6B47\u6B43\u6B49\u6B50\u6B59\u6B54\u6B5B\u6B5F\u6B61\u6B78\u6B79\u6B7F\u6B80\u6B84\u6B83\u6B8D\u6B98\u6B95\u6B9E\u6BA4\u6BAA\u6BAB\u6BAF\u6BB2\u6BB1\u6BB3\u6BB7\u6BBC\u6BC6\u6BCB\u6BD3\u6BDF\u6BEC\u6BEB\u6BF3\u6BEF"],
    ["9f80", "\u9EBE\u6C08\u6C13\u6C14\u6C1B\u6C24\u6C23\u6C5E\u6C55\u6C62\u6C6A\u6C82\u6C8D\u6C9A\u6C81\u6C9B\u6C7E\u6C68\u6C73\u6C92\u6C90\u6CC4\u6CF1\u6CD3\u6CBD\u6CD7\u6CC5\u6CDD\u6CAE\u6CB1\u6CBE\u6CBA\u6CDB\u6CEF\u6CD9\u6CEA\u6D1F\u884D\u6D36\u6D2B\u6D3D\u6D38\u6D19\u6D35\u6D33\u6D12\u6D0C\u6D63\u6D93\u6D64\u6D5A\u6D79\u6D59\u6D8E\u6D95\u6FE4\u6D85\u6DF9\u6E15\u6E0A\u6DB5\u6DC7\u6DE6\u6DB8\u6DC6\u6DEC\u6DDE\u6DCC\u6DE8\u6DD2\u6DC5\u6DFA\u6DD9\u6DE4\u6DD5\u6DEA\u6DEE\u6E2D\u6E6E\u6E2E\u6E19\u6E72\u6E5F\u6E3E\u6E23\u6E6B\u6E2B\u6E76\u6E4D\u6E1F\u6E43\u6E3A\u6E4E\u6E24\u6EFF\u6E1D\u6E38\u6E82\u6EAA\u6E98\u6EC9\u6EB7\u6ED3\u6EBD\u6EAF\u6EC4\u6EB2\u6ED4\u6ED5\u6E8F\u6EA5\u6EC2\u6E9F\u6F41\u6F11\u704C\u6EEC\u6EF8\u6EFE\u6F3F\u6EF2\u6F31\u6EEF\u6F32\u6ECC"],
    ["e040", "\u6F3E\u6F13\u6EF7\u6F86\u6F7A\u6F78\u6F81\u6F80\u6F6F\u6F5B\u6FF3\u6F6D\u6F82\u6F7C\u6F58\u6F8E\u6F91\u6FC2\u6F66\u6FB3\u6FA3\u6FA1\u6FA4\u6FB9\u6FC6\u6FAA\u6FDF\u6FD5\u6FEC\u6FD4\u6FD8\u6FF1\u6FEE\u6FDB\u7009\u700B\u6FFA\u7011\u7001\u700F\u6FFE\u701B\u701A\u6F74\u701D\u7018\u701F\u7030\u703E\u7032\u7051\u7063\u7099\u7092\u70AF\u70F1\u70AC\u70B8\u70B3\u70AE\u70DF\u70CB\u70DD"],
    ["e080", "\u70D9\u7109\u70FD\u711C\u7119\u7165\u7155\u7188\u7166\u7162\u714C\u7156\u716C\u718F\u71FB\u7184\u7195\u71A8\u71AC\u71D7\u71B9\u71BE\u71D2\u71C9\u71D4\u71CE\u71E0\u71EC\u71E7\u71F5\u71FC\u71F9\u71FF\u720D\u7210\u721B\u7228\u722D\u722C\u7230\u7232\u723B\u723C\u723F\u7240\u7246\u724B\u7258\u7274\u727E\u7282\u7281\u7287\u7292\u7296\u72A2\u72A7\u72B9\u72B2\u72C3\u72C6\u72C4\u72CE\u72D2\u72E2\u72E0\u72E1\u72F9\u72F7\u500F\u7317\u730A\u731C\u7316\u731D\u7334\u732F\u7329\u7325\u733E\u734E\u734F\u9ED8\u7357\u736A\u7368\u7370\u7378\u7375\u737B\u737A\u73C8\u73B3\u73CE\u73BB\u73C0\u73E5\u73EE\u73DE\u74A2\u7405\u746F\u7425\u73F8\u7432\u743A\u7455\u743F\u745F\u7459\u7441\u745C\u7469\u7470\u7463\u746A\u7476\u747E\u748B\u749E\u74A7\u74CA\u74CF\u74D4\u73F1"],
    ["e140", "\u74E0\u74E3\u74E7\u74E9\u74EE\u74F2\u74F0\u74F1\u74F8\u74F7\u7504\u7503\u7505\u750C\u750E\u750D\u7515\u7513\u751E\u7526\u752C\u753C\u7544\u754D\u754A\u7549\u755B\u7546\u755A\u7569\u7564\u7567\u756B\u756D\u7578\u7576\u7586\u7587\u7574\u758A\u7589\u7582\u7594\u759A\u759D\u75A5\u75A3\u75C2\u75B3\u75C3\u75B5\u75BD\u75B8\u75BC\u75B1\u75CD\u75CA\u75D2\u75D9\u75E3\u75DE\u75FE\u75FF"],
    ["e180", "\u75FC\u7601\u75F0\u75FA\u75F2\u75F3\u760B\u760D\u7609\u761F\u7627\u7620\u7621\u7622\u7624\u7634\u7630\u763B\u7647\u7648\u7646\u765C\u7658\u7661\u7662\u7668\u7669\u766A\u7667\u766C\u7670\u7672\u7676\u7678\u767C\u7680\u7683\u7688\u768B\u768E\u7696\u7693\u7699\u769A\u76B0\u76B4\u76B8\u76B9\u76BA\u76C2\u76CD\u76D6\u76D2\u76DE\u76E1\u76E5\u76E7\u76EA\u862F\u76FB\u7708\u7707\u7704\u7729\u7724\u771E\u7725\u7726\u771B\u7737\u7738\u7747\u775A\u7768\u776B\u775B\u7765\u777F\u777E\u7779\u778E\u778B\u7791\u77A0\u779E\u77B0\u77B6\u77B9\u77BF\u77BC\u77BD\u77BB\u77C7\u77CD\u77D7\u77DA\u77DC\u77E3\u77EE\u77FC\u780C\u7812\u7926\u7820\u792A\u7845\u788E\u7874\u7886\u787C\u789A\u788C\u78A3\u78B5\u78AA\u78AF\u78D1\u78C6\u78CB\u78D4\u78BE\u78BC\u78C5\u78CA\u78EC"],
    ["e240", "\u78E7\u78DA\u78FD\u78F4\u7907\u7912\u7911\u7919\u792C\u792B\u7940\u7960\u7957\u795F\u795A\u7955\u7953\u797A\u797F\u798A\u799D\u79A7\u9F4B\u79AA\u79AE\u79B3\u79B9\u79BA\u79C9\u79D5\u79E7\u79EC\u79E1\u79E3\u7A08\u7A0D\u7A18\u7A19\u7A20\u7A1F\u7980\u7A31\u7A3B\u7A3E\u7A37\u7A43\u7A57\u7A49\u7A61\u7A62\u7A69\u9F9D\u7A70\u7A79\u7A7D\u7A88\u7A97\u7A95\u7A98\u7A96\u7AA9\u7AC8\u7AB0"],
    ["e280", "\u7AB6\u7AC5\u7AC4\u7ABF\u9083\u7AC7\u7ACA\u7ACD\u7ACF\u7AD5\u7AD3\u7AD9\u7ADA\u7ADD\u7AE1\u7AE2\u7AE6\u7AED\u7AF0\u7B02\u7B0F\u7B0A\u7B06\u7B33\u7B18\u7B19\u7B1E\u7B35\u7B28\u7B36\u7B50\u7B7A\u7B04\u7B4D\u7B0B\u7B4C\u7B45\u7B75\u7B65\u7B74\u7B67\u7B70\u7B71\u7B6C\u7B6E\u7B9D\u7B98\u7B9F\u7B8D\u7B9C\u7B9A\u7B8B\u7B92\u7B8F\u7B5D\u7B99\u7BCB\u7BC1\u7BCC\u7BCF\u7BB4\u7BC6\u7BDD\u7BE9\u7C11\u7C14\u7BE6\u7BE5\u7C60\u7C00\u7C07\u7C13\u7BF3\u7BF7\u7C17\u7C0D\u7BF6\u7C23\u7C27\u7C2A\u7C1F\u7C37\u7C2B\u7C3D\u7C4C\u7C43\u7C54\u7C4F\u7C40\u7C50\u7C58\u7C5F\u7C64\u7C56\u7C65\u7C6C\u7C75\u7C83\u7C90\u7CA4\u7CAD\u7CA2\u7CAB\u7CA1\u7CA8\u7CB3\u7CB2\u7CB1\u7CAE\u7CB9\u7CBD\u7CC0\u7CC5\u7CC2\u7CD8\u7CD2\u7CDC\u7CE2\u9B3B\u7CEF\u7CF2\u7CF4\u7CF6\u7CFA\u7D06"],
    ["e340", "\u7D02\u7D1C\u7D15\u7D0A\u7D45\u7D4B\u7D2E\u7D32\u7D3F\u7D35\u7D46\u7D73\u7D56\u7D4E\u7D72\u7D68\u7D6E\u7D4F\u7D63\u7D93\u7D89\u7D5B\u7D8F\u7D7D\u7D9B\u7DBA\u7DAE\u7DA3\u7DB5\u7DC7\u7DBD\u7DAB\u7E3D\u7DA2\u7DAF\u7DDC\u7DB8\u7D9F\u7DB0\u7DD8\u7DDD\u7DE4\u7DDE\u7DFB\u7DF2\u7DE1\u7E05\u7E0A\u7E23\u7E21\u7E12\u7E31\u7E1F\u7E09\u7E0B\u7E22\u7E46\u7E66\u7E3B\u7E35\u7E39\u7E43\u7E37"],
    ["e380", "\u7E32\u7E3A\u7E67\u7E5D\u7E56\u7E5E\u7E59\u7E5A\u7E79\u7E6A\u7E69\u7E7C\u7E7B\u7E83\u7DD5\u7E7D\u8FAE\u7E7F\u7E88\u7E89\u7E8C\u7E92\u7E90\u7E93\u7E94\u7E96\u7E8E\u7E9B\u7E9C\u7F38\u7F3A\u7F45\u7F4C\u7F4D\u7F4E\u7F50\u7F51\u7F55\u7F54\u7F58\u7F5F\u7F60\u7F68\u7F69\u7F67\u7F78\u7F82\u7F86\u7F83\u7F88\u7F87\u7F8C\u7F94\u7F9E\u7F9D\u7F9A\u7FA3\u7FAF\u7FB2\u7FB9\u7FAE\u7FB6\u7FB8\u8B71\u7FC5\u7FC6\u7FCA\u7FD5\u7FD4\u7FE1\u7FE6\u7FE9\u7FF3\u7FF9\u98DC\u8006\u8004\u800B\u8012\u8018\u8019\u801C\u8021\u8028\u803F\u803B\u804A\u8046\u8052\u8058\u805A\u805F\u8062\u8068\u8073\u8072\u8070\u8076\u8079\u807D\u807F\u8084\u8086\u8085\u809B\u8093\u809A\u80AD\u5190\u80AC\u80DB\u80E5\u80D9\u80DD\u80C4\u80DA\u80D6\u8109\u80EF\u80F1\u811B\u8129\u8123\u812F\u814B"],
    ["e440", "\u968B\u8146\u813E\u8153\u8151\u80FC\u8171\u816E\u8165\u8166\u8174\u8183\u8188\u818A\u8180\u8182\u81A0\u8195\u81A4\u81A3\u815F\u8193\u81A9\u81B0\u81B5\u81BE\u81B8\u81BD\u81C0\u81C2\u81BA\u81C9\u81CD\u81D1\u81D9\u81D8\u81C8\u81DA\u81DF\u81E0\u81E7\u81FA\u81FB\u81FE\u8201\u8202\u8205\u8207\u820A\u820D\u8210\u8216\u8229\u822B\u8238\u8233\u8240\u8259\u8258\u825D\u825A\u825F\u8264"],
    ["e480", "\u8262\u8268\u826A\u826B\u822E\u8271\u8277\u8278\u827E\u828D\u8292\u82AB\u829F\u82BB\u82AC\u82E1\u82E3\u82DF\u82D2\u82F4\u82F3\u82FA\u8393\u8303\u82FB\u82F9\u82DE\u8306\u82DC\u8309\u82D9\u8335\u8334\u8316\u8332\u8331\u8340\u8339\u8350\u8345\u832F\u832B\u8317\u8318\u8385\u839A\u83AA\u839F\u83A2\u8396\u8323\u838E\u8387\u838A\u837C\u83B5\u8373\u8375\u83A0\u8389\u83A8\u83F4\u8413\u83EB\u83CE\u83FD\u8403\u83D8\u840B\u83C1\u83F7\u8407\u83E0\u83F2\u840D\u8422\u8420\u83BD\u8438\u8506\u83FB\u846D\u842A\u843C\u855A\u8484\u8477\u846B\u84AD\u846E\u8482\u8469\u8446\u842C\u846F\u8479\u8435\u84CA\u8462\u84B9\u84BF\u849F\u84D9\u84CD\u84BB\u84DA\u84D0\u84C1\u84C6\u84D6\u84A1\u8521\u84FF\u84F4\u8517\u8518\u852C\u851F\u8515\u8514\u84FC\u8540\u8563\u8558\u8548"],
    ["e540", "\u8541\u8602\u854B\u8555\u8580\u85A4\u8588\u8591\u858A\u85A8\u856D\u8594\u859B\u85EA\u8587\u859C\u8577\u857E\u8590\u85C9\u85BA\u85CF\u85B9\u85D0\u85D5\u85DD\u85E5\u85DC\u85F9\u860A\u8613\u860B\u85FE\u85FA\u8606\u8622\u861A\u8630\u863F\u864D\u4E55\u8654\u865F\u8667\u8671\u8693\u86A3\u86A9\u86AA\u868B\u868C\u86B6\u86AF\u86C4\u86C6\u86B0\u86C9\u8823\u86AB\u86D4\u86DE\u86E9\u86EC"],
    ["e580", "\u86DF\u86DB\u86EF\u8712\u8706\u8708\u8700\u8703\u86FB\u8711\u8709\u870D\u86F9\u870A\u8734\u873F\u8737\u873B\u8725\u8729\u871A\u8760\u875F\u8778\u874C\u874E\u8774\u8757\u8768\u876E\u8759\u8753\u8763\u876A\u8805\u87A2\u879F\u8782\u87AF\u87CB\u87BD\u87C0\u87D0\u96D6\u87AB\u87C4\u87B3\u87C7\u87C6\u87BB\u87EF\u87F2\u87E0\u880F\u880D\u87FE\u87F6\u87F7\u880E\u87D2\u8811\u8816\u8815\u8822\u8821\u8831\u8836\u8839\u8827\u883B\u8844\u8842\u8852\u8859\u885E\u8862\u886B\u8881\u887E\u889E\u8875\u887D\u88B5\u8872\u8882\u8897\u8892\u88AE\u8899\u88A2\u888D\u88A4\u88B0\u88BF\u88B1\u88C3\u88C4\u88D4\u88D8\u88D9\u88DD\u88F9\u8902\u88FC\u88F4\u88E8\u88F2\u8904\u890C\u890A\u8913\u8943\u891E\u8925\u892A\u892B\u8941\u8944\u893B\u8936\u8938\u894C\u891D\u8960\u895E"],
    ["e640", "\u8966\u8964\u896D\u896A\u896F\u8974\u8977\u897E\u8983\u8988\u898A\u8993\u8998\u89A1\u89A9\u89A6\u89AC\u89AF\u89B2\u89BA\u89BD\u89BF\u89C0\u89DA\u89DC\u89DD\u89E7\u89F4\u89F8\u8A03\u8A16\u8A10\u8A0C\u8A1B\u8A1D\u8A25\u8A36\u8A41\u8A5B\u8A52\u8A46\u8A48\u8A7C\u8A6D\u8A6C\u8A62\u8A85\u8A82\u8A84\u8AA8\u8AA1\u8A91\u8AA5\u8AA6\u8A9A\u8AA3\u8AC4\u8ACD\u8AC2\u8ADA\u8AEB\u8AF3\u8AE7"],
    ["e680", "\u8AE4\u8AF1\u8B14\u8AE0\u8AE2\u8AF7\u8ADE\u8ADB\u8B0C\u8B07\u8B1A\u8AE1\u8B16\u8B10\u8B17\u8B20\u8B33\u97AB\u8B26\u8B2B\u8B3E\u8B28\u8B41\u8B4C\u8B4F\u8B4E\u8B49\u8B56\u8B5B\u8B5A\u8B6B\u8B5F\u8B6C\u8B6F\u8B74\u8B7D\u8B80\u8B8C\u8B8E\u8B92\u8B93\u8B96\u8B99\u8B9A\u8C3A\u8C41\u8C3F\u8C48\u8C4C\u8C4E\u8C50\u8C55\u8C62\u8C6C\u8C78\u8C7A\u8C82\u8C89\u8C85\u8C8A\u8C8D\u8C8E\u8C94\u8C7C\u8C98\u621D\u8CAD\u8CAA\u8CBD\u8CB2\u8CB3\u8CAE\u8CB6\u8CC8\u8CC1\u8CE4\u8CE3\u8CDA\u8CFD\u8CFA\u8CFB\u8D04\u8D05\u8D0A\u8D07\u8D0F\u8D0D\u8D10\u9F4E\u8D13\u8CCD\u8D14\u8D16\u8D67\u8D6D\u8D71\u8D73\u8D81\u8D99\u8DC2\u8DBE\u8DBA\u8DCF\u8DDA\u8DD6\u8DCC\u8DDB\u8DCB\u8DEA\u8DEB\u8DDF\u8DE3\u8DFC\u8E08\u8E09\u8DFF\u8E1D\u8E1E\u8E10\u8E1F\u8E42\u8E35\u8E30\u8E34\u8E4A"],
    ["e740", "\u8E47\u8E49\u8E4C\u8E50\u8E48\u8E59\u8E64\u8E60\u8E2A\u8E63\u8E55\u8E76\u8E72\u8E7C\u8E81\u8E87\u8E85\u8E84\u8E8B\u8E8A\u8E93\u8E91\u8E94\u8E99\u8EAA\u8EA1\u8EAC\u8EB0\u8EC6\u8EB1\u8EBE\u8EC5\u8EC8\u8ECB\u8EDB\u8EE3\u8EFC\u8EFB\u8EEB\u8EFE\u8F0A\u8F05\u8F15\u8F12\u8F19\u8F13\u8F1C\u8F1F\u8F1B\u8F0C\u8F26\u8F33\u8F3B\u8F39\u8F45\u8F42\u8F3E\u8F4C\u8F49\u8F46\u8F4E\u8F57\u8F5C"],
    ["e780", "\u8F62\u8F63\u8F64\u8F9C\u8F9F\u8FA3\u8FAD\u8FAF\u8FB7\u8FDA\u8FE5\u8FE2\u8FEA\u8FEF\u9087\u8FF4\u9005\u8FF9\u8FFA\u9011\u9015\u9021\u900D\u901E\u9016\u900B\u9027\u9036\u9035\u9039\u8FF8\u904F\u9050\u9051\u9052\u900E\u9049\u903E\u9056\u9058\u905E\u9068\u906F\u9076\u96A8\u9072\u9082\u907D\u9081\u9080\u908A\u9089\u908F\u90A8\u90AF\u90B1\u90B5\u90E2\u90E4\u6248\u90DB\u9102\u9112\u9119\u9132\u9130\u914A\u9156\u9158\u9163\u9165\u9169\u9173\u9172\u918B\u9189\u9182\u91A2\u91AB\u91AF\u91AA\u91B5\u91B4\u91BA\u91C0\u91C1\u91C9\u91CB\u91D0\u91D6\u91DF\u91E1\u91DB\u91FC\u91F5\u91F6\u921E\u91FF\u9214\u922C\u9215\u9211\u925E\u9257\u9245\u9249\u9264\u9248\u9295\u923F\u924B\u9250\u929C\u9296\u9293\u929B\u925A\u92CF\u92B9\u92B7\u92E9\u930F\u92FA\u9344\u932E"],
    ["e840", "\u9319\u9322\u931A\u9323\u933A\u9335\u933B\u935C\u9360\u937C\u936E\u9356\u93B0\u93AC\u93AD\u9394\u93B9\u93D6\u93D7\u93E8\u93E5\u93D8\u93C3\u93DD\u93D0\u93C8\u93E4\u941A\u9414\u9413\u9403\u9407\u9410\u9436\u942B\u9435\u9421\u943A\u9441\u9452\u9444\u945B\u9460\u9462\u945E\u946A\u9229\u9470\u9475\u9477\u947D\u945A\u947C\u947E\u9481\u947F\u9582\u9587\u958A\u9594\u9596\u9598\u9599"],
    ["e880", "\u95A0\u95A8\u95A7\u95AD\u95BC\u95BB\u95B9\u95BE\u95CA\u6FF6\u95C3\u95CD\u95CC\u95D5\u95D4\u95D6\u95DC\u95E1\u95E5\u95E2\u9621\u9628\u962E\u962F\u9642\u964C\u964F\u964B\u9677\u965C\u965E\u965D\u965F\u9666\u9672\u966C\u968D\u9698\u9695\u9697\u96AA\u96A7\u96B1\u96B2\u96B0\u96B4\u96B6\u96B8\u96B9\u96CE\u96CB\u96C9\u96CD\u894D\u96DC\u970D\u96D5\u96F9\u9704\u9706\u9708\u9713\u970E\u9711\u970F\u9716\u9719\u9724\u972A\u9730\u9739\u973D\u973E\u9744\u9746\u9748\u9742\u9749\u975C\u9760\u9764\u9766\u9768\u52D2\u976B\u9771\u9779\u9785\u977C\u9781\u977A\u9786\u978B\u978F\u9790\u979C\u97A8\u97A6\u97A3\u97B3\u97B4\u97C3\u97C6\u97C8\u97CB\u97DC\u97ED\u9F4F\u97F2\u7ADF\u97F6\u97F5\u980F\u980C\u9838\u9824\u9821\u9837\u983D\u9846\u984F\u984B\u986B\u986F\u9870"],
    ["e940", "\u9871\u9874\u9873\u98AA\u98AF\u98B1\u98B6\u98C4\u98C3\u98C6\u98E9\u98EB\u9903\u9909\u9912\u9914\u9918\u9921\u991D\u991E\u9924\u9920\u992C\u992E\u993D\u993E\u9942\u9949\u9945\u9950\u994B\u9951\u9952\u994C\u9955\u9997\u9998\u99A5\u99AD\u99AE\u99BC\u99DF\u99DB\u99DD\u99D8\u99D1\u99ED\u99EE\u99F1\u99F2\u99FB\u99F8\u9A01\u9A0F\u9A05\u99E2\u9A19\u9A2B\u9A37\u9A45\u9A42\u9A40\u9A43"],
    ["e980", "\u9A3E\u9A55\u9A4D\u9A5B\u9A57\u9A5F\u9A62\u9A65\u9A64\u9A69\u9A6B\u9A6A\u9AAD\u9AB0\u9ABC\u9AC0\u9ACF\u9AD1\u9AD3\u9AD4\u9ADE\u9ADF\u9AE2\u9AE3\u9AE6\u9AEF\u9AEB\u9AEE\u9AF4\u9AF1\u9AF7\u9AFB\u9B06\u9B18\u9B1A\u9B1F\u9B22\u9B23\u9B25\u9B27\u9B28\u9B29\u9B2A\u9B2E\u9B2F\u9B32\u9B44\u9B43\u9B4F\u9B4D\u9B4E\u9B51\u9B58\u9B74\u9B93\u9B83\u9B91\u9B96\u9B97\u9B9F\u9BA0\u9BA8\u9BB4\u9BC0\u9BCA\u9BB9\u9BC6\u9BCF\u9BD1\u9BD2\u9BE3\u9BE2\u9BE4\u9BD4\u9BE1\u9C3A\u9BF2\u9BF1\u9BF0\u9C15\u9C14\u9C09\u9C13\u9C0C\u9C06\u9C08\u9C12\u9C0A\u9C04\u9C2E\u9C1B\u9C25\u9C24\u9C21\u9C30\u9C47\u9C32\u9C46\u9C3E\u9C5A\u9C60\u9C67\u9C76\u9C78\u9CE7\u9CEC\u9CF0\u9D09\u9D08\u9CEB\u9D03\u9D06\u9D2A\u9D26\u9DAF\u9D23\u9D1F\u9D44\u9D15\u9D12\u9D41\u9D3F\u9D3E\u9D46\u9D48"],
    ["ea40", "\u9D5D\u9D5E\u9D64\u9D51\u9D50\u9D59\u9D72\u9D89\u9D87\u9DAB\u9D6F\u9D7A\u9D9A\u9DA4\u9DA9\u9DB2\u9DC4\u9DC1\u9DBB\u9DB8\u9DBA\u9DC6\u9DCF\u9DC2\u9DD9\u9DD3\u9DF8\u9DE6\u9DED\u9DEF\u9DFD\u9E1A\u9E1B\u9E1E\u9E75\u9E79\u9E7D\u9E81\u9E88\u9E8B\u9E8C\u9E92\u9E95\u9E91\u9E9D\u9EA5\u9EA9\u9EB8\u9EAA\u9EAD\u9761\u9ECC\u9ECE\u9ECF\u9ED0\u9ED4\u9EDC\u9EDE\u9EDD\u9EE0\u9EE5\u9EE8\u9EEF"],
    ["ea80", "\u9EF4\u9EF6\u9EF7\u9EF9\u9EFB\u9EFC\u9EFD\u9F07\u9F08\u76B7\u9F15\u9F21\u9F2C\u9F3E\u9F4A\u9F52\u9F54\u9F63\u9F5F\u9F60\u9F61\u9F66\u9F67\u9F6C\u9F6A\u9F77\u9F72\u9F76\u9F95\u9F9C\u9FA0\u582F\u69C7\u9059\u7464\u51DC\u7199"],
    ["ed40", "\u7E8A\u891C\u9348\u9288\u84DC\u4FC9\u70BB\u6631\u68C8\u92F9\u66FB\u5F45\u4E28\u4EE1\u4EFC\u4F00\u4F03\u4F39\u4F56\u4F92\u4F8A\u4F9A\u4F94\u4FCD\u5040\u5022\u4FFF\u501E\u5046\u5070\u5042\u5094\u50F4\u50D8\u514A\u5164\u519D\u51BE\u51EC\u5215\u529C\u52A6\u52C0\u52DB\u5300\u5307\u5324\u5372\u5393\u53B2\u53DD\uFA0E\u549C\u548A\u54A9\u54FF\u5586\u5759\u5765\u57AC\u57C8\u57C7\uFA0F"],
    ["ed80", "\uFA10\u589E\u58B2\u590B\u5953\u595B\u595D\u5963\u59A4\u59BA\u5B56\u5BC0\u752F\u5BD8\u5BEC\u5C1E\u5CA6\u5CBA\u5CF5\u5D27\u5D53\uFA11\u5D42\u5D6D\u5DB8\u5DB9\u5DD0\u5F21\u5F34\u5F67\u5FB7\u5FDE\u605D\u6085\u608A\u60DE\u60D5\u6120\u60F2\u6111\u6137\u6130\u6198\u6213\u62A6\u63F5\u6460\u649D\u64CE\u654E\u6600\u6615\u663B\u6609\u662E\u661E\u6624\u6665\u6657\u6659\uFA12\u6673\u6699\u66A0\u66B2\u66BF\u66FA\u670E\uF929\u6766\u67BB\u6852\u67C0\u6801\u6844\u68CF\uFA13\u6968\uFA14\u6998\u69E2\u6A30\u6A6B\u6A46\u6A73\u6A7E\u6AE2\u6AE4\u6BD6\u6C3F\u6C5C\u6C86\u6C6F\u6CDA\u6D04\u6D87\u6D6F\u6D96\u6DAC\u6DCF\u6DF8\u6DF2\u6DFC\u6E39\u6E5C\u6E27\u6E3C\u6EBF\u6F88\u6FB5\u6FF5\u7005\u7007\u7028\u7085\u70AB\u710F\u7104\u715C\u7146\u7147\uFA15\u71C1\u71FE\u72B1"],
    ["ee40", "\u72BE\u7324\uFA16\u7377\u73BD\u73C9\u73D6\u73E3\u73D2\u7407\u73F5\u7426\u742A\u7429\u742E\u7462\u7489\u749F\u7501\u756F\u7682\u769C\u769E\u769B\u76A6\uFA17\u7746\u52AF\u7821\u784E\u7864\u787A\u7930\uFA18\uFA19\uFA1A\u7994\uFA1B\u799B\u7AD1\u7AE7\uFA1C\u7AEB\u7B9E\uFA1D\u7D48\u7D5C\u7DB7\u7DA0\u7DD6\u7E52\u7F47\u7FA1\uFA1E\u8301\u8362\u837F\u83C7\u83F6\u8448\u84B4\u8553\u8559"],
    ["ee80", "\u856B\uFA1F\u85B0\uFA20\uFA21\u8807\u88F5\u8A12\u8A37\u8A79\u8AA7\u8ABE\u8ADF\uFA22\u8AF6\u8B53\u8B7F\u8CF0\u8CF4\u8D12\u8D76\uFA23\u8ECF\uFA24\uFA25\u9067\u90DE\uFA26\u9115\u9127\u91DA\u91D7\u91DE\u91ED\u91EE\u91E4\u91E5\u9206\u9210\u920A\u923A\u9240\u923C\u924E\u9259\u9251\u9239\u9267\u92A7\u9277\u9278\u92E7\u92D7\u92D9\u92D0\uFA27\u92D5\u92E0\u92D3\u9325\u9321\u92FB\uFA28\u931E\u92FF\u931D\u9302\u9370\u9357\u93A4\u93C6\u93DE\u93F8\u9431\u9445\u9448\u9592\uF9DC\uFA29\u969D\u96AF\u9733\u973B\u9743\u974D\u974F\u9751\u9755\u9857\u9865\uFA2A\uFA2B\u9927\uFA2C\u999E\u9A4E\u9AD9\u9ADC\u9B75\u9B72\u9B8F\u9BB1\u9BBB\u9C00\u9D70\u9D6B\uFA2D\u9E19\u9ED1"],
    ["eeef", "\u2170", 9, "\uFFE2\uFFE4\uFF07\uFF02"],
    ["f040", "\uE000", 62],
    ["f080", "\uE03F", 124],
    ["f140", "\uE0BC", 62],
    ["f180", "\uE0FB", 124],
    ["f240", "\uE178", 62],
    ["f280", "\uE1B7", 124],
    ["f340", "\uE234", 62],
    ["f380", "\uE273", 124],
    ["f440", "\uE2F0", 62],
    ["f480", "\uE32F", 124],
    ["f540", "\uE3AC", 62],
    ["f580", "\uE3EB", 124],
    ["f640", "\uE468", 62],
    ["f680", "\uE4A7", 124],
    ["f740", "\uE524", 62],
    ["f780", "\uE563", 124],
    ["f840", "\uE5E0", 62],
    ["f880", "\uE61F", 124],
    ["f940", "\uE69C"],
    ["fa40", "\u2170", 9, "\u2160", 9, "\uFFE2\uFFE4\uFF07\uFF02\u3231\u2116\u2121\u2235\u7E8A\u891C\u9348\u9288\u84DC\u4FC9\u70BB\u6631\u68C8\u92F9\u66FB\u5F45\u4E28\u4EE1\u4EFC\u4F00\u4F03\u4F39\u4F56\u4F92\u4F8A\u4F9A\u4F94\u4FCD\u5040\u5022\u4FFF\u501E\u5046\u5070\u5042\u5094\u50F4\u50D8\u514A"],
    ["fa80", "\u5164\u519D\u51BE\u51EC\u5215\u529C\u52A6\u52C0\u52DB\u5300\u5307\u5324\u5372\u5393\u53B2\u53DD\uFA0E\u549C\u548A\u54A9\u54FF\u5586\u5759\u5765\u57AC\u57C8\u57C7\uFA0F\uFA10\u589E\u58B2\u590B\u5953\u595B\u595D\u5963\u59A4\u59BA\u5B56\u5BC0\u752F\u5BD8\u5BEC\u5C1E\u5CA6\u5CBA\u5CF5\u5D27\u5D53\uFA11\u5D42\u5D6D\u5DB8\u5DB9\u5DD0\u5F21\u5F34\u5F67\u5FB7\u5FDE\u605D\u6085\u608A\u60DE\u60D5\u6120\u60F2\u6111\u6137\u6130\u6198\u6213\u62A6\u63F5\u6460\u649D\u64CE\u654E\u6600\u6615\u663B\u6609\u662E\u661E\u6624\u6665\u6657\u6659\uFA12\u6673\u6699\u66A0\u66B2\u66BF\u66FA\u670E\uF929\u6766\u67BB\u6852\u67C0\u6801\u6844\u68CF\uFA13\u6968\uFA14\u6998\u69E2\u6A30\u6A6B\u6A46\u6A73\u6A7E\u6AE2\u6AE4\u6BD6\u6C3F\u6C5C\u6C86\u6C6F\u6CDA\u6D04\u6D87\u6D6F"],
    ["fb40", "\u6D96\u6DAC\u6DCF\u6DF8\u6DF2\u6DFC\u6E39\u6E5C\u6E27\u6E3C\u6EBF\u6F88\u6FB5\u6FF5\u7005\u7007\u7028\u7085\u70AB\u710F\u7104\u715C\u7146\u7147\uFA15\u71C1\u71FE\u72B1\u72BE\u7324\uFA16\u7377\u73BD\u73C9\u73D6\u73E3\u73D2\u7407\u73F5\u7426\u742A\u7429\u742E\u7462\u7489\u749F\u7501\u756F\u7682\u769C\u769E\u769B\u76A6\uFA17\u7746\u52AF\u7821\u784E\u7864\u787A\u7930\uFA18\uFA19"],
    ["fb80", "\uFA1A\u7994\uFA1B\u799B\u7AD1\u7AE7\uFA1C\u7AEB\u7B9E\uFA1D\u7D48\u7D5C\u7DB7\u7DA0\u7DD6\u7E52\u7F47\u7FA1\uFA1E\u8301\u8362\u837F\u83C7\u83F6\u8448\u84B4\u8553\u8559\u856B\uFA1F\u85B0\uFA20\uFA21\u8807\u88F5\u8A12\u8A37\u8A79\u8AA7\u8ABE\u8ADF\uFA22\u8AF6\u8B53\u8B7F\u8CF0\u8CF4\u8D12\u8D76\uFA23\u8ECF\uFA24\uFA25\u9067\u90DE\uFA26\u9115\u9127\u91DA\u91D7\u91DE\u91ED\u91EE\u91E4\u91E5\u9206\u9210\u920A\u923A\u9240\u923C\u924E\u9259\u9251\u9239\u9267\u92A7\u9277\u9278\u92E7\u92D7\u92D9\u92D0\uFA27\u92D5\u92E0\u92D3\u9325\u9321\u92FB\uFA28\u931E\u92FF\u931D\u9302\u9370\u9357\u93A4\u93C6\u93DE\u93F8\u9431\u9445\u9448\u9592\uF9DC\uFA29\u969D\u96AF\u9733\u973B\u9743\u974D\u974F\u9751\u9755\u9857\u9865\uFA2A\uFA2B\u9927\uFA2C\u999E\u9A4E\u9AD9"],
    ["fc40", "\u9ADC\u9B75\u9B72\u9B8F\u9BB1\u9BBB\u9C00\u9D70\u9D6B\uFA2D\u9E19\u9ED1"]
  ];
});

// ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/eucjp.json
var require_eucjp = __commonJS((exports2, module2) => {
  module2.exports = [
    ["0", "\0", 127],
    ["8ea1", "\uFF61", 62],
    ["a1a1", "\u3000\u3001\u3002\uFF0C\uFF0E\u30FB\uFF1A\uFF1B\uFF1F\uFF01\u309B\u309C\xB4\uFF40\xA8\uFF3E\uFFE3\uFF3F\u30FD\u30FE\u309D\u309E\u3003\u4EDD\u3005\u3006\u3007\u30FC\u2015\u2010\uFF0F\uFF3C\uFF5E\u2225\uFF5C\u2026\u2025\u2018\u2019\u201C\u201D\uFF08\uFF09\u3014\u3015\uFF3B\uFF3D\uFF5B\uFF5D\u3008", 9, "\uFF0B\uFF0D\xB1\xD7\xF7\uFF1D\u2260\uFF1C\uFF1E\u2266\u2267\u221E\u2234\u2642\u2640\xB0\u2032\u2033\u2103\uFFE5\uFF04\uFFE0\uFFE1\uFF05\uFF03\uFF06\uFF0A\uFF20\xA7\u2606\u2605\u25CB\u25CF\u25CE\u25C7"],
    ["a2a1", "\u25C6\u25A1\u25A0\u25B3\u25B2\u25BD\u25BC\u203B\u3012\u2192\u2190\u2191\u2193\u3013"],
    ["a2ba", "\u2208\u220B\u2286\u2287\u2282\u2283\u222A\u2229"],
    ["a2ca", "\u2227\u2228\uFFE2\u21D2\u21D4\u2200\u2203"],
    ["a2dc", "\u2220\u22A5\u2312\u2202\u2207\u2261\u2252\u226A\u226B\u221A\u223D\u221D\u2235\u222B\u222C"],
    ["a2f2", "\u212B\u2030\u266F\u266D\u266A\u2020\u2021\xB6"],
    ["a2fe", "\u25EF"],
    ["a3b0", "\uFF10", 9],
    ["a3c1", "\uFF21", 25],
    ["a3e1", "\uFF41", 25],
    ["a4a1", "\u3041", 82],
    ["a5a1", "\u30A1", 85],
    ["a6a1", "\u0391", 16, "\u03A3", 6],
    ["a6c1", "\u03B1", 16, "\u03C3", 6],
    ["a7a1", "\u0410", 5, "\u0401\u0416", 25],
    ["a7d1", "\u0430", 5, "\u0451\u0436", 25],
    ["a8a1", "\u2500\u2502\u250C\u2510\u2518\u2514\u251C\u252C\u2524\u2534\u253C\u2501\u2503\u250F\u2513\u251B\u2517\u2523\u2533\u252B\u253B\u254B\u2520\u252F\u2528\u2537\u253F\u251D\u2530\u2525\u2538\u2542"],
    ["ada1", "\u2460", 19, "\u2160", 9],
    ["adc0", "\u3349\u3314\u3322\u334D\u3318\u3327\u3303\u3336\u3351\u3357\u330D\u3326\u3323\u332B\u334A\u333B\u339C\u339D\u339E\u338E\u338F\u33C4\u33A1"],
    ["addf", "\u337B\u301D\u301F\u2116\u33CD\u2121\u32A4", 4, "\u3231\u3232\u3239\u337E\u337D\u337C\u2252\u2261\u222B\u222E\u2211\u221A\u22A5\u2220\u221F\u22BF\u2235\u2229\u222A"],
    ["b0a1", "\u4E9C\u5516\u5A03\u963F\u54C0\u611B\u6328\u59F6\u9022\u8475\u831C\u7A50\u60AA\u63E1\u6E25\u65ED\u8466\u82A6\u9BF5\u6893\u5727\u65A1\u6271\u5B9B\u59D0\u867B\u98F4\u7D62\u7DBE\u9B8E\u6216\u7C9F\u88B7\u5B89\u5EB5\u6309\u6697\u6848\u95C7\u978D\u674F\u4EE5\u4F0A\u4F4D\u4F9D\u5049\u56F2\u5937\u59D4\u5A01\u5C09\u60DF\u610F\u6170\u6613\u6905\u70BA\u754F\u7570\u79FB\u7DAD\u7DEF\u80C3\u840E\u8863\u8B02\u9055\u907A\u533B\u4E95\u4EA5\u57DF\u80B2\u90C1\u78EF\u4E00\u58F1\u6EA2\u9038\u7A32\u8328\u828B\u9C2F\u5141\u5370\u54BD\u54E1\u56E0\u59FB\u5F15\u98F2\u6DEB\u80E4\u852D"],
    ["b1a1", "\u9662\u9670\u96A0\u97FB\u540B\u53F3\u5B87\u70CF\u7FBD\u8FC2\u96E8\u536F\u9D5C\u7ABA\u4E11\u7893\u81FC\u6E26\u5618\u5504\u6B1D\u851A\u9C3B\u59E5\u53A9\u6D66\u74DC\u958F\u5642\u4E91\u904B\u96F2\u834F\u990C\u53E1\u55B6\u5B30\u5F71\u6620\u66F3\u6804\u6C38\u6CF3\u6D29\u745B\u76C8\u7A4E\u9834\u82F1\u885B\u8A60\u92ED\u6DB2\u75AB\u76CA\u99C5\u60A6\u8B01\u8D8A\u95B2\u698E\u53AD\u5186\u5712\u5830\u5944\u5BB4\u5EF6\u6028\u63A9\u63F4\u6CBF\u6F14\u708E\u7114\u7159\u71D5\u733F\u7E01\u8276\u82D1\u8597\u9060\u925B\u9D1B\u5869\u65BC\u6C5A\u7525\u51F9\u592E\u5965\u5F80\u5FDC"],
    ["b2a1", "\u62BC\u65FA\u6A2A\u6B27\u6BB4\u738B\u7FC1\u8956\u9D2C\u9D0E\u9EC4\u5CA1\u6C96\u837B\u5104\u5C4B\u61B6\u81C6\u6876\u7261\u4E59\u4FFA\u5378\u6069\u6E29\u7A4F\u97F3\u4E0B\u5316\u4EEE\u4F55\u4F3D\u4FA1\u4F73\u52A0\u53EF\u5609\u590F\u5AC1\u5BB6\u5BE1\u79D1\u6687\u679C\u67B6\u6B4C\u6CB3\u706B\u73C2\u798D\u79BE\u7A3C\u7B87\u82B1\u82DB\u8304\u8377\u83EF\u83D3\u8766\u8AB2\u5629\u8CA8\u8FE6\u904E\u971E\u868A\u4FC4\u5CE8\u6211\u7259\u753B\u81E5\u82BD\u86FE\u8CC0\u96C5\u9913\u99D5\u4ECB\u4F1A\u89E3\u56DE\u584A\u58CA\u5EFB\u5FEB\u602A\u6094\u6062\u61D0\u6212\u62D0\u6539"],
    ["b3a1", "\u9B41\u6666\u68B0\u6D77\u7070\u754C\u7686\u7D75\u82A5\u87F9\u958B\u968E\u8C9D\u51F1\u52BE\u5916\u54B3\u5BB3\u5D16\u6168\u6982\u6DAF\u788D\u84CB\u8857\u8A72\u93A7\u9AB8\u6D6C\u99A8\u86D9\u57A3\u67FF\u86CE\u920E\u5283\u5687\u5404\u5ED3\u62E1\u64B9\u683C\u6838\u6BBB\u7372\u78BA\u7A6B\u899A\u89D2\u8D6B\u8F03\u90ED\u95A3\u9694\u9769\u5B66\u5CB3\u697D\u984D\u984E\u639B\u7B20\u6A2B\u6A7F\u68B6\u9C0D\u6F5F\u5272\u559D\u6070\u62EC\u6D3B\u6E07\u6ED1\u845B\u8910\u8F44\u4E14\u9C39\u53F6\u691B\u6A3A\u9784\u682A\u515C\u7AC3\u84B2\u91DC\u938C\u565B\u9D28\u6822\u8305\u8431"],
    ["b4a1", "\u7CA5\u5208\u82C5\u74E6\u4E7E\u4F83\u51A0\u5BD2\u520A\u52D8\u52E7\u5DFB\u559A\u582A\u59E6\u5B8C\u5B98\u5BDB\u5E72\u5E79\u60A3\u611F\u6163\u61BE\u63DB\u6562\u67D1\u6853\u68FA\u6B3E\u6B53\u6C57\u6F22\u6F97\u6F45\u74B0\u7518\u76E3\u770B\u7AFF\u7BA1\u7C21\u7DE9\u7F36\u7FF0\u809D\u8266\u839E\u89B3\u8ACC\u8CAB\u9084\u9451\u9593\u9591\u95A2\u9665\u97D3\u9928\u8218\u4E38\u542B\u5CB8\u5DCC\u73A9\u764C\u773C\u5CA9\u7FEB\u8D0B\u96C1\u9811\u9854\u9858\u4F01\u4F0E\u5371\u559C\u5668\u57FA\u5947\u5B09\u5BC4\u5C90\u5E0C\u5E7E\u5FCC\u63EE\u673A\u65D7\u65E2\u671F\u68CB\u68C4"],
    ["b5a1", "\u6A5F\u5E30\u6BC5\u6C17\u6C7D\u757F\u7948\u5B63\u7A00\u7D00\u5FBD\u898F\u8A18\u8CB4\u8D77\u8ECC\u8F1D\u98E2\u9A0E\u9B3C\u4E80\u507D\u5100\u5993\u5B9C\u622F\u6280\u64EC\u6B3A\u72A0\u7591\u7947\u7FA9\u87FB\u8ABC\u8B70\u63AC\u83CA\u97A0\u5409\u5403\u55AB\u6854\u6A58\u8A70\u7827\u6775\u9ECD\u5374\u5BA2\u811A\u8650\u9006\u4E18\u4E45\u4EC7\u4F11\u53CA\u5438\u5BAE\u5F13\u6025\u6551\u673D\u6C42\u6C72\u6CE3\u7078\u7403\u7A76\u7AAE\u7B08\u7D1A\u7CFE\u7D66\u65E7\u725B\u53BB\u5C45\u5DE8\u62D2\u62E0\u6319\u6E20\u865A\u8A31\u8DDD\u92F8\u6F01\u79A6\u9B5A\u4EA8\u4EAB\u4EAC"],
    ["b6a1", "\u4F9B\u4FA0\u50D1\u5147\u7AF6\u5171\u51F6\u5354\u5321\u537F\u53EB\u55AC\u5883\u5CE1\u5F37\u5F4A\u602F\u6050\u606D\u631F\u6559\u6A4B\u6CC1\u72C2\u72ED\u77EF\u80F8\u8105\u8208\u854E\u90F7\u93E1\u97FF\u9957\u9A5A\u4EF0\u51DD\u5C2D\u6681\u696D\u5C40\u66F2\u6975\u7389\u6850\u7C81\u50C5\u52E4\u5747\u5DFE\u9326\u65A4\u6B23\u6B3D\u7434\u7981\u79BD\u7B4B\u7DCA\u82B9\u83CC\u887F\u895F\u8B39\u8FD1\u91D1\u541F\u9280\u4E5D\u5036\u53E5\u533A\u72D7\u7396\u77E9\u82E6\u8EAF\u99C6\u99C8\u99D2\u5177\u611A\u865E\u55B0\u7A7A\u5076\u5BD3\u9047\u9685\u4E32\u6ADB\u91E7\u5C51\u5C48"],
    ["b7a1", "\u6398\u7A9F\u6C93\u9774\u8F61\u7AAA\u718A\u9688\u7C82\u6817\u7E70\u6851\u936C\u52F2\u541B\u85AB\u8A13\u7FA4\u8ECD\u90E1\u5366\u8888\u7941\u4FC2\u50BE\u5211\u5144\u5553\u572D\u73EA\u578B\u5951\u5F62\u5F84\u6075\u6176\u6167\u61A9\u63B2\u643A\u656C\u666F\u6842\u6E13\u7566\u7A3D\u7CFB\u7D4C\u7D99\u7E4B\u7F6B\u830E\u834A\u86CD\u8A08\u8A63\u8B66\u8EFD\u981A\u9D8F\u82B8\u8FCE\u9BE8\u5287\u621F\u6483\u6FC0\u9699\u6841\u5091\u6B20\u6C7A\u6F54\u7A74\u7D50\u8840\u8A23\u6708\u4EF6\u5039\u5026\u5065\u517C\u5238\u5263\u55A7\u570F\u5805\u5ACC\u5EFA\u61B2\u61F8\u62F3\u6372"],
    ["b8a1", "\u691C\u6A29\u727D\u72AC\u732E\u7814\u786F\u7D79\u770C\u80A9\u898B\u8B19\u8CE2\u8ED2\u9063\u9375\u967A\u9855\u9A13\u9E78\u5143\u539F\u53B3\u5E7B\u5F26\u6E1B\u6E90\u7384\u73FE\u7D43\u8237\u8A00\u8AFA\u9650\u4E4E\u500B\u53E4\u547C\u56FA\u59D1\u5B64\u5DF1\u5EAB\u5F27\u6238\u6545\u67AF\u6E56\u72D0\u7CCA\u88B4\u80A1\u80E1\u83F0\u864E\u8A87\u8DE8\u9237\u96C7\u9867\u9F13\u4E94\u4E92\u4F0D\u5348\u5449\u543E\u5A2F\u5F8C\u5FA1\u609F\u68A7\u6A8E\u745A\u7881\u8A9E\u8AA4\u8B77\u9190\u4E5E\u9BC9\u4EA4\u4F7C\u4FAF\u5019\u5016\u5149\u516C\u529F\u52B9\u52FE\u539A\u53E3\u5411"],
    ["b9a1", "\u540E\u5589\u5751\u57A2\u597D\u5B54\u5B5D\u5B8F\u5DE5\u5DE7\u5DF7\u5E78\u5E83\u5E9A\u5EB7\u5F18\u6052\u614C\u6297\u62D8\u63A7\u653B\u6602\u6643\u66F4\u676D\u6821\u6897\u69CB\u6C5F\u6D2A\u6D69\u6E2F\u6E9D\u7532\u7687\u786C\u7A3F\u7CE0\u7D05\u7D18\u7D5E\u7DB1\u8015\u8003\u80AF\u80B1\u8154\u818F\u822A\u8352\u884C\u8861\u8B1B\u8CA2\u8CFC\u90CA\u9175\u9271\u783F\u92FC\u95A4\u964D\u9805\u9999\u9AD8\u9D3B\u525B\u52AB\u53F7\u5408\u58D5\u62F7\u6FE0\u8C6A\u8F5F\u9EB9\u514B\u523B\u544A\u56FD\u7A40\u9177\u9D60\u9ED2\u7344\u6F09\u8170\u7511\u5FFD\u60DA\u9AA8\u72DB\u8FBC"],
    ["baa1", "\u6B64\u9803\u4ECA\u56F0\u5764\u58BE\u5A5A\u6068\u61C7\u660F\u6606\u6839\u68B1\u6DF7\u75D5\u7D3A\u826E\u9B42\u4E9B\u4F50\u53C9\u5506\u5D6F\u5DE6\u5DEE\u67FB\u6C99\u7473\u7802\u8A50\u9396\u88DF\u5750\u5EA7\u632B\u50B5\u50AC\u518D\u6700\u54C9\u585E\u59BB\u5BB0\u5F69\u624D\u63A1\u683D\u6B73\u6E08\u707D\u91C7\u7280\u7815\u7826\u796D\u658E\u7D30\u83DC\u88C1\u8F09\u969B\u5264\u5728\u6750\u7F6A\u8CA1\u51B4\u5742\u962A\u583A\u698A\u80B4\u54B2\u5D0E\u57FC\u7895\u9DFA\u4F5C\u524A\u548B\u643E\u6628\u6714\u67F5\u7A84\u7B56\u7D22\u932F\u685C\u9BAD\u7B39\u5319\u518A\u5237"],
    ["bba1", "\u5BDF\u62F6\u64AE\u64E6\u672D\u6BBA\u85A9\u96D1\u7690\u9BD6\u634C\u9306\u9BAB\u76BF\u6652\u4E09\u5098\u53C2\u5C71\u60E8\u6492\u6563\u685F\u71E6\u73CA\u7523\u7B97\u7E82\u8695\u8B83\u8CDB\u9178\u9910\u65AC\u66AB\u6B8B\u4ED5\u4ED4\u4F3A\u4F7F\u523A\u53F8\u53F2\u55E3\u56DB\u58EB\u59CB\u59C9\u59FF\u5B50\u5C4D\u5E02\u5E2B\u5FD7\u601D\u6307\u652F\u5B5C\u65AF\u65BD\u65E8\u679D\u6B62\u6B7B\u6C0F\u7345\u7949\u79C1\u7CF8\u7D19\u7D2B\u80A2\u8102\u81F3\u8996\u8A5E\u8A69\u8A66\u8A8C\u8AEE\u8CC7\u8CDC\u96CC\u98FC\u6B6F\u4E8B\u4F3C\u4F8D\u5150\u5B57\u5BFA\u6148\u6301\u6642"],
    ["bca1", "\u6B21\u6ECB\u6CBB\u723E\u74BD\u75D4\u78C1\u793A\u800C\u8033\u81EA\u8494\u8F9E\u6C50\u9E7F\u5F0F\u8B58\u9D2B\u7AFA\u8EF8\u5B8D\u96EB\u4E03\u53F1\u57F7\u5931\u5AC9\u5BA4\u6089\u6E7F\u6F06\u75BE\u8CEA\u5B9F\u8500\u7BE0\u5072\u67F4\u829D\u5C61\u854A\u7E1E\u820E\u5199\u5C04\u6368\u8D66\u659C\u716E\u793E\u7D17\u8005\u8B1D\u8ECA\u906E\u86C7\u90AA\u501F\u52FA\u5C3A\u6753\u707C\u7235\u914C\u91C8\u932B\u82E5\u5BC2\u5F31\u60F9\u4E3B\u53D6\u5B88\u624B\u6731\u6B8A\u72E9\u73E0\u7A2E\u816B\u8DA3\u9152\u9996\u5112\u53D7\u546A\u5BFF\u6388\u6A39\u7DAC\u9700\u56DA\u53CE\u5468"],
    ["bda1", "\u5B97\u5C31\u5DDE\u4FEE\u6101\u62FE\u6D32\u79C0\u79CB\u7D42\u7E4D\u7FD2\u81ED\u821F\u8490\u8846\u8972\u8B90\u8E74\u8F2F\u9031\u914B\u916C\u96C6\u919C\u4EC0\u4F4F\u5145\u5341\u5F93\u620E\u67D4\u6C41\u6E0B\u7363\u7E26\u91CD\u9283\u53D4\u5919\u5BBF\u6DD1\u795D\u7E2E\u7C9B\u587E\u719F\u51FA\u8853\u8FF0\u4FCA\u5CFB\u6625\u77AC\u7AE3\u821C\u99FF\u51C6\u5FAA\u65EC\u696F\u6B89\u6DF3\u6E96\u6F64\u76FE\u7D14\u5DE1\u9075\u9187\u9806\u51E6\u521D\u6240\u6691\u66D9\u6E1A\u5EB6\u7DD2\u7F72\u66F8\u85AF\u85F7\u8AF8\u52A9\u53D9\u5973\u5E8F\u5F90\u6055\u92E4\u9664\u50B7\u511F"],
    ["bea1", "\u52DD\u5320\u5347\u53EC\u54E8\u5546\u5531\u5617\u5968\u59BE\u5A3C\u5BB5\u5C06\u5C0F\u5C11\u5C1A\u5E84\u5E8A\u5EE0\u5F70\u627F\u6284\u62DB\u638C\u6377\u6607\u660C\u662D\u6676\u677E\u68A2\u6A1F\u6A35\u6CBC\u6D88\u6E09\u6E58\u713C\u7126\u7167\u75C7\u7701\u785D\u7901\u7965\u79F0\u7AE0\u7B11\u7CA7\u7D39\u8096\u83D6\u848B\u8549\u885D\u88F3\u8A1F\u8A3C\u8A54\u8A73\u8C61\u8CDE\u91A4\u9266\u937E\u9418\u969C\u9798\u4E0A\u4E08\u4E1E\u4E57\u5197\u5270\u57CE\u5834\u58CC\u5B22\u5E38\u60C5\u64FE\u6761\u6756\u6D44\u72B6\u7573\u7A63\u84B8\u8B72\u91B8\u9320\u5631\u57F4\u98FE"],
    ["bfa1", "\u62ED\u690D\u6B96\u71ED\u7E54\u8077\u8272\u89E6\u98DF\u8755\u8FB1\u5C3B\u4F38\u4FE1\u4FB5\u5507\u5A20\u5BDD\u5BE9\u5FC3\u614E\u632F\u65B0\u664B\u68EE\u699B\u6D78\u6DF1\u7533\u75B9\u771F\u795E\u79E6\u7D33\u81E3\u82AF\u85AA\u89AA\u8A3A\u8EAB\u8F9B\u9032\u91DD\u9707\u4EBA\u4EC1\u5203\u5875\u58EC\u5C0B\u751A\u5C3D\u814E\u8A0A\u8FC5\u9663\u976D\u7B25\u8ACF\u9808\u9162\u56F3\u53A8\u9017\u5439\u5782\u5E25\u63A8\u6C34\u708A\u7761\u7C8B\u7FE0\u8870\u9042\u9154\u9310\u9318\u968F\u745E\u9AC4\u5D07\u5D69\u6570\u67A2\u8DA8\u96DB\u636E\u6749\u6919\u83C5\u9817\u96C0\u88FE"],
    ["c0a1", "\u6F84\u647A\u5BF8\u4E16\u702C\u755D\u662F\u51C4\u5236\u52E2\u59D3\u5F81\u6027\u6210\u653F\u6574\u661F\u6674\u68F2\u6816\u6B63\u6E05\u7272\u751F\u76DB\u7CBE\u8056\u58F0\u88FD\u897F\u8AA0\u8A93\u8ACB\u901D\u9192\u9752\u9759\u6589\u7A0E\u8106\u96BB\u5E2D\u60DC\u621A\u65A5\u6614\u6790\u77F3\u7A4D\u7C4D\u7E3E\u810A\u8CAC\u8D64\u8DE1\u8E5F\u78A9\u5207\u62D9\u63A5\u6442\u6298\u8A2D\u7A83\u7BC0\u8AAC\u96EA\u7D76\u820C\u8749\u4ED9\u5148\u5343\u5360\u5BA3\u5C02\u5C16\u5DDD\u6226\u6247\u64B0\u6813\u6834\u6CC9\u6D45\u6D17\u67D3\u6F5C\u714E\u717D\u65CB\u7A7F\u7BAD\u7DDA"],
    ["c1a1", "\u7E4A\u7FA8\u817A\u821B\u8239\u85A6\u8A6E\u8CCE\u8DF5\u9078\u9077\u92AD\u9291\u9583\u9BAE\u524D\u5584\u6F38\u7136\u5168\u7985\u7E55\u81B3\u7CCE\u564C\u5851\u5CA8\u63AA\u66FE\u66FD\u695A\u72D9\u758F\u758E\u790E\u7956\u79DF\u7C97\u7D20\u7D44\u8607\u8A34\u963B\u9061\u9F20\u50E7\u5275\u53CC\u53E2\u5009\u55AA\u58EE\u594F\u723D\u5B8B\u5C64\u531D\u60E3\u60F3\u635C\u6383\u633F\u63BB\u64CD\u65E9\u66F9\u5DE3\u69CD\u69FD\u6F15\u71E5\u4E89\u75E9\u76F8\u7A93\u7CDF\u7DCF\u7D9C\u8061\u8349\u8358\u846C\u84BC\u85FB\u88C5\u8D70\u9001\u906D\u9397\u971C\u9A12\u50CF\u5897\u618E"],
    ["c2a1", "\u81D3\u8535\u8D08\u9020\u4FC3\u5074\u5247\u5373\u606F\u6349\u675F\u6E2C\u8DB3\u901F\u4FD7\u5C5E\u8CCA\u65CF\u7D9A\u5352\u8896\u5176\u63C3\u5B58\u5B6B\u5C0A\u640D\u6751\u905C\u4ED6\u591A\u592A\u6C70\u8A51\u553E\u5815\u59A5\u60F0\u6253\u67C1\u8235\u6955\u9640\u99C4\u9A28\u4F53\u5806\u5BFE\u8010\u5CB1\u5E2F\u5F85\u6020\u614B\u6234\u66FF\u6CF0\u6EDE\u80CE\u817F\u82D4\u888B\u8CB8\u9000\u902E\u968A\u9EDB\u9BDB\u4EE3\u53F0\u5927\u7B2C\u918D\u984C\u9DF9\u6EDD\u7027\u5353\u5544\u5B85\u6258\u629E\u62D3\u6CA2\u6FEF\u7422\u8A17\u9438\u6FC1\u8AFE\u8338\u51E7\u86F8\u53EA"],
    ["c3a1", "\u53E9\u4F46\u9054\u8FB0\u596A\u8131\u5DFD\u7AEA\u8FBF\u68DA\u8C37\u72F8\u9C48\u6A3D\u8AB0\u4E39\u5358\u5606\u5766\u62C5\u63A2\u65E6\u6B4E\u6DE1\u6E5B\u70AD\u77ED\u7AEF\u7BAA\u7DBB\u803D\u80C6\u86CB\u8A95\u935B\u56E3\u58C7\u5F3E\u65AD\u6696\u6A80\u6BB5\u7537\u8AC7\u5024\u77E5\u5730\u5F1B\u6065\u667A\u6C60\u75F4\u7A1A\u7F6E\u81F4\u8718\u9045\u99B3\u7BC9\u755C\u7AF9\u7B51\u84C4\u9010\u79E9\u7A92\u8336\u5AE1\u7740\u4E2D\u4EF2\u5B99\u5FE0\u62BD\u663C\u67F1\u6CE8\u866B\u8877\u8A3B\u914E\u92F3\u99D0\u6A17\u7026\u732A\u82E7\u8457\u8CAF\u4E01\u5146\u51CB\u558B\u5BF5"],
    ["c4a1", "\u5E16\u5E33\u5E81\u5F14\u5F35\u5F6B\u5FB4\u61F2\u6311\u66A2\u671D\u6F6E\u7252\u753A\u773A\u8074\u8139\u8178\u8776\u8ABF\u8ADC\u8D85\u8DF3\u929A\u9577\u9802\u9CE5\u52C5\u6357\u76F4\u6715\u6C88\u73CD\u8CC3\u93AE\u9673\u6D25\u589C\u690E\u69CC\u8FFD\u939A\u75DB\u901A\u585A\u6802\u63B4\u69FB\u4F43\u6F2C\u67D8\u8FBB\u8526\u7DB4\u9354\u693F\u6F70\u576A\u58F7\u5B2C\u7D2C\u722A\u540A\u91E3\u9DB4\u4EAD\u4F4E\u505C\u5075\u5243\u8C9E\u5448\u5824\u5B9A\u5E1D\u5E95\u5EAD\u5EF7\u5F1F\u608C\u62B5\u633A\u63D0\u68AF\u6C40\u7887\u798E\u7A0B\u7DE0\u8247\u8A02\u8AE6\u8E44\u9013"],
    ["c5a1", "\u90B8\u912D\u91D8\u9F0E\u6CE5\u6458\u64E2\u6575\u6EF4\u7684\u7B1B\u9069\u93D1\u6EBA\u54F2\u5FB9\u64A4\u8F4D\u8FED\u9244\u5178\u586B\u5929\u5C55\u5E97\u6DFB\u7E8F\u751C\u8CBC\u8EE2\u985B\u70B9\u4F1D\u6BBF\u6FB1\u7530\u96FB\u514E\u5410\u5835\u5857\u59AC\u5C60\u5F92\u6597\u675C\u6E21\u767B\u83DF\u8CED\u9014\u90FD\u934D\u7825\u783A\u52AA\u5EA6\u571F\u5974\u6012\u5012\u515A\u51AC\u51CD\u5200\u5510\u5854\u5858\u5957\u5B95\u5CF6\u5D8B\u60BC\u6295\u642D\u6771\u6843\u68BC\u68DF\u76D7\u6DD8\u6E6F\u6D9B\u706F\u71C8\u5F53\u75D8\u7977\u7B49\u7B54\u7B52\u7CD6\u7D71\u5230"],
    ["c6a1", "\u8463\u8569\u85E4\u8A0E\u8B04\u8C46\u8E0F\u9003\u900F\u9419\u9676\u982D\u9A30\u95D8\u50CD\u52D5\u540C\u5802\u5C0E\u61A7\u649E\u6D1E\u77B3\u7AE5\u80F4\u8404\u9053\u9285\u5CE0\u9D07\u533F\u5F97\u5FB3\u6D9C\u7279\u7763\u79BF\u7BE4\u6BD2\u72EC\u8AAD\u6803\u6A61\u51F8\u7A81\u6934\u5C4A\u9CF6\u82EB\u5BC5\u9149\u701E\u5678\u5C6F\u60C7\u6566\u6C8C\u8C5A\u9041\u9813\u5451\u66C7\u920D\u5948\u90A3\u5185\u4E4D\u51EA\u8599\u8B0E\u7058\u637A\u934B\u6962\u99B4\u7E04\u7577\u5357\u6960\u8EDF\u96E3\u6C5D\u4E8C\u5C3C\u5F10\u8FE9\u5302\u8CD1\u8089\u8679\u5EFF\u65E5\u4E73\u5165"],
    ["c7a1", "\u5982\u5C3F\u97EE\u4EFB\u598A\u5FCD\u8A8D\u6FE1\u79B0\u7962\u5BE7\u8471\u732B\u71B1\u5E74\u5FF5\u637B\u649A\u71C3\u7C98\u4E43\u5EFC\u4E4B\u57DC\u56A2\u60A9\u6FC3\u7D0D\u80FD\u8133\u81BF\u8FB2\u8997\u86A4\u5DF4\u628A\u64AD\u8987\u6777\u6CE2\u6D3E\u7436\u7834\u5A46\u7F75\u82AD\u99AC\u4FF3\u5EC3\u62DD\u6392\u6557\u676F\u76C3\u724C\u80CC\u80BA\u8F29\u914D\u500D\u57F9\u5A92\u6885\u6973\u7164\u72FD\u8CB7\u58F2\u8CE0\u966A\u9019\u877F\u79E4\u77E7\u8429\u4F2F\u5265\u535A\u62CD\u67CF\u6CCA\u767D\u7B94\u7C95\u8236\u8584\u8FEB\u66DD\u6F20\u7206\u7E1B\u83AB\u99C1\u9EA6"],
    ["c8a1", "\u51FD\u7BB1\u7872\u7BB8\u8087\u7B48\u6AE8\u5E61\u808C\u7551\u7560\u516B\u9262\u6E8C\u767A\u9197\u9AEA\u4F10\u7F70\u629C\u7B4F\u95A5\u9CE9\u567A\u5859\u86E4\u96BC\u4F34\u5224\u534A\u53CD\u53DB\u5E06\u642C\u6591\u677F\u6C3E\u6C4E\u7248\u72AF\u73ED\u7554\u7E41\u822C\u85E9\u8CA9\u7BC4\u91C6\u7169\u9812\u98EF\u633D\u6669\u756A\u76E4\u78D0\u8543\u86EE\u532A\u5351\u5426\u5983\u5E87\u5F7C\u60B2\u6249\u6279\u62AB\u6590\u6BD4\u6CCC\u75B2\u76AE\u7891\u79D8\u7DCB\u7F77\u80A5\u88AB\u8AB9\u8CBB\u907F\u975E\u98DB\u6A0B\u7C38\u5099\u5C3E\u5FAE\u6787\u6BD8\u7435\u7709\u7F8E"],
    ["c9a1", "\u9F3B\u67CA\u7A17\u5339\u758B\u9AED\u5F66\u819D\u83F1\u8098\u5F3C\u5FC5\u7562\u7B46\u903C\u6867\u59EB\u5A9B\u7D10\u767E\u8B2C\u4FF5\u5F6A\u6A19\u6C37\u6F02\u74E2\u7968\u8868\u8A55\u8C79\u5EDF\u63CF\u75C5\u79D2\u82D7\u9328\u92F2\u849C\u86ED\u9C2D\u54C1\u5F6C\u658C\u6D5C\u7015\u8CA7\u8CD3\u983B\u654F\u74F6\u4E0D\u4ED8\u57E0\u592B\u5A66\u5BCC\u51A8\u5E03\u5E9C\u6016\u6276\u6577\u65A7\u666E\u6D6E\u7236\u7B26\u8150\u819A\u8299\u8B5C\u8CA0\u8CE6\u8D74\u961C\u9644\u4FAE\u64AB\u6B66\u821E\u8461\u856A\u90E8\u5C01\u6953\u98A8\u847A\u8557\u4F0F\u526F\u5FA9\u5E45\u670D"],
    ["caa1", "\u798F\u8179\u8907\u8986\u6DF5\u5F17\u6255\u6CB8\u4ECF\u7269\u9B92\u5206\u543B\u5674\u58B3\u61A4\u626E\u711A\u596E\u7C89\u7CDE\u7D1B\u96F0\u6587\u805E\u4E19\u4F75\u5175\u5840\u5E63\u5E73\u5F0A\u67C4\u4E26\u853D\u9589\u965B\u7C73\u9801\u50FB\u58C1\u7656\u78A7\u5225\u77A5\u8511\u7B86\u504F\u5909\u7247\u7BC7\u7DE8\u8FBA\u8FD4\u904D\u4FBF\u52C9\u5A29\u5F01\u97AD\u4FDD\u8217\u92EA\u5703\u6355\u6B69\u752B\u88DC\u8F14\u7A42\u52DF\u5893\u6155\u620A\u66AE\u6BCD\u7C3F\u83E9\u5023\u4FF8\u5305\u5446\u5831\u5949\u5B9D\u5CF0\u5CEF\u5D29\u5E96\u62B1\u6367\u653E\u65B9\u670B"],
    ["cba1", "\u6CD5\u6CE1\u70F9\u7832\u7E2B\u80DE\u82B3\u840C\u84EC\u8702\u8912\u8A2A\u8C4A\u90A6\u92D2\u98FD\u9CF3\u9D6C\u4E4F\u4EA1\u508D\u5256\u574A\u59A8\u5E3D\u5FD8\u5FD9\u623F\u66B4\u671B\u67D0\u68D2\u5192\u7D21\u80AA\u81A8\u8B00\u8C8C\u8CBF\u927E\u9632\u5420\u982C\u5317\u50D5\u535C\u58A8\u64B2\u6734\u7267\u7766\u7A46\u91E6\u52C3\u6CA1\u6B86\u5800\u5E4C\u5954\u672C\u7FFB\u51E1\u76C6\u6469\u78E8\u9B54\u9EBB\u57CB\u59B9\u6627\u679A\u6BCE\u54E9\u69D9\u5E55\u819C\u6795\u9BAA\u67FE\u9C52\u685D\u4EA6\u4FE3\u53C8\u62B9\u672B\u6CAB\u8FC4\u4FAD\u7E6D\u9EBF\u4E07\u6162\u6E80"],
    ["cca1", "\u6F2B\u8513\u5473\u672A\u9B45\u5DF3\u7B95\u5CAC\u5BC6\u871C\u6E4A\u84D1\u7A14\u8108\u5999\u7C8D\u6C11\u7720\u52D9\u5922\u7121\u725F\u77DB\u9727\u9D61\u690B\u5A7F\u5A18\u51A5\u540D\u547D\u660E\u76DF\u8FF7\u9298\u9CF4\u59EA\u725D\u6EC5\u514D\u68C9\u7DBF\u7DEC\u9762\u9EBA\u6478\u6A21\u8302\u5984\u5B5F\u6BDB\u731B\u76F2\u7DB2\u8017\u8499\u5132\u6728\u9ED9\u76EE\u6762\u52FF\u9905\u5C24\u623B\u7C7E\u8CB0\u554F\u60B6\u7D0B\u9580\u5301\u4E5F\u51B6\u591C\u723A\u8036\u91CE\u5F25\u77E2\u5384\u5F79\u7D04\u85AC\u8A33\u8E8D\u9756\u67F3\u85AE\u9453\u6109\u6108\u6CB9\u7652"],
    ["cda1", "\u8AED\u8F38\u552F\u4F51\u512A\u52C7\u53CB\u5BA5\u5E7D\u60A0\u6182\u63D6\u6709\u67DA\u6E67\u6D8C\u7336\u7337\u7531\u7950\u88D5\u8A98\u904A\u9091\u90F5\u96C4\u878D\u5915\u4E88\u4F59\u4E0E\u8A89\u8F3F\u9810\u50AD\u5E7C\u5996\u5BB9\u5EB8\u63DA\u63FA\u64C1\u66DC\u694A\u69D8\u6D0B\u6EB6\u7194\u7528\u7AAF\u7F8A\u8000\u8449\u84C9\u8981\u8B21\u8E0A\u9065\u967D\u990A\u617E\u6291\u6B32\u6C83\u6D74\u7FCC\u7FFC\u6DC0\u7F85\u87BA\u88F8\u6765\u83B1\u983C\u96F7\u6D1B\u7D61\u843D\u916A\u4E71\u5375\u5D50\u6B04\u6FEB\u85CD\u862D\u89A7\u5229\u540F\u5C65\u674E\u68A8\u7406\u7483"],
    ["cea1", "\u75E2\u88CF\u88E1\u91CC\u96E2\u9678\u5F8B\u7387\u7ACB\u844E\u63A0\u7565\u5289\u6D41\u6E9C\u7409\u7559\u786B\u7C92\u9686\u7ADC\u9F8D\u4FB6\u616E\u65C5\u865C\u4E86\u4EAE\u50DA\u4E21\u51CC\u5BEE\u6599\u6881\u6DBC\u731F\u7642\u77AD\u7A1C\u7CE7\u826F\u8AD2\u907C\u91CF\u9675\u9818\u529B\u7DD1\u502B\u5398\u6797\u6DCB\u71D0\u7433\u81E8\u8F2A\u96A3\u9C57\u9E9F\u7460\u5841\u6D99\u7D2F\u985E\u4EE4\u4F36\u4F8B\u51B7\u52B1\u5DBA\u601C\u73B2\u793C\u82D3\u9234\u96B7\u96F6\u970A\u9E97\u9F62\u66A6\u6B74\u5217\u52A3\u70C8\u88C2\u5EC9\u604B\u6190\u6F23\u7149\u7C3E\u7DF4\u806F"],
    ["cfa1", "\u84EE\u9023\u932C\u5442\u9B6F\u6AD3\u7089\u8CC2\u8DEF\u9732\u52B4\u5A41\u5ECA\u5F04\u6717\u697C\u6994\u6D6A\u6F0F\u7262\u72FC\u7BED\u8001\u807E\u874B\u90CE\u516D\u9E93\u7984\u808B\u9332\u8AD6\u502D\u548C\u8A71\u6B6A\u8CC4\u8107\u60D1\u67A0\u9DF2\u4E99\u4E98\u9C10\u8A6B\u85C1\u8568\u6900\u6E7E\u7897\u8155"],
    ["d0a1", "\u5F0C\u4E10\u4E15\u4E2A\u4E31\u4E36\u4E3C\u4E3F\u4E42\u4E56\u4E58\u4E82\u4E85\u8C6B\u4E8A\u8212\u5F0D\u4E8E\u4E9E\u4E9F\u4EA0\u4EA2\u4EB0\u4EB3\u4EB6\u4ECE\u4ECD\u4EC4\u4EC6\u4EC2\u4ED7\u4EDE\u4EED\u4EDF\u4EF7\u4F09\u4F5A\u4F30\u4F5B\u4F5D\u4F57\u4F47\u4F76\u4F88\u4F8F\u4F98\u4F7B\u4F69\u4F70\u4F91\u4F6F\u4F86\u4F96\u5118\u4FD4\u4FDF\u4FCE\u4FD8\u4FDB\u4FD1\u4FDA\u4FD0\u4FE4\u4FE5\u501A\u5028\u5014\u502A\u5025\u5005\u4F1C\u4FF6\u5021\u5029\u502C\u4FFE\u4FEF\u5011\u5006\u5043\u5047\u6703\u5055\u5050\u5048\u505A\u5056\u506C\u5078\u5080\u509A\u5085\u50B4\u50B2"],
    ["d1a1", "\u50C9\u50CA\u50B3\u50C2\u50D6\u50DE\u50E5\u50ED\u50E3\u50EE\u50F9\u50F5\u5109\u5101\u5102\u5116\u5115\u5114\u511A\u5121\u513A\u5137\u513C\u513B\u513F\u5140\u5152\u514C\u5154\u5162\u7AF8\u5169\u516A\u516E\u5180\u5182\u56D8\u518C\u5189\u518F\u5191\u5193\u5195\u5196\u51A4\u51A6\u51A2\u51A9\u51AA\u51AB\u51B3\u51B1\u51B2\u51B0\u51B5\u51BD\u51C5\u51C9\u51DB\u51E0\u8655\u51E9\u51ED\u51F0\u51F5\u51FE\u5204\u520B\u5214\u520E\u5227\u522A\u522E\u5233\u5239\u524F\u5244\u524B\u524C\u525E\u5254\u526A\u5274\u5269\u5273\u527F\u527D\u528D\u5294\u5292\u5271\u5288\u5291\u8FA8"],
    ["d2a1", "\u8FA7\u52AC\u52AD\u52BC\u52B5\u52C1\u52CD\u52D7\u52DE\u52E3\u52E6\u98ED\u52E0\u52F3\u52F5\u52F8\u52F9\u5306\u5308\u7538\u530D\u5310\u530F\u5315\u531A\u5323\u532F\u5331\u5333\u5338\u5340\u5346\u5345\u4E17\u5349\u534D\u51D6\u535E\u5369\u536E\u5918\u537B\u5377\u5382\u5396\u53A0\u53A6\u53A5\u53AE\u53B0\u53B6\u53C3\u7C12\u96D9\u53DF\u66FC\u71EE\u53EE\u53E8\u53ED\u53FA\u5401\u543D\u5440\u542C\u542D\u543C\u542E\u5436\u5429\u541D\u544E\u548F\u5475\u548E\u545F\u5471\u5477\u5470\u5492\u547B\u5480\u5476\u5484\u5490\u5486\u54C7\u54A2\u54B8\u54A5\u54AC\u54C4\u54C8\u54A8"],
    ["d3a1", "\u54AB\u54C2\u54A4\u54BE\u54BC\u54D8\u54E5\u54E6\u550F\u5514\u54FD\u54EE\u54ED\u54FA\u54E2\u5539\u5540\u5563\u554C\u552E\u555C\u5545\u5556\u5557\u5538\u5533\u555D\u5599\u5580\u54AF\u558A\u559F\u557B\u557E\u5598\u559E\u55AE\u557C\u5583\u55A9\u5587\u55A8\u55DA\u55C5\u55DF\u55C4\u55DC\u55E4\u55D4\u5614\u55F7\u5616\u55FE\u55FD\u561B\u55F9\u564E\u5650\u71DF\u5634\u5636\u5632\u5638\u566B\u5664\u562F\u566C\u566A\u5686\u5680\u568A\u56A0\u5694\u568F\u56A5\u56AE\u56B6\u56B4\u56C2\u56BC\u56C1\u56C3\u56C0\u56C8\u56CE\u56D1\u56D3\u56D7\u56EE\u56F9\u5700\u56FF\u5704\u5709"],
    ["d4a1", "\u5708\u570B\u570D\u5713\u5718\u5716\u55C7\u571C\u5726\u5737\u5738\u574E\u573B\u5740\u574F\u5769\u57C0\u5788\u5761\u577F\u5789\u5793\u57A0\u57B3\u57A4\u57AA\u57B0\u57C3\u57C6\u57D4\u57D2\u57D3\u580A\u57D6\u57E3\u580B\u5819\u581D\u5872\u5821\u5862\u584B\u5870\u6BC0\u5852\u583D\u5879\u5885\u58B9\u589F\u58AB\u58BA\u58DE\u58BB\u58B8\u58AE\u58C5\u58D3\u58D1\u58D7\u58D9\u58D8\u58E5\u58DC\u58E4\u58DF\u58EF\u58FA\u58F9\u58FB\u58FC\u58FD\u5902\u590A\u5910\u591B\u68A6\u5925\u592C\u592D\u5932\u5938\u593E\u7AD2\u5955\u5950\u594E\u595A\u5958\u5962\u5960\u5967\u596C\u5969"],
    ["d5a1", "\u5978\u5981\u599D\u4F5E\u4FAB\u59A3\u59B2\u59C6\u59E8\u59DC\u598D\u59D9\u59DA\u5A25\u5A1F\u5A11\u5A1C\u5A09\u5A1A\u5A40\u5A6C\u5A49\u5A35\u5A36\u5A62\u5A6A\u5A9A\u5ABC\u5ABE\u5ACB\u5AC2\u5ABD\u5AE3\u5AD7\u5AE6\u5AE9\u5AD6\u5AFA\u5AFB\u5B0C\u5B0B\u5B16\u5B32\u5AD0\u5B2A\u5B36\u5B3E\u5B43\u5B45\u5B40\u5B51\u5B55\u5B5A\u5B5B\u5B65\u5B69\u5B70\u5B73\u5B75\u5B78\u6588\u5B7A\u5B80\u5B83\u5BA6\u5BB8\u5BC3\u5BC7\u5BC9\u5BD4\u5BD0\u5BE4\u5BE6\u5BE2\u5BDE\u5BE5\u5BEB\u5BF0\u5BF6\u5BF3\u5C05\u5C07\u5C08\u5C0D\u5C13\u5C20\u5C22\u5C28\u5C38\u5C39\u5C41\u5C46\u5C4E\u5C53"],
    ["d6a1", "\u5C50\u5C4F\u5B71\u5C6C\u5C6E\u4E62\u5C76\u5C79\u5C8C\u5C91\u5C94\u599B\u5CAB\u5CBB\u5CB6\u5CBC\u5CB7\u5CC5\u5CBE\u5CC7\u5CD9\u5CE9\u5CFD\u5CFA\u5CED\u5D8C\u5CEA\u5D0B\u5D15\u5D17\u5D5C\u5D1F\u5D1B\u5D11\u5D14\u5D22\u5D1A\u5D19\u5D18\u5D4C\u5D52\u5D4E\u5D4B\u5D6C\u5D73\u5D76\u5D87\u5D84\u5D82\u5DA2\u5D9D\u5DAC\u5DAE\u5DBD\u5D90\u5DB7\u5DBC\u5DC9\u5DCD\u5DD3\u5DD2\u5DD6\u5DDB\u5DEB\u5DF2\u5DF5\u5E0B\u5E1A\u5E19\u5E11\u5E1B\u5E36\u5E37\u5E44\u5E43\u5E40\u5E4E\u5E57\u5E54\u5E5F\u5E62\u5E64\u5E47\u5E75\u5E76\u5E7A\u9EBC\u5E7F\u5EA0\u5EC1\u5EC2\u5EC8\u5ED0\u5ECF"],
    ["d7a1", "\u5ED6\u5EE3\u5EDD\u5EDA\u5EDB\u5EE2\u5EE1\u5EE8\u5EE9\u5EEC\u5EF1\u5EF3\u5EF0\u5EF4\u5EF8\u5EFE\u5F03\u5F09\u5F5D\u5F5C\u5F0B\u5F11\u5F16\u5F29\u5F2D\u5F38\u5F41\u5F48\u5F4C\u5F4E\u5F2F\u5F51\u5F56\u5F57\u5F59\u5F61\u5F6D\u5F73\u5F77\u5F83\u5F82\u5F7F\u5F8A\u5F88\u5F91\u5F87\u5F9E\u5F99\u5F98\u5FA0\u5FA8\u5FAD\u5FBC\u5FD6\u5FFB\u5FE4\u5FF8\u5FF1\u5FDD\u60B3\u5FFF\u6021\u6060\u6019\u6010\u6029\u600E\u6031\u601B\u6015\u602B\u6026\u600F\u603A\u605A\u6041\u606A\u6077\u605F\u604A\u6046\u604D\u6063\u6043\u6064\u6042\u606C\u606B\u6059\u6081\u608D\u60E7\u6083\u609A"],
    ["d8a1", "\u6084\u609B\u6096\u6097\u6092\u60A7\u608B\u60E1\u60B8\u60E0\u60D3\u60B4\u5FF0\u60BD\u60C6\u60B5\u60D8\u614D\u6115\u6106\u60F6\u60F7\u6100\u60F4\u60FA\u6103\u6121\u60FB\u60F1\u610D\u610E\u6147\u613E\u6128\u6127\u614A\u613F\u613C\u612C\u6134\u613D\u6142\u6144\u6173\u6177\u6158\u6159\u615A\u616B\u6174\u616F\u6165\u6171\u615F\u615D\u6153\u6175\u6199\u6196\u6187\u61AC\u6194\u619A\u618A\u6191\u61AB\u61AE\u61CC\u61CA\u61C9\u61F7\u61C8\u61C3\u61C6\u61BA\u61CB\u7F79\u61CD\u61E6\u61E3\u61F6\u61FA\u61F4\u61FF\u61FD\u61FC\u61FE\u6200\u6208\u6209\u620D\u620C\u6214\u621B"],
    ["d9a1", "\u621E\u6221\u622A\u622E\u6230\u6232\u6233\u6241\u624E\u625E\u6263\u625B\u6260\u6268\u627C\u6282\u6289\u627E\u6292\u6293\u6296\u62D4\u6283\u6294\u62D7\u62D1\u62BB\u62CF\u62FF\u62C6\u64D4\u62C8\u62DC\u62CC\u62CA\u62C2\u62C7\u629B\u62C9\u630C\u62EE\u62F1\u6327\u6302\u6308\u62EF\u62F5\u6350\u633E\u634D\u641C\u634F\u6396\u638E\u6380\u63AB\u6376\u63A3\u638F\u6389\u639F\u63B5\u636B\u6369\u63BE\u63E9\u63C0\u63C6\u63E3\u63C9\u63D2\u63F6\u63C4\u6416\u6434\u6406\u6413\u6426\u6436\u651D\u6417\u6428\u640F\u6467\u646F\u6476\u644E\u652A\u6495\u6493\u64A5\u64A9\u6488\u64BC"],
    ["daa1", "\u64DA\u64D2\u64C5\u64C7\u64BB\u64D8\u64C2\u64F1\u64E7\u8209\u64E0\u64E1\u62AC\u64E3\u64EF\u652C\u64F6\u64F4\u64F2\u64FA\u6500\u64FD\u6518\u651C\u6505\u6524\u6523\u652B\u6534\u6535\u6537\u6536\u6538\u754B\u6548\u6556\u6555\u654D\u6558\u655E\u655D\u6572\u6578\u6582\u6583\u8B8A\u659B\u659F\u65AB\u65B7\u65C3\u65C6\u65C1\u65C4\u65CC\u65D2\u65DB\u65D9\u65E0\u65E1\u65F1\u6772\u660A\u6603\u65FB\u6773\u6635\u6636\u6634\u661C\u664F\u6644\u6649\u6641\u665E\u665D\u6664\u6667\u6668\u665F\u6662\u6670\u6683\u6688\u668E\u6689\u6684\u6698\u669D\u66C1\u66B9\u66C9\u66BE\u66BC"],
    ["dba1", "\u66C4\u66B8\u66D6\u66DA\u66E0\u663F\u66E6\u66E9\u66F0\u66F5\u66F7\u670F\u6716\u671E\u6726\u6727\u9738\u672E\u673F\u6736\u6741\u6738\u6737\u6746\u675E\u6760\u6759\u6763\u6764\u6789\u6770\u67A9\u677C\u676A\u678C\u678B\u67A6\u67A1\u6785\u67B7\u67EF\u67B4\u67EC\u67B3\u67E9\u67B8\u67E4\u67DE\u67DD\u67E2\u67EE\u67B9\u67CE\u67C6\u67E7\u6A9C\u681E\u6846\u6829\u6840\u684D\u6832\u684E\u68B3\u682B\u6859\u6863\u6877\u687F\u689F\u688F\u68AD\u6894\u689D\u689B\u6883\u6AAE\u68B9\u6874\u68B5\u68A0\u68BA\u690F\u688D\u687E\u6901\u68CA\u6908\u68D8\u6922\u6926\u68E1\u690C\u68CD"],
    ["dca1", "\u68D4\u68E7\u68D5\u6936\u6912\u6904\u68D7\u68E3\u6925\u68F9\u68E0\u68EF\u6928\u692A\u691A\u6923\u6921\u68C6\u6979\u6977\u695C\u6978\u696B\u6954\u697E\u696E\u6939\u6974\u693D\u6959\u6930\u6961\u695E\u695D\u6981\u696A\u69B2\u69AE\u69D0\u69BF\u69C1\u69D3\u69BE\u69CE\u5BE8\u69CA\u69DD\u69BB\u69C3\u69A7\u6A2E\u6991\u69A0\u699C\u6995\u69B4\u69DE\u69E8\u6A02\u6A1B\u69FF\u6B0A\u69F9\u69F2\u69E7\u6A05\u69B1\u6A1E\u69ED\u6A14\u69EB\u6A0A\u6A12\u6AC1\u6A23\u6A13\u6A44\u6A0C\u6A72\u6A36\u6A78\u6A47\u6A62\u6A59\u6A66\u6A48\u6A38\u6A22\u6A90\u6A8D\u6AA0\u6A84\u6AA2\u6AA3"],
    ["dda1", "\u6A97\u8617\u6ABB\u6AC3\u6AC2\u6AB8\u6AB3\u6AAC\u6ADE\u6AD1\u6ADF\u6AAA\u6ADA\u6AEA\u6AFB\u6B05\u8616\u6AFA\u6B12\u6B16\u9B31\u6B1F\u6B38\u6B37\u76DC\u6B39\u98EE\u6B47\u6B43\u6B49\u6B50\u6B59\u6B54\u6B5B\u6B5F\u6B61\u6B78\u6B79\u6B7F\u6B80\u6B84\u6B83\u6B8D\u6B98\u6B95\u6B9E\u6BA4\u6BAA\u6BAB\u6BAF\u6BB2\u6BB1\u6BB3\u6BB7\u6BBC\u6BC6\u6BCB\u6BD3\u6BDF\u6BEC\u6BEB\u6BF3\u6BEF\u9EBE\u6C08\u6C13\u6C14\u6C1B\u6C24\u6C23\u6C5E\u6C55\u6C62\u6C6A\u6C82\u6C8D\u6C9A\u6C81\u6C9B\u6C7E\u6C68\u6C73\u6C92\u6C90\u6CC4\u6CF1\u6CD3\u6CBD\u6CD7\u6CC5\u6CDD\u6CAE\u6CB1\u6CBE"],
    ["dea1", "\u6CBA\u6CDB\u6CEF\u6CD9\u6CEA\u6D1F\u884D\u6D36\u6D2B\u6D3D\u6D38\u6D19\u6D35\u6D33\u6D12\u6D0C\u6D63\u6D93\u6D64\u6D5A\u6D79\u6D59\u6D8E\u6D95\u6FE4\u6D85\u6DF9\u6E15\u6E0A\u6DB5\u6DC7\u6DE6\u6DB8\u6DC6\u6DEC\u6DDE\u6DCC\u6DE8\u6DD2\u6DC5\u6DFA\u6DD9\u6DE4\u6DD5\u6DEA\u6DEE\u6E2D\u6E6E\u6E2E\u6E19\u6E72\u6E5F\u6E3E\u6E23\u6E6B\u6E2B\u6E76\u6E4D\u6E1F\u6E43\u6E3A\u6E4E\u6E24\u6EFF\u6E1D\u6E38\u6E82\u6EAA\u6E98\u6EC9\u6EB7\u6ED3\u6EBD\u6EAF\u6EC4\u6EB2\u6ED4\u6ED5\u6E8F\u6EA5\u6EC2\u6E9F\u6F41\u6F11\u704C\u6EEC\u6EF8\u6EFE\u6F3F\u6EF2\u6F31\u6EEF\u6F32\u6ECC"],
    ["dfa1", "\u6F3E\u6F13\u6EF7\u6F86\u6F7A\u6F78\u6F81\u6F80\u6F6F\u6F5B\u6FF3\u6F6D\u6F82\u6F7C\u6F58\u6F8E\u6F91\u6FC2\u6F66\u6FB3\u6FA3\u6FA1\u6FA4\u6FB9\u6FC6\u6FAA\u6FDF\u6FD5\u6FEC\u6FD4\u6FD8\u6FF1\u6FEE\u6FDB\u7009\u700B\u6FFA\u7011\u7001\u700F\u6FFE\u701B\u701A\u6F74\u701D\u7018\u701F\u7030\u703E\u7032\u7051\u7063\u7099\u7092\u70AF\u70F1\u70AC\u70B8\u70B3\u70AE\u70DF\u70CB\u70DD\u70D9\u7109\u70FD\u711C\u7119\u7165\u7155\u7188\u7166\u7162\u714C\u7156\u716C\u718F\u71FB\u7184\u7195\u71A8\u71AC\u71D7\u71B9\u71BE\u71D2\u71C9\u71D4\u71CE\u71E0\u71EC\u71E7\u71F5\u71FC"],
    ["e0a1", "\u71F9\u71FF\u720D\u7210\u721B\u7228\u722D\u722C\u7230\u7232\u723B\u723C\u723F\u7240\u7246\u724B\u7258\u7274\u727E\u7282\u7281\u7287\u7292\u7296\u72A2\u72A7\u72B9\u72B2\u72C3\u72C6\u72C4\u72CE\u72D2\u72E2\u72E0\u72E1\u72F9\u72F7\u500F\u7317\u730A\u731C\u7316\u731D\u7334\u732F\u7329\u7325\u733E\u734E\u734F\u9ED8\u7357\u736A\u7368\u7370\u7378\u7375\u737B\u737A\u73C8\u73B3\u73CE\u73BB\u73C0\u73E5\u73EE\u73DE\u74A2\u7405\u746F\u7425\u73F8\u7432\u743A\u7455\u743F\u745F\u7459\u7441\u745C\u7469\u7470\u7463\u746A\u7476\u747E\u748B\u749E\u74A7\u74CA\u74CF\u74D4\u73F1"],
    ["e1a1", "\u74E0\u74E3\u74E7\u74E9\u74EE\u74F2\u74F0\u74F1\u74F8\u74F7\u7504\u7503\u7505\u750C\u750E\u750D\u7515\u7513\u751E\u7526\u752C\u753C\u7544\u754D\u754A\u7549\u755B\u7546\u755A\u7569\u7564\u7567\u756B\u756D\u7578\u7576\u7586\u7587\u7574\u758A\u7589\u7582\u7594\u759A\u759D\u75A5\u75A3\u75C2\u75B3\u75C3\u75B5\u75BD\u75B8\u75BC\u75B1\u75CD\u75CA\u75D2\u75D9\u75E3\u75DE\u75FE\u75FF\u75FC\u7601\u75F0\u75FA\u75F2\u75F3\u760B\u760D\u7609\u761F\u7627\u7620\u7621\u7622\u7624\u7634\u7630\u763B\u7647\u7648\u7646\u765C\u7658\u7661\u7662\u7668\u7669\u766A\u7667\u766C\u7670"],
    ["e2a1", "\u7672\u7676\u7678\u767C\u7680\u7683\u7688\u768B\u768E\u7696\u7693\u7699\u769A\u76B0\u76B4\u76B8\u76B9\u76BA\u76C2\u76CD\u76D6\u76D2\u76DE\u76E1\u76E5\u76E7\u76EA\u862F\u76FB\u7708\u7707\u7704\u7729\u7724\u771E\u7725\u7726\u771B\u7737\u7738\u7747\u775A\u7768\u776B\u775B\u7765\u777F\u777E\u7779\u778E\u778B\u7791\u77A0\u779E\u77B0\u77B6\u77B9\u77BF\u77BC\u77BD\u77BB\u77C7\u77CD\u77D7\u77DA\u77DC\u77E3\u77EE\u77FC\u780C\u7812\u7926\u7820\u792A\u7845\u788E\u7874\u7886\u787C\u789A\u788C\u78A3\u78B5\u78AA\u78AF\u78D1\u78C6\u78CB\u78D4\u78BE\u78BC\u78C5\u78CA\u78EC"],
    ["e3a1", "\u78E7\u78DA\u78FD\u78F4\u7907\u7912\u7911\u7919\u792C\u792B\u7940\u7960\u7957\u795F\u795A\u7955\u7953\u797A\u797F\u798A\u799D\u79A7\u9F4B\u79AA\u79AE\u79B3\u79B9\u79BA\u79C9\u79D5\u79E7\u79EC\u79E1\u79E3\u7A08\u7A0D\u7A18\u7A19\u7A20\u7A1F\u7980\u7A31\u7A3B\u7A3E\u7A37\u7A43\u7A57\u7A49\u7A61\u7A62\u7A69\u9F9D\u7A70\u7A79\u7A7D\u7A88\u7A97\u7A95\u7A98\u7A96\u7AA9\u7AC8\u7AB0\u7AB6\u7AC5\u7AC4\u7ABF\u9083\u7AC7\u7ACA\u7ACD\u7ACF\u7AD5\u7AD3\u7AD9\u7ADA\u7ADD\u7AE1\u7AE2\u7AE6\u7AED\u7AF0\u7B02\u7B0F\u7B0A\u7B06\u7B33\u7B18\u7B19\u7B1E\u7B35\u7B28\u7B36\u7B50"],
    ["e4a1", "\u7B7A\u7B04\u7B4D\u7B0B\u7B4C\u7B45\u7B75\u7B65\u7B74\u7B67\u7B70\u7B71\u7B6C\u7B6E\u7B9D\u7B98\u7B9F\u7B8D\u7B9C\u7B9A\u7B8B\u7B92\u7B8F\u7B5D\u7B99\u7BCB\u7BC1\u7BCC\u7BCF\u7BB4\u7BC6\u7BDD\u7BE9\u7C11\u7C14\u7BE6\u7BE5\u7C60\u7C00\u7C07\u7C13\u7BF3\u7BF7\u7C17\u7C0D\u7BF6\u7C23\u7C27\u7C2A\u7C1F\u7C37\u7C2B\u7C3D\u7C4C\u7C43\u7C54\u7C4F\u7C40\u7C50\u7C58\u7C5F\u7C64\u7C56\u7C65\u7C6C\u7C75\u7C83\u7C90\u7CA4\u7CAD\u7CA2\u7CAB\u7CA1\u7CA8\u7CB3\u7CB2\u7CB1\u7CAE\u7CB9\u7CBD\u7CC0\u7CC5\u7CC2\u7CD8\u7CD2\u7CDC\u7CE2\u9B3B\u7CEF\u7CF2\u7CF4\u7CF6\u7CFA\u7D06"],
    ["e5a1", "\u7D02\u7D1C\u7D15\u7D0A\u7D45\u7D4B\u7D2E\u7D32\u7D3F\u7D35\u7D46\u7D73\u7D56\u7D4E\u7D72\u7D68\u7D6E\u7D4F\u7D63\u7D93\u7D89\u7D5B\u7D8F\u7D7D\u7D9B\u7DBA\u7DAE\u7DA3\u7DB5\u7DC7\u7DBD\u7DAB\u7E3D\u7DA2\u7DAF\u7DDC\u7DB8\u7D9F\u7DB0\u7DD8\u7DDD\u7DE4\u7DDE\u7DFB\u7DF2\u7DE1\u7E05\u7E0A\u7E23\u7E21\u7E12\u7E31\u7E1F\u7E09\u7E0B\u7E22\u7E46\u7E66\u7E3B\u7E35\u7E39\u7E43\u7E37\u7E32\u7E3A\u7E67\u7E5D\u7E56\u7E5E\u7E59\u7E5A\u7E79\u7E6A\u7E69\u7E7C\u7E7B\u7E83\u7DD5\u7E7D\u8FAE\u7E7F\u7E88\u7E89\u7E8C\u7E92\u7E90\u7E93\u7E94\u7E96\u7E8E\u7E9B\u7E9C\u7F38\u7F3A"],
    ["e6a1", "\u7F45\u7F4C\u7F4D\u7F4E\u7F50\u7F51\u7F55\u7F54\u7F58\u7F5F\u7F60\u7F68\u7F69\u7F67\u7F78\u7F82\u7F86\u7F83\u7F88\u7F87\u7F8C\u7F94\u7F9E\u7F9D\u7F9A\u7FA3\u7FAF\u7FB2\u7FB9\u7FAE\u7FB6\u7FB8\u8B71\u7FC5\u7FC6\u7FCA\u7FD5\u7FD4\u7FE1\u7FE6\u7FE9\u7FF3\u7FF9\u98DC\u8006\u8004\u800B\u8012\u8018\u8019\u801C\u8021\u8028\u803F\u803B\u804A\u8046\u8052\u8058\u805A\u805F\u8062\u8068\u8073\u8072\u8070\u8076\u8079\u807D\u807F\u8084\u8086\u8085\u809B\u8093\u809A\u80AD\u5190\u80AC\u80DB\u80E5\u80D9\u80DD\u80C4\u80DA\u80D6\u8109\u80EF\u80F1\u811B\u8129\u8123\u812F\u814B"],
    ["e7a1", "\u968B\u8146\u813E\u8153\u8151\u80FC\u8171\u816E\u8165\u8166\u8174\u8183\u8188\u818A\u8180\u8182\u81A0\u8195\u81A4\u81A3\u815F\u8193\u81A9\u81B0\u81B5\u81BE\u81B8\u81BD\u81C0\u81C2\u81BA\u81C9\u81CD\u81D1\u81D9\u81D8\u81C8\u81DA\u81DF\u81E0\u81E7\u81FA\u81FB\u81FE\u8201\u8202\u8205\u8207\u820A\u820D\u8210\u8216\u8229\u822B\u8238\u8233\u8240\u8259\u8258\u825D\u825A\u825F\u8264\u8262\u8268\u826A\u826B\u822E\u8271\u8277\u8278\u827E\u828D\u8292\u82AB\u829F\u82BB\u82AC\u82E1\u82E3\u82DF\u82D2\u82F4\u82F3\u82FA\u8393\u8303\u82FB\u82F9\u82DE\u8306\u82DC\u8309\u82D9"],
    ["e8a1", "\u8335\u8334\u8316\u8332\u8331\u8340\u8339\u8350\u8345\u832F\u832B\u8317\u8318\u8385\u839A\u83AA\u839F\u83A2\u8396\u8323\u838E\u8387\u838A\u837C\u83B5\u8373\u8375\u83A0\u8389\u83A8\u83F4\u8413\u83EB\u83CE\u83FD\u8403\u83D8\u840B\u83C1\u83F7\u8407\u83E0\u83F2\u840D\u8422\u8420\u83BD\u8438\u8506\u83FB\u846D\u842A\u843C\u855A\u8484\u8477\u846B\u84AD\u846E\u8482\u8469\u8446\u842C\u846F\u8479\u8435\u84CA\u8462\u84B9\u84BF\u849F\u84D9\u84CD\u84BB\u84DA\u84D0\u84C1\u84C6\u84D6\u84A1\u8521\u84FF\u84F4\u8517\u8518\u852C\u851F\u8515\u8514\u84FC\u8540\u8563\u8558\u8548"],
    ["e9a1", "\u8541\u8602\u854B\u8555\u8580\u85A4\u8588\u8591\u858A\u85A8\u856D\u8594\u859B\u85EA\u8587\u859C\u8577\u857E\u8590\u85C9\u85BA\u85CF\u85B9\u85D0\u85D5\u85DD\u85E5\u85DC\u85F9\u860A\u8613\u860B\u85FE\u85FA\u8606\u8622\u861A\u8630\u863F\u864D\u4E55\u8654\u865F\u8667\u8671\u8693\u86A3\u86A9\u86AA\u868B\u868C\u86B6\u86AF\u86C4\u86C6\u86B0\u86C9\u8823\u86AB\u86D4\u86DE\u86E9\u86EC\u86DF\u86DB\u86EF\u8712\u8706\u8708\u8700\u8703\u86FB\u8711\u8709\u870D\u86F9\u870A\u8734\u873F\u8737\u873B\u8725\u8729\u871A\u8760\u875F\u8778\u874C\u874E\u8774\u8757\u8768\u876E\u8759"],
    ["eaa1", "\u8753\u8763\u876A\u8805\u87A2\u879F\u8782\u87AF\u87CB\u87BD\u87C0\u87D0\u96D6\u87AB\u87C4\u87B3\u87C7\u87C6\u87BB\u87EF\u87F2\u87E0\u880F\u880D\u87FE\u87F6\u87F7\u880E\u87D2\u8811\u8816\u8815\u8822\u8821\u8831\u8836\u8839\u8827\u883B\u8844\u8842\u8852\u8859\u885E\u8862\u886B\u8881\u887E\u889E\u8875\u887D\u88B5\u8872\u8882\u8897\u8892\u88AE\u8899\u88A2\u888D\u88A4\u88B0\u88BF\u88B1\u88C3\u88C4\u88D4\u88D8\u88D9\u88DD\u88F9\u8902\u88FC\u88F4\u88E8\u88F2\u8904\u890C\u890A\u8913\u8943\u891E\u8925\u892A\u892B\u8941\u8944\u893B\u8936\u8938\u894C\u891D\u8960\u895E"],
    ["eba1", "\u8966\u8964\u896D\u896A\u896F\u8974\u8977\u897E\u8983\u8988\u898A\u8993\u8998\u89A1\u89A9\u89A6\u89AC\u89AF\u89B2\u89BA\u89BD\u89BF\u89C0\u89DA\u89DC\u89DD\u89E7\u89F4\u89F8\u8A03\u8A16\u8A10\u8A0C\u8A1B\u8A1D\u8A25\u8A36\u8A41\u8A5B\u8A52\u8A46\u8A48\u8A7C\u8A6D\u8A6C\u8A62\u8A85\u8A82\u8A84\u8AA8\u8AA1\u8A91\u8AA5\u8AA6\u8A9A\u8AA3\u8AC4\u8ACD\u8AC2\u8ADA\u8AEB\u8AF3\u8AE7\u8AE4\u8AF1\u8B14\u8AE0\u8AE2\u8AF7\u8ADE\u8ADB\u8B0C\u8B07\u8B1A\u8AE1\u8B16\u8B10\u8B17\u8B20\u8B33\u97AB\u8B26\u8B2B\u8B3E\u8B28\u8B41\u8B4C\u8B4F\u8B4E\u8B49\u8B56\u8B5B\u8B5A\u8B6B"],
    ["eca1", "\u8B5F\u8B6C\u8B6F\u8B74\u8B7D\u8B80\u8B8C\u8B8E\u8B92\u8B93\u8B96\u8B99\u8B9A\u8C3A\u8C41\u8C3F\u8C48\u8C4C\u8C4E\u8C50\u8C55\u8C62\u8C6C\u8C78\u8C7A\u8C82\u8C89\u8C85\u8C8A\u8C8D\u8C8E\u8C94\u8C7C\u8C98\u621D\u8CAD\u8CAA\u8CBD\u8CB2\u8CB3\u8CAE\u8CB6\u8CC8\u8CC1\u8CE4\u8CE3\u8CDA\u8CFD\u8CFA\u8CFB\u8D04\u8D05\u8D0A\u8D07\u8D0F\u8D0D\u8D10\u9F4E\u8D13\u8CCD\u8D14\u8D16\u8D67\u8D6D\u8D71\u8D73\u8D81\u8D99\u8DC2\u8DBE\u8DBA\u8DCF\u8DDA\u8DD6\u8DCC\u8DDB\u8DCB\u8DEA\u8DEB\u8DDF\u8DE3\u8DFC\u8E08\u8E09\u8DFF\u8E1D\u8E1E\u8E10\u8E1F\u8E42\u8E35\u8E30\u8E34\u8E4A"],
    ["eda1", "\u8E47\u8E49\u8E4C\u8E50\u8E48\u8E59\u8E64\u8E60\u8E2A\u8E63\u8E55\u8E76\u8E72\u8E7C\u8E81\u8E87\u8E85\u8E84\u8E8B\u8E8A\u8E93\u8E91\u8E94\u8E99\u8EAA\u8EA1\u8EAC\u8EB0\u8EC6\u8EB1\u8EBE\u8EC5\u8EC8\u8ECB\u8EDB\u8EE3\u8EFC\u8EFB\u8EEB\u8EFE\u8F0A\u8F05\u8F15\u8F12\u8F19\u8F13\u8F1C\u8F1F\u8F1B\u8F0C\u8F26\u8F33\u8F3B\u8F39\u8F45\u8F42\u8F3E\u8F4C\u8F49\u8F46\u8F4E\u8F57\u8F5C\u8F62\u8F63\u8F64\u8F9C\u8F9F\u8FA3\u8FAD\u8FAF\u8FB7\u8FDA\u8FE5\u8FE2\u8FEA\u8FEF\u9087\u8FF4\u9005\u8FF9\u8FFA\u9011\u9015\u9021\u900D\u901E\u9016\u900B\u9027\u9036\u9035\u9039\u8FF8"],
    ["eea1", "\u904F\u9050\u9051\u9052\u900E\u9049\u903E\u9056\u9058\u905E\u9068\u906F\u9076\u96A8\u9072\u9082\u907D\u9081\u9080\u908A\u9089\u908F\u90A8\u90AF\u90B1\u90B5\u90E2\u90E4\u6248\u90DB\u9102\u9112\u9119\u9132\u9130\u914A\u9156\u9158\u9163\u9165\u9169\u9173\u9172\u918B\u9189\u9182\u91A2\u91AB\u91AF\u91AA\u91B5\u91B4\u91BA\u91C0\u91C1\u91C9\u91CB\u91D0\u91D6\u91DF\u91E1\u91DB\u91FC\u91F5\u91F6\u921E\u91FF\u9214\u922C\u9215\u9211\u925E\u9257\u9245\u9249\u9264\u9248\u9295\u923F\u924B\u9250\u929C\u9296\u9293\u929B\u925A\u92CF\u92B9\u92B7\u92E9\u930F\u92FA\u9344\u932E"],
    ["efa1", "\u9319\u9322\u931A\u9323\u933A\u9335\u933B\u935C\u9360\u937C\u936E\u9356\u93B0\u93AC\u93AD\u9394\u93B9\u93D6\u93D7\u93E8\u93E5\u93D8\u93C3\u93DD\u93D0\u93C8\u93E4\u941A\u9414\u9413\u9403\u9407\u9410\u9436\u942B\u9435\u9421\u943A\u9441\u9452\u9444\u945B\u9460\u9462\u945E\u946A\u9229\u9470\u9475\u9477\u947D\u945A\u947C\u947E\u9481\u947F\u9582\u9587\u958A\u9594\u9596\u9598\u9599\u95A0\u95A8\u95A7\u95AD\u95BC\u95BB\u95B9\u95BE\u95CA\u6FF6\u95C3\u95CD\u95CC\u95D5\u95D4\u95D6\u95DC\u95E1\u95E5\u95E2\u9621\u9628\u962E\u962F\u9642\u964C\u964F\u964B\u9677\u965C\u965E"],
    ["f0a1", "\u965D\u965F\u9666\u9672\u966C\u968D\u9698\u9695\u9697\u96AA\u96A7\u96B1\u96B2\u96B0\u96B4\u96B6\u96B8\u96B9\u96CE\u96CB\u96C9\u96CD\u894D\u96DC\u970D\u96D5\u96F9\u9704\u9706\u9708\u9713\u970E\u9711\u970F\u9716\u9719\u9724\u972A\u9730\u9739\u973D\u973E\u9744\u9746\u9748\u9742\u9749\u975C\u9760\u9764\u9766\u9768\u52D2\u976B\u9771\u9779\u9785\u977C\u9781\u977A\u9786\u978B\u978F\u9790\u979C\u97A8\u97A6\u97A3\u97B3\u97B4\u97C3\u97C6\u97C8\u97CB\u97DC\u97ED\u9F4F\u97F2\u7ADF\u97F6\u97F5\u980F\u980C\u9838\u9824\u9821\u9837\u983D\u9846\u984F\u984B\u986B\u986F\u9870"],
    ["f1a1", "\u9871\u9874\u9873\u98AA\u98AF\u98B1\u98B6\u98C4\u98C3\u98C6\u98E9\u98EB\u9903\u9909\u9912\u9914\u9918\u9921\u991D\u991E\u9924\u9920\u992C\u992E\u993D\u993E\u9942\u9949\u9945\u9950\u994B\u9951\u9952\u994C\u9955\u9997\u9998\u99A5\u99AD\u99AE\u99BC\u99DF\u99DB\u99DD\u99D8\u99D1\u99ED\u99EE\u99F1\u99F2\u99FB\u99F8\u9A01\u9A0F\u9A05\u99E2\u9A19\u9A2B\u9A37\u9A45\u9A42\u9A40\u9A43\u9A3E\u9A55\u9A4D\u9A5B\u9A57\u9A5F\u9A62\u9A65\u9A64\u9A69\u9A6B\u9A6A\u9AAD\u9AB0\u9ABC\u9AC0\u9ACF\u9AD1\u9AD3\u9AD4\u9ADE\u9ADF\u9AE2\u9AE3\u9AE6\u9AEF\u9AEB\u9AEE\u9AF4\u9AF1\u9AF7"],
    ["f2a1", "\u9AFB\u9B06\u9B18\u9B1A\u9B1F\u9B22\u9B23\u9B25\u9B27\u9B28\u9B29\u9B2A\u9B2E\u9B2F\u9B32\u9B44\u9B43\u9B4F\u9B4D\u9B4E\u9B51\u9B58\u9B74\u9B93\u9B83\u9B91\u9B96\u9B97\u9B9F\u9BA0\u9BA8\u9BB4\u9BC0\u9BCA\u9BB9\u9BC6\u9BCF\u9BD1\u9BD2\u9BE3\u9BE2\u9BE4\u9BD4\u9BE1\u9C3A\u9BF2\u9BF1\u9BF0\u9C15\u9C14\u9C09\u9C13\u9C0C\u9C06\u9C08\u9C12\u9C0A\u9C04\u9C2E\u9C1B\u9C25\u9C24\u9C21\u9C30\u9C47\u9C32\u9C46\u9C3E\u9C5A\u9C60\u9C67\u9C76\u9C78\u9CE7\u9CEC\u9CF0\u9D09\u9D08\u9CEB\u9D03\u9D06\u9D2A\u9D26\u9DAF\u9D23\u9D1F\u9D44\u9D15\u9D12\u9D41\u9D3F\u9D3E\u9D46\u9D48"],
    ["f3a1", "\u9D5D\u9D5E\u9D64\u9D51\u9D50\u9D59\u9D72\u9D89\u9D87\u9DAB\u9D6F\u9D7A\u9D9A\u9DA4\u9DA9\u9DB2\u9DC4\u9DC1\u9DBB\u9DB8\u9DBA\u9DC6\u9DCF\u9DC2\u9DD9\u9DD3\u9DF8\u9DE6\u9DED\u9DEF\u9DFD\u9E1A\u9E1B\u9E1E\u9E75\u9E79\u9E7D\u9E81\u9E88\u9E8B\u9E8C\u9E92\u9E95\u9E91\u9E9D\u9EA5\u9EA9\u9EB8\u9EAA\u9EAD\u9761\u9ECC\u9ECE\u9ECF\u9ED0\u9ED4\u9EDC\u9EDE\u9EDD\u9EE0\u9EE5\u9EE8\u9EEF\u9EF4\u9EF6\u9EF7\u9EF9\u9EFB\u9EFC\u9EFD\u9F07\u9F08\u76B7\u9F15\u9F21\u9F2C\u9F3E\u9F4A\u9F52\u9F54\u9F63\u9F5F\u9F60\u9F61\u9F66\u9F67\u9F6C\u9F6A\u9F77\u9F72\u9F76\u9F95\u9F9C\u9FA0"],
    ["f4a1", "\u582F\u69C7\u9059\u7464\u51DC\u7199"],
    ["f9a1", "\u7E8A\u891C\u9348\u9288\u84DC\u4FC9\u70BB\u6631\u68C8\u92F9\u66FB\u5F45\u4E28\u4EE1\u4EFC\u4F00\u4F03\u4F39\u4F56\u4F92\u4F8A\u4F9A\u4F94\u4FCD\u5040\u5022\u4FFF\u501E\u5046\u5070\u5042\u5094\u50F4\u50D8\u514A\u5164\u519D\u51BE\u51EC\u5215\u529C\u52A6\u52C0\u52DB\u5300\u5307\u5324\u5372\u5393\u53B2\u53DD\uFA0E\u549C\u548A\u54A9\u54FF\u5586\u5759\u5765\u57AC\u57C8\u57C7\uFA0F\uFA10\u589E\u58B2\u590B\u5953\u595B\u595D\u5963\u59A4\u59BA\u5B56\u5BC0\u752F\u5BD8\u5BEC\u5C1E\u5CA6\u5CBA\u5CF5\u5D27\u5D53\uFA11\u5D42\u5D6D\u5DB8\u5DB9\u5DD0\u5F21\u5F34\u5F67\u5FB7"],
    ["faa1", "\u5FDE\u605D\u6085\u608A\u60DE\u60D5\u6120\u60F2\u6111\u6137\u6130\u6198\u6213\u62A6\u63F5\u6460\u649D\u64CE\u654E\u6600\u6615\u663B\u6609\u662E\u661E\u6624\u6665\u6657\u6659\uFA12\u6673\u6699\u66A0\u66B2\u66BF\u66FA\u670E\uF929\u6766\u67BB\u6852\u67C0\u6801\u6844\u68CF\uFA13\u6968\uFA14\u6998\u69E2\u6A30\u6A6B\u6A46\u6A73\u6A7E\u6AE2\u6AE4\u6BD6\u6C3F\u6C5C\u6C86\u6C6F\u6CDA\u6D04\u6D87\u6D6F\u6D96\u6DAC\u6DCF\u6DF8\u6DF2\u6DFC\u6E39\u6E5C\u6E27\u6E3C\u6EBF\u6F88\u6FB5\u6FF5\u7005\u7007\u7028\u7085\u70AB\u710F\u7104\u715C\u7146\u7147\uFA15\u71C1\u71FE\u72B1"],
    ["fba1", "\u72BE\u7324\uFA16\u7377\u73BD\u73C9\u73D6\u73E3\u73D2\u7407\u73F5\u7426\u742A\u7429\u742E\u7462\u7489\u749F\u7501\u756F\u7682\u769C\u769E\u769B\u76A6\uFA17\u7746\u52AF\u7821\u784E\u7864\u787A\u7930\uFA18\uFA19\uFA1A\u7994\uFA1B\u799B\u7AD1\u7AE7\uFA1C\u7AEB\u7B9E\uFA1D\u7D48\u7D5C\u7DB7\u7DA0\u7DD6\u7E52\u7F47\u7FA1\uFA1E\u8301\u8362\u837F\u83C7\u83F6\u8448\u84B4\u8553\u8559\u856B\uFA1F\u85B0\uFA20\uFA21\u8807\u88F5\u8A12\u8A37\u8A79\u8AA7\u8ABE\u8ADF\uFA22\u8AF6\u8B53\u8B7F\u8CF0\u8CF4\u8D12\u8D76\uFA23\u8ECF\uFA24\uFA25\u9067\u90DE\uFA26\u9115\u9127\u91DA"],
    ["fca1", "\u91D7\u91DE\u91ED\u91EE\u91E4\u91E5\u9206\u9210\u920A\u923A\u9240\u923C\u924E\u9259\u9251\u9239\u9267\u92A7\u9277\u9278\u92E7\u92D7\u92D9\u92D0\uFA27\u92D5\u92E0\u92D3\u9325\u9321\u92FB\uFA28\u931E\u92FF\u931D\u9302\u9370\u9357\u93A4\u93C6\u93DE\u93F8\u9431\u9445\u9448\u9592\uF9DC\uFA29\u969D\u96AF\u9733\u973B\u9743\u974D\u974F\u9751\u9755\u9857\u9865\uFA2A\uFA2B\u9927\uFA2C\u999E\u9A4E\u9AD9\u9ADC\u9B75\u9B72\u9B8F\u9BB1\u9BBB\u9C00\u9D70\u9D6B\uFA2D\u9E19\u9ED1"],
    ["fcf1", "\u2170", 9, "\uFFE2\uFFE4\uFF07\uFF02"],
    ["8fa2af", "\u02D8\u02C7\xB8\u02D9\u02DD\xAF\u02DB\u02DA\uFF5E\u0384\u0385"],
    ["8fa2c2", "\xA1\xA6\xBF"],
    ["8fa2eb", "\xBA\xAA\xA9\xAE\u2122\xA4\u2116"],
    ["8fa6e1", "\u0386\u0388\u0389\u038A\u03AA"],
    ["8fa6e7", "\u038C"],
    ["8fa6e9", "\u038E\u03AB"],
    ["8fa6ec", "\u038F"],
    ["8fa6f1", "\u03AC\u03AD\u03AE\u03AF\u03CA\u0390\u03CC\u03C2\u03CD\u03CB\u03B0\u03CE"],
    ["8fa7c2", "\u0402", 10, "\u040E\u040F"],
    ["8fa7f2", "\u0452", 10, "\u045E\u045F"],
    ["8fa9a1", "\xC6\u0110"],
    ["8fa9a4", "\u0126"],
    ["8fa9a6", "\u0132"],
    ["8fa9a8", "\u0141\u013F"],
    ["8fa9ab", "\u014A\xD8\u0152"],
    ["8fa9af", "\u0166\xDE"],
    ["8fa9c1", "\xE6\u0111\xF0\u0127\u0131\u0133\u0138\u0142\u0140\u0149\u014B\xF8\u0153\xDF\u0167\xFE"],
    ["8faaa1", "\xC1\xC0\xC4\xC2\u0102\u01CD\u0100\u0104\xC5\xC3\u0106\u0108\u010C\xC7\u010A\u010E\xC9\xC8\xCB\xCA\u011A\u0116\u0112\u0118"],
    ["8faaba", "\u011C\u011E\u0122\u0120\u0124\xCD\xCC\xCF\xCE\u01CF\u0130\u012A\u012E\u0128\u0134\u0136\u0139\u013D\u013B\u0143\u0147\u0145\xD1\xD3\xD2\xD6\xD4\u01D1\u0150\u014C\xD5\u0154\u0158\u0156\u015A\u015C\u0160\u015E\u0164\u0162\xDA\xD9\xDC\xDB\u016C\u01D3\u0170\u016A\u0172\u016E\u0168\u01D7\u01DB\u01D9\u01D5\u0174\xDD\u0178\u0176\u0179\u017D\u017B"],
    ["8faba1", "\xE1\xE0\xE4\xE2\u0103\u01CE\u0101\u0105\xE5\xE3\u0107\u0109\u010D\xE7\u010B\u010F\xE9\xE8\xEB\xEA\u011B\u0117\u0113\u0119\u01F5\u011D\u011F"],
    ["8fabbd", "\u0121\u0125\xED\xEC\xEF\xEE\u01D0"],
    ["8fabc5", "\u012B\u012F\u0129\u0135\u0137\u013A\u013E\u013C\u0144\u0148\u0146\xF1\xF3\xF2\xF6\xF4\u01D2\u0151\u014D\xF5\u0155\u0159\u0157\u015B\u015D\u0161\u015F\u0165\u0163\xFA\xF9\xFC\xFB\u016D\u01D4\u0171\u016B\u0173\u016F\u0169\u01D8\u01DC\u01DA\u01D6\u0175\xFD\xFF\u0177\u017A\u017E\u017C"],
    ["8fb0a1", "\u4E02\u4E04\u4E05\u4E0C\u4E12\u4E1F\u4E23\u4E24\u4E28\u4E2B\u4E2E\u4E2F\u4E30\u4E35\u4E40\u4E41\u4E44\u4E47\u4E51\u4E5A\u4E5C\u4E63\u4E68\u4E69\u4E74\u4E75\u4E79\u4E7F\u4E8D\u4E96\u4E97\u4E9D\u4EAF\u4EB9\u4EC3\u4ED0\u4EDA\u4EDB\u4EE0\u4EE1\u4EE2\u4EE8\u4EEF\u4EF1\u4EF3\u4EF5\u4EFD\u4EFE\u4EFF\u4F00\u4F02\u4F03\u4F08\u4F0B\u4F0C\u4F12\u4F15\u4F16\u4F17\u4F19\u4F2E\u4F31\u4F60\u4F33\u4F35\u4F37\u4F39\u4F3B\u4F3E\u4F40\u4F42\u4F48\u4F49\u4F4B\u4F4C\u4F52\u4F54\u4F56\u4F58\u4F5F\u4F63\u4F6A\u4F6C\u4F6E\u4F71\u4F77\u4F78\u4F79\u4F7A\u4F7D\u4F7E\u4F81\u4F82\u4F84"],
    ["8fb1a1", "\u4F85\u4F89\u4F8A\u4F8C\u4F8E\u4F90\u4F92\u4F93\u4F94\u4F97\u4F99\u4F9A\u4F9E\u4F9F\u4FB2\u4FB7\u4FB9\u4FBB\u4FBC\u4FBD\u4FBE\u4FC0\u4FC1\u4FC5\u4FC6\u4FC8\u4FC9\u4FCB\u4FCC\u4FCD\u4FCF\u4FD2\u4FDC\u4FE0\u4FE2\u4FF0\u4FF2\u4FFC\u4FFD\u4FFF\u5000\u5001\u5004\u5007\u500A\u500C\u500E\u5010\u5013\u5017\u5018\u501B\u501C\u501D\u501E\u5022\u5027\u502E\u5030\u5032\u5033\u5035\u5040\u5041\u5042\u5045\u5046\u504A\u504C\u504E\u5051\u5052\u5053\u5057\u5059\u505F\u5060\u5062\u5063\u5066\u5067\u506A\u506D\u5070\u5071\u503B\u5081\u5083\u5084\u5086\u508A\u508E\u508F\u5090"],
    ["8fb2a1", "\u5092\u5093\u5094\u5096\u509B\u509C\u509E", 4, "\u50AA\u50AF\u50B0\u50B9\u50BA\u50BD\u50C0\u50C3\u50C4\u50C7\u50CC\u50CE\u50D0\u50D3\u50D4\u50D8\u50DC\u50DD\u50DF\u50E2\u50E4\u50E6\u50E8\u50E9\u50EF\u50F1\u50F6\u50FA\u50FE\u5103\u5106\u5107\u5108\u510B\u510C\u510D\u510E\u50F2\u5110\u5117\u5119\u511B\u511C\u511D\u511E\u5123\u5127\u5128\u512C\u512D\u512F\u5131\u5133\u5134\u5135\u5138\u5139\u5142\u514A\u514F\u5153\u5155\u5157\u5158\u515F\u5164\u5166\u517E\u5183\u5184\u518B\u518E\u5198\u519D\u51A1\u51A3\u51AD\u51B8\u51BA\u51BC\u51BE\u51BF\u51C2"],
    ["8fb3a1", "\u51C8\u51CF\u51D1\u51D2\u51D3\u51D5\u51D8\u51DE\u51E2\u51E5\u51EE\u51F2\u51F3\u51F4\u51F7\u5201\u5202\u5205\u5212\u5213\u5215\u5216\u5218\u5222\u5228\u5231\u5232\u5235\u523C\u5245\u5249\u5255\u5257\u5258\u525A\u525C\u525F\u5260\u5261\u5266\u526E\u5277\u5278\u5279\u5280\u5282\u5285\u528A\u528C\u5293\u5295\u5296\u5297\u5298\u529A\u529C\u52A4\u52A5\u52A6\u52A7\u52AF\u52B0\u52B6\u52B7\u52B8\u52BA\u52BB\u52BD\u52C0\u52C4\u52C6\u52C8\u52CC\u52CF\u52D1\u52D4\u52D6\u52DB\u52DC\u52E1\u52E5\u52E8\u52E9\u52EA\u52EC\u52F0\u52F1\u52F4\u52F6\u52F7\u5300\u5303\u530A\u530B"],
    ["8fb4a1", "\u530C\u5311\u5313\u5318\u531B\u531C\u531E\u531F\u5325\u5327\u5328\u5329\u532B\u532C\u532D\u5330\u5332\u5335\u533C\u533D\u533E\u5342\u534C\u534B\u5359\u535B\u5361\u5363\u5365\u536C\u536D\u5372\u5379\u537E\u5383\u5387\u5388\u538E\u5393\u5394\u5399\u539D\u53A1\u53A4\u53AA\u53AB\u53AF\u53B2\u53B4\u53B5\u53B7\u53B8\u53BA\u53BD\u53C0\u53C5\u53CF\u53D2\u53D3\u53D5\u53DA\u53DD\u53DE\u53E0\u53E6\u53E7\u53F5\u5402\u5413\u541A\u5421\u5427\u5428\u542A\u542F\u5431\u5434\u5435\u5443\u5444\u5447\u544D\u544F\u545E\u5462\u5464\u5466\u5467\u5469\u546B\u546D\u546E\u5474\u547F"],
    ["8fb5a1", "\u5481\u5483\u5485\u5488\u5489\u548D\u5491\u5495\u5496\u549C\u549F\u54A1\u54A6\u54A7\u54A9\u54AA\u54AD\u54AE\u54B1\u54B7\u54B9\u54BA\u54BB\u54BF\u54C6\u54CA\u54CD\u54CE\u54E0\u54EA\u54EC\u54EF\u54F6\u54FC\u54FE\u54FF\u5500\u5501\u5505\u5508\u5509\u550C\u550D\u550E\u5515\u552A\u552B\u5532\u5535\u5536\u553B\u553C\u553D\u5541\u5547\u5549\u554A\u554D\u5550\u5551\u5558\u555A\u555B\u555E\u5560\u5561\u5564\u5566\u557F\u5581\u5582\u5586\u5588\u558E\u558F\u5591\u5592\u5593\u5594\u5597\u55A3\u55A4\u55AD\u55B2\u55BF\u55C1\u55C3\u55C6\u55C9\u55CB\u55CC\u55CE\u55D1\u55D2"],
    ["8fb6a1", "\u55D3\u55D7\u55D8\u55DB\u55DE\u55E2\u55E9\u55F6\u55FF\u5605\u5608\u560A\u560D", 5, "\u5619\u562C\u5630\u5633\u5635\u5637\u5639\u563B\u563C\u563D\u563F\u5640\u5641\u5643\u5644\u5646\u5649\u564B\u564D\u564F\u5654\u565E\u5660\u5661\u5662\u5663\u5666\u5669\u566D\u566F\u5671\u5672\u5675\u5684\u5685\u5688\u568B\u568C\u5695\u5699\u569A\u569D\u569E\u569F\u56A6\u56A7\u56A8\u56A9\u56AB\u56AC\u56AD\u56B1\u56B3\u56B7\u56BE\u56C5\u56C9\u56CA\u56CB\u56CF\u56D0\u56CC\u56CD\u56D9\u56DC\u56DD\u56DF\u56E1\u56E4", 4, "\u56F1\u56EB\u56ED"],
    ["8fb7a1", "\u56F6\u56F7\u5701\u5702\u5707\u570A\u570C\u5711\u5715\u571A\u571B\u571D\u5720\u5722\u5723\u5724\u5725\u5729\u572A\u572C\u572E\u572F\u5733\u5734\u573D\u573E\u573F\u5745\u5746\u574C\u574D\u5752\u5762\u5765\u5767\u5768\u576B\u576D", 4, "\u5773\u5774\u5775\u5777\u5779\u577A\u577B\u577C\u577E\u5781\u5783\u578C\u5794\u5797\u5799\u579A\u579C\u579D\u579E\u579F\u57A1\u5795\u57A7\u57A8\u57A9\u57AC\u57B8\u57BD\u57C7\u57C8\u57CC\u57CF\u57D5\u57DD\u57DE\u57E4\u57E6\u57E7\u57E9\u57ED\u57F0\u57F5\u57F6\u57F8\u57FD\u57FE\u57FF\u5803\u5804\u5808\u5809\u57E1"],
    ["8fb8a1", "\u580C\u580D\u581B\u581E\u581F\u5820\u5826\u5827\u582D\u5832\u5839\u583F\u5849\u584C\u584D\u584F\u5850\u5855\u585F\u5861\u5864\u5867\u5868\u5878\u587C\u587F\u5880\u5881\u5887\u5888\u5889\u588A\u588C\u588D\u588F\u5890\u5894\u5896\u589D\u58A0\u58A1\u58A2\u58A6\u58A9\u58B1\u58B2\u58C4\u58BC\u58C2\u58C8\u58CD\u58CE\u58D0\u58D2\u58D4\u58D6\u58DA\u58DD\u58E1\u58E2\u58E9\u58F3\u5905\u5906\u590B\u590C\u5912\u5913\u5914\u8641\u591D\u5921\u5923\u5924\u5928\u592F\u5930\u5933\u5935\u5936\u593F\u5943\u5946\u5952\u5953\u5959\u595B\u595D\u595E\u595F\u5961\u5963\u596B\u596D"],
    ["8fb9a1", "\u596F\u5972\u5975\u5976\u5979\u597B\u597C\u598B\u598C\u598E\u5992\u5995\u5997\u599F\u59A4\u59A7\u59AD\u59AE\u59AF\u59B0\u59B3\u59B7\u59BA\u59BC\u59C1\u59C3\u59C4\u59C8\u59CA\u59CD\u59D2\u59DD\u59DE\u59DF\u59E3\u59E4\u59E7\u59EE\u59EF\u59F1\u59F2\u59F4\u59F7\u5A00\u5A04\u5A0C\u5A0D\u5A0E\u5A12\u5A13\u5A1E\u5A23\u5A24\u5A27\u5A28\u5A2A\u5A2D\u5A30\u5A44\u5A45\u5A47\u5A48\u5A4C\u5A50\u5A55\u5A5E\u5A63\u5A65\u5A67\u5A6D\u5A77\u5A7A\u5A7B\u5A7E\u5A8B\u5A90\u5A93\u5A96\u5A99\u5A9C\u5A9E\u5A9F\u5AA0\u5AA2\u5AA7\u5AAC\u5AB1\u5AB2\u5AB3\u5AB5\u5AB8\u5ABA\u5ABB\u5ABF"],
    ["8fbaa1", "\u5AC4\u5AC6\u5AC8\u5ACF\u5ADA\u5ADC\u5AE0\u5AE5\u5AEA\u5AEE\u5AF5\u5AF6\u5AFD\u5B00\u5B01\u5B08\u5B17\u5B34\u5B19\u5B1B\u5B1D\u5B21\u5B25\u5B2D\u5B38\u5B41\u5B4B\u5B4C\u5B52\u5B56\u5B5E\u5B68\u5B6E\u5B6F\u5B7C\u5B7D\u5B7E\u5B7F\u5B81\u5B84\u5B86\u5B8A\u5B8E\u5B90\u5B91\u5B93\u5B94\u5B96\u5BA8\u5BA9\u5BAC\u5BAD\u5BAF\u5BB1\u5BB2\u5BB7\u5BBA\u5BBC\u5BC0\u5BC1\u5BCD\u5BCF\u5BD6", 4, "\u5BE0\u5BEF\u5BF1\u5BF4\u5BFD\u5C0C\u5C17\u5C1E\u5C1F\u5C23\u5C26\u5C29\u5C2B\u5C2C\u5C2E\u5C30\u5C32\u5C35\u5C36\u5C59\u5C5A\u5C5C\u5C62\u5C63\u5C67\u5C68\u5C69"],
    ["8fbba1", "\u5C6D\u5C70\u5C74\u5C75\u5C7A\u5C7B\u5C7C\u5C7D\u5C87\u5C88\u5C8A\u5C8F\u5C92\u5C9D\u5C9F\u5CA0\u5CA2\u5CA3\u5CA6\u5CAA\u5CB2\u5CB4\u5CB5\u5CBA\u5CC9\u5CCB\u5CD2\u5CDD\u5CD7\u5CEE\u5CF1\u5CF2\u5CF4\u5D01\u5D06\u5D0D\u5D12\u5D2B\u5D23\u5D24\u5D26\u5D27\u5D31\u5D34\u5D39\u5D3D\u5D3F\u5D42\u5D43\u5D46\u5D48\u5D55\u5D51\u5D59\u5D4A\u5D5F\u5D60\u5D61\u5D62\u5D64\u5D6A\u5D6D\u5D70\u5D79\u5D7A\u5D7E\u5D7F\u5D81\u5D83\u5D88\u5D8A\u5D92\u5D93\u5D94\u5D95\u5D99\u5D9B\u5D9F\u5DA0\u5DA7\u5DAB\u5DB0\u5DB4\u5DB8\u5DB9\u5DC3\u5DC7\u5DCB\u5DD0\u5DCE\u5DD8\u5DD9\u5DE0\u5DE4"],
    ["8fbca1", "\u5DE9\u5DF8\u5DF9\u5E00\u5E07\u5E0D\u5E12\u5E14\u5E15\u5E18\u5E1F\u5E20\u5E2E\u5E28\u5E32\u5E35\u5E3E\u5E4B\u5E50\u5E49\u5E51\u5E56\u5E58\u5E5B\u5E5C\u5E5E\u5E68\u5E6A", 4, "\u5E70\u5E80\u5E8B\u5E8E\u5EA2\u5EA4\u5EA5\u5EA8\u5EAA\u5EAC\u5EB1\u5EB3\u5EBD\u5EBE\u5EBF\u5EC6\u5ECC\u5ECB\u5ECE\u5ED1\u5ED2\u5ED4\u5ED5\u5EDC\u5EDE\u5EE5\u5EEB\u5F02\u5F06\u5F07\u5F08\u5F0E\u5F19\u5F1C\u5F1D\u5F21\u5F22\u5F23\u5F24\u5F28\u5F2B\u5F2C\u5F2E\u5F30\u5F34\u5F36\u5F3B\u5F3D\u5F3F\u5F40\u5F44\u5F45\u5F47\u5F4D\u5F50\u5F54\u5F58\u5F5B\u5F60\u5F63\u5F64\u5F67"],
    ["8fbda1", "\u5F6F\u5F72\u5F74\u5F75\u5F78\u5F7A\u5F7D\u5F7E\u5F89\u5F8D\u5F8F\u5F96\u5F9C\u5F9D\u5FA2\u5FA7\u5FAB\u5FA4\u5FAC\u5FAF\u5FB0\u5FB1\u5FB8\u5FC4\u5FC7\u5FC8\u5FC9\u5FCB\u5FD0", 4, "\u5FDE\u5FE1\u5FE2\u5FE8\u5FE9\u5FEA\u5FEC\u5FED\u5FEE\u5FEF\u5FF2\u5FF3\u5FF6\u5FFA\u5FFC\u6007\u600A\u600D\u6013\u6014\u6017\u6018\u601A\u601F\u6024\u602D\u6033\u6035\u6040\u6047\u6048\u6049\u604C\u6051\u6054\u6056\u6057\u605D\u6061\u6067\u6071\u607E\u607F\u6082\u6086\u6088\u608A\u608E\u6091\u6093\u6095\u6098\u609D\u609E\u60A2\u60A4\u60A5\u60A8\u60B0\u60B1\u60B7"],
    ["8fbea1", "\u60BB\u60BE\u60C2\u60C4\u60C8\u60C9\u60CA\u60CB\u60CE\u60CF\u60D4\u60D5\u60D9\u60DB\u60DD\u60DE\u60E2\u60E5\u60F2\u60F5\u60F8\u60FC\u60FD\u6102\u6107\u610A\u610C\u6110", 4, "\u6116\u6117\u6119\u611C\u611E\u6122\u612A\u612B\u6130\u6131\u6135\u6136\u6137\u6139\u6141\u6145\u6146\u6149\u615E\u6160\u616C\u6172\u6178\u617B\u617C\u617F\u6180\u6181\u6183\u6184\u618B\u618D\u6192\u6193\u6197\u6198\u619C\u619D\u619F\u61A0\u61A5\u61A8\u61AA\u61AD\u61B8\u61B9\u61BC\u61C0\u61C1\u61C2\u61CE\u61CF\u61D5\u61DC\u61DD\u61DE\u61DF\u61E1\u61E2\u61E7\u61E9\u61E5"],
    ["8fbfa1", "\u61EC\u61ED\u61EF\u6201\u6203\u6204\u6207\u6213\u6215\u621C\u6220\u6222\u6223\u6227\u6229\u622B\u6239\u623D\u6242\u6243\u6244\u6246\u624C\u6250\u6251\u6252\u6254\u6256\u625A\u625C\u6264\u626D\u626F\u6273\u627A\u627D\u628D\u628E\u628F\u6290\u62A6\u62A8\u62B3\u62B6\u62B7\u62BA\u62BE\u62BF\u62C4\u62CE\u62D5\u62D6\u62DA\u62EA\u62F2\u62F4\u62FC\u62FD\u6303\u6304\u630A\u630B\u630D\u6310\u6313\u6316\u6318\u6329\u632A\u632D\u6335\u6336\u6339\u633C\u6341\u6342\u6343\u6344\u6346\u634A\u634B\u634E\u6352\u6353\u6354\u6358\u635B\u6365\u6366\u636C\u636D\u6371\u6374\u6375"],
    ["8fc0a1", "\u6378\u637C\u637D\u637F\u6382\u6384\u6387\u638A\u6390\u6394\u6395\u6399\u639A\u639E\u63A4\u63A6\u63AD\u63AE\u63AF\u63BD\u63C1\u63C5\u63C8\u63CE\u63D1\u63D3\u63D4\u63D5\u63DC\u63E0\u63E5\u63EA\u63EC\u63F2\u63F3\u63F5\u63F8\u63F9\u6409\u640A\u6410\u6412\u6414\u6418\u641E\u6420\u6422\u6424\u6425\u6429\u642A\u642F\u6430\u6435\u643D\u643F\u644B\u644F\u6451\u6452\u6453\u6454\u645A\u645B\u645C\u645D\u645F\u6460\u6461\u6463\u646D\u6473\u6474\u647B\u647D\u6485\u6487\u648F\u6490\u6491\u6498\u6499\u649B\u649D\u649F\u64A1\u64A3\u64A6\u64A8\u64AC\u64B3\u64BD\u64BE\u64BF"],
    ["8fc1a1", "\u64C4\u64C9\u64CA\u64CB\u64CC\u64CE\u64D0\u64D1\u64D5\u64D7\u64E4\u64E5\u64E9\u64EA\u64ED\u64F0\u64F5\u64F7\u64FB\u64FF\u6501\u6504\u6508\u6509\u650A\u650F\u6513\u6514\u6516\u6519\u651B\u651E\u651F\u6522\u6526\u6529\u652E\u6531\u653A\u653C\u653D\u6543\u6547\u6549\u6550\u6552\u6554\u655F\u6560\u6567\u656B\u657A\u657D\u6581\u6585\u658A\u6592\u6595\u6598\u659D\u65A0\u65A3\u65A6\u65AE\u65B2\u65B3\u65B4\u65BF\u65C2\u65C8\u65C9\u65CE\u65D0\u65D4\u65D6\u65D8\u65DF\u65F0\u65F2\u65F4\u65F5\u65F9\u65FE\u65FF\u6600\u6604\u6608\u6609\u660D\u6611\u6612\u6615\u6616\u661D"],
    ["8fc2a1", "\u661E\u6621\u6622\u6623\u6624\u6626\u6629\u662A\u662B\u662C\u662E\u6630\u6631\u6633\u6639\u6637\u6640\u6645\u6646\u664A\u664C\u6651\u664E\u6657\u6658\u6659\u665B\u665C\u6660\u6661\u66FB\u666A\u666B\u666C\u667E\u6673\u6675\u667F\u6677\u6678\u6679\u667B\u6680\u667C\u668B\u668C\u668D\u6690\u6692\u6699\u669A\u669B\u669C\u669F\u66A0\u66A4\u66AD\u66B1\u66B2\u66B5\u66BB\u66BF\u66C0\u66C2\u66C3\u66C8\u66CC\u66CE\u66CF\u66D4\u66DB\u66DF\u66E8\u66EB\u66EC\u66EE\u66FA\u6705\u6707\u670E\u6713\u6719\u671C\u6720\u6722\u6733\u673E\u6745\u6747\u6748\u674C\u6754\u6755\u675D"],
    ["8fc3a1", "\u6766\u676C\u676E\u6774\u6776\u677B\u6781\u6784\u678E\u678F\u6791\u6793\u6796\u6798\u6799\u679B\u67B0\u67B1\u67B2\u67B5\u67BB\u67BC\u67BD\u67F9\u67C0\u67C2\u67C3\u67C5\u67C8\u67C9\u67D2\u67D7\u67D9\u67DC\u67E1\u67E6\u67F0\u67F2\u67F6\u67F7\u6852\u6814\u6819\u681D\u681F\u6828\u6827\u682C\u682D\u682F\u6830\u6831\u6833\u683B\u683F\u6844\u6845\u684A\u684C\u6855\u6857\u6858\u685B\u686B\u686E", 4, "\u6875\u6879\u687A\u687B\u687C\u6882\u6884\u6886\u6888\u6896\u6898\u689A\u689C\u68A1\u68A3\u68A5\u68A9\u68AA\u68AE\u68B2\u68BB\u68C5\u68C8\u68CC\u68CF"],
    ["8fc4a1", "\u68D0\u68D1\u68D3\u68D6\u68D9\u68DC\u68DD\u68E5\u68E8\u68EA\u68EB\u68EC\u68ED\u68F0\u68F1\u68F5\u68F6\u68FB\u68FC\u68FD\u6906\u6909\u690A\u6910\u6911\u6913\u6916\u6917\u6931\u6933\u6935\u6938\u693B\u6942\u6945\u6949\u694E\u6957\u695B\u6963\u6964\u6965\u6966\u6968\u6969\u696C\u6970\u6971\u6972\u697A\u697B\u697F\u6980\u698D\u6992\u6996\u6998\u69A1\u69A5\u69A6\u69A8\u69AB\u69AD\u69AF\u69B7\u69B8\u69BA\u69BC\u69C5\u69C8\u69D1\u69D6\u69D7\u69E2\u69E5\u69EE\u69EF\u69F1\u69F3\u69F5\u69FE\u6A00\u6A01\u6A03\u6A0F\u6A11\u6A15\u6A1A\u6A1D\u6A20\u6A24\u6A28\u6A30\u6A32"],
    ["8fc5a1", "\u6A34\u6A37\u6A3B\u6A3E\u6A3F\u6A45\u6A46\u6A49\u6A4A\u6A4E\u6A50\u6A51\u6A52\u6A55\u6A56\u6A5B\u6A64\u6A67\u6A6A\u6A71\u6A73\u6A7E\u6A81\u6A83\u6A86\u6A87\u6A89\u6A8B\u6A91\u6A9B\u6A9D\u6A9E\u6A9F\u6AA5\u6AAB\u6AAF\u6AB0\u6AB1\u6AB4\u6ABD\u6ABE\u6ABF\u6AC6\u6AC9\u6AC8\u6ACC\u6AD0\u6AD4\u6AD5\u6AD6\u6ADC\u6ADD\u6AE4\u6AE7\u6AEC\u6AF0\u6AF1\u6AF2\u6AFC\u6AFD\u6B02\u6B03\u6B06\u6B07\u6B09\u6B0F\u6B10\u6B11\u6B17\u6B1B\u6B1E\u6B24\u6B28\u6B2B\u6B2C\u6B2F\u6B35\u6B36\u6B3B\u6B3F\u6B46\u6B4A\u6B4D\u6B52\u6B56\u6B58\u6B5D\u6B60\u6B67\u6B6B\u6B6E\u6B70\u6B75\u6B7D"],
    ["8fc6a1", "\u6B7E\u6B82\u6B85\u6B97\u6B9B\u6B9F\u6BA0\u6BA2\u6BA3\u6BA8\u6BA9\u6BAC\u6BAD\u6BAE\u6BB0\u6BB8\u6BB9\u6BBD\u6BBE\u6BC3\u6BC4\u6BC9\u6BCC\u6BD6\u6BDA\u6BE1\u6BE3\u6BE6\u6BE7\u6BEE\u6BF1\u6BF7\u6BF9\u6BFF\u6C02\u6C04\u6C05\u6C09\u6C0D\u6C0E\u6C10\u6C12\u6C19\u6C1F\u6C26\u6C27\u6C28\u6C2C\u6C2E\u6C33\u6C35\u6C36\u6C3A\u6C3B\u6C3F\u6C4A\u6C4B\u6C4D\u6C4F\u6C52\u6C54\u6C59\u6C5B\u6C5C\u6C6B\u6C6D\u6C6F\u6C74\u6C76\u6C78\u6C79\u6C7B\u6C85\u6C86\u6C87\u6C89\u6C94\u6C95\u6C97\u6C98\u6C9C\u6C9F\u6CB0\u6CB2\u6CB4\u6CC2\u6CC6\u6CCD\u6CCF\u6CD0\u6CD1\u6CD2\u6CD4\u6CD6"],
    ["8fc7a1", "\u6CDA\u6CDC\u6CE0\u6CE7\u6CE9\u6CEB\u6CEC\u6CEE\u6CF2\u6CF4\u6D04\u6D07\u6D0A\u6D0E\u6D0F\u6D11\u6D13\u6D1A\u6D26\u6D27\u6D28\u6C67\u6D2E\u6D2F\u6D31\u6D39\u6D3C\u6D3F\u6D57\u6D5E\u6D5F\u6D61\u6D65\u6D67\u6D6F\u6D70\u6D7C\u6D82\u6D87\u6D91\u6D92\u6D94\u6D96\u6D97\u6D98\u6DAA\u6DAC\u6DB4\u6DB7\u6DB9\u6DBD\u6DBF\u6DC4\u6DC8\u6DCA\u6DCE\u6DCF\u6DD6\u6DDB\u6DDD\u6DDF\u6DE0\u6DE2\u6DE5\u6DE9\u6DEF\u6DF0\u6DF4\u6DF6\u6DFC\u6E00\u6E04\u6E1E\u6E22\u6E27\u6E32\u6E36\u6E39\u6E3B\u6E3C\u6E44\u6E45\u6E48\u6E49\u6E4B\u6E4F\u6E51\u6E52\u6E53\u6E54\u6E57\u6E5C\u6E5D\u6E5E"],
    ["8fc8a1", "\u6E62\u6E63\u6E68\u6E73\u6E7B\u6E7D\u6E8D\u6E93\u6E99\u6EA0\u6EA7\u6EAD\u6EAE\u6EB1\u6EB3\u6EBB\u6EBF\u6EC0\u6EC1\u6EC3\u6EC7\u6EC8\u6ECA\u6ECD\u6ECE\u6ECF\u6EEB\u6EED\u6EEE\u6EF9\u6EFB\u6EFD\u6F04\u6F08\u6F0A\u6F0C\u6F0D\u6F16\u6F18\u6F1A\u6F1B\u6F26\u6F29\u6F2A\u6F2F\u6F30\u6F33\u6F36\u6F3B\u6F3C\u6F2D\u6F4F\u6F51\u6F52\u6F53\u6F57\u6F59\u6F5A\u6F5D\u6F5E\u6F61\u6F62\u6F68\u6F6C\u6F7D\u6F7E\u6F83\u6F87\u6F88\u6F8B\u6F8C\u6F8D\u6F90\u6F92\u6F93\u6F94\u6F96\u6F9A\u6F9F\u6FA0\u6FA5\u6FA6\u6FA7\u6FA8\u6FAE\u6FAF\u6FB0\u6FB5\u6FB6\u6FBC\u6FC5\u6FC7\u6FC8\u6FCA"],
    ["8fc9a1", "\u6FDA\u6FDE\u6FE8\u6FE9\u6FF0\u6FF5\u6FF9\u6FFC\u6FFD\u7000\u7005\u7006\u7007\u700D\u7017\u7020\u7023\u702F\u7034\u7037\u7039\u703C\u7043\u7044\u7048\u7049\u704A\u704B\u7054\u7055\u705D\u705E\u704E\u7064\u7065\u706C\u706E\u7075\u7076\u707E\u7081\u7085\u7086\u7094", 4, "\u709B\u70A4\u70AB\u70B0\u70B1\u70B4\u70B7\u70CA\u70D1\u70D3\u70D4\u70D5\u70D6\u70D8\u70DC\u70E4\u70FA\u7103", 4, "\u710B\u710C\u710F\u711E\u7120\u712B\u712D\u712F\u7130\u7131\u7138\u7141\u7145\u7146\u7147\u714A\u714B\u7150\u7152\u7157\u715A\u715C\u715E\u7160"],
    ["8fcaa1", "\u7168\u7179\u7180\u7185\u7187\u718C\u7192\u719A\u719B\u71A0\u71A2\u71AF\u71B0\u71B2\u71B3\u71BA\u71BF\u71C0\u71C1\u71C4\u71CB\u71CC\u71D3\u71D6\u71D9\u71DA\u71DC\u71F8\u71FE\u7200\u7207\u7208\u7209\u7213\u7217\u721A\u721D\u721F\u7224\u722B\u722F\u7234\u7238\u7239\u7241\u7242\u7243\u7245\u724E\u724F\u7250\u7253\u7255\u7256\u725A\u725C\u725E\u7260\u7263\u7268\u726B\u726E\u726F\u7271\u7277\u7278\u727B\u727C\u727F\u7284\u7289\u728D\u728E\u7293\u729B\u72A8\u72AD\u72AE\u72B1\u72B4\u72BE\u72C1\u72C7\u72C9\u72CC\u72D5\u72D6\u72D8\u72DF\u72E5\u72F3\u72F4\u72FA\u72FB"],
    ["8fcba1", "\u72FE\u7302\u7304\u7305\u7307\u730B\u730D\u7312\u7313\u7318\u7319\u731E\u7322\u7324\u7327\u7328\u732C\u7331\u7332\u7335\u733A\u733B\u733D\u7343\u734D\u7350\u7352\u7356\u7358\u735D\u735E\u735F\u7360\u7366\u7367\u7369\u736B\u736C\u736E\u736F\u7371\u7377\u7379\u737C\u7380\u7381\u7383\u7385\u7386\u738E\u7390\u7393\u7395\u7397\u7398\u739C\u739E\u739F\u73A0\u73A2\u73A5\u73A6\u73AA\u73AB\u73AD\u73B5\u73B7\u73B9\u73BC\u73BD\u73BF\u73C5\u73C6\u73C9\u73CB\u73CC\u73CF\u73D2\u73D3\u73D6\u73D9\u73DD\u73E1\u73E3\u73E6\u73E7\u73E9\u73F4\u73F5\u73F7\u73F9\u73FA\u73FB\u73FD"],
    ["8fcca1", "\u73FF\u7400\u7401\u7404\u7407\u740A\u7411\u741A\u741B\u7424\u7426\u7428", 9, "\u7439\u7440\u7443\u7444\u7446\u7447\u744B\u744D\u7451\u7452\u7457\u745D\u7462\u7466\u7467\u7468\u746B\u746D\u746E\u7471\u7472\u7480\u7481\u7485\u7486\u7487\u7489\u748F\u7490\u7491\u7492\u7498\u7499\u749A\u749C\u749F\u74A0\u74A1\u74A3\u74A6\u74A8\u74A9\u74AA\u74AB\u74AE\u74AF\u74B1\u74B2\u74B5\u74B9\u74BB\u74BF\u74C8\u74C9\u74CC\u74D0\u74D3\u74D8\u74DA\u74DB\u74DE\u74DF\u74E4\u74E8\u74EA\u74EB\u74EF\u74F4\u74FA\u74FB\u74FC\u74FF\u7506"],
    ["8fcda1", "\u7512\u7516\u7517\u7520\u7521\u7524\u7527\u7529\u752A\u752F\u7536\u7539\u753D\u753E\u753F\u7540\u7543\u7547\u7548\u754E\u7550\u7552\u7557\u755E\u755F\u7561\u756F\u7571\u7579", 5, "\u7581\u7585\u7590\u7592\u7593\u7595\u7599\u759C\u75A2\u75A4\u75B4\u75BA\u75BF\u75C0\u75C1\u75C4\u75C6\u75CC\u75CE\u75CF\u75D7\u75DC\u75DF\u75E0\u75E1\u75E4\u75E7\u75EC\u75EE\u75EF\u75F1\u75F9\u7600\u7602\u7603\u7604\u7607\u7608\u760A\u760C\u760F\u7612\u7613\u7615\u7616\u7619\u761B\u761C\u761D\u761E\u7623\u7625\u7626\u7629\u762D\u7632\u7633\u7635\u7638\u7639"],
    ["8fcea1", "\u763A\u763C\u764A\u7640\u7641\u7643\u7644\u7645\u7649\u764B\u7655\u7659\u765F\u7664\u7665\u766D\u766E\u766F\u7671\u7674\u7681\u7685\u768C\u768D\u7695\u769B\u769C\u769D\u769F\u76A0\u76A2", 6, "\u76AA\u76AD\u76BD\u76C1\u76C5\u76C9\u76CB\u76CC\u76CE\u76D4\u76D9\u76E0\u76E6\u76E8\u76EC\u76F0\u76F1\u76F6\u76F9\u76FC\u7700\u7706\u770A\u770E\u7712\u7714\u7715\u7717\u7719\u771A\u771C\u7722\u7728\u772D\u772E\u772F\u7734\u7735\u7736\u7739\u773D\u773E\u7742\u7745\u7746\u774A\u774D\u774E\u774F\u7752\u7756\u7757\u775C\u775E\u775F\u7760\u7762"],
    ["8fcfa1", "\u7764\u7767\u776A\u776C\u7770\u7772\u7773\u7774\u777A\u777D\u7780\u7784\u778C\u778D\u7794\u7795\u7796\u779A\u779F\u77A2\u77A7\u77AA\u77AE\u77AF\u77B1\u77B5\u77BE\u77C3\u77C9\u77D1\u77D2\u77D5\u77D9\u77DE\u77DF\u77E0\u77E4\u77E6\u77EA\u77EC\u77F0\u77F1\u77F4\u77F8\u77FB\u7805\u7806\u7809\u780D\u780E\u7811\u781D\u7821\u7822\u7823\u782D\u782E\u7830\u7835\u7837\u7843\u7844\u7847\u7848\u784C\u784E\u7852\u785C\u785E\u7860\u7861\u7863\u7864\u7868\u786A\u786E\u787A\u787E\u788A\u788F\u7894\u7898\u78A1\u789D\u789E\u789F\u78A4\u78A8\u78AC\u78AD\u78B0\u78B1\u78B2\u78B3"],
    ["8fd0a1", "\u78BB\u78BD\u78BF\u78C7\u78C8\u78C9\u78CC\u78CE\u78D2\u78D3\u78D5\u78D6\u78E4\u78DB\u78DF\u78E0\u78E1\u78E6\u78EA\u78F2\u78F3\u7900\u78F6\u78F7\u78FA\u78FB\u78FF\u7906\u790C\u7910\u791A\u791C\u791E\u791F\u7920\u7925\u7927\u7929\u792D\u7931\u7934\u7935\u793B\u793D\u793F\u7944\u7945\u7946\u794A\u794B\u794F\u7951\u7954\u7958\u795B\u795C\u7967\u7969\u796B\u7972\u7979\u797B\u797C\u797E\u798B\u798C\u7991\u7993\u7994\u7995\u7996\u7998\u799B\u799C\u79A1\u79A8\u79A9\u79AB\u79AF\u79B1\u79B4\u79B8\u79BB\u79C2\u79C4\u79C7\u79C8\u79CA\u79CF\u79D4\u79D6\u79DA\u79DD\u79DE"],
    ["8fd1a1", "\u79E0\u79E2\u79E5\u79EA\u79EB\u79ED\u79F1\u79F8\u79FC\u7A02\u7A03\u7A07\u7A09\u7A0A\u7A0C\u7A11\u7A15\u7A1B\u7A1E\u7A21\u7A27\u7A2B\u7A2D\u7A2F\u7A30\u7A34\u7A35\u7A38\u7A39\u7A3A\u7A44\u7A45\u7A47\u7A48\u7A4C\u7A55\u7A56\u7A59\u7A5C\u7A5D\u7A5F\u7A60\u7A65\u7A67\u7A6A\u7A6D\u7A75\u7A78\u7A7E\u7A80\u7A82\u7A85\u7A86\u7A8A\u7A8B\u7A90\u7A91\u7A94\u7A9E\u7AA0\u7AA3\u7AAC\u7AB3\u7AB5\u7AB9\u7ABB\u7ABC\u7AC6\u7AC9\u7ACC\u7ACE\u7AD1\u7ADB\u7AE8\u7AE9\u7AEB\u7AEC\u7AF1\u7AF4\u7AFB\u7AFD\u7AFE\u7B07\u7B14\u7B1F\u7B23\u7B27\u7B29\u7B2A\u7B2B\u7B2D\u7B2E\u7B2F\u7B30"],
    ["8fd2a1", "\u7B31\u7B34\u7B3D\u7B3F\u7B40\u7B41\u7B47\u7B4E\u7B55\u7B60\u7B64\u7B66\u7B69\u7B6A\u7B6D\u7B6F\u7B72\u7B73\u7B77\u7B84\u7B89\u7B8E\u7B90\u7B91\u7B96\u7B9B\u7B9E\u7BA0\u7BA5\u7BAC\u7BAF\u7BB0\u7BB2\u7BB5\u7BB6\u7BBA\u7BBB\u7BBC\u7BBD\u7BC2\u7BC5\u7BC8\u7BCA\u7BD4\u7BD6\u7BD7\u7BD9\u7BDA\u7BDB\u7BE8\u7BEA\u7BF2\u7BF4\u7BF5\u7BF8\u7BF9\u7BFA\u7BFC\u7BFE\u7C01\u7C02\u7C03\u7C04\u7C06\u7C09\u7C0B\u7C0C\u7C0E\u7C0F\u7C19\u7C1B\u7C20\u7C25\u7C26\u7C28\u7C2C\u7C31\u7C33\u7C34\u7C36\u7C39\u7C3A\u7C46\u7C4A\u7C55\u7C51\u7C52\u7C53\u7C59", 5],
    ["8fd3a1", "\u7C61\u7C63\u7C67\u7C69\u7C6D\u7C6E\u7C70\u7C72\u7C79\u7C7C\u7C7D\u7C86\u7C87\u7C8F\u7C94\u7C9E\u7CA0\u7CA6\u7CB0\u7CB6\u7CB7\u7CBA\u7CBB\u7CBC\u7CBF\u7CC4\u7CC7\u7CC8\u7CC9\u7CCD\u7CCF\u7CD3\u7CD4\u7CD5\u7CD7\u7CD9\u7CDA\u7CDD\u7CE6\u7CE9\u7CEB\u7CF5\u7D03\u7D07\u7D08\u7D09\u7D0F\u7D11\u7D12\u7D13\u7D16\u7D1D\u7D1E\u7D23\u7D26\u7D2A\u7D2D\u7D31\u7D3C\u7D3D\u7D3E\u7D40\u7D41\u7D47\u7D48\u7D4D\u7D51\u7D53\u7D57\u7D59\u7D5A\u7D5C\u7D5D\u7D65\u7D67\u7D6A\u7D70\u7D78\u7D7A\u7D7B\u7D7F\u7D81\u7D82\u7D83\u7D85\u7D86\u7D88\u7D8B\u7D8C\u7D8D\u7D91\u7D96\u7D97\u7D9D"],
    ["8fd4a1", "\u7D9E\u7DA6\u7DA7\u7DAA\u7DB3\u7DB6\u7DB7\u7DB9\u7DC2", 4, "\u7DCC\u7DCD\u7DCE\u7DD7\u7DD9\u7E00\u7DE2\u7DE5\u7DE6\u7DEA\u7DEB\u7DED\u7DF1\u7DF5\u7DF6\u7DF9\u7DFA\u7E08\u7E10\u7E11\u7E15\u7E17\u7E1C\u7E1D\u7E20\u7E27\u7E28\u7E2C\u7E2D\u7E2F\u7E33\u7E36\u7E3F\u7E44\u7E45\u7E47\u7E4E\u7E50\u7E52\u7E58\u7E5F\u7E61\u7E62\u7E65\u7E6B\u7E6E\u7E6F\u7E73\u7E78\u7E7E\u7E81\u7E86\u7E87\u7E8A\u7E8D\u7E91\u7E95\u7E98\u7E9A\u7E9D\u7E9E\u7F3C\u7F3B\u7F3D\u7F3E\u7F3F\u7F43\u7F44\u7F47\u7F4F\u7F52\u7F53\u7F5B\u7F5C\u7F5D\u7F61\u7F63\u7F64\u7F65\u7F66\u7F6D"],
    ["8fd5a1", "\u7F71\u7F7D\u7F7E\u7F7F\u7F80\u7F8B\u7F8D\u7F8F\u7F90\u7F91\u7F96\u7F97\u7F9C\u7FA1\u7FA2\u7FA6\u7FAA\u7FAD\u7FB4\u7FBC\u7FBF\u7FC0\u7FC3\u7FC8\u7FCE\u7FCF\u7FDB\u7FDF\u7FE3\u7FE5\u7FE8\u7FEC\u7FEE\u7FEF\u7FF2\u7FFA\u7FFD\u7FFE\u7FFF\u8007\u8008\u800A\u800D\u800E\u800F\u8011\u8013\u8014\u8016\u801D\u801E\u801F\u8020\u8024\u8026\u802C\u802E\u8030\u8034\u8035\u8037\u8039\u803A\u803C\u803E\u8040\u8044\u8060\u8064\u8066\u806D\u8071\u8075\u8081\u8088\u808E\u809C\u809E\u80A6\u80A7\u80AB\u80B8\u80B9\u80C8\u80CD\u80CF\u80D2\u80D4\u80D5\u80D7\u80D8\u80E0\u80ED\u80EE"],
    ["8fd6a1", "\u80F0\u80F2\u80F3\u80F6\u80F9\u80FA\u80FE\u8103\u810B\u8116\u8117\u8118\u811C\u811E\u8120\u8124\u8127\u812C\u8130\u8135\u813A\u813C\u8145\u8147\u814A\u814C\u8152\u8157\u8160\u8161\u8167\u8168\u8169\u816D\u816F\u8177\u8181\u8190\u8184\u8185\u8186\u818B\u818E\u8196\u8198\u819B\u819E\u81A2\u81AE\u81B2\u81B4\u81BB\u81CB\u81C3\u81C5\u81CA\u81CE\u81CF\u81D5\u81D7\u81DB\u81DD\u81DE\u81E1\u81E4\u81EB\u81EC\u81F0\u81F1\u81F2\u81F5\u81F6\u81F8\u81F9\u81FD\u81FF\u8200\u8203\u820F\u8213\u8214\u8219\u821A\u821D\u8221\u8222\u8228\u8232\u8234\u823A\u8243\u8244\u8245\u8246"],
    ["8fd7a1", "\u824B\u824E\u824F\u8251\u8256\u825C\u8260\u8263\u8267\u826D\u8274\u827B\u827D\u827F\u8280\u8281\u8283\u8284\u8287\u8289\u828A\u828E\u8291\u8294\u8296\u8298\u829A\u829B\u82A0\u82A1\u82A3\u82A4\u82A7\u82A8\u82A9\u82AA\u82AE\u82B0\u82B2\u82B4\u82B7\u82BA\u82BC\u82BE\u82BF\u82C6\u82D0\u82D5\u82DA\u82E0\u82E2\u82E4\u82E8\u82EA\u82ED\u82EF\u82F6\u82F7\u82FD\u82FE\u8300\u8301\u8307\u8308\u830A\u830B\u8354\u831B\u831D\u831E\u831F\u8321\u8322\u832C\u832D\u832E\u8330\u8333\u8337\u833A\u833C\u833D\u8342\u8343\u8344\u8347\u834D\u834E\u8351\u8355\u8356\u8357\u8370\u8378"],
    ["8fd8a1", "\u837D\u837F\u8380\u8382\u8384\u8386\u838D\u8392\u8394\u8395\u8398\u8399\u839B\u839C\u839D\u83A6\u83A7\u83A9\u83AC\u83BE\u83BF\u83C0\u83C7\u83C9\u83CF\u83D0\u83D1\u83D4\u83DD\u8353\u83E8\u83EA\u83F6\u83F8\u83F9\u83FC\u8401\u8406\u840A\u840F\u8411\u8415\u8419\u83AD\u842F\u8439\u8445\u8447\u8448\u844A\u844D\u844F\u8451\u8452\u8456\u8458\u8459\u845A\u845C\u8460\u8464\u8465\u8467\u846A\u8470\u8473\u8474\u8476\u8478\u847C\u847D\u8481\u8485\u8492\u8493\u8495\u849E\u84A6\u84A8\u84A9\u84AA\u84AF\u84B1\u84B4\u84BA\u84BD\u84BE\u84C0\u84C2\u84C7\u84C8\u84CC\u84CF\u84D3"],
    ["8fd9a1", "\u84DC\u84E7\u84EA\u84EF\u84F0\u84F1\u84F2\u84F7\u8532\u84FA\u84FB\u84FD\u8502\u8503\u8507\u850C\u850E\u8510\u851C\u851E\u8522\u8523\u8524\u8525\u8527\u852A\u852B\u852F\u8533\u8534\u8536\u853F\u8546\u854F", 4, "\u8556\u8559\u855C", 6, "\u8564\u856B\u856F\u8579\u857A\u857B\u857D\u857F\u8581\u8585\u8586\u8589\u858B\u858C\u858F\u8593\u8598\u859D\u859F\u85A0\u85A2\u85A5\u85A7\u85B4\u85B6\u85B7\u85B8\u85BC\u85BD\u85BE\u85BF\u85C2\u85C7\u85CA\u85CB\u85CE\u85AD\u85D8\u85DA\u85DF\u85E0\u85E6\u85E8\u85ED\u85F3\u85F6\u85FC"],
    ["8fdaa1", "\u85FF\u8600\u8604\u8605\u860D\u860E\u8610\u8611\u8612\u8618\u8619\u861B\u861E\u8621\u8627\u8629\u8636\u8638\u863A\u863C\u863D\u8640\u8642\u8646\u8652\u8653\u8656\u8657\u8658\u8659\u865D\u8660", 4, "\u8669\u866C\u866F\u8675\u8676\u8677\u867A\u868D\u8691\u8696\u8698\u869A\u869C\u86A1\u86A6\u86A7\u86A8\u86AD\u86B1\u86B3\u86B4\u86B5\u86B7\u86B8\u86B9\u86BF\u86C0\u86C1\u86C3\u86C5\u86D1\u86D2\u86D5\u86D7\u86DA\u86DC\u86E0\u86E3\u86E5\u86E7\u8688\u86FA\u86FC\u86FD\u8704\u8705\u8707\u870B\u870E\u870F\u8710\u8713\u8714\u8719\u871E\u871F\u8721\u8723"],
    ["8fdba1", "\u8728\u872E\u872F\u8731\u8732\u8739\u873A\u873C\u873D\u873E\u8740\u8743\u8745\u874D\u8758\u875D\u8761\u8764\u8765\u876F\u8771\u8772\u877B\u8783", 6, "\u878B\u878C\u8790\u8793\u8795\u8797\u8798\u8799\u879E\u87A0\u87A3\u87A7\u87AC\u87AD\u87AE\u87B1\u87B5\u87BE\u87BF\u87C1\u87C8\u87C9\u87CA\u87CE\u87D5\u87D6\u87D9\u87DA\u87DC\u87DF\u87E2\u87E3\u87E4\u87EA\u87EB\u87ED\u87F1\u87F3\u87F8\u87FA\u87FF\u8801\u8803\u8806\u8809\u880A\u880B\u8810\u8819\u8812\u8813\u8814\u8818\u881A\u881B\u881C\u881E\u881F\u8828\u882D\u882E\u8830\u8832\u8835"],
    ["8fdca1", "\u883A\u883C\u8841\u8843\u8845\u8848\u8849\u884A\u884B\u884E\u8851\u8855\u8856\u8858\u885A\u885C\u885F\u8860\u8864\u8869\u8871\u8879\u887B\u8880\u8898\u889A\u889B\u889C\u889F\u88A0\u88A8\u88AA\u88BA\u88BD\u88BE\u88C0\u88CA", 4, "\u88D1\u88D2\u88D3\u88DB\u88DE\u88E7\u88EF\u88F0\u88F1\u88F5\u88F7\u8901\u8906\u890D\u890E\u890F\u8915\u8916\u8918\u8919\u891A\u891C\u8920\u8926\u8927\u8928\u8930\u8931\u8932\u8935\u8939\u893A\u893E\u8940\u8942\u8945\u8946\u8949\u894F\u8952\u8957\u895A\u895B\u895C\u8961\u8962\u8963\u896B\u896E\u8970\u8973\u8975\u897A"],
    ["8fdda1", "\u897B\u897C\u897D\u8989\u898D\u8990\u8994\u8995\u899B\u899C\u899F\u89A0\u89A5\u89B0\u89B4\u89B5\u89B6\u89B7\u89BC\u89D4", 4, "\u89E5\u89E9\u89EB\u89ED\u89F1\u89F3\u89F6\u89F9\u89FD\u89FF\u8A04\u8A05\u8A07\u8A0F\u8A11\u8A12\u8A14\u8A15\u8A1E\u8A20\u8A22\u8A24\u8A26\u8A2B\u8A2C\u8A2F\u8A35\u8A37\u8A3D\u8A3E\u8A40\u8A43\u8A45\u8A47\u8A49\u8A4D\u8A4E\u8A53\u8A56\u8A57\u8A58\u8A5C\u8A5D\u8A61\u8A65\u8A67\u8A75\u8A76\u8A77\u8A79\u8A7A\u8A7B\u8A7E\u8A7F\u8A80\u8A83\u8A86\u8A8B\u8A8F\u8A90\u8A92\u8A96\u8A97\u8A99\u8A9F\u8AA7\u8AA9\u8AAE\u8AAF\u8AB3"],
    ["8fdea1", "\u8AB6\u8AB7\u8ABB\u8ABE\u8AC3\u8AC6\u8AC8\u8AC9\u8ACA\u8AD1\u8AD3\u8AD4\u8AD5\u8AD7\u8ADD\u8ADF\u8AEC\u8AF0\u8AF4\u8AF5\u8AF6\u8AFC\u8AFF\u8B05\u8B06\u8B0B\u8B11\u8B1C\u8B1E\u8B1F\u8B0A\u8B2D\u8B30\u8B37\u8B3C\u8B42", 4, "\u8B48\u8B52\u8B53\u8B54\u8B59\u8B4D\u8B5E\u8B63\u8B6D\u8B76\u8B78\u8B79\u8B7C\u8B7E\u8B81\u8B84\u8B85\u8B8B\u8B8D\u8B8F\u8B94\u8B95\u8B9C\u8B9E\u8B9F\u8C38\u8C39\u8C3D\u8C3E\u8C45\u8C47\u8C49\u8C4B\u8C4F\u8C51\u8C53\u8C54\u8C57\u8C58\u8C5B\u8C5D\u8C59\u8C63\u8C64\u8C66\u8C68\u8C69\u8C6D\u8C73\u8C75\u8C76\u8C7B\u8C7E\u8C86"],
    ["8fdfa1", "\u8C87\u8C8B\u8C90\u8C92\u8C93\u8C99\u8C9B\u8C9C\u8CA4\u8CB9\u8CBA\u8CC5\u8CC6\u8CC9\u8CCB\u8CCF\u8CD6\u8CD5\u8CD9\u8CDD\u8CE1\u8CE8\u8CEC\u8CEF\u8CF0\u8CF2\u8CF5\u8CF7\u8CF8\u8CFE\u8CFF\u8D01\u8D03\u8D09\u8D12\u8D17\u8D1B\u8D65\u8D69\u8D6C\u8D6E\u8D7F\u8D82\u8D84\u8D88\u8D8D\u8D90\u8D91\u8D95\u8D9E\u8D9F\u8DA0\u8DA6\u8DAB\u8DAC\u8DAF\u8DB2\u8DB5\u8DB7\u8DB9\u8DBB\u8DC0\u8DC5\u8DC6\u8DC7\u8DC8\u8DCA\u8DCE\u8DD1\u8DD4\u8DD5\u8DD7\u8DD9\u8DE4\u8DE5\u8DE7\u8DEC\u8DF0\u8DBC\u8DF1\u8DF2\u8DF4\u8DFD\u8E01\u8E04\u8E05\u8E06\u8E0B\u8E11\u8E14\u8E16\u8E20\u8E21\u8E22"],
    ["8fe0a1", "\u8E23\u8E26\u8E27\u8E31\u8E33\u8E36\u8E37\u8E38\u8E39\u8E3D\u8E40\u8E41\u8E4B\u8E4D\u8E4E\u8E4F\u8E54\u8E5B\u8E5C\u8E5D\u8E5E\u8E61\u8E62\u8E69\u8E6C\u8E6D\u8E6F\u8E70\u8E71\u8E79\u8E7A\u8E7B\u8E82\u8E83\u8E89\u8E90\u8E92\u8E95\u8E9A\u8E9B\u8E9D\u8E9E\u8EA2\u8EA7\u8EA9\u8EAD\u8EAE\u8EB3\u8EB5\u8EBA\u8EBB\u8EC0\u8EC1\u8EC3\u8EC4\u8EC7\u8ECF\u8ED1\u8ED4\u8EDC\u8EE8\u8EEE\u8EF0\u8EF1\u8EF7\u8EF9\u8EFA\u8EED\u8F00\u8F02\u8F07\u8F08\u8F0F\u8F10\u8F16\u8F17\u8F18\u8F1E\u8F20\u8F21\u8F23\u8F25\u8F27\u8F28\u8F2C\u8F2D\u8F2E\u8F34\u8F35\u8F36\u8F37\u8F3A\u8F40\u8F41"],
    ["8fe1a1", "\u8F43\u8F47\u8F4F\u8F51", 4, "\u8F58\u8F5D\u8F5E\u8F65\u8F9D\u8FA0\u8FA1\u8FA4\u8FA5\u8FA6\u8FB5\u8FB6\u8FB8\u8FBE\u8FC0\u8FC1\u8FC6\u8FCA\u8FCB\u8FCD\u8FD0\u8FD2\u8FD3\u8FD5\u8FE0\u8FE3\u8FE4\u8FE8\u8FEE\u8FF1\u8FF5\u8FF6\u8FFB\u8FFE\u9002\u9004\u9008\u900C\u9018\u901B\u9028\u9029\u902F\u902A\u902C\u902D\u9033\u9034\u9037\u903F\u9043\u9044\u904C\u905B\u905D\u9062\u9066\u9067\u906C\u9070\u9074\u9079\u9085\u9088\u908B\u908C\u908E\u9090\u9095\u9097\u9098\u9099\u909B\u90A0\u90A1\u90A2\u90A5\u90B0\u90B2\u90B3\u90B4\u90B6\u90BD\u90CC\u90BE\u90C3"],
    ["8fe2a1", "\u90C4\u90C5\u90C7\u90C8\u90D5\u90D7\u90D8\u90D9\u90DC\u90DD\u90DF\u90E5\u90D2\u90F6\u90EB\u90EF\u90F0\u90F4\u90FE\u90FF\u9100\u9104\u9105\u9106\u9108\u910D\u9110\u9114\u9116\u9117\u9118\u911A\u911C\u911E\u9120\u9125\u9122\u9123\u9127\u9129\u912E\u912F\u9131\u9134\u9136\u9137\u9139\u913A\u913C\u913D\u9143\u9147\u9148\u914F\u9153\u9157\u9159\u915A\u915B\u9161\u9164\u9167\u916D\u9174\u9179\u917A\u917B\u9181\u9183\u9185\u9186\u918A\u918E\u9191\u9193\u9194\u9195\u9198\u919E\u91A1\u91A6\u91A8\u91AC\u91AD\u91AE\u91B0\u91B1\u91B2\u91B3\u91B6\u91BB\u91BC\u91BD\u91BF"],
    ["8fe3a1", "\u91C2\u91C3\u91C5\u91D3\u91D4\u91D7\u91D9\u91DA\u91DE\u91E4\u91E5\u91E9\u91EA\u91EC", 5, "\u91F7\u91F9\u91FB\u91FD\u9200\u9201\u9204\u9205\u9206\u9207\u9209\u920A\u920C\u9210\u9212\u9213\u9216\u9218\u921C\u921D\u9223\u9224\u9225\u9226\u9228\u922E\u922F\u9230\u9233\u9235\u9236\u9238\u9239\u923A\u923C\u923E\u9240\u9242\u9243\u9246\u9247\u924A\u924D\u924E\u924F\u9251\u9258\u9259\u925C\u925D\u9260\u9261\u9265\u9267\u9268\u9269\u926E\u926F\u9270\u9275", 4, "\u927B\u927C\u927D\u927F\u9288\u9289\u928A\u928D\u928E\u9292\u9297"],
    ["8fe4a1", "\u9299\u929F\u92A0\u92A4\u92A5\u92A7\u92A8\u92AB\u92AF\u92B2\u92B6\u92B8\u92BA\u92BB\u92BC\u92BD\u92BF", 4, "\u92C5\u92C6\u92C7\u92C8\u92CB\u92CC\u92CD\u92CE\u92D0\u92D3\u92D5\u92D7\u92D8\u92D9\u92DC\u92DD\u92DF\u92E0\u92E1\u92E3\u92E5\u92E7\u92E8\u92EC\u92EE\u92F0\u92F9\u92FB\u92FF\u9300\u9302\u9308\u930D\u9311\u9314\u9315\u931C\u931D\u931E\u931F\u9321\u9324\u9325\u9327\u9329\u932A\u9333\u9334\u9336\u9337\u9347\u9348\u9349\u9350\u9351\u9352\u9355\u9357\u9358\u935A\u935E\u9364\u9365\u9367\u9369\u936A\u936D\u936F\u9370\u9371\u9373\u9374\u9376"],
    ["8fe5a1", "\u937A\u937D\u937F\u9380\u9381\u9382\u9388\u938A\u938B\u938D\u938F\u9392\u9395\u9398\u939B\u939E\u93A1\u93A3\u93A4\u93A6\u93A8\u93AB\u93B4\u93B5\u93B6\u93BA\u93A9\u93C1\u93C4\u93C5\u93C6\u93C7\u93C9", 4, "\u93D3\u93D9\u93DC\u93DE\u93DF\u93E2\u93E6\u93E7\u93F9\u93F7\u93F8\u93FA\u93FB\u93FD\u9401\u9402\u9404\u9408\u9409\u940D\u940E\u940F\u9415\u9416\u9417\u941F\u942E\u942F\u9431\u9432\u9433\u9434\u943B\u943F\u943D\u9443\u9445\u9448\u944A\u944C\u9455\u9459\u945C\u945F\u9461\u9463\u9468\u946B\u946D\u946E\u946F\u9471\u9472\u9484\u9483\u9578\u9579"],
    ["8fe6a1", "\u957E\u9584\u9588\u958C\u958D\u958E\u959D\u959E\u959F\u95A1\u95A6\u95A9\u95AB\u95AC\u95B4\u95B6\u95BA\u95BD\u95BF\u95C6\u95C8\u95C9\u95CB\u95D0\u95D1\u95D2\u95D3\u95D9\u95DA\u95DD\u95DE\u95DF\u95E0\u95E4\u95E6\u961D\u961E\u9622\u9624\u9625\u9626\u962C\u9631\u9633\u9637\u9638\u9639\u963A\u963C\u963D\u9641\u9652\u9654\u9656\u9657\u9658\u9661\u966E\u9674\u967B\u967C\u967E\u967F\u9681\u9682\u9683\u9684\u9689\u9691\u9696\u969A\u969D\u969F\u96A4\u96A5\u96A6\u96A9\u96AE\u96AF\u96B3\u96BA\u96CA\u96D2\u5DB2\u96D8\u96DA\u96DD\u96DE\u96DF\u96E9\u96EF\u96F1\u96FA\u9702"],
    ["8fe7a1", "\u9703\u9705\u9709\u971A\u971B\u971D\u9721\u9722\u9723\u9728\u9731\u9733\u9741\u9743\u974A\u974E\u974F\u9755\u9757\u9758\u975A\u975B\u9763\u9767\u976A\u976E\u9773\u9776\u9777\u9778\u977B\u977D\u977F\u9780\u9789\u9795\u9796\u9797\u9799\u979A\u979E\u979F\u97A2\u97AC\u97AE\u97B1\u97B2\u97B5\u97B6\u97B8\u97B9\u97BA\u97BC\u97BE\u97BF\u97C1\u97C4\u97C5\u97C7\u97C9\u97CA\u97CC\u97CD\u97CE\u97D0\u97D1\u97D4\u97D7\u97D8\u97D9\u97DD\u97DE\u97E0\u97DB\u97E1\u97E4\u97EF\u97F1\u97F4\u97F7\u97F8\u97FA\u9807\u980A\u9819\u980D\u980E\u9814\u9816\u981C\u981E\u9820\u9823\u9826"],
    ["8fe8a1", "\u982B\u982E\u982F\u9830\u9832\u9833\u9835\u9825\u983E\u9844\u9847\u984A\u9851\u9852\u9853\u9856\u9857\u9859\u985A\u9862\u9863\u9865\u9866\u986A\u986C\u98AB\u98AD\u98AE\u98B0\u98B4\u98B7\u98B8\u98BA\u98BB\u98BF\u98C2\u98C5\u98C8\u98CC\u98E1\u98E3\u98E5\u98E6\u98E7\u98EA\u98F3\u98F6\u9902\u9907\u9908\u9911\u9915\u9916\u9917\u991A\u991B\u991C\u991F\u9922\u9926\u9927\u992B\u9931", 4, "\u9939\u993A\u993B\u993C\u9940\u9941\u9946\u9947\u9948\u994D\u994E\u9954\u9958\u9959\u995B\u995C\u995E\u995F\u9960\u999B\u999D\u999F\u99A6\u99B0\u99B1\u99B2\u99B5"],
    ["8fe9a1", "\u99B9\u99BA\u99BD\u99BF\u99C3\u99C9\u99D3\u99D4\u99D9\u99DA\u99DC\u99DE\u99E7\u99EA\u99EB\u99EC\u99F0\u99F4\u99F5\u99F9\u99FD\u99FE\u9A02\u9A03\u9A04\u9A0B\u9A0C\u9A10\u9A11\u9A16\u9A1E\u9A20\u9A22\u9A23\u9A24\u9A27\u9A2D\u9A2E\u9A33\u9A35\u9A36\u9A38\u9A47\u9A41\u9A44\u9A4A\u9A4B\u9A4C\u9A4E\u9A51\u9A54\u9A56\u9A5D\u9AAA\u9AAC\u9AAE\u9AAF\u9AB2\u9AB4\u9AB5\u9AB6\u9AB9\u9ABB\u9ABE\u9ABF\u9AC1\u9AC3\u9AC6\u9AC8\u9ACE\u9AD0\u9AD2\u9AD5\u9AD6\u9AD7\u9ADB\u9ADC\u9AE0\u9AE4\u9AE5\u9AE7\u9AE9\u9AEC\u9AF2\u9AF3\u9AF5\u9AF9\u9AFA\u9AFD\u9AFF", 4],
    ["8feaa1", "\u9B04\u9B05\u9B08\u9B09\u9B0B\u9B0C\u9B0D\u9B0E\u9B10\u9B12\u9B16\u9B19\u9B1B\u9B1C\u9B20\u9B26\u9B2B\u9B2D\u9B33\u9B34\u9B35\u9B37\u9B39\u9B3A\u9B3D\u9B48\u9B4B\u9B4C\u9B55\u9B56\u9B57\u9B5B\u9B5E\u9B61\u9B63\u9B65\u9B66\u9B68\u9B6A", 4, "\u9B73\u9B75\u9B77\u9B78\u9B79\u9B7F\u9B80\u9B84\u9B85\u9B86\u9B87\u9B89\u9B8A\u9B8B\u9B8D\u9B8F\u9B90\u9B94\u9B9A\u9B9D\u9B9E\u9BA6\u9BA7\u9BA9\u9BAC\u9BB0\u9BB1\u9BB2\u9BB7\u9BB8\u9BBB\u9BBC\u9BBE\u9BBF\u9BC1\u9BC7\u9BC8\u9BCE\u9BD0\u9BD7\u9BD8\u9BDD\u9BDF\u9BE5\u9BE7\u9BEA\u9BEB\u9BEF\u9BF3\u9BF7\u9BF8"],
    ["8feba1", "\u9BF9\u9BFA\u9BFD\u9BFF\u9C00\u9C02\u9C0B\u9C0F\u9C11\u9C16\u9C18\u9C19\u9C1A\u9C1C\u9C1E\u9C22\u9C23\u9C26", 4, "\u9C31\u9C35\u9C36\u9C37\u9C3D\u9C41\u9C43\u9C44\u9C45\u9C49\u9C4A\u9C4E\u9C4F\u9C50\u9C53\u9C54\u9C56\u9C58\u9C5B\u9C5D\u9C5E\u9C5F\u9C63\u9C69\u9C6A\u9C5C\u9C6B\u9C68\u9C6E\u9C70\u9C72\u9C75\u9C77\u9C7B\u9CE6\u9CF2\u9CF7\u9CF9\u9D0B\u9D02\u9D11\u9D17\u9D18\u9D1C\u9D1D\u9D1E\u9D2F\u9D30\u9D32\u9D33\u9D34\u9D3A\u9D3C\u9D45\u9D3D\u9D42\u9D43\u9D47\u9D4A\u9D53\u9D54\u9D5F\u9D63\u9D62\u9D65\u9D69\u9D6A\u9D6B\u9D70\u9D76\u9D77\u9D7B"],
    ["8feca1", "\u9D7C\u9D7E\u9D83\u9D84\u9D86\u9D8A\u9D8D\u9D8E\u9D92\u9D93\u9D95\u9D96\u9D97\u9D98\u9DA1\u9DAA\u9DAC\u9DAE\u9DB1\u9DB5\u9DB9\u9DBC\u9DBF\u9DC3\u9DC7\u9DC9\u9DCA\u9DD4\u9DD5\u9DD6\u9DD7\u9DDA\u9DDE\u9DDF\u9DE0\u9DE5\u9DE7\u9DE9\u9DEB\u9DEE\u9DF0\u9DF3\u9DF4\u9DFE\u9E0A\u9E02\u9E07\u9E0E\u9E10\u9E11\u9E12\u9E15\u9E16\u9E19\u9E1C\u9E1D\u9E7A\u9E7B\u9E7C\u9E80\u9E82\u9E83\u9E84\u9E85\u9E87\u9E8E\u9E8F\u9E96\u9E98\u9E9B\u9E9E\u9EA4\u9EA8\u9EAC\u9EAE\u9EAF\u9EB0\u9EB3\u9EB4\u9EB5\u9EC6\u9EC8\u9ECB\u9ED5\u9EDF\u9EE4\u9EE7\u9EEC\u9EED\u9EEE\u9EF0\u9EF1\u9EF2\u9EF5"],
    ["8feda1", "\u9EF8\u9EFF\u9F02\u9F03\u9F09\u9F0F\u9F10\u9F11\u9F12\u9F14\u9F16\u9F17\u9F19\u9F1A\u9F1B\u9F1F\u9F22\u9F26\u9F2A\u9F2B\u9F2F\u9F31\u9F32\u9F34\u9F37\u9F39\u9F3A\u9F3C\u9F3D\u9F3F\u9F41\u9F43", 4, "\u9F53\u9F55\u9F56\u9F57\u9F58\u9F5A\u9F5D\u9F5E\u9F68\u9F69\u9F6D", 4, "\u9F73\u9F75\u9F7A\u9F7D\u9F8F\u9F90\u9F91\u9F92\u9F94\u9F96\u9F97\u9F9E\u9FA1\u9FA2\u9FA3\u9FA5"]
  ];
});

// ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/cp936.json
var require_cp936 = __commonJS((exports2, module2) => {
  module2.exports = [
    ["0", "\0", 127, "\u20AC"],
    ["8140", "\u4E02\u4E04\u4E05\u4E06\u4E0F\u4E12\u4E17\u4E1F\u4E20\u4E21\u4E23\u4E26\u4E29\u4E2E\u4E2F\u4E31\u4E33\u4E35\u4E37\u4E3C\u4E40\u4E41\u4E42\u4E44\u4E46\u4E4A\u4E51\u4E55\u4E57\u4E5A\u4E5B\u4E62\u4E63\u4E64\u4E65\u4E67\u4E68\u4E6A", 5, "\u4E72\u4E74", 9, "\u4E7F", 6, "\u4E87\u4E8A"],
    ["8180", "\u4E90\u4E96\u4E97\u4E99\u4E9C\u4E9D\u4E9E\u4EA3\u4EAA\u4EAF\u4EB0\u4EB1\u4EB4\u4EB6\u4EB7\u4EB8\u4EB9\u4EBC\u4EBD\u4EBE\u4EC8\u4ECC\u4ECF\u4ED0\u4ED2\u4EDA\u4EDB\u4EDC\u4EE0\u4EE2\u4EE6\u4EE7\u4EE9\u4EED\u4EEE\u4EEF\u4EF1\u4EF4\u4EF8\u4EF9\u4EFA\u4EFC\u4EFE\u4F00\u4F02", 6, "\u4F0B\u4F0C\u4F12", 4, "\u4F1C\u4F1D\u4F21\u4F23\u4F28\u4F29\u4F2C\u4F2D\u4F2E\u4F31\u4F33\u4F35\u4F37\u4F39\u4F3B\u4F3E", 4, "\u4F44\u4F45\u4F47", 5, "\u4F52\u4F54\u4F56\u4F61\u4F62\u4F66\u4F68\u4F6A\u4F6B\u4F6D\u4F6E\u4F71\u4F72\u4F75\u4F77\u4F78\u4F79\u4F7A\u4F7D\u4F80\u4F81\u4F82\u4F85\u4F86\u4F87\u4F8A\u4F8C\u4F8E\u4F90\u4F92\u4F93\u4F95\u4F96\u4F98\u4F99\u4F9A\u4F9C\u4F9E\u4F9F\u4FA1\u4FA2"],
    ["8240", "\u4FA4\u4FAB\u4FAD\u4FB0", 4, "\u4FB6", 8, "\u4FC0\u4FC1\u4FC2\u4FC6\u4FC7\u4FC8\u4FC9\u4FCB\u4FCC\u4FCD\u4FD2", 4, "\u4FD9\u4FDB\u4FE0\u4FE2\u4FE4\u4FE5\u4FE7\u4FEB\u4FEC\u4FF0\u4FF2\u4FF4\u4FF5\u4FF6\u4FF7\u4FF9\u4FFB\u4FFC\u4FFD\u4FFF", 11],
    ["8280", "\u500B\u500E\u5010\u5011\u5013\u5015\u5016\u5017\u501B\u501D\u501E\u5020\u5022\u5023\u5024\u5027\u502B\u502F", 10, "\u503B\u503D\u503F\u5040\u5041\u5042\u5044\u5045\u5046\u5049\u504A\u504B\u504D\u5050", 4, "\u5056\u5057\u5058\u5059\u505B\u505D", 7, "\u5066", 5, "\u506D", 8, "\u5078\u5079\u507A\u507C\u507D\u5081\u5082\u5083\u5084\u5086\u5087\u5089\u508A\u508B\u508C\u508E", 20, "\u50A4\u50A6\u50AA\u50AB\u50AD", 4, "\u50B3", 6, "\u50BC"],
    ["8340", "\u50BD", 17, "\u50D0", 5, "\u50D7\u50D8\u50D9\u50DB", 10, "\u50E8\u50E9\u50EA\u50EB\u50EF\u50F0\u50F1\u50F2\u50F4\u50F6", 4, "\u50FC", 9, "\u5108"],
    ["8380", "\u5109\u510A\u510C", 5, "\u5113", 13, "\u5122", 28, "\u5142\u5147\u514A\u514C\u514E\u514F\u5150\u5152\u5153\u5157\u5158\u5159\u515B\u515D", 4, "\u5163\u5164\u5166\u5167\u5169\u516A\u516F\u5172\u517A\u517E\u517F\u5183\u5184\u5186\u5187\u518A\u518B\u518E\u518F\u5190\u5191\u5193\u5194\u5198\u519A\u519D\u519E\u519F\u51A1\u51A3\u51A6", 4, "\u51AD\u51AE\u51B4\u51B8\u51B9\u51BA\u51BE\u51BF\u51C1\u51C2\u51C3\u51C5\u51C8\u51CA\u51CD\u51CE\u51D0\u51D2", 5],
    ["8440", "\u51D8\u51D9\u51DA\u51DC\u51DE\u51DF\u51E2\u51E3\u51E5", 5, "\u51EC\u51EE\u51F1\u51F2\u51F4\u51F7\u51FE\u5204\u5205\u5209\u520B\u520C\u520F\u5210\u5213\u5214\u5215\u521C\u521E\u521F\u5221\u5222\u5223\u5225\u5226\u5227\u522A\u522C\u522F\u5231\u5232\u5234\u5235\u523C\u523E\u5244", 5, "\u524B\u524E\u524F\u5252\u5253\u5255\u5257\u5258"],
    ["8480", "\u5259\u525A\u525B\u525D\u525F\u5260\u5262\u5263\u5264\u5266\u5268\u526B\u526C\u526D\u526E\u5270\u5271\u5273", 9, "\u527E\u5280\u5283", 4, "\u5289", 6, "\u5291\u5292\u5294", 6, "\u529C\u52A4\u52A5\u52A6\u52A7\u52AE\u52AF\u52B0\u52B4", 9, "\u52C0\u52C1\u52C2\u52C4\u52C5\u52C6\u52C8\u52CA\u52CC\u52CD\u52CE\u52CF\u52D1\u52D3\u52D4\u52D5\u52D7\u52D9", 5, "\u52E0\u52E1\u52E2\u52E3\u52E5", 10, "\u52F1", 7, "\u52FB\u52FC\u52FD\u5301\u5302\u5303\u5304\u5307\u5309\u530A\u530B\u530C\u530E"],
    ["8540", "\u5311\u5312\u5313\u5314\u5318\u531B\u531C\u531E\u531F\u5322\u5324\u5325\u5327\u5328\u5329\u532B\u532C\u532D\u532F", 9, "\u533C\u533D\u5340\u5342\u5344\u5346\u534B\u534C\u534D\u5350\u5354\u5358\u5359\u535B\u535D\u5365\u5368\u536A\u536C\u536D\u5372\u5376\u5379\u537B\u537C\u537D\u537E\u5380\u5381\u5383\u5387\u5388\u538A\u538E\u538F"],
    ["8580", "\u5390", 4, "\u5396\u5397\u5399\u539B\u539C\u539E\u53A0\u53A1\u53A4\u53A7\u53AA\u53AB\u53AC\u53AD\u53AF", 6, "\u53B7\u53B8\u53B9\u53BA\u53BC\u53BD\u53BE\u53C0\u53C3", 4, "\u53CE\u53CF\u53D0\u53D2\u53D3\u53D5\u53DA\u53DC\u53DD\u53DE\u53E1\u53E2\u53E7\u53F4\u53FA\u53FE\u53FF\u5400\u5402\u5405\u5407\u540B\u5414\u5418\u5419\u541A\u541C\u5422\u5424\u5425\u542A\u5430\u5433\u5436\u5437\u543A\u543D\u543F\u5441\u5442\u5444\u5445\u5447\u5449\u544C\u544D\u544E\u544F\u5451\u545A\u545D", 4, "\u5463\u5465\u5467\u5469", 7, "\u5474\u5479\u547A\u547E\u547F\u5481\u5483\u5485\u5487\u5488\u5489\u548A\u548D\u5491\u5493\u5497\u5498\u549C\u549E\u549F\u54A0\u54A1"],
    ["8640", "\u54A2\u54A5\u54AE\u54B0\u54B2\u54B5\u54B6\u54B7\u54B9\u54BA\u54BC\u54BE\u54C3\u54C5\u54CA\u54CB\u54D6\u54D8\u54DB\u54E0", 4, "\u54EB\u54EC\u54EF\u54F0\u54F1\u54F4", 5, "\u54FB\u54FE\u5500\u5502\u5503\u5504\u5505\u5508\u550A", 4, "\u5512\u5513\u5515", 5, "\u551C\u551D\u551E\u551F\u5521\u5525\u5526"],
    ["8680", "\u5528\u5529\u552B\u552D\u5532\u5534\u5535\u5536\u5538\u5539\u553A\u553B\u553D\u5540\u5542\u5545\u5547\u5548\u554B", 4, "\u5551\u5552\u5553\u5554\u5557", 4, "\u555D\u555E\u555F\u5560\u5562\u5563\u5568\u5569\u556B\u556F", 5, "\u5579\u557A\u557D\u557F\u5585\u5586\u558C\u558D\u558E\u5590\u5592\u5593\u5595\u5596\u5597\u559A\u559B\u559E\u55A0", 6, "\u55A8", 8, "\u55B2\u55B4\u55B6\u55B8\u55BA\u55BC\u55BF", 4, "\u55C6\u55C7\u55C8\u55CA\u55CB\u55CE\u55CF\u55D0\u55D5\u55D7", 4, "\u55DE\u55E0\u55E2\u55E7\u55E9\u55ED\u55EE\u55F0\u55F1\u55F4\u55F6\u55F8", 4, "\u55FF\u5602\u5603\u5604\u5605"],
    ["8740", "\u5606\u5607\u560A\u560B\u560D\u5610", 7, "\u5619\u561A\u561C\u561D\u5620\u5621\u5622\u5625\u5626\u5628\u5629\u562A\u562B\u562E\u562F\u5630\u5633\u5635\u5637\u5638\u563A\u563C\u563D\u563E\u5640", 11, "\u564F", 4, "\u5655\u5656\u565A\u565B\u565D", 4],
    ["8780", "\u5663\u5665\u5666\u5667\u566D\u566E\u566F\u5670\u5672\u5673\u5674\u5675\u5677\u5678\u5679\u567A\u567D", 7, "\u5687", 6, "\u5690\u5691\u5692\u5694", 14, "\u56A4", 10, "\u56B0", 6, "\u56B8\u56B9\u56BA\u56BB\u56BD", 12, "\u56CB", 8, "\u56D5\u56D6\u56D8\u56D9\u56DC\u56E3\u56E5", 5, "\u56EC\u56EE\u56EF\u56F2\u56F3\u56F6\u56F7\u56F8\u56FB\u56FC\u5700\u5701\u5702\u5705\u5707\u570B", 6],
    ["8840", "\u5712", 9, "\u571D\u571E\u5720\u5721\u5722\u5724\u5725\u5726\u5727\u572B\u5731\u5732\u5734", 4, "\u573C\u573D\u573F\u5741\u5743\u5744\u5745\u5746\u5748\u5749\u574B\u5752", 4, "\u5758\u5759\u5762\u5763\u5765\u5767\u576C\u576E\u5770\u5771\u5772\u5774\u5775\u5778\u5779\u577A\u577D\u577E\u577F\u5780"],
    ["8880", "\u5781\u5787\u5788\u5789\u578A\u578D", 4, "\u5794", 6, "\u579C\u579D\u579E\u579F\u57A5\u57A8\u57AA\u57AC\u57AF\u57B0\u57B1\u57B3\u57B5\u57B6\u57B7\u57B9", 8, "\u57C4", 6, "\u57CC\u57CD\u57D0\u57D1\u57D3\u57D6\u57D7\u57DB\u57DC\u57DE\u57E1\u57E2\u57E3\u57E5", 7, "\u57EE\u57F0\u57F1\u57F2\u57F3\u57F5\u57F6\u57F7\u57FB\u57FC\u57FE\u57FF\u5801\u5803\u5804\u5805\u5808\u5809\u580A\u580C\u580E\u580F\u5810\u5812\u5813\u5814\u5816\u5817\u5818\u581A\u581B\u581C\u581D\u581F\u5822\u5823\u5825", 4, "\u582B", 4, "\u5831\u5832\u5833\u5834\u5836", 7],
    ["8940", "\u583E", 5, "\u5845", 6, "\u584E\u584F\u5850\u5852\u5853\u5855\u5856\u5857\u5859", 4, "\u585F", 5, "\u5866", 4, "\u586D", 16, "\u587F\u5882\u5884\u5886\u5887\u5888\u588A\u588B\u588C"],
    ["8980", "\u588D", 4, "\u5894", 4, "\u589B\u589C\u589D\u58A0", 7, "\u58AA", 17, "\u58BD\u58BE\u58BF\u58C0\u58C2\u58C3\u58C4\u58C6", 10, "\u58D2\u58D3\u58D4\u58D6", 13, "\u58E5", 5, "\u58ED\u58EF\u58F1\u58F2\u58F4\u58F5\u58F7\u58F8\u58FA", 7, "\u5903\u5905\u5906\u5908", 4, "\u590E\u5910\u5911\u5912\u5913\u5917\u5918\u591B\u591D\u591E\u5920\u5921\u5922\u5923\u5926\u5928\u592C\u5930\u5932\u5933\u5935\u5936\u593B"],
    ["8a40", "\u593D\u593E\u593F\u5940\u5943\u5945\u5946\u594A\u594C\u594D\u5950\u5952\u5953\u5959\u595B", 4, "\u5961\u5963\u5964\u5966", 12, "\u5975\u5977\u597A\u597B\u597C\u597E\u597F\u5980\u5985\u5989\u598B\u598C\u598E\u598F\u5990\u5991\u5994\u5995\u5998\u599A\u599B\u599C\u599D\u599F\u59A0\u59A1\u59A2\u59A6"],
    ["8a80", "\u59A7\u59AC\u59AD\u59B0\u59B1\u59B3", 5, "\u59BA\u59BC\u59BD\u59BF", 6, "\u59C7\u59C8\u59C9\u59CC\u59CD\u59CE\u59CF\u59D5\u59D6\u59D9\u59DB\u59DE", 4, "\u59E4\u59E6\u59E7\u59E9\u59EA\u59EB\u59ED", 11, "\u59FA\u59FC\u59FD\u59FE\u5A00\u5A02\u5A0A\u5A0B\u5A0D\u5A0E\u5A0F\u5A10\u5A12\u5A14\u5A15\u5A16\u5A17\u5A19\u5A1A\u5A1B\u5A1D\u5A1E\u5A21\u5A22\u5A24\u5A26\u5A27\u5A28\u5A2A", 6, "\u5A33\u5A35\u5A37", 4, "\u5A3D\u5A3E\u5A3F\u5A41", 4, "\u5A47\u5A48\u5A4B", 9, "\u5A56\u5A57\u5A58\u5A59\u5A5B", 5],
    ["8b40", "\u5A61\u5A63\u5A64\u5A65\u5A66\u5A68\u5A69\u5A6B", 8, "\u5A78\u5A79\u5A7B\u5A7C\u5A7D\u5A7E\u5A80", 17, "\u5A93", 6, "\u5A9C", 13, "\u5AAB\u5AAC"],
    ["8b80", "\u5AAD", 4, "\u5AB4\u5AB6\u5AB7\u5AB9", 4, "\u5ABF\u5AC0\u5AC3", 5, "\u5ACA\u5ACB\u5ACD", 4, "\u5AD3\u5AD5\u5AD7\u5AD9\u5ADA\u5ADB\u5ADD\u5ADE\u5ADF\u5AE2\u5AE4\u5AE5\u5AE7\u5AE8\u5AEA\u5AEC", 4, "\u5AF2", 22, "\u5B0A", 11, "\u5B18", 25, "\u5B33\u5B35\u5B36\u5B38", 7, "\u5B41", 6],
    ["8c40", "\u5B48", 7, "\u5B52\u5B56\u5B5E\u5B60\u5B61\u5B67\u5B68\u5B6B\u5B6D\u5B6E\u5B6F\u5B72\u5B74\u5B76\u5B77\u5B78\u5B79\u5B7B\u5B7C\u5B7E\u5B7F\u5B82\u5B86\u5B8A\u5B8D\u5B8E\u5B90\u5B91\u5B92\u5B94\u5B96\u5B9F\u5BA7\u5BA8\u5BA9\u5BAC\u5BAD\u5BAE\u5BAF\u5BB1\u5BB2\u5BB7\u5BBA\u5BBB\u5BBC\u5BC0\u5BC1\u5BC3\u5BC8\u5BC9\u5BCA\u5BCB\u5BCD\u5BCE\u5BCF"],
    ["8c80", "\u5BD1\u5BD4", 8, "\u5BE0\u5BE2\u5BE3\u5BE6\u5BE7\u5BE9", 4, "\u5BEF\u5BF1", 6, "\u5BFD\u5BFE\u5C00\u5C02\u5C03\u5C05\u5C07\u5C08\u5C0B\u5C0C\u5C0D\u5C0E\u5C10\u5C12\u5C13\u5C17\u5C19\u5C1B\u5C1E\u5C1F\u5C20\u5C21\u5C23\u5C26\u5C28\u5C29\u5C2A\u5C2B\u5C2D\u5C2E\u5C2F\u5C30\u5C32\u5C33\u5C35\u5C36\u5C37\u5C43\u5C44\u5C46\u5C47\u5C4C\u5C4D\u5C52\u5C53\u5C54\u5C56\u5C57\u5C58\u5C5A\u5C5B\u5C5C\u5C5D\u5C5F\u5C62\u5C64\u5C67", 6, "\u5C70\u5C72", 6, "\u5C7B\u5C7C\u5C7D\u5C7E\u5C80\u5C83", 4, "\u5C89\u5C8A\u5C8B\u5C8E\u5C8F\u5C92\u5C93\u5C95\u5C9D", 4, "\u5CA4", 4],
    ["8d40", "\u5CAA\u5CAE\u5CAF\u5CB0\u5CB2\u5CB4\u5CB6\u5CB9\u5CBA\u5CBB\u5CBC\u5CBE\u5CC0\u5CC2\u5CC3\u5CC5", 5, "\u5CCC", 5, "\u5CD3", 5, "\u5CDA", 6, "\u5CE2\u5CE3\u5CE7\u5CE9\u5CEB\u5CEC\u5CEE\u5CEF\u5CF1", 9, "\u5CFC", 4],
    ["8d80", "\u5D01\u5D04\u5D05\u5D08", 5, "\u5D0F", 4, "\u5D15\u5D17\u5D18\u5D19\u5D1A\u5D1C\u5D1D\u5D1F", 4, "\u5D25\u5D28\u5D2A\u5D2B\u5D2C\u5D2F", 4, "\u5D35", 7, "\u5D3F", 7, "\u5D48\u5D49\u5D4D", 10, "\u5D59\u5D5A\u5D5C\u5D5E", 10, "\u5D6A\u5D6D\u5D6E\u5D70\u5D71\u5D72\u5D73\u5D75", 12, "\u5D83", 21, "\u5D9A\u5D9B\u5D9C\u5D9E\u5D9F\u5DA0"],
    ["8e40", "\u5DA1", 21, "\u5DB8", 12, "\u5DC6", 6, "\u5DCE", 12, "\u5DDC\u5DDF\u5DE0\u5DE3\u5DE4\u5DEA\u5DEC\u5DED"],
    ["8e80", "\u5DF0\u5DF5\u5DF6\u5DF8", 4, "\u5DFF\u5E00\u5E04\u5E07\u5E09\u5E0A\u5E0B\u5E0D\u5E0E\u5E12\u5E13\u5E17\u5E1E", 7, "\u5E28", 4, "\u5E2F\u5E30\u5E32", 4, "\u5E39\u5E3A\u5E3E\u5E3F\u5E40\u5E41\u5E43\u5E46", 5, "\u5E4D", 6, "\u5E56", 4, "\u5E5C\u5E5D\u5E5F\u5E60\u5E63", 14, "\u5E75\u5E77\u5E79\u5E7E\u5E81\u5E82\u5E83\u5E85\u5E88\u5E89\u5E8C\u5E8D\u5E8E\u5E92\u5E98\u5E9B\u5E9D\u5EA1\u5EA2\u5EA3\u5EA4\u5EA8", 4, "\u5EAE", 4, "\u5EB4\u5EBA\u5EBB\u5EBC\u5EBD\u5EBF", 6],
    ["8f40", "\u5EC6\u5EC7\u5EC8\u5ECB", 5, "\u5ED4\u5ED5\u5ED7\u5ED8\u5ED9\u5EDA\u5EDC", 11, "\u5EE9\u5EEB", 8, "\u5EF5\u5EF8\u5EF9\u5EFB\u5EFC\u5EFD\u5F05\u5F06\u5F07\u5F09\u5F0C\u5F0D\u5F0E\u5F10\u5F12\u5F14\u5F16\u5F19\u5F1A\u5F1C\u5F1D\u5F1E\u5F21\u5F22\u5F23\u5F24"],
    ["8f80", "\u5F28\u5F2B\u5F2C\u5F2E\u5F30\u5F32", 6, "\u5F3B\u5F3D\u5F3E\u5F3F\u5F41", 14, "\u5F51\u5F54\u5F59\u5F5A\u5F5B\u5F5C\u5F5E\u5F5F\u5F60\u5F63\u5F65\u5F67\u5F68\u5F6B\u5F6E\u5F6F\u5F72\u5F74\u5F75\u5F76\u5F78\u5F7A\u5F7D\u5F7E\u5F7F\u5F83\u5F86\u5F8D\u5F8E\u5F8F\u5F91\u5F93\u5F94\u5F96\u5F9A\u5F9B\u5F9D\u5F9E\u5F9F\u5FA0\u5FA2", 5, "\u5FA9\u5FAB\u5FAC\u5FAF", 5, "\u5FB6\u5FB8\u5FB9\u5FBA\u5FBB\u5FBE", 4, "\u5FC7\u5FC8\u5FCA\u5FCB\u5FCE\u5FD3\u5FD4\u5FD5\u5FDA\u5FDB\u5FDC\u5FDE\u5FDF\u5FE2\u5FE3\u5FE5\u5FE6\u5FE8\u5FE9\u5FEC\u5FEF\u5FF0\u5FF2\u5FF3\u5FF4\u5FF6\u5FF7\u5FF9\u5FFA\u5FFC\u6007"],
    ["9040", "\u6008\u6009\u600B\u600C\u6010\u6011\u6013\u6017\u6018\u601A\u601E\u601F\u6022\u6023\u6024\u602C\u602D\u602E\u6030", 4, "\u6036", 4, "\u603D\u603E\u6040\u6044", 6, "\u604C\u604E\u604F\u6051\u6053\u6054\u6056\u6057\u6058\u605B\u605C\u605E\u605F\u6060\u6061\u6065\u6066\u606E\u6071\u6072\u6074\u6075\u6077\u607E\u6080"],
    ["9080", "\u6081\u6082\u6085\u6086\u6087\u6088\u608A\u608B\u608E\u608F\u6090\u6091\u6093\u6095\u6097\u6098\u6099\u609C\u609E\u60A1\u60A2\u60A4\u60A5\u60A7\u60A9\u60AA\u60AE\u60B0\u60B3\u60B5\u60B6\u60B7\u60B9\u60BA\u60BD", 7, "\u60C7\u60C8\u60C9\u60CC", 4, "\u60D2\u60D3\u60D4\u60D6\u60D7\u60D9\u60DB\u60DE\u60E1", 4, "\u60EA\u60F1\u60F2\u60F5\u60F7\u60F8\u60FB", 4, "\u6102\u6103\u6104\u6105\u6107\u610A\u610B\u610C\u6110", 4, "\u6116\u6117\u6118\u6119\u611B\u611C\u611D\u611E\u6121\u6122\u6125\u6128\u6129\u612A\u612C", 18, "\u6140", 6],
    ["9140", "\u6147\u6149\u614B\u614D\u614F\u6150\u6152\u6153\u6154\u6156", 6, "\u615E\u615F\u6160\u6161\u6163\u6164\u6165\u6166\u6169", 6, "\u6171\u6172\u6173\u6174\u6176\u6178", 18, "\u618C\u618D\u618F", 4, "\u6195"],
    ["9180", "\u6196", 6, "\u619E", 8, "\u61AA\u61AB\u61AD", 9, "\u61B8", 5, "\u61BF\u61C0\u61C1\u61C3", 4, "\u61C9\u61CC", 4, "\u61D3\u61D5", 16, "\u61E7", 13, "\u61F6", 8, "\u6200", 5, "\u6207\u6209\u6213\u6214\u6219\u621C\u621D\u621E\u6220\u6223\u6226\u6227\u6228\u6229\u622B\u622D\u622F\u6230\u6231\u6232\u6235\u6236\u6238", 4, "\u6242\u6244\u6245\u6246\u624A"],
    ["9240", "\u624F\u6250\u6255\u6256\u6257\u6259\u625A\u625C", 6, "\u6264\u6265\u6268\u6271\u6272\u6274\u6275\u6277\u6278\u627A\u627B\u627D\u6281\u6282\u6283\u6285\u6286\u6287\u6288\u628B", 5, "\u6294\u6299\u629C\u629D\u629E\u62A3\u62A6\u62A7\u62A9\u62AA\u62AD\u62AE\u62AF\u62B0\u62B2\u62B3\u62B4\u62B6\u62B7\u62B8\u62BA\u62BE\u62C0\u62C1"],
    ["9280", "\u62C3\u62CB\u62CF\u62D1\u62D5\u62DD\u62DE\u62E0\u62E1\u62E4\u62EA\u62EB\u62F0\u62F2\u62F5\u62F8\u62F9\u62FA\u62FB\u6300\u6303\u6304\u6305\u6306\u630A\u630B\u630C\u630D\u630F\u6310\u6312\u6313\u6314\u6315\u6317\u6318\u6319\u631C\u6326\u6327\u6329\u632C\u632D\u632E\u6330\u6331\u6333", 5, "\u633B\u633C\u633E\u633F\u6340\u6341\u6344\u6347\u6348\u634A\u6351\u6352\u6353\u6354\u6356", 7, "\u6360\u6364\u6365\u6366\u6368\u636A\u636B\u636C\u636F\u6370\u6372\u6373\u6374\u6375\u6378\u6379\u637C\u637D\u637E\u637F\u6381\u6383\u6384\u6385\u6386\u638B\u638D\u6391\u6393\u6394\u6395\u6397\u6399", 6, "\u63A1\u63A4\u63A6\u63AB\u63AF\u63B1\u63B2\u63B5\u63B6\u63B9\u63BB\u63BD\u63BF\u63C0"],
    ["9340", "\u63C1\u63C2\u63C3\u63C5\u63C7\u63C8\u63CA\u63CB\u63CC\u63D1\u63D3\u63D4\u63D5\u63D7", 6, "\u63DF\u63E2\u63E4", 4, "\u63EB\u63EC\u63EE\u63EF\u63F0\u63F1\u63F3\u63F5\u63F7\u63F9\u63FA\u63FB\u63FC\u63FE\u6403\u6404\u6406", 4, "\u640D\u640E\u6411\u6412\u6415", 5, "\u641D\u641F\u6422\u6423\u6424"],
    ["9380", "\u6425\u6427\u6428\u6429\u642B\u642E", 5, "\u6435", 4, "\u643B\u643C\u643E\u6440\u6442\u6443\u6449\u644B", 6, "\u6453\u6455\u6456\u6457\u6459", 4, "\u645F", 7, "\u6468\u646A\u646B\u646C\u646E", 9, "\u647B", 6, "\u6483\u6486\u6488", 8, "\u6493\u6494\u6497\u6498\u649A\u649B\u649C\u649D\u649F", 4, "\u64A5\u64A6\u64A7\u64A8\u64AA\u64AB\u64AF\u64B1\u64B2\u64B3\u64B4\u64B6\u64B9\u64BB\u64BD\u64BE\u64BF\u64C1\u64C3\u64C4\u64C6", 6, "\u64CF\u64D1\u64D3\u64D4\u64D5\u64D6\u64D9\u64DA"],
    ["9440", "\u64DB\u64DC\u64DD\u64DF\u64E0\u64E1\u64E3\u64E5\u64E7", 24, "\u6501", 7, "\u650A", 7, "\u6513", 4, "\u6519", 8],
    ["9480", "\u6522\u6523\u6524\u6526", 4, "\u652C\u652D\u6530\u6531\u6532\u6533\u6537\u653A\u653C\u653D\u6540", 4, "\u6546\u6547\u654A\u654B\u654D\u654E\u6550\u6552\u6553\u6554\u6557\u6558\u655A\u655C\u655F\u6560\u6561\u6564\u6565\u6567\u6568\u6569\u656A\u656D\u656E\u656F\u6571\u6573\u6575\u6576\u6578", 14, "\u6588\u6589\u658A\u658D\u658E\u658F\u6592\u6594\u6595\u6596\u6598\u659A\u659D\u659E\u65A0\u65A2\u65A3\u65A6\u65A8\u65AA\u65AC\u65AE\u65B1", 7, "\u65BA\u65BB\u65BE\u65BF\u65C0\u65C2\u65C7\u65C8\u65C9\u65CA\u65CD\u65D0\u65D1\u65D3\u65D4\u65D5\u65D8", 7, "\u65E1\u65E3\u65E4\u65EA\u65EB"],
    ["9540", "\u65F2\u65F3\u65F4\u65F5\u65F8\u65F9\u65FB", 4, "\u6601\u6604\u6605\u6607\u6608\u6609\u660B\u660D\u6610\u6611\u6612\u6616\u6617\u6618\u661A\u661B\u661C\u661E\u6621\u6622\u6623\u6624\u6626\u6629\u662A\u662B\u662C\u662E\u6630\u6632\u6633\u6637", 4, "\u663D\u663F\u6640\u6642\u6644", 6, "\u664D\u664E\u6650\u6651\u6658"],
    ["9580", "\u6659\u665B\u665C\u665D\u665E\u6660\u6662\u6663\u6665\u6667\u6669", 4, "\u6671\u6672\u6673\u6675\u6678\u6679\u667B\u667C\u667D\u667F\u6680\u6681\u6683\u6685\u6686\u6688\u6689\u668A\u668B\u668D\u668E\u668F\u6690\u6692\u6693\u6694\u6695\u6698", 4, "\u669E", 8, "\u66A9", 4, "\u66AF", 4, "\u66B5\u66B6\u66B7\u66B8\u66BA\u66BB\u66BC\u66BD\u66BF", 25, "\u66DA\u66DE", 7, "\u66E7\u66E8\u66EA", 5, "\u66F1\u66F5\u66F6\u66F8\u66FA\u66FB\u66FD\u6701\u6702\u6703"],
    ["9640", "\u6704\u6705\u6706\u6707\u670C\u670E\u670F\u6711\u6712\u6713\u6716\u6718\u6719\u671A\u671C\u671E\u6720", 5, "\u6727\u6729\u672E\u6730\u6732\u6733\u6736\u6737\u6738\u6739\u673B\u673C\u673E\u673F\u6741\u6744\u6745\u6747\u674A\u674B\u674D\u6752\u6754\u6755\u6757", 4, "\u675D\u6762\u6763\u6764\u6766\u6767\u676B\u676C\u676E\u6771\u6774\u6776"],
    ["9680", "\u6778\u6779\u677A\u677B\u677D\u6780\u6782\u6783\u6785\u6786\u6788\u678A\u678C\u678D\u678E\u678F\u6791\u6792\u6793\u6794\u6796\u6799\u679B\u679F\u67A0\u67A1\u67A4\u67A6\u67A9\u67AC\u67AE\u67B1\u67B2\u67B4\u67B9", 7, "\u67C2\u67C5", 9, "\u67D5\u67D6\u67D7\u67DB\u67DF\u67E1\u67E3\u67E4\u67E6\u67E7\u67E8\u67EA\u67EB\u67ED\u67EE\u67F2\u67F5", 7, "\u67FE\u6801\u6802\u6803\u6804\u6806\u680D\u6810\u6812\u6814\u6815\u6818", 4, "\u681E\u681F\u6820\u6822", 6, "\u682B", 6, "\u6834\u6835\u6836\u683A\u683B\u683F\u6847\u684B\u684D\u684F\u6852\u6856", 5],
    ["9740", "\u685C\u685D\u685E\u685F\u686A\u686C", 7, "\u6875\u6878", 8, "\u6882\u6884\u6887", 7, "\u6890\u6891\u6892\u6894\u6895\u6896\u6898", 9, "\u68A3\u68A4\u68A5\u68A9\u68AA\u68AB\u68AC\u68AE\u68B1\u68B2\u68B4\u68B6\u68B7\u68B8"],
    ["9780", "\u68B9", 6, "\u68C1\u68C3", 5, "\u68CA\u68CC\u68CE\u68CF\u68D0\u68D1\u68D3\u68D4\u68D6\u68D7\u68D9\u68DB", 4, "\u68E1\u68E2\u68E4", 9, "\u68EF\u68F2\u68F3\u68F4\u68F6\u68F7\u68F8\u68FB\u68FD\u68FE\u68FF\u6900\u6902\u6903\u6904\u6906", 4, "\u690C\u690F\u6911\u6913", 11, "\u6921\u6922\u6923\u6925", 7, "\u692E\u692F\u6931\u6932\u6933\u6935\u6936\u6937\u6938\u693A\u693B\u693C\u693E\u6940\u6941\u6943", 16, "\u6955\u6956\u6958\u6959\u695B\u695C\u695F"],
    ["9840", "\u6961\u6962\u6964\u6965\u6967\u6968\u6969\u696A\u696C\u696D\u696F\u6970\u6972", 4, "\u697A\u697B\u697D\u697E\u697F\u6981\u6983\u6985\u698A\u698B\u698C\u698E", 5, "\u6996\u6997\u6999\u699A\u699D", 9, "\u69A9\u69AA\u69AC\u69AE\u69AF\u69B0\u69B2\u69B3\u69B5\u69B6\u69B8\u69B9\u69BA\u69BC\u69BD"],
    ["9880", "\u69BE\u69BF\u69C0\u69C2", 7, "\u69CB\u69CD\u69CF\u69D1\u69D2\u69D3\u69D5", 5, "\u69DC\u69DD\u69DE\u69E1", 11, "\u69EE\u69EF\u69F0\u69F1\u69F3", 9, "\u69FE\u6A00", 9, "\u6A0B", 11, "\u6A19", 5, "\u6A20\u6A22", 5, "\u6A29\u6A2B\u6A2C\u6A2D\u6A2E\u6A30\u6A32\u6A33\u6A34\u6A36", 6, "\u6A3F", 4, "\u6A45\u6A46\u6A48", 7, "\u6A51", 6, "\u6A5A"],
    ["9940", "\u6A5C", 4, "\u6A62\u6A63\u6A64\u6A66", 10, "\u6A72", 6, "\u6A7A\u6A7B\u6A7D\u6A7E\u6A7F\u6A81\u6A82\u6A83\u6A85", 8, "\u6A8F\u6A92", 4, "\u6A98", 7, "\u6AA1", 5],
    ["9980", "\u6AA7\u6AA8\u6AAA\u6AAD", 114, "\u6B25\u6B26\u6B28", 6],
    ["9a40", "\u6B2F\u6B30\u6B31\u6B33\u6B34\u6B35\u6B36\u6B38\u6B3B\u6B3C\u6B3D\u6B3F\u6B40\u6B41\u6B42\u6B44\u6B45\u6B48\u6B4A\u6B4B\u6B4D", 11, "\u6B5A", 7, "\u6B68\u6B69\u6B6B", 13, "\u6B7A\u6B7D\u6B7E\u6B7F\u6B80\u6B85\u6B88"],
    ["9a80", "\u6B8C\u6B8E\u6B8F\u6B90\u6B91\u6B94\u6B95\u6B97\u6B98\u6B99\u6B9C", 4, "\u6BA2", 7, "\u6BAB", 7, "\u6BB6\u6BB8", 6, "\u6BC0\u6BC3\u6BC4\u6BC6", 4, "\u6BCC\u6BCE\u6BD0\u6BD1\u6BD8\u6BDA\u6BDC", 4, "\u6BE2", 7, "\u6BEC\u6BED\u6BEE\u6BF0\u6BF1\u6BF2\u6BF4\u6BF6\u6BF7\u6BF8\u6BFA\u6BFB\u6BFC\u6BFE", 6, "\u6C08", 4, "\u6C0E\u6C12\u6C17\u6C1C\u6C1D\u6C1E\u6C20\u6C23\u6C25\u6C2B\u6C2C\u6C2D\u6C31\u6C33\u6C36\u6C37\u6C39\u6C3A\u6C3B\u6C3C\u6C3E\u6C3F\u6C43\u6C44\u6C45\u6C48\u6C4B", 4, "\u6C51\u6C52\u6C53\u6C56\u6C58"],
    ["9b40", "\u6C59\u6C5A\u6C62\u6C63\u6C65\u6C66\u6C67\u6C6B", 4, "\u6C71\u6C73\u6C75\u6C77\u6C78\u6C7A\u6C7B\u6C7C\u6C7F\u6C80\u6C84\u6C87\u6C8A\u6C8B\u6C8D\u6C8E\u6C91\u6C92\u6C95\u6C96\u6C97\u6C98\u6C9A\u6C9C\u6C9D\u6C9E\u6CA0\u6CA2\u6CA8\u6CAC\u6CAF\u6CB0\u6CB4\u6CB5\u6CB6\u6CB7\u6CBA\u6CC0\u6CC1\u6CC2\u6CC3\u6CC6\u6CC7\u6CC8\u6CCB\u6CCD\u6CCE\u6CCF\u6CD1\u6CD2\u6CD8"],
    ["9b80", "\u6CD9\u6CDA\u6CDC\u6CDD\u6CDF\u6CE4\u6CE6\u6CE7\u6CE9\u6CEC\u6CED\u6CF2\u6CF4\u6CF9\u6CFF\u6D00\u6D02\u6D03\u6D05\u6D06\u6D08\u6D09\u6D0A\u6D0D\u6D0F\u6D10\u6D11\u6D13\u6D14\u6D15\u6D16\u6D18\u6D1C\u6D1D\u6D1F", 5, "\u6D26\u6D28\u6D29\u6D2C\u6D2D\u6D2F\u6D30\u6D34\u6D36\u6D37\u6D38\u6D3A\u6D3F\u6D40\u6D42\u6D44\u6D49\u6D4C\u6D50\u6D55\u6D56\u6D57\u6D58\u6D5B\u6D5D\u6D5F\u6D61\u6D62\u6D64\u6D65\u6D67\u6D68\u6D6B\u6D6C\u6D6D\u6D70\u6D71\u6D72\u6D73\u6D75\u6D76\u6D79\u6D7A\u6D7B\u6D7D", 4, "\u6D83\u6D84\u6D86\u6D87\u6D8A\u6D8B\u6D8D\u6D8F\u6D90\u6D92\u6D96", 4, "\u6D9C\u6DA2\u6DA5\u6DAC\u6DAD\u6DB0\u6DB1\u6DB3\u6DB4\u6DB6\u6DB7\u6DB9", 5, "\u6DC1\u6DC2\u6DC3\u6DC8\u6DC9\u6DCA"],
    ["9c40", "\u6DCD\u6DCE\u6DCF\u6DD0\u6DD2\u6DD3\u6DD4\u6DD5\u6DD7\u6DDA\u6DDB\u6DDC\u6DDF\u6DE2\u6DE3\u6DE5\u6DE7\u6DE8\u6DE9\u6DEA\u6DED\u6DEF\u6DF0\u6DF2\u6DF4\u6DF5\u6DF6\u6DF8\u6DFA\u6DFD", 7, "\u6E06\u6E07\u6E08\u6E09\u6E0B\u6E0F\u6E12\u6E13\u6E15\u6E18\u6E19\u6E1B\u6E1C\u6E1E\u6E1F\u6E22\u6E26\u6E27\u6E28\u6E2A\u6E2C\u6E2E\u6E30\u6E31\u6E33\u6E35"],
    ["9c80", "\u6E36\u6E37\u6E39\u6E3B", 7, "\u6E45", 7, "\u6E4F\u6E50\u6E51\u6E52\u6E55\u6E57\u6E59\u6E5A\u6E5C\u6E5D\u6E5E\u6E60", 10, "\u6E6C\u6E6D\u6E6F", 14, "\u6E80\u6E81\u6E82\u6E84\u6E87\u6E88\u6E8A", 4, "\u6E91", 6, "\u6E99\u6E9A\u6E9B\u6E9D\u6E9E\u6EA0\u6EA1\u6EA3\u6EA4\u6EA6\u6EA8\u6EA9\u6EAB\u6EAC\u6EAD\u6EAE\u6EB0\u6EB3\u6EB5\u6EB8\u6EB9\u6EBC\u6EBE\u6EBF\u6EC0\u6EC3\u6EC4\u6EC5\u6EC6\u6EC8\u6EC9\u6ECA\u6ECC\u6ECD\u6ECE\u6ED0\u6ED2\u6ED6\u6ED8\u6ED9\u6EDB\u6EDC\u6EDD\u6EE3\u6EE7\u6EEA", 5],
    ["9d40", "\u6EF0\u6EF1\u6EF2\u6EF3\u6EF5\u6EF6\u6EF7\u6EF8\u6EFA", 7, "\u6F03\u6F04\u6F05\u6F07\u6F08\u6F0A", 4, "\u6F10\u6F11\u6F12\u6F16", 9, "\u6F21\u6F22\u6F23\u6F25\u6F26\u6F27\u6F28\u6F2C\u6F2E\u6F30\u6F32\u6F34\u6F35\u6F37", 6, "\u6F3F\u6F40\u6F41\u6F42"],
    ["9d80", "\u6F43\u6F44\u6F45\u6F48\u6F49\u6F4A\u6F4C\u6F4E", 9, "\u6F59\u6F5A\u6F5B\u6F5D\u6F5F\u6F60\u6F61\u6F63\u6F64\u6F65\u6F67", 5, "\u6F6F\u6F70\u6F71\u6F73\u6F75\u6F76\u6F77\u6F79\u6F7B\u6F7D", 6, "\u6F85\u6F86\u6F87\u6F8A\u6F8B\u6F8F", 12, "\u6F9D\u6F9E\u6F9F\u6FA0\u6FA2", 4, "\u6FA8", 10, "\u6FB4\u6FB5\u6FB7\u6FB8\u6FBA", 5, "\u6FC1\u6FC3", 5, "\u6FCA", 6, "\u6FD3", 10, "\u6FDF\u6FE2\u6FE3\u6FE4\u6FE5"],
    ["9e40", "\u6FE6", 7, "\u6FF0", 32, "\u7012", 7, "\u701C", 6, "\u7024", 6],
    ["9e80", "\u702B", 9, "\u7036\u7037\u7038\u703A", 17, "\u704D\u704E\u7050", 13, "\u705F", 11, "\u706E\u7071\u7072\u7073\u7074\u7077\u7079\u707A\u707B\u707D\u7081\u7082\u7083\u7084\u7086\u7087\u7088\u708B\u708C\u708D\u708F\u7090\u7091\u7093\u7097\u7098\u709A\u709B\u709E", 12, "\u70B0\u70B2\u70B4\u70B5\u70B6\u70BA\u70BE\u70BF\u70C4\u70C5\u70C6\u70C7\u70C9\u70CB", 12, "\u70DA"],
    ["9f40", "\u70DC\u70DD\u70DE\u70E0\u70E1\u70E2\u70E3\u70E5\u70EA\u70EE\u70F0", 6, "\u70F8\u70FA\u70FB\u70FC\u70FE", 10, "\u710B", 4, "\u7111\u7112\u7114\u7117\u711B", 10, "\u7127", 7, "\u7132\u7133\u7134"],
    ["9f80", "\u7135\u7137", 13, "\u7146\u7147\u7148\u7149\u714B\u714D\u714F", 12, "\u715D\u715F", 4, "\u7165\u7169", 4, "\u716F\u7170\u7171\u7174\u7175\u7176\u7177\u7179\u717B\u717C\u717E", 5, "\u7185", 4, "\u718B\u718C\u718D\u718E\u7190\u7191\u7192\u7193\u7195\u7196\u7197\u719A", 4, "\u71A1", 6, "\u71A9\u71AA\u71AB\u71AD", 5, "\u71B4\u71B6\u71B7\u71B8\u71BA", 8, "\u71C4", 9, "\u71CF", 4],
    ["a040", "\u71D6", 9, "\u71E1\u71E2\u71E3\u71E4\u71E6\u71E8", 5, "\u71EF", 9, "\u71FA", 11, "\u7207", 19],
    ["a080", "\u721B\u721C\u721E", 9, "\u7229\u722B\u722D\u722E\u722F\u7232\u7233\u7234\u723A\u723C\u723E\u7240", 6, "\u7249\u724A\u724B\u724E\u724F\u7250\u7251\u7253\u7254\u7255\u7257\u7258\u725A\u725C\u725E\u7260\u7263\u7264\u7265\u7268\u726A\u726B\u726C\u726D\u7270\u7271\u7273\u7274\u7276\u7277\u7278\u727B\u727C\u727D\u7282\u7283\u7285", 4, "\u728C\u728E\u7290\u7291\u7293", 11, "\u72A0", 11, "\u72AE\u72B1\u72B2\u72B3\u72B5\u72BA", 6, "\u72C5\u72C6\u72C7\u72C9\u72CA\u72CB\u72CC\u72CF\u72D1\u72D3\u72D4\u72D5\u72D6\u72D8\u72DA\u72DB"],
    ["a1a1", "\u3000\u3001\u3002\xB7\u02C9\u02C7\xA8\u3003\u3005\u2014\uFF5E\u2016\u2026\u2018\u2019\u201C\u201D\u3014\u3015\u3008", 7, "\u3016\u3017\u3010\u3011\xB1\xD7\xF7\u2236\u2227\u2228\u2211\u220F\u222A\u2229\u2208\u2237\u221A\u22A5\u2225\u2220\u2312\u2299\u222B\u222E\u2261\u224C\u2248\u223D\u221D\u2260\u226E\u226F\u2264\u2265\u221E\u2235\u2234\u2642\u2640\xB0\u2032\u2033\u2103\uFF04\xA4\uFFE0\uFFE1\u2030\xA7\u2116\u2606\u2605\u25CB\u25CF\u25CE\u25C7\u25C6\u25A1\u25A0\u25B3\u25B2\u203B\u2192\u2190\u2191\u2193\u3013"],
    ["a2a1", "\u2170", 9],
    ["a2b1", "\u2488", 19, "\u2474", 19, "\u2460", 9],
    ["a2e5", "\u3220", 9],
    ["a2f1", "\u2160", 11],
    ["a3a1", "\uFF01\uFF02\uFF03\uFFE5\uFF05", 88, "\uFFE3"],
    ["a4a1", "\u3041", 82],
    ["a5a1", "\u30A1", 85],
    ["a6a1", "\u0391", 16, "\u03A3", 6],
    ["a6c1", "\u03B1", 16, "\u03C3", 6],
    ["a6e0", "\uFE35\uFE36\uFE39\uFE3A\uFE3F\uFE40\uFE3D\uFE3E\uFE41\uFE42\uFE43\uFE44"],
    ["a6ee", "\uFE3B\uFE3C\uFE37\uFE38\uFE31"],
    ["a6f4", "\uFE33\uFE34"],
    ["a7a1", "\u0410", 5, "\u0401\u0416", 25],
    ["a7d1", "\u0430", 5, "\u0451\u0436", 25],
    ["a840", "\u02CA\u02CB\u02D9\u2013\u2015\u2025\u2035\u2105\u2109\u2196\u2197\u2198\u2199\u2215\u221F\u2223\u2252\u2266\u2267\u22BF\u2550", 35, "\u2581", 6],
    ["a880", "\u2588", 7, "\u2593\u2594\u2595\u25BC\u25BD\u25E2\u25E3\u25E4\u25E5\u2609\u2295\u3012\u301D\u301E"],
    ["a8a1", "\u0101\xE1\u01CE\xE0\u0113\xE9\u011B\xE8\u012B\xED\u01D0\xEC\u014D\xF3\u01D2\xF2\u016B\xFA\u01D4\xF9\u01D6\u01D8\u01DA\u01DC\xFC\xEA\u0251"],
    ["a8bd", "\u0144\u0148"],
    ["a8c0", "\u0261"],
    ["a8c5", "\u3105", 36],
    ["a940", "\u3021", 8, "\u32A3\u338E\u338F\u339C\u339D\u339E\u33A1\u33C4\u33CE\u33D1\u33D2\u33D5\uFE30\uFFE2\uFFE4"],
    ["a959", "\u2121\u3231"],
    ["a95c", "\u2010"],
    ["a960", "\u30FC\u309B\u309C\u30FD\u30FE\u3006\u309D\u309E\uFE49", 9, "\uFE54\uFE55\uFE56\uFE57\uFE59", 8],
    ["a980", "\uFE62", 4, "\uFE68\uFE69\uFE6A\uFE6B"],
    ["a996", "\u3007"],
    ["a9a4", "\u2500", 75],
    ["aa40", "\u72DC\u72DD\u72DF\u72E2", 5, "\u72EA\u72EB\u72F5\u72F6\u72F9\u72FD\u72FE\u72FF\u7300\u7302\u7304", 5, "\u730B\u730C\u730D\u730F\u7310\u7311\u7312\u7314\u7318\u7319\u731A\u731F\u7320\u7323\u7324\u7326\u7327\u7328\u732D\u732F\u7330\u7332\u7333\u7335\u7336\u733A\u733B\u733C\u733D\u7340", 8],
    ["aa80", "\u7349\u734A\u734B\u734C\u734E\u734F\u7351\u7353\u7354\u7355\u7356\u7358", 7, "\u7361", 10, "\u736E\u7370\u7371"],
    ["ab40", "\u7372", 11, "\u737F", 4, "\u7385\u7386\u7388\u738A\u738C\u738D\u738F\u7390\u7392\u7393\u7394\u7395\u7397\u7398\u7399\u739A\u739C\u739D\u739E\u73A0\u73A1\u73A3", 5, "\u73AA\u73AC\u73AD\u73B1\u73B4\u73B5\u73B6\u73B8\u73B9\u73BC\u73BD\u73BE\u73BF\u73C1\u73C3", 4],
    ["ab80", "\u73CB\u73CC\u73CE\u73D2", 6, "\u73DA\u73DB\u73DC\u73DD\u73DF\u73E1\u73E2\u73E3\u73E4\u73E6\u73E8\u73EA\u73EB\u73EC\u73EE\u73EF\u73F0\u73F1\u73F3", 4],
    ["ac40", "\u73F8", 10, "\u7404\u7407\u7408\u740B\u740C\u740D\u740E\u7411", 8, "\u741C", 5, "\u7423\u7424\u7427\u7429\u742B\u742D\u742F\u7431\u7432\u7437", 4, "\u743D\u743E\u743F\u7440\u7442", 11],
    ["ac80", "\u744E", 6, "\u7456\u7458\u745D\u7460", 12, "\u746E\u746F\u7471", 4, "\u7478\u7479\u747A"],
    ["ad40", "\u747B\u747C\u747D\u747F\u7482\u7484\u7485\u7486\u7488\u7489\u748A\u748C\u748D\u748F\u7491", 10, "\u749D\u749F", 7, "\u74AA", 15, "\u74BB", 12],
    ["ad80", "\u74C8", 9, "\u74D3", 8, "\u74DD\u74DF\u74E1\u74E5\u74E7", 6, "\u74F0\u74F1\u74F2"],
    ["ae40", "\u74F3\u74F5\u74F8", 6, "\u7500\u7501\u7502\u7503\u7505", 7, "\u750E\u7510\u7512\u7514\u7515\u7516\u7517\u751B\u751D\u751E\u7520", 4, "\u7526\u7527\u752A\u752E\u7534\u7536\u7539\u753C\u753D\u753F\u7541\u7542\u7543\u7544\u7546\u7547\u7549\u754A\u754D\u7550\u7551\u7552\u7553\u7555\u7556\u7557\u7558"],
    ["ae80", "\u755D", 7, "\u7567\u7568\u7569\u756B", 6, "\u7573\u7575\u7576\u7577\u757A", 4, "\u7580\u7581\u7582\u7584\u7585\u7587"],
    ["af40", "\u7588\u7589\u758A\u758C\u758D\u758E\u7590\u7593\u7595\u7598\u759B\u759C\u759E\u75A2\u75A6", 4, "\u75AD\u75B6\u75B7\u75BA\u75BB\u75BF\u75C0\u75C1\u75C6\u75CB\u75CC\u75CE\u75CF\u75D0\u75D1\u75D3\u75D7\u75D9\u75DA\u75DC\u75DD\u75DF\u75E0\u75E1\u75E5\u75E9\u75EC\u75ED\u75EE\u75EF\u75F2\u75F3\u75F5\u75F6\u75F7\u75F8\u75FA\u75FB\u75FD\u75FE\u7602\u7604\u7606\u7607"],
    ["af80", "\u7608\u7609\u760B\u760D\u760E\u760F\u7611\u7612\u7613\u7614\u7616\u761A\u761C\u761D\u761E\u7621\u7623\u7627\u7628\u762C\u762E\u762F\u7631\u7632\u7636\u7637\u7639\u763A\u763B\u763D\u7641\u7642\u7644"],
    ["b040", "\u7645", 6, "\u764E", 5, "\u7655\u7657", 4, "\u765D\u765F\u7660\u7661\u7662\u7664", 6, "\u766C\u766D\u766E\u7670", 7, "\u7679\u767A\u767C\u767F\u7680\u7681\u7683\u7685\u7689\u768A\u768C\u768D\u768F\u7690\u7692\u7694\u7695\u7697\u7698\u769A\u769B"],
    ["b080", "\u769C", 7, "\u76A5", 8, "\u76AF\u76B0\u76B3\u76B5", 9, "\u76C0\u76C1\u76C3\u554A\u963F\u57C3\u6328\u54CE\u5509\u54C0\u7691\u764C\u853C\u77EE\u827E\u788D\u7231\u9698\u978D\u6C28\u5B89\u4FFA\u6309\u6697\u5CB8\u80FA\u6848\u80AE\u6602\u76CE\u51F9\u6556\u71AC\u7FF1\u8884\u50B2\u5965\u61CA\u6FB3\u82AD\u634C\u6252\u53ED\u5427\u7B06\u516B\u75A4\u5DF4\u62D4\u8DCB\u9776\u628A\u8019\u575D\u9738\u7F62\u7238\u767D\u67CF\u767E\u6446\u4F70\u8D25\u62DC\u7A17\u6591\u73ED\u642C\u6273\u822C\u9881\u677F\u7248\u626E\u62CC\u4F34\u74E3\u534A\u529E\u7ECA\u90A6\u5E2E\u6886\u699C\u8180\u7ED1\u68D2\u78C5\u868C\u9551\u508D\u8C24\u82DE\u80DE\u5305\u8912\u5265"],
    ["b140", "\u76C4\u76C7\u76C9\u76CB\u76CC\u76D3\u76D5\u76D9\u76DA\u76DC\u76DD\u76DE\u76E0", 4, "\u76E6", 7, "\u76F0\u76F3\u76F5\u76F6\u76F7\u76FA\u76FB\u76FD\u76FF\u7700\u7702\u7703\u7705\u7706\u770A\u770C\u770E", 10, "\u771B\u771C\u771D\u771E\u7721\u7723\u7724\u7725\u7727\u772A\u772B"],
    ["b180", "\u772C\u772E\u7730", 4, "\u7739\u773B\u773D\u773E\u773F\u7742\u7744\u7745\u7746\u7748", 7, "\u7752", 7, "\u775C\u8584\u96F9\u4FDD\u5821\u9971\u5B9D\u62B1\u62A5\u66B4\u8C79\u9C8D\u7206\u676F\u7891\u60B2\u5351\u5317\u8F88\u80CC\u8D1D\u94A1\u500D\u72C8\u5907\u60EB\u7119\u88AB\u5954\u82EF\u672C\u7B28\u5D29\u7EF7\u752D\u6CF5\u8E66\u8FF8\u903C\u9F3B\u6BD4\u9119\u7B14\u5F7C\u78A7\u84D6\u853D\u6BD5\u6BD9\u6BD6\u5E01\u5E87\u75F9\u95ED\u655D\u5F0A\u5FC5\u8F9F\u58C1\u81C2\u907F\u965B\u97AD\u8FB9\u7F16\u8D2C\u6241\u4FBF\u53D8\u535E\u8FA8\u8FA9\u8FAB\u904D\u6807\u5F6A\u8198\u8868\u9CD6\u618B\u522B\u762A\u5F6C\u658C\u6FD2\u6EE8\u5BBE\u6448\u5175\u51B0\u67C4\u4E19\u79C9\u997C\u70B3"],
    ["b240", "\u775D\u775E\u775F\u7760\u7764\u7767\u7769\u776A\u776D", 11, "\u777A\u777B\u777C\u7781\u7782\u7783\u7786", 5, "\u778F\u7790\u7793", 11, "\u77A1\u77A3\u77A4\u77A6\u77A8\u77AB\u77AD\u77AE\u77AF\u77B1\u77B2\u77B4\u77B6", 4],
    ["b280", "\u77BC\u77BE\u77C0", 12, "\u77CE", 8, "\u77D8\u77D9\u77DA\u77DD", 4, "\u77E4\u75C5\u5E76\u73BB\u83E0\u64AD\u62E8\u94B5\u6CE2\u535A\u52C3\u640F\u94C2\u7B94\u4F2F\u5E1B\u8236\u8116\u818A\u6E24\u6CCA\u9A73\u6355\u535C\u54FA\u8865\u57E0\u4E0D\u5E03\u6B65\u7C3F\u90E8\u6016\u64E6\u731C\u88C1\u6750\u624D\u8D22\u776C\u8E29\u91C7\u5F69\u83DC\u8521\u9910\u53C2\u8695\u6B8B\u60ED\u60E8\u707F\u82CD\u8231\u4ED3\u6CA7\u85CF\u64CD\u7CD9\u69FD\u66F9\u8349\u5395\u7B56\u4FA7\u518C\u6D4B\u5C42\u8E6D\u63D2\u53C9\u832C\u8336\u67E5\u78B4\u643D\u5BDF\u5C94\u5DEE\u8BE7\u62C6\u67F4\u8C7A\u6400\u63BA\u8749\u998B\u8C17\u7F20\u94F2\u4EA7\u9610\u98A4\u660C\u7316"],
    ["b340", "\u77E6\u77E8\u77EA\u77EF\u77F0\u77F1\u77F2\u77F4\u77F5\u77F7\u77F9\u77FA\u77FB\u77FC\u7803", 5, "\u780A\u780B\u780E\u780F\u7810\u7813\u7815\u7819\u781B\u781E\u7820\u7821\u7822\u7824\u7828\u782A\u782B\u782E\u782F\u7831\u7832\u7833\u7835\u7836\u783D\u783F\u7841\u7842\u7843\u7844\u7846\u7848\u7849\u784A\u784B\u784D\u784F\u7851\u7853\u7854\u7858\u7859\u785A"],
    ["b380", "\u785B\u785C\u785E", 11, "\u786F", 7, "\u7878\u7879\u787A\u787B\u787D", 6, "\u573A\u5C1D\u5E38\u957F\u507F\u80A0\u5382\u655E\u7545\u5531\u5021\u8D85\u6284\u949E\u671D\u5632\u6F6E\u5DE2\u5435\u7092\u8F66\u626F\u64A4\u63A3\u5F7B\u6F88\u90F4\u81E3\u8FB0\u5C18\u6668\u5FF1\u6C89\u9648\u8D81\u886C\u6491\u79F0\u57CE\u6A59\u6210\u5448\u4E58\u7A0B\u60E9\u6F84\u8BDA\u627F\u901E\u9A8B\u79E4\u5403\u75F4\u6301\u5319\u6C60\u8FDF\u5F1B\u9A70\u803B\u9F7F\u4F88\u5C3A\u8D64\u7FC5\u65A5\u70BD\u5145\u51B2\u866B\u5D07\u5BA0\u62BD\u916C\u7574\u8E0C\u7A20\u6101\u7B79\u4EC7\u7EF8\u7785\u4E11\u81ED\u521D\u51FA\u6A71\u53A8\u8E87\u9504\u96CF\u6EC1\u9664\u695A"],
    ["b440", "\u7884\u7885\u7886\u7888\u788A\u788B\u788F\u7890\u7892\u7894\u7895\u7896\u7899\u789D\u789E\u78A0\u78A2\u78A4\u78A6\u78A8", 7, "\u78B5\u78B6\u78B7\u78B8\u78BA\u78BB\u78BC\u78BD\u78BF\u78C0\u78C2\u78C3\u78C4\u78C6\u78C7\u78C8\u78CC\u78CD\u78CE\u78CF\u78D1\u78D2\u78D3\u78D6\u78D7\u78D8\u78DA", 9],
    ["b480", "\u78E4\u78E5\u78E6\u78E7\u78E9\u78EA\u78EB\u78ED", 4, "\u78F3\u78F5\u78F6\u78F8\u78F9\u78FB", 5, "\u7902\u7903\u7904\u7906", 6, "\u7840\u50A8\u77D7\u6410\u89E6\u5904\u63E3\u5DDD\u7A7F\u693D\u4F20\u8239\u5598\u4E32\u75AE\u7A97\u5E62\u5E8A\u95EF\u521B\u5439\u708A\u6376\u9524\u5782\u6625\u693F\u9187\u5507\u6DF3\u7EAF\u8822\u6233\u7EF0\u75B5\u8328\u78C1\u96CC\u8F9E\u6148\u74F7\u8BCD\u6B64\u523A\u8D50\u6B21\u806A\u8471\u56F1\u5306\u4ECE\u4E1B\u51D1\u7C97\u918B\u7C07\u4FC3\u8E7F\u7BE1\u7A9C\u6467\u5D14\u50AC\u8106\u7601\u7CB9\u6DEC\u7FE0\u6751\u5B58\u5BF8\u78CB\u64AE\u6413\u63AA\u632B\u9519\u642D\u8FBE\u7B54\u7629\u6253\u5927\u5446\u6B79\u50A3\u6234\u5E26\u6B86\u4EE3\u8D37\u888B\u5F85\u902E"],
    ["b540", "\u790D", 5, "\u7914", 9, "\u791F", 4, "\u7925", 14, "\u7935", 4, "\u793D\u793F\u7942\u7943\u7944\u7945\u7947\u794A", 8, "\u7954\u7955\u7958\u7959\u7961\u7963"],
    ["b580", "\u7964\u7966\u7969\u796A\u796B\u796C\u796E\u7970", 6, "\u7979\u797B", 4, "\u7982\u7983\u7986\u7987\u7988\u7989\u798B\u798C\u798D\u798E\u7990\u7991\u7992\u6020\u803D\u62C5\u4E39\u5355\u90F8\u63B8\u80C6\u65E6\u6C2E\u4F46\u60EE\u6DE1\u8BDE\u5F39\u86CB\u5F53\u6321\u515A\u8361\u6863\u5200\u6363\u8E48\u5012\u5C9B\u7977\u5BFC\u5230\u7A3B\u60BC\u9053\u76D7\u5FB7\u5F97\u7684\u8E6C\u706F\u767B\u7B49\u77AA\u51F3\u9093\u5824\u4F4E\u6EF4\u8FEA\u654C\u7B1B\u72C4\u6DA4\u7FDF\u5AE1\u62B5\u5E95\u5730\u8482\u7B2C\u5E1D\u5F1F\u9012\u7F14\u98A0\u6382\u6EC7\u7898\u70B9\u5178\u975B\u57AB\u7535\u4F43\u7538\u5E97\u60E6\u5960\u6DC0\u6BBF\u7889\u53FC\u96D5\u51CB\u5201\u6389\u540A\u9493\u8C03\u8DCC\u7239\u789F\u8776\u8FED\u8C0D\u53E0"],
    ["b640", "\u7993", 6, "\u799B", 11, "\u79A8", 10, "\u79B4", 4, "\u79BC\u79BF\u79C2\u79C4\u79C5\u79C7\u79C8\u79CA\u79CC\u79CE\u79CF\u79D0\u79D3\u79D4\u79D6\u79D7\u79D9", 5, "\u79E0\u79E1\u79E2\u79E5\u79E8\u79EA"],
    ["b680", "\u79EC\u79EE\u79F1", 6, "\u79F9\u79FA\u79FC\u79FE\u79FF\u7A01\u7A04\u7A05\u7A07\u7A08\u7A09\u7A0A\u7A0C\u7A0F", 4, "\u7A15\u7A16\u7A18\u7A19\u7A1B\u7A1C\u4E01\u76EF\u53EE\u9489\u9876\u9F0E\u952D\u5B9A\u8BA2\u4E22\u4E1C\u51AC\u8463\u61C2\u52A8\u680B\u4F97\u606B\u51BB\u6D1E\u515C\u6296\u6597\u9661\u8C46\u9017\u75D8\u90FD\u7763\u6BD2\u728A\u72EC\u8BFB\u5835\u7779\u8D4C\u675C\u9540\u809A\u5EA6\u6E21\u5992\u7AEF\u77ED\u953B\u6BB5\u65AD\u7F0E\u5806\u5151\u961F\u5BF9\u58A9\u5428\u8E72\u6566\u987F\u56E4\u949D\u76FE\u9041\u6387\u54C6\u591A\u593A\u579B\u8EB2\u6735\u8DFA\u8235\u5241\u60F0\u5815\u86FE\u5CE8\u9E45\u4FC4\u989D\u8BB9\u5A25\u6076\u5384\u627C\u904F\u9102\u997F\u6069\u800C\u513F\u8033\u5C14\u9975\u6D31\u4E8C"],
    ["b740", "\u7A1D\u7A1F\u7A21\u7A22\u7A24", 14, "\u7A34\u7A35\u7A36\u7A38\u7A3A\u7A3E\u7A40", 5, "\u7A47", 9, "\u7A52", 4, "\u7A58", 16],
    ["b780", "\u7A69", 6, "\u7A71\u7A72\u7A73\u7A75\u7A7B\u7A7C\u7A7D\u7A7E\u7A82\u7A85\u7A87\u7A89\u7A8A\u7A8B\u7A8C\u7A8E\u7A8F\u7A90\u7A93\u7A94\u7A99\u7A9A\u7A9B\u7A9E\u7AA1\u7AA2\u8D30\u53D1\u7F5A\u7B4F\u4F10\u4E4F\u9600\u6CD5\u73D0\u85E9\u5E06\u756A\u7FFB\u6A0A\u77FE\u9492\u7E41\u51E1\u70E6\u53CD\u8FD4\u8303\u8D29\u72AF\u996D\u6CDB\u574A\u82B3\u65B9\u80AA\u623F\u9632\u59A8\u4EFF\u8BBF\u7EBA\u653E\u83F2\u975E\u5561\u98DE\u80A5\u532A\u8BFD\u5420\u80BA\u5E9F\u6CB8\u8D39\u82AC\u915A\u5429\u6C1B\u5206\u7EB7\u575F\u711A\u6C7E\u7C89\u594B\u4EFD\u5FFF\u6124\u7CAA\u4E30\u5C01\u67AB\u8702\u5CF0\u950B\u98CE\u75AF\u70FD\u9022\u51AF\u7F1D\u8BBD\u5949\u51E4\u4F5B\u5426\u592B\u6577\u80A4\u5B75\u6276\u62C2\u8F90\u5E45\u6C1F\u7B26\u4F0F\u4FD8\u670D"],
    ["b840", "\u7AA3\u7AA4\u7AA7\u7AA9\u7AAA\u7AAB\u7AAE", 4, "\u7AB4", 10, "\u7AC0", 10, "\u7ACC", 9, "\u7AD7\u7AD8\u7ADA\u7ADB\u7ADC\u7ADD\u7AE1\u7AE2\u7AE4\u7AE7", 5, "\u7AEE\u7AF0\u7AF1\u7AF2\u7AF3"],
    ["b880", "\u7AF4", 4, "\u7AFB\u7AFC\u7AFE\u7B00\u7B01\u7B02\u7B05\u7B07\u7B09\u7B0C\u7B0D\u7B0E\u7B10\u7B12\u7B13\u7B16\u7B17\u7B18\u7B1A\u7B1C\u7B1D\u7B1F\u7B21\u7B22\u7B23\u7B27\u7B29\u7B2D\u6D6E\u6DAA\u798F\u88B1\u5F17\u752B\u629A\u8F85\u4FEF\u91DC\u65A7\u812F\u8151\u5E9C\u8150\u8D74\u526F\u8986\u8D4B\u590D\u5085\u4ED8\u961C\u7236\u8179\u8D1F\u5BCC\u8BA3\u9644\u5987\u7F1A\u5490\u5676\u560E\u8BE5\u6539\u6982\u9499\u76D6\u6E89\u5E72\u7518\u6746\u67D1\u7AFF\u809D\u8D76\u611F\u79C6\u6562\u8D63\u5188\u521A\u94A2\u7F38\u809B\u7EB2\u5C97\u6E2F\u6760\u7BD9\u768B\u9AD8\u818F\u7F94\u7CD5\u641E\u9550\u7A3F\u544A\u54E5\u6B4C\u6401\u6208\u9E3D\u80F3\u7599\u5272\u9769\u845B\u683C\u86E4\u9601\u9694\u94EC\u4E2A\u5404\u7ED9\u6839\u8DDF\u8015\u66F4\u5E9A\u7FB9"],
    ["b940", "\u7B2F\u7B30\u7B32\u7B34\u7B35\u7B36\u7B37\u7B39\u7B3B\u7B3D\u7B3F", 5, "\u7B46\u7B48\u7B4A\u7B4D\u7B4E\u7B53\u7B55\u7B57\u7B59\u7B5C\u7B5E\u7B5F\u7B61\u7B63", 10, "\u7B6F\u7B70\u7B73\u7B74\u7B76\u7B78\u7B7A\u7B7C\u7B7D\u7B7F\u7B81\u7B82\u7B83\u7B84\u7B86", 6, "\u7B8E\u7B8F"],
    ["b980", "\u7B91\u7B92\u7B93\u7B96\u7B98\u7B99\u7B9A\u7B9B\u7B9E\u7B9F\u7BA0\u7BA3\u7BA4\u7BA5\u7BAE\u7BAF\u7BB0\u7BB2\u7BB3\u7BB5\u7BB6\u7BB7\u7BB9", 7, "\u7BC2\u7BC3\u7BC4\u57C2\u803F\u6897\u5DE5\u653B\u529F\u606D\u9F9A\u4F9B\u8EAC\u516C\u5BAB\u5F13\u5DE9\u6C5E\u62F1\u8D21\u5171\u94A9\u52FE\u6C9F\u82DF\u72D7\u57A2\u6784\u8D2D\u591F\u8F9C\u83C7\u5495\u7B8D\u4F30\u6CBD\u5B64\u59D1\u9F13\u53E4\u86CA\u9AA8\u8C37\u80A1\u6545\u987E\u56FA\u96C7\u522E\u74DC\u5250\u5BE1\u6302\u8902\u4E56\u62D0\u602A\u68FA\u5173\u5B98\u51A0\u89C2\u7BA1\u9986\u7F50\u60EF\u704C\u8D2F\u5149\u5E7F\u901B\u7470\u89C4\u572D\u7845\u5F52\u9F9F\u95FA\u8F68\u9B3C\u8BE1\u7678\u6842\u67DC\u8DEA\u8D35\u523D\u8F8A\u6EDA\u68CD\u9505\u90ED\u56FD\u679C\u88F9\u8FC7\u54C8"],
    ["ba40", "\u7BC5\u7BC8\u7BC9\u7BCA\u7BCB\u7BCD\u7BCE\u7BCF\u7BD0\u7BD2\u7BD4", 4, "\u7BDB\u7BDC\u7BDE\u7BDF\u7BE0\u7BE2\u7BE3\u7BE4\u7BE7\u7BE8\u7BE9\u7BEB\u7BEC\u7BED\u7BEF\u7BF0\u7BF2", 4, "\u7BF8\u7BF9\u7BFA\u7BFB\u7BFD\u7BFF", 7, "\u7C08\u7C09\u7C0A\u7C0D\u7C0E\u7C10", 5, "\u7C17\u7C18\u7C19"],
    ["ba80", "\u7C1A", 4, "\u7C20", 5, "\u7C28\u7C29\u7C2B", 12, "\u7C39", 5, "\u7C42\u9AB8\u5B69\u6D77\u6C26\u4EA5\u5BB3\u9A87\u9163\u61A8\u90AF\u97E9\u542B\u6DB5\u5BD2\u51FD\u558A\u7F55\u7FF0\u64BC\u634D\u65F1\u61BE\u608D\u710A\u6C57\u6C49\u592F\u676D\u822A\u58D5\u568E\u8C6A\u6BEB\u90DD\u597D\u8017\u53F7\u6D69\u5475\u559D\u8377\u83CF\u6838\u79BE\u548C\u4F55\u5408\u76D2\u8C89\u9602\u6CB3\u6DB8\u8D6B\u8910\u9E64\u8D3A\u563F\u9ED1\u75D5\u5F88\u72E0\u6068\u54FC\u4EA8\u6A2A\u8861\u6052\u8F70\u54C4\u70D8\u8679\u9E3F\u6D2A\u5B8F\u5F18\u7EA2\u5589\u4FAF\u7334\u543C\u539A\u5019\u540E\u547C\u4E4E\u5FFD\u745A\u58F6\u846B\u80E1\u8774\u72D0\u7CCA\u6E56"],
    ["bb40", "\u7C43", 9, "\u7C4E", 36, "\u7C75", 5, "\u7C7E", 9],
    ["bb80", "\u7C88\u7C8A", 6, "\u7C93\u7C94\u7C96\u7C99\u7C9A\u7C9B\u7CA0\u7CA1\u7CA3\u7CA6\u7CA7\u7CA8\u7CA9\u7CAB\u7CAC\u7CAD\u7CAF\u7CB0\u7CB4", 4, "\u7CBA\u7CBB\u5F27\u864E\u552C\u62A4\u4E92\u6CAA\u6237\u82B1\u54D7\u534E\u733E\u6ED1\u753B\u5212\u5316\u8BDD\u69D0\u5F8A\u6000\u6DEE\u574F\u6B22\u73AF\u6853\u8FD8\u7F13\u6362\u60A3\u5524\u75EA\u8C62\u7115\u6DA3\u5BA6\u5E7B\u8352\u614C\u9EC4\u78FA\u8757\u7C27\u7687\u51F0\u60F6\u714C\u6643\u5E4C\u604D\u8C0E\u7070\u6325\u8F89\u5FBD\u6062\u86D4\u56DE\u6BC1\u6094\u6167\u5349\u60E0\u6666\u8D3F\u79FD\u4F1A\u70E9\u6C47\u8BB3\u8BF2\u7ED8\u8364\u660F\u5A5A\u9B42\u6D51\u6DF7\u8C41\u6D3B\u4F19\u706B\u83B7\u6216\u60D1\u970D\u8D27\u7978\u51FB\u573E\u57FA\u673A\u7578\u7A3D\u79EF\u7B95"],
    ["bc40", "\u7CBF\u7CC0\u7CC2\u7CC3\u7CC4\u7CC6\u7CC9\u7CCB\u7CCE", 6, "\u7CD8\u7CDA\u7CDB\u7CDD\u7CDE\u7CE1", 6, "\u7CE9", 5, "\u7CF0", 7, "\u7CF9\u7CFA\u7CFC", 13, "\u7D0B", 5],
    ["bc80", "\u7D11", 14, "\u7D21\u7D23\u7D24\u7D25\u7D26\u7D28\u7D29\u7D2A\u7D2C\u7D2D\u7D2E\u7D30", 6, "\u808C\u9965\u8FF9\u6FC0\u8BA5\u9E21\u59EC\u7EE9\u7F09\u5409\u6781\u68D8\u8F91\u7C4D\u96C6\u53CA\u6025\u75BE\u6C72\u5373\u5AC9\u7EA7\u6324\u51E0\u810A\u5DF1\u84DF\u6280\u5180\u5B63\u4F0E\u796D\u5242\u60B8\u6D4E\u5BC4\u5BC2\u8BA1\u8BB0\u65E2\u5FCC\u9645\u5993\u7EE7\u7EAA\u5609\u67B7\u5939\u4F73\u5BB6\u52A0\u835A\u988A\u8D3E\u7532\u94BE\u5047\u7A3C\u4EF7\u67B6\u9A7E\u5AC1\u6B7C\u76D1\u575A\u5C16\u7B3A\u95F4\u714E\u517C\u80A9\u8270\u5978\u7F04\u8327\u68C0\u67EC\u78B1\u7877\u62E3\u6361\u7B80\u4FED\u526A\u51CF\u8350\u69DB\u9274\u8DF5\u8D31\u89C1\u952E\u7BAD\u4EF6"],
    ["bd40", "\u7D37", 54, "\u7D6F", 7],
    ["bd80", "\u7D78", 32, "\u5065\u8230\u5251\u996F\u6E10\u6E85\u6DA7\u5EFA\u50F5\u59DC\u5C06\u6D46\u6C5F\u7586\u848B\u6868\u5956\u8BB2\u5320\u9171\u964D\u8549\u6912\u7901\u7126\u80F6\u4EA4\u90CA\u6D47\u9A84\u5A07\u56BC\u6405\u94F0\u77EB\u4FA5\u811A\u72E1\u89D2\u997A\u7F34\u7EDE\u527F\u6559\u9175\u8F7F\u8F83\u53EB\u7A96\u63ED\u63A5\u7686\u79F8\u8857\u9636\u622A\u52AB\u8282\u6854\u6770\u6377\u776B\u7AED\u6D01\u7ED3\u89E3\u59D0\u6212\u85C9\u82A5\u754C\u501F\u4ECB\u75A5\u8BEB\u5C4A\u5DFE\u7B4B\u65A4\u91D1\u4ECA\u6D25\u895F\u7D27\u9526\u4EC5\u8C28\u8FDB\u9773\u664B\u7981\u8FD1\u70EC\u6D78"],
    ["be40", "\u7D99", 12, "\u7DA7", 6, "\u7DAF", 42],
    ["be80", "\u7DDA", 32, "\u5C3D\u52B2\u8346\u5162\u830E\u775B\u6676\u9CB8\u4EAC\u60CA\u7CBE\u7CB3\u7ECF\u4E95\u8B66\u666F\u9888\u9759\u5883\u656C\u955C\u5F84\u75C9\u9756\u7ADF\u7ADE\u51C0\u70AF\u7A98\u63EA\u7A76\u7EA0\u7396\u97ED\u4E45\u7078\u4E5D\u9152\u53A9\u6551\u65E7\u81FC\u8205\u548E\u5C31\u759A\u97A0\u62D8\u72D9\u75BD\u5C45\u9A79\u83CA\u5C40\u5480\u77E9\u4E3E\u6CAE\u805A\u62D2\u636E\u5DE8\u5177\u8DDD\u8E1E\u952F\u4FF1\u53E5\u60E7\u70AC\u5267\u6350\u9E43\u5A1F\u5026\u7737\u5377\u7EE2\u6485\u652B\u6289\u6398\u5014\u7235\u89C9\u51B3\u8BC0\u7EDD\u5747\u83CC\u94A7\u519B\u541B\u5CFB"],
    ["bf40", "\u7DFB", 62],
    ["bf80", "\u7E3A\u7E3C", 4, "\u7E42", 4, "\u7E48", 21, "\u4FCA\u7AE3\u6D5A\u90E1\u9A8F\u5580\u5496\u5361\u54AF\u5F00\u63E9\u6977\u51EF\u6168\u520A\u582A\u52D8\u574E\u780D\u770B\u5EB7\u6177\u7CE0\u625B\u6297\u4EA2\u7095\u8003\u62F7\u70E4\u9760\u5777\u82DB\u67EF\u68F5\u78D5\u9897\u79D1\u58F3\u54B3\u53EF\u6E34\u514B\u523B\u5BA2\u8BFE\u80AF\u5543\u57A6\u6073\u5751\u542D\u7A7A\u6050\u5B54\u63A7\u62A0\u53E3\u6263\u5BC7\u67AF\u54ED\u7A9F\u82E6\u9177\u5E93\u88E4\u5938\u57AE\u630E\u8DE8\u80EF\u5757\u7B77\u4FA9\u5FEB\u5BBD\u6B3E\u5321\u7B50\u72C2\u6846\u77FF\u7736\u65F7\u51B5\u4E8F\u76D4\u5CBF\u7AA5\u8475\u594E\u9B41\u5080"],
    ["c040", "\u7E5E", 35, "\u7E83", 23, "\u7E9C\u7E9D\u7E9E"],
    ["c080", "\u7EAE\u7EB4\u7EBB\u7EBC\u7ED6\u7EE4\u7EEC\u7EF9\u7F0A\u7F10\u7F1E\u7F37\u7F39\u7F3B", 6, "\u7F43\u7F46", 9, "\u7F52\u7F53\u9988\u6127\u6E83\u5764\u6606\u6346\u56F0\u62EC\u6269\u5ED3\u9614\u5783\u62C9\u5587\u8721\u814A\u8FA3\u5566\u83B1\u6765\u8D56\u84DD\u5A6A\u680F\u62E6\u7BEE\u9611\u5170\u6F9C\u8C30\u63FD\u89C8\u61D2\u7F06\u70C2\u6EE5\u7405\u6994\u72FC\u5ECA\u90CE\u6717\u6D6A\u635E\u52B3\u7262\u8001\u4F6C\u59E5\u916A\u70D9\u6D9D\u52D2\u4E50\u96F7\u956D\u857E\u78CA\u7D2F\u5121\u5792\u64C2\u808B\u7C7B\u6CEA\u68F1\u695E\u51B7\u5398\u68A8\u7281\u9ECE\u7BF1\u72F8\u79BB\u6F13\u7406\u674E\u91CC\u9CA4\u793C\u8389\u8354\u540F\u6817\u4E3D\u5389\u52B1\u783E\u5386\u5229\u5088\u4F8B\u4FD0"],
    ["c140", "\u7F56\u7F59\u7F5B\u7F5C\u7F5D\u7F5E\u7F60\u7F63", 4, "\u7F6B\u7F6C\u7F6D\u7F6F\u7F70\u7F73\u7F75\u7F76\u7F77\u7F78\u7F7A\u7F7B\u7F7C\u7F7D\u7F7F\u7F80\u7F82", 7, "\u7F8B\u7F8D\u7F8F", 4, "\u7F95", 4, "\u7F9B\u7F9C\u7FA0\u7FA2\u7FA3\u7FA5\u7FA6\u7FA8", 6, "\u7FB1"],
    ["c180", "\u7FB3", 4, "\u7FBA\u7FBB\u7FBE\u7FC0\u7FC2\u7FC3\u7FC4\u7FC6\u7FC7\u7FC8\u7FC9\u7FCB\u7FCD\u7FCF", 4, "\u7FD6\u7FD7\u7FD9", 5, "\u7FE2\u7FE3\u75E2\u7ACB\u7C92\u6CA5\u96B6\u529B\u7483\u54E9\u4FE9\u8054\u83B2\u8FDE\u9570\u5EC9\u601C\u6D9F\u5E18\u655B\u8138\u94FE\u604B\u70BC\u7EC3\u7CAE\u51C9\u6881\u7CB1\u826F\u4E24\u8F86\u91CF\u667E\u4EAE\u8C05\u64A9\u804A\u50DA\u7597\u71CE\u5BE5\u8FBD\u6F66\u4E86\u6482\u9563\u5ED6\u6599\u5217\u88C2\u70C8\u52A3\u730E\u7433\u6797\u78F7\u9716\u4E34\u90BB\u9CDE\u6DCB\u51DB\u8D41\u541D\u62CE\u73B2\u83F1\u96F6\u9F84\u94C3\u4F36\u7F9A\u51CC\u7075\u9675\u5CAD\u9886\u53E6\u4EE4\u6E9C\u7409\u69B4\u786B\u998F\u7559\u5218\u7624\u6D41\u67F3\u516D\u9F99\u804B\u5499\u7B3C\u7ABF"],
    ["c240", "\u7FE4\u7FE7\u7FE8\u7FEA\u7FEB\u7FEC\u7FED\u7FEF\u7FF2\u7FF4", 6, "\u7FFD\u7FFE\u7FFF\u8002\u8007\u8008\u8009\u800A\u800E\u800F\u8011\u8013\u801A\u801B\u801D\u801E\u801F\u8021\u8023\u8024\u802B", 5, "\u8032\u8034\u8039\u803A\u803C\u803E\u8040\u8041\u8044\u8045\u8047\u8048\u8049\u804E\u804F\u8050\u8051\u8053\u8055\u8056\u8057"],
    ["c280", "\u8059\u805B", 13, "\u806B", 5, "\u8072", 11, "\u9686\u5784\u62E2\u9647\u697C\u5A04\u6402\u7BD3\u6F0F\u964B\u82A6\u5362\u9885\u5E90\u7089\u63B3\u5364\u864F\u9C81\u9E93\u788C\u9732\u8DEF\u8D42\u9E7F\u6F5E\u7984\u5F55\u9646\u622E\u9A74\u5415\u94DD\u4FA3\u65C5\u5C65\u5C61\u7F15\u8651\u6C2F\u5F8B\u7387\u6EE4\u7EFF\u5CE6\u631B\u5B6A\u6EE6\u5375\u4E71\u63A0\u7565\u62A1\u8F6E\u4F26\u4ED1\u6CA6\u7EB6\u8BBA\u841D\u87BA\u7F57\u903B\u9523\u7BA9\u9AA1\u88F8\u843D\u6D1B\u9A86\u7EDC\u5988\u9EBB\u739B\u7801\u8682\u9A6C\u9A82\u561B\u5417\u57CB\u4E70\u9EA6\u5356\u8FC8\u8109\u7792\u9992\u86EE\u6EE1\u8513\u66FC\u6162\u6F2B"],
    ["c340", "\u807E\u8081\u8082\u8085\u8088\u808A\u808D", 5, "\u8094\u8095\u8097\u8099\u809E\u80A3\u80A6\u80A7\u80A8\u80AC\u80B0\u80B3\u80B5\u80B6\u80B8\u80B9\u80BB\u80C5\u80C7", 4, "\u80CF", 6, "\u80D8\u80DF\u80E0\u80E2\u80E3\u80E6\u80EE\u80F5\u80F7\u80F9\u80FB\u80FE\u80FF\u8100\u8101\u8103\u8104\u8105\u8107\u8108\u810B"],
    ["c380", "\u810C\u8115\u8117\u8119\u811B\u811C\u811D\u811F", 12, "\u812D\u812E\u8130\u8133\u8134\u8135\u8137\u8139", 4, "\u813F\u8C29\u8292\u832B\u76F2\u6C13\u5FD9\u83BD\u732B\u8305\u951A\u6BDB\u77DB\u94C6\u536F\u8302\u5192\u5E3D\u8C8C\u8D38\u4E48\u73AB\u679A\u6885\u9176\u9709\u7164\u6CA1\u7709\u5A92\u9541\u6BCF\u7F8E\u6627\u5BD0\u59B9\u5A9A\u95E8\u95F7\u4EEC\u840C\u8499\u6AAC\u76DF\u9530\u731B\u68A6\u5B5F\u772F\u919A\u9761\u7CDC\u8FF7\u8C1C\u5F25\u7C73\u79D8\u89C5\u6CCC\u871C\u5BC6\u5E42\u68C9\u7720\u7EF5\u5195\u514D\u52C9\u5A29\u7F05\u9762\u82D7\u63CF\u7784\u85D0\u79D2\u6E3A\u5E99\u5999\u8511\u706D\u6C11\u62BF\u76BF\u654F\u60AF\u95FD\u660E\u879F\u9E23\u94ED\u540D\u547D\u8C2C\u6478"],
    ["c440", "\u8140", 5, "\u8147\u8149\u814D\u814E\u814F\u8152\u8156\u8157\u8158\u815B", 4, "\u8161\u8162\u8163\u8164\u8166\u8168\u816A\u816B\u816C\u816F\u8172\u8173\u8175\u8176\u8177\u8178\u8181\u8183", 4, "\u8189\u818B\u818C\u818D\u818E\u8190\u8192", 5, "\u8199\u819A\u819E", 4, "\u81A4\u81A5"],
    ["c480", "\u81A7\u81A9\u81AB", 7, "\u81B4", 5, "\u81BC\u81BD\u81BE\u81BF\u81C4\u81C5\u81C7\u81C8\u81C9\u81CB\u81CD", 6, "\u6479\u8611\u6A21\u819C\u78E8\u6469\u9B54\u62B9\u672B\u83AB\u58A8\u9ED8\u6CAB\u6F20\u5BDE\u964C\u8C0B\u725F\u67D0\u62C7\u7261\u4EA9\u59C6\u6BCD\u5893\u66AE\u5E55\u52DF\u6155\u6728\u76EE\u7766\u7267\u7A46\u62FF\u54EA\u5450\u94A0\u90A3\u5A1C\u7EB3\u6C16\u4E43\u5976\u8010\u5948\u5357\u7537\u96BE\u56CA\u6320\u8111\u607C\u95F9\u6DD6\u5462\u9981\u5185\u5AE9\u80FD\u59AE\u9713\u502A\u6CE5\u5C3C\u62DF\u4F60\u533F\u817B\u9006\u6EBA\u852B\u62C8\u5E74\u78BE\u64B5\u637B\u5FF5\u5A18\u917F\u9E1F\u5C3F\u634F\u8042\u5B7D\u556E\u954A\u954D\u6D85\u60A8\u67E0\u72DE\u51DD\u5B81"],
    ["c540", "\u81D4", 14, "\u81E4\u81E5\u81E6\u81E8\u81E9\u81EB\u81EE", 4, "\u81F5", 5, "\u81FD\u81FF\u8203\u8207", 4, "\u820E\u820F\u8211\u8213\u8215", 5, "\u821D\u8220\u8224\u8225\u8226\u8227\u8229\u822E\u8232\u823A\u823C\u823D\u823F"],
    ["c580", "\u8240\u8241\u8242\u8243\u8245\u8246\u8248\u824A\u824C\u824D\u824E\u8250", 7, "\u8259\u825B\u825C\u825D\u825E\u8260", 7, "\u8269\u62E7\u6CDE\u725B\u626D\u94AE\u7EBD\u8113\u6D53\u519C\u5F04\u5974\u52AA\u6012\u5973\u6696\u8650\u759F\u632A\u61E6\u7CEF\u8BFA\u54E6\u6B27\u9E25\u6BB4\u85D5\u5455\u5076\u6CA4\u556A\u8DB4\u722C\u5E15\u6015\u7436\u62CD\u6392\u724C\u5F98\u6E43\u6D3E\u6500\u6F58\u76D8\u78D0\u76FC\u7554\u5224\u53DB\u4E53\u5E9E\u65C1\u802A\u80D6\u629B\u5486\u5228\u70AE\u888D\u8DD1\u6CE1\u5478\u80DA\u57F9\u88F4\u8D54\u966A\u914D\u4F69\u6C9B\u55B7\u76C6\u7830\u62A8\u70F9\u6F8E\u5F6D\u84EC\u68DA\u787C\u7BF7\u81A8\u670B\u9E4F\u6367\u78B0\u576F\u7812\u9739\u6279\u62AB\u5288\u7435\u6BD7"],
    ["c640", "\u826A\u826B\u826C\u826D\u8271\u8275\u8276\u8277\u8278\u827B\u827C\u8280\u8281\u8283\u8285\u8286\u8287\u8289\u828C\u8290\u8293\u8294\u8295\u8296\u829A\u829B\u829E\u82A0\u82A2\u82A3\u82A7\u82B2\u82B5\u82B6\u82BA\u82BB\u82BC\u82BF\u82C0\u82C2\u82C3\u82C5\u82C6\u82C9\u82D0\u82D6\u82D9\u82DA\u82DD\u82E2\u82E7\u82E8\u82E9\u82EA\u82EC\u82ED\u82EE\u82F0\u82F2\u82F3\u82F5\u82F6\u82F8"],
    ["c680", "\u82FA\u82FC", 4, "\u830A\u830B\u830D\u8310\u8312\u8313\u8316\u8318\u8319\u831D", 9, "\u8329\u832A\u832E\u8330\u8332\u8337\u833B\u833D\u5564\u813E\u75B2\u76AE\u5339\u75DE\u50FB\u5C41\u8B6C\u7BC7\u504F\u7247\u9A97\u98D8\u6F02\u74E2\u7968\u6487\u77A5\u62FC\u9891\u8D2B\u54C1\u8058\u4E52\u576A\u82F9\u840D\u5E73\u51ED\u74F6\u8BC4\u5C4F\u5761\u6CFC\u9887\u5A46\u7834\u9B44\u8FEB\u7C95\u5256\u6251\u94FA\u4EC6\u8386\u8461\u83E9\u84B2\u57D4\u6734\u5703\u666E\u6D66\u8C31\u66DD\u7011\u671F\u6B3A\u6816\u621A\u59BB\u4E03\u51C4\u6F06\u67D2\u6C8F\u5176\u68CB\u5947\u6B67\u7566\u5D0E\u8110\u9F50\u65D7\u7948\u7941\u9A91\u8D77\u5C82\u4E5E\u4F01\u542F\u5951\u780C\u5668\u6C14\u8FC4\u5F03\u6C7D\u6CE3\u8BAB\u6390"],
    ["c740", "\u833E\u833F\u8341\u8342\u8344\u8345\u8348\u834A", 4, "\u8353\u8355", 4, "\u835D\u8362\u8370", 6, "\u8379\u837A\u837E", 6, "\u8387\u8388\u838A\u838B\u838C\u838D\u838F\u8390\u8391\u8394\u8395\u8396\u8397\u8399\u839A\u839D\u839F\u83A1", 6, "\u83AC\u83AD\u83AE"],
    ["c780", "\u83AF\u83B5\u83BB\u83BE\u83BF\u83C2\u83C3\u83C4\u83C6\u83C8\u83C9\u83CB\u83CD\u83CE\u83D0\u83D1\u83D2\u83D3\u83D5\u83D7\u83D9\u83DA\u83DB\u83DE\u83E2\u83E3\u83E4\u83E6\u83E7\u83E8\u83EB\u83EC\u83ED\u6070\u6D3D\u7275\u6266\u948E\u94C5\u5343\u8FC1\u7B7E\u4EDF\u8C26\u4E7E\u9ED4\u94B1\u94B3\u524D\u6F5C\u9063\u6D45\u8C34\u5811\u5D4C\u6B20\u6B49\u67AA\u545B\u8154\u7F8C\u5899\u8537\u5F3A\u62A2\u6A47\u9539\u6572\u6084\u6865\u77A7\u4E54\u4FA8\u5DE7\u9798\u64AC\u7FD8\u5CED\u4FCF\u7A8D\u5207\u8304\u4E14\u602F\u7A83\u94A6\u4FB5\u4EB2\u79E6\u7434\u52E4\u82B9\u64D2\u79BD\u5BDD\u6C81\u9752\u8F7B\u6C22\u503E\u537F\u6E05\u64CE\u6674\u6C30\u60C5\u9877\u8BF7\u5E86\u743C\u7A77\u79CB\u4E18\u90B1\u7403\u6C42\u56DA\u914B\u6CC5\u8D8B\u533A\u86C6\u66F2\u8EAF\u5C48\u9A71\u6E20"],
    ["c840", "\u83EE\u83EF\u83F3", 4, "\u83FA\u83FB\u83FC\u83FE\u83FF\u8400\u8402\u8405\u8407\u8408\u8409\u840A\u8410\u8412", 5, "\u8419\u841A\u841B\u841E", 5, "\u8429", 7, "\u8432", 5, "\u8439\u843A\u843B\u843E", 7, "\u8447\u8448\u8449"],
    ["c880", "\u844A", 6, "\u8452", 4, "\u8458\u845D\u845E\u845F\u8460\u8462\u8464", 4, "\u846A\u846E\u846F\u8470\u8472\u8474\u8477\u8479\u847B\u847C\u53D6\u5A36\u9F8B\u8DA3\u53BB\u5708\u98A7\u6743\u919B\u6CC9\u5168\u75CA\u62F3\u72AC\u5238\u529D\u7F3A\u7094\u7638\u5374\u9E4A\u69B7\u786E\u96C0\u88D9\u7FA4\u7136\u71C3\u5189\u67D3\u74E4\u58E4\u6518\u56B7\u8BA9\u9976\u6270\u7ED5\u60F9\u70ED\u58EC\u4EC1\u4EBA\u5FCD\u97E7\u4EFB\u8BA4\u5203\u598A\u7EAB\u6254\u4ECD\u65E5\u620E\u8338\u84C9\u8363\u878D\u7194\u6EB6\u5BB9\u7ED2\u5197\u63C9\u67D4\u8089\u8339\u8815\u5112\u5B7A\u5982\u8FB1\u4E73\u6C5D\u5165\u8925\u8F6F\u962E\u854A\u745E\u9510\u95F0\u6DA6\u82E5\u5F31\u6492\u6D12\u8428\u816E\u9CC3\u585E\u8D5B\u4E09\u53C1"],
    ["c940", "\u847D", 4, "\u8483\u8484\u8485\u8486\u848A\u848D\u848F", 7, "\u8498\u849A\u849B\u849D\u849E\u849F\u84A0\u84A2", 12, "\u84B0\u84B1\u84B3\u84B5\u84B6\u84B7\u84BB\u84BC\u84BE\u84C0\u84C2\u84C3\u84C5\u84C6\u84C7\u84C8\u84CB\u84CC\u84CE\u84CF\u84D2\u84D4\u84D5\u84D7"],
    ["c980", "\u84D8", 4, "\u84DE\u84E1\u84E2\u84E4\u84E7", 4, "\u84ED\u84EE\u84EF\u84F1", 10, "\u84FD\u84FE\u8500\u8501\u8502\u4F1E\u6563\u6851\u55D3\u4E27\u6414\u9A9A\u626B\u5AC2\u745F\u8272\u6DA9\u68EE\u50E7\u838E\u7802\u6740\u5239\u6C99\u7EB1\u50BB\u5565\u715E\u7B5B\u6652\u73CA\u82EB\u6749\u5C71\u5220\u717D\u886B\u95EA\u9655\u64C5\u8D61\u81B3\u5584\u6C55\u6247\u7F2E\u5892\u4F24\u5546\u8D4F\u664C\u4E0A\u5C1A\u88F3\u68A2\u634E\u7A0D\u70E7\u828D\u52FA\u97F6\u5C11\u54E8\u90B5\u7ECD\u5962\u8D4A\u86C7\u820C\u820D\u8D66\u6444\u5C04\u6151\u6D89\u793E\u8BBE\u7837\u7533\u547B\u4F38\u8EAB\u6DF1\u5A20\u7EC5\u795E\u6C88\u5BA1\u5A76\u751A\u80BE\u614E\u6E17\u58F0\u751F\u7525\u7272\u5347\u7EF3"],
    ["ca40", "\u8503", 8, "\u850D\u850E\u850F\u8510\u8512\u8514\u8515\u8516\u8518\u8519\u851B\u851C\u851D\u851E\u8520\u8522", 8, "\u852D", 9, "\u853E", 4, "\u8544\u8545\u8546\u8547\u854B", 10],
    ["ca80", "\u8557\u8558\u855A\u855B\u855C\u855D\u855F", 4, "\u8565\u8566\u8567\u8569", 8, "\u8573\u8575\u8576\u8577\u8578\u857C\u857D\u857F\u8580\u8581\u7701\u76DB\u5269\u80DC\u5723\u5E08\u5931\u72EE\u65BD\u6E7F\u8BD7\u5C38\u8671\u5341\u77F3\u62FE\u65F6\u4EC0\u98DF\u8680\u5B9E\u8BC6\u53F2\u77E2\u4F7F\u5C4E\u9A76\u59CB\u5F0F\u793A\u58EB\u4E16\u67FF\u4E8B\u62ED\u8A93\u901D\u52BF\u662F\u55DC\u566C\u9002\u4ED5\u4F8D\u91CA\u9970\u6C0F\u5E02\u6043\u5BA4\u89C6\u8BD5\u6536\u624B\u9996\u5B88\u5BFF\u6388\u552E\u53D7\u7626\u517D\u852C\u67A2\u68B3\u6B8A\u6292\u8F93\u53D4\u8212\u6DD1\u758F\u4E66\u8D4E\u5B70\u719F\u85AF\u6691\u66D9\u7F72\u8700\u9ECD\u9F20\u5C5E\u672F\u8FF0\u6811\u675F\u620D\u7AD6\u5885\u5EB6\u6570\u6F31"],
    ["cb40", "\u8582\u8583\u8586\u8588", 6, "\u8590", 10, "\u859D", 6, "\u85A5\u85A6\u85A7\u85A9\u85AB\u85AC\u85AD\u85B1", 5, "\u85B8\u85BA", 6, "\u85C2", 6, "\u85CA", 4, "\u85D1\u85D2"],
    ["cb80", "\u85D4\u85D6", 5, "\u85DD", 6, "\u85E5\u85E6\u85E7\u85E8\u85EA", 14, "\u6055\u5237\u800D\u6454\u8870\u7529\u5E05\u6813\u62F4\u971C\u53CC\u723D\u8C01\u6C34\u7761\u7A0E\u542E\u77AC\u987A\u821C\u8BF4\u7855\u6714\u70C1\u65AF\u6495\u5636\u601D\u79C1\u53F8\u4E1D\u6B7B\u8086\u5BFA\u55E3\u56DB\u4F3A\u4F3C\u9972\u5DF3\u677E\u8038\u6002\u9882\u9001\u5B8B\u8BBC\u8BF5\u641C\u8258\u64DE\u55FD\u82CF\u9165\u4FD7\u7D20\u901F\u7C9F\u50F3\u5851\u6EAF\u5BBF\u8BC9\u8083\u9178\u849C\u7B97\u867D\u968B\u968F\u7EE5\u9AD3\u788E\u5C81\u7A57\u9042\u96A7\u795F\u5B59\u635F\u7B0B\u84D1\u68AD\u5506\u7F29\u7410\u7D22\u9501\u6240\u584C\u4ED6\u5B83\u5979\u5854"],
    ["cc40", "\u85F9\u85FA\u85FC\u85FD\u85FE\u8600", 4, "\u8606", 10, "\u8612\u8613\u8614\u8615\u8617", 15, "\u8628\u862A", 13, "\u8639\u863A\u863B\u863D\u863E\u863F\u8640"],
    ["cc80", "\u8641", 11, "\u8652\u8653\u8655", 4, "\u865B\u865C\u865D\u865F\u8660\u8661\u8663", 7, "\u736D\u631E\u8E4B\u8E0F\u80CE\u82D4\u62AC\u53F0\u6CF0\u915E\u592A\u6001\u6C70\u574D\u644A\u8D2A\u762B\u6EE9\u575B\u6A80\u75F0\u6F6D\u8C2D\u8C08\u5766\u6BEF\u8892\u78B3\u63A2\u53F9\u70AD\u6C64\u5858\u642A\u5802\u68E0\u819B\u5510\u7CD6\u5018\u8EBA\u6DCC\u8D9F\u70EB\u638F\u6D9B\u6ED4\u7EE6\u8404\u6843\u9003\u6DD8\u9676\u8BA8\u5957\u7279\u85E4\u817E\u75BC\u8A8A\u68AF\u5254\u8E22\u9511\u63D0\u9898\u8E44\u557C\u4F53\u66FF\u568F\u60D5\u6D95\u5243\u5C49\u5929\u6DFB\u586B\u7530\u751C\u606C\u8214\u8146\u6311\u6761\u8FE2\u773A\u8DF3\u8D34\u94C1\u5E16\u5385\u542C\u70C3"],
    ["cd40", "\u866D\u866F\u8670\u8672", 6, "\u8683", 6, "\u868E", 4, "\u8694\u8696", 5, "\u869E", 4, "\u86A5\u86A6\u86AB\u86AD\u86AE\u86B2\u86B3\u86B7\u86B8\u86B9\u86BB", 4, "\u86C1\u86C2\u86C3\u86C5\u86C8\u86CC\u86CD\u86D2\u86D3\u86D5\u86D6\u86D7\u86DA\u86DC"],
    ["cd80", "\u86DD\u86E0\u86E1\u86E2\u86E3\u86E5\u86E6\u86E7\u86E8\u86EA\u86EB\u86EC\u86EF\u86F5\u86F6\u86F7\u86FA\u86FB\u86FC\u86FD\u86FF\u8701\u8704\u8705\u8706\u870B\u870C\u870E\u870F\u8710\u8711\u8714\u8716\u6C40\u5EF7\u505C\u4EAD\u5EAD\u633A\u8247\u901A\u6850\u916E\u77B3\u540C\u94DC\u5F64\u7AE5\u6876\u6345\u7B52\u7EDF\u75DB\u5077\u6295\u5934\u900F\u51F8\u79C3\u7A81\u56FE\u5F92\u9014\u6D82\u5C60\u571F\u5410\u5154\u6E4D\u56E2\u63A8\u9893\u817F\u8715\u892A\u9000\u541E\u5C6F\u81C0\u62D6\u6258\u8131\u9E35\u9640\u9A6E\u9A7C\u692D\u59A5\u62D3\u553E\u6316\u54C7\u86D9\u6D3C\u5A03\u74E6\u889C\u6B6A\u5916\u8C4C\u5F2F\u6E7E\u73A9\u987D\u4E38\u70F7\u5B8C\u7897\u633D\u665A\u7696\u60CB\u5B9B\u5A49\u4E07\u8155\u6C6A\u738B\u4EA1\u6789\u7F51\u5F80\u65FA\u671B\u5FD8\u5984\u5A01"],
    ["ce40", "\u8719\u871B\u871D\u871F\u8720\u8724\u8726\u8727\u8728\u872A\u872B\u872C\u872D\u872F\u8730\u8732\u8733\u8735\u8736\u8738\u8739\u873A\u873C\u873D\u8740", 6, "\u874A\u874B\u874D\u874F\u8750\u8751\u8752\u8754\u8755\u8756\u8758\u875A", 5, "\u8761\u8762\u8766", 7, "\u876F\u8771\u8772\u8773\u8775"],
    ["ce80", "\u8777\u8778\u8779\u877A\u877F\u8780\u8781\u8784\u8786\u8787\u8789\u878A\u878C\u878E", 4, "\u8794\u8795\u8796\u8798", 6, "\u87A0", 4, "\u5DCD\u5FAE\u5371\u97E6\u8FDD\u6845\u56F4\u552F\u60DF\u4E3A\u6F4D\u7EF4\u82C7\u840E\u59D4\u4F1F\u4F2A\u5C3E\u7EAC\u672A\u851A\u5473\u754F\u80C3\u5582\u9B4F\u4F4D\u6E2D\u8C13\u5C09\u6170\u536B\u761F\u6E29\u868A\u6587\u95FB\u7EB9\u543B\u7A33\u7D0A\u95EE\u55E1\u7FC1\u74EE\u631D\u8717\u6DA1\u7A9D\u6211\u65A1\u5367\u63E1\u6C83\u5DEB\u545C\u94A8\u4E4C\u6C61\u8BEC\u5C4B\u65E0\u829C\u68A7\u543E\u5434\u6BCB\u6B66\u4E94\u6342\u5348\u821E\u4F0D\u4FAE\u575E\u620A\u96FE\u6664\u7269\u52FF\u52A1\u609F\u8BEF\u6614\u7199\u6790\u897F\u7852\u77FD\u6670\u563B\u5438\u9521\u727A"],
    ["cf40", "\u87A5\u87A6\u87A7\u87A9\u87AA\u87AE\u87B0\u87B1\u87B2\u87B4\u87B6\u87B7\u87B8\u87B9\u87BB\u87BC\u87BE\u87BF\u87C1", 4, "\u87C7\u87C8\u87C9\u87CC", 4, "\u87D4", 6, "\u87DC\u87DD\u87DE\u87DF\u87E1\u87E2\u87E3\u87E4\u87E6\u87E7\u87E8\u87E9\u87EB\u87EC\u87ED\u87EF", 9],
    ["cf80", "\u87FA\u87FB\u87FC\u87FD\u87FF\u8800\u8801\u8802\u8804", 5, "\u880B", 7, "\u8814\u8817\u8818\u8819\u881A\u881C", 4, "\u8823\u7A00\u606F\u5E0C\u6089\u819D\u5915\u60DC\u7184\u70EF\u6EAA\u6C50\u7280\u6A84\u88AD\u5E2D\u4E60\u5AB3\u559C\u94E3\u6D17\u7CFB\u9699\u620F\u7EC6\u778E\u867E\u5323\u971E\u8F96\u6687\u5CE1\u4FA0\u72ED\u4E0B\u53A6\u590F\u5413\u6380\u9528\u5148\u4ED9\u9C9C\u7EA4\u54B8\u8D24\u8854\u8237\u95F2\u6D8E\u5F26\u5ACC\u663E\u9669\u73B0\u732E\u53BF\u817A\u9985\u7FA1\u5BAA\u9677\u9650\u7EBF\u76F8\u53A2\u9576\u9999\u7BB1\u8944\u6E58\u4E61\u7FD4\u7965\u8BE6\u60F3\u54CD\u4EAB\u9879\u5DF7\u6A61\u50CF\u5411\u8C61\u8427\u785D\u9704\u524A\u54EE\u56A3\u9500\u6D88\u5BB5\u6DC6\u6653"],
    ["d040", "\u8824", 13, "\u8833", 5, "\u883A\u883B\u883D\u883E\u883F\u8841\u8842\u8843\u8846", 5, "\u884E", 5, "\u8855\u8856\u8858\u885A", 6, "\u8866\u8867\u886A\u886D\u886F\u8871\u8873\u8874\u8875\u8876\u8878\u8879\u887A"],
    ["d080", "\u887B\u887C\u8880\u8883\u8886\u8887\u8889\u888A\u888C\u888E\u888F\u8890\u8891\u8893\u8894\u8895\u8897", 4, "\u889D", 4, "\u88A3\u88A5", 5, "\u5C0F\u5B5D\u6821\u8096\u5578\u7B11\u6548\u6954\u4E9B\u6B47\u874E\u978B\u534F\u631F\u643A\u90AA\u659C\u80C1\u8C10\u5199\u68B0\u5378\u87F9\u61C8\u6CC4\u6CFB\u8C22\u5C51\u85AA\u82AF\u950C\u6B23\u8F9B\u65B0\u5FFB\u5FC3\u4FE1\u8845\u661F\u8165\u7329\u60FA\u5174\u5211\u578B\u5F62\u90A2\u884C\u9192\u5E78\u674F\u6027\u59D3\u5144\u51F6\u80F8\u5308\u6C79\u96C4\u718A\u4F11\u4FEE\u7F9E\u673D\u55C5\u9508\u79C0\u8896\u7EE3\u589F\u620C\u9700\u865A\u5618\u987B\u5F90\u8BB8\u84C4\u9157\u53D9\u65ED\u5E8F\u755C\u6064\u7D6E\u5A7F\u7EEA\u7EED\u8F69\u55A7\u5BA3\u60AC\u65CB\u7384"],
    ["d140", "\u88AC\u88AE\u88AF\u88B0\u88B2", 4, "\u88B8\u88B9\u88BA\u88BB\u88BD\u88BE\u88BF\u88C0\u88C3\u88C4\u88C7\u88C8\u88CA\u88CB\u88CC\u88CD\u88CF\u88D0\u88D1\u88D3\u88D6\u88D7\u88DA", 4, "\u88E0\u88E1\u88E6\u88E7\u88E9", 6, "\u88F2\u88F5\u88F6\u88F7\u88FA\u88FB\u88FD\u88FF\u8900\u8901\u8903", 5],
    ["d180", "\u8909\u890B", 4, "\u8911\u8914", 4, "\u891C", 4, "\u8922\u8923\u8924\u8926\u8927\u8928\u8929\u892C\u892D\u892E\u892F\u8931\u8932\u8933\u8935\u8937\u9009\u7663\u7729\u7EDA\u9774\u859B\u5B66\u7A74\u96EA\u8840\u52CB\u718F\u5FAA\u65EC\u8BE2\u5BFB\u9A6F\u5DE1\u6B89\u6C5B\u8BAD\u8BAF\u900A\u8FC5\u538B\u62BC\u9E26\u9E2D\u5440\u4E2B\u82BD\u7259\u869C\u5D16\u8859\u6DAF\u96C5\u54D1\u4E9A\u8BB6\u7109\u54BD\u9609\u70DF\u6DF9\u76D0\u4E25\u7814\u8712\u5CA9\u5EF6\u8A00\u989C\u960E\u708E\u6CBF\u5944\u63A9\u773C\u884D\u6F14\u8273\u5830\u71D5\u538C\u781A\u96C1\u5501\u5F66\u7130\u5BB4\u8C1A\u9A8C\u6B83\u592E\u9E2F\u79E7\u6768\u626C\u4F6F\u75A1\u7F8A\u6D0B\u9633\u6C27\u4EF0\u75D2\u517B\u6837\u6F3E\u9080\u8170\u5996\u7476"],
    ["d240", "\u8938", 8, "\u8942\u8943\u8945", 24, "\u8960", 5, "\u8967", 19, "\u897C"],
    ["d280", "\u897D\u897E\u8980\u8982\u8984\u8985\u8987", 26, "\u6447\u5C27\u9065\u7A91\u8C23\u59DA\u54AC\u8200\u836F\u8981\u8000\u6930\u564E\u8036\u7237\u91CE\u51B6\u4E5F\u9875\u6396\u4E1A\u53F6\u66F3\u814B\u591C\u6DB2\u4E00\u58F9\u533B\u63D6\u94F1\u4F9D\u4F0A\u8863\u9890\u5937\u9057\u79FB\u4EEA\u80F0\u7591\u6C82\u5B9C\u59E8\u5F5D\u6905\u8681\u501A\u5DF2\u4E59\u77E3\u4EE5\u827A\u6291\u6613\u9091\u5C79\u4EBF\u5F79\u81C6\u9038\u8084\u75AB\u4EA6\u88D4\u610F\u6BC5\u5FC6\u4E49\u76CA\u6EA2\u8BE3\u8BAE\u8C0A\u8BD1\u5F02\u7FFC\u7FCC\u7ECE\u8335\u836B\u56E0\u6BB7\u97F3\u9634\u59FB\u541F\u94F6\u6DEB\u5BC5\u996E\u5C39\u5F15\u9690"],
    ["d340", "\u89A2", 30, "\u89C3\u89CD\u89D3\u89D4\u89D5\u89D7\u89D8\u89D9\u89DB\u89DD\u89DF\u89E0\u89E1\u89E2\u89E4\u89E7\u89E8\u89E9\u89EA\u89EC\u89ED\u89EE\u89F0\u89F1\u89F2\u89F4", 6],
    ["d380", "\u89FB", 4, "\u8A01", 5, "\u8A08", 21, "\u5370\u82F1\u6A31\u5A74\u9E70\u5E94\u7F28\u83B9\u8424\u8425\u8367\u8747\u8FCE\u8D62\u76C8\u5F71\u9896\u786C\u6620\u54DF\u62E5\u4F63\u81C3\u75C8\u5EB8\u96CD\u8E0A\u86F9\u548F\u6CF3\u6D8C\u6C38\u607F\u52C7\u7528\u5E7D\u4F18\u60A0\u5FE7\u5C24\u7531\u90AE\u94C0\u72B9\u6CB9\u6E38\u9149\u6709\u53CB\u53F3\u4F51\u91C9\u8BF1\u53C8\u5E7C\u8FC2\u6DE4\u4E8E\u76C2\u6986\u865E\u611A\u8206\u4F59\u4FDE\u903E\u9C7C\u6109\u6E1D\u6E14\u9685\u4E88\u5A31\u96E8\u4E0E\u5C7F\u79B9\u5B87\u8BED\u7FBD\u7389\u57DF\u828B\u90C1\u5401\u9047\u55BB\u5CEA\u5FA1\u6108\u6B32\u72F1\u80B2\u8A89"],
    ["d440", "\u8A1E", 31, "\u8A3F", 8, "\u8A49", 21],
    ["d480", "\u8A5F", 25, "\u8A7A", 6, "\u6D74\u5BD3\u88D5\u9884\u8C6B\u9A6D\u9E33\u6E0A\u51A4\u5143\u57A3\u8881\u539F\u63F4\u8F95\u56ED\u5458\u5706\u733F\u6E90\u7F18\u8FDC\u82D1\u613F\u6028\u9662\u66F0\u7EA6\u8D8A\u8DC3\u94A5\u5CB3\u7CA4\u6708\u60A6\u9605\u8018\u4E91\u90E7\u5300\u9668\u5141\u8FD0\u8574\u915D\u6655\u97F5\u5B55\u531D\u7838\u6742\u683D\u54C9\u707E\u5BB0\u8F7D\u518D\u5728\u54B1\u6512\u6682\u8D5E\u8D43\u810F\u846C\u906D\u7CDF\u51FF\u85FB\u67A3\u65E9\u6FA1\u86A4\u8E81\u566A\u9020\u7682\u7076\u71E5\u8D23\u62E9\u5219\u6CFD\u8D3C\u600E\u589E\u618E\u66FE\u8D60\u624E\u55B3\u6E23\u672D\u8F67"],
    ["d540", "\u8A81", 7, "\u8A8B", 7, "\u8A94", 46],
    ["d580", "\u8AC3", 32, "\u94E1\u95F8\u7728\u6805\u69A8\u548B\u4E4D\u70B8\u8BC8\u6458\u658B\u5B85\u7A84\u503A\u5BE8\u77BB\u6BE1\u8A79\u7C98\u6CBE\u76CF\u65A9\u8F97\u5D2D\u5C55\u8638\u6808\u5360\u6218\u7AD9\u6E5B\u7EFD\u6A1F\u7AE0\u5F70\u6F33\u5F20\u638C\u6DA8\u6756\u4E08\u5E10\u8D26\u4ED7\u80C0\u7634\u969C\u62DB\u662D\u627E\u6CBC\u8D75\u7167\u7F69\u5146\u8087\u53EC\u906E\u6298\u54F2\u86F0\u8F99\u8005\u9517\u8517\u8FD9\u6D59\u73CD\u659F\u771F\u7504\u7827\u81FB\u8D1E\u9488\u4FA6\u6795\u75B9\u8BCA\u9707\u632F\u9547\u9635\u84B8\u6323\u7741\u5F81\u72F0\u4E89\u6014\u6574\u62EF\u6B63\u653F"],
    ["d640", "\u8AE4", 34, "\u8B08", 27],
    ["d680", "\u8B24\u8B25\u8B27", 30, "\u5E27\u75C7\u90D1\u8BC1\u829D\u679D\u652F\u5431\u8718\u77E5\u80A2\u8102\u6C41\u4E4B\u7EC7\u804C\u76F4\u690D\u6B96\u6267\u503C\u4F84\u5740\u6307\u6B62\u8DBE\u53EA\u65E8\u7EB8\u5FD7\u631A\u63B7\u81F3\u81F4\u7F6E\u5E1C\u5CD9\u5236\u667A\u79E9\u7A1A\u8D28\u7099\u75D4\u6EDE\u6CBB\u7A92\u4E2D\u76C5\u5FE0\u949F\u8877\u7EC8\u79CD\u80BF\u91CD\u4EF2\u4F17\u821F\u5468\u5DDE\u6D32\u8BCC\u7CA5\u8F74\u8098\u5E1A\u5492\u76B1\u5B99\u663C\u9AA4\u73E0\u682A\u86DB\u6731\u732A\u8BF8\u8BDB\u9010\u7AF9\u70DB\u716E\u62C4\u77A9\u5631\u4E3B\u8457\u67F1\u52A9\u86C0\u8D2E\u94F8\u7B51"],
    ["d740", "\u8B46", 31, "\u8B67", 4, "\u8B6D", 25],
    ["d780", "\u8B87", 24, "\u8BAC\u8BB1\u8BBB\u8BC7\u8BD0\u8BEA\u8C09\u8C1E\u4F4F\u6CE8\u795D\u9A7B\u6293\u722A\u62FD\u4E13\u7816\u8F6C\u64B0\u8D5A\u7BC6\u6869\u5E84\u88C5\u5986\u649E\u58EE\u72B6\u690E\u9525\u8FFD\u8D58\u5760\u7F00\u8C06\u51C6\u6349\u62D9\u5353\u684C\u7422\u8301\u914C\u5544\u7740\u707C\u6D4A\u5179\u54A8\u8D44\u59FF\u6ECB\u6DC4\u5B5C\u7D2B\u4ED4\u7C7D\u6ED3\u5B50\u81EA\u6E0D\u5B57\u9B03\u68D5\u8E2A\u5B97\u7EFC\u603B\u7EB5\u90B9\u8D70\u594F\u63CD\u79DF\u8DB3\u5352\u65CF\u7956\u8BC5\u963B\u7EC4\u94BB\u7E82\u5634\u9189\u6700\u7F6A\u5C0A\u9075\u6628\u5DE6\u4F50\u67DE\u505A\u4F5C\u5750\u5EA7"],
    ["d840", "\u8C38", 8, "\u8C42\u8C43\u8C44\u8C45\u8C48\u8C4A\u8C4B\u8C4D", 7, "\u8C56\u8C57\u8C58\u8C59\u8C5B", 5, "\u8C63", 6, "\u8C6C", 6, "\u8C74\u8C75\u8C76\u8C77\u8C7B", 6, "\u8C83\u8C84\u8C86\u8C87"],
    ["d880", "\u8C88\u8C8B\u8C8D", 6, "\u8C95\u8C96\u8C97\u8C99", 20, "\u4E8D\u4E0C\u5140\u4E10\u5EFF\u5345\u4E15\u4E98\u4E1E\u9B32\u5B6C\u5669\u4E28\u79BA\u4E3F\u5315\u4E47\u592D\u723B\u536E\u6C10\u56DF\u80E4\u9997\u6BD3\u777E\u9F17\u4E36\u4E9F\u9F10\u4E5C\u4E69\u4E93\u8288\u5B5B\u556C\u560F\u4EC4\u538D\u539D\u53A3\u53A5\u53AE\u9765\u8D5D\u531A\u53F5\u5326\u532E\u533E\u8D5C\u5366\u5363\u5202\u5208\u520E\u522D\u5233\u523F\u5240\u524C\u525E\u5261\u525C\u84AF\u527D\u5282\u5281\u5290\u5293\u5182\u7F54\u4EBB\u4EC3\u4EC9\u4EC2\u4EE8\u4EE1\u4EEB\u4EDE\u4F1B\u4EF3\u4F22\u4F64\u4EF5\u4F25\u4F27\u4F09\u4F2B\u4F5E\u4F67\u6538\u4F5A\u4F5D"],
    ["d940", "\u8CAE", 62],
    ["d980", "\u8CED", 32, "\u4F5F\u4F57\u4F32\u4F3D\u4F76\u4F74\u4F91\u4F89\u4F83\u4F8F\u4F7E\u4F7B\u4FAA\u4F7C\u4FAC\u4F94\u4FE6\u4FE8\u4FEA\u4FC5\u4FDA\u4FE3\u4FDC\u4FD1\u4FDF\u4FF8\u5029\u504C\u4FF3\u502C\u500F\u502E\u502D\u4FFE\u501C\u500C\u5025\u5028\u507E\u5043\u5055\u5048\u504E\u506C\u507B\u50A5\u50A7\u50A9\u50BA\u50D6\u5106\u50ED\u50EC\u50E6\u50EE\u5107\u510B\u4EDD\u6C3D\u4F58\u4F65\u4FCE\u9FA0\u6C46\u7C74\u516E\u5DFD\u9EC9\u9998\u5181\u5914\u52F9\u530D\u8A07\u5310\u51EB\u5919\u5155\u4EA0\u5156\u4EB3\u886E\u88A4\u4EB5\u8114\u88D2\u7980\u5B34\u8803\u7FB8\u51AB\u51B1\u51BD\u51BC"],
    ["da40", "\u8D0E", 14, "\u8D20\u8D51\u8D52\u8D57\u8D5F\u8D65\u8D68\u8D69\u8D6A\u8D6C\u8D6E\u8D6F\u8D71\u8D72\u8D78", 8, "\u8D82\u8D83\u8D86\u8D87\u8D88\u8D89\u8D8C", 4, "\u8D92\u8D93\u8D95", 9, "\u8DA0\u8DA1"],
    ["da80", "\u8DA2\u8DA4", 12, "\u8DB2\u8DB6\u8DB7\u8DB9\u8DBB\u8DBD\u8DC0\u8DC1\u8DC2\u8DC5\u8DC7\u8DC8\u8DC9\u8DCA\u8DCD\u8DD0\u8DD2\u8DD3\u8DD4\u51C7\u5196\u51A2\u51A5\u8BA0\u8BA6\u8BA7\u8BAA\u8BB4\u8BB5\u8BB7\u8BC2\u8BC3\u8BCB\u8BCF\u8BCE\u8BD2\u8BD3\u8BD4\u8BD6\u8BD8\u8BD9\u8BDC\u8BDF\u8BE0\u8BE4\u8BE8\u8BE9\u8BEE\u8BF0\u8BF3\u8BF6\u8BF9\u8BFC\u8BFF\u8C00\u8C02\u8C04\u8C07\u8C0C\u8C0F\u8C11\u8C12\u8C14\u8C15\u8C16\u8C19\u8C1B\u8C18\u8C1D\u8C1F\u8C20\u8C21\u8C25\u8C27\u8C2A\u8C2B\u8C2E\u8C2F\u8C32\u8C33\u8C35\u8C36\u5369\u537A\u961D\u9622\u9621\u9631\u962A\u963D\u963C\u9642\u9649\u9654\u965F\u9667\u966C\u9672\u9674\u9688\u968D\u9697\u96B0\u9097\u909B\u909D\u9099\u90AC\u90A1\u90B4\u90B3\u90B6\u90BA"],
    ["db40", "\u8DD5\u8DD8\u8DD9\u8DDC\u8DE0\u8DE1\u8DE2\u8DE5\u8DE6\u8DE7\u8DE9\u8DED\u8DEE\u8DF0\u8DF1\u8DF2\u8DF4\u8DF6\u8DFC\u8DFE", 6, "\u8E06\u8E07\u8E08\u8E0B\u8E0D\u8E0E\u8E10\u8E11\u8E12\u8E13\u8E15", 7, "\u8E20\u8E21\u8E24", 4, "\u8E2B\u8E2D\u8E30\u8E32\u8E33\u8E34\u8E36\u8E37\u8E38\u8E3B\u8E3C\u8E3E"],
    ["db80", "\u8E3F\u8E43\u8E45\u8E46\u8E4C", 4, "\u8E53", 5, "\u8E5A", 11, "\u8E67\u8E68\u8E6A\u8E6B\u8E6E\u8E71\u90B8\u90B0\u90CF\u90C5\u90BE\u90D0\u90C4\u90C7\u90D3\u90E6\u90E2\u90DC\u90D7\u90DB\u90EB\u90EF\u90FE\u9104\u9122\u911E\u9123\u9131\u912F\u9139\u9143\u9146\u520D\u5942\u52A2\u52AC\u52AD\u52BE\u54FF\u52D0\u52D6\u52F0\u53DF\u71EE\u77CD\u5EF4\u51F5\u51FC\u9B2F\u53B6\u5F01\u755A\u5DEF\u574C\u57A9\u57A1\u587E\u58BC\u58C5\u58D1\u5729\u572C\u572A\u5733\u5739\u572E\u572F\u575C\u573B\u5742\u5769\u5785\u576B\u5786\u577C\u577B\u5768\u576D\u5776\u5773\u57AD\u57A4\u578C\u57B2\u57CF\u57A7\u57B4\u5793\u57A0\u57D5\u57D8\u57DA\u57D9\u57D2\u57B8\u57F4\u57EF\u57F8\u57E4\u57DD"],
    ["dc40", "\u8E73\u8E75\u8E77", 4, "\u8E7D\u8E7E\u8E80\u8E82\u8E83\u8E84\u8E86\u8E88", 6, "\u8E91\u8E92\u8E93\u8E95", 6, "\u8E9D\u8E9F", 11, "\u8EAD\u8EAE\u8EB0\u8EB1\u8EB3", 6, "\u8EBB", 7],
    ["dc80", "\u8EC3", 10, "\u8ECF", 21, "\u580B\u580D\u57FD\u57ED\u5800\u581E\u5819\u5844\u5820\u5865\u586C\u5881\u5889\u589A\u5880\u99A8\u9F19\u61FF\u8279\u827D\u827F\u828F\u828A\u82A8\u8284\u828E\u8291\u8297\u8299\u82AB\u82B8\u82BE\u82B0\u82C8\u82CA\u82E3\u8298\u82B7\u82AE\u82CB\u82CC\u82C1\u82A9\u82B4\u82A1\u82AA\u829F\u82C4\u82CE\u82A4\u82E1\u8309\u82F7\u82E4\u830F\u8307\u82DC\u82F4\u82D2\u82D8\u830C\u82FB\u82D3\u8311\u831A\u8306\u8314\u8315\u82E0\u82D5\u831C\u8351\u835B\u835C\u8308\u8392\u833C\u8334\u8331\u839B\u835E\u832F\u834F\u8347\u8343\u835F\u8340\u8317\u8360\u832D\u833A\u8333\u8366\u8365"],
    ["dd40", "\u8EE5", 62],
    ["dd80", "\u8F24", 32, "\u8368\u831B\u8369\u836C\u836A\u836D\u836E\u83B0\u8378\u83B3\u83B4\u83A0\u83AA\u8393\u839C\u8385\u837C\u83B6\u83A9\u837D\u83B8\u837B\u8398\u839E\u83A8\u83BA\u83BC\u83C1\u8401\u83E5\u83D8\u5807\u8418\u840B\u83DD\u83FD\u83D6\u841C\u8438\u8411\u8406\u83D4\u83DF\u840F\u8403\u83F8\u83F9\u83EA\u83C5\u83C0\u8426\u83F0\u83E1\u845C\u8451\u845A\u8459\u8473\u8487\u8488\u847A\u8489\u8478\u843C\u8446\u8469\u8476\u848C\u848E\u8431\u846D\u84C1\u84CD\u84D0\u84E6\u84BD\u84D3\u84CA\u84BF\u84BA\u84E0\u84A1\u84B9\u84B4\u8497\u84E5\u84E3\u850C\u750D\u8538\u84F0\u8539\u851F\u853A"],
    ["de40", "\u8F45", 32, "\u8F6A\u8F80\u8F8C\u8F92\u8F9D\u8FA0\u8FA1\u8FA2\u8FA4\u8FA5\u8FA6\u8FA7\u8FAA\u8FAC\u8FAD\u8FAE\u8FAF\u8FB2\u8FB3\u8FB4\u8FB5\u8FB7\u8FB8\u8FBA\u8FBB\u8FBC\u8FBF\u8FC0\u8FC3\u8FC6"],
    ["de80", "\u8FC9", 4, "\u8FCF\u8FD2\u8FD6\u8FD7\u8FDA\u8FE0\u8FE1\u8FE3\u8FE7\u8FEC\u8FEF\u8FF1\u8FF2\u8FF4\u8FF5\u8FF6\u8FFA\u8FFB\u8FFC\u8FFE\u8FFF\u9007\u9008\u900C\u900E\u9013\u9015\u9018\u8556\u853B\u84FF\u84FC\u8559\u8548\u8568\u8564\u855E\u857A\u77A2\u8543\u8572\u857B\u85A4\u85A8\u8587\u858F\u8579\u85AE\u859C\u8585\u85B9\u85B7\u85B0\u85D3\u85C1\u85DC\u85FF\u8627\u8605\u8629\u8616\u863C\u5EFE\u5F08\u593C\u5941\u8037\u5955\u595A\u5958\u530F\u5C22\u5C25\u5C2C\u5C34\u624C\u626A\u629F\u62BB\u62CA\u62DA\u62D7\u62EE\u6322\u62F6\u6339\u634B\u6343\u63AD\u63F6\u6371\u637A\u638E\u63B4\u636D\u63AC\u638A\u6369\u63AE\u63BC\u63F2\u63F8\u63E0\u63FF\u63C4\u63DE\u63CE\u6452\u63C6\u63BE\u6445\u6441\u640B\u641B\u6420\u640C\u6426\u6421\u645E\u6484\u646D\u6496"],
    ["df40", "\u9019\u901C\u9023\u9024\u9025\u9027", 5, "\u9030", 4, "\u9037\u9039\u903A\u903D\u903F\u9040\u9043\u9045\u9046\u9048", 4, "\u904E\u9054\u9055\u9056\u9059\u905A\u905C", 5, "\u9064\u9066\u9067\u9069\u906A\u906B\u906C\u906F", 4, "\u9076", 6, "\u907E\u9081"],
    ["df80", "\u9084\u9085\u9086\u9087\u9089\u908A\u908C", 4, "\u9092\u9094\u9096\u9098\u909A\u909C\u909E\u909F\u90A0\u90A4\u90A5\u90A7\u90A8\u90A9\u90AB\u90AD\u90B2\u90B7\u90BC\u90BD\u90BF\u90C0\u647A\u64B7\u64B8\u6499\u64BA\u64C0\u64D0\u64D7\u64E4\u64E2\u6509\u6525\u652E\u5F0B\u5FD2\u7519\u5F11\u535F\u53F1\u53FD\u53E9\u53E8\u53FB\u5412\u5416\u5406\u544B\u5452\u5453\u5454\u5456\u5443\u5421\u5457\u5459\u5423\u5432\u5482\u5494\u5477\u5471\u5464\u549A\u549B\u5484\u5476\u5466\u549D\u54D0\u54AD\u54C2\u54B4\u54D2\u54A7\u54A6\u54D3\u54D4\u5472\u54A3\u54D5\u54BB\u54BF\u54CC\u54D9\u54DA\u54DC\u54A9\u54AA\u54A4\u54DD\u54CF\u54DE\u551B\u54E7\u5520\u54FD\u5514\u54F3\u5522\u5523\u550F\u5511\u5527\u552A\u5567\u558F\u55B5\u5549\u556D\u5541\u5555\u553F\u5550\u553C"],
    ["e040", "\u90C2\u90C3\u90C6\u90C8\u90C9\u90CB\u90CC\u90CD\u90D2\u90D4\u90D5\u90D6\u90D8\u90D9\u90DA\u90DE\u90DF\u90E0\u90E3\u90E4\u90E5\u90E9\u90EA\u90EC\u90EE\u90F0\u90F1\u90F2\u90F3\u90F5\u90F6\u90F7\u90F9\u90FA\u90FB\u90FC\u90FF\u9100\u9101\u9103\u9105", 19, "\u911A\u911B\u911C"],
    ["e080", "\u911D\u911F\u9120\u9121\u9124", 10, "\u9130\u9132", 6, "\u913A", 8, "\u9144\u5537\u5556\u5575\u5576\u5577\u5533\u5530\u555C\u558B\u55D2\u5583\u55B1\u55B9\u5588\u5581\u559F\u557E\u55D6\u5591\u557B\u55DF\u55BD\u55BE\u5594\u5599\u55EA\u55F7\u55C9\u561F\u55D1\u55EB\u55EC\u55D4\u55E6\u55DD\u55C4\u55EF\u55E5\u55F2\u55F3\u55CC\u55CD\u55E8\u55F5\u55E4\u8F94\u561E\u5608\u560C\u5601\u5624\u5623\u55FE\u5600\u5627\u562D\u5658\u5639\u5657\u562C\u564D\u5662\u5659\u565C\u564C\u5654\u5686\u5664\u5671\u566B\u567B\u567C\u5685\u5693\u56AF\u56D4\u56D7\u56DD\u56E1\u56F5\u56EB\u56F9\u56FF\u5704\u570A\u5709\u571C\u5E0F\u5E19\u5E14\u5E11\u5E31\u5E3B\u5E3C"],
    ["e140", "\u9145\u9147\u9148\u9151\u9153\u9154\u9155\u9156\u9158\u9159\u915B\u915C\u915F\u9160\u9166\u9167\u9168\u916B\u916D\u9173\u917A\u917B\u917C\u9180", 4, "\u9186\u9188\u918A\u918E\u918F\u9193", 6, "\u919C", 5, "\u91A4", 5, "\u91AB\u91AC\u91B0\u91B1\u91B2\u91B3\u91B6\u91B7\u91B8\u91B9\u91BB"],
    ["e180", "\u91BC", 10, "\u91C8\u91CB\u91D0\u91D2", 9, "\u91DD", 8, "\u5E37\u5E44\u5E54\u5E5B\u5E5E\u5E61\u5C8C\u5C7A\u5C8D\u5C90\u5C96\u5C88\u5C98\u5C99\u5C91\u5C9A\u5C9C\u5CB5\u5CA2\u5CBD\u5CAC\u5CAB\u5CB1\u5CA3\u5CC1\u5CB7\u5CC4\u5CD2\u5CE4\u5CCB\u5CE5\u5D02\u5D03\u5D27\u5D26\u5D2E\u5D24\u5D1E\u5D06\u5D1B\u5D58\u5D3E\u5D34\u5D3D\u5D6C\u5D5B\u5D6F\u5D5D\u5D6B\u5D4B\u5D4A\u5D69\u5D74\u5D82\u5D99\u5D9D\u8C73\u5DB7\u5DC5\u5F73\u5F77\u5F82\u5F87\u5F89\u5F8C\u5F95\u5F99\u5F9C\u5FA8\u5FAD\u5FB5\u5FBC\u8862\u5F61\u72AD\u72B0\u72B4\u72B7\u72B8\u72C3\u72C1\u72CE\u72CD\u72D2\u72E8\u72EF\u72E9\u72F2\u72F4\u72F7\u7301\u72F3\u7303\u72FA"],
    ["e240", "\u91E6", 62],
    ["e280", "\u9225", 32, "\u72FB\u7317\u7313\u7321\u730A\u731E\u731D\u7315\u7322\u7339\u7325\u732C\u7338\u7331\u7350\u734D\u7357\u7360\u736C\u736F\u737E\u821B\u5925\u98E7\u5924\u5902\u9963\u9967", 5, "\u9974\u9977\u997D\u9980\u9984\u9987\u998A\u998D\u9990\u9991\u9993\u9994\u9995\u5E80\u5E91\u5E8B\u5E96\u5EA5\u5EA0\u5EB9\u5EB5\u5EBE\u5EB3\u8D53\u5ED2\u5ED1\u5EDB\u5EE8\u5EEA\u81BA\u5FC4\u5FC9\u5FD6\u5FCF\u6003\u5FEE\u6004\u5FE1\u5FE4\u5FFE\u6005\u6006\u5FEA\u5FED\u5FF8\u6019\u6035\u6026\u601B\u600F\u600D\u6029\u602B\u600A\u603F\u6021\u6078\u6079\u607B\u607A\u6042"],
    ["e340", "\u9246", 45, "\u9275", 16],
    ["e380", "\u9286", 7, "\u928F", 24, "\u606A\u607D\u6096\u609A\u60AD\u609D\u6083\u6092\u608C\u609B\u60EC\u60BB\u60B1\u60DD\u60D8\u60C6\u60DA\u60B4\u6120\u6126\u6115\u6123\u60F4\u6100\u610E\u612B\u614A\u6175\u61AC\u6194\u61A7\u61B7\u61D4\u61F5\u5FDD\u96B3\u95E9\u95EB\u95F1\u95F3\u95F5\u95F6\u95FC\u95FE\u9603\u9604\u9606\u9608\u960A\u960B\u960C\u960D\u960F\u9612\u9615\u9616\u9617\u9619\u961A\u4E2C\u723F\u6215\u6C35\u6C54\u6C5C\u6C4A\u6CA3\u6C85\u6C90\u6C94\u6C8C\u6C68\u6C69\u6C74\u6C76\u6C86\u6CA9\u6CD0\u6CD4\u6CAD\u6CF7\u6CF8\u6CF1\u6CD7\u6CB2\u6CE0\u6CD6\u6CFA\u6CEB\u6CEE\u6CB1\u6CD3\u6CEF\u6CFE"],
    ["e440", "\u92A8", 5, "\u92AF", 24, "\u92C9", 31],
    ["e480", "\u92E9", 32, "\u6D39\u6D27\u6D0C\u6D43\u6D48\u6D07\u6D04\u6D19\u6D0E\u6D2B\u6D4D\u6D2E\u6D35\u6D1A\u6D4F\u6D52\u6D54\u6D33\u6D91\u6D6F\u6D9E\u6DA0\u6D5E\u6D93\u6D94\u6D5C\u6D60\u6D7C\u6D63\u6E1A\u6DC7\u6DC5\u6DDE\u6E0E\u6DBF\u6DE0\u6E11\u6DE6\u6DDD\u6DD9\u6E16\u6DAB\u6E0C\u6DAE\u6E2B\u6E6E\u6E4E\u6E6B\u6EB2\u6E5F\u6E86\u6E53\u6E54\u6E32\u6E25\u6E44\u6EDF\u6EB1\u6E98\u6EE0\u6F2D\u6EE2\u6EA5\u6EA7\u6EBD\u6EBB\u6EB7\u6ED7\u6EB4\u6ECF\u6E8F\u6EC2\u6E9F\u6F62\u6F46\u6F47\u6F24\u6F15\u6EF9\u6F2F\u6F36\u6F4B\u6F74\u6F2A\u6F09\u6F29\u6F89\u6F8D\u6F8C\u6F78\u6F72\u6F7C\u6F7A\u6FD1"],
    ["e540", "\u930A", 51, "\u933F", 10],
    ["e580", "\u934A", 31, "\u936B\u6FC9\u6FA7\u6FB9\u6FB6\u6FC2\u6FE1\u6FEE\u6FDE\u6FE0\u6FEF\u701A\u7023\u701B\u7039\u7035\u704F\u705E\u5B80\u5B84\u5B95\u5B93\u5BA5\u5BB8\u752F\u9A9E\u6434\u5BE4\u5BEE\u8930\u5BF0\u8E47\u8B07\u8FB6\u8FD3\u8FD5\u8FE5\u8FEE\u8FE4\u8FE9\u8FE6\u8FF3\u8FE8\u9005\u9004\u900B\u9026\u9011\u900D\u9016\u9021\u9035\u9036\u902D\u902F\u9044\u9051\u9052\u9050\u9068\u9058\u9062\u905B\u66B9\u9074\u907D\u9082\u9088\u9083\u908B\u5F50\u5F57\u5F56\u5F58\u5C3B\u54AB\u5C50\u5C59\u5B71\u5C63\u5C66\u7FBC\u5F2A\u5F29\u5F2D\u8274\u5F3C\u9B3B\u5C6E\u5981\u5983\u598D\u59A9\u59AA\u59A3"],
    ["e640", "\u936C", 34, "\u9390", 27],
    ["e680", "\u93AC", 29, "\u93CB\u93CC\u93CD\u5997\u59CA\u59AB\u599E\u59A4\u59D2\u59B2\u59AF\u59D7\u59BE\u5A05\u5A06\u59DD\u5A08\u59E3\u59D8\u59F9\u5A0C\u5A09\u5A32\u5A34\u5A11\u5A23\u5A13\u5A40\u5A67\u5A4A\u5A55\u5A3C\u5A62\u5A75\u80EC\u5AAA\u5A9B\u5A77\u5A7A\u5ABE\u5AEB\u5AB2\u5AD2\u5AD4\u5AB8\u5AE0\u5AE3\u5AF1\u5AD6\u5AE6\u5AD8\u5ADC\u5B09\u5B17\u5B16\u5B32\u5B37\u5B40\u5C15\u5C1C\u5B5A\u5B65\u5B73\u5B51\u5B53\u5B62\u9A75\u9A77\u9A78\u9A7A\u9A7F\u9A7D\u9A80\u9A81\u9A85\u9A88\u9A8A\u9A90\u9A92\u9A93\u9A96\u9A98\u9A9B\u9A9C\u9A9D\u9A9F\u9AA0\u9AA2\u9AA3\u9AA5\u9AA7\u7E9F\u7EA1\u7EA3\u7EA5\u7EA8\u7EA9"],
    ["e740", "\u93CE", 7, "\u93D7", 54],
    ["e780", "\u940E", 32, "\u7EAD\u7EB0\u7EBE\u7EC0\u7EC1\u7EC2\u7EC9\u7ECB\u7ECC\u7ED0\u7ED4\u7ED7\u7EDB\u7EE0\u7EE1\u7EE8\u7EEB\u7EEE\u7EEF\u7EF1\u7EF2\u7F0D\u7EF6\u7EFA\u7EFB\u7EFE\u7F01\u7F02\u7F03\u7F07\u7F08\u7F0B\u7F0C\u7F0F\u7F11\u7F12\u7F17\u7F19\u7F1C\u7F1B\u7F1F\u7F21", 6, "\u7F2A\u7F2B\u7F2C\u7F2D\u7F2F", 4, "\u7F35\u5E7A\u757F\u5DDB\u753E\u9095\u738E\u7391\u73AE\u73A2\u739F\u73CF\u73C2\u73D1\u73B7\u73B3\u73C0\u73C9\u73C8\u73E5\u73D9\u987C\u740A\u73E9\u73E7\u73DE\u73BA\u73F2\u740F\u742A\u745B\u7426\u7425\u7428\u7430\u742E\u742C"],
    ["e840", "\u942F", 14, "\u943F", 43, "\u946C\u946D\u946E\u946F"],
    ["e880", "\u9470", 20, "\u9491\u9496\u9498\u94C7\u94CF\u94D3\u94D4\u94DA\u94E6\u94FB\u951C\u9520\u741B\u741A\u7441\u745C\u7457\u7455\u7459\u7477\u746D\u747E\u749C\u748E\u7480\u7481\u7487\u748B\u749E\u74A8\u74A9\u7490\u74A7\u74D2\u74BA\u97EA\u97EB\u97EC\u674C\u6753\u675E\u6748\u6769\u67A5\u6787\u676A\u6773\u6798\u67A7\u6775\u67A8\u679E\u67AD\u678B\u6777\u677C\u67F0\u6809\u67D8\u680A\u67E9\u67B0\u680C\u67D9\u67B5\u67DA\u67B3\u67DD\u6800\u67C3\u67B8\u67E2\u680E\u67C1\u67FD\u6832\u6833\u6860\u6861\u684E\u6862\u6844\u6864\u6883\u681D\u6855\u6866\u6841\u6867\u6840\u683E\u684A\u6849\u6829\u68B5\u688F\u6874\u6877\u6893\u686B\u68C2\u696E\u68FC\u691F\u6920\u68F9"],
    ["e940", "\u9527\u9533\u953D\u9543\u9548\u954B\u9555\u955A\u9560\u956E\u9574\u9575\u9577", 7, "\u9580", 42],
    ["e980", "\u95AB", 32, "\u6924\u68F0\u690B\u6901\u6957\u68E3\u6910\u6971\u6939\u6960\u6942\u695D\u6984\u696B\u6980\u6998\u6978\u6934\u69CC\u6987\u6988\u69CE\u6989\u6966\u6963\u6979\u699B\u69A7\u69BB\u69AB\u69AD\u69D4\u69B1\u69C1\u69CA\u69DF\u6995\u69E0\u698D\u69FF\u6A2F\u69ED\u6A17\u6A18\u6A65\u69F2\u6A44\u6A3E\u6AA0\u6A50\u6A5B\u6A35\u6A8E\u6A79\u6A3D\u6A28\u6A58\u6A7C\u6A91\u6A90\u6AA9\u6A97\u6AAB\u7337\u7352\u6B81\u6B82\u6B87\u6B84\u6B92\u6B93\u6B8D\u6B9A\u6B9B\u6BA1\u6BAA\u8F6B\u8F6D\u8F71\u8F72\u8F73\u8F75\u8F76\u8F78\u8F77\u8F79\u8F7A\u8F7C\u8F7E\u8F81\u8F82\u8F84\u8F87\u8F8B"],
    ["ea40", "\u95CC", 27, "\u95EC\u95FF\u9607\u9613\u9618\u961B\u961E\u9620\u9623", 6, "\u962B\u962C\u962D\u962F\u9630\u9637\u9638\u9639\u963A\u963E\u9641\u9643\u964A\u964E\u964F\u9651\u9652\u9653\u9656\u9657"],
    ["ea80", "\u9658\u9659\u965A\u965C\u965D\u965E\u9660\u9663\u9665\u9666\u966B\u966D", 4, "\u9673\u9678", 12, "\u9687\u9689\u968A\u8F8D\u8F8E\u8F8F\u8F98\u8F9A\u8ECE\u620B\u6217\u621B\u621F\u6222\u6221\u6225\u6224\u622C\u81E7\u74EF\u74F4\u74FF\u750F\u7511\u7513\u6534\u65EE\u65EF\u65F0\u660A\u6619\u6772\u6603\u6615\u6600\u7085\u66F7\u661D\u6634\u6631\u6636\u6635\u8006\u665F\u6654\u6641\u664F\u6656\u6661\u6657\u6677\u6684\u668C\u66A7\u669D\u66BE\u66DB\u66DC\u66E6\u66E9\u8D32\u8D33\u8D36\u8D3B\u8D3D\u8D40\u8D45\u8D46\u8D48\u8D49\u8D47\u8D4D\u8D55\u8D59\u89C7\u89CA\u89CB\u89CC\u89CE\u89CF\u89D0\u89D1\u726E\u729F\u725D\u7266\u726F\u727E\u727F\u7284\u728B\u728D\u728F\u7292\u6308\u6332\u63B0"],
    ["eb40", "\u968C\u968E\u9691\u9692\u9693\u9695\u9696\u969A\u969B\u969D", 9, "\u96A8", 7, "\u96B1\u96B2\u96B4\u96B5\u96B7\u96B8\u96BA\u96BB\u96BF\u96C2\u96C3\u96C8\u96CA\u96CB\u96D0\u96D1\u96D3\u96D4\u96D6", 9, "\u96E1", 6, "\u96EB"],
    ["eb80", "\u96EC\u96ED\u96EE\u96F0\u96F1\u96F2\u96F4\u96F5\u96F8\u96FA\u96FB\u96FC\u96FD\u96FF\u9702\u9703\u9705\u970A\u970B\u970C\u9710\u9711\u9712\u9714\u9715\u9717", 4, "\u971D\u971F\u9720\u643F\u64D8\u8004\u6BEA\u6BF3\u6BFD\u6BF5\u6BF9\u6C05\u6C07\u6C06\u6C0D\u6C15\u6C18\u6C19\u6C1A\u6C21\u6C29\u6C24\u6C2A\u6C32\u6535\u6555\u656B\u724D\u7252\u7256\u7230\u8662\u5216\u809F\u809C\u8093\u80BC\u670A\u80BD\u80B1\u80AB\u80AD\u80B4\u80B7\u80E7\u80E8\u80E9\u80EA\u80DB\u80C2\u80C4\u80D9\u80CD\u80D7\u6710\u80DD\u80EB\u80F1\u80F4\u80ED\u810D\u810E\u80F2\u80FC\u6715\u8112\u8C5A\u8136\u811E\u812C\u8118\u8132\u8148\u814C\u8153\u8174\u8159\u815A\u8171\u8160\u8169\u817C\u817D\u816D\u8167\u584D\u5AB5\u8188\u8182\u8191\u6ED5\u81A3\u81AA\u81CC\u6726\u81CA\u81BB"],
    ["ec40", "\u9721", 8, "\u972B\u972C\u972E\u972F\u9731\u9733", 4, "\u973A\u973B\u973C\u973D\u973F", 18, "\u9754\u9755\u9757\u9758\u975A\u975C\u975D\u975F\u9763\u9764\u9766\u9767\u9768\u976A", 7],
    ["ec80", "\u9772\u9775\u9777", 4, "\u977D", 7, "\u9786", 4, "\u978C\u978E\u978F\u9790\u9793\u9795\u9796\u9797\u9799", 4, "\u81C1\u81A6\u6B24\u6B37\u6B39\u6B43\u6B46\u6B59\u98D1\u98D2\u98D3\u98D5\u98D9\u98DA\u6BB3\u5F40\u6BC2\u89F3\u6590\u9F51\u6593\u65BC\u65C6\u65C4\u65C3\u65CC\u65CE\u65D2\u65D6\u7080\u709C\u7096\u709D\u70BB\u70C0\u70B7\u70AB\u70B1\u70E8\u70CA\u7110\u7113\u7116\u712F\u7131\u7173\u715C\u7168\u7145\u7172\u714A\u7178\u717A\u7198\u71B3\u71B5\u71A8\u71A0\u71E0\u71D4\u71E7\u71F9\u721D\u7228\u706C\u7118\u7166\u71B9\u623E\u623D\u6243\u6248\u6249\u793B\u7940\u7946\u7949\u795B\u795C\u7953\u795A\u7962\u7957\u7960\u796F\u7967\u797A\u7985\u798A\u799A\u79A7\u79B3\u5FD1\u5FD0"],
    ["ed40", "\u979E\u979F\u97A1\u97A2\u97A4", 6, "\u97AC\u97AE\u97B0\u97B1\u97B3\u97B5", 46],
    ["ed80", "\u97E4\u97E5\u97E8\u97EE", 4, "\u97F4\u97F7", 23, "\u603C\u605D\u605A\u6067\u6041\u6059\u6063\u60AB\u6106\u610D\u615D\u61A9\u619D\u61CB\u61D1\u6206\u8080\u807F\u6C93\u6CF6\u6DFC\u77F6\u77F8\u7800\u7809\u7817\u7818\u7811\u65AB\u782D\u781C\u781D\u7839\u783A\u783B\u781F\u783C\u7825\u782C\u7823\u7829\u784E\u786D\u7856\u7857\u7826\u7850\u7847\u784C\u786A\u789B\u7893\u789A\u7887\u789C\u78A1\u78A3\u78B2\u78B9\u78A5\u78D4\u78D9\u78C9\u78EC\u78F2\u7905\u78F4\u7913\u7924\u791E\u7934\u9F9B\u9EF9\u9EFB\u9EFC\u76F1\u7704\u770D\u76F9\u7707\u7708\u771A\u7722\u7719\u772D\u7726\u7735\u7738\u7750\u7751\u7747\u7743\u775A\u7768"],
    ["ee40", "\u980F", 62],
    ["ee80", "\u984E", 32, "\u7762\u7765\u777F\u778D\u777D\u7780\u778C\u7791\u779F\u77A0\u77B0\u77B5\u77BD\u753A\u7540\u754E\u754B\u7548\u755B\u7572\u7579\u7583\u7F58\u7F61\u7F5F\u8A48\u7F68\u7F74\u7F71\u7F79\u7F81\u7F7E\u76CD\u76E5\u8832\u9485\u9486\u9487\u948B\u948A\u948C\u948D\u948F\u9490\u9494\u9497\u9495\u949A\u949B\u949C\u94A3\u94A4\u94AB\u94AA\u94AD\u94AC\u94AF\u94B0\u94B2\u94B4\u94B6", 4, "\u94BC\u94BD\u94BF\u94C4\u94C8", 6, "\u94D0\u94D1\u94D2\u94D5\u94D6\u94D7\u94D9\u94D8\u94DB\u94DE\u94DF\u94E0\u94E2\u94E4\u94E5\u94E7\u94E8\u94EA"],
    ["ef40", "\u986F", 5, "\u988B\u988E\u9892\u9895\u9899\u98A3\u98A8", 37, "\u98CF\u98D0\u98D4\u98D6\u98D7\u98DB\u98DC\u98DD\u98E0", 4],
    ["ef80", "\u98E5\u98E6\u98E9", 30, "\u94E9\u94EB\u94EE\u94EF\u94F3\u94F4\u94F5\u94F7\u94F9\u94FC\u94FD\u94FF\u9503\u9502\u9506\u9507\u9509\u950A\u950D\u950E\u950F\u9512", 4, "\u9518\u951B\u951D\u951E\u951F\u9522\u952A\u952B\u9529\u952C\u9531\u9532\u9534\u9536\u9537\u9538\u953C\u953E\u953F\u9542\u9535\u9544\u9545\u9546\u9549\u954C\u954E\u954F\u9552\u9553\u9554\u9556\u9557\u9558\u9559\u955B\u955E\u955F\u955D\u9561\u9562\u9564", 8, "\u956F\u9571\u9572\u9573\u953A\u77E7\u77EC\u96C9\u79D5\u79ED\u79E3\u79EB\u7A06\u5D47\u7A03\u7A02\u7A1E\u7A14"],
    ["f040", "\u9908", 4, "\u990E\u990F\u9911", 28, "\u992F", 26],
    ["f080", "\u994A", 9, "\u9956", 12, "\u9964\u9966\u9973\u9978\u9979\u997B\u997E\u9982\u9983\u9989\u7A39\u7A37\u7A51\u9ECF\u99A5\u7A70\u7688\u768E\u7693\u7699\u76A4\u74DE\u74E0\u752C\u9E20\u9E22\u9E28", 4, "\u9E32\u9E31\u9E36\u9E38\u9E37\u9E39\u9E3A\u9E3E\u9E41\u9E42\u9E44\u9E46\u9E47\u9E48\u9E49\u9E4B\u9E4C\u9E4E\u9E51\u9E55\u9E57\u9E5A\u9E5B\u9E5C\u9E5E\u9E63\u9E66", 6, "\u9E71\u9E6D\u9E73\u7592\u7594\u7596\u75A0\u759D\u75AC\u75A3\u75B3\u75B4\u75B8\u75C4\u75B1\u75B0\u75C3\u75C2\u75D6\u75CD\u75E3\u75E8\u75E6\u75E4\u75EB\u75E7\u7603\u75F1\u75FC\u75FF\u7610\u7600\u7605\u760C\u7617\u760A\u7625\u7618\u7615\u7619"],
    ["f140", "\u998C\u998E\u999A", 10, "\u99A6\u99A7\u99A9", 47],
    ["f180", "\u99D9", 32, "\u761B\u763C\u7622\u7620\u7640\u762D\u7630\u763F\u7635\u7643\u763E\u7633\u764D\u765E\u7654\u765C\u7656\u766B\u766F\u7FCA\u7AE6\u7A78\u7A79\u7A80\u7A86\u7A88\u7A95\u7AA6\u7AA0\u7AAC\u7AA8\u7AAD\u7AB3\u8864\u8869\u8872\u887D\u887F\u8882\u88A2\u88C6\u88B7\u88BC\u88C9\u88E2\u88CE\u88E3\u88E5\u88F1\u891A\u88FC\u88E8\u88FE\u88F0\u8921\u8919\u8913\u891B\u890A\u8934\u892B\u8936\u8941\u8966\u897B\u758B\u80E5\u76B2\u76B4\u77DC\u8012\u8014\u8016\u801C\u8020\u8022\u8025\u8026\u8027\u8029\u8028\u8031\u800B\u8035\u8043\u8046\u804D\u8052\u8069\u8071\u8983\u9878\u9880\u9883"],
    ["f240", "\u99FA", 62],
    ["f280", "\u9A39", 32, "\u9889\u988C\u988D\u988F\u9894\u989A\u989B\u989E\u989F\u98A1\u98A2\u98A5\u98A6\u864D\u8654\u866C\u866E\u867F\u867A\u867C\u867B\u86A8\u868D\u868B\u86AC\u869D\u86A7\u86A3\u86AA\u8693\u86A9\u86B6\u86C4\u86B5\u86CE\u86B0\u86BA\u86B1\u86AF\u86C9\u86CF\u86B4\u86E9\u86F1\u86F2\u86ED\u86F3\u86D0\u8713\u86DE\u86F4\u86DF\u86D8\u86D1\u8703\u8707\u86F8\u8708\u870A\u870D\u8709\u8723\u873B\u871E\u8725\u872E\u871A\u873E\u8748\u8734\u8731\u8729\u8737\u873F\u8782\u8722\u877D\u877E\u877B\u8760\u8770\u874C\u876E\u878B\u8753\u8763\u877C\u8764\u8759\u8765\u8793\u87AF\u87A8\u87D2"],
    ["f340", "\u9A5A", 17, "\u9A72\u9A83\u9A89\u9A8D\u9A8E\u9A94\u9A95\u9A99\u9AA6\u9AA9", 6, "\u9AB2\u9AB3\u9AB4\u9AB5\u9AB9\u9ABB\u9ABD\u9ABE\u9ABF\u9AC3\u9AC4\u9AC6", 4, "\u9ACD\u9ACE\u9ACF\u9AD0\u9AD2\u9AD4\u9AD5\u9AD6\u9AD7\u9AD9\u9ADA\u9ADB\u9ADC"],
    ["f380", "\u9ADD\u9ADE\u9AE0\u9AE2\u9AE3\u9AE4\u9AE5\u9AE7\u9AE8\u9AE9\u9AEA\u9AEC\u9AEE\u9AF0", 8, "\u9AFA\u9AFC", 6, "\u9B04\u9B05\u9B06\u87C6\u8788\u8785\u87AD\u8797\u8783\u87AB\u87E5\u87AC\u87B5\u87B3\u87CB\u87D3\u87BD\u87D1\u87C0\u87CA\u87DB\u87EA\u87E0\u87EE\u8816\u8813\u87FE\u880A\u881B\u8821\u8839\u883C\u7F36\u7F42\u7F44\u7F45\u8210\u7AFA\u7AFD\u7B08\u7B03\u7B04\u7B15\u7B0A\u7B2B\u7B0F\u7B47\u7B38\u7B2A\u7B19\u7B2E\u7B31\u7B20\u7B25\u7B24\u7B33\u7B3E\u7B1E\u7B58\u7B5A\u7B45\u7B75\u7B4C\u7B5D\u7B60\u7B6E\u7B7B\u7B62\u7B72\u7B71\u7B90\u7BA6\u7BA7\u7BB8\u7BAC\u7B9D\u7BA8\u7B85\u7BAA\u7B9C\u7BA2\u7BAB\u7BB4\u7BD1\u7BC1\u7BCC\u7BDD\u7BDA\u7BE5\u7BE6\u7BEA\u7C0C\u7BFE\u7BFC\u7C0F\u7C16\u7C0B"],
    ["f440", "\u9B07\u9B09", 5, "\u9B10\u9B11\u9B12\u9B14", 10, "\u9B20\u9B21\u9B22\u9B24", 10, "\u9B30\u9B31\u9B33", 7, "\u9B3D\u9B3E\u9B3F\u9B40\u9B46\u9B4A\u9B4B\u9B4C\u9B4E\u9B50\u9B52\u9B53\u9B55", 5],
    ["f480", "\u9B5B", 32, "\u7C1F\u7C2A\u7C26\u7C38\u7C41\u7C40\u81FE\u8201\u8202\u8204\u81EC\u8844\u8221\u8222\u8223\u822D\u822F\u8228\u822B\u8238\u823B\u8233\u8234\u823E\u8244\u8249\u824B\u824F\u825A\u825F\u8268\u887E\u8885\u8888\u88D8\u88DF\u895E\u7F9D\u7F9F\u7FA7\u7FAF\u7FB0\u7FB2\u7C7C\u6549\u7C91\u7C9D\u7C9C\u7C9E\u7CA2\u7CB2\u7CBC\u7CBD\u7CC1\u7CC7\u7CCC\u7CCD\u7CC8\u7CC5\u7CD7\u7CE8\u826E\u66A8\u7FBF\u7FCE\u7FD5\u7FE5\u7FE1\u7FE6\u7FE9\u7FEE\u7FF3\u7CF8\u7D77\u7DA6\u7DAE\u7E47\u7E9B\u9EB8\u9EB4\u8D73\u8D84\u8D94\u8D91\u8DB1\u8D67\u8D6D\u8C47\u8C49\u914A\u9150\u914E\u914F\u9164"],
    ["f540", "\u9B7C", 62],
    ["f580", "\u9BBB", 32, "\u9162\u9161\u9170\u9169\u916F\u917D\u917E\u9172\u9174\u9179\u918C\u9185\u9190\u918D\u9191\u91A2\u91A3\u91AA\u91AD\u91AE\u91AF\u91B5\u91B4\u91BA\u8C55\u9E7E\u8DB8\u8DEB\u8E05\u8E59\u8E69\u8DB5\u8DBF\u8DBC\u8DBA\u8DC4\u8DD6\u8DD7\u8DDA\u8DDE\u8DCE\u8DCF\u8DDB\u8DC6\u8DEC\u8DF7\u8DF8\u8DE3\u8DF9\u8DFB\u8DE4\u8E09\u8DFD\u8E14\u8E1D\u8E1F\u8E2C\u8E2E\u8E23\u8E2F\u8E3A\u8E40\u8E39\u8E35\u8E3D\u8E31\u8E49\u8E41\u8E42\u8E51\u8E52\u8E4A\u8E70\u8E76\u8E7C\u8E6F\u8E74\u8E85\u8E8F\u8E94\u8E90\u8E9C\u8E9E\u8C78\u8C82\u8C8A\u8C85\u8C98\u8C94\u659B\u89D6\u89DE\u89DA\u89DC"],
    ["f640", "\u9BDC", 62],
    ["f680", "\u9C1B", 32, "\u89E5\u89EB\u89EF\u8A3E\u8B26\u9753\u96E9\u96F3\u96EF\u9706\u9701\u9708\u970F\u970E\u972A\u972D\u9730\u973E\u9F80\u9F83\u9F85", 5, "\u9F8C\u9EFE\u9F0B\u9F0D\u96B9\u96BC\u96BD\u96CE\u96D2\u77BF\u96E0\u928E\u92AE\u92C8\u933E\u936A\u93CA\u938F\u943E\u946B\u9C7F\u9C82\u9C85\u9C86\u9C87\u9C88\u7A23\u9C8B\u9C8E\u9C90\u9C91\u9C92\u9C94\u9C95\u9C9A\u9C9B\u9C9E", 5, "\u9CA5", 4, "\u9CAB\u9CAD\u9CAE\u9CB0", 7, "\u9CBA\u9CBB\u9CBC\u9CBD\u9CC4\u9CC5\u9CC6\u9CC7\u9CCA\u9CCB"],
    ["f740", "\u9C3C", 62],
    ["f780", "\u9C7B\u9C7D\u9C7E\u9C80\u9C83\u9C84\u9C89\u9C8A\u9C8C\u9C8F\u9C93\u9C96\u9C97\u9C98\u9C99\u9C9D\u9CAA\u9CAC\u9CAF\u9CB9\u9CBE", 4, "\u9CC8\u9CC9\u9CD1\u9CD2\u9CDA\u9CDB\u9CE0\u9CE1\u9CCC", 4, "\u9CD3\u9CD4\u9CD5\u9CD7\u9CD8\u9CD9\u9CDC\u9CDD\u9CDF\u9CE2\u977C\u9785\u9791\u9792\u9794\u97AF\u97AB\u97A3\u97B2\u97B4\u9AB1\u9AB0\u9AB7\u9E58\u9AB6\u9ABA\u9ABC\u9AC1\u9AC0\u9AC5\u9AC2\u9ACB\u9ACC\u9AD1\u9B45\u9B43\u9B47\u9B49\u9B48\u9B4D\u9B51\u98E8\u990D\u992E\u9955\u9954\u9ADF\u9AE1\u9AE6\u9AEF\u9AEB\u9AFB\u9AED\u9AF9\u9B08\u9B0F\u9B13\u9B1F\u9B23\u9EBD\u9EBE\u7E3B\u9E82\u9E87\u9E88\u9E8B\u9E92\u93D6\u9E9D\u9E9F\u9EDB\u9EDC\u9EDD\u9EE0\u9EDF\u9EE2\u9EE9\u9EE7\u9EE5\u9EEA\u9EEF\u9F22\u9F2C\u9F2F\u9F39\u9F37\u9F3D\u9F3E\u9F44"],
    ["f840", "\u9CE3", 62],
    ["f880", "\u9D22", 32],
    ["f940", "\u9D43", 62],
    ["f980", "\u9D82", 32],
    ["fa40", "\u9DA3", 62],
    ["fa80", "\u9DE2", 32],
    ["fb40", "\u9E03", 27, "\u9E24\u9E27\u9E2E\u9E30\u9E34\u9E3B\u9E3C\u9E40\u9E4D\u9E50\u9E52\u9E53\u9E54\u9E56\u9E59\u9E5D\u9E5F\u9E60\u9E61\u9E62\u9E65\u9E6E\u9E6F\u9E72\u9E74", 9, "\u9E80"],
    ["fb80", "\u9E81\u9E83\u9E84\u9E85\u9E86\u9E89\u9E8A\u9E8C", 5, "\u9E94", 8, "\u9E9E\u9EA0", 5, "\u9EA7\u9EA8\u9EA9\u9EAA"],
    ["fc40", "\u9EAB", 8, "\u9EB5\u9EB6\u9EB7\u9EB9\u9EBA\u9EBC\u9EBF", 4, "\u9EC5\u9EC6\u9EC7\u9EC8\u9ECA\u9ECB\u9ECC\u9ED0\u9ED2\u9ED3\u9ED5\u9ED6\u9ED7\u9ED9\u9EDA\u9EDE\u9EE1\u9EE3\u9EE4\u9EE6\u9EE8\u9EEB\u9EEC\u9EED\u9EEE\u9EF0", 8, "\u9EFA\u9EFD\u9EFF", 6],
    ["fc80", "\u9F06", 4, "\u9F0C\u9F0F\u9F11\u9F12\u9F14\u9F15\u9F16\u9F18\u9F1A", 5, "\u9F21\u9F23", 8, "\u9F2D\u9F2E\u9F30\u9F31"],
    ["fd40", "\u9F32", 4, "\u9F38\u9F3A\u9F3C\u9F3F", 4, "\u9F45", 10, "\u9F52", 38],
    ["fd80", "\u9F79", 5, "\u9F81\u9F82\u9F8D", 11, "\u9F9C\u9F9D\u9F9E\u9FA1", 4, "\uF92C\uF979\uF995\uF9E7\uF9F1"],
    ["fe40", "\uFA0C\uFA0D\uFA0E\uFA0F\uFA11\uFA13\uFA14\uFA18\uFA1F\uFA20\uFA21\uFA23\uFA24\uFA27\uFA28\uFA29"]
  ];
});

// ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/gbk-added.json
var require_gbk_added = __commonJS((exports2, module2) => {
  module2.exports = [
    ["a140", "\uE4C6", 62],
    ["a180", "\uE505", 32],
    ["a240", "\uE526", 62],
    ["a280", "\uE565", 32],
    ["a2ab", "\uE766", 5],
    ["a2e3", "\u20AC\uE76D"],
    ["a2ef", "\uE76E\uE76F"],
    ["a2fd", "\uE770\uE771"],
    ["a340", "\uE586", 62],
    ["a380", "\uE5C5", 31, "\u3000"],
    ["a440", "\uE5E6", 62],
    ["a480", "\uE625", 32],
    ["a4f4", "\uE772", 10],
    ["a540", "\uE646", 62],
    ["a580", "\uE685", 32],
    ["a5f7", "\uE77D", 7],
    ["a640", "\uE6A6", 62],
    ["a680", "\uE6E5", 32],
    ["a6b9", "\uE785", 7],
    ["a6d9", "\uE78D", 6],
    ["a6ec", "\uE794\uE795"],
    ["a6f3", "\uE796"],
    ["a6f6", "\uE797", 8],
    ["a740", "\uE706", 62],
    ["a780", "\uE745", 32],
    ["a7c2", "\uE7A0", 14],
    ["a7f2", "\uE7AF", 12],
    ["a896", "\uE7BC", 10],
    ["a8bc", "\uE7C7"],
    ["a8bf", "\u01F9"],
    ["a8c1", "\uE7C9\uE7CA\uE7CB\uE7CC"],
    ["a8ea", "\uE7CD", 20],
    ["a958", "\uE7E2"],
    ["a95b", "\uE7E3"],
    ["a95d", "\uE7E4\uE7E5\uE7E6"],
    ["a989", "\u303E\u2FF0", 11],
    ["a997", "\uE7F4", 12],
    ["a9f0", "\uE801", 14],
    ["aaa1", "\uE000", 93],
    ["aba1", "\uE05E", 93],
    ["aca1", "\uE0BC", 93],
    ["ada1", "\uE11A", 93],
    ["aea1", "\uE178", 93],
    ["afa1", "\uE1D6", 93],
    ["d7fa", "\uE810", 4],
    ["f8a1", "\uE234", 93],
    ["f9a1", "\uE292", 93],
    ["faa1", "\uE2F0", 93],
    ["fba1", "\uE34E", 93],
    ["fca1", "\uE3AC", 93],
    ["fda1", "\uE40A", 93],
    ["fe50", "\u2E81\uE816\uE817\uE818\u2E84\u3473\u3447\u2E88\u2E8B\uE81E\u359E\u361A\u360E\u2E8C\u2E97\u396E\u3918\uE826\u39CF\u39DF\u3A73\u39D0\uE82B\uE82C\u3B4E\u3C6E\u3CE0\u2EA7\uE831\uE832\u2EAA\u4056\u415F\u2EAE\u4337\u2EB3\u2EB6\u2EB7\uE83B\u43B1\u43AC\u2EBB\u43DD\u44D6\u4661\u464C\uE843"],
    ["fe80", "\u4723\u4729\u477C\u478D\u2ECA\u4947\u497A\u497D\u4982\u4983\u4985\u4986\u499F\u499B\u49B7\u49B6\uE854\uE855\u4CA3\u4C9F\u4CA0\u4CA1\u4C77\u4CA2\u4D13", 6, "\u4DAE\uE864\uE468", 93]
  ];
});

// ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/gb18030-ranges.json
var require_gb18030_ranges = __commonJS((exports2, module2) => {
  module2.exports = {uChars: [128, 165, 169, 178, 184, 216, 226, 235, 238, 244, 248, 251, 253, 258, 276, 284, 300, 325, 329, 334, 364, 463, 465, 467, 469, 471, 473, 475, 477, 506, 594, 610, 712, 716, 730, 930, 938, 962, 970, 1026, 1104, 1106, 8209, 8215, 8218, 8222, 8231, 8241, 8244, 8246, 8252, 8365, 8452, 8454, 8458, 8471, 8482, 8556, 8570, 8596, 8602, 8713, 8720, 8722, 8726, 8731, 8737, 8740, 8742, 8748, 8751, 8760, 8766, 8777, 8781, 8787, 8802, 8808, 8816, 8854, 8858, 8870, 8896, 8979, 9322, 9372, 9548, 9588, 9616, 9622, 9634, 9652, 9662, 9672, 9676, 9680, 9702, 9735, 9738, 9793, 9795, 11906, 11909, 11913, 11917, 11928, 11944, 11947, 11951, 11956, 11960, 11964, 11979, 12284, 12292, 12312, 12319, 12330, 12351, 12436, 12447, 12535, 12543, 12586, 12842, 12850, 12964, 13200, 13215, 13218, 13253, 13263, 13267, 13270, 13384, 13428, 13727, 13839, 13851, 14617, 14703, 14801, 14816, 14964, 15183, 15471, 15585, 16471, 16736, 17208, 17325, 17330, 17374, 17623, 17997, 18018, 18212, 18218, 18301, 18318, 18760, 18811, 18814, 18820, 18823, 18844, 18848, 18872, 19576, 19620, 19738, 19887, 40870, 59244, 59336, 59367, 59413, 59417, 59423, 59431, 59437, 59443, 59452, 59460, 59478, 59493, 63789, 63866, 63894, 63976, 63986, 64016, 64018, 64021, 64025, 64034, 64037, 64042, 65074, 65093, 65107, 65112, 65127, 65132, 65375, 65510, 65536], gbChars: [0, 36, 38, 45, 50, 81, 89, 95, 96, 100, 103, 104, 105, 109, 126, 133, 148, 172, 175, 179, 208, 306, 307, 308, 309, 310, 311, 312, 313, 341, 428, 443, 544, 545, 558, 741, 742, 749, 750, 805, 819, 820, 7922, 7924, 7925, 7927, 7934, 7943, 7944, 7945, 7950, 8062, 8148, 8149, 8152, 8164, 8174, 8236, 8240, 8262, 8264, 8374, 8380, 8381, 8384, 8388, 8390, 8392, 8393, 8394, 8396, 8401, 8406, 8416, 8419, 8424, 8437, 8439, 8445, 8482, 8485, 8496, 8521, 8603, 8936, 8946, 9046, 9050, 9063, 9066, 9076, 9092, 9100, 9108, 9111, 9113, 9131, 9162, 9164, 9218, 9219, 11329, 11331, 11334, 11336, 11346, 11361, 11363, 11366, 11370, 11372, 11375, 11389, 11682, 11686, 11687, 11692, 11694, 11714, 11716, 11723, 11725, 11730, 11736, 11982, 11989, 12102, 12336, 12348, 12350, 12384, 12393, 12395, 12397, 12510, 12553, 12851, 12962, 12973, 13738, 13823, 13919, 13933, 14080, 14298, 14585, 14698, 15583, 15847, 16318, 16434, 16438, 16481, 16729, 17102, 17122, 17315, 17320, 17402, 17418, 17859, 17909, 17911, 17915, 17916, 17936, 17939, 17961, 18664, 18703, 18814, 18962, 19043, 33469, 33470, 33471, 33484, 33485, 33490, 33497, 33501, 33505, 33513, 33520, 33536, 33550, 37845, 37921, 37948, 38029, 38038, 38064, 38065, 38066, 38069, 38075, 38076, 38078, 39108, 39109, 39113, 39114, 39115, 39116, 39265, 39394, 189e3]};
});

// ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/cp949.json
var require_cp949 = __commonJS((exports2, module2) => {
  module2.exports = [
    ["0", "\0", 127],
    ["8141", "\uAC02\uAC03\uAC05\uAC06\uAC0B", 4, "\uAC18\uAC1E\uAC1F\uAC21\uAC22\uAC23\uAC25", 6, "\uAC2E\uAC32\uAC33\uAC34"],
    ["8161", "\uAC35\uAC36\uAC37\uAC3A\uAC3B\uAC3D\uAC3E\uAC3F\uAC41", 9, "\uAC4C\uAC4E", 5, "\uAC55"],
    ["8181", "\uAC56\uAC57\uAC59\uAC5A\uAC5B\uAC5D", 18, "\uAC72\uAC73\uAC75\uAC76\uAC79\uAC7B", 4, "\uAC82\uAC87\uAC88\uAC8D\uAC8E\uAC8F\uAC91\uAC92\uAC93\uAC95", 6, "\uAC9E\uACA2", 5, "\uACAB\uACAD\uACAE\uACB1", 6, "\uACBA\uACBE\uACBF\uACC0\uACC2\uACC3\uACC5\uACC6\uACC7\uACC9\uACCA\uACCB\uACCD", 7, "\uACD6\uACD8", 7, "\uACE2\uACE3\uACE5\uACE6\uACE9\uACEB\uACED\uACEE\uACF2\uACF4\uACF7", 4, "\uACFE\uACFF\uAD01\uAD02\uAD03\uAD05\uAD07", 4, "\uAD0E\uAD10\uAD12\uAD13"],
    ["8241", "\uAD14\uAD15\uAD16\uAD17\uAD19\uAD1A\uAD1B\uAD1D\uAD1E\uAD1F\uAD21", 7, "\uAD2A\uAD2B\uAD2E", 5],
    ["8261", "\uAD36\uAD37\uAD39\uAD3A\uAD3B\uAD3D", 6, "\uAD46\uAD48\uAD4A", 5, "\uAD51\uAD52\uAD53\uAD55\uAD56\uAD57"],
    ["8281", "\uAD59", 7, "\uAD62\uAD64", 7, "\uAD6E\uAD6F\uAD71\uAD72\uAD77\uAD78\uAD79\uAD7A\uAD7E\uAD80\uAD83", 4, "\uAD8A\uAD8B\uAD8D\uAD8E\uAD8F\uAD91", 10, "\uAD9E", 5, "\uADA5", 17, "\uADB8", 7, "\uADC2\uADC3\uADC5\uADC6\uADC7\uADC9", 6, "\uADD2\uADD4", 7, "\uADDD\uADDE\uADDF\uADE1\uADE2\uADE3\uADE5", 18],
    ["8341", "\uADFA\uADFB\uADFD\uADFE\uAE02", 5, "\uAE0A\uAE0C\uAE0E", 5, "\uAE15", 7],
    ["8361", "\uAE1D", 18, "\uAE32\uAE33\uAE35\uAE36\uAE39\uAE3B\uAE3C"],
    ["8381", "\uAE3D\uAE3E\uAE3F\uAE42\uAE44\uAE47\uAE48\uAE49\uAE4B\uAE4F\uAE51\uAE52\uAE53\uAE55\uAE57", 4, "\uAE5E\uAE62\uAE63\uAE64\uAE66\uAE67\uAE6A\uAE6B\uAE6D\uAE6E\uAE6F\uAE71", 6, "\uAE7A\uAE7E", 5, "\uAE86", 5, "\uAE8D", 46, "\uAEBF\uAEC1\uAEC2\uAEC3\uAEC5", 6, "\uAECE\uAED2", 5, "\uAEDA\uAEDB\uAEDD", 8],
    ["8441", "\uAEE6\uAEE7\uAEE9\uAEEA\uAEEC\uAEEE", 5, "\uAEF5\uAEF6\uAEF7\uAEF9\uAEFA\uAEFB\uAEFD", 8],
    ["8461", "\uAF06\uAF09\uAF0A\uAF0B\uAF0C\uAF0E\uAF0F\uAF11", 18],
    ["8481", "\uAF24", 7, "\uAF2E\uAF2F\uAF31\uAF33\uAF35", 6, "\uAF3E\uAF40\uAF44\uAF45\uAF46\uAF47\uAF4A", 5, "\uAF51", 10, "\uAF5E", 5, "\uAF66", 18, "\uAF7A", 5, "\uAF81\uAF82\uAF83\uAF85\uAF86\uAF87\uAF89", 6, "\uAF92\uAF93\uAF94\uAF96", 5, "\uAF9D", 26, "\uAFBA\uAFBB\uAFBD\uAFBE"],
    ["8541", "\uAFBF\uAFC1", 5, "\uAFCA\uAFCC\uAFCF", 4, "\uAFD5", 6, "\uAFDD", 4],
    ["8561", "\uAFE2", 5, "\uAFEA", 5, "\uAFF2\uAFF3\uAFF5\uAFF6\uAFF7\uAFF9", 6, "\uB002\uB003"],
    ["8581", "\uB005", 6, "\uB00D\uB00E\uB00F\uB011\uB012\uB013\uB015", 6, "\uB01E", 9, "\uB029", 26, "\uB046\uB047\uB049\uB04B\uB04D\uB04F\uB050\uB051\uB052\uB056\uB058\uB05A\uB05B\uB05C\uB05E", 29, "\uB07E\uB07F\uB081\uB082\uB083\uB085", 6, "\uB08E\uB090\uB092", 5, "\uB09B\uB09D\uB09E\uB0A3\uB0A4"],
    ["8641", "\uB0A5\uB0A6\uB0A7\uB0AA\uB0B0\uB0B2\uB0B6\uB0B7\uB0B9\uB0BA\uB0BB\uB0BD", 6, "\uB0C6\uB0CA", 5, "\uB0D2"],
    ["8661", "\uB0D3\uB0D5\uB0D6\uB0D7\uB0D9", 6, "\uB0E1\uB0E2\uB0E3\uB0E4\uB0E6", 10],
    ["8681", "\uB0F1", 22, "\uB10A\uB10D\uB10E\uB10F\uB111\uB114\uB115\uB116\uB117\uB11A\uB11E", 4, "\uB126\uB127\uB129\uB12A\uB12B\uB12D", 6, "\uB136\uB13A", 5, "\uB142\uB143\uB145\uB146\uB147\uB149", 6, "\uB152\uB153\uB156\uB157\uB159\uB15A\uB15B\uB15D\uB15E\uB15F\uB161", 22, "\uB17A\uB17B\uB17D\uB17E\uB17F\uB181\uB183", 4, "\uB18A\uB18C\uB18E\uB18F\uB190\uB191\uB195\uB196\uB197\uB199\uB19A\uB19B\uB19D"],
    ["8741", "\uB19E", 9, "\uB1A9", 15],
    ["8761", "\uB1B9", 18, "\uB1CD\uB1CE\uB1CF\uB1D1\uB1D2\uB1D3\uB1D5"],
    ["8781", "\uB1D6", 5, "\uB1DE\uB1E0", 7, "\uB1EA\uB1EB\uB1ED\uB1EE\uB1EF\uB1F1", 7, "\uB1FA\uB1FC\uB1FE", 5, "\uB206\uB207\uB209\uB20A\uB20D", 6, "\uB216\uB218\uB21A", 5, "\uB221", 18, "\uB235", 6, "\uB23D", 26, "\uB259\uB25A\uB25B\uB25D\uB25E\uB25F\uB261", 6, "\uB26A", 4],
    ["8841", "\uB26F", 4, "\uB276", 5, "\uB27D", 6, "\uB286\uB287\uB288\uB28A", 4],
    ["8861", "\uB28F\uB292\uB293\uB295\uB296\uB297\uB29B", 4, "\uB2A2\uB2A4\uB2A7\uB2A8\uB2A9\uB2AB\uB2AD\uB2AE\uB2AF\uB2B1\uB2B2\uB2B3\uB2B5\uB2B6\uB2B7"],
    ["8881", "\uB2B8", 15, "\uB2CA\uB2CB\uB2CD\uB2CE\uB2CF\uB2D1\uB2D3", 4, "\uB2DA\uB2DC\uB2DE\uB2DF\uB2E0\uB2E1\uB2E3\uB2E7\uB2E9\uB2EA\uB2F0\uB2F1\uB2F2\uB2F6\uB2FC\uB2FD\uB2FE\uB302\uB303\uB305\uB306\uB307\uB309", 6, "\uB312\uB316", 5, "\uB31D", 54, "\uB357\uB359\uB35A\uB35D\uB360\uB361\uB362\uB363"],
    ["8941", "\uB366\uB368\uB36A\uB36C\uB36D\uB36F\uB372\uB373\uB375\uB376\uB377\uB379", 6, "\uB382\uB386", 5, "\uB38D"],
    ["8961", "\uB38E\uB38F\uB391\uB392\uB393\uB395", 10, "\uB3A2", 5, "\uB3A9\uB3AA\uB3AB\uB3AD"],
    ["8981", "\uB3AE", 21, "\uB3C6\uB3C7\uB3C9\uB3CA\uB3CD\uB3CF\uB3D1\uB3D2\uB3D3\uB3D6\uB3D8\uB3DA\uB3DC\uB3DE\uB3DF\uB3E1\uB3E2\uB3E3\uB3E5\uB3E6\uB3E7\uB3E9", 18, "\uB3FD", 18, "\uB411", 6, "\uB419\uB41A\uB41B\uB41D\uB41E\uB41F\uB421", 6, "\uB42A\uB42C", 7, "\uB435", 15],
    ["8a41", "\uB445", 10, "\uB452\uB453\uB455\uB456\uB457\uB459", 6, "\uB462\uB464\uB466"],
    ["8a61", "\uB467", 4, "\uB46D", 18, "\uB481\uB482"],
    ["8a81", "\uB483", 4, "\uB489", 19, "\uB49E", 5, "\uB4A5\uB4A6\uB4A7\uB4A9\uB4AA\uB4AB\uB4AD", 7, "\uB4B6\uB4B8\uB4BA", 5, "\uB4C1\uB4C2\uB4C3\uB4C5\uB4C6\uB4C7\uB4C9", 6, "\uB4D1\uB4D2\uB4D3\uB4D4\uB4D6", 5, "\uB4DE\uB4DF\uB4E1\uB4E2\uB4E5\uB4E7", 4, "\uB4EE\uB4F0\uB4F2", 5, "\uB4F9", 26, "\uB516\uB517\uB519\uB51A\uB51D"],
    ["8b41", "\uB51E", 5, "\uB526\uB52B", 4, "\uB532\uB533\uB535\uB536\uB537\uB539", 6, "\uB542\uB546"],
    ["8b61", "\uB547\uB548\uB549\uB54A\uB54E\uB54F\uB551\uB552\uB553\uB555", 6, "\uB55E\uB562", 8],
    ["8b81", "\uB56B", 52, "\uB5A2\uB5A3\uB5A5\uB5A6\uB5A7\uB5A9\uB5AC\uB5AD\uB5AE\uB5AF\uB5B2\uB5B6", 4, "\uB5BE\uB5BF\uB5C1\uB5C2\uB5C3\uB5C5", 6, "\uB5CE\uB5D2", 5, "\uB5D9", 18, "\uB5ED", 18],
    ["8c41", "\uB600", 15, "\uB612\uB613\uB615\uB616\uB617\uB619", 4],
    ["8c61", "\uB61E", 6, "\uB626", 5, "\uB62D", 6, "\uB635", 5],
    ["8c81", "\uB63B", 12, "\uB649", 26, "\uB665\uB666\uB667\uB669", 50, "\uB69E\uB69F\uB6A1\uB6A2\uB6A3\uB6A5", 5, "\uB6AD\uB6AE\uB6AF\uB6B0\uB6B2", 16],
    ["8d41", "\uB6C3", 16, "\uB6D5", 8],
    ["8d61", "\uB6DE", 17, "\uB6F1\uB6F2\uB6F3\uB6F5\uB6F6\uB6F7\uB6F9\uB6FA"],
    ["8d81", "\uB6FB", 4, "\uB702\uB703\uB704\uB706", 33, "\uB72A\uB72B\uB72D\uB72E\uB731", 6, "\uB73A\uB73C", 7, "\uB745\uB746\uB747\uB749\uB74A\uB74B\uB74D", 6, "\uB756", 9, "\uB761\uB762\uB763\uB765\uB766\uB767\uB769", 6, "\uB772\uB774\uB776", 5, "\uB77E\uB77F\uB781\uB782\uB783\uB785", 6, "\uB78E\uB793\uB794\uB795\uB79A\uB79B\uB79D\uB79E"],
    ["8e41", "\uB79F\uB7A1", 6, "\uB7AA\uB7AE", 5, "\uB7B6\uB7B7\uB7B9", 8],
    ["8e61", "\uB7C2", 4, "\uB7C8\uB7CA", 19],
    ["8e81", "\uB7DE", 13, "\uB7EE\uB7EF\uB7F1\uB7F2\uB7F3\uB7F5", 6, "\uB7FE\uB802", 4, "\uB80A\uB80B\uB80D\uB80E\uB80F\uB811", 6, "\uB81A\uB81C\uB81E", 5, "\uB826\uB827\uB829\uB82A\uB82B\uB82D", 6, "\uB836\uB83A", 5, "\uB841\uB842\uB843\uB845", 11, "\uB852\uB854", 7, "\uB85E\uB85F\uB861\uB862\uB863\uB865", 6, "\uB86E\uB870\uB872", 5, "\uB879\uB87A\uB87B\uB87D", 7],
    ["8f41", "\uB885", 7, "\uB88E", 17],
    ["8f61", "\uB8A0", 7, "\uB8A9", 6, "\uB8B1\uB8B2\uB8B3\uB8B5\uB8B6\uB8B7\uB8B9", 4],
    ["8f81", "\uB8BE\uB8BF\uB8C2\uB8C4\uB8C6", 5, "\uB8CD\uB8CE\uB8CF\uB8D1\uB8D2\uB8D3\uB8D5", 7, "\uB8DE\uB8E0\uB8E2", 5, "\uB8EA\uB8EB\uB8ED\uB8EE\uB8EF\uB8F1", 6, "\uB8FA\uB8FC\uB8FE", 5, "\uB905", 18, "\uB919", 6, "\uB921", 26, "\uB93E\uB93F\uB941\uB942\uB943\uB945", 6, "\uB94D\uB94E\uB950\uB952", 5],
    ["9041", "\uB95A\uB95B\uB95D\uB95E\uB95F\uB961", 6, "\uB96A\uB96C\uB96E", 5, "\uB976\uB977\uB979\uB97A\uB97B\uB97D"],
    ["9061", "\uB97E", 5, "\uB986\uB988\uB98B\uB98C\uB98F", 15],
    ["9081", "\uB99F", 12, "\uB9AE\uB9AF\uB9B1\uB9B2\uB9B3\uB9B5", 6, "\uB9BE\uB9C0\uB9C2", 5, "\uB9CA\uB9CB\uB9CD\uB9D3", 4, "\uB9DA\uB9DC\uB9DF\uB9E0\uB9E2\uB9E6\uB9E7\uB9E9\uB9EA\uB9EB\uB9ED", 6, "\uB9F6\uB9FB", 4, "\uBA02", 5, "\uBA09", 11, "\uBA16", 33, "\uBA3A\uBA3B\uBA3D\uBA3E\uBA3F\uBA41\uBA43\uBA44\uBA45\uBA46"],
    ["9141", "\uBA47\uBA4A\uBA4C\uBA4F\uBA50\uBA51\uBA52\uBA56\uBA57\uBA59\uBA5A\uBA5B\uBA5D", 6, "\uBA66\uBA6A", 5],
    ["9161", "\uBA72\uBA73\uBA75\uBA76\uBA77\uBA79", 9, "\uBA86\uBA88\uBA89\uBA8A\uBA8B\uBA8D", 5],
    ["9181", "\uBA93", 20, "\uBAAA\uBAAD\uBAAE\uBAAF\uBAB1\uBAB3", 4, "\uBABA\uBABC\uBABE", 5, "\uBAC5\uBAC6\uBAC7\uBAC9", 14, "\uBADA", 33, "\uBAFD\uBAFE\uBAFF\uBB01\uBB02\uBB03\uBB05", 7, "\uBB0E\uBB10\uBB12", 5, "\uBB19\uBB1A\uBB1B\uBB1D\uBB1E\uBB1F\uBB21", 6],
    ["9241", "\uBB28\uBB2A\uBB2C", 7, "\uBB37\uBB39\uBB3A\uBB3F", 4, "\uBB46\uBB48\uBB4A\uBB4B\uBB4C\uBB4E\uBB51\uBB52"],
    ["9261", "\uBB53\uBB55\uBB56\uBB57\uBB59", 7, "\uBB62\uBB64", 7, "\uBB6D", 4],
    ["9281", "\uBB72", 21, "\uBB89\uBB8A\uBB8B\uBB8D\uBB8E\uBB8F\uBB91", 18, "\uBBA5\uBBA6\uBBA7\uBBA9\uBBAA\uBBAB\uBBAD", 6, "\uBBB5\uBBB6\uBBB8", 7, "\uBBC1\uBBC2\uBBC3\uBBC5\uBBC6\uBBC7\uBBC9", 6, "\uBBD1\uBBD2\uBBD4", 35, "\uBBFA\uBBFB\uBBFD\uBBFE\uBC01"],
    ["9341", "\uBC03", 4, "\uBC0A\uBC0E\uBC10\uBC12\uBC13\uBC19\uBC1A\uBC20\uBC21\uBC22\uBC23\uBC26\uBC28\uBC2A\uBC2B\uBC2C\uBC2E\uBC2F\uBC32\uBC33\uBC35"],
    ["9361", "\uBC36\uBC37\uBC39", 6, "\uBC42\uBC46\uBC47\uBC48\uBC4A\uBC4B\uBC4E\uBC4F\uBC51", 8],
    ["9381", "\uBC5A\uBC5B\uBC5C\uBC5E", 37, "\uBC86\uBC87\uBC89\uBC8A\uBC8D\uBC8F", 4, "\uBC96\uBC98\uBC9B", 4, "\uBCA2\uBCA3\uBCA5\uBCA6\uBCA9", 6, "\uBCB2\uBCB6", 5, "\uBCBE\uBCBF\uBCC1\uBCC2\uBCC3\uBCC5", 7, "\uBCCE\uBCD2\uBCD3\uBCD4\uBCD6\uBCD7\uBCD9\uBCDA\uBCDB\uBCDD", 22, "\uBCF7\uBCF9\uBCFA\uBCFB\uBCFD"],
    ["9441", "\uBCFE", 5, "\uBD06\uBD08\uBD0A", 5, "\uBD11\uBD12\uBD13\uBD15", 8],
    ["9461", "\uBD1E", 5, "\uBD25", 6, "\uBD2D", 12],
    ["9481", "\uBD3A", 5, "\uBD41", 6, "\uBD4A\uBD4B\uBD4D\uBD4E\uBD4F\uBD51", 6, "\uBD5A", 9, "\uBD65\uBD66\uBD67\uBD69", 22, "\uBD82\uBD83\uBD85\uBD86\uBD8B", 4, "\uBD92\uBD94\uBD96\uBD97\uBD98\uBD9B\uBD9D", 6, "\uBDA5", 10, "\uBDB1", 6, "\uBDB9", 24],
    ["9541", "\uBDD2\uBDD3\uBDD6\uBDD7\uBDD9\uBDDA\uBDDB\uBDDD", 11, "\uBDEA", 5, "\uBDF1"],
    ["9561", "\uBDF2\uBDF3\uBDF5\uBDF6\uBDF7\uBDF9", 6, "\uBE01\uBE02\uBE04\uBE06", 5, "\uBE0E\uBE0F\uBE11\uBE12\uBE13"],
    ["9581", "\uBE15", 6, "\uBE1E\uBE20", 35, "\uBE46\uBE47\uBE49\uBE4A\uBE4B\uBE4D\uBE4F", 4, "\uBE56\uBE58\uBE5C\uBE5D\uBE5E\uBE5F\uBE62\uBE63\uBE65\uBE66\uBE67\uBE69\uBE6B", 4, "\uBE72\uBE76", 4, "\uBE7E\uBE7F\uBE81\uBE82\uBE83\uBE85", 6, "\uBE8E\uBE92", 5, "\uBE9A", 13, "\uBEA9", 14],
    ["9641", "\uBEB8", 23, "\uBED2\uBED3"],
    ["9661", "\uBED5\uBED6\uBED9", 6, "\uBEE1\uBEE2\uBEE6", 5, "\uBEED", 8],
    ["9681", "\uBEF6", 10, "\uBF02", 5, "\uBF0A", 13, "\uBF1A\uBF1E", 33, "\uBF42\uBF43\uBF45\uBF46\uBF47\uBF49", 6, "\uBF52\uBF53\uBF54\uBF56", 44],
    ["9741", "\uBF83", 16, "\uBF95", 8],
    ["9761", "\uBF9E", 17, "\uBFB1", 7],
    ["9781", "\uBFB9", 11, "\uBFC6", 5, "\uBFCE\uBFCF\uBFD1\uBFD2\uBFD3\uBFD5", 6, "\uBFDD\uBFDE\uBFE0\uBFE2", 89, "\uC03D\uC03E\uC03F"],
    ["9841", "\uC040", 16, "\uC052", 5, "\uC059\uC05A\uC05B"],
    ["9861", "\uC05D\uC05E\uC05F\uC061", 6, "\uC06A", 15],
    ["9881", "\uC07A", 21, "\uC092\uC093\uC095\uC096\uC097\uC099", 6, "\uC0A2\uC0A4\uC0A6", 5, "\uC0AE\uC0B1\uC0B2\uC0B7", 4, "\uC0BE\uC0C2\uC0C3\uC0C4\uC0C6\uC0C7\uC0CA\uC0CB\uC0CD\uC0CE\uC0CF\uC0D1", 6, "\uC0DA\uC0DE", 5, "\uC0E6\uC0E7\uC0E9\uC0EA\uC0EB\uC0ED", 6, "\uC0F6\uC0F8\uC0FA", 5, "\uC101\uC102\uC103\uC105\uC106\uC107\uC109", 6, "\uC111\uC112\uC113\uC114\uC116", 5, "\uC121\uC122\uC125\uC128\uC129\uC12A\uC12B\uC12E"],
    ["9941", "\uC132\uC133\uC134\uC135\uC137\uC13A\uC13B\uC13D\uC13E\uC13F\uC141", 6, "\uC14A\uC14E", 5, "\uC156\uC157"],
    ["9961", "\uC159\uC15A\uC15B\uC15D", 6, "\uC166\uC16A", 5, "\uC171\uC172\uC173\uC175\uC176\uC177\uC179\uC17A\uC17B"],
    ["9981", "\uC17C", 8, "\uC186", 5, "\uC18F\uC191\uC192\uC193\uC195\uC197", 4, "\uC19E\uC1A0\uC1A2\uC1A3\uC1A4\uC1A6\uC1A7\uC1AA\uC1AB\uC1AD\uC1AE\uC1AF\uC1B1", 11, "\uC1BE", 5, "\uC1C5\uC1C6\uC1C7\uC1C9\uC1CA\uC1CB\uC1CD", 6, "\uC1D5\uC1D6\uC1D9", 6, "\uC1E1\uC1E2\uC1E3\uC1E5\uC1E6\uC1E7\uC1E9", 6, "\uC1F2\uC1F4", 7, "\uC1FE\uC1FF\uC201\uC202\uC203\uC205", 6, "\uC20E\uC210\uC212", 5, "\uC21A\uC21B\uC21D\uC21E\uC221\uC222\uC223"],
    ["9a41", "\uC224\uC225\uC226\uC227\uC22A\uC22C\uC22E\uC230\uC233\uC235", 16],
    ["9a61", "\uC246\uC247\uC249", 6, "\uC252\uC253\uC255\uC256\uC257\uC259", 6, "\uC261\uC262\uC263\uC264\uC266"],
    ["9a81", "\uC267", 4, "\uC26E\uC26F\uC271\uC272\uC273\uC275", 6, "\uC27E\uC280\uC282", 5, "\uC28A", 5, "\uC291", 6, "\uC299\uC29A\uC29C\uC29E", 5, "\uC2A6\uC2A7\uC2A9\uC2AA\uC2AB\uC2AE", 5, "\uC2B6\uC2B8\uC2BA", 33, "\uC2DE\uC2DF\uC2E1\uC2E2\uC2E5", 5, "\uC2EE\uC2F0\uC2F2\uC2F3\uC2F4\uC2F5\uC2F7\uC2FA\uC2FD\uC2FE\uC2FF\uC301", 6, "\uC30A\uC30B\uC30E\uC30F"],
    ["9b41", "\uC310\uC311\uC312\uC316\uC317\uC319\uC31A\uC31B\uC31D", 6, "\uC326\uC327\uC32A", 8],
    ["9b61", "\uC333", 17, "\uC346", 7],
    ["9b81", "\uC34E", 25, "\uC36A\uC36B\uC36D\uC36E\uC36F\uC371\uC373", 4, "\uC37A\uC37B\uC37E", 5, "\uC385\uC386\uC387\uC389\uC38A\uC38B\uC38D", 50, "\uC3C1", 22, "\uC3DA"],
    ["9c41", "\uC3DB\uC3DD\uC3DE\uC3E1\uC3E3", 4, "\uC3EA\uC3EB\uC3EC\uC3EE", 5, "\uC3F6\uC3F7\uC3F9", 5],
    ["9c61", "\uC3FF", 8, "\uC409", 6, "\uC411", 9],
    ["9c81", "\uC41B", 8, "\uC425", 6, "\uC42D\uC42E\uC42F\uC431\uC432\uC433\uC435", 6, "\uC43E", 9, "\uC449", 26, "\uC466\uC467\uC469\uC46A\uC46B\uC46D", 6, "\uC476\uC477\uC478\uC47A", 5, "\uC481", 18, "\uC495", 6, "\uC49D", 12],
    ["9d41", "\uC4AA", 13, "\uC4B9\uC4BA\uC4BB\uC4BD", 8],
    ["9d61", "\uC4C6", 25],
    ["9d81", "\uC4E0", 8, "\uC4EA", 5, "\uC4F2\uC4F3\uC4F5\uC4F6\uC4F7\uC4F9\uC4FB\uC4FC\uC4FD\uC4FE\uC502", 9, "\uC50D\uC50E\uC50F\uC511\uC512\uC513\uC515", 6, "\uC51D", 10, "\uC52A\uC52B\uC52D\uC52E\uC52F\uC531", 6, "\uC53A\uC53C\uC53E", 5, "\uC546\uC547\uC54B\uC54F\uC550\uC551\uC552\uC556\uC55A\uC55B\uC55C\uC55F\uC562\uC563\uC565\uC566\uC567\uC569", 6, "\uC572\uC576", 5, "\uC57E\uC57F\uC581\uC582\uC583\uC585\uC586\uC588\uC589\uC58A\uC58B\uC58E\uC590\uC592\uC593\uC594"],
    ["9e41", "\uC596\uC599\uC59A\uC59B\uC59D\uC59E\uC59F\uC5A1", 7, "\uC5AA", 9, "\uC5B6"],
    ["9e61", "\uC5B7\uC5BA\uC5BF", 4, "\uC5CB\uC5CD\uC5CF\uC5D2\uC5D3\uC5D5\uC5D6\uC5D7\uC5D9", 6, "\uC5E2\uC5E4\uC5E6\uC5E7"],
    ["9e81", "\uC5E8\uC5E9\uC5EA\uC5EB\uC5EF\uC5F1\uC5F2\uC5F3\uC5F5\uC5F8\uC5F9\uC5FA\uC5FB\uC602\uC603\uC604\uC609\uC60A\uC60B\uC60D\uC60E\uC60F\uC611", 6, "\uC61A\uC61D", 6, "\uC626\uC627\uC629\uC62A\uC62B\uC62F\uC631\uC632\uC636\uC638\uC63A\uC63C\uC63D\uC63E\uC63F\uC642\uC643\uC645\uC646\uC647\uC649", 6, "\uC652\uC656", 5, "\uC65E\uC65F\uC661", 10, "\uC66D\uC66E\uC670\uC672", 5, "\uC67A\uC67B\uC67D\uC67E\uC67F\uC681", 6, "\uC68A\uC68C\uC68E", 5, "\uC696\uC697\uC699\uC69A\uC69B\uC69D", 6, "\uC6A6"],
    ["9f41", "\uC6A8\uC6AA", 5, "\uC6B2\uC6B3\uC6B5\uC6B6\uC6B7\uC6BB", 4, "\uC6C2\uC6C4\uC6C6", 5, "\uC6CE"],
    ["9f61", "\uC6CF\uC6D1\uC6D2\uC6D3\uC6D5", 6, "\uC6DE\uC6DF\uC6E2", 5, "\uC6EA\uC6EB\uC6ED\uC6EE\uC6EF\uC6F1\uC6F2"],
    ["9f81", "\uC6F3", 4, "\uC6FA\uC6FB\uC6FC\uC6FE", 5, "\uC706\uC707\uC709\uC70A\uC70B\uC70D", 6, "\uC716\uC718\uC71A", 5, "\uC722\uC723\uC725\uC726\uC727\uC729", 6, "\uC732\uC734\uC736\uC738\uC739\uC73A\uC73B\uC73E\uC73F\uC741\uC742\uC743\uC745", 4, "\uC74B\uC74E\uC750\uC759\uC75A\uC75B\uC75D\uC75E\uC75F\uC761", 6, "\uC769\uC76A\uC76C", 7, "\uC776\uC777\uC779\uC77A\uC77B\uC77F\uC780\uC781\uC782\uC786\uC78B\uC78C\uC78D\uC78F\uC792\uC793\uC795\uC799\uC79B", 4, "\uC7A2\uC7A7", 4, "\uC7AE\uC7AF\uC7B1\uC7B2\uC7B3\uC7B5\uC7B6\uC7B7"],
    ["a041", "\uC7B8\uC7B9\uC7BA\uC7BB\uC7BE\uC7C2", 5, "\uC7CA\uC7CB\uC7CD\uC7CF\uC7D1", 6, "\uC7D9\uC7DA\uC7DB\uC7DC"],
    ["a061", "\uC7DE", 5, "\uC7E5\uC7E6\uC7E7\uC7E9\uC7EA\uC7EB\uC7ED", 13],
    ["a081", "\uC7FB", 4, "\uC802\uC803\uC805\uC806\uC807\uC809\uC80B", 4, "\uC812\uC814\uC817", 4, "\uC81E\uC81F\uC821\uC822\uC823\uC825", 6, "\uC82E\uC830\uC832", 5, "\uC839\uC83A\uC83B\uC83D\uC83E\uC83F\uC841", 6, "\uC84A\uC84B\uC84E", 5, "\uC855", 26, "\uC872\uC873\uC875\uC876\uC877\uC879\uC87B", 4, "\uC882\uC884\uC888\uC889\uC88A\uC88E", 5, "\uC895", 7, "\uC89E\uC8A0\uC8A2\uC8A3\uC8A4"],
    ["a141", "\uC8A5\uC8A6\uC8A7\uC8A9", 18, "\uC8BE\uC8BF\uC8C0\uC8C1"],
    ["a161", "\uC8C2\uC8C3\uC8C5\uC8C6\uC8C7\uC8C9\uC8CA\uC8CB\uC8CD", 6, "\uC8D6\uC8D8\uC8DA", 5, "\uC8E2\uC8E3\uC8E5"],
    ["a181", "\uC8E6", 14, "\uC8F6", 5, "\uC8FE\uC8FF\uC901\uC902\uC903\uC907", 4, "\uC90E\u3000\u3001\u3002\xB7\u2025\u2026\xA8\u3003\xAD\u2015\u2225\uFF3C\u223C\u2018\u2019\u201C\u201D\u3014\u3015\u3008", 9, "\xB1\xD7\xF7\u2260\u2264\u2265\u221E\u2234\xB0\u2032\u2033\u2103\u212B\uFFE0\uFFE1\uFFE5\u2642\u2640\u2220\u22A5\u2312\u2202\u2207\u2261\u2252\xA7\u203B\u2606\u2605\u25CB\u25CF\u25CE\u25C7\u25C6\u25A1\u25A0\u25B3\u25B2\u25BD\u25BC\u2192\u2190\u2191\u2193\u2194\u3013\u226A\u226B\u221A\u223D\u221D\u2235\u222B\u222C\u2208\u220B\u2286\u2287\u2282\u2283\u222A\u2229\u2227\u2228\uFFE2"],
    ["a241", "\uC910\uC912", 5, "\uC919", 18],
    ["a261", "\uC92D", 6, "\uC935", 18],
    ["a281", "\uC948", 7, "\uC952\uC953\uC955\uC956\uC957\uC959", 6, "\uC962\uC964", 7, "\uC96D\uC96E\uC96F\u21D2\u21D4\u2200\u2203\xB4\uFF5E\u02C7\u02D8\u02DD\u02DA\u02D9\xB8\u02DB\xA1\xBF\u02D0\u222E\u2211\u220F\xA4\u2109\u2030\u25C1\u25C0\u25B7\u25B6\u2664\u2660\u2661\u2665\u2667\u2663\u2299\u25C8\u25A3\u25D0\u25D1\u2592\u25A4\u25A5\u25A8\u25A7\u25A6\u25A9\u2668\u260F\u260E\u261C\u261E\xB6\u2020\u2021\u2195\u2197\u2199\u2196\u2198\u266D\u2669\u266A\u266C\u327F\u321C\u2116\u33C7\u2122\u33C2\u33D8\u2121\u20AC\xAE"],
    ["a341", "\uC971\uC972\uC973\uC975", 6, "\uC97D", 10, "\uC98A\uC98B\uC98D\uC98E\uC98F"],
    ["a361", "\uC991", 6, "\uC99A\uC99C\uC99E", 16],
    ["a381", "\uC9AF", 16, "\uC9C2\uC9C3\uC9C5\uC9C6\uC9C9\uC9CB", 4, "\uC9D2\uC9D4\uC9D7\uC9D8\uC9DB\uFF01", 58, "\uFFE6\uFF3D", 32, "\uFFE3"],
    ["a441", "\uC9DE\uC9DF\uC9E1\uC9E3\uC9E5\uC9E6\uC9E8\uC9E9\uC9EA\uC9EB\uC9EE\uC9F2", 5, "\uC9FA\uC9FB\uC9FD\uC9FE\uC9FF\uCA01\uCA02\uCA03\uCA04"],
    ["a461", "\uCA05\uCA06\uCA07\uCA0A\uCA0E", 5, "\uCA15\uCA16\uCA17\uCA19", 12],
    ["a481", "\uCA26\uCA27\uCA28\uCA2A", 28, "\u3131", 93],
    ["a541", "\uCA47", 4, "\uCA4E\uCA4F\uCA51\uCA52\uCA53\uCA55", 6, "\uCA5E\uCA62", 5, "\uCA69\uCA6A"],
    ["a561", "\uCA6B", 17, "\uCA7E", 5, "\uCA85\uCA86"],
    ["a581", "\uCA87", 16, "\uCA99", 14, "\u2170", 9],
    ["a5b0", "\u2160", 9],
    ["a5c1", "\u0391", 16, "\u03A3", 6],
    ["a5e1", "\u03B1", 16, "\u03C3", 6],
    ["a641", "\uCAA8", 19, "\uCABE\uCABF\uCAC1\uCAC2\uCAC3\uCAC5"],
    ["a661", "\uCAC6", 5, "\uCACE\uCAD0\uCAD2\uCAD4\uCAD5\uCAD6\uCAD7\uCADA", 5, "\uCAE1", 6],
    ["a681", "\uCAE8\uCAE9\uCAEA\uCAEB\uCAED", 6, "\uCAF5", 18, "\uCB09\uCB0A\u2500\u2502\u250C\u2510\u2518\u2514\u251C\u252C\u2524\u2534\u253C\u2501\u2503\u250F\u2513\u251B\u2517\u2523\u2533\u252B\u253B\u254B\u2520\u252F\u2528\u2537\u253F\u251D\u2530\u2525\u2538\u2542\u2512\u2511\u251A\u2519\u2516\u2515\u250E\u250D\u251E\u251F\u2521\u2522\u2526\u2527\u2529\u252A\u252D\u252E\u2531\u2532\u2535\u2536\u2539\u253A\u253D\u253E\u2540\u2541\u2543", 7],
    ["a741", "\uCB0B", 4, "\uCB11\uCB12\uCB13\uCB15\uCB16\uCB17\uCB19", 6, "\uCB22", 7],
    ["a761", "\uCB2A", 22, "\uCB42\uCB43\uCB44"],
    ["a781", "\uCB45\uCB46\uCB47\uCB4A\uCB4B\uCB4D\uCB4E\uCB4F\uCB51", 6, "\uCB5A\uCB5B\uCB5C\uCB5E", 5, "\uCB65", 7, "\u3395\u3396\u3397\u2113\u3398\u33C4\u33A3\u33A4\u33A5\u33A6\u3399", 9, "\u33CA\u338D\u338E\u338F\u33CF\u3388\u3389\u33C8\u33A7\u33A8\u33B0", 9, "\u3380", 4, "\u33BA", 5, "\u3390", 4, "\u2126\u33C0\u33C1\u338A\u338B\u338C\u33D6\u33C5\u33AD\u33AE\u33AF\u33DB\u33A9\u33AA\u33AB\u33AC\u33DD\u33D0\u33D3\u33C3\u33C9\u33DC\u33C6"],
    ["a841", "\uCB6D", 10, "\uCB7A", 14],
    ["a861", "\uCB89", 18, "\uCB9D", 6],
    ["a881", "\uCBA4", 19, "\uCBB9", 11, "\xC6\xD0\xAA\u0126"],
    ["a8a6", "\u0132"],
    ["a8a8", "\u013F\u0141\xD8\u0152\xBA\xDE\u0166\u014A"],
    ["a8b1", "\u3260", 27, "\u24D0", 25, "\u2460", 14, "\xBD\u2153\u2154\xBC\xBE\u215B\u215C\u215D\u215E"],
    ["a941", "\uCBC5", 14, "\uCBD5", 10],
    ["a961", "\uCBE0\uCBE1\uCBE2\uCBE3\uCBE5\uCBE6\uCBE8\uCBEA", 18],
    ["a981", "\uCBFD", 14, "\uCC0E\uCC0F\uCC11\uCC12\uCC13\uCC15", 6, "\uCC1E\uCC1F\uCC20\uCC23\uCC24\xE6\u0111\xF0\u0127\u0131\u0133\u0138\u0140\u0142\xF8\u0153\xDF\xFE\u0167\u014B\u0149\u3200", 27, "\u249C", 25, "\u2474", 14, "\xB9\xB2\xB3\u2074\u207F\u2081\u2082\u2083\u2084"],
    ["aa41", "\uCC25\uCC26\uCC2A\uCC2B\uCC2D\uCC2F\uCC31", 6, "\uCC3A\uCC3F", 4, "\uCC46\uCC47\uCC49\uCC4A\uCC4B\uCC4D\uCC4E"],
    ["aa61", "\uCC4F", 4, "\uCC56\uCC5A", 5, "\uCC61\uCC62\uCC63\uCC65\uCC67\uCC69", 6, "\uCC71\uCC72"],
    ["aa81", "\uCC73\uCC74\uCC76", 29, "\u3041", 82],
    ["ab41", "\uCC94\uCC95\uCC96\uCC97\uCC9A\uCC9B\uCC9D\uCC9E\uCC9F\uCCA1", 6, "\uCCAA\uCCAE", 5, "\uCCB6\uCCB7\uCCB9"],
    ["ab61", "\uCCBA\uCCBB\uCCBD", 6, "\uCCC6\uCCC8\uCCCA", 5, "\uCCD1\uCCD2\uCCD3\uCCD5", 5],
    ["ab81", "\uCCDB", 8, "\uCCE5", 6, "\uCCED\uCCEE\uCCEF\uCCF1", 12, "\u30A1", 85],
    ["ac41", "\uCCFE\uCCFF\uCD00\uCD02", 5, "\uCD0A\uCD0B\uCD0D\uCD0E\uCD0F\uCD11", 6, "\uCD1A\uCD1C\uCD1E\uCD1F\uCD20"],
    ["ac61", "\uCD21\uCD22\uCD23\uCD25\uCD26\uCD27\uCD29\uCD2A\uCD2B\uCD2D", 11, "\uCD3A", 4],
    ["ac81", "\uCD3F", 28, "\uCD5D\uCD5E\uCD5F\u0410", 5, "\u0401\u0416", 25],
    ["acd1", "\u0430", 5, "\u0451\u0436", 25],
    ["ad41", "\uCD61\uCD62\uCD63\uCD65", 6, "\uCD6E\uCD70\uCD72", 5, "\uCD79", 7],
    ["ad61", "\uCD81", 6, "\uCD89", 10, "\uCD96\uCD97\uCD99\uCD9A\uCD9B\uCD9D\uCD9E\uCD9F"],
    ["ad81", "\uCDA0\uCDA1\uCDA2\uCDA3\uCDA6\uCDA8\uCDAA", 5, "\uCDB1", 18, "\uCDC5"],
    ["ae41", "\uCDC6", 5, "\uCDCD\uCDCE\uCDCF\uCDD1", 16],
    ["ae61", "\uCDE2", 5, "\uCDE9\uCDEA\uCDEB\uCDED\uCDEE\uCDEF\uCDF1", 6, "\uCDFA\uCDFC\uCDFE", 4],
    ["ae81", "\uCE03\uCE05\uCE06\uCE07\uCE09\uCE0A\uCE0B\uCE0D", 6, "\uCE15\uCE16\uCE17\uCE18\uCE1A", 5, "\uCE22\uCE23\uCE25\uCE26\uCE27\uCE29\uCE2A\uCE2B"],
    ["af41", "\uCE2C\uCE2D\uCE2E\uCE2F\uCE32\uCE34\uCE36", 19],
    ["af61", "\uCE4A", 13, "\uCE5A\uCE5B\uCE5D\uCE5E\uCE62", 5, "\uCE6A\uCE6C"],
    ["af81", "\uCE6E", 5, "\uCE76\uCE77\uCE79\uCE7A\uCE7B\uCE7D", 6, "\uCE86\uCE88\uCE8A", 5, "\uCE92\uCE93\uCE95\uCE96\uCE97\uCE99"],
    ["b041", "\uCE9A", 5, "\uCEA2\uCEA6", 5, "\uCEAE", 12],
    ["b061", "\uCEBB", 5, "\uCEC2", 19],
    ["b081", "\uCED6", 13, "\uCEE6\uCEE7\uCEE9\uCEEA\uCEED", 6, "\uCEF6\uCEFA", 5, "\uAC00\uAC01\uAC04\uAC07\uAC08\uAC09\uAC0A\uAC10", 7, "\uAC19", 4, "\uAC20\uAC24\uAC2C\uAC2D\uAC2F\uAC30\uAC31\uAC38\uAC39\uAC3C\uAC40\uAC4B\uAC4D\uAC54\uAC58\uAC5C\uAC70\uAC71\uAC74\uAC77\uAC78\uAC7A\uAC80\uAC81\uAC83\uAC84\uAC85\uAC86\uAC89\uAC8A\uAC8B\uAC8C\uAC90\uAC94\uAC9C\uAC9D\uAC9F\uACA0\uACA1\uACA8\uACA9\uACAA\uACAC\uACAF\uACB0\uACB8\uACB9\uACBB\uACBC\uACBD\uACC1\uACC4\uACC8\uACCC\uACD5\uACD7\uACE0\uACE1\uACE4\uACE7\uACE8\uACEA\uACEC\uACEF\uACF0\uACF1\uACF3\uACF5\uACF6\uACFC\uACFD\uAD00\uAD04\uAD06"],
    ["b141", "\uCF02\uCF03\uCF05\uCF06\uCF07\uCF09", 6, "\uCF12\uCF14\uCF16", 5, "\uCF1D\uCF1E\uCF1F\uCF21\uCF22\uCF23"],
    ["b161", "\uCF25", 6, "\uCF2E\uCF32", 5, "\uCF39", 11],
    ["b181", "\uCF45", 14, "\uCF56\uCF57\uCF59\uCF5A\uCF5B\uCF5D", 6, "\uCF66\uCF68\uCF6A\uCF6B\uCF6C\uAD0C\uAD0D\uAD0F\uAD11\uAD18\uAD1C\uAD20\uAD29\uAD2C\uAD2D\uAD34\uAD35\uAD38\uAD3C\uAD44\uAD45\uAD47\uAD49\uAD50\uAD54\uAD58\uAD61\uAD63\uAD6C\uAD6D\uAD70\uAD73\uAD74\uAD75\uAD76\uAD7B\uAD7C\uAD7D\uAD7F\uAD81\uAD82\uAD88\uAD89\uAD8C\uAD90\uAD9C\uAD9D\uADA4\uADB7\uADC0\uADC1\uADC4\uADC8\uADD0\uADD1\uADD3\uADDC\uADE0\uADE4\uADF8\uADF9\uADFC\uADFF\uAE00\uAE01\uAE08\uAE09\uAE0B\uAE0D\uAE14\uAE30\uAE31\uAE34\uAE37\uAE38\uAE3A\uAE40\uAE41\uAE43\uAE45\uAE46\uAE4A\uAE4C\uAE4D\uAE4E\uAE50\uAE54\uAE56\uAE5C\uAE5D\uAE5F\uAE60\uAE61\uAE65\uAE68\uAE69\uAE6C\uAE70\uAE78"],
    ["b241", "\uCF6D\uCF6E\uCF6F\uCF72\uCF73\uCF75\uCF76\uCF77\uCF79", 6, "\uCF81\uCF82\uCF83\uCF84\uCF86", 5, "\uCF8D"],
    ["b261", "\uCF8E", 18, "\uCFA2", 5, "\uCFA9"],
    ["b281", "\uCFAA", 5, "\uCFB1", 18, "\uCFC5", 6, "\uAE79\uAE7B\uAE7C\uAE7D\uAE84\uAE85\uAE8C\uAEBC\uAEBD\uAEBE\uAEC0\uAEC4\uAECC\uAECD\uAECF\uAED0\uAED1\uAED8\uAED9\uAEDC\uAEE8\uAEEB\uAEED\uAEF4\uAEF8\uAEFC\uAF07\uAF08\uAF0D\uAF10\uAF2C\uAF2D\uAF30\uAF32\uAF34\uAF3C\uAF3D\uAF3F\uAF41\uAF42\uAF43\uAF48\uAF49\uAF50\uAF5C\uAF5D\uAF64\uAF65\uAF79\uAF80\uAF84\uAF88\uAF90\uAF91\uAF95\uAF9C\uAFB8\uAFB9\uAFBC\uAFC0\uAFC7\uAFC8\uAFC9\uAFCB\uAFCD\uAFCE\uAFD4\uAFDC\uAFE8\uAFE9\uAFF0\uAFF1\uAFF4\uAFF8\uB000\uB001\uB004\uB00C\uB010\uB014\uB01C\uB01D\uB028\uB044\uB045\uB048\uB04A\uB04C\uB04E\uB053\uB054\uB055\uB057\uB059"],
    ["b341", "\uCFCC", 19, "\uCFE2\uCFE3\uCFE5\uCFE6\uCFE7\uCFE9"],
    ["b361", "\uCFEA", 5, "\uCFF2\uCFF4\uCFF6", 5, "\uCFFD\uCFFE\uCFFF\uD001\uD002\uD003\uD005", 5],
    ["b381", "\uD00B", 5, "\uD012", 5, "\uD019", 19, "\uB05D\uB07C\uB07D\uB080\uB084\uB08C\uB08D\uB08F\uB091\uB098\uB099\uB09A\uB09C\uB09F\uB0A0\uB0A1\uB0A2\uB0A8\uB0A9\uB0AB", 4, "\uB0B1\uB0B3\uB0B4\uB0B5\uB0B8\uB0BC\uB0C4\uB0C5\uB0C7\uB0C8\uB0C9\uB0D0\uB0D1\uB0D4\uB0D8\uB0E0\uB0E5\uB108\uB109\uB10B\uB10C\uB110\uB112\uB113\uB118\uB119\uB11B\uB11C\uB11D\uB123\uB124\uB125\uB128\uB12C\uB134\uB135\uB137\uB138\uB139\uB140\uB141\uB144\uB148\uB150\uB151\uB154\uB155\uB158\uB15C\uB160\uB178\uB179\uB17C\uB180\uB182\uB188\uB189\uB18B\uB18D\uB192\uB193\uB194\uB198\uB19C\uB1A8\uB1CC\uB1D0\uB1D4\uB1DC\uB1DD"],
    ["b441", "\uD02E", 5, "\uD036\uD037\uD039\uD03A\uD03B\uD03D", 6, "\uD046\uD048\uD04A", 5],
    ["b461", "\uD051\uD052\uD053\uD055\uD056\uD057\uD059", 6, "\uD061", 10, "\uD06E\uD06F"],
    ["b481", "\uD071\uD072\uD073\uD075", 6, "\uD07E\uD07F\uD080\uD082", 18, "\uB1DF\uB1E8\uB1E9\uB1EC\uB1F0\uB1F9\uB1FB\uB1FD\uB204\uB205\uB208\uB20B\uB20C\uB214\uB215\uB217\uB219\uB220\uB234\uB23C\uB258\uB25C\uB260\uB268\uB269\uB274\uB275\uB27C\uB284\uB285\uB289\uB290\uB291\uB294\uB298\uB299\uB29A\uB2A0\uB2A1\uB2A3\uB2A5\uB2A6\uB2AA\uB2AC\uB2B0\uB2B4\uB2C8\uB2C9\uB2CC\uB2D0\uB2D2\uB2D8\uB2D9\uB2DB\uB2DD\uB2E2\uB2E4\uB2E5\uB2E6\uB2E8\uB2EB", 4, "\uB2F3\uB2F4\uB2F5\uB2F7", 4, "\uB2FF\uB300\uB301\uB304\uB308\uB310\uB311\uB313\uB314\uB315\uB31C\uB354\uB355\uB356\uB358\uB35B\uB35C\uB35E\uB35F\uB364\uB365"],
    ["b541", "\uD095", 14, "\uD0A6\uD0A7\uD0A9\uD0AA\uD0AB\uD0AD", 5],
    ["b561", "\uD0B3\uD0B6\uD0B8\uD0BA", 5, "\uD0C2\uD0C3\uD0C5\uD0C6\uD0C7\uD0CA", 5, "\uD0D2\uD0D6", 4],
    ["b581", "\uD0DB\uD0DE\uD0DF\uD0E1\uD0E2\uD0E3\uD0E5", 6, "\uD0EE\uD0F2", 5, "\uD0F9", 11, "\uB367\uB369\uB36B\uB36E\uB370\uB371\uB374\uB378\uB380\uB381\uB383\uB384\uB385\uB38C\uB390\uB394\uB3A0\uB3A1\uB3A8\uB3AC\uB3C4\uB3C5\uB3C8\uB3CB\uB3CC\uB3CE\uB3D0\uB3D4\uB3D5\uB3D7\uB3D9\uB3DB\uB3DD\uB3E0\uB3E4\uB3E8\uB3FC\uB410\uB418\uB41C\uB420\uB428\uB429\uB42B\uB434\uB450\uB451\uB454\uB458\uB460\uB461\uB463\uB465\uB46C\uB480\uB488\uB49D\uB4A4\uB4A8\uB4AC\uB4B5\uB4B7\uB4B9\uB4C0\uB4C4\uB4C8\uB4D0\uB4D5\uB4DC\uB4DD\uB4E0\uB4E3\uB4E4\uB4E6\uB4EC\uB4ED\uB4EF\uB4F1\uB4F8\uB514\uB515\uB518\uB51B\uB51C\uB524\uB525\uB527\uB528\uB529\uB52A\uB530\uB531\uB534\uB538"],
    ["b641", "\uD105", 7, "\uD10E", 17],
    ["b661", "\uD120", 15, "\uD132\uD133\uD135\uD136\uD137\uD139\uD13B\uD13C\uD13D\uD13E"],
    ["b681", "\uD13F\uD142\uD146", 5, "\uD14E\uD14F\uD151\uD152\uD153\uD155", 6, "\uD15E\uD160\uD162", 5, "\uD169\uD16A\uD16B\uD16D\uB540\uB541\uB543\uB544\uB545\uB54B\uB54C\uB54D\uB550\uB554\uB55C\uB55D\uB55F\uB560\uB561\uB5A0\uB5A1\uB5A4\uB5A8\uB5AA\uB5AB\uB5B0\uB5B1\uB5B3\uB5B4\uB5B5\uB5BB\uB5BC\uB5BD\uB5C0\uB5C4\uB5CC\uB5CD\uB5CF\uB5D0\uB5D1\uB5D8\uB5EC\uB610\uB611\uB614\uB618\uB625\uB62C\uB634\uB648\uB664\uB668\uB69C\uB69D\uB6A0\uB6A4\uB6AB\uB6AC\uB6B1\uB6D4\uB6F0\uB6F4\uB6F8\uB700\uB701\uB705\uB728\uB729\uB72C\uB72F\uB730\uB738\uB739\uB73B\uB744\uB748\uB74C\uB754\uB755\uB760\uB764\uB768\uB770\uB771\uB773\uB775\uB77C\uB77D\uB780\uB784\uB78C\uB78D\uB78F\uB790\uB791\uB792\uB796\uB797"],
    ["b741", "\uD16E", 13, "\uD17D", 6, "\uD185\uD186\uD187\uD189\uD18A"],
    ["b761", "\uD18B", 20, "\uD1A2\uD1A3\uD1A5\uD1A6\uD1A7"],
    ["b781", "\uD1A9", 6, "\uD1B2\uD1B4\uD1B6\uD1B7\uD1B8\uD1B9\uD1BB\uD1BD\uD1BE\uD1BF\uD1C1", 14, "\uB798\uB799\uB79C\uB7A0\uB7A8\uB7A9\uB7AB\uB7AC\uB7AD\uB7B4\uB7B5\uB7B8\uB7C7\uB7C9\uB7EC\uB7ED\uB7F0\uB7F4\uB7FC\uB7FD\uB7FF\uB800\uB801\uB807\uB808\uB809\uB80C\uB810\uB818\uB819\uB81B\uB81D\uB824\uB825\uB828\uB82C\uB834\uB835\uB837\uB838\uB839\uB840\uB844\uB851\uB853\uB85C\uB85D\uB860\uB864\uB86C\uB86D\uB86F\uB871\uB878\uB87C\uB88D\uB8A8\uB8B0\uB8B4\uB8B8\uB8C0\uB8C1\uB8C3\uB8C5\uB8CC\uB8D0\uB8D4\uB8DD\uB8DF\uB8E1\uB8E8\uB8E9\uB8EC\uB8F0\uB8F8\uB8F9\uB8FB\uB8FD\uB904\uB918\uB920\uB93C\uB93D\uB940\uB944\uB94C\uB94F\uB951\uB958\uB959\uB95C\uB960\uB968\uB969"],
    ["b841", "\uD1D0", 7, "\uD1D9", 17],
    ["b861", "\uD1EB", 8, "\uD1F5\uD1F6\uD1F7\uD1F9", 13],
    ["b881", "\uD208\uD20A", 5, "\uD211", 24, "\uB96B\uB96D\uB974\uB975\uB978\uB97C\uB984\uB985\uB987\uB989\uB98A\uB98D\uB98E\uB9AC\uB9AD\uB9B0\uB9B4\uB9BC\uB9BD\uB9BF\uB9C1\uB9C8\uB9C9\uB9CC\uB9CE", 4, "\uB9D8\uB9D9\uB9DB\uB9DD\uB9DE\uB9E1\uB9E3\uB9E4\uB9E5\uB9E8\uB9EC\uB9F4\uB9F5\uB9F7\uB9F8\uB9F9\uB9FA\uBA00\uBA01\uBA08\uBA15\uBA38\uBA39\uBA3C\uBA40\uBA42\uBA48\uBA49\uBA4B\uBA4D\uBA4E\uBA53\uBA54\uBA55\uBA58\uBA5C\uBA64\uBA65\uBA67\uBA68\uBA69\uBA70\uBA71\uBA74\uBA78\uBA83\uBA84\uBA85\uBA87\uBA8C\uBAA8\uBAA9\uBAAB\uBAAC\uBAB0\uBAB2\uBAB8\uBAB9\uBABB\uBABD\uBAC4\uBAC8\uBAD8\uBAD9\uBAFC"],
    ["b941", "\uD22A\uD22B\uD22E\uD22F\uD231\uD232\uD233\uD235", 6, "\uD23E\uD240\uD242", 5, "\uD249\uD24A\uD24B\uD24C"],
    ["b961", "\uD24D", 14, "\uD25D", 6, "\uD265\uD266\uD267\uD268"],
    ["b981", "\uD269", 22, "\uD282\uD283\uD285\uD286\uD287\uD289\uD28A\uD28B\uD28C\uBB00\uBB04\uBB0D\uBB0F\uBB11\uBB18\uBB1C\uBB20\uBB29\uBB2B\uBB34\uBB35\uBB36\uBB38\uBB3B\uBB3C\uBB3D\uBB3E\uBB44\uBB45\uBB47\uBB49\uBB4D\uBB4F\uBB50\uBB54\uBB58\uBB61\uBB63\uBB6C\uBB88\uBB8C\uBB90\uBBA4\uBBA8\uBBAC\uBBB4\uBBB7\uBBC0\uBBC4\uBBC8\uBBD0\uBBD3\uBBF8\uBBF9\uBBFC\uBBFF\uBC00\uBC02\uBC08\uBC09\uBC0B\uBC0C\uBC0D\uBC0F\uBC11\uBC14", 4, "\uBC1B", 4, "\uBC24\uBC25\uBC27\uBC29\uBC2D\uBC30\uBC31\uBC34\uBC38\uBC40\uBC41\uBC43\uBC44\uBC45\uBC49\uBC4C\uBC4D\uBC50\uBC5D\uBC84\uBC85\uBC88\uBC8B\uBC8C\uBC8E\uBC94\uBC95\uBC97"],
    ["ba41", "\uD28D\uD28E\uD28F\uD292\uD293\uD294\uD296", 5, "\uD29D\uD29E\uD29F\uD2A1\uD2A2\uD2A3\uD2A5", 6, "\uD2AD"],
    ["ba61", "\uD2AE\uD2AF\uD2B0\uD2B2", 5, "\uD2BA\uD2BB\uD2BD\uD2BE\uD2C1\uD2C3", 4, "\uD2CA\uD2CC", 5],
    ["ba81", "\uD2D2\uD2D3\uD2D5\uD2D6\uD2D7\uD2D9\uD2DA\uD2DB\uD2DD", 6, "\uD2E6", 9, "\uD2F2\uD2F3\uD2F5\uD2F6\uD2F7\uD2F9\uD2FA\uBC99\uBC9A\uBCA0\uBCA1\uBCA4\uBCA7\uBCA8\uBCB0\uBCB1\uBCB3\uBCB4\uBCB5\uBCBC\uBCBD\uBCC0\uBCC4\uBCCD\uBCCF\uBCD0\uBCD1\uBCD5\uBCD8\uBCDC\uBCF4\uBCF5\uBCF6\uBCF8\uBCFC\uBD04\uBD05\uBD07\uBD09\uBD10\uBD14\uBD24\uBD2C\uBD40\uBD48\uBD49\uBD4C\uBD50\uBD58\uBD59\uBD64\uBD68\uBD80\uBD81\uBD84\uBD87\uBD88\uBD89\uBD8A\uBD90\uBD91\uBD93\uBD95\uBD99\uBD9A\uBD9C\uBDA4\uBDB0\uBDB8\uBDD4\uBDD5\uBDD8\uBDDC\uBDE9\uBDF0\uBDF4\uBDF8\uBE00\uBE03\uBE05\uBE0C\uBE0D\uBE10\uBE14\uBE1C\uBE1D\uBE1F\uBE44\uBE45\uBE48\uBE4C\uBE4E\uBE54\uBE55\uBE57\uBE59\uBE5A\uBE5B\uBE60\uBE61\uBE64"],
    ["bb41", "\uD2FB", 4, "\uD302\uD304\uD306", 5, "\uD30F\uD311\uD312\uD313\uD315\uD317", 4, "\uD31E\uD322\uD323"],
    ["bb61", "\uD324\uD326\uD327\uD32A\uD32B\uD32D\uD32E\uD32F\uD331", 6, "\uD33A\uD33E", 5, "\uD346\uD347\uD348\uD349"],
    ["bb81", "\uD34A", 31, "\uBE68\uBE6A\uBE70\uBE71\uBE73\uBE74\uBE75\uBE7B\uBE7C\uBE7D\uBE80\uBE84\uBE8C\uBE8D\uBE8F\uBE90\uBE91\uBE98\uBE99\uBEA8\uBED0\uBED1\uBED4\uBED7\uBED8\uBEE0\uBEE3\uBEE4\uBEE5\uBEEC\uBF01\uBF08\uBF09\uBF18\uBF19\uBF1B\uBF1C\uBF1D\uBF40\uBF41\uBF44\uBF48\uBF50\uBF51\uBF55\uBF94\uBFB0\uBFC5\uBFCC\uBFCD\uBFD0\uBFD4\uBFDC\uBFDF\uBFE1\uC03C\uC051\uC058\uC05C\uC060\uC068\uC069\uC090\uC091\uC094\uC098\uC0A0\uC0A1\uC0A3\uC0A5\uC0AC\uC0AD\uC0AF\uC0B0\uC0B3\uC0B4\uC0B5\uC0B6\uC0BC\uC0BD\uC0BF\uC0C0\uC0C1\uC0C5\uC0C8\uC0C9\uC0CC\uC0D0\uC0D8\uC0D9\uC0DB\uC0DC\uC0DD\uC0E4"],
    ["bc41", "\uD36A", 17, "\uD37E\uD37F\uD381\uD382\uD383\uD385\uD386\uD387"],
    ["bc61", "\uD388\uD389\uD38A\uD38B\uD38E\uD392", 5, "\uD39A\uD39B\uD39D\uD39E\uD39F\uD3A1", 6, "\uD3AA\uD3AC\uD3AE"],
    ["bc81", "\uD3AF", 4, "\uD3B5\uD3B6\uD3B7\uD3B9\uD3BA\uD3BB\uD3BD", 6, "\uD3C6\uD3C7\uD3CA", 5, "\uD3D1", 5, "\uC0E5\uC0E8\uC0EC\uC0F4\uC0F5\uC0F7\uC0F9\uC100\uC104\uC108\uC110\uC115\uC11C", 4, "\uC123\uC124\uC126\uC127\uC12C\uC12D\uC12F\uC130\uC131\uC136\uC138\uC139\uC13C\uC140\uC148\uC149\uC14B\uC14C\uC14D\uC154\uC155\uC158\uC15C\uC164\uC165\uC167\uC168\uC169\uC170\uC174\uC178\uC185\uC18C\uC18D\uC18E\uC190\uC194\uC196\uC19C\uC19D\uC19F\uC1A1\uC1A5\uC1A8\uC1A9\uC1AC\uC1B0\uC1BD\uC1C4\uC1C8\uC1CC\uC1D4\uC1D7\uC1D8\uC1E0\uC1E4\uC1E8\uC1F0\uC1F1\uC1F3\uC1FC\uC1FD\uC200\uC204\uC20C\uC20D\uC20F\uC211\uC218\uC219\uC21C\uC21F\uC220\uC228\uC229\uC22B\uC22D"],
    ["bd41", "\uD3D7\uD3D9", 7, "\uD3E2\uD3E4", 7, "\uD3EE\uD3EF\uD3F1\uD3F2\uD3F3\uD3F5\uD3F6\uD3F7"],
    ["bd61", "\uD3F8\uD3F9\uD3FA\uD3FB\uD3FE\uD400\uD402", 5, "\uD409", 13],
    ["bd81", "\uD417", 5, "\uD41E", 25, "\uC22F\uC231\uC232\uC234\uC248\uC250\uC251\uC254\uC258\uC260\uC265\uC26C\uC26D\uC270\uC274\uC27C\uC27D\uC27F\uC281\uC288\uC289\uC290\uC298\uC29B\uC29D\uC2A4\uC2A5\uC2A8\uC2AC\uC2AD\uC2B4\uC2B5\uC2B7\uC2B9\uC2DC\uC2DD\uC2E0\uC2E3\uC2E4\uC2EB\uC2EC\uC2ED\uC2EF\uC2F1\uC2F6\uC2F8\uC2F9\uC2FB\uC2FC\uC300\uC308\uC309\uC30C\uC30D\uC313\uC314\uC315\uC318\uC31C\uC324\uC325\uC328\uC329\uC345\uC368\uC369\uC36C\uC370\uC372\uC378\uC379\uC37C\uC37D\uC384\uC388\uC38C\uC3C0\uC3D8\uC3D9\uC3DC\uC3DF\uC3E0\uC3E2\uC3E8\uC3E9\uC3ED\uC3F4\uC3F5\uC3F8\uC408\uC410\uC424\uC42C\uC430"],
    ["be41", "\uD438", 7, "\uD441\uD442\uD443\uD445", 14],
    ["be61", "\uD454", 7, "\uD45D\uD45E\uD45F\uD461\uD462\uD463\uD465", 7, "\uD46E\uD470\uD471\uD472"],
    ["be81", "\uD473", 4, "\uD47A\uD47B\uD47D\uD47E\uD481\uD483", 4, "\uD48A\uD48C\uD48E", 5, "\uD495", 8, "\uC434\uC43C\uC43D\uC448\uC464\uC465\uC468\uC46C\uC474\uC475\uC479\uC480\uC494\uC49C\uC4B8\uC4BC\uC4E9\uC4F0\uC4F1\uC4F4\uC4F8\uC4FA\uC4FF\uC500\uC501\uC50C\uC510\uC514\uC51C\uC528\uC529\uC52C\uC530\uC538\uC539\uC53B\uC53D\uC544\uC545\uC548\uC549\uC54A\uC54C\uC54D\uC54E\uC553\uC554\uC555\uC557\uC558\uC559\uC55D\uC55E\uC560\uC561\uC564\uC568\uC570\uC571\uC573\uC574\uC575\uC57C\uC57D\uC580\uC584\uC587\uC58C\uC58D\uC58F\uC591\uC595\uC597\uC598\uC59C\uC5A0\uC5A9\uC5B4\uC5B5\uC5B8\uC5B9\uC5BB\uC5BC\uC5BD\uC5BE\uC5C4", 6, "\uC5CC\uC5CE"],
    ["bf41", "\uD49E", 10, "\uD4AA", 14],
    ["bf61", "\uD4B9", 18, "\uD4CD\uD4CE\uD4CF\uD4D1\uD4D2\uD4D3\uD4D5"],
    ["bf81", "\uD4D6", 5, "\uD4DD\uD4DE\uD4E0", 7, "\uD4E9\uD4EA\uD4EB\uD4ED\uD4EE\uD4EF\uD4F1", 6, "\uD4F9\uD4FA\uD4FC\uC5D0\uC5D1\uC5D4\uC5D8\uC5E0\uC5E1\uC5E3\uC5E5\uC5EC\uC5ED\uC5EE\uC5F0\uC5F4\uC5F6\uC5F7\uC5FC", 5, "\uC605\uC606\uC607\uC608\uC60C\uC610\uC618\uC619\uC61B\uC61C\uC624\uC625\uC628\uC62C\uC62D\uC62E\uC630\uC633\uC634\uC635\uC637\uC639\uC63B\uC640\uC641\uC644\uC648\uC650\uC651\uC653\uC654\uC655\uC65C\uC65D\uC660\uC66C\uC66F\uC671\uC678\uC679\uC67C\uC680\uC688\uC689\uC68B\uC68D\uC694\uC695\uC698\uC69C\uC6A4\uC6A5\uC6A7\uC6A9\uC6B0\uC6B1\uC6B4\uC6B8\uC6B9\uC6BA\uC6C0\uC6C1\uC6C3\uC6C5\uC6CC\uC6CD\uC6D0\uC6D4\uC6DC\uC6DD\uC6E0\uC6E1\uC6E8"],
    ["c041", "\uD4FE", 5, "\uD505\uD506\uD507\uD509\uD50A\uD50B\uD50D", 6, "\uD516\uD518", 5],
    ["c061", "\uD51E", 25],
    ["c081", "\uD538\uD539\uD53A\uD53B\uD53E\uD53F\uD541\uD542\uD543\uD545", 6, "\uD54E\uD550\uD552", 5, "\uD55A\uD55B\uD55D\uD55E\uD55F\uD561\uD562\uD563\uC6E9\uC6EC\uC6F0\uC6F8\uC6F9\uC6FD\uC704\uC705\uC708\uC70C\uC714\uC715\uC717\uC719\uC720\uC721\uC724\uC728\uC730\uC731\uC733\uC735\uC737\uC73C\uC73D\uC740\uC744\uC74A\uC74C\uC74D\uC74F\uC751", 7, "\uC75C\uC760\uC768\uC76B\uC774\uC775\uC778\uC77C\uC77D\uC77E\uC783\uC784\uC785\uC787\uC788\uC789\uC78A\uC78E\uC790\uC791\uC794\uC796\uC797\uC798\uC79A\uC7A0\uC7A1\uC7A3\uC7A4\uC7A5\uC7A6\uC7AC\uC7AD\uC7B0\uC7B4\uC7BC\uC7BD\uC7BF\uC7C0\uC7C1\uC7C8\uC7C9\uC7CC\uC7CE\uC7D0\uC7D8\uC7DD\uC7E4\uC7E8\uC7EC\uC800\uC801\uC804\uC808\uC80A"],
    ["c141", "\uD564\uD566\uD567\uD56A\uD56C\uD56E", 5, "\uD576\uD577\uD579\uD57A\uD57B\uD57D", 6, "\uD586\uD58A\uD58B"],
    ["c161", "\uD58C\uD58D\uD58E\uD58F\uD591", 19, "\uD5A6\uD5A7"],
    ["c181", "\uD5A8", 31, "\uC810\uC811\uC813\uC815\uC816\uC81C\uC81D\uC820\uC824\uC82C\uC82D\uC82F\uC831\uC838\uC83C\uC840\uC848\uC849\uC84C\uC84D\uC854\uC870\uC871\uC874\uC878\uC87A\uC880\uC881\uC883\uC885\uC886\uC887\uC88B\uC88C\uC88D\uC894\uC89D\uC89F\uC8A1\uC8A8\uC8BC\uC8BD\uC8C4\uC8C8\uC8CC\uC8D4\uC8D5\uC8D7\uC8D9\uC8E0\uC8E1\uC8E4\uC8F5\uC8FC\uC8FD\uC900\uC904\uC905\uC906\uC90C\uC90D\uC90F\uC911\uC918\uC92C\uC934\uC950\uC951\uC954\uC958\uC960\uC961\uC963\uC96C\uC970\uC974\uC97C\uC988\uC989\uC98C\uC990\uC998\uC999\uC99B\uC99D\uC9C0\uC9C1\uC9C4\uC9C7\uC9C8\uC9CA\uC9D0\uC9D1\uC9D3"],
    ["c241", "\uD5CA\uD5CB\uD5CD\uD5CE\uD5CF\uD5D1\uD5D3", 4, "\uD5DA\uD5DC\uD5DE", 5, "\uD5E6\uD5E7\uD5E9\uD5EA\uD5EB\uD5ED\uD5EE"],
    ["c261", "\uD5EF", 4, "\uD5F6\uD5F8\uD5FA", 5, "\uD602\uD603\uD605\uD606\uD607\uD609", 6, "\uD612"],
    ["c281", "\uD616", 5, "\uD61D\uD61E\uD61F\uD621\uD622\uD623\uD625", 7, "\uD62E", 9, "\uD63A\uD63B\uC9D5\uC9D6\uC9D9\uC9DA\uC9DC\uC9DD\uC9E0\uC9E2\uC9E4\uC9E7\uC9EC\uC9ED\uC9EF\uC9F0\uC9F1\uC9F8\uC9F9\uC9FC\uCA00\uCA08\uCA09\uCA0B\uCA0C\uCA0D\uCA14\uCA18\uCA29\uCA4C\uCA4D\uCA50\uCA54\uCA5C\uCA5D\uCA5F\uCA60\uCA61\uCA68\uCA7D\uCA84\uCA98\uCABC\uCABD\uCAC0\uCAC4\uCACC\uCACD\uCACF\uCAD1\uCAD3\uCAD8\uCAD9\uCAE0\uCAEC\uCAF4\uCB08\uCB10\uCB14\uCB18\uCB20\uCB21\uCB41\uCB48\uCB49\uCB4C\uCB50\uCB58\uCB59\uCB5D\uCB64\uCB78\uCB79\uCB9C\uCBB8\uCBD4\uCBE4\uCBE7\uCBE9\uCC0C\uCC0D\uCC10\uCC14\uCC1C\uCC1D\uCC21\uCC22\uCC27\uCC28\uCC29\uCC2C\uCC2E\uCC30\uCC38\uCC39\uCC3B"],
    ["c341", "\uD63D\uD63E\uD63F\uD641\uD642\uD643\uD644\uD646\uD647\uD64A\uD64C\uD64E\uD64F\uD650\uD652\uD653\uD656\uD657\uD659\uD65A\uD65B\uD65D", 4],
    ["c361", "\uD662", 4, "\uD668\uD66A", 5, "\uD672\uD673\uD675", 11],
    ["c381", "\uD681\uD682\uD684\uD686", 5, "\uD68E\uD68F\uD691\uD692\uD693\uD695", 7, "\uD69E\uD6A0\uD6A2", 5, "\uD6A9\uD6AA\uCC3C\uCC3D\uCC3E\uCC44\uCC45\uCC48\uCC4C\uCC54\uCC55\uCC57\uCC58\uCC59\uCC60\uCC64\uCC66\uCC68\uCC70\uCC75\uCC98\uCC99\uCC9C\uCCA0\uCCA8\uCCA9\uCCAB\uCCAC\uCCAD\uCCB4\uCCB5\uCCB8\uCCBC\uCCC4\uCCC5\uCCC7\uCCC9\uCCD0\uCCD4\uCCE4\uCCEC\uCCF0\uCD01\uCD08\uCD09\uCD0C\uCD10\uCD18\uCD19\uCD1B\uCD1D\uCD24\uCD28\uCD2C\uCD39\uCD5C\uCD60\uCD64\uCD6C\uCD6D\uCD6F\uCD71\uCD78\uCD88\uCD94\uCD95\uCD98\uCD9C\uCDA4\uCDA5\uCDA7\uCDA9\uCDB0\uCDC4\uCDCC\uCDD0\uCDE8\uCDEC\uCDF0\uCDF8\uCDF9\uCDFB\uCDFD\uCE04\uCE08\uCE0C\uCE14\uCE19\uCE20\uCE21\uCE24\uCE28\uCE30\uCE31\uCE33\uCE35"],
    ["c441", "\uD6AB\uD6AD\uD6AE\uD6AF\uD6B1", 7, "\uD6BA\uD6BC", 7, "\uD6C6\uD6C7\uD6C9\uD6CA\uD6CB"],
    ["c461", "\uD6CD\uD6CE\uD6CF\uD6D0\uD6D2\uD6D3\uD6D5\uD6D6\uD6D8\uD6DA", 5, "\uD6E1\uD6E2\uD6E3\uD6E5\uD6E6\uD6E7\uD6E9", 4],
    ["c481", "\uD6EE\uD6EF\uD6F1\uD6F2\uD6F3\uD6F4\uD6F6", 5, "\uD6FE\uD6FF\uD701\uD702\uD703\uD705", 11, "\uD712\uD713\uD714\uCE58\uCE59\uCE5C\uCE5F\uCE60\uCE61\uCE68\uCE69\uCE6B\uCE6D\uCE74\uCE75\uCE78\uCE7C\uCE84\uCE85\uCE87\uCE89\uCE90\uCE91\uCE94\uCE98\uCEA0\uCEA1\uCEA3\uCEA4\uCEA5\uCEAC\uCEAD\uCEC1\uCEE4\uCEE5\uCEE8\uCEEB\uCEEC\uCEF4\uCEF5\uCEF7\uCEF8\uCEF9\uCF00\uCF01\uCF04\uCF08\uCF10\uCF11\uCF13\uCF15\uCF1C\uCF20\uCF24\uCF2C\uCF2D\uCF2F\uCF30\uCF31\uCF38\uCF54\uCF55\uCF58\uCF5C\uCF64\uCF65\uCF67\uCF69\uCF70\uCF71\uCF74\uCF78\uCF80\uCF85\uCF8C\uCFA1\uCFA8\uCFB0\uCFC4\uCFE0\uCFE1\uCFE4\uCFE8\uCFF0\uCFF1\uCFF3\uCFF5\uCFFC\uD000\uD004\uD011\uD018\uD02D\uD034\uD035\uD038\uD03C"],
    ["c541", "\uD715\uD716\uD717\uD71A\uD71B\uD71D\uD71E\uD71F\uD721", 6, "\uD72A\uD72C\uD72E", 5, "\uD736\uD737\uD739"],
    ["c561", "\uD73A\uD73B\uD73D", 6, "\uD745\uD746\uD748\uD74A", 5, "\uD752\uD753\uD755\uD75A", 4],
    ["c581", "\uD75F\uD762\uD764\uD766\uD767\uD768\uD76A\uD76B\uD76D\uD76E\uD76F\uD771\uD772\uD773\uD775", 6, "\uD77E\uD77F\uD780\uD782", 5, "\uD78A\uD78B\uD044\uD045\uD047\uD049\uD050\uD054\uD058\uD060\uD06C\uD06D\uD070\uD074\uD07C\uD07D\uD081\uD0A4\uD0A5\uD0A8\uD0AC\uD0B4\uD0B5\uD0B7\uD0B9\uD0C0\uD0C1\uD0C4\uD0C8\uD0C9\uD0D0\uD0D1\uD0D3\uD0D4\uD0D5\uD0DC\uD0DD\uD0E0\uD0E4\uD0EC\uD0ED\uD0EF\uD0F0\uD0F1\uD0F8\uD10D\uD130\uD131\uD134\uD138\uD13A\uD140\uD141\uD143\uD144\uD145\uD14C\uD14D\uD150\uD154\uD15C\uD15D\uD15F\uD161\uD168\uD16C\uD17C\uD184\uD188\uD1A0\uD1A1\uD1A4\uD1A8\uD1B0\uD1B1\uD1B3\uD1B5\uD1BA\uD1BC\uD1C0\uD1D8\uD1F4\uD1F8\uD207\uD209\uD210\uD22C\uD22D\uD230\uD234\uD23C\uD23D\uD23F\uD241\uD248\uD25C"],
    ["c641", "\uD78D\uD78E\uD78F\uD791", 6, "\uD79A\uD79C\uD79E", 5],
    ["c6a1", "\uD264\uD280\uD281\uD284\uD288\uD290\uD291\uD295\uD29C\uD2A0\uD2A4\uD2AC\uD2B1\uD2B8\uD2B9\uD2BC\uD2BF\uD2C0\uD2C2\uD2C8\uD2C9\uD2CB\uD2D4\uD2D8\uD2DC\uD2E4\uD2E5\uD2F0\uD2F1\uD2F4\uD2F8\uD300\uD301\uD303\uD305\uD30C\uD30D\uD30E\uD310\uD314\uD316\uD31C\uD31D\uD31F\uD320\uD321\uD325\uD328\uD329\uD32C\uD330\uD338\uD339\uD33B\uD33C\uD33D\uD344\uD345\uD37C\uD37D\uD380\uD384\uD38C\uD38D\uD38F\uD390\uD391\uD398\uD399\uD39C\uD3A0\uD3A8\uD3A9\uD3AB\uD3AD\uD3B4\uD3B8\uD3BC\uD3C4\uD3C5\uD3C8\uD3C9\uD3D0\uD3D8\uD3E1\uD3E3\uD3EC\uD3ED\uD3F0\uD3F4\uD3FC\uD3FD\uD3FF\uD401"],
    ["c7a1", "\uD408\uD41D\uD440\uD444\uD45C\uD460\uD464\uD46D\uD46F\uD478\uD479\uD47C\uD47F\uD480\uD482\uD488\uD489\uD48B\uD48D\uD494\uD4A9\uD4CC\uD4D0\uD4D4\uD4DC\uD4DF\uD4E8\uD4EC\uD4F0\uD4F8\uD4FB\uD4FD\uD504\uD508\uD50C\uD514\uD515\uD517\uD53C\uD53D\uD540\uD544\uD54C\uD54D\uD54F\uD551\uD558\uD559\uD55C\uD560\uD565\uD568\uD569\uD56B\uD56D\uD574\uD575\uD578\uD57C\uD584\uD585\uD587\uD588\uD589\uD590\uD5A5\uD5C8\uD5C9\uD5CC\uD5D0\uD5D2\uD5D8\uD5D9\uD5DB\uD5DD\uD5E4\uD5E5\uD5E8\uD5EC\uD5F4\uD5F5\uD5F7\uD5F9\uD600\uD601\uD604\uD608\uD610\uD611\uD613\uD614\uD615\uD61C\uD620"],
    ["c8a1", "\uD624\uD62D\uD638\uD639\uD63C\uD640\uD645\uD648\uD649\uD64B\uD64D\uD651\uD654\uD655\uD658\uD65C\uD667\uD669\uD670\uD671\uD674\uD683\uD685\uD68C\uD68D\uD690\uD694\uD69D\uD69F\uD6A1\uD6A8\uD6AC\uD6B0\uD6B9\uD6BB\uD6C4\uD6C5\uD6C8\uD6CC\uD6D1\uD6D4\uD6D7\uD6D9\uD6E0\uD6E4\uD6E8\uD6F0\uD6F5\uD6FC\uD6FD\uD700\uD704\uD711\uD718\uD719\uD71C\uD720\uD728\uD729\uD72B\uD72D\uD734\uD735\uD738\uD73C\uD744\uD747\uD749\uD750\uD751\uD754\uD756\uD757\uD758\uD759\uD760\uD761\uD763\uD765\uD769\uD76C\uD770\uD774\uD77C\uD77D\uD781\uD788\uD789\uD78C\uD790\uD798\uD799\uD79B\uD79D"],
    ["caa1", "\u4F3D\u4F73\u5047\u50F9\u52A0\u53EF\u5475\u54E5\u5609\u5AC1\u5BB6\u6687\u67B6\u67B7\u67EF\u6B4C\u73C2\u75C2\u7A3C\u82DB\u8304\u8857\u8888\u8A36\u8CC8\u8DCF\u8EFB\u8FE6\u99D5\u523B\u5374\u5404\u606A\u6164\u6BBC\u73CF\u811A\u89BA\u89D2\u95A3\u4F83\u520A\u58BE\u5978\u59E6\u5E72\u5E79\u61C7\u63C0\u6746\u67EC\u687F\u6F97\u764E\u770B\u78F5\u7A08\u7AFF\u7C21\u809D\u826E\u8271\u8AEB\u9593\u4E6B\u559D\u66F7\u6E34\u78A3\u7AED\u845B\u8910\u874E\u97A8\u52D8\u574E\u582A\u5D4C\u611F\u61BE\u6221\u6562\u67D1\u6A44\u6E1B\u7518\u75B3\u76E3\u77B0\u7D3A\u90AF\u9451\u9452\u9F95"],
    ["cba1", "\u5323\u5CAC\u7532\u80DB\u9240\u9598\u525B\u5808\u59DC\u5CA1\u5D17\u5EB7\u5F3A\u5F4A\u6177\u6C5F\u757A\u7586\u7CE0\u7D73\u7DB1\u7F8C\u8154\u8221\u8591\u8941\u8B1B\u92FC\u964D\u9C47\u4ECB\u4EF7\u500B\u51F1\u584F\u6137\u613E\u6168\u6539\u69EA\u6F11\u75A5\u7686\u76D6\u7B87\u82A5\u84CB\uF900\u93A7\u958B\u5580\u5BA2\u5751\uF901\u7CB3\u7FB9\u91B5\u5028\u53BB\u5C45\u5DE8\u62D2\u636E\u64DA\u64E7\u6E20\u70AC\u795B\u8DDD\u8E1E\uF902\u907D\u9245\u92F8\u4E7E\u4EF6\u5065\u5DFE\u5EFA\u6106\u6957\u8171\u8654\u8E47\u9375\u9A2B\u4E5E\u5091\u6770\u6840\u5109\u528D\u5292\u6AA2"],
    ["cca1", "\u77BC\u9210\u9ED4\u52AB\u602F\u8FF2\u5048\u61A9\u63ED\u64CA\u683C\u6A84\u6FC0\u8188\u89A1\u9694\u5805\u727D\u72AC\u7504\u7D79\u7E6D\u80A9\u898B\u8B74\u9063\u9D51\u6289\u6C7A\u6F54\u7D50\u7F3A\u8A23\u517C\u614A\u7B9D\u8B19\u9257\u938C\u4EAC\u4FD3\u501E\u50BE\u5106\u52C1\u52CD\u537F\u5770\u5883\u5E9A\u5F91\u6176\u61AC\u64CE\u656C\u666F\u66BB\u66F4\u6897\u6D87\u7085\u70F1\u749F\u74A5\u74CA\u75D9\u786C\u78EC\u7ADF\u7AF6\u7D45\u7D93\u8015\u803F\u811B\u8396\u8B66\u8F15\u9015\u93E1\u9803\u9838\u9A5A\u9BE8\u4FC2\u5553\u583A\u5951\u5B63\u5C46\u60B8\u6212\u6842\u68B0"],
    ["cda1", "\u68E8\u6EAA\u754C\u7678\u78CE\u7A3D\u7CFB\u7E6B\u7E7C\u8A08\u8AA1\u8C3F\u968E\u9DC4\u53E4\u53E9\u544A\u5471\u56FA\u59D1\u5B64\u5C3B\u5EAB\u62F7\u6537\u6545\u6572\u66A0\u67AF\u69C1\u6CBD\u75FC\u7690\u777E\u7A3F\u7F94\u8003\u80A1\u818F\u82E6\u82FD\u83F0\u85C1\u8831\u88B4\u8AA5\uF903\u8F9C\u932E\u96C7\u9867\u9AD8\u9F13\u54ED\u659B\u66F2\u688F\u7A40\u8C37\u9D60\u56F0\u5764\u5D11\u6606\u68B1\u68CD\u6EFE\u7428\u889E\u9BE4\u6C68\uF904\u9AA8\u4F9B\u516C\u5171\u529F\u5B54\u5DE5\u6050\u606D\u62F1\u63A7\u653B\u73D9\u7A7A\u86A3\u8CA2\u978F\u4E32\u5BE1\u6208\u679C\u74DC"],
    ["cea1", "\u79D1\u83D3\u8A87\u8AB2\u8DE8\u904E\u934B\u9846\u5ED3\u69E8\u85FF\u90ED\uF905\u51A0\u5B98\u5BEC\u6163\u68FA\u6B3E\u704C\u742F\u74D8\u7BA1\u7F50\u83C5\u89C0\u8CAB\u95DC\u9928\u522E\u605D\u62EC\u9002\u4F8A\u5149\u5321\u58D9\u5EE3\u66E0\u6D38\u709A\u72C2\u73D6\u7B50\u80F1\u945B\u5366\u639B\u7F6B\u4E56\u5080\u584A\u58DE\u602A\u6127\u62D0\u69D0\u9B41\u5B8F\u7D18\u80B1\u8F5F\u4EA4\u50D1\u54AC\u55AC\u5B0C\u5DA0\u5DE7\u652A\u654E\u6821\u6A4B\u72E1\u768E\u77EF\u7D5E\u7FF9\u81A0\u854E\u86DF\u8F03\u8F4E\u90CA\u9903\u9A55\u9BAB\u4E18\u4E45\u4E5D\u4EC7\u4FF1\u5177\u52FE"],
    ["cfa1", "\u5340\u53E3\u53E5\u548E\u5614\u5775\u57A2\u5BC7\u5D87\u5ED0\u61FC\u62D8\u6551\u67B8\u67E9\u69CB\u6B50\u6BC6\u6BEC\u6C42\u6E9D\u7078\u72D7\u7396\u7403\u77BF\u77E9\u7A76\u7D7F\u8009\u81FC\u8205\u820A\u82DF\u8862\u8B33\u8CFC\u8EC0\u9011\u90B1\u9264\u92B6\u99D2\u9A45\u9CE9\u9DD7\u9F9C\u570B\u5C40\u83CA\u97A0\u97AB\u9EB4\u541B\u7A98\u7FA4\u88D9\u8ECD\u90E1\u5800\u5C48\u6398\u7A9F\u5BAE\u5F13\u7A79\u7AAE\u828E\u8EAC\u5026\u5238\u52F8\u5377\u5708\u62F3\u6372\u6B0A\u6DC3\u7737\u53A5\u7357\u8568\u8E76\u95D5\u673A\u6AC3\u6F70\u8A6D\u8ECC\u994B\uF906\u6677\u6B78\u8CB4"],
    ["d0a1", "\u9B3C\uF907\u53EB\u572D\u594E\u63C6\u69FB\u73EA\u7845\u7ABA\u7AC5\u7CFE\u8475\u898F\u8D73\u9035\u95A8\u52FB\u5747\u7547\u7B60\u83CC\u921E\uF908\u6A58\u514B\u524B\u5287\u621F\u68D8\u6975\u9699\u50C5\u52A4\u52E4\u61C3\u65A4\u6839\u69FF\u747E\u7B4B\u82B9\u83EB\u89B2\u8B39\u8FD1\u9949\uF909\u4ECA\u5997\u64D2\u6611\u6A8E\u7434\u7981\u79BD\u82A9\u887E\u887F\u895F\uF90A\u9326\u4F0B\u53CA\u6025\u6271\u6C72\u7D1A\u7D66\u4E98\u5162\u77DC\u80AF\u4F01\u4F0E\u5176\u5180\u55DC\u5668\u573B\u57FA\u57FC\u5914\u5947\u5993\u5BC4\u5C90\u5D0E\u5DF1\u5E7E\u5FCC\u6280\u65D7\u65E3"],
    ["d1a1", "\u671E\u671F\u675E\u68CB\u68C4\u6A5F\u6B3A\u6C23\u6C7D\u6C82\u6DC7\u7398\u7426\u742A\u7482\u74A3\u7578\u757F\u7881\u78EF\u7941\u7947\u7948\u797A\u7B95\u7D00\u7DBA\u7F88\u8006\u802D\u808C\u8A18\u8B4F\u8C48\u8D77\u9321\u9324\u98E2\u9951\u9A0E\u9A0F\u9A65\u9E92\u7DCA\u4F76\u5409\u62EE\u6854\u91D1\u55AB\u513A\uF90B\uF90C\u5A1C\u61E6\uF90D\u62CF\u62FF\uF90E", 5, "\u90A3\uF914", 4, "\u8AFE\uF919\uF91A\uF91B\uF91C\u6696\uF91D\u7156\uF91E\uF91F\u96E3\uF920\u634F\u637A\u5357\uF921\u678F\u6960\u6E73\uF922\u7537\uF923\uF924\uF925"],
    ["d2a1", "\u7D0D\uF926\uF927\u8872\u56CA\u5A18\uF928", 4, "\u4E43\uF92D\u5167\u5948\u67F0\u8010\uF92E\u5973\u5E74\u649A\u79CA\u5FF5\u606C\u62C8\u637B\u5BE7\u5BD7\u52AA\uF92F\u5974\u5F29\u6012\uF930\uF931\uF932\u7459\uF933", 5, "\u99D1\uF939", 10, "\u6FC3\uF944\uF945\u81BF\u8FB2\u60F1\uF946\uF947\u8166\uF948\uF949\u5C3F\uF94A", 7, "\u5AE9\u8A25\u677B\u7D10\uF952", 5, "\u80FD\uF958\uF959\u5C3C\u6CE5\u533F\u6EBA\u591A\u8336"],
    ["d3a1", "\u4E39\u4EB6\u4F46\u55AE\u5718\u58C7\u5F56\u65B7\u65E6\u6A80\u6BB5\u6E4D\u77ED\u7AEF\u7C1E\u7DDE\u86CB\u8892\u9132\u935B\u64BB\u6FBE\u737A\u75B8\u9054\u5556\u574D\u61BA\u64D4\u66C7\u6DE1\u6E5B\u6F6D\u6FB9\u75F0\u8043\u81BD\u8541\u8983\u8AC7\u8B5A\u931F\u6C93\u7553\u7B54\u8E0F\u905D\u5510\u5802\u5858\u5E62\u6207\u649E\u68E0\u7576\u7CD6\u87B3\u9EE8\u4EE3\u5788\u576E\u5927\u5C0D\u5CB1\u5E36\u5F85\u6234\u64E1\u73B3\u81FA\u888B\u8CB8\u968A\u9EDB\u5B85\u5FB7\u60B3\u5012\u5200\u5230\u5716\u5835\u5857\u5C0E\u5C60\u5CF6\u5D8B\u5EA6\u5F92\u60BC\u6311\u6389\u6417\u6843"],
    ["d4a1", "\u68F9\u6AC2\u6DD8\u6E21\u6ED4\u6FE4\u71FE\u76DC\u7779\u79B1\u7A3B\u8404\u89A9\u8CED\u8DF3\u8E48\u9003\u9014\u9053\u90FD\u934D\u9676\u97DC\u6BD2\u7006\u7258\u72A2\u7368\u7763\u79BF\u7BE4\u7E9B\u8B80\u58A9\u60C7\u6566\u65FD\u66BE\u6C8C\u711E\u71C9\u8C5A\u9813\u4E6D\u7A81\u4EDD\u51AC\u51CD\u52D5\u540C\u61A7\u6771\u6850\u68DF\u6D1E\u6F7C\u75BC\u77B3\u7AE5\u80F4\u8463\u9285\u515C\u6597\u675C\u6793\u75D8\u7AC7\u8373\uF95A\u8C46\u9017\u982D\u5C6F\u81C0\u829A\u9041\u906F\u920D\u5F97\u5D9D\u6A59\u71C8\u767B\u7B49\u85E4\u8B04\u9127\u9A30\u5587\u61F6\uF95B\u7669\u7F85"],
    ["d5a1", "\u863F\u87BA\u88F8\u908F\uF95C\u6D1B\u70D9\u73DE\u7D61\u843D\uF95D\u916A\u99F1\uF95E\u4E82\u5375\u6B04\u6B12\u703E\u721B\u862D\u9E1E\u524C\u8FA3\u5D50\u64E5\u652C\u6B16\u6FEB\u7C43\u7E9C\u85CD\u8964\u89BD\u62C9\u81D8\u881F\u5ECA\u6717\u6D6A\u72FC\u7405\u746F\u8782\u90DE\u4F86\u5D0D\u5FA0\u840A\u51B7\u63A0\u7565\u4EAE\u5006\u5169\u51C9\u6881\u6A11\u7CAE\u7CB1\u7CE7\u826F\u8AD2\u8F1B\u91CF\u4FB6\u5137\u52F5\u5442\u5EEC\u616E\u623E\u65C5\u6ADA\u6FFE\u792A\u85DC\u8823\u95AD\u9A62\u9A6A\u9E97\u9ECE\u529B\u66C6\u6B77\u701D\u792B\u8F62\u9742\u6190\u6200\u6523\u6F23"],
    ["d6a1", "\u7149\u7489\u7DF4\u806F\u84EE\u8F26\u9023\u934A\u51BD\u5217\u52A3\u6D0C\u70C8\u88C2\u5EC9\u6582\u6BAE\u6FC2\u7C3E\u7375\u4EE4\u4F36\u56F9\uF95F\u5CBA\u5DBA\u601C\u73B2\u7B2D\u7F9A\u7FCE\u8046\u901E\u9234\u96F6\u9748\u9818\u9F61\u4F8B\u6FA7\u79AE\u91B4\u96B7\u52DE\uF960\u6488\u64C4\u6AD3\u6F5E\u7018\u7210\u76E7\u8001\u8606\u865C\u8DEF\u8F05\u9732\u9B6F\u9DFA\u9E75\u788C\u797F\u7DA0\u83C9\u9304\u9E7F\u9E93\u8AD6\u58DF\u5F04\u6727\u7027\u74CF\u7C60\u807E\u5121\u7028\u7262\u78CA\u8CC2\u8CDA\u8CF4\u96F7\u4E86\u50DA\u5BEE\u5ED6\u6599\u71CE\u7642\u77AD\u804A\u84FC"],
    ["d7a1", "\u907C\u9B27\u9F8D\u58D8\u5A41\u5C62\u6A13\u6DDA\u6F0F\u763B\u7D2F\u7E37\u851E\u8938\u93E4\u964B\u5289\u65D2\u67F3\u69B4\u6D41\u6E9C\u700F\u7409\u7460\u7559\u7624\u786B\u8B2C\u985E\u516D\u622E\u9678\u4F96\u502B\u5D19\u6DEA\u7DB8\u8F2A\u5F8B\u6144\u6817\uF961\u9686\u52D2\u808B\u51DC\u51CC\u695E\u7A1C\u7DBE\u83F1\u9675\u4FDA\u5229\u5398\u540F\u550E\u5C65\u60A7\u674E\u68A8\u6D6C\u7281\u72F8\u7406\u7483\uF962\u75E2\u7C6C\u7F79\u7FB8\u8389\u88CF\u88E1\u91CC\u91D0\u96E2\u9BC9\u541D\u6F7E\u71D0\u7498\u85FA\u8EAA\u96A3\u9C57\u9E9F\u6797\u6DCB\u7433\u81E8\u9716\u782C"],
    ["d8a1", "\u7ACB\u7B20\u7C92\u6469\u746A\u75F2\u78BC\u78E8\u99AC\u9B54\u9EBB\u5BDE\u5E55\u6F20\u819C\u83AB\u9088\u4E07\u534D\u5A29\u5DD2\u5F4E\u6162\u633D\u6669\u66FC\u6EFF\u6F2B\u7063\u779E\u842C\u8513\u883B\u8F13\u9945\u9C3B\u551C\u62B9\u672B\u6CAB\u8309\u896A\u977A\u4EA1\u5984\u5FD8\u5FD9\u671B\u7DB2\u7F54\u8292\u832B\u83BD\u8F1E\u9099\u57CB\u59B9\u5A92\u5BD0\u6627\u679A\u6885\u6BCF\u7164\u7F75\u8CB7\u8CE3\u9081\u9B45\u8108\u8C8A\u964C\u9A40\u9EA5\u5B5F\u6C13\u731B\u76F2\u76DF\u840C\u51AA\u8993\u514D\u5195\u52C9\u68C9\u6C94\u7704\u7720\u7DBF\u7DEC\u9762\u9EB5\u6EC5"],
    ["d9a1", "\u8511\u51A5\u540D\u547D\u660E\u669D\u6927\u6E9F\u76BF\u7791\u8317\u84C2\u879F\u9169\u9298\u9CF4\u8882\u4FAE\u5192\u52DF\u59C6\u5E3D\u6155\u6478\u6479\u66AE\u67D0\u6A21\u6BCD\u6BDB\u725F\u7261\u7441\u7738\u77DB\u8017\u82BC\u8305\u8B00\u8B28\u8C8C\u6728\u6C90\u7267\u76EE\u7766\u7A46\u9DA9\u6B7F\u6C92\u5922\u6726\u8499\u536F\u5893\u5999\u5EDF\u63CF\u6634\u6773\u6E3A\u732B\u7AD7\u82D7\u9328\u52D9\u5DEB\u61AE\u61CB\u620A\u62C7\u64AB\u65E0\u6959\u6B66\u6BCB\u7121\u73F7\u755D\u7E46\u821E\u8302\u856A\u8AA3\u8CBF\u9727\u9D61\u58A8\u9ED8\u5011\u520E\u543B\u554F\u6587"],
    ["daa1", "\u6C76\u7D0A\u7D0B\u805E\u868A\u9580\u96EF\u52FF\u6C95\u7269\u5473\u5A9A\u5C3E\u5D4B\u5F4C\u5FAE\u672A\u68B6\u6963\u6E3C\u6E44\u7709\u7C73\u7F8E\u8587\u8B0E\u8FF7\u9761\u9EF4\u5CB7\u60B6\u610D\u61AB\u654F\u65FB\u65FC\u6C11\u6CEF\u739F\u73C9\u7DE1\u9594\u5BC6\u871C\u8B10\u525D\u535A\u62CD\u640F\u64B2\u6734\u6A38\u6CCA\u73C0\u749E\u7B94\u7C95\u7E1B\u818A\u8236\u8584\u8FEB\u96F9\u99C1\u4F34\u534A\u53CD\u53DB\u62CC\u642C\u6500\u6591\u69C3\u6CEE\u6F58\u73ED\u7554\u7622\u76E4\u76FC\u78D0\u78FB\u792C\u7D46\u822C\u87E0\u8FD4\u9812\u98EF\u52C3\u62D4\u64A5\u6E24\u6F51"],
    ["dba1", "\u767C\u8DCB\u91B1\u9262\u9AEE\u9B43\u5023\u508D\u574A\u59A8\u5C28\u5E47\u5F77\u623F\u653E\u65B9\u65C1\u6609\u678B\u699C\u6EC2\u78C5\u7D21\u80AA\u8180\u822B\u82B3\u84A1\u868C\u8A2A\u8B17\u90A6\u9632\u9F90\u500D\u4FF3\uF963\u57F9\u5F98\u62DC\u6392\u676F\u6E43\u7119\u76C3\u80CC\u80DA\u88F4\u88F5\u8919\u8CE0\u8F29\u914D\u966A\u4F2F\u4F70\u5E1B\u67CF\u6822\u767D\u767E\u9B44\u5E61\u6A0A\u7169\u71D4\u756A\uF964\u7E41\u8543\u85E9\u98DC\u4F10\u7B4F\u7F70\u95A5\u51E1\u5E06\u68B5\u6C3E\u6C4E\u6CDB\u72AF\u7BC4\u8303\u6CD5\u743A\u50FB\u5288\u58C1\u64D8\u6A97\u74A7\u7656"],
    ["dca1", "\u78A7\u8617\u95E2\u9739\uF965\u535E\u5F01\u8B8A\u8FA8\u8FAF\u908A\u5225\u77A5\u9C49\u9F08\u4E19\u5002\u5175\u5C5B\u5E77\u661E\u663A\u67C4\u68C5\u70B3\u7501\u75C5\u79C9\u7ADD\u8F27\u9920\u9A08\u4FDD\u5821\u5831\u5BF6\u666E\u6B65\u6D11\u6E7A\u6F7D\u73E4\u752B\u83E9\u88DC\u8913\u8B5C\u8F14\u4F0F\u50D5\u5310\u535C\u5B93\u5FA9\u670D\u798F\u8179\u832F\u8514\u8907\u8986\u8F39\u8F3B\u99A5\u9C12\u672C\u4E76\u4FF8\u5949\u5C01\u5CEF\u5CF0\u6367\u68D2\u70FD\u71A2\u742B\u7E2B\u84EC\u8702\u9022\u92D2\u9CF3\u4E0D\u4ED8\u4FEF\u5085\u5256\u526F\u5426\u5490\u57E0\u592B\u5A66"],
    ["dda1", "\u5B5A\u5B75\u5BCC\u5E9C\uF966\u6276\u6577\u65A7\u6D6E\u6EA5\u7236\u7B26\u7C3F\u7F36\u8150\u8151\u819A\u8240\u8299\u83A9\u8A03\u8CA0\u8CE6\u8CFB\u8D74\u8DBA\u90E8\u91DC\u961C\u9644\u99D9\u9CE7\u5317\u5206\u5429\u5674\u58B3\u5954\u596E\u5FFF\u61A4\u626E\u6610\u6C7E\u711A\u76C6\u7C89\u7CDE\u7D1B\u82AC\u8CC1\u96F0\uF967\u4F5B\u5F17\u5F7F\u62C2\u5D29\u670B\u68DA\u787C\u7E43\u9D6C\u4E15\u5099\u5315\u532A\u5351\u5983\u5A62\u5E87\u60B2\u618A\u6249\u6279\u6590\u6787\u69A7\u6BD4\u6BD6\u6BD7\u6BD8\u6CB8\uF968\u7435\u75FA\u7812\u7891\u79D5\u79D8\u7C83\u7DCB\u7FE1\u80A5"],
    ["dea1", "\u813E\u81C2\u83F2\u871A\u88E8\u8AB9\u8B6C\u8CBB\u9119\u975E\u98DB\u9F3B\u56AC\u5B2A\u5F6C\u658C\u6AB3\u6BAF\u6D5C\u6FF1\u7015\u725D\u73AD\u8CA7\u8CD3\u983B\u6191\u6C37\u8058\u9A01\u4E4D\u4E8B\u4E9B\u4ED5\u4F3A\u4F3C\u4F7F\u4FDF\u50FF\u53F2\u53F8\u5506\u55E3\u56DB\u58EB\u5962\u5A11\u5BEB\u5BFA\u5C04\u5DF3\u5E2B\u5F99\u601D\u6368\u659C\u65AF\u67F6\u67FB\u68AD\u6B7B\u6C99\u6CD7\u6E23\u7009\u7345\u7802\u793E\u7940\u7960\u79C1\u7BE9\u7D17\u7D72\u8086\u820D\u838E\u84D1\u86C7\u88DF\u8A50\u8A5E\u8B1D\u8CDC\u8D66\u8FAD\u90AA\u98FC\u99DF\u9E9D\u524A\uF969\u6714\uF96A"],
    ["dfa1", "\u5098\u522A\u5C71\u6563\u6C55\u73CA\u7523\u759D\u7B97\u849C\u9178\u9730\u4E77\u6492\u6BBA\u715E\u85A9\u4E09\uF96B\u6749\u68EE\u6E17\u829F\u8518\u886B\u63F7\u6F81\u9212\u98AF\u4E0A\u50B7\u50CF\u511F\u5546\u55AA\u5617\u5B40\u5C19\u5CE0\u5E38\u5E8A\u5EA0\u5EC2\u60F3\u6851\u6A61\u6E58\u723D\u7240\u72C0\u76F8\u7965\u7BB1\u7FD4\u88F3\u89F4\u8A73\u8C61\u8CDE\u971C\u585E\u74BD\u8CFD\u55C7\uF96C\u7A61\u7D22\u8272\u7272\u751F\u7525\uF96D\u7B19\u5885\u58FB\u5DBC\u5E8F\u5EB6\u5F90\u6055\u6292\u637F\u654D\u6691\u66D9\u66F8\u6816\u68F2\u7280\u745E\u7B6E\u7D6E\u7DD6\u7F72"],
    ["e0a1", "\u80E5\u8212\u85AF\u897F\u8A93\u901D\u92E4\u9ECD\u9F20\u5915\u596D\u5E2D\u60DC\u6614\u6673\u6790\u6C50\u6DC5\u6F5F\u77F3\u78A9\u84C6\u91CB\u932B\u4ED9\u50CA\u5148\u5584\u5B0B\u5BA3\u6247\u657E\u65CB\u6E32\u717D\u7401\u7444\u7487\u74BF\u766C\u79AA\u7DDA\u7E55\u7FA8\u817A\u81B3\u8239\u861A\u87EC\u8A75\u8DE3\u9078\u9291\u9425\u994D\u9BAE\u5368\u5C51\u6954\u6CC4\u6D29\u6E2B\u820C\u859B\u893B\u8A2D\u8AAA\u96EA\u9F67\u5261\u66B9\u6BB2\u7E96\u87FE\u8D0D\u9583\u965D\u651D\u6D89\u71EE\uF96E\u57CE\u59D3\u5BAC\u6027\u60FA\u6210\u661F\u665F\u7329\u73F9\u76DB\u7701\u7B6C"],
    ["e1a1", "\u8056\u8072\u8165\u8AA0\u9192\u4E16\u52E2\u6B72\u6D17\u7A05\u7B39\u7D30\uF96F\u8CB0\u53EC\u562F\u5851\u5BB5\u5C0F\u5C11\u5DE2\u6240\u6383\u6414\u662D\u68B3\u6CBC\u6D88\u6EAF\u701F\u70A4\u71D2\u7526\u758F\u758E\u7619\u7B11\u7BE0\u7C2B\u7D20\u7D39\u852C\u856D\u8607\u8A34\u900D\u9061\u90B5\u92B7\u97F6\u9A37\u4FD7\u5C6C\u675F\u6D91\u7C9F\u7E8C\u8B16\u8D16\u901F\u5B6B\u5DFD\u640D\u84C0\u905C\u98E1\u7387\u5B8B\u609A\u677E\u6DDE\u8A1F\u8AA6\u9001\u980C\u5237\uF970\u7051\u788E\u9396\u8870\u91D7\u4FEE\u53D7\u55FD\u56DA\u5782\u58FD\u5AC2\u5B88\u5CAB\u5CC0\u5E25\u6101"],
    ["e2a1", "\u620D\u624B\u6388\u641C\u6536\u6578\u6A39\u6B8A\u6C34\u6D19\u6F31\u71E7\u72E9\u7378\u7407\u74B2\u7626\u7761\u79C0\u7A57\u7AEA\u7CB9\u7D8F\u7DAC\u7E61\u7F9E\u8129\u8331\u8490\u84DA\u85EA\u8896\u8AB0\u8B90\u8F38\u9042\u9083\u916C\u9296\u92B9\u968B\u96A7\u96A8\u96D6\u9700\u9808\u9996\u9AD3\u9B1A\u53D4\u587E\u5919\u5B70\u5BBF\u6DD1\u6F5A\u719F\u7421\u74B9\u8085\u83FD\u5DE1\u5F87\u5FAA\u6042\u65EC\u6812\u696F\u6A53\u6B89\u6D35\u6DF3\u73E3\u76FE\u77AC\u7B4D\u7D14\u8123\u821C\u8340\u84F4\u8563\u8A62\u8AC4\u9187\u931E\u9806\u99B4\u620C\u8853\u8FF0\u9265\u5D07\u5D27"],
    ["e3a1", "\u5D69\u745F\u819D\u8768\u6FD5\u62FE\u7FD2\u8936\u8972\u4E1E\u4E58\u50E7\u52DD\u5347\u627F\u6607\u7E69\u8805\u965E\u4F8D\u5319\u5636\u59CB\u5AA4\u5C38\u5C4E\u5C4D\u5E02\u5F11\u6043\u65BD\u662F\u6642\u67BE\u67F4\u731C\u77E2\u793A\u7FC5\u8494\u84CD\u8996\u8A66\u8A69\u8AE1\u8C55\u8C7A\u57F4\u5BD4\u5F0F\u606F\u62ED\u690D\u6B96\u6E5C\u7184\u7BD2\u8755\u8B58\u8EFE\u98DF\u98FE\u4F38\u4F81\u4FE1\u547B\u5A20\u5BB8\u613C\u65B0\u6668\u71FC\u7533\u795E\u7D33\u814E\u81E3\u8398\u85AA\u85CE\u8703\u8A0A\u8EAB\u8F9B\uF971\u8FC5\u5931\u5BA4\u5BE6\u6089\u5BE9\u5C0B\u5FC3\u6C81"],
    ["e4a1", "\uF972\u6DF1\u700B\u751A\u82AF\u8AF6\u4EC0\u5341\uF973\u96D9\u6C0F\u4E9E\u4FC4\u5152\u555E\u5A25\u5CE8\u6211\u7259\u82BD\u83AA\u86FE\u8859\u8A1D\u963F\u96C5\u9913\u9D09\u9D5D\u580A\u5CB3\u5DBD\u5E44\u60E1\u6115\u63E1\u6A02\u6E25\u9102\u9354\u984E\u9C10\u9F77\u5B89\u5CB8\u6309\u664F\u6848\u773C\u96C1\u978D\u9854\u9B9F\u65A1\u8B01\u8ECB\u95BC\u5535\u5CA9\u5DD6\u5EB5\u6697\u764C\u83F4\u95C7\u58D3\u62BC\u72CE\u9D28\u4EF0\u592E\u600F\u663B\u6B83\u79E7\u9D26\u5393\u54C0\u57C3\u5D16\u611B\u66D6\u6DAF\u788D\u827E\u9698\u9744\u5384\u627C\u6396\u6DB2\u7E0A\u814B\u984D"],
    ["e5a1", "\u6AFB\u7F4C\u9DAF\u9E1A\u4E5F\u503B\u51B6\u591C\u60F9\u63F6\u6930\u723A\u8036\uF974\u91CE\u5F31\uF975\uF976\u7D04\u82E5\u846F\u84BB\u85E5\u8E8D\uF977\u4F6F\uF978\uF979\u58E4\u5B43\u6059\u63DA\u6518\u656D\u6698\uF97A\u694A\u6A23\u6D0B\u7001\u716C\u75D2\u760D\u79B3\u7A70\uF97B\u7F8A\uF97C\u8944\uF97D\u8B93\u91C0\u967D\uF97E\u990A\u5704\u5FA1\u65BC\u6F01\u7600\u79A6\u8A9E\u99AD\u9B5A\u9F6C\u5104\u61B6\u6291\u6A8D\u81C6\u5043\u5830\u5F66\u7109\u8A00\u8AFA\u5B7C\u8616\u4FFA\u513C\u56B4\u5944\u63A9\u6DF9\u5DAA\u696D\u5186\u4E88\u4F59\uF97F\uF980\uF981\u5982\uF982"],
    ["e6a1", "\uF983\u6B5F\u6C5D\uF984\u74B5\u7916\uF985\u8207\u8245\u8339\u8F3F\u8F5D\uF986\u9918\uF987\uF988\uF989\u4EA6\uF98A\u57DF\u5F79\u6613\uF98B\uF98C\u75AB\u7E79\u8B6F\uF98D\u9006\u9A5B\u56A5\u5827\u59F8\u5A1F\u5BB4\uF98E\u5EF6\uF98F\uF990\u6350\u633B\uF991\u693D\u6C87\u6CBF\u6D8E\u6D93\u6DF5\u6F14\uF992\u70DF\u7136\u7159\uF993\u71C3\u71D5\uF994\u784F\u786F\uF995\u7B75\u7DE3\uF996\u7E2F\uF997\u884D\u8EDF\uF998\uF999\uF99A\u925B\uF99B\u9CF6\uF99C\uF99D\uF99E\u6085\u6D85\uF99F\u71B1\uF9A0\uF9A1\u95B1\u53AD\uF9A2\uF9A3\uF9A4\u67D3\uF9A5\u708E\u7130\u7430\u8276\u82D2"],
    ["e7a1", "\uF9A6\u95BB\u9AE5\u9E7D\u66C4\uF9A7\u71C1\u8449\uF9A8\uF9A9\u584B\uF9AA\uF9AB\u5DB8\u5F71\uF9AC\u6620\u668E\u6979\u69AE\u6C38\u6CF3\u6E36\u6F41\u6FDA\u701B\u702F\u7150\u71DF\u7370\uF9AD\u745B\uF9AE\u74D4\u76C8\u7A4E\u7E93\uF9AF\uF9B0\u82F1\u8A60\u8FCE\uF9B1\u9348\uF9B2\u9719\uF9B3\uF9B4\u4E42\u502A\uF9B5\u5208\u53E1\u66F3\u6C6D\u6FCA\u730A\u777F\u7A62\u82AE\u85DD\u8602\uF9B6\u88D4\u8A63\u8B7D\u8C6B\uF9B7\u92B3\uF9B8\u9713\u9810\u4E94\u4F0D\u4FC9\u50B2\u5348\u543E\u5433\u55DA\u5862\u58BA\u5967\u5A1B\u5BE4\u609F\uF9B9\u61CA\u6556\u65FF\u6664\u68A7\u6C5A\u6FB3"],
    ["e8a1", "\u70CF\u71AC\u7352\u7B7D\u8708\u8AA4\u9C32\u9F07\u5C4B\u6C83\u7344\u7389\u923A\u6EAB\u7465\u761F\u7A69\u7E15\u860A\u5140\u58C5\u64C1\u74EE\u7515\u7670\u7FC1\u9095\u96CD\u9954\u6E26\u74E6\u7AA9\u7AAA\u81E5\u86D9\u8778\u8A1B\u5A49\u5B8C\u5B9B\u68A1\u6900\u6D63\u73A9\u7413\u742C\u7897\u7DE9\u7FEB\u8118\u8155\u839E\u8C4C\u962E\u9811\u66F0\u5F80\u65FA\u6789\u6C6A\u738B\u502D\u5A03\u6B6A\u77EE\u5916\u5D6C\u5DCD\u7325\u754F\uF9BA\uF9BB\u50E5\u51F9\u582F\u592D\u5996\u59DA\u5BE5\uF9BC\uF9BD\u5DA2\u62D7\u6416\u6493\u64FE\uF9BE\u66DC\uF9BF\u6A48\uF9C0\u71FF\u7464\uF9C1"],
    ["e9a1", "\u7A88\u7AAF\u7E47\u7E5E\u8000\u8170\uF9C2\u87EF\u8981\u8B20\u9059\uF9C3\u9080\u9952\u617E\u6B32\u6D74\u7E1F\u8925\u8FB1\u4FD1\u50AD\u5197\u52C7\u57C7\u5889\u5BB9\u5EB8\u6142\u6995\u6D8C\u6E67\u6EB6\u7194\u7462\u7528\u752C\u8073\u8338\u84C9\u8E0A\u9394\u93DE\uF9C4\u4E8E\u4F51\u5076\u512A\u53C8\u53CB\u53F3\u5B87\u5BD3\u5C24\u611A\u6182\u65F4\u725B\u7397\u7440\u76C2\u7950\u7991\u79B9\u7D06\u7FBD\u828B\u85D5\u865E\u8FC2\u9047\u90F5\u91EA\u9685\u96E8\u96E9\u52D6\u5F67\u65ED\u6631\u682F\u715C\u7A36\u90C1\u980A\u4E91\uF9C5\u6A52\u6B9E\u6F90\u7189\u8018\u82B8\u8553"],
    ["eaa1", "\u904B\u9695\u96F2\u97FB\u851A\u9B31\u4E90\u718A\u96C4\u5143\u539F\u54E1\u5713\u5712\u57A3\u5A9B\u5AC4\u5BC3\u6028\u613F\u63F4\u6C85\u6D39\u6E72\u6E90\u7230\u733F\u7457\u82D1\u8881\u8F45\u9060\uF9C6\u9662\u9858\u9D1B\u6708\u8D8A\u925E\u4F4D\u5049\u50DE\u5371\u570D\u59D4\u5A01\u5C09\u6170\u6690\u6E2D\u7232\u744B\u7DEF\u80C3\u840E\u8466\u853F\u875F\u885B\u8918\u8B02\u9055\u97CB\u9B4F\u4E73\u4F91\u5112\u516A\uF9C7\u552F\u55A9\u5B7A\u5BA5\u5E7C\u5E7D\u5EBE\u60A0\u60DF\u6108\u6109\u63C4\u6538\u6709\uF9C8\u67D4\u67DA\uF9C9\u6961\u6962\u6CB9\u6D27\uF9CA\u6E38\uF9CB"],
    ["eba1", "\u6FE1\u7336\u7337\uF9CC\u745C\u7531\uF9CD\u7652\uF9CE\uF9CF\u7DAD\u81FE\u8438\u88D5\u8A98\u8ADB\u8AED\u8E30\u8E42\u904A\u903E\u907A\u9149\u91C9\u936E\uF9D0\uF9D1\u5809\uF9D2\u6BD3\u8089\u80B2\uF9D3\uF9D4\u5141\u596B\u5C39\uF9D5\uF9D6\u6F64\u73A7\u80E4\u8D07\uF9D7\u9217\u958F\uF9D8\uF9D9\uF9DA\uF9DB\u807F\u620E\u701C\u7D68\u878D\uF9DC\u57A0\u6069\u6147\u6BB7\u8ABE\u9280\u96B1\u4E59\u541F\u6DEB\u852D\u9670\u97F3\u98EE\u63D6\u6CE3\u9091\u51DD\u61C9\u81BA\u9DF9\u4F9D\u501A\u5100\u5B9C\u610F\u61FF\u64EC\u6905\u6BC5\u7591\u77E3\u7FA9\u8264\u858F\u87FB\u8863\u8ABC"],
    ["eca1", "\u8B70\u91AB\u4E8C\u4EE5\u4F0A\uF9DD\uF9DE\u5937\u59E8\uF9DF\u5DF2\u5F1B\u5F5B\u6021\uF9E0\uF9E1\uF9E2\uF9E3\u723E\u73E5\uF9E4\u7570\u75CD\uF9E5\u79FB\uF9E6\u800C\u8033\u8084\u82E1\u8351\uF9E7\uF9E8\u8CBD\u8CB3\u9087\uF9E9\uF9EA\u98F4\u990C\uF9EB\uF9EC\u7037\u76CA\u7FCA\u7FCC\u7FFC\u8B1A\u4EBA\u4EC1\u5203\u5370\uF9ED\u54BD\u56E0\u59FB\u5BC5\u5F15\u5FCD\u6E6E\uF9EE\uF9EF\u7D6A\u8335\uF9F0\u8693\u8A8D\uF9F1\u976D\u9777\uF9F2\uF9F3\u4E00\u4F5A\u4F7E\u58F9\u65E5\u6EA2\u9038\u93B0\u99B9\u4EFB\u58EC\u598A\u59D9\u6041\uF9F4\uF9F5\u7A14\uF9F6\u834F\u8CC3\u5165\u5344"],
    ["eda1", "\uF9F7\uF9F8\uF9F9\u4ECD\u5269\u5B55\u82BF\u4ED4\u523A\u54A8\u59C9\u59FF\u5B50\u5B57\u5B5C\u6063\u6148\u6ECB\u7099\u716E\u7386\u74F7\u75B5\u78C1\u7D2B\u8005\u81EA\u8328\u8517\u85C9\u8AEE\u8CC7\u96CC\u4F5C\u52FA\u56BC\u65AB\u6628\u707C\u70B8\u7235\u7DBD\u828D\u914C\u96C0\u9D72\u5B71\u68E7\u6B98\u6F7A\u76DE\u5C91\u66AB\u6F5B\u7BB4\u7C2A\u8836\u96DC\u4E08\u4ED7\u5320\u5834\u58BB\u58EF\u596C\u5C07\u5E33\u5E84\u5F35\u638C\u66B2\u6756\u6A1F\u6AA3\u6B0C\u6F3F\u7246\uF9FA\u7350\u748B\u7AE0\u7CA7\u8178\u81DF\u81E7\u838A\u846C\u8523\u8594\u85CF\u88DD\u8D13\u91AC\u9577"],
    ["eea1", "\u969C\u518D\u54C9\u5728\u5BB0\u624D\u6750\u683D\u6893\u6E3D\u6ED3\u707D\u7E21\u88C1\u8CA1\u8F09\u9F4B\u9F4E\u722D\u7B8F\u8ACD\u931A\u4F47\u4F4E\u5132\u5480\u59D0\u5E95\u62B5\u6775\u696E\u6A17\u6CAE\u6E1A\u72D9\u732A\u75BD\u7BB8\u7D35\u82E7\u83F9\u8457\u85F7\u8A5B\u8CAF\u8E87\u9019\u90B8\u96CE\u9F5F\u52E3\u540A\u5AE1\u5BC2\u6458\u6575\u6EF4\u72C4\uF9FB\u7684\u7A4D\u7B1B\u7C4D\u7E3E\u7FDF\u837B\u8B2B\u8CCA\u8D64\u8DE1\u8E5F\u8FEA\u8FF9\u9069\u93D1\u4F43\u4F7A\u50B3\u5168\u5178\u524D\u526A\u5861\u587C\u5960\u5C08\u5C55\u5EDB\u609B\u6230\u6813\u6BBF\u6C08\u6FB1"],
    ["efa1", "\u714E\u7420\u7530\u7538\u7551\u7672\u7B4C\u7B8B\u7BAD\u7BC6\u7E8F\u8A6E\u8F3E\u8F49\u923F\u9293\u9322\u942B\u96FB\u985A\u986B\u991E\u5207\u622A\u6298\u6D59\u7664\u7ACA\u7BC0\u7D76\u5360\u5CBE\u5E97\u6F38\u70B9\u7C98\u9711\u9B8E\u9EDE\u63A5\u647A\u8776\u4E01\u4E95\u4EAD\u505C\u5075\u5448\u59C3\u5B9A\u5E40\u5EAD\u5EF7\u5F81\u60C5\u633A\u653F\u6574\u65CC\u6676\u6678\u67FE\u6968\u6A89\u6B63\u6C40\u6DC0\u6DE8\u6E1F\u6E5E\u701E\u70A1\u738E\u73FD\u753A\u775B\u7887\u798E\u7A0B\u7A7D\u7CBE\u7D8E\u8247\u8A02\u8AEA\u8C9E\u912D\u914A\u91D8\u9266\u92CC\u9320\u9706\u9756"],
    ["f0a1", "\u975C\u9802\u9F0E\u5236\u5291\u557C\u5824\u5E1D\u5F1F\u608C\u63D0\u68AF\u6FDF\u796D\u7B2C\u81CD\u85BA\u88FD\u8AF8\u8E44\u918D\u9664\u969B\u973D\u984C\u9F4A\u4FCE\u5146\u51CB\u52A9\u5632\u5F14\u5F6B\u63AA\u64CD\u65E9\u6641\u66FA\u66F9\u671D\u689D\u68D7\u69FD\u6F15\u6F6E\u7167\u71E5\u722A\u74AA\u773A\u7956\u795A\u79DF\u7A20\u7A95\u7C97\u7CDF\u7D44\u7E70\u8087\u85FB\u86A4\u8A54\u8ABF\u8D99\u8E81\u9020\u906D\u91E3\u963B\u96D5\u9CE5\u65CF\u7C07\u8DB3\u93C3\u5B58\u5C0A\u5352\u62D9\u731D\u5027\u5B97\u5F9E\u60B0\u616B\u68D5\u6DD9\u742E\u7A2E\u7D42\u7D9C\u7E31\u816B"],
    ["f1a1", "\u8E2A\u8E35\u937E\u9418\u4F50\u5750\u5DE6\u5EA7\u632B\u7F6A\u4E3B\u4F4F\u4F8F\u505A\u59DD\u80C4\u546A\u5468\u55FE\u594F\u5B99\u5DDE\u5EDA\u665D\u6731\u67F1\u682A\u6CE8\u6D32\u6E4A\u6F8D\u70B7\u73E0\u7587\u7C4C\u7D02\u7D2C\u7DA2\u821F\u86DB\u8A3B\u8A85\u8D70\u8E8A\u8F33\u9031\u914E\u9152\u9444\u99D0\u7AF9\u7CA5\u4FCA\u5101\u51C6\u57C8\u5BEF\u5CFB\u6659\u6A3D\u6D5A\u6E96\u6FEC\u710C\u756F\u7AE3\u8822\u9021\u9075\u96CB\u99FF\u8301\u4E2D\u4EF2\u8846\u91CD\u537D\u6ADB\u696B\u6C41\u847A\u589E\u618E\u66FE\u62EF\u70DD\u7511\u75C7\u7E52\u84B8\u8B49\u8D08\u4E4B\u53EA"],
    ["f2a1", "\u54AB\u5730\u5740\u5FD7\u6301\u6307\u646F\u652F\u65E8\u667A\u679D\u67B3\u6B62\u6C60\u6C9A\u6F2C\u77E5\u7825\u7949\u7957\u7D19\u80A2\u8102\u81F3\u829D\u82B7\u8718\u8A8C\uF9FC\u8D04\u8DBE\u9072\u76F4\u7A19\u7A37\u7E54\u8077\u5507\u55D4\u5875\u632F\u6422\u6649\u664B\u686D\u699B\u6B84\u6D25\u6EB1\u73CD\u7468\u74A1\u755B\u75B9\u76E1\u771E\u778B\u79E6\u7E09\u7E1D\u81FB\u852F\u8897\u8A3A\u8CD1\u8EEB\u8FB0\u9032\u93AD\u9663\u9673\u9707\u4F84\u53F1\u59EA\u5AC9\u5E19\u684E\u74C6\u75BE\u79E9\u7A92\u81A3\u86ED\u8CEA\u8DCC\u8FED\u659F\u6715\uF9FD\u57F7\u6F57\u7DDD\u8F2F"],
    ["f3a1", "\u93F6\u96C6\u5FB5\u61F2\u6F84\u4E14\u4F98\u501F\u53C9\u55DF\u5D6F\u5DEE\u6B21\u6B64\u78CB\u7B9A\uF9FE\u8E49\u8ECA\u906E\u6349\u643E\u7740\u7A84\u932F\u947F\u9F6A\u64B0\u6FAF\u71E6\u74A8\u74DA\u7AC4\u7C12\u7E82\u7CB2\u7E98\u8B9A\u8D0A\u947D\u9910\u994C\u5239\u5BDF\u64E6\u672D\u7D2E\u50ED\u53C3\u5879\u6158\u6159\u61FA\u65AC\u7AD9\u8B92\u8B96\u5009\u5021\u5275\u5531\u5A3C\u5EE0\u5F70\u6134\u655E\u660C\u6636\u66A2\u69CD\u6EC4\u6F32\u7316\u7621\u7A93\u8139\u8259\u83D6\u84BC\u50B5\u57F0\u5BC0\u5BE8\u5F69\u63A1\u7826\u7DB5\u83DC\u8521\u91C7\u91F5\u518A\u67F5\u7B56"],
    ["f4a1", "\u8CAC\u51C4\u59BB\u60BD\u8655\u501C\uF9FF\u5254\u5C3A\u617D\u621A\u62D3\u64F2\u65A5\u6ECC\u7620\u810A\u8E60\u965F\u96BB\u4EDF\u5343\u5598\u5929\u5DDD\u64C5\u6CC9\u6DFA\u7394\u7A7F\u821B\u85A6\u8CE4\u8E10\u9077\u91E7\u95E1\u9621\u97C6\u51F8\u54F2\u5586\u5FB9\u64A4\u6F88\u7DB4\u8F1F\u8F4D\u9435\u50C9\u5C16\u6CBE\u6DFB\u751B\u77BB\u7C3D\u7C64\u8A79\u8AC2\u581E\u59BE\u5E16\u6377\u7252\u758A\u776B\u8ADC\u8CBC\u8F12\u5EF3\u6674\u6DF8\u807D\u83C1\u8ACB\u9751\u9BD6\uFA00\u5243\u66FF\u6D95\u6EEF\u7DE0\u8AE6\u902E\u905E\u9AD4\u521D\u527F\u54E8\u6194\u6284\u62DB\u68A2"],
    ["f5a1", "\u6912\u695A\u6A35\u7092\u7126\u785D\u7901\u790E\u79D2\u7A0D\u8096\u8278\u82D5\u8349\u8549\u8C82\u8D85\u9162\u918B\u91AE\u4FC3\u56D1\u71ED\u77D7\u8700\u89F8\u5BF8\u5FD6\u6751\u90A8\u53E2\u585A\u5BF5\u60A4\u6181\u6460\u7E3D\u8070\u8525\u9283\u64AE\u50AC\u5D14\u6700\u589C\u62BD\u63A8\u690E\u6978\u6A1E\u6E6B\u76BA\u79CB\u82BB\u8429\u8ACF\u8DA8\u8FFD\u9112\u914B\u919C\u9310\u9318\u939A\u96DB\u9A36\u9C0D\u4E11\u755C\u795D\u7AFA\u7B51\u7BC9\u7E2E\u84C4\u8E59\u8E74\u8EF8\u9010\u6625\u693F\u7443\u51FA\u672E\u9EDC\u5145\u5FE0\u6C96\u87F2\u885D\u8877\u60B4\u81B5\u8403"],
    ["f6a1", "\u8D05\u53D6\u5439\u5634\u5A36\u5C31\u708A\u7FE0\u805A\u8106\u81ED\u8DA3\u9189\u9A5F\u9DF2\u5074\u4EC4\u53A0\u60FB\u6E2C\u5C64\u4F88\u5024\u55E4\u5CD9\u5E5F\u6065\u6894\u6CBB\u6DC4\u71BE\u75D4\u75F4\u7661\u7A1A\u7A49\u7DC7\u7DFB\u7F6E\u81F4\u86A9\u8F1C\u96C9\u99B3\u9F52\u5247\u52C5\u98ED\u89AA\u4E03\u67D2\u6F06\u4FB5\u5BE2\u6795\u6C88\u6D78\u741B\u7827\u91DD\u937C\u87C4\u79E4\u7A31\u5FEB\u4ED6\u54A4\u553E\u58AE\u59A5\u60F0\u6253\u62D6\u6736\u6955\u8235\u9640\u99B1\u99DD\u502C\u5353\u5544\u577C\uFA01\u6258\uFA02\u64E2\u666B\u67DD\u6FC1\u6FEF\u7422\u7438\u8A17"],
    ["f7a1", "\u9438\u5451\u5606\u5766\u5F48\u619A\u6B4E\u7058\u70AD\u7DBB\u8A95\u596A\u812B\u63A2\u7708\u803D\u8CAA\u5854\u642D\u69BB\u5B95\u5E11\u6E6F\uFA03\u8569\u514C\u53F0\u592A\u6020\u614B\u6B86\u6C70\u6CF0\u7B1E\u80CE\u82D4\u8DC6\u90B0\u98B1\uFA04\u64C7\u6FA4\u6491\u6504\u514E\u5410\u571F\u8A0E\u615F\u6876\uFA05\u75DB\u7B52\u7D71\u901A\u5806\u69CC\u817F\u892A\u9000\u9839\u5078\u5957\u59AC\u6295\u900F\u9B2A\u615D\u7279\u95D6\u5761\u5A46\u5DF4\u628A\u64AD\u64FA\u6777\u6CE2\u6D3E\u722C\u7436\u7834\u7F77\u82AD\u8DDB\u9817\u5224\u5742\u677F\u7248\u74E3\u8CA9\u8FA6\u9211"],
    ["f8a1", "\u962A\u516B\u53ED\u634C\u4F69\u5504\u6096\u6557\u6C9B\u6D7F\u724C\u72FD\u7A17\u8987\u8C9D\u5F6D\u6F8E\u70F9\u81A8\u610E\u4FBF\u504F\u6241\u7247\u7BC7\u7DE8\u7FE9\u904D\u97AD\u9A19\u8CB6\u576A\u5E73\u67B0\u840D\u8A55\u5420\u5B16\u5E63\u5EE2\u5F0A\u6583\u80BA\u853D\u9589\u965B\u4F48\u5305\u530D\u530F\u5486\u54FA\u5703\u5E03\u6016\u629B\u62B1\u6355\uFA06\u6CE1\u6D66\u75B1\u7832\u80DE\u812F\u82DE\u8461\u84B2\u888D\u8912\u900B\u92EA\u98FD\u9B91\u5E45\u66B4\u66DD\u7011\u7206\uFA07\u4FF5\u527D\u5F6A\u6153\u6753\u6A19\u6F02\u74E2\u7968\u8868\u8C79\u98C7\u98C4\u9A43"],
    ["f9a1", "\u54C1\u7A1F\u6953\u8AF7\u8C4A\u98A8\u99AE\u5F7C\u62AB\u75B2\u76AE\u88AB\u907F\u9642\u5339\u5F3C\u5FC5\u6CCC\u73CC\u7562\u758B\u7B46\u82FE\u999D\u4E4F\u903C\u4E0B\u4F55\u53A6\u590F\u5EC8\u6630\u6CB3\u7455\u8377\u8766\u8CC0\u9050\u971E\u9C15\u58D1\u5B78\u8650\u8B14\u9DB4\u5BD2\u6068\u608D\u65F1\u6C57\u6F22\u6FA3\u701A\u7F55\u7FF0\u9591\u9592\u9650\u97D3\u5272\u8F44\u51FD\u542B\u54B8\u5563\u558A\u6ABB\u6DB5\u7DD8\u8266\u929C\u9677\u9E79\u5408\u54C8\u76D2\u86E4\u95A4\u95D4\u965C\u4EA2\u4F09\u59EE\u5AE6\u5DF7\u6052\u6297\u676D\u6841\u6C86\u6E2F\u7F38\u809B\u822A"],
    ["faa1", "\uFA08\uFA09\u9805\u4EA5\u5055\u54B3\u5793\u595A\u5B69\u5BB3\u61C8\u6977\u6D77\u7023\u87F9\u89E3\u8A72\u8AE7\u9082\u99ED\u9AB8\u52BE\u6838\u5016\u5E78\u674F\u8347\u884C\u4EAB\u5411\u56AE\u73E6\u9115\u97FF\u9909\u9957\u9999\u5653\u589F\u865B\u8A31\u61B2\u6AF6\u737B\u8ED2\u6B47\u96AA\u9A57\u5955\u7200\u8D6B\u9769\u4FD4\u5CF4\u5F26\u61F8\u665B\u6CEB\u70AB\u7384\u73B9\u73FE\u7729\u774D\u7D43\u7D62\u7E23\u8237\u8852\uFA0A\u8CE2\u9249\u986F\u5B51\u7A74\u8840\u9801\u5ACC\u4FE0\u5354\u593E\u5CFD\u633E\u6D79\u72F9\u8105\u8107\u83A2\u92CF\u9830\u4EA8\u5144\u5211\u578B"],
    ["fba1", "\u5F62\u6CC2\u6ECE\u7005\u7050\u70AF\u7192\u73E9\u7469\u834A\u87A2\u8861\u9008\u90A2\u93A3\u99A8\u516E\u5F57\u60E0\u6167\u66B3\u8559\u8E4A\u91AF\u978B\u4E4E\u4E92\u547C\u58D5\u58FA\u597D\u5CB5\u5F27\u6236\u6248\u660A\u6667\u6BEB\u6D69\u6DCF\u6E56\u6EF8\u6F94\u6FE0\u6FE9\u705D\u72D0\u7425\u745A\u74E0\u7693\u795C\u7CCA\u7E1E\u80E1\u82A6\u846B\u84BF\u864E\u865F\u8774\u8B77\u8C6A\u93AC\u9800\u9865\u60D1\u6216\u9177\u5A5A\u660F\u6DF7\u6E3E\u743F\u9B42\u5FFD\u60DA\u7B0F\u54C4\u5F18\u6C5E\u6CD3\u6D2A\u70D8\u7D05\u8679\u8A0C\u9D3B\u5316\u548C\u5B05\u6A3A\u706B\u7575"],
    ["fca1", "\u798D\u79BE\u82B1\u83EF\u8A71\u8B41\u8CA8\u9774\uFA0B\u64F4\u652B\u78BA\u78BB\u7A6B\u4E38\u559A\u5950\u5BA6\u5E7B\u60A3\u63DB\u6B61\u6665\u6853\u6E19\u7165\u74B0\u7D08\u9084\u9A69\u9C25\u6D3B\u6ED1\u733E\u8C41\u95CA\u51F0\u5E4C\u5FA8\u604D\u60F6\u6130\u614C\u6643\u6644\u69A5\u6CC1\u6E5F\u6EC9\u6F62\u714C\u749C\u7687\u7BC1\u7C27\u8352\u8757\u9051\u968D\u9EC3\u532F\u56DE\u5EFB\u5F8A\u6062\u6094\u61F7\u6666\u6703\u6A9C\u6DEE\u6FAE\u7070\u736A\u7E6A\u81BE\u8334\u86D4\u8AA8\u8CC4\u5283\u7372\u5B96\u6A6B\u9404\u54EE\u5686\u5B5D\u6548\u6585\u66C9\u689F\u6D8D\u6DC6"],
    ["fda1", "\u723B\u80B4\u9175\u9A4D\u4FAF\u5019\u539A\u540E\u543C\u5589\u55C5\u5E3F\u5F8C\u673D\u7166\u73DD\u9005\u52DB\u52F3\u5864\u58CE\u7104\u718F\u71FB\u85B0\u8A13\u6688\u85A8\u55A7\u6684\u714A\u8431\u5349\u5599\u6BC1\u5F59\u5FBD\u63EE\u6689\u7147\u8AF1\u8F1D\u9EBE\u4F11\u643A\u70CB\u7566\u8667\u6064\u8B4E\u9DF8\u5147\u51F6\u5308\u6D36\u80F8\u9ED1\u6615\u6B23\u7098\u75D5\u5403\u5C79\u7D07\u8A16\u6B20\u6B3D\u6B46\u5438\u6070\u6D3D\u7FD5\u8208\u50D6\u51DE\u559C\u566B\u56CD\u59EC\u5B09\u5E0C\u6199\u6198\u6231\u665E\u66E6\u7199\u71B9\u71BA\u72A7\u79A7\u7A00\u7FB2\u8A70"]
  ];
});

// ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/cp950.json
var require_cp950 = __commonJS((exports2, module2) => {
  module2.exports = [
    ["0", "\0", 127],
    ["a140", "\u3000\uFF0C\u3001\u3002\uFF0E\u2027\uFF1B\uFF1A\uFF1F\uFF01\uFE30\u2026\u2025\uFE50\uFE51\uFE52\xB7\uFE54\uFE55\uFE56\uFE57\uFF5C\u2013\uFE31\u2014\uFE33\u2574\uFE34\uFE4F\uFF08\uFF09\uFE35\uFE36\uFF5B\uFF5D\uFE37\uFE38\u3014\u3015\uFE39\uFE3A\u3010\u3011\uFE3B\uFE3C\u300A\u300B\uFE3D\uFE3E\u3008\u3009\uFE3F\uFE40\u300C\u300D\uFE41\uFE42\u300E\u300F\uFE43\uFE44\uFE59\uFE5A"],
    ["a1a1", "\uFE5B\uFE5C\uFE5D\uFE5E\u2018\u2019\u201C\u201D\u301D\u301E\u2035\u2032\uFF03\uFF06\uFF0A\u203B\xA7\u3003\u25CB\u25CF\u25B3\u25B2\u25CE\u2606\u2605\u25C7\u25C6\u25A1\u25A0\u25BD\u25BC\u32A3\u2105\xAF\uFFE3\uFF3F\u02CD\uFE49\uFE4A\uFE4D\uFE4E\uFE4B\uFE4C\uFE5F\uFE60\uFE61\uFF0B\uFF0D\xD7\xF7\xB1\u221A\uFF1C\uFF1E\uFF1D\u2266\u2267\u2260\u221E\u2252\u2261\uFE62", 4, "\uFF5E\u2229\u222A\u22A5\u2220\u221F\u22BF\u33D2\u33D1\u222B\u222E\u2235\u2234\u2640\u2642\u2295\u2299\u2191\u2193\u2190\u2192\u2196\u2197\u2199\u2198\u2225\u2223\uFF0F"],
    ["a240", "\uFF3C\u2215\uFE68\uFF04\uFFE5\u3012\uFFE0\uFFE1\uFF05\uFF20\u2103\u2109\uFE69\uFE6A\uFE6B\u33D5\u339C\u339D\u339E\u33CE\u33A1\u338E\u338F\u33C4\xB0\u5159\u515B\u515E\u515D\u5161\u5163\u55E7\u74E9\u7CCE\u2581", 7, "\u258F\u258E\u258D\u258C\u258B\u258A\u2589\u253C\u2534\u252C\u2524\u251C\u2594\u2500\u2502\u2595\u250C\u2510\u2514\u2518\u256D"],
    ["a2a1", "\u256E\u2570\u256F\u2550\u255E\u256A\u2561\u25E2\u25E3\u25E5\u25E4\u2571\u2572\u2573\uFF10", 9, "\u2160", 9, "\u3021", 8, "\u5341\u5344\u5345\uFF21", 25, "\uFF41", 21],
    ["a340", "\uFF57\uFF58\uFF59\uFF5A\u0391", 16, "\u03A3", 6, "\u03B1", 16, "\u03C3", 6, "\u3105", 10],
    ["a3a1", "\u3110", 25, "\u02D9\u02C9\u02CA\u02C7\u02CB"],
    ["a3e1", "\u20AC"],
    ["a440", "\u4E00\u4E59\u4E01\u4E03\u4E43\u4E5D\u4E86\u4E8C\u4EBA\u513F\u5165\u516B\u51E0\u5200\u5201\u529B\u5315\u5341\u535C\u53C8\u4E09\u4E0B\u4E08\u4E0A\u4E2B\u4E38\u51E1\u4E45\u4E48\u4E5F\u4E5E\u4E8E\u4EA1\u5140\u5203\u52FA\u5343\u53C9\u53E3\u571F\u58EB\u5915\u5927\u5973\u5B50\u5B51\u5B53\u5BF8\u5C0F\u5C22\u5C38\u5C71\u5DDD\u5DE5\u5DF1\u5DF2\u5DF3\u5DFE\u5E72\u5EFE\u5F0B\u5F13\u624D"],
    ["a4a1", "\u4E11\u4E10\u4E0D\u4E2D\u4E30\u4E39\u4E4B\u5C39\u4E88\u4E91\u4E95\u4E92\u4E94\u4EA2\u4EC1\u4EC0\u4EC3\u4EC6\u4EC7\u4ECD\u4ECA\u4ECB\u4EC4\u5143\u5141\u5167\u516D\u516E\u516C\u5197\u51F6\u5206\u5207\u5208\u52FB\u52FE\u52FF\u5316\u5339\u5348\u5347\u5345\u535E\u5384\u53CB\u53CA\u53CD\u58EC\u5929\u592B\u592A\u592D\u5B54\u5C11\u5C24\u5C3A\u5C6F\u5DF4\u5E7B\u5EFF\u5F14\u5F15\u5FC3\u6208\u6236\u624B\u624E\u652F\u6587\u6597\u65A4\u65B9\u65E5\u66F0\u6708\u6728\u6B20\u6B62\u6B79\u6BCB\u6BD4\u6BDB\u6C0F\u6C34\u706B\u722A\u7236\u723B\u7247\u7259\u725B\u72AC\u738B\u4E19"],
    ["a540", "\u4E16\u4E15\u4E14\u4E18\u4E3B\u4E4D\u4E4F\u4E4E\u4EE5\u4ED8\u4ED4\u4ED5\u4ED6\u4ED7\u4EE3\u4EE4\u4ED9\u4EDE\u5145\u5144\u5189\u518A\u51AC\u51F9\u51FA\u51F8\u520A\u52A0\u529F\u5305\u5306\u5317\u531D\u4EDF\u534A\u5349\u5361\u5360\u536F\u536E\u53BB\u53EF\u53E4\u53F3\u53EC\u53EE\u53E9\u53E8\u53FC\u53F8\u53F5\u53EB\u53E6\u53EA\u53F2\u53F1\u53F0\u53E5\u53ED\u53FB\u56DB\u56DA\u5916"],
    ["a5a1", "\u592E\u5931\u5974\u5976\u5B55\u5B83\u5C3C\u5DE8\u5DE7\u5DE6\u5E02\u5E03\u5E73\u5E7C\u5F01\u5F18\u5F17\u5FC5\u620A\u6253\u6254\u6252\u6251\u65A5\u65E6\u672E\u672C\u672A\u672B\u672D\u6B63\u6BCD\u6C11\u6C10\u6C38\u6C41\u6C40\u6C3E\u72AF\u7384\u7389\u74DC\u74E6\u7518\u751F\u7528\u7529\u7530\u7531\u7532\u7533\u758B\u767D\u76AE\u76BF\u76EE\u77DB\u77E2\u77F3\u793A\u79BE\u7A74\u7ACB\u4E1E\u4E1F\u4E52\u4E53\u4E69\u4E99\u4EA4\u4EA6\u4EA5\u4EFF\u4F09\u4F19\u4F0A\u4F15\u4F0D\u4F10\u4F11\u4F0F\u4EF2\u4EF6\u4EFB\u4EF0\u4EF3\u4EFD\u4F01\u4F0B\u5149\u5147\u5146\u5148\u5168"],
    ["a640", "\u5171\u518D\u51B0\u5217\u5211\u5212\u520E\u5216\u52A3\u5308\u5321\u5320\u5370\u5371\u5409\u540F\u540C\u540A\u5410\u5401\u540B\u5404\u5411\u540D\u5408\u5403\u540E\u5406\u5412\u56E0\u56DE\u56DD\u5733\u5730\u5728\u572D\u572C\u572F\u5729\u5919\u591A\u5937\u5938\u5984\u5978\u5983\u597D\u5979\u5982\u5981\u5B57\u5B58\u5B87\u5B88\u5B85\u5B89\u5BFA\u5C16\u5C79\u5DDE\u5E06\u5E76\u5E74"],
    ["a6a1", "\u5F0F\u5F1B\u5FD9\u5FD6\u620E\u620C\u620D\u6210\u6263\u625B\u6258\u6536\u65E9\u65E8\u65EC\u65ED\u66F2\u66F3\u6709\u673D\u6734\u6731\u6735\u6B21\u6B64\u6B7B\u6C16\u6C5D\u6C57\u6C59\u6C5F\u6C60\u6C50\u6C55\u6C61\u6C5B\u6C4D\u6C4E\u7070\u725F\u725D\u767E\u7AF9\u7C73\u7CF8\u7F36\u7F8A\u7FBD\u8001\u8003\u800C\u8012\u8033\u807F\u8089\u808B\u808C\u81E3\u81EA\u81F3\u81FC\u820C\u821B\u821F\u826E\u8272\u827E\u866B\u8840\u884C\u8863\u897F\u9621\u4E32\u4EA8\u4F4D\u4F4F\u4F47\u4F57\u4F5E\u4F34\u4F5B\u4F55\u4F30\u4F50\u4F51\u4F3D\u4F3A\u4F38\u4F43\u4F54\u4F3C\u4F46\u4F63"],
    ["a740", "\u4F5C\u4F60\u4F2F\u4F4E\u4F36\u4F59\u4F5D\u4F48\u4F5A\u514C\u514B\u514D\u5175\u51B6\u51B7\u5225\u5224\u5229\u522A\u5228\u52AB\u52A9\u52AA\u52AC\u5323\u5373\u5375\u541D\u542D\u541E\u543E\u5426\u544E\u5427\u5446\u5443\u5433\u5448\u5442\u541B\u5429\u544A\u5439\u543B\u5438\u542E\u5435\u5436\u5420\u543C\u5440\u5431\u542B\u541F\u542C\u56EA\u56F0\u56E4\u56EB\u574A\u5751\u5740\u574D"],
    ["a7a1", "\u5747\u574E\u573E\u5750\u574F\u573B\u58EF\u593E\u599D\u5992\u59A8\u599E\u59A3\u5999\u5996\u598D\u59A4\u5993\u598A\u59A5\u5B5D\u5B5C\u5B5A\u5B5B\u5B8C\u5B8B\u5B8F\u5C2C\u5C40\u5C41\u5C3F\u5C3E\u5C90\u5C91\u5C94\u5C8C\u5DEB\u5E0C\u5E8F\u5E87\u5E8A\u5EF7\u5F04\u5F1F\u5F64\u5F62\u5F77\u5F79\u5FD8\u5FCC\u5FD7\u5FCD\u5FF1\u5FEB\u5FF8\u5FEA\u6212\u6211\u6284\u6297\u6296\u6280\u6276\u6289\u626D\u628A\u627C\u627E\u6279\u6273\u6292\u626F\u6298\u626E\u6295\u6293\u6291\u6286\u6539\u653B\u6538\u65F1\u66F4\u675F\u674E\u674F\u6750\u6751\u675C\u6756\u675E\u6749\u6746\u6760"],
    ["a840", "\u6753\u6757\u6B65\u6BCF\u6C42\u6C5E\u6C99\u6C81\u6C88\u6C89\u6C85\u6C9B\u6C6A\u6C7A\u6C90\u6C70\u6C8C\u6C68\u6C96\u6C92\u6C7D\u6C83\u6C72\u6C7E\u6C74\u6C86\u6C76\u6C8D\u6C94\u6C98\u6C82\u7076\u707C\u707D\u7078\u7262\u7261\u7260\u72C4\u72C2\u7396\u752C\u752B\u7537\u7538\u7682\u76EF\u77E3\u79C1\u79C0\u79BF\u7A76\u7CFB\u7F55\u8096\u8093\u809D\u8098\u809B\u809A\u80B2\u826F\u8292"],
    ["a8a1", "\u828B\u828D\u898B\u89D2\u8A00\u8C37\u8C46\u8C55\u8C9D\u8D64\u8D70\u8DB3\u8EAB\u8ECA\u8F9B\u8FB0\u8FC2\u8FC6\u8FC5\u8FC4\u5DE1\u9091\u90A2\u90AA\u90A6\u90A3\u9149\u91C6\u91CC\u9632\u962E\u9631\u962A\u962C\u4E26\u4E56\u4E73\u4E8B\u4E9B\u4E9E\u4EAB\u4EAC\u4F6F\u4F9D\u4F8D\u4F73\u4F7F\u4F6C\u4F9B\u4F8B\u4F86\u4F83\u4F70\u4F75\u4F88\u4F69\u4F7B\u4F96\u4F7E\u4F8F\u4F91\u4F7A\u5154\u5152\u5155\u5169\u5177\u5176\u5178\u51BD\u51FD\u523B\u5238\u5237\u523A\u5230\u522E\u5236\u5241\u52BE\u52BB\u5352\u5354\u5353\u5351\u5366\u5377\u5378\u5379\u53D6\u53D4\u53D7\u5473\u5475"],
    ["a940", "\u5496\u5478\u5495\u5480\u547B\u5477\u5484\u5492\u5486\u547C\u5490\u5471\u5476\u548C\u549A\u5462\u5468\u548B\u547D\u548E\u56FA\u5783\u5777\u576A\u5769\u5761\u5766\u5764\u577C\u591C\u5949\u5947\u5948\u5944\u5954\u59BE\u59BB\u59D4\u59B9\u59AE\u59D1\u59C6\u59D0\u59CD\u59CB\u59D3\u59CA\u59AF\u59B3\u59D2\u59C5\u5B5F\u5B64\u5B63\u5B97\u5B9A\u5B98\u5B9C\u5B99\u5B9B\u5C1A\u5C48\u5C45"],
    ["a9a1", "\u5C46\u5CB7\u5CA1\u5CB8\u5CA9\u5CAB\u5CB1\u5CB3\u5E18\u5E1A\u5E16\u5E15\u5E1B\u5E11\u5E78\u5E9A\u5E97\u5E9C\u5E95\u5E96\u5EF6\u5F26\u5F27\u5F29\u5F80\u5F81\u5F7F\u5F7C\u5FDD\u5FE0\u5FFD\u5FF5\u5FFF\u600F\u6014\u602F\u6035\u6016\u602A\u6015\u6021\u6027\u6029\u602B\u601B\u6216\u6215\u623F\u623E\u6240\u627F\u62C9\u62CC\u62C4\u62BF\u62C2\u62B9\u62D2\u62DB\u62AB\u62D3\u62D4\u62CB\u62C8\u62A8\u62BD\u62BC\u62D0\u62D9\u62C7\u62CD\u62B5\u62DA\u62B1\u62D8\u62D6\u62D7\u62C6\u62AC\u62CE\u653E\u65A7\u65BC\u65FA\u6614\u6613\u660C\u6606\u6602\u660E\u6600\u660F\u6615\u660A"],
    ["aa40", "\u6607\u670D\u670B\u676D\u678B\u6795\u6771\u679C\u6773\u6777\u6787\u679D\u6797\u676F\u6770\u677F\u6789\u677E\u6790\u6775\u679A\u6793\u677C\u676A\u6772\u6B23\u6B66\u6B67\u6B7F\u6C13\u6C1B\u6CE3\u6CE8\u6CF3\u6CB1\u6CCC\u6CE5\u6CB3\u6CBD\u6CBE\u6CBC\u6CE2\u6CAB\u6CD5\u6CD3\u6CB8\u6CC4\u6CB9\u6CC1\u6CAE\u6CD7\u6CC5\u6CF1\u6CBF\u6CBB\u6CE1\u6CDB\u6CCA\u6CAC\u6CEF\u6CDC\u6CD6\u6CE0"],
    ["aaa1", "\u7095\u708E\u7092\u708A\u7099\u722C\u722D\u7238\u7248\u7267\u7269\u72C0\u72CE\u72D9\u72D7\u72D0\u73A9\u73A8\u739F\u73AB\u73A5\u753D\u759D\u7599\u759A\u7684\u76C2\u76F2\u76F4\u77E5\u77FD\u793E\u7940\u7941\u79C9\u79C8\u7A7A\u7A79\u7AFA\u7CFE\u7F54\u7F8C\u7F8B\u8005\u80BA\u80A5\u80A2\u80B1\u80A1\u80AB\u80A9\u80B4\u80AA\u80AF\u81E5\u81FE\u820D\u82B3\u829D\u8299\u82AD\u82BD\u829F\u82B9\u82B1\u82AC\u82A5\u82AF\u82B8\u82A3\u82B0\u82BE\u82B7\u864E\u8671\u521D\u8868\u8ECB\u8FCE\u8FD4\u8FD1\u90B5\u90B8\u90B1\u90B6\u91C7\u91D1\u9577\u9580\u961C\u9640\u963F\u963B\u9644"],
    ["ab40", "\u9642\u96B9\u96E8\u9752\u975E\u4E9F\u4EAD\u4EAE\u4FE1\u4FB5\u4FAF\u4FBF\u4FE0\u4FD1\u4FCF\u4FDD\u4FC3\u4FB6\u4FD8\u4FDF\u4FCA\u4FD7\u4FAE\u4FD0\u4FC4\u4FC2\u4FDA\u4FCE\u4FDE\u4FB7\u5157\u5192\u5191\u51A0\u524E\u5243\u524A\u524D\u524C\u524B\u5247\u52C7\u52C9\u52C3\u52C1\u530D\u5357\u537B\u539A\u53DB\u54AC\u54C0\u54A8\u54CE\u54C9\u54B8\u54A6\u54B3\u54C7\u54C2\u54BD\u54AA\u54C1"],
    ["aba1", "\u54C4\u54C8\u54AF\u54AB\u54B1\u54BB\u54A9\u54A7\u54BF\u56FF\u5782\u578B\u57A0\u57A3\u57A2\u57CE\u57AE\u5793\u5955\u5951\u594F\u594E\u5950\u59DC\u59D8\u59FF\u59E3\u59E8\u5A03\u59E5\u59EA\u59DA\u59E6\u5A01\u59FB\u5B69\u5BA3\u5BA6\u5BA4\u5BA2\u5BA5\u5C01\u5C4E\u5C4F\u5C4D\u5C4B\u5CD9\u5CD2\u5DF7\u5E1D\u5E25\u5E1F\u5E7D\u5EA0\u5EA6\u5EFA\u5F08\u5F2D\u5F65\u5F88\u5F85\u5F8A\u5F8B\u5F87\u5F8C\u5F89\u6012\u601D\u6020\u6025\u600E\u6028\u604D\u6070\u6068\u6062\u6046\u6043\u606C\u606B\u606A\u6064\u6241\u62DC\u6316\u6309\u62FC\u62ED\u6301\u62EE\u62FD\u6307\u62F1\u62F7"],
    ["ac40", "\u62EF\u62EC\u62FE\u62F4\u6311\u6302\u653F\u6545\u65AB\u65BD\u65E2\u6625\u662D\u6620\u6627\u662F\u661F\u6628\u6631\u6624\u66F7\u67FF\u67D3\u67F1\u67D4\u67D0\u67EC\u67B6\u67AF\u67F5\u67E9\u67EF\u67C4\u67D1\u67B4\u67DA\u67E5\u67B8\u67CF\u67DE\u67F3\u67B0\u67D9\u67E2\u67DD\u67D2\u6B6A\u6B83\u6B86\u6BB5\u6BD2\u6BD7\u6C1F\u6CC9\u6D0B\u6D32\u6D2A\u6D41\u6D25\u6D0C\u6D31\u6D1E\u6D17"],
    ["aca1", "\u6D3B\u6D3D\u6D3E\u6D36\u6D1B\u6CF5\u6D39\u6D27\u6D38\u6D29\u6D2E\u6D35\u6D0E\u6D2B\u70AB\u70BA\u70B3\u70AC\u70AF\u70AD\u70B8\u70AE\u70A4\u7230\u7272\u726F\u7274\u72E9\u72E0\u72E1\u73B7\u73CA\u73BB\u73B2\u73CD\u73C0\u73B3\u751A\u752D\u754F\u754C\u754E\u754B\u75AB\u75A4\u75A5\u75A2\u75A3\u7678\u7686\u7687\u7688\u76C8\u76C6\u76C3\u76C5\u7701\u76F9\u76F8\u7709\u770B\u76FE\u76FC\u7707\u77DC\u7802\u7814\u780C\u780D\u7946\u7949\u7948\u7947\u79B9\u79BA\u79D1\u79D2\u79CB\u7A7F\u7A81\u7AFF\u7AFD\u7C7D\u7D02\u7D05\u7D00\u7D09\u7D07\u7D04\u7D06\u7F38\u7F8E\u7FBF\u8004"],
    ["ad40", "\u8010\u800D\u8011\u8036\u80D6\u80E5\u80DA\u80C3\u80C4\u80CC\u80E1\u80DB\u80CE\u80DE\u80E4\u80DD\u81F4\u8222\u82E7\u8303\u8305\u82E3\u82DB\u82E6\u8304\u82E5\u8302\u8309\u82D2\u82D7\u82F1\u8301\u82DC\u82D4\u82D1\u82DE\u82D3\u82DF\u82EF\u8306\u8650\u8679\u867B\u867A\u884D\u886B\u8981\u89D4\u8A08\u8A02\u8A03\u8C9E\u8CA0\u8D74\u8D73\u8DB4\u8ECD\u8ECC\u8FF0\u8FE6\u8FE2\u8FEA\u8FE5"],
    ["ada1", "\u8FED\u8FEB\u8FE4\u8FE8\u90CA\u90CE\u90C1\u90C3\u914B\u914A\u91CD\u9582\u9650\u964B\u964C\u964D\u9762\u9769\u97CB\u97ED\u97F3\u9801\u98A8\u98DB\u98DF\u9996\u9999\u4E58\u4EB3\u500C\u500D\u5023\u4FEF\u5026\u5025\u4FF8\u5029\u5016\u5006\u503C\u501F\u501A\u5012\u5011\u4FFA\u5000\u5014\u5028\u4FF1\u5021\u500B\u5019\u5018\u4FF3\u4FEE\u502D\u502A\u4FFE\u502B\u5009\u517C\u51A4\u51A5\u51A2\u51CD\u51CC\u51C6\u51CB\u5256\u525C\u5254\u525B\u525D\u532A\u537F\u539F\u539D\u53DF\u54E8\u5510\u5501\u5537\u54FC\u54E5\u54F2\u5506\u54FA\u5514\u54E9\u54ED\u54E1\u5509\u54EE\u54EA"],
    ["ae40", "\u54E6\u5527\u5507\u54FD\u550F\u5703\u5704\u57C2\u57D4\u57CB\u57C3\u5809\u590F\u5957\u5958\u595A\u5A11\u5A18\u5A1C\u5A1F\u5A1B\u5A13\u59EC\u5A20\u5A23\u5A29\u5A25\u5A0C\u5A09\u5B6B\u5C58\u5BB0\u5BB3\u5BB6\u5BB4\u5BAE\u5BB5\u5BB9\u5BB8\u5C04\u5C51\u5C55\u5C50\u5CED\u5CFD\u5CFB\u5CEA\u5CE8\u5CF0\u5CF6\u5D01\u5CF4\u5DEE\u5E2D\u5E2B\u5EAB\u5EAD\u5EA7\u5F31\u5F92\u5F91\u5F90\u6059"],
    ["aea1", "\u6063\u6065\u6050\u6055\u606D\u6069\u606F\u6084\u609F\u609A\u608D\u6094\u608C\u6085\u6096\u6247\u62F3\u6308\u62FF\u634E\u633E\u632F\u6355\u6342\u6346\u634F\u6349\u633A\u6350\u633D\u632A\u632B\u6328\u634D\u634C\u6548\u6549\u6599\u65C1\u65C5\u6642\u6649\u664F\u6643\u6652\u664C\u6645\u6641\u66F8\u6714\u6715\u6717\u6821\u6838\u6848\u6846\u6853\u6839\u6842\u6854\u6829\u68B3\u6817\u684C\u6851\u683D\u67F4\u6850\u6840\u683C\u6843\u682A\u6845\u6813\u6818\u6841\u6B8A\u6B89\u6BB7\u6C23\u6C27\u6C28\u6C26\u6C24\u6CF0\u6D6A\u6D95\u6D88\u6D87\u6D66\u6D78\u6D77\u6D59\u6D93"],
    ["af40", "\u6D6C\u6D89\u6D6E\u6D5A\u6D74\u6D69\u6D8C\u6D8A\u6D79\u6D85\u6D65\u6D94\u70CA\u70D8\u70E4\u70D9\u70C8\u70CF\u7239\u7279\u72FC\u72F9\u72FD\u72F8\u72F7\u7386\u73ED\u7409\u73EE\u73E0\u73EA\u73DE\u7554\u755D\u755C\u755A\u7559\u75BE\u75C5\u75C7\u75B2\u75B3\u75BD\u75BC\u75B9\u75C2\u75B8\u768B\u76B0\u76CA\u76CD\u76CE\u7729\u771F\u7720\u7728\u77E9\u7830\u7827\u7838\u781D\u7834\u7837"],
    ["afa1", "\u7825\u782D\u7820\u781F\u7832\u7955\u7950\u7960\u795F\u7956\u795E\u795D\u7957\u795A\u79E4\u79E3\u79E7\u79DF\u79E6\u79E9\u79D8\u7A84\u7A88\u7AD9\u7B06\u7B11\u7C89\u7D21\u7D17\u7D0B\u7D0A\u7D20\u7D22\u7D14\u7D10\u7D15\u7D1A\u7D1C\u7D0D\u7D19\u7D1B\u7F3A\u7F5F\u7F94\u7FC5\u7FC1\u8006\u8018\u8015\u8019\u8017\u803D\u803F\u80F1\u8102\u80F0\u8105\u80ED\u80F4\u8106\u80F8\u80F3\u8108\u80FD\u810A\u80FC\u80EF\u81ED\u81EC\u8200\u8210\u822A\u822B\u8228\u822C\u82BB\u832B\u8352\u8354\u834A\u8338\u8350\u8349\u8335\u8334\u834F\u8332\u8339\u8336\u8317\u8340\u8331\u8328\u8343"],
    ["b040", "\u8654\u868A\u86AA\u8693\u86A4\u86A9\u868C\u86A3\u869C\u8870\u8877\u8881\u8882\u887D\u8879\u8A18\u8A10\u8A0E\u8A0C\u8A15\u8A0A\u8A17\u8A13\u8A16\u8A0F\u8A11\u8C48\u8C7A\u8C79\u8CA1\u8CA2\u8D77\u8EAC\u8ED2\u8ED4\u8ECF\u8FB1\u9001\u9006\u8FF7\u9000\u8FFA\u8FF4\u9003\u8FFD\u9005\u8FF8\u9095\u90E1\u90DD\u90E2\u9152\u914D\u914C\u91D8\u91DD\u91D7\u91DC\u91D9\u9583\u9662\u9663\u9661"],
    ["b0a1", "\u965B\u965D\u9664\u9658\u965E\u96BB\u98E2\u99AC\u9AA8\u9AD8\u9B25\u9B32\u9B3C\u4E7E\u507A\u507D\u505C\u5047\u5043\u504C\u505A\u5049\u5065\u5076\u504E\u5055\u5075\u5074\u5077\u504F\u500F\u506F\u506D\u515C\u5195\u51F0\u526A\u526F\u52D2\u52D9\u52D8\u52D5\u5310\u530F\u5319\u533F\u5340\u533E\u53C3\u66FC\u5546\u556A\u5566\u5544\u555E\u5561\u5543\u554A\u5531\u5556\u554F\u5555\u552F\u5564\u5538\u552E\u555C\u552C\u5563\u5533\u5541\u5557\u5708\u570B\u5709\u57DF\u5805\u580A\u5806\u57E0\u57E4\u57FA\u5802\u5835\u57F7\u57F9\u5920\u5962\u5A36\u5A41\u5A49\u5A66\u5A6A\u5A40"],
    ["b140", "\u5A3C\u5A62\u5A5A\u5A46\u5A4A\u5B70\u5BC7\u5BC5\u5BC4\u5BC2\u5BBF\u5BC6\u5C09\u5C08\u5C07\u5C60\u5C5C\u5C5D\u5D07\u5D06\u5D0E\u5D1B\u5D16\u5D22\u5D11\u5D29\u5D14\u5D19\u5D24\u5D27\u5D17\u5DE2\u5E38\u5E36\u5E33\u5E37\u5EB7\u5EB8\u5EB6\u5EB5\u5EBE\u5F35\u5F37\u5F57\u5F6C\u5F69\u5F6B\u5F97\u5F99\u5F9E\u5F98\u5FA1\u5FA0\u5F9C\u607F\u60A3\u6089\u60A0\u60A8\u60CB\u60B4\u60E6\u60BD"],
    ["b1a1", "\u60C5\u60BB\u60B5\u60DC\u60BC\u60D8\u60D5\u60C6\u60DF\u60B8\u60DA\u60C7\u621A\u621B\u6248\u63A0\u63A7\u6372\u6396\u63A2\u63A5\u6377\u6367\u6398\u63AA\u6371\u63A9\u6389\u6383\u639B\u636B\u63A8\u6384\u6388\u6399\u63A1\u63AC\u6392\u638F\u6380\u637B\u6369\u6368\u637A\u655D\u6556\u6551\u6559\u6557\u555F\u654F\u6558\u6555\u6554\u659C\u659B\u65AC\u65CF\u65CB\u65CC\u65CE\u665D\u665A\u6664\u6668\u6666\u665E\u66F9\u52D7\u671B\u6881\u68AF\u68A2\u6893\u68B5\u687F\u6876\u68B1\u68A7\u6897\u68B0\u6883\u68C4\u68AD\u6886\u6885\u6894\u689D\u68A8\u689F\u68A1\u6882\u6B32\u6BBA"],
    ["b240", "\u6BEB\u6BEC\u6C2B\u6D8E\u6DBC\u6DF3\u6DD9\u6DB2\u6DE1\u6DCC\u6DE4\u6DFB\u6DFA\u6E05\u6DC7\u6DCB\u6DAF\u6DD1\u6DAE\u6DDE\u6DF9\u6DB8\u6DF7\u6DF5\u6DC5\u6DD2\u6E1A\u6DB5\u6DDA\u6DEB\u6DD8\u6DEA\u6DF1\u6DEE\u6DE8\u6DC6\u6DC4\u6DAA\u6DEC\u6DBF\u6DE6\u70F9\u7109\u710A\u70FD\u70EF\u723D\u727D\u7281\u731C\u731B\u7316\u7313\u7319\u7387\u7405\u740A\u7403\u7406\u73FE\u740D\u74E0\u74F6"],
    ["b2a1", "\u74F7\u751C\u7522\u7565\u7566\u7562\u7570\u758F\u75D4\u75D5\u75B5\u75CA\u75CD\u768E\u76D4\u76D2\u76DB\u7737\u773E\u773C\u7736\u7738\u773A\u786B\u7843\u784E\u7965\u7968\u796D\u79FB\u7A92\u7A95\u7B20\u7B28\u7B1B\u7B2C\u7B26\u7B19\u7B1E\u7B2E\u7C92\u7C97\u7C95\u7D46\u7D43\u7D71\u7D2E\u7D39\u7D3C\u7D40\u7D30\u7D33\u7D44\u7D2F\u7D42\u7D32\u7D31\u7F3D\u7F9E\u7F9A\u7FCC\u7FCE\u7FD2\u801C\u804A\u8046\u812F\u8116\u8123\u812B\u8129\u8130\u8124\u8202\u8235\u8237\u8236\u8239\u838E\u839E\u8398\u8378\u83A2\u8396\u83BD\u83AB\u8392\u838A\u8393\u8389\u83A0\u8377\u837B\u837C"],
    ["b340", "\u8386\u83A7\u8655\u5F6A\u86C7\u86C0\u86B6\u86C4\u86B5\u86C6\u86CB\u86B1\u86AF\u86C9\u8853\u889E\u8888\u88AB\u8892\u8896\u888D\u888B\u8993\u898F\u8A2A\u8A1D\u8A23\u8A25\u8A31\u8A2D\u8A1F\u8A1B\u8A22\u8C49\u8C5A\u8CA9\u8CAC\u8CAB\u8CA8\u8CAA\u8CA7\u8D67\u8D66\u8DBE\u8DBA\u8EDB\u8EDF\u9019\u900D\u901A\u9017\u9023\u901F\u901D\u9010\u9015\u901E\u9020\u900F\u9022\u9016\u901B\u9014"],
    ["b3a1", "\u90E8\u90ED\u90FD\u9157\u91CE\u91F5\u91E6\u91E3\u91E7\u91ED\u91E9\u9589\u966A\u9675\u9673\u9678\u9670\u9674\u9676\u9677\u966C\u96C0\u96EA\u96E9\u7AE0\u7ADF\u9802\u9803\u9B5A\u9CE5\u9E75\u9E7F\u9EA5\u9EBB\u50A2\u508D\u5085\u5099\u5091\u5080\u5096\u5098\u509A\u6700\u51F1\u5272\u5274\u5275\u5269\u52DE\u52DD\u52DB\u535A\u53A5\u557B\u5580\u55A7\u557C\u558A\u559D\u5598\u5582\u559C\u55AA\u5594\u5587\u558B\u5583\u55B3\u55AE\u559F\u553E\u55B2\u559A\u55BB\u55AC\u55B1\u557E\u5589\u55AB\u5599\u570D\u582F\u582A\u5834\u5824\u5830\u5831\u5821\u581D\u5820\u58F9\u58FA\u5960"],
    ["b440", "\u5A77\u5A9A\u5A7F\u5A92\u5A9B\u5AA7\u5B73\u5B71\u5BD2\u5BCC\u5BD3\u5BD0\u5C0A\u5C0B\u5C31\u5D4C\u5D50\u5D34\u5D47\u5DFD\u5E45\u5E3D\u5E40\u5E43\u5E7E\u5ECA\u5EC1\u5EC2\u5EC4\u5F3C\u5F6D\u5FA9\u5FAA\u5FA8\u60D1\u60E1\u60B2\u60B6\u60E0\u611C\u6123\u60FA\u6115\u60F0\u60FB\u60F4\u6168\u60F1\u610E\u60F6\u6109\u6100\u6112\u621F\u6249\u63A3\u638C\u63CF\u63C0\u63E9\u63C9\u63C6\u63CD"],
    ["b4a1", "\u63D2\u63E3\u63D0\u63E1\u63D6\u63ED\u63EE\u6376\u63F4\u63EA\u63DB\u6452\u63DA\u63F9\u655E\u6566\u6562\u6563\u6591\u6590\u65AF\u666E\u6670\u6674\u6676\u666F\u6691\u667A\u667E\u6677\u66FE\u66FF\u671F\u671D\u68FA\u68D5\u68E0\u68D8\u68D7\u6905\u68DF\u68F5\u68EE\u68E7\u68F9\u68D2\u68F2\u68E3\u68CB\u68CD\u690D\u6912\u690E\u68C9\u68DA\u696E\u68FB\u6B3E\u6B3A\u6B3D\u6B98\u6B96\u6BBC\u6BEF\u6C2E\u6C2F\u6C2C\u6E2F\u6E38\u6E54\u6E21\u6E32\u6E67\u6E4A\u6E20\u6E25\u6E23\u6E1B\u6E5B\u6E58\u6E24\u6E56\u6E6E\u6E2D\u6E26\u6E6F\u6E34\u6E4D\u6E3A\u6E2C\u6E43\u6E1D\u6E3E\u6ECB"],
    ["b540", "\u6E89\u6E19\u6E4E\u6E63\u6E44\u6E72\u6E69\u6E5F\u7119\u711A\u7126\u7130\u7121\u7136\u716E\u711C\u724C\u7284\u7280\u7336\u7325\u7334\u7329\u743A\u742A\u7433\u7422\u7425\u7435\u7436\u7434\u742F\u741B\u7426\u7428\u7525\u7526\u756B\u756A\u75E2\u75DB\u75E3\u75D9\u75D8\u75DE\u75E0\u767B\u767C\u7696\u7693\u76B4\u76DC\u774F\u77ED\u785D\u786C\u786F\u7A0D\u7A08\u7A0B\u7A05\u7A00\u7A98"],
    ["b5a1", "\u7A97\u7A96\u7AE5\u7AE3\u7B49\u7B56\u7B46\u7B50\u7B52\u7B54\u7B4D\u7B4B\u7B4F\u7B51\u7C9F\u7CA5\u7D5E\u7D50\u7D68\u7D55\u7D2B\u7D6E\u7D72\u7D61\u7D66\u7D62\u7D70\u7D73\u5584\u7FD4\u7FD5\u800B\u8052\u8085\u8155\u8154\u814B\u8151\u814E\u8139\u8146\u813E\u814C\u8153\u8174\u8212\u821C\u83E9\u8403\u83F8\u840D\u83E0\u83C5\u840B\u83C1\u83EF\u83F1\u83F4\u8457\u840A\u83F0\u840C\u83CC\u83FD\u83F2\u83CA\u8438\u840E\u8404\u83DC\u8407\u83D4\u83DF\u865B\u86DF\u86D9\u86ED\u86D4\u86DB\u86E4\u86D0\u86DE\u8857\u88C1\u88C2\u88B1\u8983\u8996\u8A3B\u8A60\u8A55\u8A5E\u8A3C\u8A41"],
    ["b640", "\u8A54\u8A5B\u8A50\u8A46\u8A34\u8A3A\u8A36\u8A56\u8C61\u8C82\u8CAF\u8CBC\u8CB3\u8CBD\u8CC1\u8CBB\u8CC0\u8CB4\u8CB7\u8CB6\u8CBF\u8CB8\u8D8A\u8D85\u8D81\u8DCE\u8DDD\u8DCB\u8DDA\u8DD1\u8DCC\u8DDB\u8DC6\u8EFB\u8EF8\u8EFC\u8F9C\u902E\u9035\u9031\u9038\u9032\u9036\u9102\u90F5\u9109\u90FE\u9163\u9165\u91CF\u9214\u9215\u9223\u9209\u921E\u920D\u9210\u9207\u9211\u9594\u958F\u958B\u9591"],
    ["b6a1", "\u9593\u9592\u958E\u968A\u968E\u968B\u967D\u9685\u9686\u968D\u9672\u9684\u96C1\u96C5\u96C4\u96C6\u96C7\u96EF\u96F2\u97CC\u9805\u9806\u9808\u98E7\u98EA\u98EF\u98E9\u98F2\u98ED\u99AE\u99AD\u9EC3\u9ECD\u9ED1\u4E82\u50AD\u50B5\u50B2\u50B3\u50C5\u50BE\u50AC\u50B7\u50BB\u50AF\u50C7\u527F\u5277\u527D\u52DF\u52E6\u52E4\u52E2\u52E3\u532F\u55DF\u55E8\u55D3\u55E6\u55CE\u55DC\u55C7\u55D1\u55E3\u55E4\u55EF\u55DA\u55E1\u55C5\u55C6\u55E5\u55C9\u5712\u5713\u585E\u5851\u5858\u5857\u585A\u5854\u586B\u584C\u586D\u584A\u5862\u5852\u584B\u5967\u5AC1\u5AC9\u5ACC\u5ABE\u5ABD\u5ABC"],
    ["b740", "\u5AB3\u5AC2\u5AB2\u5D69\u5D6F\u5E4C\u5E79\u5EC9\u5EC8\u5F12\u5F59\u5FAC\u5FAE\u611A\u610F\u6148\u611F\u60F3\u611B\u60F9\u6101\u6108\u614E\u614C\u6144\u614D\u613E\u6134\u6127\u610D\u6106\u6137\u6221\u6222\u6413\u643E\u641E\u642A\u642D\u643D\u642C\u640F\u641C\u6414\u640D\u6436\u6416\u6417\u6406\u656C\u659F\u65B0\u6697\u6689\u6687\u6688\u6696\u6684\u6698\u668D\u6703\u6994\u696D"],
    ["b7a1", "\u695A\u6977\u6960\u6954\u6975\u6930\u6982\u694A\u6968\u696B\u695E\u6953\u6979\u6986\u695D\u6963\u695B\u6B47\u6B72\u6BC0\u6BBF\u6BD3\u6BFD\u6EA2\u6EAF\u6ED3\u6EB6\u6EC2\u6E90\u6E9D\u6EC7\u6EC5\u6EA5\u6E98\u6EBC\u6EBA\u6EAB\u6ED1\u6E96\u6E9C\u6EC4\u6ED4\u6EAA\u6EA7\u6EB4\u714E\u7159\u7169\u7164\u7149\u7167\u715C\u716C\u7166\u714C\u7165\u715E\u7146\u7168\u7156\u723A\u7252\u7337\u7345\u733F\u733E\u746F\u745A\u7455\u745F\u745E\u7441\u743F\u7459\u745B\u745C\u7576\u7578\u7600\u75F0\u7601\u75F2\u75F1\u75FA\u75FF\u75F4\u75F3\u76DE\u76DF\u775B\u776B\u7766\u775E\u7763"],
    ["b840", "\u7779\u776A\u776C\u775C\u7765\u7768\u7762\u77EE\u788E\u78B0\u7897\u7898\u788C\u7889\u787C\u7891\u7893\u787F\u797A\u797F\u7981\u842C\u79BD\u7A1C\u7A1A\u7A20\u7A14\u7A1F\u7A1E\u7A9F\u7AA0\u7B77\u7BC0\u7B60\u7B6E\u7B67\u7CB1\u7CB3\u7CB5\u7D93\u7D79\u7D91\u7D81\u7D8F\u7D5B\u7F6E\u7F69\u7F6A\u7F72\u7FA9\u7FA8\u7FA4\u8056\u8058\u8086\u8084\u8171\u8170\u8178\u8165\u816E\u8173\u816B"],
    ["b8a1", "\u8179\u817A\u8166\u8205\u8247\u8482\u8477\u843D\u8431\u8475\u8466\u846B\u8449\u846C\u845B\u843C\u8435\u8461\u8463\u8469\u846D\u8446\u865E\u865C\u865F\u86F9\u8713\u8708\u8707\u8700\u86FE\u86FB\u8702\u8703\u8706\u870A\u8859\u88DF\u88D4\u88D9\u88DC\u88D8\u88DD\u88E1\u88CA\u88D5\u88D2\u899C\u89E3\u8A6B\u8A72\u8A73\u8A66\u8A69\u8A70\u8A87\u8A7C\u8A63\u8AA0\u8A71\u8A85\u8A6D\u8A62\u8A6E\u8A6C\u8A79\u8A7B\u8A3E\u8A68\u8C62\u8C8A\u8C89\u8CCA\u8CC7\u8CC8\u8CC4\u8CB2\u8CC3\u8CC2\u8CC5\u8DE1\u8DDF\u8DE8\u8DEF\u8DF3\u8DFA\u8DEA\u8DE4\u8DE6\u8EB2\u8F03\u8F09\u8EFE\u8F0A"],
    ["b940", "\u8F9F\u8FB2\u904B\u904A\u9053\u9042\u9054\u903C\u9055\u9050\u9047\u904F\u904E\u904D\u9051\u903E\u9041\u9112\u9117\u916C\u916A\u9169\u91C9\u9237\u9257\u9238\u923D\u9240\u923E\u925B\u924B\u9264\u9251\u9234\u9249\u924D\u9245\u9239\u923F\u925A\u9598\u9698\u9694\u9695\u96CD\u96CB\u96C9\u96CA\u96F7\u96FB\u96F9\u96F6\u9756\u9774\u9776\u9810\u9811\u9813\u980A\u9812\u980C\u98FC\u98F4"],
    ["b9a1", "\u98FD\u98FE\u99B3\u99B1\u99B4\u9AE1\u9CE9\u9E82\u9F0E\u9F13\u9F20\u50E7\u50EE\u50E5\u50D6\u50ED\u50DA\u50D5\u50CF\u50D1\u50F1\u50CE\u50E9\u5162\u51F3\u5283\u5282\u5331\u53AD\u55FE\u5600\u561B\u5617\u55FD\u5614\u5606\u5609\u560D\u560E\u55F7\u5616\u561F\u5608\u5610\u55F6\u5718\u5716\u5875\u587E\u5883\u5893\u588A\u5879\u5885\u587D\u58FD\u5925\u5922\u5924\u596A\u5969\u5AE1\u5AE6\u5AE9\u5AD7\u5AD6\u5AD8\u5AE3\u5B75\u5BDE\u5BE7\u5BE1\u5BE5\u5BE6\u5BE8\u5BE2\u5BE4\u5BDF\u5C0D\u5C62\u5D84\u5D87\u5E5B\u5E63\u5E55\u5E57\u5E54\u5ED3\u5ED6\u5F0A\u5F46\u5F70\u5FB9\u6147"],
    ["ba40", "\u613F\u614B\u6177\u6162\u6163\u615F\u615A\u6158\u6175\u622A\u6487\u6458\u6454\u64A4\u6478\u645F\u647A\u6451\u6467\u6434\u646D\u647B\u6572\u65A1\u65D7\u65D6\u66A2\u66A8\u669D\u699C\u69A8\u6995\u69C1\u69AE\u69D3\u69CB\u699B\u69B7\u69BB\u69AB\u69B4\u69D0\u69CD\u69AD\u69CC\u69A6\u69C3\u69A3\u6B49\u6B4C\u6C33\u6F33\u6F14\u6EFE\u6F13\u6EF4\u6F29\u6F3E\u6F20\u6F2C\u6F0F\u6F02\u6F22"],
    ["baa1", "\u6EFF\u6EEF\u6F06\u6F31\u6F38\u6F32\u6F23\u6F15\u6F2B\u6F2F\u6F88\u6F2A\u6EEC\u6F01\u6EF2\u6ECC\u6EF7\u7194\u7199\u717D\u718A\u7184\u7192\u723E\u7292\u7296\u7344\u7350\u7464\u7463\u746A\u7470\u746D\u7504\u7591\u7627\u760D\u760B\u7609\u7613\u76E1\u76E3\u7784\u777D\u777F\u7761\u78C1\u789F\u78A7\u78B3\u78A9\u78A3\u798E\u798F\u798D\u7A2E\u7A31\u7AAA\u7AA9\u7AED\u7AEF\u7BA1\u7B95\u7B8B\u7B75\u7B97\u7B9D\u7B94\u7B8F\u7BB8\u7B87\u7B84\u7CB9\u7CBD\u7CBE\u7DBB\u7DB0\u7D9C\u7DBD\u7DBE\u7DA0\u7DCA\u7DB4\u7DB2\u7DB1\u7DBA\u7DA2\u7DBF\u7DB5\u7DB8\u7DAD\u7DD2\u7DC7\u7DAC"],
    ["bb40", "\u7F70\u7FE0\u7FE1\u7FDF\u805E\u805A\u8087\u8150\u8180\u818F\u8188\u818A\u817F\u8182\u81E7\u81FA\u8207\u8214\u821E\u824B\u84C9\u84BF\u84C6\u84C4\u8499\u849E\u84B2\u849C\u84CB\u84B8\u84C0\u84D3\u8490\u84BC\u84D1\u84CA\u873F\u871C\u873B\u8722\u8725\u8734\u8718\u8755\u8737\u8729\u88F3\u8902\u88F4\u88F9\u88F8\u88FD\u88E8\u891A\u88EF\u8AA6\u8A8C\u8A9E\u8AA3\u8A8D\u8AA1\u8A93\u8AA4"],
    ["bba1", "\u8AAA\u8AA5\u8AA8\u8A98\u8A91\u8A9A\u8AA7\u8C6A\u8C8D\u8C8C\u8CD3\u8CD1\u8CD2\u8D6B\u8D99\u8D95\u8DFC\u8F14\u8F12\u8F15\u8F13\u8FA3\u9060\u9058\u905C\u9063\u9059\u905E\u9062\u905D\u905B\u9119\u9118\u911E\u9175\u9178\u9177\u9174\u9278\u9280\u9285\u9298\u9296\u927B\u9293\u929C\u92A8\u927C\u9291\u95A1\u95A8\u95A9\u95A3\u95A5\u95A4\u9699\u969C\u969B\u96CC\u96D2\u9700\u977C\u9785\u97F6\u9817\u9818\u98AF\u98B1\u9903\u9905\u990C\u9909\u99C1\u9AAF\u9AB0\u9AE6\u9B41\u9B42\u9CF4\u9CF6\u9CF3\u9EBC\u9F3B\u9F4A\u5104\u5100\u50FB\u50F5\u50F9\u5102\u5108\u5109\u5105\u51DC"],
    ["bc40", "\u5287\u5288\u5289\u528D\u528A\u52F0\u53B2\u562E\u563B\u5639\u5632\u563F\u5634\u5629\u5653\u564E\u5657\u5674\u5636\u562F\u5630\u5880\u589F\u589E\u58B3\u589C\u58AE\u58A9\u58A6\u596D\u5B09\u5AFB\u5B0B\u5AF5\u5B0C\u5B08\u5BEE\u5BEC\u5BE9\u5BEB\u5C64\u5C65\u5D9D\u5D94\u5E62\u5E5F\u5E61\u5EE2\u5EDA\u5EDF\u5EDD\u5EE3\u5EE0\u5F48\u5F71\u5FB7\u5FB5\u6176\u6167\u616E\u615D\u6155\u6182"],
    ["bca1", "\u617C\u6170\u616B\u617E\u61A7\u6190\u61AB\u618E\u61AC\u619A\u61A4\u6194\u61AE\u622E\u6469\u646F\u6479\u649E\u64B2\u6488\u6490\u64B0\u64A5\u6493\u6495\u64A9\u6492\u64AE\u64AD\u64AB\u649A\u64AC\u6499\u64A2\u64B3\u6575\u6577\u6578\u66AE\u66AB\u66B4\u66B1\u6A23\u6A1F\u69E8\u6A01\u6A1E\u6A19\u69FD\u6A21\u6A13\u6A0A\u69F3\u6A02\u6A05\u69ED\u6A11\u6B50\u6B4E\u6BA4\u6BC5\u6BC6\u6F3F\u6F7C\u6F84\u6F51\u6F66\u6F54\u6F86\u6F6D\u6F5B\u6F78\u6F6E\u6F8E\u6F7A\u6F70\u6F64\u6F97\u6F58\u6ED5\u6F6F\u6F60\u6F5F\u719F\u71AC\u71B1\u71A8\u7256\u729B\u734E\u7357\u7469\u748B\u7483"],
    ["bd40", "\u747E\u7480\u757F\u7620\u7629\u761F\u7624\u7626\u7621\u7622\u769A\u76BA\u76E4\u778E\u7787\u778C\u7791\u778B\u78CB\u78C5\u78BA\u78CA\u78BE\u78D5\u78BC\u78D0\u7A3F\u7A3C\u7A40\u7A3D\u7A37\u7A3B\u7AAF\u7AAE\u7BAD\u7BB1\u7BC4\u7BB4\u7BC6\u7BC7\u7BC1\u7BA0\u7BCC\u7CCA\u7DE0\u7DF4\u7DEF\u7DFB\u7DD8\u7DEC\u7DDD\u7DE8\u7DE3\u7DDA\u7DDE\u7DE9\u7D9E\u7DD9\u7DF2\u7DF9\u7F75\u7F77\u7FAF"],
    ["bda1", "\u7FE9\u8026\u819B\u819C\u819D\u81A0\u819A\u8198\u8517\u853D\u851A\u84EE\u852C\u852D\u8513\u8511\u8523\u8521\u8514\u84EC\u8525\u84FF\u8506\u8782\u8774\u8776\u8760\u8766\u8778\u8768\u8759\u8757\u874C\u8753\u885B\u885D\u8910\u8907\u8912\u8913\u8915\u890A\u8ABC\u8AD2\u8AC7\u8AC4\u8A95\u8ACB\u8AF8\u8AB2\u8AC9\u8AC2\u8ABF\u8AB0\u8AD6\u8ACD\u8AB6\u8AB9\u8ADB\u8C4C\u8C4E\u8C6C\u8CE0\u8CDE\u8CE6\u8CE4\u8CEC\u8CED\u8CE2\u8CE3\u8CDC\u8CEA\u8CE1\u8D6D\u8D9F\u8DA3\u8E2B\u8E10\u8E1D\u8E22\u8E0F\u8E29\u8E1F\u8E21\u8E1E\u8EBA\u8F1D\u8F1B\u8F1F\u8F29\u8F26\u8F2A\u8F1C\u8F1E"],
    ["be40", "\u8F25\u9069\u906E\u9068\u906D\u9077\u9130\u912D\u9127\u9131\u9187\u9189\u918B\u9183\u92C5\u92BB\u92B7\u92EA\u92AC\u92E4\u92C1\u92B3\u92BC\u92D2\u92C7\u92F0\u92B2\u95AD\u95B1\u9704\u9706\u9707\u9709\u9760\u978D\u978B\u978F\u9821\u982B\u981C\u98B3\u990A\u9913\u9912\u9918\u99DD\u99D0\u99DF\u99DB\u99D1\u99D5\u99D2\u99D9\u9AB7\u9AEE\u9AEF\u9B27\u9B45\u9B44\u9B77\u9B6F\u9D06\u9D09"],
    ["bea1", "\u9D03\u9EA9\u9EBE\u9ECE\u58A8\u9F52\u5112\u5118\u5114\u5110\u5115\u5180\u51AA\u51DD\u5291\u5293\u52F3\u5659\u566B\u5679\u5669\u5664\u5678\u566A\u5668\u5665\u5671\u566F\u566C\u5662\u5676\u58C1\u58BE\u58C7\u58C5\u596E\u5B1D\u5B34\u5B78\u5BF0\u5C0E\u5F4A\u61B2\u6191\u61A9\u618A\u61CD\u61B6\u61BE\u61CA\u61C8\u6230\u64C5\u64C1\u64CB\u64BB\u64BC\u64DA\u64C4\u64C7\u64C2\u64CD\u64BF\u64D2\u64D4\u64BE\u6574\u66C6\u66C9\u66B9\u66C4\u66C7\u66B8\u6A3D\u6A38\u6A3A\u6A59\u6A6B\u6A58\u6A39\u6A44\u6A62\u6A61\u6A4B\u6A47\u6A35\u6A5F\u6A48\u6B59\u6B77\u6C05\u6FC2\u6FB1\u6FA1"],
    ["bf40", "\u6FC3\u6FA4\u6FC1\u6FA7\u6FB3\u6FC0\u6FB9\u6FB6\u6FA6\u6FA0\u6FB4\u71BE\u71C9\u71D0\u71D2\u71C8\u71D5\u71B9\u71CE\u71D9\u71DC\u71C3\u71C4\u7368\u749C\u74A3\u7498\u749F\u749E\u74E2\u750C\u750D\u7634\u7638\u763A\u76E7\u76E5\u77A0\u779E\u779F\u77A5\u78E8\u78DA\u78EC\u78E7\u79A6\u7A4D\u7A4E\u7A46\u7A4C\u7A4B\u7ABA\u7BD9\u7C11\u7BC9\u7BE4\u7BDB\u7BE1\u7BE9\u7BE6\u7CD5\u7CD6\u7E0A"],
    ["bfa1", "\u7E11\u7E08\u7E1B\u7E23\u7E1E\u7E1D\u7E09\u7E10\u7F79\u7FB2\u7FF0\u7FF1\u7FEE\u8028\u81B3\u81A9\u81A8\u81FB\u8208\u8258\u8259\u854A\u8559\u8548\u8568\u8569\u8543\u8549\u856D\u856A\u855E\u8783\u879F\u879E\u87A2\u878D\u8861\u892A\u8932\u8925\u892B\u8921\u89AA\u89A6\u8AE6\u8AFA\u8AEB\u8AF1\u8B00\u8ADC\u8AE7\u8AEE\u8AFE\u8B01\u8B02\u8AF7\u8AED\u8AF3\u8AF6\u8AFC\u8C6B\u8C6D\u8C93\u8CF4\u8E44\u8E31\u8E34\u8E42\u8E39\u8E35\u8F3B\u8F2F\u8F38\u8F33\u8FA8\u8FA6\u9075\u9074\u9078\u9072\u907C\u907A\u9134\u9192\u9320\u9336\u92F8\u9333\u932F\u9322\u92FC\u932B\u9304\u931A"],
    ["c040", "\u9310\u9326\u9321\u9315\u932E\u9319\u95BB\u96A7\u96A8\u96AA\u96D5\u970E\u9711\u9716\u970D\u9713\u970F\u975B\u975C\u9766\u9798\u9830\u9838\u983B\u9837\u982D\u9839\u9824\u9910\u9928\u991E\u991B\u9921\u991A\u99ED\u99E2\u99F1\u9AB8\u9ABC\u9AFB\u9AED\u9B28\u9B91\u9D15\u9D23\u9D26\u9D28\u9D12\u9D1B\u9ED8\u9ED4\u9F8D\u9F9C\u512A\u511F\u5121\u5132\u52F5\u568E\u5680\u5690\u5685\u5687"],
    ["c0a1", "\u568F\u58D5\u58D3\u58D1\u58CE\u5B30\u5B2A\u5B24\u5B7A\u5C37\u5C68\u5DBC\u5DBA\u5DBD\u5DB8\u5E6B\u5F4C\u5FBD\u61C9\u61C2\u61C7\u61E6\u61CB\u6232\u6234\u64CE\u64CA\u64D8\u64E0\u64F0\u64E6\u64EC\u64F1\u64E2\u64ED\u6582\u6583\u66D9\u66D6\u6A80\u6A94\u6A84\u6AA2\u6A9C\u6ADB\u6AA3\u6A7E\u6A97\u6A90\u6AA0\u6B5C\u6BAE\u6BDA\u6C08\u6FD8\u6FF1\u6FDF\u6FE0\u6FDB\u6FE4\u6FEB\u6FEF\u6F80\u6FEC\u6FE1\u6FE9\u6FD5\u6FEE\u6FF0\u71E7\u71DF\u71EE\u71E6\u71E5\u71ED\u71EC\u71F4\u71E0\u7235\u7246\u7370\u7372\u74A9\u74B0\u74A6\u74A8\u7646\u7642\u764C\u76EA\u77B3\u77AA\u77B0\u77AC"],
    ["c140", "\u77A7\u77AD\u77EF\u78F7\u78FA\u78F4\u78EF\u7901\u79A7\u79AA\u7A57\u7ABF\u7C07\u7C0D\u7BFE\u7BF7\u7C0C\u7BE0\u7CE0\u7CDC\u7CDE\u7CE2\u7CDF\u7CD9\u7CDD\u7E2E\u7E3E\u7E46\u7E37\u7E32\u7E43\u7E2B\u7E3D\u7E31\u7E45\u7E41\u7E34\u7E39\u7E48\u7E35\u7E3F\u7E2F\u7F44\u7FF3\u7FFC\u8071\u8072\u8070\u806F\u8073\u81C6\u81C3\u81BA\u81C2\u81C0\u81BF\u81BD\u81C9\u81BE\u81E8\u8209\u8271\u85AA"],
    ["c1a1", "\u8584\u857E\u859C\u8591\u8594\u85AF\u859B\u8587\u85A8\u858A\u8667\u87C0\u87D1\u87B3\u87D2\u87C6\u87AB\u87BB\u87BA\u87C8\u87CB\u893B\u8936\u8944\u8938\u893D\u89AC\u8B0E\u8B17\u8B19\u8B1B\u8B0A\u8B20\u8B1D\u8B04\u8B10\u8C41\u8C3F\u8C73\u8CFA\u8CFD\u8CFC\u8CF8\u8CFB\u8DA8\u8E49\u8E4B\u8E48\u8E4A\u8F44\u8F3E\u8F42\u8F45\u8F3F\u907F\u907D\u9084\u9081\u9082\u9080\u9139\u91A3\u919E\u919C\u934D\u9382\u9328\u9375\u934A\u9365\u934B\u9318\u937E\u936C\u935B\u9370\u935A\u9354\u95CA\u95CB\u95CC\u95C8\u95C6\u96B1\u96B8\u96D6\u971C\u971E\u97A0\u97D3\u9846\u98B6\u9935\u9A01"],
    ["c240", "\u99FF\u9BAE\u9BAB\u9BAA\u9BAD\u9D3B\u9D3F\u9E8B\u9ECF\u9EDE\u9EDC\u9EDD\u9EDB\u9F3E\u9F4B\u53E2\u5695\u56AE\u58D9\u58D8\u5B38\u5F5D\u61E3\u6233\u64F4\u64F2\u64FE\u6506\u64FA\u64FB\u64F7\u65B7\u66DC\u6726\u6AB3\u6AAC\u6AC3\u6ABB\u6AB8\u6AC2\u6AAE\u6AAF\u6B5F\u6B78\u6BAF\u7009\u700B\u6FFE\u7006\u6FFA\u7011\u700F\u71FB\u71FC\u71FE\u71F8\u7377\u7375\u74A7\u74BF\u7515\u7656\u7658"],
    ["c2a1", "\u7652\u77BD\u77BF\u77BB\u77BC\u790E\u79AE\u7A61\u7A62\u7A60\u7AC4\u7AC5\u7C2B\u7C27\u7C2A\u7C1E\u7C23\u7C21\u7CE7\u7E54\u7E55\u7E5E\u7E5A\u7E61\u7E52\u7E59\u7F48\u7FF9\u7FFB\u8077\u8076\u81CD\u81CF\u820A\u85CF\u85A9\u85CD\u85D0\u85C9\u85B0\u85BA\u85B9\u85A6\u87EF\u87EC\u87F2\u87E0\u8986\u89B2\u89F4\u8B28\u8B39\u8B2C\u8B2B\u8C50\u8D05\u8E59\u8E63\u8E66\u8E64\u8E5F\u8E55\u8EC0\u8F49\u8F4D\u9087\u9083\u9088\u91AB\u91AC\u91D0\u9394\u938A\u9396\u93A2\u93B3\u93AE\u93AC\u93B0\u9398\u939A\u9397\u95D4\u95D6\u95D0\u95D5\u96E2\u96DC\u96D9\u96DB\u96DE\u9724\u97A3\u97A6"],
    ["c340", "\u97AD\u97F9\u984D\u984F\u984C\u984E\u9853\u98BA\u993E\u993F\u993D\u992E\u99A5\u9A0E\u9AC1\u9B03\u9B06\u9B4F\u9B4E\u9B4D\u9BCA\u9BC9\u9BFD\u9BC8\u9BC0\u9D51\u9D5D\u9D60\u9EE0\u9F15\u9F2C\u5133\u56A5\u58DE\u58DF\u58E2\u5BF5\u9F90\u5EEC\u61F2\u61F7\u61F6\u61F5\u6500\u650F\u66E0\u66DD\u6AE5\u6ADD\u6ADA\u6AD3\u701B\u701F\u7028\u701A\u701D\u7015\u7018\u7206\u720D\u7258\u72A2\u7378"],
    ["c3a1", "\u737A\u74BD\u74CA\u74E3\u7587\u7586\u765F\u7661\u77C7\u7919\u79B1\u7A6B\u7A69\u7C3E\u7C3F\u7C38\u7C3D\u7C37\u7C40\u7E6B\u7E6D\u7E79\u7E69\u7E6A\u7F85\u7E73\u7FB6\u7FB9\u7FB8\u81D8\u85E9\u85DD\u85EA\u85D5\u85E4\u85E5\u85F7\u87FB\u8805\u880D\u87F9\u87FE\u8960\u895F\u8956\u895E\u8B41\u8B5C\u8B58\u8B49\u8B5A\u8B4E\u8B4F\u8B46\u8B59\u8D08\u8D0A\u8E7C\u8E72\u8E87\u8E76\u8E6C\u8E7A\u8E74\u8F54\u8F4E\u8FAD\u908A\u908B\u91B1\u91AE\u93E1\u93D1\u93DF\u93C3\u93C8\u93DC\u93DD\u93D6\u93E2\u93CD\u93D8\u93E4\u93D7\u93E8\u95DC\u96B4\u96E3\u972A\u9727\u9761\u97DC\u97FB\u985E"],
    ["c440", "\u9858\u985B\u98BC\u9945\u9949\u9A16\u9A19\u9B0D\u9BE8\u9BE7\u9BD6\u9BDB\u9D89\u9D61\u9D72\u9D6A\u9D6C\u9E92\u9E97\u9E93\u9EB4\u52F8\u56A8\u56B7\u56B6\u56B4\u56BC\u58E4\u5B40\u5B43\u5B7D\u5BF6\u5DC9\u61F8\u61FA\u6518\u6514\u6519\u66E6\u6727\u6AEC\u703E\u7030\u7032\u7210\u737B\u74CF\u7662\u7665\u7926\u792A\u792C\u792B\u7AC7\u7AF6\u7C4C\u7C43\u7C4D\u7CEF\u7CF0\u8FAE\u7E7D\u7E7C"],
    ["c4a1", "\u7E82\u7F4C\u8000\u81DA\u8266\u85FB\u85F9\u8611\u85FA\u8606\u860B\u8607\u860A\u8814\u8815\u8964\u89BA\u89F8\u8B70\u8B6C\u8B66\u8B6F\u8B5F\u8B6B\u8D0F\u8D0D\u8E89\u8E81\u8E85\u8E82\u91B4\u91CB\u9418\u9403\u93FD\u95E1\u9730\u98C4\u9952\u9951\u99A8\u9A2B\u9A30\u9A37\u9A35\u9C13\u9C0D\u9E79\u9EB5\u9EE8\u9F2F\u9F5F\u9F63\u9F61\u5137\u5138\u56C1\u56C0\u56C2\u5914\u5C6C\u5DCD\u61FC\u61FE\u651D\u651C\u6595\u66E9\u6AFB\u6B04\u6AFA\u6BB2\u704C\u721B\u72A7\u74D6\u74D4\u7669\u77D3\u7C50\u7E8F\u7E8C\u7FBC\u8617\u862D\u861A\u8823\u8822\u8821\u881F\u896A\u896C\u89BD\u8B74"],
    ["c540", "\u8B77\u8B7D\u8D13\u8E8A\u8E8D\u8E8B\u8F5F\u8FAF\u91BA\u942E\u9433\u9435\u943A\u9438\u9432\u942B\u95E2\u9738\u9739\u9732\u97FF\u9867\u9865\u9957\u9A45\u9A43\u9A40\u9A3E\u9ACF\u9B54\u9B51\u9C2D\u9C25\u9DAF\u9DB4\u9DC2\u9DB8\u9E9D\u9EEF\u9F19\u9F5C\u9F66\u9F67\u513C\u513B\u56C8\u56CA\u56C9\u5B7F\u5DD4\u5DD2\u5F4E\u61FF\u6524\u6B0A\u6B61\u7051\u7058\u7380\u74E4\u758A\u766E\u766C"],
    ["c5a1", "\u79B3\u7C60\u7C5F\u807E\u807D\u81DF\u8972\u896F\u89FC\u8B80\u8D16\u8D17\u8E91\u8E93\u8F61\u9148\u9444\u9451\u9452\u973D\u973E\u97C3\u97C1\u986B\u9955\u9A55\u9A4D\u9AD2\u9B1A\u9C49\u9C31\u9C3E\u9C3B\u9DD3\u9DD7\u9F34\u9F6C\u9F6A\u9F94\u56CC\u5DD6\u6200\u6523\u652B\u652A\u66EC\u6B10\u74DA\u7ACA\u7C64\u7C63\u7C65\u7E93\u7E96\u7E94\u81E2\u8638\u863F\u8831\u8B8A\u9090\u908F\u9463\u9460\u9464\u9768\u986F\u995C\u9A5A\u9A5B\u9A57\u9AD3\u9AD4\u9AD1\u9C54\u9C57\u9C56\u9DE5\u9E9F\u9EF4\u56D1\u58E9\u652C\u705E\u7671\u7672\u77D7\u7F50\u7F88\u8836\u8839\u8862\u8B93\u8B92"],
    ["c640", "\u8B96\u8277\u8D1B\u91C0\u946A\u9742\u9748\u9744\u97C6\u9870\u9A5F\u9B22\u9B58\u9C5F\u9DF9\u9DFA\u9E7C\u9E7D\u9F07\u9F77\u9F72\u5EF3\u6B16\u7063\u7C6C\u7C6E\u883B\u89C0\u8EA1\u91C1\u9472\u9470\u9871\u995E\u9AD6\u9B23\u9ECC\u7064\u77DA\u8B9A\u9477\u97C9\u9A62\u9A65\u7E9C\u8B9C\u8EAA\u91C5\u947D\u947E\u947C\u9C77\u9C78\u9EF7\u8C54\u947F\u9E1A\u7228\u9A6A\u9B31\u9E1B\u9E1E\u7C72"],
    ["c940", "\u4E42\u4E5C\u51F5\u531A\u5382\u4E07\u4E0C\u4E47\u4E8D\u56D7\uFA0C\u5C6E\u5F73\u4E0F\u5187\u4E0E\u4E2E\u4E93\u4EC2\u4EC9\u4EC8\u5198\u52FC\u536C\u53B9\u5720\u5903\u592C\u5C10\u5DFF\u65E1\u6BB3\u6BCC\u6C14\u723F\u4E31\u4E3C\u4EE8\u4EDC\u4EE9\u4EE1\u4EDD\u4EDA\u520C\u531C\u534C\u5722\u5723\u5917\u592F\u5B81\u5B84\u5C12\u5C3B\u5C74\u5C73\u5E04\u5E80\u5E82\u5FC9\u6209\u6250\u6C15"],
    ["c9a1", "\u6C36\u6C43\u6C3F\u6C3B\u72AE\u72B0\u738A\u79B8\u808A\u961E\u4F0E\u4F18\u4F2C\u4EF5\u4F14\u4EF1\u4F00\u4EF7\u4F08\u4F1D\u4F02\u4F05\u4F22\u4F13\u4F04\u4EF4\u4F12\u51B1\u5213\u5209\u5210\u52A6\u5322\u531F\u534D\u538A\u5407\u56E1\u56DF\u572E\u572A\u5734\u593C\u5980\u597C\u5985\u597B\u597E\u5977\u597F\u5B56\u5C15\u5C25\u5C7C\u5C7A\u5C7B\u5C7E\u5DDF\u5E75\u5E84\u5F02\u5F1A\u5F74\u5FD5\u5FD4\u5FCF\u625C\u625E\u6264\u6261\u6266\u6262\u6259\u6260\u625A\u6265\u65EF\u65EE\u673E\u6739\u6738\u673B\u673A\u673F\u673C\u6733\u6C18\u6C46\u6C52\u6C5C\u6C4F\u6C4A\u6C54\u6C4B"],
    ["ca40", "\u6C4C\u7071\u725E\u72B4\u72B5\u738E\u752A\u767F\u7A75\u7F51\u8278\u827C\u8280\u827D\u827F\u864D\u897E\u9099\u9097\u9098\u909B\u9094\u9622\u9624\u9620\u9623\u4F56\u4F3B\u4F62\u4F49\u4F53\u4F64\u4F3E\u4F67\u4F52\u4F5F\u4F41\u4F58\u4F2D\u4F33\u4F3F\u4F61\u518F\u51B9\u521C\u521E\u5221\u52AD\u52AE\u5309\u5363\u5372\u538E\u538F\u5430\u5437\u542A\u5454\u5445\u5419\u541C\u5425\u5418"],
    ["caa1", "\u543D\u544F\u5441\u5428\u5424\u5447\u56EE\u56E7\u56E5\u5741\u5745\u574C\u5749\u574B\u5752\u5906\u5940\u59A6\u5998\u59A0\u5997\u598E\u59A2\u5990\u598F\u59A7\u59A1\u5B8E\u5B92\u5C28\u5C2A\u5C8D\u5C8F\u5C88\u5C8B\u5C89\u5C92\u5C8A\u5C86\u5C93\u5C95\u5DE0\u5E0A\u5E0E\u5E8B\u5E89\u5E8C\u5E88\u5E8D\u5F05\u5F1D\u5F78\u5F76\u5FD2\u5FD1\u5FD0\u5FED\u5FE8\u5FEE\u5FF3\u5FE1\u5FE4\u5FE3\u5FFA\u5FEF\u5FF7\u5FFB\u6000\u5FF4\u623A\u6283\u628C\u628E\u628F\u6294\u6287\u6271\u627B\u627A\u6270\u6281\u6288\u6277\u627D\u6272\u6274\u6537\u65F0\u65F4\u65F3\u65F2\u65F5\u6745\u6747"],
    ["cb40", "\u6759\u6755\u674C\u6748\u675D\u674D\u675A\u674B\u6BD0\u6C19\u6C1A\u6C78\u6C67\u6C6B\u6C84\u6C8B\u6C8F\u6C71\u6C6F\u6C69\u6C9A\u6C6D\u6C87\u6C95\u6C9C\u6C66\u6C73\u6C65\u6C7B\u6C8E\u7074\u707A\u7263\u72BF\u72BD\u72C3\u72C6\u72C1\u72BA\u72C5\u7395\u7397\u7393\u7394\u7392\u753A\u7539\u7594\u7595\u7681\u793D\u8034\u8095\u8099\u8090\u8092\u809C\u8290\u828F\u8285\u828E\u8291\u8293"],
    ["cba1", "\u828A\u8283\u8284\u8C78\u8FC9\u8FBF\u909F\u90A1\u90A5\u909E\u90A7\u90A0\u9630\u9628\u962F\u962D\u4E33\u4F98\u4F7C\u4F85\u4F7D\u4F80\u4F87\u4F76\u4F74\u4F89\u4F84\u4F77\u4F4C\u4F97\u4F6A\u4F9A\u4F79\u4F81\u4F78\u4F90\u4F9C\u4F94\u4F9E\u4F92\u4F82\u4F95\u4F6B\u4F6E\u519E\u51BC\u51BE\u5235\u5232\u5233\u5246\u5231\u52BC\u530A\u530B\u533C\u5392\u5394\u5487\u547F\u5481\u5491\u5482\u5488\u546B\u547A\u547E\u5465\u546C\u5474\u5466\u548D\u546F\u5461\u5460\u5498\u5463\u5467\u5464\u56F7\u56F9\u576F\u5772\u576D\u576B\u5771\u5770\u5776\u5780\u5775\u577B\u5773\u5774\u5762"],
    ["cc40", "\u5768\u577D\u590C\u5945\u59B5\u59BA\u59CF\u59CE\u59B2\u59CC\u59C1\u59B6\u59BC\u59C3\u59D6\u59B1\u59BD\u59C0\u59C8\u59B4\u59C7\u5B62\u5B65\u5B93\u5B95\u5C44\u5C47\u5CAE\u5CA4\u5CA0\u5CB5\u5CAF\u5CA8\u5CAC\u5C9F\u5CA3\u5CAD\u5CA2\u5CAA\u5CA7\u5C9D\u5CA5\u5CB6\u5CB0\u5CA6\u5E17\u5E14\u5E19\u5F28\u5F22\u5F23\u5F24\u5F54\u5F82\u5F7E\u5F7D\u5FDE\u5FE5\u602D\u6026\u6019\u6032\u600B"],
    ["cca1", "\u6034\u600A\u6017\u6033\u601A\u601E\u602C\u6022\u600D\u6010\u602E\u6013\u6011\u600C\u6009\u601C\u6214\u623D\u62AD\u62B4\u62D1\u62BE\u62AA\u62B6\u62CA\u62AE\u62B3\u62AF\u62BB\u62A9\u62B0\u62B8\u653D\u65A8\u65BB\u6609\u65FC\u6604\u6612\u6608\u65FB\u6603\u660B\u660D\u6605\u65FD\u6611\u6610\u66F6\u670A\u6785\u676C\u678E\u6792\u6776\u677B\u6798\u6786\u6784\u6774\u678D\u678C\u677A\u679F\u6791\u6799\u6783\u677D\u6781\u6778\u6779\u6794\u6B25\u6B80\u6B7E\u6BDE\u6C1D\u6C93\u6CEC\u6CEB\u6CEE\u6CD9\u6CB6\u6CD4\u6CAD\u6CE7\u6CB7\u6CD0\u6CC2\u6CBA\u6CC3\u6CC6\u6CED\u6CF2"],
    ["cd40", "\u6CD2\u6CDD\u6CB4\u6C8A\u6C9D\u6C80\u6CDE\u6CC0\u6D30\u6CCD\u6CC7\u6CB0\u6CF9\u6CCF\u6CE9\u6CD1\u7094\u7098\u7085\u7093\u7086\u7084\u7091\u7096\u7082\u709A\u7083\u726A\u72D6\u72CB\u72D8\u72C9\u72DC\u72D2\u72D4\u72DA\u72CC\u72D1\u73A4\u73A1\u73AD\u73A6\u73A2\u73A0\u73AC\u739D\u74DD\u74E8\u753F\u7540\u753E\u758C\u7598\u76AF\u76F3\u76F1\u76F0\u76F5\u77F8\u77FC\u77F9\u77FB\u77FA"],
    ["cda1", "\u77F7\u7942\u793F\u79C5\u7A78\u7A7B\u7AFB\u7C75\u7CFD\u8035\u808F\u80AE\u80A3\u80B8\u80B5\u80AD\u8220\u82A0\u82C0\u82AB\u829A\u8298\u829B\u82B5\u82A7\u82AE\u82BC\u829E\u82BA\u82B4\u82A8\u82A1\u82A9\u82C2\u82A4\u82C3\u82B6\u82A2\u8670\u866F\u866D\u866E\u8C56\u8FD2\u8FCB\u8FD3\u8FCD\u8FD6\u8FD5\u8FD7\u90B2\u90B4\u90AF\u90B3\u90B0\u9639\u963D\u963C\u963A\u9643\u4FCD\u4FC5\u4FD3\u4FB2\u4FC9\u4FCB\u4FC1\u4FD4\u4FDC\u4FD9\u4FBB\u4FB3\u4FDB\u4FC7\u4FD6\u4FBA\u4FC0\u4FB9\u4FEC\u5244\u5249\u52C0\u52C2\u533D\u537C\u5397\u5396\u5399\u5398\u54BA\u54A1\u54AD\u54A5\u54CF"],
    ["ce40", "\u54C3\u830D\u54B7\u54AE\u54D6\u54B6\u54C5\u54C6\u54A0\u5470\u54BC\u54A2\u54BE\u5472\u54DE\u54B0\u57B5\u579E\u579F\u57A4\u578C\u5797\u579D\u579B\u5794\u5798\u578F\u5799\u57A5\u579A\u5795\u58F4\u590D\u5953\u59E1\u59DE\u59EE\u5A00\u59F1\u59DD\u59FA\u59FD\u59FC\u59F6\u59E4\u59F2\u59F7\u59DB\u59E9\u59F3\u59F5\u59E0\u59FE\u59F4\u59ED\u5BA8\u5C4C\u5CD0\u5CD8\u5CCC\u5CD7\u5CCB\u5CDB"],
    ["cea1", "\u5CDE\u5CDA\u5CC9\u5CC7\u5CCA\u5CD6\u5CD3\u5CD4\u5CCF\u5CC8\u5CC6\u5CCE\u5CDF\u5CF8\u5DF9\u5E21\u5E22\u5E23\u5E20\u5E24\u5EB0\u5EA4\u5EA2\u5E9B\u5EA3\u5EA5\u5F07\u5F2E\u5F56\u5F86\u6037\u6039\u6054\u6072\u605E\u6045\u6053\u6047\u6049\u605B\u604C\u6040\u6042\u605F\u6024\u6044\u6058\u6066\u606E\u6242\u6243\u62CF\u630D\u630B\u62F5\u630E\u6303\u62EB\u62F9\u630F\u630C\u62F8\u62F6\u6300\u6313\u6314\u62FA\u6315\u62FB\u62F0\u6541\u6543\u65AA\u65BF\u6636\u6621\u6632\u6635\u661C\u6626\u6622\u6633\u662B\u663A\u661D\u6634\u6639\u662E\u670F\u6710\u67C1\u67F2\u67C8\u67BA"],
    ["cf40", "\u67DC\u67BB\u67F8\u67D8\u67C0\u67B7\u67C5\u67EB\u67E4\u67DF\u67B5\u67CD\u67B3\u67F7\u67F6\u67EE\u67E3\u67C2\u67B9\u67CE\u67E7\u67F0\u67B2\u67FC\u67C6\u67ED\u67CC\u67AE\u67E6\u67DB\u67FA\u67C9\u67CA\u67C3\u67EA\u67CB\u6B28\u6B82\u6B84\u6BB6\u6BD6\u6BD8\u6BE0\u6C20\u6C21\u6D28\u6D34\u6D2D\u6D1F\u6D3C\u6D3F\u6D12\u6D0A\u6CDA\u6D33\u6D04\u6D19\u6D3A\u6D1A\u6D11\u6D00\u6D1D\u6D42"],
    ["cfa1", "\u6D01\u6D18\u6D37\u6D03\u6D0F\u6D40\u6D07\u6D20\u6D2C\u6D08\u6D22\u6D09\u6D10\u70B7\u709F\u70BE\u70B1\u70B0\u70A1\u70B4\u70B5\u70A9\u7241\u7249\u724A\u726C\u7270\u7273\u726E\u72CA\u72E4\u72E8\u72EB\u72DF\u72EA\u72E6\u72E3\u7385\u73CC\u73C2\u73C8\u73C5\u73B9\u73B6\u73B5\u73B4\u73EB\u73BF\u73C7\u73BE\u73C3\u73C6\u73B8\u73CB\u74EC\u74EE\u752E\u7547\u7548\u75A7\u75AA\u7679\u76C4\u7708\u7703\u7704\u7705\u770A\u76F7\u76FB\u76FA\u77E7\u77E8\u7806\u7811\u7812\u7805\u7810\u780F\u780E\u7809\u7803\u7813\u794A\u794C\u794B\u7945\u7944\u79D5\u79CD\u79CF\u79D6\u79CE\u7A80"],
    ["d040", "\u7A7E\u7AD1\u7B00\u7B01\u7C7A\u7C78\u7C79\u7C7F\u7C80\u7C81\u7D03\u7D08\u7D01\u7F58\u7F91\u7F8D\u7FBE\u8007\u800E\u800F\u8014\u8037\u80D8\u80C7\u80E0\u80D1\u80C8\u80C2\u80D0\u80C5\u80E3\u80D9\u80DC\u80CA\u80D5\u80C9\u80CF\u80D7\u80E6\u80CD\u81FF\u8221\u8294\u82D9\u82FE\u82F9\u8307\u82E8\u8300\u82D5\u833A\u82EB\u82D6\u82F4\u82EC\u82E1\u82F2\u82F5\u830C\u82FB\u82F6\u82F0\u82EA"],
    ["d0a1", "\u82E4\u82E0\u82FA\u82F3\u82ED\u8677\u8674\u867C\u8673\u8841\u884E\u8867\u886A\u8869\u89D3\u8A04\u8A07\u8D72\u8FE3\u8FE1\u8FEE\u8FE0\u90F1\u90BD\u90BF\u90D5\u90C5\u90BE\u90C7\u90CB\u90C8\u91D4\u91D3\u9654\u964F\u9651\u9653\u964A\u964E\u501E\u5005\u5007\u5013\u5022\u5030\u501B\u4FF5\u4FF4\u5033\u5037\u502C\u4FF6\u4FF7\u5017\u501C\u5020\u5027\u5035\u502F\u5031\u500E\u515A\u5194\u5193\u51CA\u51C4\u51C5\u51C8\u51CE\u5261\u525A\u5252\u525E\u525F\u5255\u5262\u52CD\u530E\u539E\u5526\u54E2\u5517\u5512\u54E7\u54F3\u54E4\u551A\u54FF\u5504\u5508\u54EB\u5511\u5505\u54F1"],
    ["d140", "\u550A\u54FB\u54F7\u54F8\u54E0\u550E\u5503\u550B\u5701\u5702\u57CC\u5832\u57D5\u57D2\u57BA\u57C6\u57BD\u57BC\u57B8\u57B6\u57BF\u57C7\u57D0\u57B9\u57C1\u590E\u594A\u5A19\u5A16\u5A2D\u5A2E\u5A15\u5A0F\u5A17\u5A0A\u5A1E\u5A33\u5B6C\u5BA7\u5BAD\u5BAC\u5C03\u5C56\u5C54\u5CEC\u5CFF\u5CEE\u5CF1\u5CF7\u5D00\u5CF9\u5E29\u5E28\u5EA8\u5EAE\u5EAA\u5EAC\u5F33\u5F30\u5F67\u605D\u605A\u6067"],
    ["d1a1", "\u6041\u60A2\u6088\u6080\u6092\u6081\u609D\u6083\u6095\u609B\u6097\u6087\u609C\u608E\u6219\u6246\u62F2\u6310\u6356\u632C\u6344\u6345\u6336\u6343\u63E4\u6339\u634B\u634A\u633C\u6329\u6341\u6334\u6358\u6354\u6359\u632D\u6347\u6333\u635A\u6351\u6338\u6357\u6340\u6348\u654A\u6546\u65C6\u65C3\u65C4\u65C2\u664A\u665F\u6647\u6651\u6712\u6713\u681F\u681A\u6849\u6832\u6833\u683B\u684B\u684F\u6816\u6831\u681C\u6835\u682B\u682D\u682F\u684E\u6844\u6834\u681D\u6812\u6814\u6826\u6828\u682E\u684D\u683A\u6825\u6820\u6B2C\u6B2F\u6B2D\u6B31\u6B34\u6B6D\u8082\u6B88\u6BE6\u6BE4"],
    ["d240", "\u6BE8\u6BE3\u6BE2\u6BE7\u6C25\u6D7A\u6D63\u6D64\u6D76\u6D0D\u6D61\u6D92\u6D58\u6D62\u6D6D\u6D6F\u6D91\u6D8D\u6DEF\u6D7F\u6D86\u6D5E\u6D67\u6D60\u6D97\u6D70\u6D7C\u6D5F\u6D82\u6D98\u6D2F\u6D68\u6D8B\u6D7E\u6D80\u6D84\u6D16\u6D83\u6D7B\u6D7D\u6D75\u6D90\u70DC\u70D3\u70D1\u70DD\u70CB\u7F39\u70E2\u70D7\u70D2\u70DE\u70E0\u70D4\u70CD\u70C5\u70C6\u70C7\u70DA\u70CE\u70E1\u7242\u7278"],
    ["d2a1", "\u7277\u7276\u7300\u72FA\u72F4\u72FE\u72F6\u72F3\u72FB\u7301\u73D3\u73D9\u73E5\u73D6\u73BC\u73E7\u73E3\u73E9\u73DC\u73D2\u73DB\u73D4\u73DD\u73DA\u73D7\u73D8\u73E8\u74DE\u74DF\u74F4\u74F5\u7521\u755B\u755F\u75B0\u75C1\u75BB\u75C4\u75C0\u75BF\u75B6\u75BA\u768A\u76C9\u771D\u771B\u7710\u7713\u7712\u7723\u7711\u7715\u7719\u771A\u7722\u7727\u7823\u782C\u7822\u7835\u782F\u7828\u782E\u782B\u7821\u7829\u7833\u782A\u7831\u7954\u795B\u794F\u795C\u7953\u7952\u7951\u79EB\u79EC\u79E0\u79EE\u79ED\u79EA\u79DC\u79DE\u79DD\u7A86\u7A89\u7A85\u7A8B\u7A8C\u7A8A\u7A87\u7AD8\u7B10"],
    ["d340", "\u7B04\u7B13\u7B05\u7B0F\u7B08\u7B0A\u7B0E\u7B09\u7B12\u7C84\u7C91\u7C8A\u7C8C\u7C88\u7C8D\u7C85\u7D1E\u7D1D\u7D11\u7D0E\u7D18\u7D16\u7D13\u7D1F\u7D12\u7D0F\u7D0C\u7F5C\u7F61\u7F5E\u7F60\u7F5D\u7F5B\u7F96\u7F92\u7FC3\u7FC2\u7FC0\u8016\u803E\u8039\u80FA\u80F2\u80F9\u80F5\u8101\u80FB\u8100\u8201\u822F\u8225\u8333\u832D\u8344\u8319\u8351\u8325\u8356\u833F\u8341\u8326\u831C\u8322"],
    ["d3a1", "\u8342\u834E\u831B\u832A\u8308\u833C\u834D\u8316\u8324\u8320\u8337\u832F\u8329\u8347\u8345\u834C\u8353\u831E\u832C\u834B\u8327\u8348\u8653\u8652\u86A2\u86A8\u8696\u868D\u8691\u869E\u8687\u8697\u8686\u868B\u869A\u8685\u86A5\u8699\u86A1\u86A7\u8695\u8698\u868E\u869D\u8690\u8694\u8843\u8844\u886D\u8875\u8876\u8872\u8880\u8871\u887F\u886F\u8883\u887E\u8874\u887C\u8A12\u8C47\u8C57\u8C7B\u8CA4\u8CA3\u8D76\u8D78\u8DB5\u8DB7\u8DB6\u8ED1\u8ED3\u8FFE\u8FF5\u9002\u8FFF\u8FFB\u9004\u8FFC\u8FF6\u90D6\u90E0\u90D9\u90DA\u90E3\u90DF\u90E5\u90D8\u90DB\u90D7\u90DC\u90E4\u9150"],
    ["d440", "\u914E\u914F\u91D5\u91E2\u91DA\u965C\u965F\u96BC\u98E3\u9ADF\u9B2F\u4E7F\u5070\u506A\u5061\u505E\u5060\u5053\u504B\u505D\u5072\u5048\u504D\u5041\u505B\u504A\u5062\u5015\u5045\u505F\u5069\u506B\u5063\u5064\u5046\u5040\u506E\u5073\u5057\u5051\u51D0\u526B\u526D\u526C\u526E\u52D6\u52D3\u532D\u539C\u5575\u5576\u553C\u554D\u5550\u5534\u552A\u5551\u5562\u5536\u5535\u5530\u5552\u5545"],
    ["d4a1", "\u550C\u5532\u5565\u554E\u5539\u5548\u552D\u553B\u5540\u554B\u570A\u5707\u57FB\u5814\u57E2\u57F6\u57DC\u57F4\u5800\u57ED\u57FD\u5808\u57F8\u580B\u57F3\u57CF\u5807\u57EE\u57E3\u57F2\u57E5\u57EC\u57E1\u580E\u57FC\u5810\u57E7\u5801\u580C\u57F1\u57E9\u57F0\u580D\u5804\u595C\u5A60\u5A58\u5A55\u5A67\u5A5E\u5A38\u5A35\u5A6D\u5A50\u5A5F\u5A65\u5A6C\u5A53\u5A64\u5A57\u5A43\u5A5D\u5A52\u5A44\u5A5B\u5A48\u5A8E\u5A3E\u5A4D\u5A39\u5A4C\u5A70\u5A69\u5A47\u5A51\u5A56\u5A42\u5A5C\u5B72\u5B6E\u5BC1\u5BC0\u5C59\u5D1E\u5D0B\u5D1D\u5D1A\u5D20\u5D0C\u5D28\u5D0D\u5D26\u5D25\u5D0F"],
    ["d540", "\u5D30\u5D12\u5D23\u5D1F\u5D2E\u5E3E\u5E34\u5EB1\u5EB4\u5EB9\u5EB2\u5EB3\u5F36\u5F38\u5F9B\u5F96\u5F9F\u608A\u6090\u6086\u60BE\u60B0\u60BA\u60D3\u60D4\u60CF\u60E4\u60D9\u60DD\u60C8\u60B1\u60DB\u60B7\u60CA\u60BF\u60C3\u60CD\u60C0\u6332\u6365\u638A\u6382\u637D\u63BD\u639E\u63AD\u639D\u6397\u63AB\u638E\u636F\u6387\u6390\u636E\u63AF\u6375\u639C\u636D\u63AE\u637C\u63A4\u633B\u639F"],
    ["d5a1", "\u6378\u6385\u6381\u6391\u638D\u6370\u6553\u65CD\u6665\u6661\u665B\u6659\u665C\u6662\u6718\u6879\u6887\u6890\u689C\u686D\u686E\u68AE\u68AB\u6956\u686F\u68A3\u68AC\u68A9\u6875\u6874\u68B2\u688F\u6877\u6892\u687C\u686B\u6872\u68AA\u6880\u6871\u687E\u689B\u6896\u688B\u68A0\u6889\u68A4\u6878\u687B\u6891\u688C\u688A\u687D\u6B36\u6B33\u6B37\u6B38\u6B91\u6B8F\u6B8D\u6B8E\u6B8C\u6C2A\u6DC0\u6DAB\u6DB4\u6DB3\u6E74\u6DAC\u6DE9\u6DE2\u6DB7\u6DF6\u6DD4\u6E00\u6DC8\u6DE0\u6DDF\u6DD6\u6DBE\u6DE5\u6DDC\u6DDD\u6DDB\u6DF4\u6DCA\u6DBD\u6DED\u6DF0\u6DBA\u6DD5\u6DC2\u6DCF\u6DC9"],
    ["d640", "\u6DD0\u6DF2\u6DD3\u6DFD\u6DD7\u6DCD\u6DE3\u6DBB\u70FA\u710D\u70F7\u7117\u70F4\u710C\u70F0\u7104\u70F3\u7110\u70FC\u70FF\u7106\u7113\u7100\u70F8\u70F6\u710B\u7102\u710E\u727E\u727B\u727C\u727F\u731D\u7317\u7307\u7311\u7318\u730A\u7308\u72FF\u730F\u731E\u7388\u73F6\u73F8\u73F5\u7404\u7401\u73FD\u7407\u7400\u73FA\u73FC\u73FF\u740C\u740B\u73F4\u7408\u7564\u7563\u75CE\u75D2\u75CF"],
    ["d6a1", "\u75CB\u75CC\u75D1\u75D0\u768F\u7689\u76D3\u7739\u772F\u772D\u7731\u7732\u7734\u7733\u773D\u7725\u773B\u7735\u7848\u7852\u7849\u784D\u784A\u784C\u7826\u7845\u7850\u7964\u7967\u7969\u796A\u7963\u796B\u7961\u79BB\u79FA\u79F8\u79F6\u79F7\u7A8F\u7A94\u7A90\u7B35\u7B47\u7B34\u7B25\u7B30\u7B22\u7B24\u7B33\u7B18\u7B2A\u7B1D\u7B31\u7B2B\u7B2D\u7B2F\u7B32\u7B38\u7B1A\u7B23\u7C94\u7C98\u7C96\u7CA3\u7D35\u7D3D\u7D38\u7D36\u7D3A\u7D45\u7D2C\u7D29\u7D41\u7D47\u7D3E\u7D3F\u7D4A\u7D3B\u7D28\u7F63\u7F95\u7F9C\u7F9D\u7F9B\u7FCA\u7FCB\u7FCD\u7FD0\u7FD1\u7FC7\u7FCF\u7FC9\u801F"],
    ["d740", "\u801E\u801B\u8047\u8043\u8048\u8118\u8125\u8119\u811B\u812D\u811F\u812C\u811E\u8121\u8115\u8127\u811D\u8122\u8211\u8238\u8233\u823A\u8234\u8232\u8274\u8390\u83A3\u83A8\u838D\u837A\u8373\u83A4\u8374\u838F\u8381\u8395\u8399\u8375\u8394\u83A9\u837D\u8383\u838C\u839D\u839B\u83AA\u838B\u837E\u83A5\u83AF\u8388\u8397\u83B0\u837F\u83A6\u8387\u83AE\u8376\u839A\u8659\u8656\u86BF\u86B7"],
    ["d7a1", "\u86C2\u86C1\u86C5\u86BA\u86B0\u86C8\u86B9\u86B3\u86B8\u86CC\u86B4\u86BB\u86BC\u86C3\u86BD\u86BE\u8852\u8889\u8895\u88A8\u88A2\u88AA\u889A\u8891\u88A1\u889F\u8898\u88A7\u8899\u889B\u8897\u88A4\u88AC\u888C\u8893\u888E\u8982\u89D6\u89D9\u89D5\u8A30\u8A27\u8A2C\u8A1E\u8C39\u8C3B\u8C5C\u8C5D\u8C7D\u8CA5\u8D7D\u8D7B\u8D79\u8DBC\u8DC2\u8DB9\u8DBF\u8DC1\u8ED8\u8EDE\u8EDD\u8EDC\u8ED7\u8EE0\u8EE1\u9024\u900B\u9011\u901C\u900C\u9021\u90EF\u90EA\u90F0\u90F4\u90F2\u90F3\u90D4\u90EB\u90EC\u90E9\u9156\u9158\u915A\u9153\u9155\u91EC\u91F4\u91F1\u91F3\u91F8\u91E4\u91F9\u91EA"],
    ["d840", "\u91EB\u91F7\u91E8\u91EE\u957A\u9586\u9588\u967C\u966D\u966B\u9671\u966F\u96BF\u976A\u9804\u98E5\u9997\u509B\u5095\u5094\u509E\u508B\u50A3\u5083\u508C\u508E\u509D\u5068\u509C\u5092\u5082\u5087\u515F\u51D4\u5312\u5311\u53A4\u53A7\u5591\u55A8\u55A5\u55AD\u5577\u5645\u55A2\u5593\u5588\u558F\u55B5\u5581\u55A3\u5592\u55A4\u557D\u558C\u55A6\u557F\u5595\u55A1\u558E\u570C\u5829\u5837"],
    ["d8a1", "\u5819\u581E\u5827\u5823\u5828\u57F5\u5848\u5825\u581C\u581B\u5833\u583F\u5836\u582E\u5839\u5838\u582D\u582C\u583B\u5961\u5AAF\u5A94\u5A9F\u5A7A\u5AA2\u5A9E\u5A78\u5AA6\u5A7C\u5AA5\u5AAC\u5A95\u5AAE\u5A37\u5A84\u5A8A\u5A97\u5A83\u5A8B\u5AA9\u5A7B\u5A7D\u5A8C\u5A9C\u5A8F\u5A93\u5A9D\u5BEA\u5BCD\u5BCB\u5BD4\u5BD1\u5BCA\u5BCE\u5C0C\u5C30\u5D37\u5D43\u5D6B\u5D41\u5D4B\u5D3F\u5D35\u5D51\u5D4E\u5D55\u5D33\u5D3A\u5D52\u5D3D\u5D31\u5D59\u5D42\u5D39\u5D49\u5D38\u5D3C\u5D32\u5D36\u5D40\u5D45\u5E44\u5E41\u5F58\u5FA6\u5FA5\u5FAB\u60C9\u60B9\u60CC\u60E2\u60CE\u60C4\u6114"],
    ["d940", "\u60F2\u610A\u6116\u6105\u60F5\u6113\u60F8\u60FC\u60FE\u60C1\u6103\u6118\u611D\u6110\u60FF\u6104\u610B\u624A\u6394\u63B1\u63B0\u63CE\u63E5\u63E8\u63EF\u63C3\u649D\u63F3\u63CA\u63E0\u63F6\u63D5\u63F2\u63F5\u6461\u63DF\u63BE\u63DD\u63DC\u63C4\u63D8\u63D3\u63C2\u63C7\u63CC\u63CB\u63C8\u63F0\u63D7\u63D9\u6532\u6567\u656A\u6564\u655C\u6568\u6565\u658C\u659D\u659E\u65AE\u65D0\u65D2"],
    ["d9a1", "\u667C\u666C\u667B\u6680\u6671\u6679\u666A\u6672\u6701\u690C\u68D3\u6904\u68DC\u692A\u68EC\u68EA\u68F1\u690F\u68D6\u68F7\u68EB\u68E4\u68F6\u6913\u6910\u68F3\u68E1\u6907\u68CC\u6908\u6970\u68B4\u6911\u68EF\u68C6\u6914\u68F8\u68D0\u68FD\u68FC\u68E8\u690B\u690A\u6917\u68CE\u68C8\u68DD\u68DE\u68E6\u68F4\u68D1\u6906\u68D4\u68E9\u6915\u6925\u68C7\u6B39\u6B3B\u6B3F\u6B3C\u6B94\u6B97\u6B99\u6B95\u6BBD\u6BF0\u6BF2\u6BF3\u6C30\u6DFC\u6E46\u6E47\u6E1F\u6E49\u6E88\u6E3C\u6E3D\u6E45\u6E62\u6E2B\u6E3F\u6E41\u6E5D\u6E73\u6E1C\u6E33\u6E4B\u6E40\u6E51\u6E3B\u6E03\u6E2E\u6E5E"],
    ["da40", "\u6E68\u6E5C\u6E61\u6E31\u6E28\u6E60\u6E71\u6E6B\u6E39\u6E22\u6E30\u6E53\u6E65\u6E27\u6E78\u6E64\u6E77\u6E55\u6E79\u6E52\u6E66\u6E35\u6E36\u6E5A\u7120\u711E\u712F\u70FB\u712E\u7131\u7123\u7125\u7122\u7132\u711F\u7128\u713A\u711B\u724B\u725A\u7288\u7289\u7286\u7285\u728B\u7312\u730B\u7330\u7322\u7331\u7333\u7327\u7332\u732D\u7326\u7323\u7335\u730C\u742E\u742C\u7430\u742B\u7416"],
    ["daa1", "\u741A\u7421\u742D\u7431\u7424\u7423\u741D\u7429\u7420\u7432\u74FB\u752F\u756F\u756C\u75E7\u75DA\u75E1\u75E6\u75DD\u75DF\u75E4\u75D7\u7695\u7692\u76DA\u7746\u7747\u7744\u774D\u7745\u774A\u774E\u774B\u774C\u77DE\u77EC\u7860\u7864\u7865\u785C\u786D\u7871\u786A\u786E\u7870\u7869\u7868\u785E\u7862\u7974\u7973\u7972\u7970\u7A02\u7A0A\u7A03\u7A0C\u7A04\u7A99\u7AE6\u7AE4\u7B4A\u7B3B\u7B44\u7B48\u7B4C\u7B4E\u7B40\u7B58\u7B45\u7CA2\u7C9E\u7CA8\u7CA1\u7D58\u7D6F\u7D63\u7D53\u7D56\u7D67\u7D6A\u7D4F\u7D6D\u7D5C\u7D6B\u7D52\u7D54\u7D69\u7D51\u7D5F\u7D4E\u7F3E\u7F3F\u7F65"],
    ["db40", "\u7F66\u7FA2\u7FA0\u7FA1\u7FD7\u8051\u804F\u8050\u80FE\u80D4\u8143\u814A\u8152\u814F\u8147\u813D\u814D\u813A\u81E6\u81EE\u81F7\u81F8\u81F9\u8204\u823C\u823D\u823F\u8275\u833B\u83CF\u83F9\u8423\u83C0\u83E8\u8412\u83E7\u83E4\u83FC\u83F6\u8410\u83C6\u83C8\u83EB\u83E3\u83BF\u8401\u83DD\u83E5\u83D8\u83FF\u83E1\u83CB\u83CE\u83D6\u83F5\u83C9\u8409\u840F\u83DE\u8411\u8406\u83C2\u83F3"],
    ["dba1", "\u83D5\u83FA\u83C7\u83D1\u83EA\u8413\u83C3\u83EC\u83EE\u83C4\u83FB\u83D7\u83E2\u841B\u83DB\u83FE\u86D8\u86E2\u86E6\u86D3\u86E3\u86DA\u86EA\u86DD\u86EB\u86DC\u86EC\u86E9\u86D7\u86E8\u86D1\u8848\u8856\u8855\u88BA\u88D7\u88B9\u88B8\u88C0\u88BE\u88B6\u88BC\u88B7\u88BD\u88B2\u8901\u88C9\u8995\u8998\u8997\u89DD\u89DA\u89DB\u8A4E\u8A4D\u8A39\u8A59\u8A40\u8A57\u8A58\u8A44\u8A45\u8A52\u8A48\u8A51\u8A4A\u8A4C\u8A4F\u8C5F\u8C81\u8C80\u8CBA\u8CBE\u8CB0\u8CB9\u8CB5\u8D84\u8D80\u8D89\u8DD8\u8DD3\u8DCD\u8DC7\u8DD6\u8DDC\u8DCF\u8DD5\u8DD9\u8DC8\u8DD7\u8DC5\u8EEF\u8EF7\u8EFA"],
    ["dc40", "\u8EF9\u8EE6\u8EEE\u8EE5\u8EF5\u8EE7\u8EE8\u8EF6\u8EEB\u8EF1\u8EEC\u8EF4\u8EE9\u902D\u9034\u902F\u9106\u912C\u9104\u90FF\u90FC\u9108\u90F9\u90FB\u9101\u9100\u9107\u9105\u9103\u9161\u9164\u915F\u9162\u9160\u9201\u920A\u9225\u9203\u921A\u9226\u920F\u920C\u9200\u9212\u91FF\u91FD\u9206\u9204\u9227\u9202\u921C\u9224\u9219\u9217\u9205\u9216\u957B\u958D\u958C\u9590\u9687\u967E\u9688"],
    ["dca1", "\u9689\u9683\u9680\u96C2\u96C8\u96C3\u96F1\u96F0\u976C\u9770\u976E\u9807\u98A9\u98EB\u9CE6\u9EF9\u4E83\u4E84\u4EB6\u50BD\u50BF\u50C6\u50AE\u50C4\u50CA\u50B4\u50C8\u50C2\u50B0\u50C1\u50BA\u50B1\u50CB\u50C9\u50B6\u50B8\u51D7\u527A\u5278\u527B\u527C\u55C3\u55DB\u55CC\u55D0\u55CB\u55CA\u55DD\u55C0\u55D4\u55C4\u55E9\u55BF\u55D2\u558D\u55CF\u55D5\u55E2\u55D6\u55C8\u55F2\u55CD\u55D9\u55C2\u5714\u5853\u5868\u5864\u584F\u584D\u5849\u586F\u5855\u584E\u585D\u5859\u5865\u585B\u583D\u5863\u5871\u58FC\u5AC7\u5AC4\u5ACB\u5ABA\u5AB8\u5AB1\u5AB5\u5AB0\u5ABF\u5AC8\u5ABB\u5AC6"],
    ["dd40", "\u5AB7\u5AC0\u5ACA\u5AB4\u5AB6\u5ACD\u5AB9\u5A90\u5BD6\u5BD8\u5BD9\u5C1F\u5C33\u5D71\u5D63\u5D4A\u5D65\u5D72\u5D6C\u5D5E\u5D68\u5D67\u5D62\u5DF0\u5E4F\u5E4E\u5E4A\u5E4D\u5E4B\u5EC5\u5ECC\u5EC6\u5ECB\u5EC7\u5F40\u5FAF\u5FAD\u60F7\u6149\u614A\u612B\u6145\u6136\u6132\u612E\u6146\u612F\u614F\u6129\u6140\u6220\u9168\u6223\u6225\u6224\u63C5\u63F1\u63EB\u6410\u6412\u6409\u6420\u6424"],
    ["dda1", "\u6433\u6443\u641F\u6415\u6418\u6439\u6437\u6422\u6423\u640C\u6426\u6430\u6428\u6441\u6435\u642F\u640A\u641A\u6440\u6425\u6427\u640B\u63E7\u641B\u642E\u6421\u640E\u656F\u6592\u65D3\u6686\u668C\u6695\u6690\u668B\u668A\u6699\u6694\u6678\u6720\u6966\u695F\u6938\u694E\u6962\u6971\u693F\u6945\u696A\u6939\u6942\u6957\u6959\u697A\u6948\u6949\u6935\u696C\u6933\u693D\u6965\u68F0\u6978\u6934\u6969\u6940\u696F\u6944\u6976\u6958\u6941\u6974\u694C\u693B\u694B\u6937\u695C\u694F\u6951\u6932\u6952\u692F\u697B\u693C\u6B46\u6B45\u6B43\u6B42\u6B48\u6B41\u6B9B\uFA0D\u6BFB\u6BFC"],
    ["de40", "\u6BF9\u6BF7\u6BF8\u6E9B\u6ED6\u6EC8\u6E8F\u6EC0\u6E9F\u6E93\u6E94\u6EA0\u6EB1\u6EB9\u6EC6\u6ED2\u6EBD\u6EC1\u6E9E\u6EC9\u6EB7\u6EB0\u6ECD\u6EA6\u6ECF\u6EB2\u6EBE\u6EC3\u6EDC\u6ED8\u6E99\u6E92\u6E8E\u6E8D\u6EA4\u6EA1\u6EBF\u6EB3\u6ED0\u6ECA\u6E97\u6EAE\u6EA3\u7147\u7154\u7152\u7163\u7160\u7141\u715D\u7162\u7172\u7178\u716A\u7161\u7142\u7158\u7143\u714B\u7170\u715F\u7150\u7153"],
    ["dea1", "\u7144\u714D\u715A\u724F\u728D\u728C\u7291\u7290\u728E\u733C\u7342\u733B\u733A\u7340\u734A\u7349\u7444\u744A\u744B\u7452\u7451\u7457\u7440\u744F\u7450\u744E\u7442\u7446\u744D\u7454\u74E1\u74FF\u74FE\u74FD\u751D\u7579\u7577\u6983\u75EF\u760F\u7603\u75F7\u75FE\u75FC\u75F9\u75F8\u7610\u75FB\u75F6\u75ED\u75F5\u75FD\u7699\u76B5\u76DD\u7755\u775F\u7760\u7752\u7756\u775A\u7769\u7767\u7754\u7759\u776D\u77E0\u7887\u789A\u7894\u788F\u7884\u7895\u7885\u7886\u78A1\u7883\u7879\u7899\u7880\u7896\u787B\u797C\u7982\u797D\u7979\u7A11\u7A18\u7A19\u7A12\u7A17\u7A15\u7A22\u7A13"],
    ["df40", "\u7A1B\u7A10\u7AA3\u7AA2\u7A9E\u7AEB\u7B66\u7B64\u7B6D\u7B74\u7B69\u7B72\u7B65\u7B73\u7B71\u7B70\u7B61\u7B78\u7B76\u7B63\u7CB2\u7CB4\u7CAF\u7D88\u7D86\u7D80\u7D8D\u7D7F\u7D85\u7D7A\u7D8E\u7D7B\u7D83\u7D7C\u7D8C\u7D94\u7D84\u7D7D\u7D92\u7F6D\u7F6B\u7F67\u7F68\u7F6C\u7FA6\u7FA5\u7FA7\u7FDB\u7FDC\u8021\u8164\u8160\u8177\u815C\u8169\u815B\u8162\u8172\u6721\u815E\u8176\u8167\u816F"],
    ["dfa1", "\u8144\u8161\u821D\u8249\u8244\u8240\u8242\u8245\u84F1\u843F\u8456\u8476\u8479\u848F\u848D\u8465\u8451\u8440\u8486\u8467\u8430\u844D\u847D\u845A\u8459\u8474\u8473\u845D\u8507\u845E\u8437\u843A\u8434\u847A\u8443\u8478\u8432\u8445\u8429\u83D9\u844B\u842F\u8442\u842D\u845F\u8470\u8439\u844E\u844C\u8452\u846F\u84C5\u848E\u843B\u8447\u8436\u8433\u8468\u847E\u8444\u842B\u8460\u8454\u846E\u8450\u870B\u8704\u86F7\u870C\u86FA\u86D6\u86F5\u874D\u86F8\u870E\u8709\u8701\u86F6\u870D\u8705\u88D6\u88CB\u88CD\u88CE\u88DE\u88DB\u88DA\u88CC\u88D0\u8985\u899B\u89DF\u89E5\u89E4"],
    ["e040", "\u89E1\u89E0\u89E2\u89DC\u89E6\u8A76\u8A86\u8A7F\u8A61\u8A3F\u8A77\u8A82\u8A84\u8A75\u8A83\u8A81\u8A74\u8A7A\u8C3C\u8C4B\u8C4A\u8C65\u8C64\u8C66\u8C86\u8C84\u8C85\u8CCC\u8D68\u8D69\u8D91\u8D8C\u8D8E\u8D8F\u8D8D\u8D93\u8D94\u8D90\u8D92\u8DF0\u8DE0\u8DEC\u8DF1\u8DEE\u8DD0\u8DE9\u8DE3\u8DE2\u8DE7\u8DF2\u8DEB\u8DF4\u8F06\u8EFF\u8F01\u8F00\u8F05\u8F07\u8F08\u8F02\u8F0B\u9052\u903F"],
    ["e0a1", "\u9044\u9049\u903D\u9110\u910D\u910F\u9111\u9116\u9114\u910B\u910E\u916E\u916F\u9248\u9252\u9230\u923A\u9266\u9233\u9265\u925E\u9283\u922E\u924A\u9246\u926D\u926C\u924F\u9260\u9267\u926F\u9236\u9261\u9270\u9231\u9254\u9263\u9250\u9272\u924E\u9253\u924C\u9256\u9232\u959F\u959C\u959E\u959B\u9692\u9693\u9691\u9697\u96CE\u96FA\u96FD\u96F8\u96F5\u9773\u9777\u9778\u9772\u980F\u980D\u980E\u98AC\u98F6\u98F9\u99AF\u99B2\u99B0\u99B5\u9AAD\u9AAB\u9B5B\u9CEA\u9CED\u9CE7\u9E80\u9EFD\u50E6\u50D4\u50D7\u50E8\u50F3\u50DB\u50EA\u50DD\u50E4\u50D3\u50EC\u50F0\u50EF\u50E3\u50E0"],
    ["e140", "\u51D8\u5280\u5281\u52E9\u52EB\u5330\u53AC\u5627\u5615\u560C\u5612\u55FC\u560F\u561C\u5601\u5613\u5602\u55FA\u561D\u5604\u55FF\u55F9\u5889\u587C\u5890\u5898\u5886\u5881\u587F\u5874\u588B\u587A\u5887\u5891\u588E\u5876\u5882\u5888\u587B\u5894\u588F\u58FE\u596B\u5ADC\u5AEE\u5AE5\u5AD5\u5AEA\u5ADA\u5AED\u5AEB\u5AF3\u5AE2\u5AE0\u5ADB\u5AEC\u5ADE\u5ADD\u5AD9\u5AE8\u5ADF\u5B77\u5BE0"],
    ["e1a1", "\u5BE3\u5C63\u5D82\u5D80\u5D7D\u5D86\u5D7A\u5D81\u5D77\u5D8A\u5D89\u5D88\u5D7E\u5D7C\u5D8D\u5D79\u5D7F\u5E58\u5E59\u5E53\u5ED8\u5ED1\u5ED7\u5ECE\u5EDC\u5ED5\u5ED9\u5ED2\u5ED4\u5F44\u5F43\u5F6F\u5FB6\u612C\u6128\u6141\u615E\u6171\u6173\u6152\u6153\u6172\u616C\u6180\u6174\u6154\u617A\u615B\u6165\u613B\u616A\u6161\u6156\u6229\u6227\u622B\u642B\u644D\u645B\u645D\u6474\u6476\u6472\u6473\u647D\u6475\u6466\u64A6\u644E\u6482\u645E\u645C\u644B\u6453\u6460\u6450\u647F\u643F\u646C\u646B\u6459\u6465\u6477\u6573\u65A0\u66A1\u66A0\u669F\u6705\u6704\u6722\u69B1\u69B6\u69C9"],
    ["e240", "\u69A0\u69CE\u6996\u69B0\u69AC\u69BC\u6991\u6999\u698E\u69A7\u698D\u69A9\u69BE\u69AF\u69BF\u69C4\u69BD\u69A4\u69D4\u69B9\u69CA\u699A\u69CF\u69B3\u6993\u69AA\u69A1\u699E\u69D9\u6997\u6990\u69C2\u69B5\u69A5\u69C6\u6B4A\u6B4D\u6B4B\u6B9E\u6B9F\u6BA0\u6BC3\u6BC4\u6BFE\u6ECE\u6EF5\u6EF1\u6F03\u6F25\u6EF8\u6F37\u6EFB\u6F2E\u6F09\u6F4E\u6F19\u6F1A\u6F27\u6F18\u6F3B\u6F12\u6EED\u6F0A"],
    ["e2a1", "\u6F36\u6F73\u6EF9\u6EEE\u6F2D\u6F40\u6F30\u6F3C\u6F35\u6EEB\u6F07\u6F0E\u6F43\u6F05\u6EFD\u6EF6\u6F39\u6F1C\u6EFC\u6F3A\u6F1F\u6F0D\u6F1E\u6F08\u6F21\u7187\u7190\u7189\u7180\u7185\u7182\u718F\u717B\u7186\u7181\u7197\u7244\u7253\u7297\u7295\u7293\u7343\u734D\u7351\u734C\u7462\u7473\u7471\u7475\u7472\u7467\u746E\u7500\u7502\u7503\u757D\u7590\u7616\u7608\u760C\u7615\u7611\u760A\u7614\u76B8\u7781\u777C\u7785\u7782\u776E\u7780\u776F\u777E\u7783\u78B2\u78AA\u78B4\u78AD\u78A8\u787E\u78AB\u789E\u78A5\u78A0\u78AC\u78A2\u78A4\u7998\u798A\u798B\u7996\u7995\u7994\u7993"],
    ["e340", "\u7997\u7988\u7992\u7990\u7A2B\u7A4A\u7A30\u7A2F\u7A28\u7A26\u7AA8\u7AAB\u7AAC\u7AEE\u7B88\u7B9C\u7B8A\u7B91\u7B90\u7B96\u7B8D\u7B8C\u7B9B\u7B8E\u7B85\u7B98\u5284\u7B99\u7BA4\u7B82\u7CBB\u7CBF\u7CBC\u7CBA\u7DA7\u7DB7\u7DC2\u7DA3\u7DAA\u7DC1\u7DC0\u7DC5\u7D9D\u7DCE\u7DC4\u7DC6\u7DCB\u7DCC\u7DAF\u7DB9\u7D96\u7DBC\u7D9F\u7DA6\u7DAE\u7DA9\u7DA1\u7DC9\u7F73\u7FE2\u7FE3\u7FE5\u7FDE"],
    ["e3a1", "\u8024\u805D\u805C\u8189\u8186\u8183\u8187\u818D\u818C\u818B\u8215\u8497\u84A4\u84A1\u849F\u84BA\u84CE\u84C2\u84AC\u84AE\u84AB\u84B9\u84B4\u84C1\u84CD\u84AA\u849A\u84B1\u84D0\u849D\u84A7\u84BB\u84A2\u8494\u84C7\u84CC\u849B\u84A9\u84AF\u84A8\u84D6\u8498\u84B6\u84CF\u84A0\u84D7\u84D4\u84D2\u84DB\u84B0\u8491\u8661\u8733\u8723\u8728\u876B\u8740\u872E\u871E\u8721\u8719\u871B\u8743\u872C\u8741\u873E\u8746\u8720\u8732\u872A\u872D\u873C\u8712\u873A\u8731\u8735\u8742\u8726\u8727\u8738\u8724\u871A\u8730\u8711\u88F7\u88E7\u88F1\u88F2\u88FA\u88FE\u88EE\u88FC\u88F6\u88FB"],
    ["e440", "\u88F0\u88EC\u88EB\u899D\u89A1\u899F\u899E\u89E9\u89EB\u89E8\u8AAB\u8A99\u8A8B\u8A92\u8A8F\u8A96\u8C3D\u8C68\u8C69\u8CD5\u8CCF\u8CD7\u8D96\u8E09\u8E02\u8DFF\u8E0D\u8DFD\u8E0A\u8E03\u8E07\u8E06\u8E05\u8DFE\u8E00\u8E04\u8F10\u8F11\u8F0E\u8F0D\u9123\u911C\u9120\u9122\u911F\u911D\u911A\u9124\u9121\u911B\u917A\u9172\u9179\u9173\u92A5\u92A4\u9276\u929B\u927A\u92A0\u9294\u92AA\u928D"],
    ["e4a1", "\u92A6\u929A\u92AB\u9279\u9297\u927F\u92A3\u92EE\u928E\u9282\u9295\u92A2\u927D\u9288\u92A1\u928A\u9286\u928C\u9299\u92A7\u927E\u9287\u92A9\u929D\u928B\u922D\u969E\u96A1\u96FF\u9758\u977D\u977A\u977E\u9783\u9780\u9782\u977B\u9784\u9781\u977F\u97CE\u97CD\u9816\u98AD\u98AE\u9902\u9900\u9907\u999D\u999C\u99C3\u99B9\u99BB\u99BA\u99C2\u99BD\u99C7\u9AB1\u9AE3\u9AE7\u9B3E\u9B3F\u9B60\u9B61\u9B5F\u9CF1\u9CF2\u9CF5\u9EA7\u50FF\u5103\u5130\u50F8\u5106\u5107\u50F6\u50FE\u510B\u510C\u50FD\u510A\u528B\u528C\u52F1\u52EF\u5648\u5642\u564C\u5635\u5641\u564A\u5649\u5646\u5658"],
    ["e540", "\u565A\u5640\u5633\u563D\u562C\u563E\u5638\u562A\u563A\u571A\u58AB\u589D\u58B1\u58A0\u58A3\u58AF\u58AC\u58A5\u58A1\u58FF\u5AFF\u5AF4\u5AFD\u5AF7\u5AF6\u5B03\u5AF8\u5B02\u5AF9\u5B01\u5B07\u5B05\u5B0F\u5C67\u5D99\u5D97\u5D9F\u5D92\u5DA2\u5D93\u5D95\u5DA0\u5D9C\u5DA1\u5D9A\u5D9E\u5E69\u5E5D\u5E60\u5E5C\u7DF3\u5EDB\u5EDE\u5EE1\u5F49\u5FB2\u618B\u6183\u6179\u61B1\u61B0\u61A2\u6189"],
    ["e5a1", "\u619B\u6193\u61AF\u61AD\u619F\u6192\u61AA\u61A1\u618D\u6166\u61B3\u622D\u646E\u6470\u6496\u64A0\u6485\u6497\u649C\u648F\u648B\u648A\u648C\u64A3\u649F\u6468\u64B1\u6498\u6576\u657A\u6579\u657B\u65B2\u65B3\u66B5\u66B0\u66A9\u66B2\u66B7\u66AA\u66AF\u6A00\u6A06\u6A17\u69E5\u69F8\u6A15\u69F1\u69E4\u6A20\u69FF\u69EC\u69E2\u6A1B\u6A1D\u69FE\u6A27\u69F2\u69EE\u6A14\u69F7\u69E7\u6A40\u6A08\u69E6\u69FB\u6A0D\u69FC\u69EB\u6A09\u6A04\u6A18\u6A25\u6A0F\u69F6\u6A26\u6A07\u69F4\u6A16\u6B51\u6BA5\u6BA3\u6BA2\u6BA6\u6C01\u6C00\u6BFF\u6C02\u6F41\u6F26\u6F7E\u6F87\u6FC6\u6F92"],
    ["e640", "\u6F8D\u6F89\u6F8C\u6F62\u6F4F\u6F85\u6F5A\u6F96\u6F76\u6F6C\u6F82\u6F55\u6F72\u6F52\u6F50\u6F57\u6F94\u6F93\u6F5D\u6F00\u6F61\u6F6B\u6F7D\u6F67\u6F90\u6F53\u6F8B\u6F69\u6F7F\u6F95\u6F63\u6F77\u6F6A\u6F7B\u71B2\u71AF\u719B\u71B0\u71A0\u719A\u71A9\u71B5\u719D\u71A5\u719E\u71A4\u71A1\u71AA\u719C\u71A7\u71B3\u7298\u729A\u7358\u7352\u735E\u735F\u7360\u735D\u735B\u7361\u735A\u7359"],
    ["e6a1", "\u7362\u7487\u7489\u748A\u7486\u7481\u747D\u7485\u7488\u747C\u7479\u7508\u7507\u757E\u7625\u761E\u7619\u761D\u761C\u7623\u761A\u7628\u761B\u769C\u769D\u769E\u769B\u778D\u778F\u7789\u7788\u78CD\u78BB\u78CF\u78CC\u78D1\u78CE\u78D4\u78C8\u78C3\u78C4\u78C9\u799A\u79A1\u79A0\u799C\u79A2\u799B\u6B76\u7A39\u7AB2\u7AB4\u7AB3\u7BB7\u7BCB\u7BBE\u7BAC\u7BCE\u7BAF\u7BB9\u7BCA\u7BB5\u7CC5\u7CC8\u7CCC\u7CCB\u7DF7\u7DDB\u7DEA\u7DE7\u7DD7\u7DE1\u7E03\u7DFA\u7DE6\u7DF6\u7DF1\u7DF0\u7DEE\u7DDF\u7F76\u7FAC\u7FB0\u7FAD\u7FED\u7FEB\u7FEA\u7FEC\u7FE6\u7FE8\u8064\u8067\u81A3\u819F"],
    ["e740", "\u819E\u8195\u81A2\u8199\u8197\u8216\u824F\u8253\u8252\u8250\u824E\u8251\u8524\u853B\u850F\u8500\u8529\u850E\u8509\u850D\u851F\u850A\u8527\u851C\u84FB\u852B\u84FA\u8508\u850C\u84F4\u852A\u84F2\u8515\u84F7\u84EB\u84F3\u84FC\u8512\u84EA\u84E9\u8516\u84FE\u8528\u851D\u852E\u8502\u84FD\u851E\u84F6\u8531\u8526\u84E7\u84E8\u84F0\u84EF\u84F9\u8518\u8520\u8530\u850B\u8519\u852F\u8662"],
    ["e7a1", "\u8756\u8763\u8764\u8777\u87E1\u8773\u8758\u8754\u875B\u8752\u8761\u875A\u8751\u875E\u876D\u876A\u8750\u874E\u875F\u875D\u876F\u876C\u877A\u876E\u875C\u8765\u874F\u877B\u8775\u8762\u8767\u8769\u885A\u8905\u890C\u8914\u890B\u8917\u8918\u8919\u8906\u8916\u8911\u890E\u8909\u89A2\u89A4\u89A3\u89ED\u89F0\u89EC\u8ACF\u8AC6\u8AB8\u8AD3\u8AD1\u8AD4\u8AD5\u8ABB\u8AD7\u8ABE\u8AC0\u8AC5\u8AD8\u8AC3\u8ABA\u8ABD\u8AD9\u8C3E\u8C4D\u8C8F\u8CE5\u8CDF\u8CD9\u8CE8\u8CDA\u8CDD\u8CE7\u8DA0\u8D9C\u8DA1\u8D9B\u8E20\u8E23\u8E25\u8E24\u8E2E\u8E15\u8E1B\u8E16\u8E11\u8E19\u8E26\u8E27"],
    ["e840", "\u8E14\u8E12\u8E18\u8E13\u8E1C\u8E17\u8E1A\u8F2C\u8F24\u8F18\u8F1A\u8F20\u8F23\u8F16\u8F17\u9073\u9070\u906F\u9067\u906B\u912F\u912B\u9129\u912A\u9132\u9126\u912E\u9185\u9186\u918A\u9181\u9182\u9184\u9180\u92D0\u92C3\u92C4\u92C0\u92D9\u92B6\u92CF\u92F1\u92DF\u92D8\u92E9\u92D7\u92DD\u92CC\u92EF\u92C2\u92E8\u92CA\u92C8\u92CE\u92E6\u92CD\u92D5\u92C9\u92E0\u92DE\u92E7\u92D1\u92D3"],
    ["e8a1", "\u92B5\u92E1\u92C6\u92B4\u957C\u95AC\u95AB\u95AE\u95B0\u96A4\u96A2\u96D3\u9705\u9708\u9702\u975A\u978A\u978E\u9788\u97D0\u97CF\u981E\u981D\u9826\u9829\u9828\u9820\u981B\u9827\u98B2\u9908\u98FA\u9911\u9914\u9916\u9917\u9915\u99DC\u99CD\u99CF\u99D3\u99D4\u99CE\u99C9\u99D6\u99D8\u99CB\u99D7\u99CC\u9AB3\u9AEC\u9AEB\u9AF3\u9AF2\u9AF1\u9B46\u9B43\u9B67\u9B74\u9B71\u9B66\u9B76\u9B75\u9B70\u9B68\u9B64\u9B6C\u9CFC\u9CFA\u9CFD\u9CFF\u9CF7\u9D07\u9D00\u9CF9\u9CFB\u9D08\u9D05\u9D04\u9E83\u9ED3\u9F0F\u9F10\u511C\u5113\u5117\u511A\u5111\u51DE\u5334\u53E1\u5670\u5660\u566E"],
    ["e940", "\u5673\u5666\u5663\u566D\u5672\u565E\u5677\u571C\u571B\u58C8\u58BD\u58C9\u58BF\u58BA\u58C2\u58BC\u58C6\u5B17\u5B19\u5B1B\u5B21\u5B14\u5B13\u5B10\u5B16\u5B28\u5B1A\u5B20\u5B1E\u5BEF\u5DAC\u5DB1\u5DA9\u5DA7\u5DB5\u5DB0\u5DAE\u5DAA\u5DA8\u5DB2\u5DAD\u5DAF\u5DB4\u5E67\u5E68\u5E66\u5E6F\u5EE9\u5EE7\u5EE6\u5EE8\u5EE5\u5F4B\u5FBC\u619D\u61A8\u6196\u61C5\u61B4\u61C6\u61C1\u61CC\u61BA"],
    ["e9a1", "\u61BF\u61B8\u618C\u64D7\u64D6\u64D0\u64CF\u64C9\u64BD\u6489\u64C3\u64DB\u64F3\u64D9\u6533\u657F\u657C\u65A2\u66C8\u66BE\u66C0\u66CA\u66CB\u66CF\u66BD\u66BB\u66BA\u66CC\u6723\u6A34\u6A66\u6A49\u6A67\u6A32\u6A68\u6A3E\u6A5D\u6A6D\u6A76\u6A5B\u6A51\u6A28\u6A5A\u6A3B\u6A3F\u6A41\u6A6A\u6A64\u6A50\u6A4F\u6A54\u6A6F\u6A69\u6A60\u6A3C\u6A5E\u6A56\u6A55\u6A4D\u6A4E\u6A46\u6B55\u6B54\u6B56\u6BA7\u6BAA\u6BAB\u6BC8\u6BC7\u6C04\u6C03\u6C06\u6FAD\u6FCB\u6FA3\u6FC7\u6FBC\u6FCE\u6FC8\u6F5E\u6FC4\u6FBD\u6F9E\u6FCA\u6FA8\u7004\u6FA5\u6FAE\u6FBA\u6FAC\u6FAA\u6FCF\u6FBF\u6FB8"],
    ["ea40", "\u6FA2\u6FC9\u6FAB\u6FCD\u6FAF\u6FB2\u6FB0\u71C5\u71C2\u71BF\u71B8\u71D6\u71C0\u71C1\u71CB\u71D4\u71CA\u71C7\u71CF\u71BD\u71D8\u71BC\u71C6\u71DA\u71DB\u729D\u729E\u7369\u7366\u7367\u736C\u7365\u736B\u736A\u747F\u749A\u74A0\u7494\u7492\u7495\u74A1\u750B\u7580\u762F\u762D\u7631\u763D\u7633\u763C\u7635\u7632\u7630\u76BB\u76E6\u779A\u779D\u77A1\u779C\u779B\u77A2\u77A3\u7795\u7799"],
    ["eaa1", "\u7797\u78DD\u78E9\u78E5\u78EA\u78DE\u78E3\u78DB\u78E1\u78E2\u78ED\u78DF\u78E0\u79A4\u7A44\u7A48\u7A47\u7AB6\u7AB8\u7AB5\u7AB1\u7AB7\u7BDE\u7BE3\u7BE7\u7BDD\u7BD5\u7BE5\u7BDA\u7BE8\u7BF9\u7BD4\u7BEA\u7BE2\u7BDC\u7BEB\u7BD8\u7BDF\u7CD2\u7CD4\u7CD7\u7CD0\u7CD1\u7E12\u7E21\u7E17\u7E0C\u7E1F\u7E20\u7E13\u7E0E\u7E1C\u7E15\u7E1A\u7E22\u7E0B\u7E0F\u7E16\u7E0D\u7E14\u7E25\u7E24\u7F43\u7F7B\u7F7C\u7F7A\u7FB1\u7FEF\u802A\u8029\u806C\u81B1\u81A6\u81AE\u81B9\u81B5\u81AB\u81B0\u81AC\u81B4\u81B2\u81B7\u81A7\u81F2\u8255\u8256\u8257\u8556\u8545\u856B\u854D\u8553\u8561\u8558"],
    ["eb40", "\u8540\u8546\u8564\u8541\u8562\u8544\u8551\u8547\u8563\u853E\u855B\u8571\u854E\u856E\u8575\u8555\u8567\u8560\u858C\u8566\u855D\u8554\u8565\u856C\u8663\u8665\u8664\u879B\u878F\u8797\u8793\u8792\u8788\u8781\u8796\u8798\u8779\u8787\u87A3\u8785\u8790\u8791\u879D\u8784\u8794\u879C\u879A\u8789\u891E\u8926\u8930\u892D\u892E\u8927\u8931\u8922\u8929\u8923\u892F\u892C\u891F\u89F1\u8AE0"],
    ["eba1", "\u8AE2\u8AF2\u8AF4\u8AF5\u8ADD\u8B14\u8AE4\u8ADF\u8AF0\u8AC8\u8ADE\u8AE1\u8AE8\u8AFF\u8AEF\u8AFB\u8C91\u8C92\u8C90\u8CF5\u8CEE\u8CF1\u8CF0\u8CF3\u8D6C\u8D6E\u8DA5\u8DA7\u8E33\u8E3E\u8E38\u8E40\u8E45\u8E36\u8E3C\u8E3D\u8E41\u8E30\u8E3F\u8EBD\u8F36\u8F2E\u8F35\u8F32\u8F39\u8F37\u8F34\u9076\u9079\u907B\u9086\u90FA\u9133\u9135\u9136\u9193\u9190\u9191\u918D\u918F\u9327\u931E\u9308\u931F\u9306\u930F\u937A\u9338\u933C\u931B\u9323\u9312\u9301\u9346\u932D\u930E\u930D\u92CB\u931D\u92FA\u9325\u9313\u92F9\u92F7\u9334\u9302\u9324\u92FF\u9329\u9339\u9335\u932A\u9314\u930C"],
    ["ec40", "\u930B\u92FE\u9309\u9300\u92FB\u9316\u95BC\u95CD\u95BE\u95B9\u95BA\u95B6\u95BF\u95B5\u95BD\u96A9\u96D4\u970B\u9712\u9710\u9799\u9797\u9794\u97F0\u97F8\u9835\u982F\u9832\u9924\u991F\u9927\u9929\u999E\u99EE\u99EC\u99E5\u99E4\u99F0\u99E3\u99EA\u99E9\u99E7\u9AB9\u9ABF\u9AB4\u9ABB\u9AF6\u9AFA\u9AF9\u9AF7\u9B33\u9B80\u9B85\u9B87\u9B7C\u9B7E\u9B7B\u9B82\u9B93\u9B92\u9B90\u9B7A\u9B95"],
    ["eca1", "\u9B7D\u9B88\u9D25\u9D17\u9D20\u9D1E\u9D14\u9D29\u9D1D\u9D18\u9D22\u9D10\u9D19\u9D1F\u9E88\u9E86\u9E87\u9EAE\u9EAD\u9ED5\u9ED6\u9EFA\u9F12\u9F3D\u5126\u5125\u5122\u5124\u5120\u5129\u52F4\u5693\u568C\u568D\u5686\u5684\u5683\u567E\u5682\u567F\u5681\u58D6\u58D4\u58CF\u58D2\u5B2D\u5B25\u5B32\u5B23\u5B2C\u5B27\u5B26\u5B2F\u5B2E\u5B7B\u5BF1\u5BF2\u5DB7\u5E6C\u5E6A\u5FBE\u5FBB\u61C3\u61B5\u61BC\u61E7\u61E0\u61E5\u61E4\u61E8\u61DE\u64EF\u64E9\u64E3\u64EB\u64E4\u64E8\u6581\u6580\u65B6\u65DA\u66D2\u6A8D\u6A96\u6A81\u6AA5\u6A89\u6A9F\u6A9B\u6AA1\u6A9E\u6A87\u6A93\u6A8E"],
    ["ed40", "\u6A95\u6A83\u6AA8\u6AA4\u6A91\u6A7F\u6AA6\u6A9A\u6A85\u6A8C\u6A92\u6B5B\u6BAD\u6C09\u6FCC\u6FA9\u6FF4\u6FD4\u6FE3\u6FDC\u6FED\u6FE7\u6FE6\u6FDE\u6FF2\u6FDD\u6FE2\u6FE8\u71E1\u71F1\u71E8\u71F2\u71E4\u71F0\u71E2\u7373\u736E\u736F\u7497\u74B2\u74AB\u7490\u74AA\u74AD\u74B1\u74A5\u74AF\u7510\u7511\u7512\u750F\u7584\u7643\u7648\u7649\u7647\u76A4\u76E9\u77B5\u77AB\u77B2\u77B7\u77B6"],
    ["eda1", "\u77B4\u77B1\u77A8\u77F0\u78F3\u78FD\u7902\u78FB\u78FC\u78F2\u7905\u78F9\u78FE\u7904\u79AB\u79A8\u7A5C\u7A5B\u7A56\u7A58\u7A54\u7A5A\u7ABE\u7AC0\u7AC1\u7C05\u7C0F\u7BF2\u7C00\u7BFF\u7BFB\u7C0E\u7BF4\u7C0B\u7BF3\u7C02\u7C09\u7C03\u7C01\u7BF8\u7BFD\u7C06\u7BF0\u7BF1\u7C10\u7C0A\u7CE8\u7E2D\u7E3C\u7E42\u7E33\u9848\u7E38\u7E2A\u7E49\u7E40\u7E47\u7E29\u7E4C\u7E30\u7E3B\u7E36\u7E44\u7E3A\u7F45\u7F7F\u7F7E\u7F7D\u7FF4\u7FF2\u802C\u81BB\u81C4\u81CC\u81CA\u81C5\u81C7\u81BC\u81E9\u825B\u825A\u825C\u8583\u8580\u858F\u85A7\u8595\u85A0\u858B\u85A3\u857B\u85A4\u859A\u859E"],
    ["ee40", "\u8577\u857C\u8589\u85A1\u857A\u8578\u8557\u858E\u8596\u8586\u858D\u8599\u859D\u8581\u85A2\u8582\u8588\u8585\u8579\u8576\u8598\u8590\u859F\u8668\u87BE\u87AA\u87AD\u87C5\u87B0\u87AC\u87B9\u87B5\u87BC\u87AE\u87C9\u87C3\u87C2\u87CC\u87B7\u87AF\u87C4\u87CA\u87B4\u87B6\u87BF\u87B8\u87BD\u87DE\u87B2\u8935\u8933\u893C\u893E\u8941\u8952\u8937\u8942\u89AD\u89AF\u89AE\u89F2\u89F3\u8B1E"],
    ["eea1", "\u8B18\u8B16\u8B11\u8B05\u8B0B\u8B22\u8B0F\u8B12\u8B15\u8B07\u8B0D\u8B08\u8B06\u8B1C\u8B13\u8B1A\u8C4F\u8C70\u8C72\u8C71\u8C6F\u8C95\u8C94\u8CF9\u8D6F\u8E4E\u8E4D\u8E53\u8E50\u8E4C\u8E47\u8F43\u8F40\u9085\u907E\u9138\u919A\u91A2\u919B\u9199\u919F\u91A1\u919D\u91A0\u93A1\u9383\u93AF\u9364\u9356\u9347\u937C\u9358\u935C\u9376\u9349\u9350\u9351\u9360\u936D\u938F\u934C\u936A\u9379\u9357\u9355\u9352\u934F\u9371\u9377\u937B\u9361\u935E\u9363\u9367\u9380\u934E\u9359\u95C7\u95C0\u95C9\u95C3\u95C5\u95B7\u96AE\u96B0\u96AC\u9720\u971F\u9718\u971D\u9719\u979A\u97A1\u979C"],
    ["ef40", "\u979E\u979D\u97D5\u97D4\u97F1\u9841\u9844\u984A\u9849\u9845\u9843\u9925\u992B\u992C\u992A\u9933\u9932\u992F\u992D\u9931\u9930\u9998\u99A3\u99A1\u9A02\u99FA\u99F4\u99F7\u99F9\u99F8\u99F6\u99FB\u99FD\u99FE\u99FC\u9A03\u9ABE\u9AFE\u9AFD\u9B01\u9AFC\u9B48\u9B9A\u9BA8\u9B9E\u9B9B\u9BA6\u9BA1\u9BA5\u9BA4\u9B86\u9BA2\u9BA0\u9BAF\u9D33\u9D41\u9D67\u9D36\u9D2E\u9D2F\u9D31\u9D38\u9D30"],
    ["efa1", "\u9D45\u9D42\u9D43\u9D3E\u9D37\u9D40\u9D3D\u7FF5\u9D2D\u9E8A\u9E89\u9E8D\u9EB0\u9EC8\u9EDA\u9EFB\u9EFF\u9F24\u9F23\u9F22\u9F54\u9FA0\u5131\u512D\u512E\u5698\u569C\u5697\u569A\u569D\u5699\u5970\u5B3C\u5C69\u5C6A\u5DC0\u5E6D\u5E6E\u61D8\u61DF\u61ED\u61EE\u61F1\u61EA\u61F0\u61EB\u61D6\u61E9\u64FF\u6504\u64FD\u64F8\u6501\u6503\u64FC\u6594\u65DB\u66DA\u66DB\u66D8\u6AC5\u6AB9\u6ABD\u6AE1\u6AC6\u6ABA\u6AB6\u6AB7\u6AC7\u6AB4\u6AAD\u6B5E\u6BC9\u6C0B\u7007\u700C\u700D\u7001\u7005\u7014\u700E\u6FFF\u7000\u6FFB\u7026\u6FFC\u6FF7\u700A\u7201\u71FF\u71F9\u7203\u71FD\u7376"],
    ["f040", "\u74B8\u74C0\u74B5\u74C1\u74BE\u74B6\u74BB\u74C2\u7514\u7513\u765C\u7664\u7659\u7650\u7653\u7657\u765A\u76A6\u76BD\u76EC\u77C2\u77BA\u78FF\u790C\u7913\u7914\u7909\u7910\u7912\u7911\u79AD\u79AC\u7A5F\u7C1C\u7C29\u7C19\u7C20\u7C1F\u7C2D\u7C1D\u7C26\u7C28\u7C22\u7C25\u7C30\u7E5C\u7E50\u7E56\u7E63\u7E58\u7E62\u7E5F\u7E51\u7E60\u7E57\u7E53\u7FB5\u7FB3\u7FF7\u7FF8\u8075\u81D1\u81D2"],
    ["f0a1", "\u81D0\u825F\u825E\u85B4\u85C6\u85C0\u85C3\u85C2\u85B3\u85B5\u85BD\u85C7\u85C4\u85BF\u85CB\u85CE\u85C8\u85C5\u85B1\u85B6\u85D2\u8624\u85B8\u85B7\u85BE\u8669\u87E7\u87E6\u87E2\u87DB\u87EB\u87EA\u87E5\u87DF\u87F3\u87E4\u87D4\u87DC\u87D3\u87ED\u87D8\u87E3\u87A4\u87D7\u87D9\u8801\u87F4\u87E8\u87DD\u8953\u894B\u894F\u894C\u8946\u8950\u8951\u8949\u8B2A\u8B27\u8B23\u8B33\u8B30\u8B35\u8B47\u8B2F\u8B3C\u8B3E\u8B31\u8B25\u8B37\u8B26\u8B36\u8B2E\u8B24\u8B3B\u8B3D\u8B3A\u8C42\u8C75\u8C99\u8C98\u8C97\u8CFE\u8D04\u8D02\u8D00\u8E5C\u8E62\u8E60\u8E57\u8E56\u8E5E\u8E65\u8E67"],
    ["f140", "\u8E5B\u8E5A\u8E61\u8E5D\u8E69\u8E54\u8F46\u8F47\u8F48\u8F4B\u9128\u913A\u913B\u913E\u91A8\u91A5\u91A7\u91AF\u91AA\u93B5\u938C\u9392\u93B7\u939B\u939D\u9389\u93A7\u938E\u93AA\u939E\u93A6\u9395\u9388\u9399\u939F\u938D\u93B1\u9391\u93B2\u93A4\u93A8\u93B4\u93A3\u93A5\u95D2\u95D3\u95D1\u96B3\u96D7\u96DA\u5DC2\u96DF\u96D8\u96DD\u9723\u9722\u9725\u97AC\u97AE\u97A8\u97AB\u97A4\u97AA"],
    ["f1a1", "\u97A2\u97A5\u97D7\u97D9\u97D6\u97D8\u97FA\u9850\u9851\u9852\u98B8\u9941\u993C\u993A\u9A0F\u9A0B\u9A09\u9A0D\u9A04\u9A11\u9A0A\u9A05\u9A07\u9A06\u9AC0\u9ADC\u9B08\u9B04\u9B05\u9B29\u9B35\u9B4A\u9B4C\u9B4B\u9BC7\u9BC6\u9BC3\u9BBF\u9BC1\u9BB5\u9BB8\u9BD3\u9BB6\u9BC4\u9BB9\u9BBD\u9D5C\u9D53\u9D4F\u9D4A\u9D5B\u9D4B\u9D59\u9D56\u9D4C\u9D57\u9D52\u9D54\u9D5F\u9D58\u9D5A\u9E8E\u9E8C\u9EDF\u9F01\u9F00\u9F16\u9F25\u9F2B\u9F2A\u9F29\u9F28\u9F4C\u9F55\u5134\u5135\u5296\u52F7\u53B4\u56AB\u56AD\u56A6\u56A7\u56AA\u56AC\u58DA\u58DD\u58DB\u5912\u5B3D\u5B3E\u5B3F\u5DC3\u5E70"],
    ["f240", "\u5FBF\u61FB\u6507\u6510\u650D\u6509\u650C\u650E\u6584\u65DE\u65DD\u66DE\u6AE7\u6AE0\u6ACC\u6AD1\u6AD9\u6ACB\u6ADF\u6ADC\u6AD0\u6AEB\u6ACF\u6ACD\u6ADE\u6B60\u6BB0\u6C0C\u7019\u7027\u7020\u7016\u702B\u7021\u7022\u7023\u7029\u7017\u7024\u701C\u702A\u720C\u720A\u7207\u7202\u7205\u72A5\u72A6\u72A4\u72A3\u72A1\u74CB\u74C5\u74B7\u74C3\u7516\u7660\u77C9\u77CA\u77C4\u77F1\u791D\u791B"],
    ["f2a1", "\u7921\u791C\u7917\u791E\u79B0\u7A67\u7A68\u7C33\u7C3C\u7C39\u7C2C\u7C3B\u7CEC\u7CEA\u7E76\u7E75\u7E78\u7E70\u7E77\u7E6F\u7E7A\u7E72\u7E74\u7E68\u7F4B\u7F4A\u7F83\u7F86\u7FB7\u7FFD\u7FFE\u8078\u81D7\u81D5\u8264\u8261\u8263\u85EB\u85F1\u85ED\u85D9\u85E1\u85E8\u85DA\u85D7\u85EC\u85F2\u85F8\u85D8\u85DF\u85E3\u85DC\u85D1\u85F0\u85E6\u85EF\u85DE\u85E2\u8800\u87FA\u8803\u87F6\u87F7\u8809\u880C\u880B\u8806\u87FC\u8808\u87FF\u880A\u8802\u8962\u895A\u895B\u8957\u8961\u895C\u8958\u895D\u8959\u8988\u89B7\u89B6\u89F6\u8B50\u8B48\u8B4A\u8B40\u8B53\u8B56\u8B54\u8B4B\u8B55"],
    ["f340", "\u8B51\u8B42\u8B52\u8B57\u8C43\u8C77\u8C76\u8C9A\u8D06\u8D07\u8D09\u8DAC\u8DAA\u8DAD\u8DAB\u8E6D\u8E78\u8E73\u8E6A\u8E6F\u8E7B\u8EC2\u8F52\u8F51\u8F4F\u8F50\u8F53\u8FB4\u9140\u913F\u91B0\u91AD\u93DE\u93C7\u93CF\u93C2\u93DA\u93D0\u93F9\u93EC\u93CC\u93D9\u93A9\u93E6\u93CA\u93D4\u93EE\u93E3\u93D5\u93C4\u93CE\u93C0\u93D2\u93E7\u957D\u95DA\u95DB\u96E1\u9729\u972B\u972C\u9728\u9726"],
    ["f3a1", "\u97B3\u97B7\u97B6\u97DD\u97DE\u97DF\u985C\u9859\u985D\u9857\u98BF\u98BD\u98BB\u98BE\u9948\u9947\u9943\u99A6\u99A7\u9A1A\u9A15\u9A25\u9A1D\u9A24\u9A1B\u9A22\u9A20\u9A27\u9A23\u9A1E\u9A1C\u9A14\u9AC2\u9B0B\u9B0A\u9B0E\u9B0C\u9B37\u9BEA\u9BEB\u9BE0\u9BDE\u9BE4\u9BE6\u9BE2\u9BF0\u9BD4\u9BD7\u9BEC\u9BDC\u9BD9\u9BE5\u9BD5\u9BE1\u9BDA\u9D77\u9D81\u9D8A\u9D84\u9D88\u9D71\u9D80\u9D78\u9D86\u9D8B\u9D8C\u9D7D\u9D6B\u9D74\u9D75\u9D70\u9D69\u9D85\u9D73\u9D7B\u9D82\u9D6F\u9D79\u9D7F\u9D87\u9D68\u9E94\u9E91\u9EC0\u9EFC\u9F2D\u9F40\u9F41\u9F4D\u9F56\u9F57\u9F58\u5337\u56B2"],
    ["f440", "\u56B5\u56B3\u58E3\u5B45\u5DC6\u5DC7\u5EEE\u5EEF\u5FC0\u5FC1\u61F9\u6517\u6516\u6515\u6513\u65DF\u66E8\u66E3\u66E4\u6AF3\u6AF0\u6AEA\u6AE8\u6AF9\u6AF1\u6AEE\u6AEF\u703C\u7035\u702F\u7037\u7034\u7031\u7042\u7038\u703F\u703A\u7039\u7040\u703B\u7033\u7041\u7213\u7214\u72A8\u737D\u737C\u74BA\u76AB\u76AA\u76BE\u76ED\u77CC\u77CE\u77CF\u77CD\u77F2\u7925\u7923\u7927\u7928\u7924\u7929"],
    ["f4a1", "\u79B2\u7A6E\u7A6C\u7A6D\u7AF7\u7C49\u7C48\u7C4A\u7C47\u7C45\u7CEE\u7E7B\u7E7E\u7E81\u7E80\u7FBA\u7FFF\u8079\u81DB\u81D9\u820B\u8268\u8269\u8622\u85FF\u8601\u85FE\u861B\u8600\u85F6\u8604\u8609\u8605\u860C\u85FD\u8819\u8810\u8811\u8817\u8813\u8816\u8963\u8966\u89B9\u89F7\u8B60\u8B6A\u8B5D\u8B68\u8B63\u8B65\u8B67\u8B6D\u8DAE\u8E86\u8E88\u8E84\u8F59\u8F56\u8F57\u8F55\u8F58\u8F5A\u908D\u9143\u9141\u91B7\u91B5\u91B2\u91B3\u940B\u9413\u93FB\u9420\u940F\u9414\u93FE\u9415\u9410\u9428\u9419\u940D\u93F5\u9400\u93F7\u9407\u940E\u9416\u9412\u93FA\u9409\u93F8\u940A\u93FF"],
    ["f540", "\u93FC\u940C\u93F6\u9411\u9406\u95DE\u95E0\u95DF\u972E\u972F\u97B9\u97BB\u97FD\u97FE\u9860\u9862\u9863\u985F\u98C1\u98C2\u9950\u994E\u9959\u994C\u994B\u9953\u9A32\u9A34\u9A31\u9A2C\u9A2A\u9A36\u9A29\u9A2E\u9A38\u9A2D\u9AC7\u9ACA\u9AC6\u9B10\u9B12\u9B11\u9C0B\u9C08\u9BF7\u9C05\u9C12\u9BF8\u9C40\u9C07\u9C0E\u9C06\u9C17\u9C14\u9C09\u9D9F\u9D99\u9DA4\u9D9D\u9D92\u9D98\u9D90\u9D9B"],
    ["f5a1", "\u9DA0\u9D94\u9D9C\u9DAA\u9D97\u9DA1\u9D9A\u9DA2\u9DA8\u9D9E\u9DA3\u9DBF\u9DA9\u9D96\u9DA6\u9DA7\u9E99\u9E9B\u9E9A\u9EE5\u9EE4\u9EE7\u9EE6\u9F30\u9F2E\u9F5B\u9F60\u9F5E\u9F5D\u9F59\u9F91\u513A\u5139\u5298\u5297\u56C3\u56BD\u56BE\u5B48\u5B47\u5DCB\u5DCF\u5EF1\u61FD\u651B\u6B02\u6AFC\u6B03\u6AF8\u6B00\u7043\u7044\u704A\u7048\u7049\u7045\u7046\u721D\u721A\u7219\u737E\u7517\u766A\u77D0\u792D\u7931\u792F\u7C54\u7C53\u7CF2\u7E8A\u7E87\u7E88\u7E8B\u7E86\u7E8D\u7F4D\u7FBB\u8030\u81DD\u8618\u862A\u8626\u861F\u8623\u861C\u8619\u8627\u862E\u8621\u8620\u8629\u861E\u8625"],
    ["f640", "\u8829\u881D\u881B\u8820\u8824\u881C\u882B\u884A\u896D\u8969\u896E\u896B\u89FA\u8B79\u8B78\u8B45\u8B7A\u8B7B\u8D10\u8D14\u8DAF\u8E8E\u8E8C\u8F5E\u8F5B\u8F5D\u9146\u9144\u9145\u91B9\u943F\u943B\u9436\u9429\u943D\u943C\u9430\u9439\u942A\u9437\u942C\u9440\u9431\u95E5\u95E4\u95E3\u9735\u973A\u97BF\u97E1\u9864\u98C9\u98C6\u98C0\u9958\u9956\u9A39\u9A3D\u9A46\u9A44\u9A42\u9A41\u9A3A"],
    ["f6a1", "\u9A3F\u9ACD\u9B15\u9B17\u9B18\u9B16\u9B3A\u9B52\u9C2B\u9C1D\u9C1C\u9C2C\u9C23\u9C28\u9C29\u9C24\u9C21\u9DB7\u9DB6\u9DBC\u9DC1\u9DC7\u9DCA\u9DCF\u9DBE\u9DC5\u9DC3\u9DBB\u9DB5\u9DCE\u9DB9\u9DBA\u9DAC\u9DC8\u9DB1\u9DAD\u9DCC\u9DB3\u9DCD\u9DB2\u9E7A\u9E9C\u9EEB\u9EEE\u9EED\u9F1B\u9F18\u9F1A\u9F31\u9F4E\u9F65\u9F64\u9F92\u4EB9\u56C6\u56C5\u56CB\u5971\u5B4B\u5B4C\u5DD5\u5DD1\u5EF2\u6521\u6520\u6526\u6522\u6B0B\u6B08\u6B09\u6C0D\u7055\u7056\u7057\u7052\u721E\u721F\u72A9\u737F\u74D8\u74D5\u74D9\u74D7\u766D\u76AD\u7935\u79B4\u7A70\u7A71\u7C57\u7C5C\u7C59\u7C5B\u7C5A"],
    ["f740", "\u7CF4\u7CF1\u7E91\u7F4F\u7F87\u81DE\u826B\u8634\u8635\u8633\u862C\u8632\u8636\u882C\u8828\u8826\u882A\u8825\u8971\u89BF\u89BE\u89FB\u8B7E\u8B84\u8B82\u8B86\u8B85\u8B7F\u8D15\u8E95\u8E94\u8E9A\u8E92\u8E90\u8E96\u8E97\u8F60\u8F62\u9147\u944C\u9450\u944A\u944B\u944F\u9447\u9445\u9448\u9449\u9446\u973F\u97E3\u986A\u9869\u98CB\u9954\u995B\u9A4E\u9A53\u9A54\u9A4C\u9A4F\u9A48\u9A4A"],
    ["f7a1", "\u9A49\u9A52\u9A50\u9AD0\u9B19\u9B2B\u9B3B\u9B56\u9B55\u9C46\u9C48\u9C3F\u9C44\u9C39\u9C33\u9C41\u9C3C\u9C37\u9C34\u9C32\u9C3D\u9C36\u9DDB\u9DD2\u9DDE\u9DDA\u9DCB\u9DD0\u9DDC\u9DD1\u9DDF\u9DE9\u9DD9\u9DD8\u9DD6\u9DF5\u9DD5\u9DDD\u9EB6\u9EF0\u9F35\u9F33\u9F32\u9F42\u9F6B\u9F95\u9FA2\u513D\u5299\u58E8\u58E7\u5972\u5B4D\u5DD8\u882F\u5F4F\u6201\u6203\u6204\u6529\u6525\u6596\u66EB\u6B11\u6B12\u6B0F\u6BCA\u705B\u705A\u7222\u7382\u7381\u7383\u7670\u77D4\u7C67\u7C66\u7E95\u826C\u863A\u8640\u8639\u863C\u8631\u863B\u863E\u8830\u8832\u882E\u8833\u8976\u8974\u8973\u89FE"],
    ["f840", "\u8B8C\u8B8E\u8B8B\u8B88\u8C45\u8D19\u8E98\u8F64\u8F63\u91BC\u9462\u9455\u945D\u9457\u945E\u97C4\u97C5\u9800\u9A56\u9A59\u9B1E\u9B1F\u9B20\u9C52\u9C58\u9C50\u9C4A\u9C4D\u9C4B\u9C55\u9C59\u9C4C\u9C4E\u9DFB\u9DF7\u9DEF\u9DE3\u9DEB\u9DF8\u9DE4\u9DF6\u9DE1\u9DEE\u9DE6\u9DF2\u9DF0\u9DE2\u9DEC\u9DF4\u9DF3\u9DE8\u9DED\u9EC2\u9ED0\u9EF2\u9EF3\u9F06\u9F1C\u9F38\u9F37\u9F36\u9F43\u9F4F"],
    ["f8a1", "\u9F71\u9F70\u9F6E\u9F6F\u56D3\u56CD\u5B4E\u5C6D\u652D\u66ED\u66EE\u6B13\u705F\u7061\u705D\u7060\u7223\u74DB\u74E5\u77D5\u7938\u79B7\u79B6\u7C6A\u7E97\u7F89\u826D\u8643\u8838\u8837\u8835\u884B\u8B94\u8B95\u8E9E\u8E9F\u8EA0\u8E9D\u91BE\u91BD\u91C2\u946B\u9468\u9469\u96E5\u9746\u9743\u9747\u97C7\u97E5\u9A5E\u9AD5\u9B59\u9C63\u9C67\u9C66\u9C62\u9C5E\u9C60\u9E02\u9DFE\u9E07\u9E03\u9E06\u9E05\u9E00\u9E01\u9E09\u9DFF\u9DFD\u9E04\u9EA0\u9F1E\u9F46\u9F74\u9F75\u9F76\u56D4\u652E\u65B8\u6B18\u6B19\u6B17\u6B1A\u7062\u7226\u72AA\u77D8\u77D9\u7939\u7C69\u7C6B\u7CF6\u7E9A"],
    ["f940", "\u7E98\u7E9B\u7E99\u81E0\u81E1\u8646\u8647\u8648\u8979\u897A\u897C\u897B\u89FF\u8B98\u8B99\u8EA5\u8EA4\u8EA3\u946E\u946D\u946F\u9471\u9473\u9749\u9872\u995F\u9C68\u9C6E\u9C6D\u9E0B\u9E0D\u9E10\u9E0F\u9E12\u9E11\u9EA1\u9EF5\u9F09\u9F47\u9F78\u9F7B\u9F7A\u9F79\u571E\u7066\u7C6F\u883C\u8DB2\u8EA6\u91C3\u9474\u9478\u9476\u9475\u9A60\u9C74\u9C73\u9C71\u9C75\u9E14\u9E13\u9EF6\u9F0A"],
    ["f9a1", "\u9FA4\u7068\u7065\u7CF7\u866A\u883E\u883D\u883F\u8B9E\u8C9C\u8EA9\u8EC9\u974B\u9873\u9874\u98CC\u9961\u99AB\u9A64\u9A66\u9A67\u9B24\u9E15\u9E17\u9F48\u6207\u6B1E\u7227\u864C\u8EA8\u9482\u9480\u9481\u9A69\u9A68\u9B2E\u9E19\u7229\u864B\u8B9F\u9483\u9C79\u9EB7\u7675\u9A6B\u9C7A\u9E1D\u7069\u706A\u9EA4\u9F7E\u9F49\u9F98\u7881\u92B9\u88CF\u58BB\u6052\u7CA7\u5AFA\u2554\u2566\u2557\u2560\u256C\u2563\u255A\u2569\u255D\u2552\u2564\u2555\u255E\u256A\u2561\u2558\u2567\u255B\u2553\u2565\u2556\u255F\u256B\u2562\u2559\u2568\u255C\u2551\u2550\u256D\u256E\u2570\u256F\u2593"]
  ];
});

// ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/big5-added.json
var require_big5_added = __commonJS((exports2, module2) => {
  module2.exports = [
    ["8740", "\u43F0\u4C32\u4603\u45A6\u4578\u{27267}\u4D77\u45B3\u{27CB1}\u4CE2\u{27CC5}\u3B95\u4736\u4744\u4C47\u4C40\u{242BF}\u{23617}\u{27352}\u{26E8B}\u{270D2}\u4C57\u{2A351}\u474F\u45DA\u4C85\u{27C6C}\u4D07\u4AA4\u46A1\u{26B23}\u7225\u{25A54}\u{21A63}\u{23E06}\u{23F61}\u664D\u56FB"],
    ["8767", "\u7D95\u591D\u{28BB9}\u3DF4\u9734\u{27BEF}\u5BDB\u{21D5E}\u5AA4\u3625\u{29EB0}\u5AD1\u5BB7\u5CFC\u676E\u8593\u{29945}\u7461\u749D\u3875\u{21D53}\u{2369E}\u{26021}\u3EEC"],
    ["87a1", "\u{258DE}\u3AF5\u7AFC\u9F97\u{24161}\u{2890D}\u{231EA}\u{20A8A}\u{2325E}\u430A\u8484\u9F96\u942F\u4930\u8613\u5896\u974A\u9218\u79D0\u7A32\u6660\u6A29\u889D\u744C\u7BC5\u6782\u7A2C\u524F\u9046\u34E6\u73C4\u{25DB9}\u74C6\u9FC7\u57B3\u492F\u544C\u4131\u{2368E}\u5818\u7A72\u{27B65}\u8B8F\u46AE\u{26E88}\u4181\u{25D99}\u7BAE\u{224BC}\u9FC8\u{224C1}\u{224C9}\u{224CC}\u9FC9\u8504\u{235BB}\u40B4\u9FCA\u44E1\u{2ADFF}\u62C1\u706E\u9FCB"],
    ["8840", "\u31C0", 4, "\u{2010C}\u31C5\u{200D1}\u{200CD}\u31C6\u31C7\u{200CB}\u{21FE8}\u31C8\u{200CA}\u31C9\u31CA\u31CB\u31CC\u{2010E}\u31CD\u31CE\u0100\xC1\u01CD\xC0\u0112\xC9\u011A\xC8\u014C\xD3\u01D1\xD2\u0FFF\xCA\u0304\u1EBE\u0FFF\xCA\u030C\u1EC0\xCA\u0101\xE1\u01CE\xE0\u0251\u0113\xE9\u011B\xE8\u012B\xED\u01D0\xEC\u014D\xF3\u01D2\xF2\u016B\xFA\u01D4\xF9\u01D6\u01D8\u01DA"],
    ["88a1", "\u01DC\xFC\u0FFF\xEA\u0304\u1EBF\u0FFF\xEA\u030C\u1EC1\xEA\u0261\u23DA\u23DB"],
    ["8940", "\u{2A3A9}\u{21145}"],
    ["8943", "\u650A"],
    ["8946", "\u4E3D\u6EDD\u9D4E\u91DF"],
    ["894c", "\u{27735}\u6491\u4F1A\u4F28\u4FA8\u5156\u5174\u519C\u51E4\u52A1\u52A8\u533B\u534E\u53D1\u53D8\u56E2\u58F0\u5904\u5907\u5932\u5934\u5B66\u5B9E\u5B9F\u5C9A\u5E86\u603B\u6589\u67FE\u6804\u6865\u6D4E\u70BC\u7535\u7EA4\u7EAC\u7EBA\u7EC7\u7ECF\u7EDF\u7F06\u7F37\u827A\u82CF\u836F\u89C6\u8BBE\u8BE2\u8F66\u8F67\u8F6E"],
    ["89a1", "\u7411\u7CFC\u7DCD\u6946\u7AC9\u5227"],
    ["89ab", "\u918C\u78B8\u915E\u80BC"],
    ["89b0", "\u8D0B\u80F6\u{209E7}"],
    ["89b5", "\u809F\u9EC7\u4CCD\u9DC9\u9E0C\u4C3E\u{29DF6}\u{2700E}\u9E0A\u{2A133}\u35C1"],
    ["89c1", "\u6E9A\u823E\u7519"],
    ["89c5", "\u4911\u9A6C\u9A8F\u9F99\u7987\u{2846C}\u{21DCA}\u{205D0}\u{22AE6}\u4E24\u4E81\u4E80\u4E87\u4EBF\u4EEB\u4F37\u344C\u4FBD\u3E48\u5003\u5088\u347D\u3493\u34A5\u5186\u5905\u51DB\u51FC\u5205\u4E89\u5279\u5290\u5327\u35C7\u53A9\u3551\u53B0\u3553\u53C2\u5423\u356D\u3572\u3681\u5493\u54A3\u54B4\u54B9\u54D0\u54EF\u5518\u5523\u5528\u3598\u553F\u35A5\u35BF\u55D7\u35C5"],
    ["8a40", "\u{27D84}\u5525"],
    ["8a43", "\u{20C42}\u{20D15}\u{2512B}\u5590\u{22CC6}\u39EC\u{20341}\u8E46\u{24DB8}\u{294E5}\u4053\u{280BE}\u777A\u{22C38}\u3A34\u47D5\u{2815D}\u{269F2}\u{24DEA}\u64DD\u{20D7C}\u{20FB4}\u{20CD5}\u{210F4}\u648D\u8E7E\u{20E96}\u{20C0B}\u{20F64}\u{22CA9}\u{28256}\u{244D3}"],
    ["8a64", "\u{20D46}\u{29A4D}\u{280E9}\u47F4\u{24EA7}\u{22CC2}\u9AB2\u3A67\u{295F4}\u3FED\u3506\u{252C7}\u{297D4}\u{278C8}\u{22D44}\u9D6E\u9815"],
    ["8a76", "\u43D9\u{260A5}\u64B4\u54E3\u{22D4C}\u{22BCA}\u{21077}\u39FB\u{2106F}"],
    ["8aa1", "\u{266DA}\u{26716}\u{279A0}\u64EA\u{25052}\u{20C43}\u8E68\u{221A1}\u{28B4C}\u{20731}"],
    ["8aac", "\u480B\u{201A9}\u3FFA\u5873\u{22D8D}"],
    ["8ab2", "\u{245C8}\u{204FC}\u{26097}\u{20F4C}\u{20D96}\u5579\u40BB\u43BA"],
    ["8abb", "\u4AB4\u{22A66}\u{2109D}\u81AA\u98F5\u{20D9C}\u6379\u39FE\u{22775}\u8DC0\u56A1\u647C\u3E43"],
    ["8ac9", "\u{2A601}\u{20E09}\u{22ACF}\u{22CC9}"],
    ["8ace", "\u{210C8}\u{239C2}\u3992\u3A06\u{2829B}\u3578\u{25E49}\u{220C7}\u5652\u{20F31}\u{22CB2}\u{29720}\u34BC\u6C3D\u{24E3B}"],
    ["8adf", "\u{27574}\u{22E8B}\u{22208}\u{2A65B}\u{28CCD}\u{20E7A}\u{20C34}\u{2681C}\u7F93\u{210CF}\u{22803}\u{22939}\u35FB\u{251E3}\u{20E8C}\u{20F8D}\u{20EAA}\u3F93\u{20F30}\u{20D47}\u{2114F}\u{20E4C}"],
    ["8af6", "\u{20EAB}\u{20BA9}\u{20D48}\u{210C0}\u{2113D}\u3FF9\u{22696}\u6432\u{20FAD}"],
    ["8b40", "\u{233F4}\u{27639}\u{22BCE}\u{20D7E}\u{20D7F}\u{22C51}\u{22C55}\u3A18\u{20E98}\u{210C7}\u{20F2E}\u{2A632}\u{26B50}\u{28CD2}\u{28D99}\u{28CCA}\u95AA\u54CC\u82C4\u55B9"],
    ["8b55", "\u{29EC3}\u9C26\u9AB6\u{2775E}\u{22DEE}\u7140\u816D\u80EC\u5C1C\u{26572}\u8134\u3797\u535F\u{280BD}\u91B6\u{20EFA}\u{20E0F}\u{20E77}\u{20EFB}\u35DD\u{24DEB}\u3609\u{20CD6}\u56AF\u{227B5}\u{210C9}\u{20E10}\u{20E78}\u{21078}\u{21148}\u{28207}\u{21455}\u{20E79}\u{24E50}\u{22DA4}\u5A54\u{2101D}\u{2101E}\u{210F5}\u{210F6}\u579C\u{20E11}"],
    ["8ba1", "\u{27694}\u{282CD}\u{20FB5}\u{20E7B}\u{2517E}\u3703\u{20FB6}\u{21180}\u{252D8}\u{2A2BD}\u{249DA}\u{2183A}\u{24177}\u{2827C}\u5899\u5268\u361A\u{2573D}\u7BB2\u5B68\u4800\u4B2C\u9F27\u49E7\u9C1F\u9B8D\u{25B74}\u{2313D}\u55FB\u35F2\u5689\u4E28\u5902\u{21BC1}\u{2F878}\u9751\u{20086}\u4E5B\u4EBB\u353E\u5C23\u5F51\u5FC4\u38FA\u624C\u6535\u6B7A\u6C35\u6C3A\u706C\u722B\u4E2C\u72AD\u{248E9}\u7F52\u793B\u7CF9\u7F53\u{2626A}\u34C1"],
    ["8bde", "\u{2634B}\u8002\u8080\u{26612}\u{26951}\u535D\u8864\u89C1\u{278B2}\u8BA0\u8D1D\u9485\u9578\u957F\u95E8\u{28E0F}\u97E6\u9875\u98CE\u98DE\u9963\u{29810}\u9C7C\u9E1F\u9EC4\u6B6F\uF907\u4E37\u{20087}\u961D\u6237\u94A2"],
    ["8c40", "\u503B\u6DFE\u{29C73}\u9FA6\u3DC9\u888F\u{2414E}\u7077\u5CF5\u4B20\u{251CD}\u3559\u{25D30}\u6122\u{28A32}\u8FA7\u91F6\u7191\u6719\u73BA\u{23281}\u{2A107}\u3C8B\u{21980}\u4B10\u78E4\u7402\u51AE\u{2870F}\u4009\u6A63\u{2A2BA}\u4223\u860F\u{20A6F}\u7A2A\u{29947}\u{28AEA}\u9755\u704D\u5324\u{2207E}\u93F4\u76D9\u{289E3}\u9FA7\u77DD\u4EA3\u4FF0\u50BC\u4E2F\u4F17\u9FA8\u5434\u7D8B\u5892\u58D0\u{21DB6}\u5E92\u5E99\u5FC2\u{22712}\u658B"],
    ["8ca1", "\u{233F9}\u6919\u6A43\u{23C63}\u6CFF"],
    ["8ca7", "\u7200\u{24505}\u738C\u3EDB\u{24A13}\u5B15\u74B9\u8B83\u{25CA4}\u{25695}\u7A93\u7BEC\u7CC3\u7E6C\u82F8\u8597\u9FA9\u8890\u9FAA\u8EB9\u9FAB\u8FCF\u855F\u99E0\u9221\u9FAC\u{28DB9}\u{2143F}\u4071\u42A2\u5A1A"],
    ["8cc9", "\u9868\u676B\u4276\u573D"],
    ["8cce", "\u85D6\u{2497B}\u82BF\u{2710D}\u4C81\u{26D74}\u5D7B\u{26B15}\u{26FBE}\u9FAD\u9FAE\u5B96\u9FAF\u66E7\u7E5B\u6E57\u79CA\u3D88\u44C3\u{23256}\u{22796}\u439A\u4536"],
    ["8ce6", "\u5CD5\u{23B1A}\u8AF9\u5C78\u3D12\u{23551}\u5D78\u9FB2\u7157\u4558\u{240EC}\u{21E23}\u4C77\u3978\u344A\u{201A4}\u{26C41}\u8ACC\u4FB4\u{20239}\u59BF\u816C\u9856\u{298FA}\u5F3B"],
    ["8d40", "\u{20B9F}"],
    ["8d42", "\u{221C1}\u{2896D}\u4102\u46BB\u{29079}\u3F07\u9FB3\u{2A1B5}\u40F8\u37D6\u46F7\u{26C46}\u417C\u{286B2}\u{273FF}\u456D\u38D4\u{2549A}\u4561\u451B\u4D89\u4C7B\u4D76\u45EA\u3FC8\u{24B0F}\u3661\u44DE\u44BD\u41ED\u5D3E\u5D48\u5D56\u3DFC\u380F\u5DA4\u5DB9\u3820\u3838\u5E42\u5EBD\u5F25\u5F83\u3908\u3914\u393F\u394D\u60D7\u613D\u5CE5\u3989\u61B7\u61B9\u61CF\u39B8\u622C\u6290\u62E5\u6318\u39F8\u56B1"],
    ["8da1", "\u3A03\u63E2\u63FB\u6407\u645A\u3A4B\u64C0\u5D15\u5621\u9F9F\u3A97\u6586\u3ABD\u65FF\u6653\u3AF2\u6692\u3B22\u6716\u3B42\u67A4\u6800\u3B58\u684A\u6884\u3B72\u3B71\u3B7B\u6909\u6943\u725C\u6964\u699F\u6985\u3BBC\u69D6\u3BDD\u6A65\u6A74\u6A71\u6A82\u3BEC\u6A99\u3BF2\u6AAB\u6AB5\u6AD4\u6AF6\u6B81\u6BC1\u6BEA\u6C75\u6CAA\u3CCB\u6D02\u6D06\u6D26\u6D81\u3CEF\u6DA4\u6DB1\u6E15\u6E18\u6E29\u6E86\u{289C0}\u6EBB\u6EE2\u6EDA\u9F7F\u6EE8\u6EE9\u6F24\u6F34\u3D46\u{23F41}\u6F81\u6FBE\u3D6A\u3D75\u71B7\u5C99\u3D8A\u702C\u3D91\u7050\u7054\u706F\u707F\u7089\u{20325}\u43C1\u35F1\u{20ED8}"],
    ["8e40", "\u{23ED7}\u57BE\u{26ED3}\u713E\u{257E0}\u364E\u69A2\u{28BE9}\u5B74\u7A49\u{258E1}\u{294D9}\u7A65\u7A7D\u{259AC}\u7ABB\u7AB0\u7AC2\u7AC3\u71D1\u{2648D}\u41CA\u7ADA\u7ADD\u7AEA\u41EF\u54B2\u{25C01}\u7B0B\u7B55\u7B29\u{2530E}\u{25CFE}\u7BA2\u7B6F\u839C\u{25BB4}\u{26C7F}\u7BD0\u8421\u7B92\u7BB8\u{25D20}\u3DAD\u{25C65}\u8492\u7BFA\u7C06\u7C35\u{25CC1}\u7C44\u7C83\u{24882}\u7CA6\u667D\u{24578}\u7CC9\u7CC7\u7CE6\u7C74\u7CF3\u7CF5\u7CCE"],
    ["8ea1", "\u7E67\u451D\u{26E44}\u7D5D\u{26ED6}\u748D\u7D89\u7DAB\u7135\u7DB3\u7DD2\u{24057}\u{26029}\u7DE4\u3D13\u7DF5\u{217F9}\u7DE5\u{2836D}\u7E1D\u{26121}\u{2615A}\u7E6E\u7E92\u432B\u946C\u7E27\u7F40\u7F41\u7F47\u7936\u{262D0}\u99E1\u7F97\u{26351}\u7FA3\u{21661}\u{20068}\u455C\u{23766}\u4503\u{2833A}\u7FFA\u{26489}\u8005\u8008\u801D\u8028\u802F\u{2A087}\u{26CC3}\u803B\u803C\u8061\u{22714}\u4989\u{26626}\u{23DE3}\u{266E8}\u6725\u80A7\u{28A48}\u8107\u811A\u58B0\u{226F6}\u6C7F\u{26498}\u{24FB8}\u64E7\u{2148A}\u8218\u{2185E}\u6A53\u{24A65}\u{24A95}\u447A\u8229\u{20B0D}\u{26A52}\u{23D7E}\u4FF9\u{214FD}\u84E2\u8362\u{26B0A}\u{249A7}\u{23530}\u{21773}\u{23DF8}\u82AA\u691B\u{2F994}\u41DB"],
    ["8f40", "\u854B\u82D0\u831A\u{20E16}\u{217B4}\u36C1\u{2317D}\u{2355A}\u827B\u82E2\u8318\u{23E8B}\u{26DA3}\u{26B05}\u{26B97}\u{235CE}\u3DBF\u831D\u55EC\u8385\u450B\u{26DA5}\u83AC\u83C1\u83D3\u347E\u{26ED4}\u6A57\u855A\u3496\u{26E42}\u{22EEF}\u8458\u{25BE4}\u8471\u3DD3\u44E4\u6AA7\u844A\u{23CB5}\u7958\u84A8\u{26B96}\u{26E77}\u{26E43}\u84DE\u840F\u8391\u44A0\u8493\u84E4\u{25C91}\u4240\u{25CC0}\u4543\u8534\u5AF2\u{26E99}\u4527\u8573\u4516\u67BF\u8616"],
    ["8fa1", "\u{28625}\u{2863B}\u85C1\u{27088}\u8602\u{21582}\u{270CD}\u{2F9B2}\u456A\u8628\u3648\u{218A2}\u53F7\u{2739A}\u867E\u8771\u{2A0F8}\u87EE\u{22C27}\u87B1\u87DA\u880F\u5661\u866C\u6856\u460F\u8845\u8846\u{275E0}\u{23DB9}\u{275E4}\u885E\u889C\u465B\u88B4\u88B5\u63C1\u88C5\u7777\u{2770F}\u8987\u898A\u89A6\u89A9\u89A7\u89BC\u{28A25}\u89E7\u{27924}\u{27ABD}\u8A9C\u7793\u91FE\u8A90\u{27A59}\u7AE9\u{27B3A}\u{23F8F}\u4713\u{27B38}\u717C\u8B0C\u8B1F\u{25430}\u{25565}\u8B3F\u8B4C\u8B4D\u8AA9\u{24A7A}\u8B90\u8B9B\u8AAF\u{216DF}\u4615\u884F\u8C9B\u{27D54}\u{27D8F}\u{2F9D4}\u3725\u{27D53}\u8CD6\u{27D98}\u{27DBD}\u8D12\u8D03\u{21910}\u8CDB\u705C\u8D11\u{24CC9}\u3ED0\u8D77"],
    ["9040", "\u8DA9\u{28002}\u{21014}\u{2498A}\u3B7C\u{281BC}\u{2710C}\u7AE7\u8EAD\u8EB6\u8EC3\u92D4\u8F19\u8F2D\u{28365}\u{28412}\u8FA5\u9303\u{2A29F}\u{20A50}\u8FB3\u492A\u{289DE}\u{2853D}\u{23DBB}\u5EF8\u{23262}\u8FF9\u{2A014}\u{286BC}\u{28501}\u{22325}\u3980\u{26ED7}\u9037\u{2853C}\u{27ABE}\u9061\u{2856C}\u{2860B}\u90A8\u{28713}\u90C4\u{286E6}\u90AE\u90FD\u9167\u3AF0\u91A9\u91C4\u7CAC\u{28933}\u{21E89}\u920E\u6C9F\u9241\u9262\u{255B9}\u92B9\u{28AC6}\u{23C9B}\u{28B0C}\u{255DB}"],
    ["90a1", "\u{20D31}\u932C\u936B\u{28AE1}\u{28BEB}\u708F\u5AC3\u{28AE2}\u{28AE5}\u4965\u9244\u{28BEC}\u{28C39}\u{28BFF}\u9373\u945B\u8EBC\u9585\u95A6\u9426\u95A0\u6FF6\u42B9\u{2267A}\u{286D8}\u{2127C}\u{23E2E}\u49DF\u6C1C\u967B\u9696\u416C\u96A3\u{26ED5}\u61DA\u96B6\u78F5\u{28AE0}\u96BD\u53CC\u49A1\u{26CB8}\u{20274}\u{26410}\u{290AF}\u{290E5}\u{24AD1}\u{21915}\u{2330A}\u9731\u8642\u9736\u4A0F\u453D\u4585\u{24AE9}\u7075\u5B41\u971B\u975C\u{291D5}\u9757\u5B4A\u{291EB}\u975F\u9425\u50D0\u{230B7}\u{230BC}\u9789\u979F\u97B1\u97BE\u97C0\u97D2\u97E0\u{2546C}\u97EE\u741C\u{29433}\u97FF\u97F5\u{2941D}\u{2797A}\u4AD1\u9834\u9833\u984B\u9866\u3B0E\u{27175}\u3D51\u{20630}\u{2415C}"],
    ["9140", "\u{25706}\u98CA\u98B7\u98C8\u98C7\u4AFF\u{26D27}\u{216D3}\u55B0\u98E1\u98E6\u98EC\u9378\u9939\u{24A29}\u4B72\u{29857}\u{29905}\u99F5\u9A0C\u9A3B\u9A10\u9A58\u{25725}\u36C4\u{290B1}\u{29BD5}\u9AE0\u9AE2\u{29B05}\u9AF4\u4C0E\u9B14\u9B2D\u{28600}\u5034\u9B34\u{269A8}\u38C3\u{2307D}\u9B50\u9B40\u{29D3E}\u5A45\u{21863}\u9B8E\u{2424B}\u9C02\u9BFF\u9C0C\u{29E68}\u9DD4\u{29FB7}\u{2A192}\u{2A1AB}\u{2A0E1}\u{2A123}\u{2A1DF}\u9D7E\u9D83\u{2A134}\u9E0E\u6888"],
    ["91a1", "\u9DC4\u{2215B}\u{2A193}\u{2A220}\u{2193B}\u{2A233}\u9D39\u{2A0B9}\u{2A2B4}\u9E90\u9E95\u9E9E\u9EA2\u4D34\u9EAA\u9EAF\u{24364}\u9EC1\u3B60\u39E5\u3D1D\u4F32\u37BE\u{28C2B}\u9F02\u9F08\u4B96\u9424\u{26DA2}\u9F17\u9F16\u9F39\u569F\u568A\u9F45\u99B8\u{2908B}\u97F2\u847F\u9F62\u9F69\u7ADC\u9F8E\u7216\u4BBE\u{24975}\u{249BB}\u7177\u{249F8}\u{24348}\u{24A51}\u739E\u{28BDA}\u{218FA}\u799F\u{2897E}\u{28E36}\u9369\u93F3\u{28A44}\u92EC\u9381\u93CB\u{2896C}\u{244B9}\u7217\u3EEB\u7772\u7A43\u70D0\u{24473}\u{243F8}\u717E\u{217EF}\u70A3\u{218BE}\u{23599}\u3EC7\u{21885}\u{2542F}\u{217F8}\u3722\u{216FB}\u{21839}\u36E1\u{21774}\u{218D1}\u{25F4B}\u3723\u{216C0}\u575B\u{24A25}\u{213FE}\u{212A8}"],
    ["9240", "\u{213C6}\u{214B6}\u8503\u{236A6}\u8503\u8455\u{24994}\u{27165}\u{23E31}\u{2555C}\u{23EFB}\u{27052}\u44F4\u{236EE}\u{2999D}\u{26F26}\u67F9\u3733\u3C15\u3DE7\u586C\u{21922}\u6810\u4057\u{2373F}\u{240E1}\u{2408B}\u{2410F}\u{26C21}\u54CB\u569E\u{266B1}\u5692\u{20FDF}\u{20BA8}\u{20E0D}\u93C6\u{28B13}\u939C\u4EF8\u512B\u3819\u{24436}\u4EBC\u{20465}\u{2037F}\u4F4B\u4F8A\u{25651}\u5A68\u{201AB}\u{203CB}\u3999\u{2030A}\u{20414}\u3435\u4F29\u{202C0}\u{28EB3}\u{20275}\u8ADA\u{2020C}\u4E98"],
    ["92a1", "\u50CD\u510D\u4FA2\u4F03\u{24A0E}\u{23E8A}\u4F42\u502E\u506C\u5081\u4FCC\u4FE5\u5058\u50FC\u5159\u515B\u515D\u515E\u6E76\u{23595}\u{23E39}\u{23EBF}\u6D72\u{21884}\u{23E89}\u51A8\u51C3\u{205E0}\u44DD\u{204A3}\u{20492}\u{20491}\u8D7A\u{28A9C}\u{2070E}\u5259\u52A4\u{20873}\u52E1\u936E\u467A\u718C\u{2438C}\u{20C20}\u{249AC}\u{210E4}\u69D1\u{20E1D}\u7479\u3EDE\u7499\u7414\u7456\u7398\u4B8E\u{24ABC}\u{2408D}\u53D0\u3584\u720F\u{240C9}\u55B4\u{20345}\u54CD\u{20BC6}\u571D\u925D\u96F4\u9366\u57DD\u578D\u577F\u363E\u58CB\u5A99\u{28A46}\u{216FA}\u{2176F}\u{21710}\u5A2C\u59B8\u928F\u5A7E\u5ACF\u5A12\u{25946}\u{219F3}\u{21861}\u{24295}\u36F5\u6D05\u7443\u5A21\u{25E83}"],
    ["9340", "\u5A81\u{28BD7}\u{20413}\u93E0\u748C\u{21303}\u7105\u4972\u9408\u{289FB}\u93BD\u37A0\u5C1E\u5C9E\u5E5E\u5E48\u{21996}\u{2197C}\u{23AEE}\u5ECD\u5B4F\u{21903}\u{21904}\u3701\u{218A0}\u36DD\u{216FE}\u36D3\u812A\u{28A47}\u{21DBA}\u{23472}\u{289A8}\u5F0C\u5F0E\u{21927}\u{217AB}\u5A6B\u{2173B}\u5B44\u8614\u{275FD}\u8860\u607E\u{22860}\u{2262B}\u5FDB\u3EB8\u{225AF}\u{225BE}\u{29088}\u{26F73}\u61C0\u{2003E}\u{20046}\u{2261B}\u6199\u6198\u6075\u{22C9B}\u{22D07}\u{246D4}\u{2914D}"],
    ["93a1", "\u6471\u{24665}\u{22B6A}\u3A29\u{22B22}\u{23450}\u{298EA}\u{22E78}\u6337\u{2A45B}\u64B6\u6331\u63D1\u{249E3}\u{22D67}\u62A4\u{22CA1}\u643B\u656B\u6972\u3BF4\u{2308E}\u{232AD}\u{24989}\u{232AB}\u550D\u{232E0}\u{218D9}\u{2943F}\u66CE\u{23289}\u{231B3}\u3AE0\u4190\u{25584}\u{28B22}\u{2558F}\u{216FC}\u{2555B}\u{25425}\u78EE\u{23103}\u{2182A}\u{23234}\u3464\u{2320F}\u{23182}\u{242C9}\u668E\u{26D24}\u666B\u4B93\u6630\u{27870}\u{21DEB}\u6663\u{232D2}\u{232E1}\u661E\u{25872}\u38D1\u{2383A}\u{237BC}\u3B99\u{237A2}\u{233FE}\u74D0\u3B96\u678F\u{2462A}\u68B6\u681E\u3BC4\u6ABE\u3863\u{237D5}\u{24487}\u6A33\u6A52\u6AC9\u6B05\u{21912}\u6511\u6898\u6A4C\u3BD7\u6A7A\u6B57\u{23FC0}\u{23C9A}\u93A0\u92F2\u{28BEA}\u{28ACB}"],
    ["9440", "\u9289\u{2801E}\u{289DC}\u9467\u6DA5\u6F0B\u{249EC}\u6D67\u{23F7F}\u3D8F\u6E04\u{2403C}\u5A3D\u6E0A\u5847\u6D24\u7842\u713B\u{2431A}\u{24276}\u70F1\u7250\u7287\u7294\u{2478F}\u{24725}\u5179\u{24AA4}\u{205EB}\u747A\u{23EF8}\u{2365F}\u{24A4A}\u{24917}\u{25FE1}\u3F06\u3EB1\u{24ADF}\u{28C23}\u{23F35}\u60A7\u3EF3\u74CC\u743C\u9387\u7437\u449F\u{26DEA}\u4551\u7583\u3F63\u{24CD9}\u{24D06}\u3F58\u7555\u7673\u{2A5C6}\u3B19\u7468\u{28ACC}\u{249AB}\u{2498E}\u3AFB"],
    ["94a1", "\u3DCD\u{24A4E}\u3EFF\u{249C5}\u{248F3}\u91FA\u5732\u9342\u{28AE3}\u{21864}\u50DF\u{25221}\u{251E7}\u7778\u{23232}\u770E\u770F\u777B\u{24697}\u{23781}\u3A5E\u{248F0}\u7438\u749B\u3EBF\u{24ABA}\u{24AC7}\u40C8\u{24A96}\u{261AE}\u9307\u{25581}\u781E\u788D\u7888\u78D2\u73D0\u7959\u{27741}\u{256E3}\u410E\u799B\u8496\u79A5\u6A2D\u{23EFA}\u7A3A\u79F4\u416E\u{216E6}\u4132\u9235\u79F1\u{20D4C}\u{2498C}\u{20299}\u{23DBA}\u{2176E}\u3597\u556B\u3570\u36AA\u{201D4}\u{20C0D}\u7AE2\u5A59\u{226F5}\u{25AAF}\u{25A9C}\u5A0D\u{2025B}\u78F0\u5A2A\u{25BC6}\u7AFE\u41F9\u7C5D\u7C6D\u4211\u{25BB3}\u{25EBC}\u{25EA6}\u7CCD\u{249F9}\u{217B0}\u7C8E\u7C7C\u7CAE\u6AB2\u7DDC\u7E07\u7DD3\u7F4E\u{26261}"],
    ["9540", "\u{2615C}\u{27B48}\u7D97\u{25E82}\u426A\u{26B75}\u{20916}\u67D6\u{2004E}\u{235CF}\u57C4\u{26412}\u{263F8}\u{24962}\u7FDD\u7B27\u{2082C}\u{25AE9}\u{25D43}\u7B0C\u{25E0E}\u99E6\u8645\u9A63\u6A1C\u{2343F}\u39E2\u{249F7}\u{265AD}\u9A1F\u{265A0}\u8480\u{27127}\u{26CD1}\u44EA\u8137\u4402\u80C6\u8109\u8142\u{267B4}\u98C3\u{26A42}\u8262\u8265\u{26A51}\u8453\u{26DA7}\u8610\u{2721B}\u5A86\u417F\u{21840}\u5B2B\u{218A1}\u5AE4\u{218D8}\u86A0\u{2F9BC}\u{23D8F}\u882D\u{27422}\u5A02"],
    ["95a1", "\u886E\u4F45\u8887\u88BF\u88E6\u8965\u894D\u{25683}\u8954\u{27785}\u{27784}\u{28BF5}\u{28BD9}\u{28B9C}\u{289F9}\u3EAD\u84A3\u46F5\u46CF\u37F2\u8A3D\u8A1C\u{29448}\u5F4D\u922B\u{24284}\u65D4\u7129\u70C4\u{21845}\u9D6D\u8C9F\u8CE9\u{27DDC}\u599A\u77C3\u59F0\u436E\u36D4\u8E2A\u8EA7\u{24C09}\u8F30\u8F4A\u42F4\u6C58\u6FBB\u{22321}\u489B\u6F79\u6E8B\u{217DA}\u9BE9\u36B5\u{2492F}\u90BB\u9097\u5571\u4906\u91BB\u9404\u{28A4B}\u4062\u{28AFC}\u9427\u{28C1D}\u{28C3B}\u84E5\u8A2B\u9599\u95A7\u9597\u9596\u{28D34}\u7445\u3EC2\u{248FF}\u{24A42}\u{243EA}\u3EE7\u{23225}\u968F\u{28EE7}\u{28E66}\u{28E65}\u3ECC\u{249ED}\u{24A78}\u{23FEE}\u7412\u746B\u3EFC\u9741\u{290B0}"],
    ["9640", "\u6847\u4A1D\u{29093}\u{257DF}\u975D\u9368\u{28989}\u{28C26}\u{28B2F}\u{263BE}\u92BA\u5B11\u8B69\u493C\u73F9\u{2421B}\u979B\u9771\u9938\u{20F26}\u5DC1\u{28BC5}\u{24AB2}\u981F\u{294DA}\u92F6\u{295D7}\u91E5\u44C0\u{28B50}\u{24A67}\u{28B64}\u98DC\u{28A45}\u3F00\u922A\u4925\u8414\u993B\u994D\u{27B06}\u3DFD\u999B\u4B6F\u99AA\u9A5C\u{28B65}\u{258C8}\u6A8F\u9A21\u5AFE\u9A2F\u{298F1}\u4B90\u{29948}\u99BC\u4BBD\u4B97\u937D\u5872\u{21302}\u5822\u{249B8}"],
    ["96a1", "\u{214E8}\u7844\u{2271F}\u{23DB8}\u68C5\u3D7D\u9458\u3927\u6150\u{22781}\u{2296B}\u6107\u9C4F\u9C53\u9C7B\u9C35\u9C10\u9B7F\u9BCF\u{29E2D}\u9B9F\u{2A1F5}\u{2A0FE}\u9D21\u4CAE\u{24104}\u9E18\u4CB0\u9D0C\u{2A1B4}\u{2A0ED}\u{2A0F3}\u{2992F}\u9DA5\u84BD\u{26E12}\u{26FDF}\u{26B82}\u85FC\u4533\u{26DA4}\u{26E84}\u{26DF0}\u8420\u85EE\u{26E00}\u{237D7}\u{26064}\u79E2\u{2359C}\u{23640}\u492D\u{249DE}\u3D62\u93DB\u92BE\u9348\u{202BF}\u78B9\u9277\u944D\u4FE4\u3440\u9064\u{2555D}\u783D\u7854\u78B6\u784B\u{21757}\u{231C9}\u{24941}\u369A\u4F72\u6FDA\u6FD9\u701E\u701E\u5414\u{241B5}\u57BB\u58F3\u578A\u9D16\u57D7\u7134\u34AF\u{241AC}\u71EB\u{26C40}\u{24F97}\u5B28\u{217B5}\u{28A49}"],
    ["9740", "\u610C\u5ACE\u5A0B\u42BC\u{24488}\u372C\u4B7B\u{289FC}\u93BB\u93B8\u{218D6}\u{20F1D}\u8472\u{26CC0}\u{21413}\u{242FA}\u{22C26}\u{243C1}\u5994\u{23DB7}\u{26741}\u7DA8\u{2615B}\u{260A4}\u{249B9}\u{2498B}\u{289FA}\u92E5\u73E2\u3EE9\u74B4\u{28B63}\u{2189F}\u3EE1\u{24AB3}\u6AD8\u73F3\u73FB\u3ED6\u{24A3E}\u{24A94}\u{217D9}\u{24A66}\u{203A7}\u{21424}\u{249E5}\u7448\u{24916}\u70A5\u{24976}\u9284\u73E6\u935F\u{204FE}\u9331\u{28ACE}\u{28A16}\u9386\u{28BE7}\u{255D5}\u4935\u{28A82}\u716B"],
    ["97a1", "\u{24943}\u{20CFF}\u56A4\u{2061A}\u{20BEB}\u{20CB8}\u5502\u79C4\u{217FA}\u7DFE\u{216C2}\u{24A50}\u{21852}\u452E\u9401\u370A\u{28AC0}\u{249AD}\u59B0\u{218BF}\u{21883}\u{27484}\u5AA1\u36E2\u{23D5B}\u36B0\u925F\u5A79\u{28A81}\u{21862}\u9374\u3CCD\u{20AB4}\u4A96\u398A\u50F4\u3D69\u3D4C\u{2139C}\u7175\u42FB\u{28218}\u6E0F\u{290E4}\u44EB\u6D57\u{27E4F}\u7067\u6CAF\u3CD6\u{23FED}\u{23E2D}\u6E02\u6F0C\u3D6F\u{203F5}\u7551\u36BC\u34C8\u4680\u3EDA\u4871\u59C4\u926E\u493E\u8F41\u{28C1C}\u{26BC0}\u5812\u57C8\u36D6\u{21452}\u70FE\u{24362}\u{24A71}\u{22FE3}\u{212B0}\u{223BD}\u68B9\u6967\u{21398}\u{234E5}\u{27BF4}\u{236DF}\u{28A83}\u{237D6}\u{233FA}\u{24C9F}\u6A1A\u{236AD}\u{26CB7}\u843E\u44DF\u44CE"],
    ["9840", "\u{26D26}\u{26D51}\u{26C82}\u{26FDE}\u6F17\u{27109}\u833D\u{2173A}\u83ED\u{26C80}\u{27053}\u{217DB}\u5989\u5A82\u{217B3}\u5A61\u5A71\u{21905}\u{241FC}\u372D\u59EF\u{2173C}\u36C7\u718E\u9390\u669A\u{242A5}\u5A6E\u5A2B\u{24293}\u6A2B\u{23EF9}\u{27736}\u{2445B}\u{242CA}\u711D\u{24259}\u{289E1}\u4FB0\u{26D28}\u5CC2\u{244CE}\u{27E4D}\u{243BD}\u6A0C\u{24256}\u{21304}\u70A6\u7133\u{243E9}\u3DA5\u6CDF\u{2F825}\u{24A4F}\u7E65\u59EB\u5D2F\u3DF3\u5F5C\u{24A5D}\u{217DF}\u7DA4\u8426"],
    ["98a1", "\u5485\u{23AFA}\u{23300}\u{20214}\u577E\u{208D5}\u{20619}\u3FE5\u{21F9E}\u{2A2B6}\u7003\u{2915B}\u5D70\u738F\u7CD3\u{28A59}\u{29420}\u4FC8\u7FE7\u72CD\u7310\u{27AF4}\u7338\u7339\u{256F6}\u7341\u7348\u3EA9\u{27B18}\u906C\u71F5\u{248F2}\u73E1\u81F6\u3ECA\u770C\u3ED1\u6CA2\u56FD\u7419\u741E\u741F\u3EE2\u3EF0\u3EF4\u3EFA\u74D3\u3F0E\u3F53\u7542\u756D\u7572\u758D\u3F7C\u75C8\u75DC\u3FC0\u764D\u3FD7\u7674\u3FDC\u767A\u{24F5C}\u7188\u5623\u8980\u5869\u401D\u7743\u4039\u6761\u4045\u35DB\u7798\u406A\u406F\u5C5E\u77BE\u77CB\u58F2\u7818\u70B9\u781C\u40A8\u7839\u7847\u7851\u7866\u8448\u{25535}\u7933\u6803\u7932\u4103"],
    ["9940", "\u4109\u7991\u7999\u8FBB\u7A06\u8FBC\u4167\u7A91\u41B2\u7ABC\u8279\u41C4\u7ACF\u7ADB\u41CF\u4E21\u7B62\u7B6C\u7B7B\u7C12\u7C1B\u4260\u427A\u7C7B\u7C9C\u428C\u7CB8\u4294\u7CED\u8F93\u70C0\u{20CCF}\u7DCF\u7DD4\u7DD0\u7DFD\u7FAE\u7FB4\u729F\u4397\u8020\u8025\u7B39\u802E\u8031\u8054\u3DCC\u57B4\u70A0\u80B7\u80E9\u43ED\u810C\u732A\u810E\u8112\u7560\u8114\u4401\u3B39\u8156\u8159\u815A"],
    ["99a1", "\u4413\u583A\u817C\u8184\u4425\u8193\u442D\u81A5\u57EF\u81C1\u81E4\u8254\u448F\u82A6\u8276\u82CA\u82D8\u82FF\u44B0\u8357\u9669\u698A\u8405\u70F5\u8464\u60E3\u8488\u4504\u84BE\u84E1\u84F8\u8510\u8538\u8552\u453B\u856F\u8570\u85E0\u4577\u8672\u8692\u86B2\u86EF\u9645\u878B\u4606\u4617\u88AE\u88FF\u8924\u8947\u8991\u{27967}\u8A29\u8A38\u8A94\u8AB4\u8C51\u8CD4\u8CF2\u8D1C\u4798\u585F\u8DC3\u47ED\u4EEE\u8E3A\u55D8\u5754\u8E71\u55F5\u8EB0\u4837\u8ECE\u8EE2\u8EE4\u8EED\u8EF2\u8FB7\u8FC1\u8FCA\u8FCC\u9033\u99C4\u48AD\u98E0\u9213\u491E\u9228\u9258\u926B\u92B1\u92AE\u92BF"],
    ["9a40", "\u92E3\u92EB\u92F3\u92F4\u92FD\u9343\u9384\u93AD\u4945\u4951\u9EBF\u9417\u5301\u941D\u942D\u943E\u496A\u9454\u9479\u952D\u95A2\u49A7\u95F4\u9633\u49E5\u67A0\u4A24\u9740\u4A35\u97B2\u97C2\u5654\u4AE4\u60E8\u98B9\u4B19\u98F1\u5844\u990E\u9919\u51B4\u991C\u9937\u9942\u995D\u9962\u4B70\u99C5\u4B9D\u9A3C\u9B0F\u7A83\u9B69\u9B81\u9BDD\u9BF1\u9BF4\u4C6D\u9C20\u376F\u{21BC2}\u9D49\u9C3A"],
    ["9aa1", "\u9EFE\u5650\u9D93\u9DBD\u9DC0\u9DFC\u94F6\u8FB6\u9E7B\u9EAC\u9EB1\u9EBD\u9EC6\u94DC\u9EE2\u9EF1\u9EF8\u7AC8\u9F44\u{20094}\u{202B7}\u{203A0}\u691A\u94C3\u59AC\u{204D7}\u5840\u94C1\u37B9\u{205D5}\u{20615}\u{20676}\u{216BA}\u5757\u7173\u{20AC2}\u{20ACD}\u{20BBF}\u546A\u{2F83B}\u{20BCB}\u549E\u{20BFB}\u{20C3B}\u{20C53}\u{20C65}\u{20C7C}\u60E7\u{20C8D}\u567A\u{20CB5}\u{20CDD}\u{20CED}\u{20D6F}\u{20DB2}\u{20DC8}\u6955\u9C2F\u87A5\u{20E04}\u{20E0E}\u{20ED7}\u{20F90}\u{20F2D}\u{20E73}\u5C20\u{20FBC}\u5E0B\u{2105C}\u{2104F}\u{21076}\u671E\u{2107B}\u{21088}\u{21096}\u3647\u{210BF}\u{210D3}\u{2112F}\u{2113B}\u5364\u84AD\u{212E3}\u{21375}\u{21336}\u8B81\u{21577}\u{21619}\u{217C3}\u{217C7}\u4E78\u70BB\u{2182D}\u{2196A}"],
    ["9b40", "\u{21A2D}\u{21A45}\u{21C2A}\u{21C70}\u{21CAC}\u{21EC8}\u62C3\u{21ED5}\u{21F15}\u7198\u6855\u{22045}\u69E9\u36C8\u{2227C}\u{223D7}\u{223FA}\u{2272A}\u{22871}\u{2294F}\u82FD\u{22967}\u{22993}\u{22AD5}\u89A5\u{22AE8}\u8FA0\u{22B0E}\u97B8\u{22B3F}\u9847\u9ABD\u{22C4C}"],
    ["9b62", "\u{22C88}\u{22CB7}\u{25BE8}\u{22D08}\u{22D12}\u{22DB7}\u{22D95}\u{22E42}\u{22F74}\u{22FCC}\u{23033}\u{23066}\u{2331F}\u{233DE}\u5FB1\u6648\u66BF\u{27A79}\u{23567}\u{235F3}\u7201\u{249BA}\u77D7\u{2361A}\u{23716}\u7E87\u{20346}\u58B5\u670E"],
    ["9ba1", "\u6918\u{23AA7}\u{27657}\u{25FE2}\u{23E11}\u{23EB9}\u{275FE}\u{2209A}\u48D0\u4AB8\u{24119}\u{28A9A}\u{242EE}\u{2430D}\u{2403B}\u{24334}\u{24396}\u{24A45}\u{205CA}\u51D2\u{20611}\u599F\u{21EA8}\u3BBE\u{23CFF}\u{24404}\u{244D6}\u5788\u{24674}\u399B\u{2472F}\u{285E8}\u{299C9}\u3762\u{221C3}\u8B5E\u{28B4E}\u99D6\u{24812}\u{248FB}\u{24A15}\u7209\u{24AC0}\u{20C78}\u5965\u{24EA5}\u{24F86}\u{20779}\u8EDA\u{2502C}\u528F\u573F\u7171\u{25299}\u{25419}\u{23F4A}\u{24AA7}\u55BC\u{25446}\u{2546E}\u{26B52}\u91D4\u3473\u{2553F}\u{27632}\u{2555E}\u4718\u{25562}\u{25566}\u{257C7}\u{2493F}\u{2585D}\u5066\u34FB\u{233CC}\u60DE\u{25903}\u477C\u{28948}\u{25AAE}\u{25B89}\u{25C06}\u{21D90}\u57A1\u7151\u6FB6\u{26102}\u{27C12}\u9056\u{261B2}\u{24F9A}\u8B62\u{26402}\u{2644A}"],
    ["9c40", "\u5D5B\u{26BF7}\u8F36\u{26484}\u{2191C}\u8AEA\u{249F6}\u{26488}\u{23FEF}\u{26512}\u4BC0\u{265BF}\u{266B5}\u{2271B}\u9465\u{257E1}\u6195\u5A27\u{2F8CD}\u4FBB\u56B9\u{24521}\u{266FC}\u4E6A\u{24934}\u9656\u6D8F\u{26CBD}\u3618\u8977\u{26799}\u{2686E}\u{26411}\u{2685E}\u71DF\u{268C7}\u7B42\u{290C0}\u{20A11}\u{26926}\u9104\u{26939}\u7A45\u9DF0\u{269FA}\u9A26\u{26A2D}\u365F\u{26469}\u{20021}\u7983\u{26A34}\u{26B5B}\u5D2C\u{23519}\u83CF\u{26B9D}\u46D0\u{26CA4}\u753B\u8865\u{26DAE}\u58B6"],
    ["9ca1", "\u371C\u{2258D}\u{2704B}\u{271CD}\u3C54\u{27280}\u{27285}\u9281\u{2217A}\u{2728B}\u9330\u{272E6}\u{249D0}\u6C39\u949F\u{27450}\u{20EF8}\u8827\u88F5\u{22926}\u{28473}\u{217B1}\u6EB8\u{24A2A}\u{21820}\u39A4\u36B9\u5C10\u79E3\u453F\u66B6\u{29CAD}\u{298A4}\u8943\u{277CC}\u{27858}\u56D6\u40DF\u{2160A}\u39A1\u{2372F}\u{280E8}\u{213C5}\u71AD\u8366\u{279DD}\u{291A8}\u5A67\u4CB7\u{270AF}\u{289AB}\u{279FD}\u{27A0A}\u{27B0B}\u{27D66}\u{2417A}\u7B43\u797E\u{28009}\u6FB5\u{2A2DF}\u6A03\u{28318}\u53A2\u{26E07}\u93BF\u6836\u975D\u{2816F}\u{28023}\u{269B5}\u{213ED}\u{2322F}\u{28048}\u5D85\u{28C30}\u{28083}\u5715\u9823\u{28949}\u5DAB\u{24988}\u65BE\u69D5\u53D2\u{24AA5}\u{23F81}\u3C11\u6736\u{28090}\u{280F4}\u{2812E}\u{21FA1}\u{2814F}"],
    ["9d40", "\u{28189}\u{281AF}\u{2821A}\u{28306}\u{2832F}\u{2838A}\u35CA\u{28468}\u{286AA}\u48FA\u63E6\u{28956}\u7808\u9255\u{289B8}\u43F2\u{289E7}\u43DF\u{289E8}\u{28B46}\u{28BD4}\u59F8\u{28C09}\u8F0B\u{28FC5}\u{290EC}\u7B51\u{29110}\u{2913C}\u3DF7\u{2915E}\u{24ACA}\u8FD0\u728F\u568B\u{294E7}\u{295E9}\u{295B0}\u{295B8}\u{29732}\u{298D1}\u{29949}\u{2996A}\u{299C3}\u{29A28}\u{29B0E}\u{29D5A}\u{29D9B}\u7E9F\u{29EF8}\u{29F23}\u4CA4\u9547\u{2A293}\u71A2\u{2A2FF}\u4D91\u9012\u{2A5CB}\u4D9C\u{20C9C}\u8FBE\u55C1"],
    ["9da1", "\u8FBA\u{224B0}\u8FB9\u{24A93}\u4509\u7E7F\u6F56\u6AB1\u4EEA\u34E4\u{28B2C}\u{2789D}\u373A\u8E80\u{217F5}\u{28024}\u{28B6C}\u{28B99}\u{27A3E}\u{266AF}\u3DEB\u{27655}\u{23CB7}\u{25635}\u{25956}\u4E9A\u{25E81}\u{26258}\u56BF\u{20E6D}\u8E0E\u5B6D\u{23E88}\u{24C9E}\u63DE\u62D0\u{217F6}\u{2187B}\u6530\u562D\u{25C4A}\u541A\u{25311}\u3DC6\u{29D98}\u4C7D\u5622\u561E\u7F49\u{25ED8}\u5975\u{23D40}\u8770\u4E1C\u{20FEA}\u{20D49}\u{236BA}\u8117\u9D5E\u8D18\u763B\u9C45\u764E\u77B9\u9345\u5432\u8148\u82F7\u5625\u8132\u8418\u80BD\u55EA\u7962\u5643\u5416\u{20E9D}\u35CE\u5605\u55F1\u66F1\u{282E2}\u362D\u7534\u55F0\u55BA\u5497\u5572\u{20C41}\u{20C96}\u5ED0\u{25148}\u{20E76}\u{22C62}"],
    ["9e40", "\u{20EA2}\u9EAB\u7D5A\u55DE\u{21075}\u629D\u976D\u5494\u8CCD\u71F6\u9176\u63FC\u63B9\u63FE\u5569\u{22B43}\u9C72\u{22EB3}\u519A\u34DF\u{20DA7}\u51A7\u544D\u551E\u5513\u7666\u8E2D\u{2688A}\u75B1\u80B6\u8804\u8786\u88C7\u81B6\u841C\u{210C1}\u44EC\u7304\u{24706}\u5B90\u830B\u{26893}\u567B\u{226F4}\u{27D2F}\u{241A3}\u{27D73}\u{26ED0}\u{272B6}\u9170\u{211D9}\u9208\u{23CFC}\u{2A6A9}\u{20EAC}\u{20EF9}\u7266\u{21CA2}\u474E\u{24FC2}\u{27FF9}\u{20FEB}\u40FA"],
    ["9ea1", "\u9C5D\u651F\u{22DA0}\u48F3\u{247E0}\u{29D7C}\u{20FEC}\u{20E0A}\u6062\u{275A3}\u{20FED}"],
    ["9ead", "\u{26048}\u{21187}\u71A3\u7E8E\u9D50\u4E1A\u4E04\u3577\u5B0D\u6CB2\u5367\u36AC\u39DC\u537D\u36A5\u{24618}\u589A\u{24B6E}\u822D\u544B\u57AA\u{25A95}\u{20979}"],
    ["9ec5", "\u3A52\u{22465}\u7374\u{29EAC}\u4D09\u9BED\u{23CFE}\u{29F30}\u4C5B\u{24FA9}\u{2959E}\u{29FDE}\u845C\u{23DB6}\u{272B2}\u{267B3}\u{23720}\u632E\u7D25\u{23EF7}\u{23E2C}\u3A2A\u9008\u52CC\u3E74\u367A\u45E9\u{2048E}\u7640\u5AF0\u{20EB6}\u787A\u{27F2E}\u58A7\u40BF\u567C\u9B8B\u5D74\u7654\u{2A434}\u9E85\u4CE1\u75F9\u37FB\u6119\u{230DA}\u{243F2}"],
    ["9ef5", "\u565D\u{212A9}\u57A7\u{24963}\u{29E06}\u5234\u{270AE}\u35AD\u6C4A\u9D7C"],
    ["9f40", "\u7C56\u9B39\u57DE\u{2176C}\u5C53\u64D3\u{294D0}\u{26335}\u{27164}\u86AD\u{20D28}\u{26D22}\u{24AE2}\u{20D71}"],
    ["9f4f", "\u51FE\u{21F0F}\u5D8E\u9703\u{21DD1}\u9E81\u904C\u7B1F\u9B02\u5CD1\u7BA3\u6268\u6335\u9AFF\u7BCF\u9B2A\u7C7E\u9B2E\u7C42\u7C86\u9C15\u7BFC\u9B09\u9F17\u9C1B\u{2493E}\u9F5A\u5573\u5BC3\u4FFD\u9E98\u4FF2\u5260\u3E06\u52D1\u5767\u5056\u59B7\u5E12\u97C8\u9DAB\u8F5C\u5469\u97B4\u9940\u97BA\u532C\u6130"],
    ["9fa1", "\u692C\u53DA\u9C0A\u9D02\u4C3B\u9641\u6980\u50A6\u7546\u{2176D}\u99DA\u5273"],
    ["9fae", "\u9159\u9681\u915C"],
    ["9fb2", "\u9151\u{28E97}\u637F\u{26D23}\u6ACA\u5611\u918E\u757A\u6285\u{203FC}\u734F\u7C70\u{25C21}\u{23CFD}"],
    ["9fc1", "\u{24919}\u76D6\u9B9D\u4E2A\u{20CD4}\u83BE\u8842"],
    ["9fc9", "\u5C4A\u69C0\u50ED\u577A\u521F\u5DF5\u4ECE\u6C31\u{201F2}\u4F39\u549C\u54DA\u529A\u8D82\u35FE\u5F0C\u35F3"],
    ["9fdb", "\u6B52\u917C\u9FA5\u9B97\u982E\u98B4\u9ABA\u9EA8\u9E84\u717A\u7B14"],
    ["9fe7", "\u6BFA\u8818\u7F78"],
    ["9feb", "\u5620\u{2A64A}\u8E77\u9F53"],
    ["9ff0", "\u8DD4\u8E4F\u9E1C\u8E01\u6282\u{2837D}\u8E28\u8E75\u7AD3\u{24A77}\u7A3E\u78D8\u6CEA\u8A67\u7607"],
    ["a040", "\u{28A5A}\u9F26\u6CCE\u87D6\u75C3\u{2A2B2}\u7853\u{2F840}\u8D0C\u72E2\u7371\u8B2D\u7302\u74F1\u8CEB\u{24ABB}\u862F\u5FBA\u88A0\u44B7"],
    ["a055", "\u{2183B}\u{26E05}"],
    ["a058", "\u8A7E\u{2251B}"],
    ["a05b", "\u60FD\u7667\u9AD7\u9D44\u936E\u9B8F\u87F5"],
    ["a063", "\u880F\u8CF7\u732C\u9721\u9BB0\u35D6\u72B2\u4C07\u7C51\u994A\u{26159}\u6159\u4C04\u9E96\u617D"],
    ["a073", "\u575F\u616F\u62A6\u6239\u62CE\u3A5C\u61E2\u53AA\u{233F5}\u6364\u6802\u35D2"],
    ["a0a1", "\u5D57\u{28BC2}\u8FDA\u{28E39}"],
    ["a0a6", "\u50D9\u{21D46}\u7906\u5332\u9638\u{20F3B}\u4065"],
    ["a0ae", "\u77FE"],
    ["a0b0", "\u7CC2\u{25F1A}\u7CDA\u7A2D\u8066\u8063\u7D4D\u7505\u74F2\u8994\u821A\u670C\u8062\u{27486}\u805B\u74F0\u8103\u7724\u8989\u{267CC}\u7553\u{26ED1}\u87A9\u87CE\u81C8\u878C\u8A49\u8CAD\u8B43\u772B\u74F8\u84DA\u3635\u69B2\u8DA6"],
    ["a0d4", "\u89A9\u7468\u6DB9\u87C1\u{24011}\u74E7\u3DDB\u7176\u60A4\u619C\u3CD1\u7162\u6077"],
    ["a0e2", "\u7F71\u{28B2D}\u7250\u60E9\u4B7E\u5220\u3C18\u{23CC7}\u{25ED7}\u{27656}\u{25531}\u{21944}\u{212FE}\u{29903}\u{26DDC}\u{270AD}\u5CC1\u{261AD}\u{28A0F}\u{23677}\u{200EE}\u{26846}\u{24F0E}\u4562\u5B1F\u{2634C}\u9F50\u9EA6\u{2626B}"],
    ["a3c0", "\u2400", 31, "\u2421"],
    ["c6a1", "\u2460", 9, "\u2474", 9, "\u2170", 9, "\u4E36\u4E3F\u4E85\u4EA0\u5182\u5196\u51AB\u52F9\u5338\u5369\u53B6\u590A\u5B80\u5DDB\u2F33\u5E7F\u5EF4\u5F50\u5F61\u6534\u65E0\u7592\u7676\u8FB5\u96B6\xA8\u02C6\u30FD\u30FE\u309D\u309E\u3003\u4EDD\u3005\u3006\u3007\u30FC\uFF3B\uFF3D\u273D\u3041", 23],
    ["c740", "\u3059", 58, "\u30A1\u30A2\u30A3\u30A4"],
    ["c7a1", "\u30A5", 81, "\u0410", 5, "\u0401\u0416", 4],
    ["c840", "\u041B", 26, "\u0451\u0436", 25, "\u21E7\u21B8\u21B9\u31CF\u{200CC}\u4E5A\u{2008A}\u5202\u4491"],
    ["c8a1", "\u9FB0\u5188\u9FB1\u{27607}"],
    ["c8cd", "\uFFE2\uFFE4\uFF07\uFF02\u3231\u2116\u2121\u309B\u309C\u2E80\u2E84\u2E86\u2E87\u2E88\u2E8A\u2E8C\u2E8D\u2E95\u2E9C\u2E9D\u2EA5\u2EA7\u2EAA\u2EAC\u2EAE\u2EB6\u2EBC\u2EBE\u2EC6\u2ECA\u2ECC\u2ECD\u2ECF\u2ED6\u2ED7\u2EDE\u2EE3"],
    ["c8f5", "\u0283\u0250\u025B\u0254\u0275\u0153\xF8\u014B\u028A\u026A"],
    ["f9fe", "\uFFED"],
    ["fa40", "\u{20547}\u92DB\u{205DF}\u{23FC5}\u854C\u42B5\u73EF\u51B5\u3649\u{24942}\u{289E4}\u9344\u{219DB}\u82EE\u{23CC8}\u783C\u6744\u62DF\u{24933}\u{289AA}\u{202A0}\u{26BB3}\u{21305}\u4FAB\u{224ED}\u5008\u{26D29}\u{27A84}\u{23600}\u{24AB1}\u{22513}\u5029\u{2037E}\u5FA4\u{20380}\u{20347}\u6EDB\u{2041F}\u507D\u5101\u347A\u510E\u986C\u3743\u8416\u{249A4}\u{20487}\u5160\u{233B4}\u516A\u{20BFF}\u{220FC}\u{202E5}\u{22530}\u{2058E}\u{23233}\u{21983}\u5B82\u877D\u{205B3}\u{23C99}\u51B2\u51B8"],
    ["faa1", "\u9D34\u51C9\u51CF\u51D1\u3CDC\u51D3\u{24AA6}\u51B3\u51E2\u5342\u51ED\u83CD\u693E\u{2372D}\u5F7B\u520B\u5226\u523C\u52B5\u5257\u5294\u52B9\u52C5\u7C15\u8542\u52E0\u860D\u{26B13}\u5305\u{28ADE}\u5549\u6ED9\u{23F80}\u{20954}\u{23FEC}\u5333\u5344\u{20BE2}\u6CCB\u{21726}\u681B\u73D5\u604A\u3EAA\u38CC\u{216E8}\u71DD\u44A2\u536D\u5374\u{286AB}\u537E\u537F\u{21596}\u{21613}\u77E6\u5393\u{28A9B}\u53A0\u53AB\u53AE\u73A7\u{25772}\u3F59\u739C\u53C1\u53C5\u6C49\u4E49\u57FE\u53D9\u3AAB\u{20B8F}\u53E0\u{23FEB}\u{22DA3}\u53F6\u{20C77}\u5413\u7079\u552B\u6657\u6D5B\u546D\u{26B53}\u{20D74}\u555D\u548F\u54A4\u47A6\u{2170D}\u{20EDD}\u3DB4\u{20D4D}"],
    ["fb40", "\u{289BC}\u{22698}\u5547\u4CED\u542F\u7417\u5586\u55A9\u5605\u{218D7}\u{2403A}\u4552\u{24435}\u66B3\u{210B4}\u5637\u66CD\u{2328A}\u66A4\u66AD\u564D\u564F\u78F1\u56F1\u9787\u53FE\u5700\u56EF\u56ED\u{28B66}\u3623\u{2124F}\u5746\u{241A5}\u6C6E\u708B\u5742\u36B1\u{26C7E}\u57E6\u{21416}\u5803\u{21454}\u{24363}\u5826\u{24BF5}\u585C\u58AA\u3561\u58E0\u58DC\u{2123C}\u58FB\u5BFF\u5743\u{2A150}\u{24278}\u93D3\u35A1\u591F\u68A6\u36C3\u6E59"],
    ["fba1", "\u{2163E}\u5A24\u5553\u{21692}\u8505\u59C9\u{20D4E}\u{26C81}\u{26D2A}\u{217DC}\u59D9\u{217FB}\u{217B2}\u{26DA6}\u6D71\u{21828}\u{216D5}\u59F9\u{26E45}\u5AAB\u5A63\u36E6\u{249A9}\u5A77\u3708\u5A96\u7465\u5AD3\u{26FA1}\u{22554}\u3D85\u{21911}\u3732\u{216B8}\u5E83\u52D0\u5B76\u6588\u5B7C\u{27A0E}\u4004\u485D\u{20204}\u5BD5\u6160\u{21A34}\u{259CC}\u{205A5}\u5BF3\u5B9D\u4D10\u5C05\u{21B44}\u5C13\u73CE\u5C14\u{21CA5}\u{26B28}\u5C49\u48DD\u5C85\u5CE9\u5CEF\u5D8B\u{21DF9}\u{21E37}\u5D10\u5D18\u5D46\u{21EA4}\u5CBA\u5DD7\u82FC\u382D\u{24901}\u{22049}\u{22173}\u8287\u3836\u3BC2\u5E2E\u6A8A\u5E75\u5E7A\u{244BC}\u{20CD3}\u53A6\u4EB7\u5ED0\u53A8\u{21771}\u5E09\u5EF4\u{28482}"],
    ["fc40", "\u5EF9\u5EFB\u38A0\u5EFC\u683E\u941B\u5F0D\u{201C1}\u{2F894}\u3ADE\u48AE\u{2133A}\u5F3A\u{26888}\u{223D0}\u5F58\u{22471}\u5F63\u97BD\u{26E6E}\u5F72\u9340\u{28A36}\u5FA7\u5DB6\u3D5F\u{25250}\u{21F6A}\u{270F8}\u{22668}\u91D6\u{2029E}\u{28A29}\u6031\u6685\u{21877}\u3963\u3DC7\u3639\u5790\u{227B4}\u7971\u3E40\u609E\u60A4\u60B3\u{24982}\u{2498F}\u{27A53}\u74A4\u50E1\u5AA0\u6164\u8424\u6142\u{2F8A6}\u{26ED2}\u6181\u51F4\u{20656}\u6187\u5BAA\u{23FB7}"],
    ["fca1", "\u{2285F}\u61D3\u{28B9D}\u{2995D}\u61D0\u3932\u{22980}\u{228C1}\u6023\u615C\u651E\u638B\u{20118}\u62C5\u{21770}\u62D5\u{22E0D}\u636C\u{249DF}\u3A17\u6438\u63F8\u{2138E}\u{217FC}\u6490\u6F8A\u{22E36}\u9814\u{2408C}\u{2571D}\u64E1\u64E5\u947B\u3A66\u643A\u3A57\u654D\u6F16\u{24A28}\u{24A23}\u6585\u656D\u655F\u{2307E}\u65B5\u{24940}\u4B37\u65D1\u40D8\u{21829}\u65E0\u65E3\u5FDF\u{23400}\u6618\u{231F7}\u{231F8}\u6644\u{231A4}\u{231A5}\u664B\u{20E75}\u6667\u{251E6}\u6673\u6674\u{21E3D}\u{23231}\u{285F4}\u{231C8}\u{25313}\u77C5\u{228F7}\u99A4\u6702\u{2439C}\u{24A21}\u3B2B\u69FA\u{237C2}\u675E\u6767\u6762\u{241CD}\u{290ED}\u67D7\u44E9\u6822\u6E50\u923C\u6801\u{233E6}\u{26DA0}\u685D"],
    ["fd40", "\u{2346F}\u69E1\u6A0B\u{28ADF}\u6973\u68C3\u{235CD}\u6901\u6900\u3D32\u3A01\u{2363C}\u3B80\u67AC\u6961\u{28A4A}\u42FC\u6936\u6998\u3BA1\u{203C9}\u8363\u5090\u69F9\u{23659}\u{2212A}\u6A45\u{23703}\u6A9D\u3BF3\u67B1\u6AC8\u{2919C}\u3C0D\u6B1D\u{20923}\u60DE\u6B35\u6B74\u{227CD}\u6EB5\u{23ADB}\u{203B5}\u{21958}\u3740\u5421\u{23B5A}\u6BE1\u{23EFC}\u6BDC\u6C37\u{2248B}\u{248F1}\u{26B51}\u6C5A\u8226\u6C79\u{23DBC}\u44C5\u{23DBD}\u{241A4}\u{2490C}\u{24900}"],
    ["fda1", "\u{23CC9}\u36E5\u3CEB\u{20D32}\u9B83\u{231F9}\u{22491}\u7F8F\u6837\u{26D25}\u{26DA1}\u{26DEB}\u6D96\u6D5C\u6E7C\u6F04\u{2497F}\u{24085}\u{26E72}\u8533\u{26F74}\u51C7\u6C9C\u6E1D\u842E\u{28B21}\u6E2F\u{23E2F}\u7453\u{23F82}\u79CC\u6E4F\u5A91\u{2304B}\u6FF8\u370D\u6F9D\u{23E30}\u6EFA\u{21497}\u{2403D}\u4555\u93F0\u6F44\u6F5C\u3D4E\u6F74\u{29170}\u3D3B\u6F9F\u{24144}\u6FD3\u{24091}\u{24155}\u{24039}\u{23FF0}\u{23FB4}\u{2413F}\u51DF\u{24156}\u{24157}\u{24140}\u{261DD}\u704B\u707E\u70A7\u7081\u70CC\u70D5\u70D6\u70DF\u4104\u3DE8\u71B4\u7196\u{24277}\u712B\u7145\u5A88\u714A\u716E\u5C9C\u{24365}\u714F\u9362\u{242C1}\u712C\u{2445A}\u{24A27}\u{24A22}\u71BA\u{28BE8}\u70BD\u720E"],
    ["fe40", "\u9442\u7215\u5911\u9443\u7224\u9341\u{25605}\u722E\u7240\u{24974}\u68BD\u7255\u7257\u3E55\u{23044}\u680D\u6F3D\u7282\u732A\u732B\u{24823}\u{2882B}\u48ED\u{28804}\u7328\u732E\u73CF\u73AA\u{20C3A}\u{26A2E}\u73C9\u7449\u{241E2}\u{216E7}\u{24A24}\u6623\u36C5\u{249B7}\u{2498D}\u{249FB}\u73F7\u7415\u6903\u{24A26}\u7439\u{205C3}\u3ED7\u745C\u{228AD}\u7460\u{28EB2}\u7447\u73E4\u7476\u83B9\u746C\u3730\u7474\u93F1\u6A2C\u7482\u4953\u{24A8C}"],
    ["fea1", "\u{2415F}\u{24A79}\u{28B8F}\u5B46\u{28C03}\u{2189E}\u74C8\u{21988}\u750E\u74E9\u751E\u{28ED9}\u{21A4B}\u5BD7\u{28EAC}\u9385\u754D\u754A\u7567\u756E\u{24F82}\u3F04\u{24D13}\u758E\u745D\u759E\u75B4\u7602\u762C\u7651\u764F\u766F\u7676\u{263F5}\u7690\u81EF\u37F8\u{26911}\u{2690E}\u76A1\u76A5\u76B7\u76CC\u{26F9F}\u8462\u{2509D}\u{2517D}\u{21E1C}\u771E\u7726\u7740\u64AF\u{25220}\u7758\u{232AC}\u77AF\u{28964}\u{28968}\u{216C1}\u77F4\u7809\u{21376}\u{24A12}\u68CA\u78AF\u78C7\u78D3\u96A5\u792E\u{255E0}\u78D7\u7934\u78B1\u{2760C}\u8FB8\u8884\u{28B2B}\u{26083}\u{2261C}\u7986\u8900\u6902\u7980\u{25857}\u799D\u{27B39}\u793C\u79A9\u6E2A\u{27126}\u3EA8\u79C6\u{2910D}\u79D4"]
  ];
});

// ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/dbcs-data.js
var require_dbcs_data = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    shiftjis: {
      type: "_dbcs",
      table: function() {
        return require_shiftjis();
      },
      encodeAdd: {"\xA5": 92, "\u203E": 126},
      encodeSkipVals: [{from: 60736, to: 63808}]
    },
    csshiftjis: "shiftjis",
    mskanji: "shiftjis",
    sjis: "shiftjis",
    windows31j: "shiftjis",
    ms31j: "shiftjis",
    xsjis: "shiftjis",
    windows932: "shiftjis",
    ms932: "shiftjis",
    "932": "shiftjis",
    cp932: "shiftjis",
    eucjp: {
      type: "_dbcs",
      table: function() {
        return require_eucjp();
      },
      encodeAdd: {"\xA5": 92, "\u203E": 126}
    },
    gb2312: "cp936",
    gb231280: "cp936",
    gb23121980: "cp936",
    csgb2312: "cp936",
    csiso58gb231280: "cp936",
    euccn: "cp936",
    windows936: "cp936",
    ms936: "cp936",
    "936": "cp936",
    cp936: {
      type: "_dbcs",
      table: function() {
        return require_cp936();
      }
    },
    gbk: {
      type: "_dbcs",
      table: function() {
        return require_cp936().concat(require_gbk_added());
      }
    },
    xgbk: "gbk",
    isoir58: "gbk",
    gb18030: {
      type: "_dbcs",
      table: function() {
        return require_cp936().concat(require_gbk_added());
      },
      gb18030: function() {
        return require_gb18030_ranges();
      },
      encodeSkipVals: [128],
      encodeAdd: {"\u20AC": 41699}
    },
    chinese: "gb18030",
    windows949: "cp949",
    ms949: "cp949",
    "949": "cp949",
    cp949: {
      type: "_dbcs",
      table: function() {
        return require_cp949();
      }
    },
    cseuckr: "cp949",
    csksc56011987: "cp949",
    euckr: "cp949",
    isoir149: "cp949",
    korean: "cp949",
    ksc56011987: "cp949",
    ksc56011989: "cp949",
    ksc5601: "cp949",
    windows950: "cp950",
    ms950: "cp950",
    "950": "cp950",
    cp950: {
      type: "_dbcs",
      table: function() {
        return require_cp950();
      }
    },
    big5: "big5hkscs",
    big5hkscs: {
      type: "_dbcs",
      table: function() {
        return require_cp950().concat(require_big5_added());
      },
      encodeSkipVals: [41676]
    },
    cnbig5: "big5hkscs",
    csbig5: "big5hkscs",
    xxbig5: "big5hkscs"
  };
});

// ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/index.js
var require_encodings = __commonJS((exports2, module2) => {
  "use strict";
  var modules = [
    require_internal(),
    require_utf16(),
    require_utf7(),
    require_sbcs_codec(),
    require_sbcs_data(),
    require_sbcs_data_generated(),
    require_dbcs_codec(),
    require_dbcs_data()
  ];
  for (var i = 0; i < modules.length; i++) {
    module2 = modules[i];
    for (enc in module2)
      if (Object.prototype.hasOwnProperty.call(module2, enc))
        exports2[enc] = module2[enc];
  }
  var module2;
  var enc;
});

// ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/lib/streams.js
var require_streams = __commonJS((exports2, module2) => {
  "use strict";
  var Buffer2 = require("buffer").Buffer;
  var Transform = require("stream").Transform;
  module2.exports = function(iconv) {
    iconv.encodeStream = function encodeStream(encoding, options) {
      return new IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
    };
    iconv.decodeStream = function decodeStream(encoding, options) {
      return new IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
    };
    iconv.supportsStreams = true;
    iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
    iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
    iconv._collect = IconvLiteDecoderStream.prototype.collect;
  };
  function IconvLiteEncoderStream(conv, options) {
    this.conv = conv;
    options = options || {};
    options.decodeStrings = false;
    Transform.call(this, options);
  }
  IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
    constructor: {value: IconvLiteEncoderStream}
  });
  IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
    if (typeof chunk != "string")
      return done(new Error("Iconv encoding stream needs strings as its input."));
    try {
      var res = this.conv.write(chunk);
      if (res && res.length)
        this.push(res);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteEncoderStream.prototype._flush = function(done) {
    try {
      var res = this.conv.end();
      if (res && res.length)
        this.push(res);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteEncoderStream.prototype.collect = function(cb) {
    var chunks = [];
    this.on("error", cb);
    this.on("data", function(chunk) {
      chunks.push(chunk);
    });
    this.on("end", function() {
      cb(null, Buffer2.concat(chunks));
    });
    return this;
  };
  function IconvLiteDecoderStream(conv, options) {
    this.conv = conv;
    options = options || {};
    options.encoding = this.encoding = "utf8";
    Transform.call(this, options);
  }
  IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
    constructor: {value: IconvLiteDecoderStream}
  });
  IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
    if (!Buffer2.isBuffer(chunk))
      return done(new Error("Iconv decoding stream needs buffers as its input."));
    try {
      var res = this.conv.write(chunk);
      if (res && res.length)
        this.push(res, this.encoding);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteDecoderStream.prototype._flush = function(done) {
    try {
      var res = this.conv.end();
      if (res && res.length)
        this.push(res, this.encoding);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteDecoderStream.prototype.collect = function(cb) {
    var res = "";
    this.on("error", cb);
    this.on("data", function(chunk) {
      res += chunk;
    });
    this.on("end", function() {
      cb(null, res);
    });
    return this;
  };
});

// ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/lib/extend-node.js
var require_extend_node = __commonJS((exports2, module2) => {
  "use strict";
  var Buffer2 = require("buffer").Buffer;
  module2.exports = function(iconv) {
    var original = void 0;
    iconv.supportsNodeEncodingsExtension = !(Buffer2.from || new Buffer2(0) instanceof Uint8Array);
    iconv.extendNodeEncodings = function extendNodeEncodings() {
      if (original)
        return;
      original = {};
      if (!iconv.supportsNodeEncodingsExtension) {
        console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node");
        console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
        return;
      }
      var nodeNativeEncodings = {
        hex: true,
        utf8: true,
        "utf-8": true,
        ascii: true,
        binary: true,
        base64: true,
        ucs2: true,
        "ucs-2": true,
        utf16le: true,
        "utf-16le": true
      };
      Buffer2.isNativeEncoding = function(enc) {
        return enc && nodeNativeEncodings[enc.toLowerCase()];
      };
      var SlowBuffer = require("buffer").SlowBuffer;
      original.SlowBufferToString = SlowBuffer.prototype.toString;
      SlowBuffer.prototype.toString = function(encoding, start, end) {
        encoding = String(encoding || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding))
          return original.SlowBufferToString.call(this, encoding, start, end);
        if (typeof start == "undefined")
          start = 0;
        if (typeof end == "undefined")
          end = this.length;
        return iconv.decode(this.slice(start, end), encoding);
      };
      original.SlowBufferWrite = SlowBuffer.prototype.write;
      SlowBuffer.prototype.write = function(string, offset, length, encoding) {
        if (isFinite(offset)) {
          if (!isFinite(length)) {
            encoding = length;
            length = void 0;
          }
        } else {
          var swap = encoding;
          encoding = offset;
          offset = length;
          length = swap;
        }
        offset = +offset || 0;
        var remaining = this.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = +length;
          if (length > remaining) {
            length = remaining;
          }
        }
        encoding = String(encoding || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding))
          return original.SlowBufferWrite.call(this, string, offset, length, encoding);
        if (string.length > 0 && (length < 0 || offset < 0))
          throw new RangeError("attempt to write beyond buffer bounds");
        var buf = iconv.encode(string, encoding);
        if (buf.length < length)
          length = buf.length;
        buf.copy(this, offset, 0, length);
        return length;
      };
      original.BufferIsEncoding = Buffer2.isEncoding;
      Buffer2.isEncoding = function(encoding) {
        return Buffer2.isNativeEncoding(encoding) || iconv.encodingExists(encoding);
      };
      original.BufferByteLength = Buffer2.byteLength;
      Buffer2.byteLength = SlowBuffer.byteLength = function(str, encoding) {
        encoding = String(encoding || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding))
          return original.BufferByteLength.call(this, str, encoding);
        return iconv.encode(str, encoding).length;
      };
      original.BufferToString = Buffer2.prototype.toString;
      Buffer2.prototype.toString = function(encoding, start, end) {
        encoding = String(encoding || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding))
          return original.BufferToString.call(this, encoding, start, end);
        if (typeof start == "undefined")
          start = 0;
        if (typeof end == "undefined")
          end = this.length;
        return iconv.decode(this.slice(start, end), encoding);
      };
      original.BufferWrite = Buffer2.prototype.write;
      Buffer2.prototype.write = function(string, offset, length, encoding) {
        var _offset = offset, _length = length, _encoding = encoding;
        if (isFinite(offset)) {
          if (!isFinite(length)) {
            encoding = length;
            length = void 0;
          }
        } else {
          var swap = encoding;
          encoding = offset;
          offset = length;
          length = swap;
        }
        encoding = String(encoding || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding))
          return original.BufferWrite.call(this, string, _offset, _length, _encoding);
        offset = +offset || 0;
        var remaining = this.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = +length;
          if (length > remaining) {
            length = remaining;
          }
        }
        if (string.length > 0 && (length < 0 || offset < 0))
          throw new RangeError("attempt to write beyond buffer bounds");
        var buf = iconv.encode(string, encoding);
        if (buf.length < length)
          length = buf.length;
        buf.copy(this, offset, 0, length);
        return length;
      };
      if (iconv.supportsStreams) {
        var Readable = require("stream").Readable;
        original.ReadableSetEncoding = Readable.prototype.setEncoding;
        Readable.prototype.setEncoding = function setEncoding(enc, options) {
          this._readableState.decoder = iconv.getDecoder(enc, options);
          this._readableState.encoding = enc;
        };
        Readable.prototype.collect = iconv._collect;
      }
    };
    iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {
      if (!iconv.supportsNodeEncodingsExtension)
        return;
      if (!original)
        throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.");
      delete Buffer2.isNativeEncoding;
      var SlowBuffer = require("buffer").SlowBuffer;
      SlowBuffer.prototype.toString = original.SlowBufferToString;
      SlowBuffer.prototype.write = original.SlowBufferWrite;
      Buffer2.isEncoding = original.BufferIsEncoding;
      Buffer2.byteLength = original.BufferByteLength;
      Buffer2.prototype.toString = original.BufferToString;
      Buffer2.prototype.write = original.BufferWrite;
      if (iconv.supportsStreams) {
        var Readable = require("stream").Readable;
        Readable.prototype.setEncoding = original.ReadableSetEncoding;
        delete Readable.prototype.collect;
      }
      original = void 0;
    };
  };
});

// ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/lib/index.js
var require_lib8 = __commonJS((exports2, module2) => {
  "use strict";
  var Buffer2 = require_safer().Buffer;
  var bomHandling = require_bom_handling();
  var iconv = module2.exports;
  iconv.encodings = null;
  iconv.defaultCharUnicode = "\uFFFD";
  iconv.defaultCharSingleByte = "?";
  iconv.encode = function encode(str, encoding, options) {
    str = "" + (str || "");
    var encoder = iconv.getEncoder(encoding, options);
    var res = encoder.write(str);
    var trail = encoder.end();
    return trail && trail.length > 0 ? Buffer2.concat([res, trail]) : res;
  };
  iconv.decode = function decode(buf, encoding, options) {
    if (typeof buf === "string") {
      if (!iconv.skipDecodeWarning) {
        console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
        iconv.skipDecodeWarning = true;
      }
      buf = Buffer2.from("" + (buf || ""), "binary");
    }
    var decoder = iconv.getDecoder(encoding, options);
    var res = decoder.write(buf);
    var trail = decoder.end();
    return trail ? res + trail : res;
  };
  iconv.encodingExists = function encodingExists(enc) {
    try {
      iconv.getCodec(enc);
      return true;
    } catch (e) {
      return false;
    }
  };
  iconv.toEncoding = iconv.encode;
  iconv.fromEncoding = iconv.decode;
  iconv._codecDataCache = {};
  iconv.getCodec = function getCodec(encoding) {
    if (!iconv.encodings)
      iconv.encodings = require_encodings();
    var enc = iconv._canonicalizeEncoding(encoding);
    var codecOptions = {};
    while (true) {
      var codec = iconv._codecDataCache[enc];
      if (codec)
        return codec;
      var codecDef = iconv.encodings[enc];
      switch (typeof codecDef) {
        case "string":
          enc = codecDef;
          break;
        case "object":
          for (var key in codecDef)
            codecOptions[key] = codecDef[key];
          if (!codecOptions.encodingName)
            codecOptions.encodingName = enc;
          enc = codecDef.type;
          break;
        case "function":
          if (!codecOptions.encodingName)
            codecOptions.encodingName = enc;
          codec = new codecDef(codecOptions, iconv);
          iconv._codecDataCache[codecOptions.encodingName] = codec;
          return codec;
        default:
          throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
      }
    }
  };
  iconv._canonicalizeEncoding = function(encoding) {
    return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
  };
  iconv.getEncoder = function getEncoder(encoding, options) {
    var codec = iconv.getCodec(encoding), encoder = new codec.encoder(options, codec);
    if (codec.bomAware && options && options.addBOM)
      encoder = new bomHandling.PrependBOM(encoder, options);
    return encoder;
  };
  iconv.getDecoder = function getDecoder(encoding, options) {
    var codec = iconv.getCodec(encoding), decoder = new codec.decoder(options, codec);
    if (codec.bomAware && !(options && options.stripBOM === false))
      decoder = new bomHandling.StripBOM(decoder, options);
    return decoder;
  };
  var nodeVer = typeof process !== "undefined" && process.versions && process.versions.node;
  if (nodeVer) {
    nodeVerArr = nodeVer.split(".").map(Number);
    if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
      require_streams()(iconv);
    }
    require_extend_node()(iconv);
  }
  var nodeVerArr;
  if (false) {
    console.error("iconv-lite warning: javascript files use encoding different from utf-8. See https://github.com/ashtuchkin/iconv-lite/wiki/Javascript-source-file-encodings for more info.");
  }
});

// ../../node_modules/.pnpm/unpipe@1.0.0/node_modules/unpipe/index.js
var require_unpipe = __commonJS((exports2, module2) => {
  /*!
   * unpipe
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  module2.exports = unpipe;
  function hasPipeDataListeners(stream) {
    var listeners = stream.listeners("data");
    for (var i = 0; i < listeners.length; i++) {
      if (listeners[i].name === "ondata") {
        return true;
      }
    }
    return false;
  }
  function unpipe(stream) {
    if (!stream) {
      throw new TypeError("argument stream is required");
    }
    if (typeof stream.unpipe === "function") {
      stream.unpipe();
      return;
    }
    if (!hasPipeDataListeners(stream)) {
      return;
    }
    var listener;
    var listeners = stream.listeners("close");
    for (var i = 0; i < listeners.length; i++) {
      listener = listeners[i];
      if (listener.name !== "cleanup" && listener.name !== "onclose") {
        continue;
      }
      listener.call(stream);
    }
  }
});

// ../../node_modules/.pnpm/raw-body@2.4.0/node_modules/raw-body/index.js
var require_raw_body = __commonJS((exports2, module2) => {
  /*!
   * raw-body
   * Copyright(c) 2013-2014 Jonathan Ong
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var bytes = require_bytes();
  var createError = require_http_errors();
  var iconv = require_lib8();
  var unpipe = require_unpipe();
  module2.exports = getRawBody;
  var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;
  function getDecoder(encoding) {
    if (!encoding)
      return null;
    try {
      return iconv.getDecoder(encoding);
    } catch (e) {
      if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message))
        throw e;
      throw createError(415, "specified encoding unsupported", {
        encoding,
        type: "encoding.unsupported"
      });
    }
  }
  function getRawBody(stream, options, callback) {
    var done = callback;
    var opts = options || {};
    if (options === true || typeof options === "string") {
      opts = {
        encoding: options
      };
    }
    if (typeof options === "function") {
      done = options;
      opts = {};
    }
    if (done !== void 0 && typeof done !== "function") {
      throw new TypeError("argument callback must be a function");
    }
    if (!done && !global.Promise) {
      throw new TypeError("argument callback is required");
    }
    var encoding = opts.encoding !== true ? opts.encoding : "utf-8";
    var limit = bytes.parse(opts.limit);
    var length = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;
    if (done) {
      return readStream(stream, encoding, length, limit, done);
    }
    return new Promise(function executor(resolve, reject) {
      readStream(stream, encoding, length, limit, function onRead(err, buf) {
        if (err)
          return reject(err);
        resolve(buf);
      });
    });
  }
  function halt(stream) {
    unpipe(stream);
    if (typeof stream.pause === "function") {
      stream.pause();
    }
  }
  function readStream(stream, encoding, length, limit, callback) {
    var complete = false;
    var sync2 = true;
    if (limit !== null && length !== null && length > limit) {
      return done(createError(413, "request entity too large", {
        expected: length,
        length,
        limit,
        type: "entity.too.large"
      }));
    }
    var state = stream._readableState;
    if (stream._decoder || state && (state.encoding || state.decoder)) {
      return done(createError(500, "stream encoding should not be set", {
        type: "stream.encoding.set"
      }));
    }
    var received = 0;
    var decoder;
    try {
      decoder = getDecoder(encoding);
    } catch (err) {
      return done(err);
    }
    var buffer = decoder ? "" : [];
    stream.on("aborted", onAborted);
    stream.on("close", cleanup2);
    stream.on("data", onData);
    stream.on("end", onEnd);
    stream.on("error", onEnd);
    sync2 = false;
    function done() {
      var args2 = new Array(arguments.length);
      for (var i = 0; i < args2.length; i++) {
        args2[i] = arguments[i];
      }
      complete = true;
      if (sync2) {
        process.nextTick(invokeCallback);
      } else {
        invokeCallback();
      }
      function invokeCallback() {
        cleanup2();
        if (args2[0]) {
          halt(stream);
        }
        callback.apply(null, args2);
      }
    }
    function onAborted() {
      if (complete)
        return;
      done(createError(400, "request aborted", {
        code: "ECONNABORTED",
        expected: length,
        length,
        received,
        type: "request.aborted"
      }));
    }
    function onData(chunk) {
      if (complete)
        return;
      received += chunk.length;
      if (limit !== null && received > limit) {
        done(createError(413, "request entity too large", {
          limit,
          received,
          type: "entity.too.large"
        }));
      } else if (decoder) {
        buffer += decoder.write(chunk);
      } else {
        buffer.push(chunk);
      }
    }
    function onEnd(err) {
      if (complete)
        return;
      if (err)
        return done(err);
      if (length !== null && received !== length) {
        done(createError(400, "request size did not match content length", {
          expected: length,
          length,
          received,
          type: "request.size.invalid"
        }));
      } else {
        var string = decoder ? buffer + (decoder.end() || "") : Buffer.concat(buffer);
        done(null, string);
      }
    }
    function cleanup2() {
      buffer = null;
      stream.removeListener("aborted", onAborted);
      stream.removeListener("data", onData);
      stream.removeListener("end", onEnd);
      stream.removeListener("error", onEnd);
      stream.removeListener("close", cleanup2);
    }
  }
});

// ../../node_modules/.pnpm/ee-first@1.1.1/node_modules/ee-first/index.js
var require_ee_first = __commonJS((exports2, module2) => {
  /*!
   * ee-first
   * Copyright(c) 2014 Jonathan Ong
   * MIT Licensed
   */
  "use strict";
  module2.exports = first;
  function first(stuff, done) {
    if (!Array.isArray(stuff))
      throw new TypeError("arg must be an array of [ee, events...] arrays");
    var cleanups = [];
    for (var i = 0; i < stuff.length; i++) {
      var arr = stuff[i];
      if (!Array.isArray(arr) || arr.length < 2)
        throw new TypeError("each array member must be [ee, events...]");
      var ee = arr[0];
      for (var j = 1; j < arr.length; j++) {
        var event = arr[j];
        var fn = listener(event, callback);
        ee.on(event, fn);
        cleanups.push({
          ee,
          event,
          fn
        });
      }
    }
    function callback() {
      cleanup2();
      done.apply(null, arguments);
    }
    function cleanup2() {
      var x;
      for (var i2 = 0; i2 < cleanups.length; i2++) {
        x = cleanups[i2];
        x.ee.removeListener(x.event, x.fn);
      }
    }
    function thunk(fn2) {
      done = fn2;
    }
    thunk.cancel = cleanup2;
    return thunk;
  }
  function listener(event, done) {
    return function onevent(arg1) {
      var args2 = new Array(arguments.length);
      var ee = this;
      var err = event === "error" ? arg1 : null;
      for (var i = 0; i < args2.length; i++) {
        args2[i] = arguments[i];
      }
      done(err, ee, event, args2);
    };
  }
});

// ../../node_modules/.pnpm/on-finished@2.3.0/node_modules/on-finished/index.js
var require_on_finished = __commonJS((exports2, module2) => {
  /*!
   * on-finished
   * Copyright(c) 2013 Jonathan Ong
   * Copyright(c) 2014 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  module2.exports = onFinished;
  module2.exports.isFinished = isFinished;
  var first = require_ee_first();
  var defer = typeof setImmediate === "function" ? setImmediate : function(fn) {
    process.nextTick(fn.bind.apply(fn, arguments));
  };
  function onFinished(msg, listener) {
    if (isFinished(msg) !== false) {
      defer(listener, null, msg);
      return msg;
    }
    attachListener(msg, listener);
    return msg;
  }
  function isFinished(msg) {
    var socket = msg.socket;
    if (typeof msg.finished === "boolean") {
      return Boolean(msg.finished || socket && !socket.writable);
    }
    if (typeof msg.complete === "boolean") {
      return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
    }
    return void 0;
  }
  function attachFinishedListener(msg, callback) {
    var eeMsg;
    var eeSocket;
    var finished = false;
    function onFinish(error) {
      eeMsg.cancel();
      eeSocket.cancel();
      finished = true;
      callback(error);
    }
    eeMsg = eeSocket = first([[msg, "end", "finish"]], onFinish);
    function onSocket(socket) {
      msg.removeListener("socket", onSocket);
      if (finished)
        return;
      if (eeMsg !== eeSocket)
        return;
      eeSocket = first([[socket, "error", "close"]], onFinish);
    }
    if (msg.socket) {
      onSocket(msg.socket);
      return;
    }
    msg.on("socket", onSocket);
    if (msg.socket === void 0) {
      patchAssignSocket(msg, onSocket);
    }
  }
  function attachListener(msg, listener) {
    var attached = msg.__onFinished;
    if (!attached || !attached.queue) {
      attached = msg.__onFinished = createListener(msg);
      attachFinishedListener(msg, attached);
    }
    attached.queue.push(listener);
  }
  function createListener(msg) {
    function listener(err) {
      if (msg.__onFinished === listener)
        msg.__onFinished = null;
      if (!listener.queue)
        return;
      var queue = listener.queue;
      listener.queue = null;
      for (var i = 0; i < queue.length; i++) {
        queue[i](err, msg);
      }
    }
    listener.queue = [];
    return listener;
  }
  function patchAssignSocket(res, callback) {
    var assignSocket = res.assignSocket;
    if (typeof assignSocket !== "function")
      return;
    res.assignSocket = function _assignSocket(socket) {
      assignSocket.call(this, socket);
      callback(socket);
    };
  }
});

// ../../node_modules/.pnpm/body-parser@1.19.0/node_modules/body-parser/lib/read.js
var require_read = __commonJS((exports2, module2) => {
  /*!
   * body-parser
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var createError = require_http_errors();
  var getBody = require_raw_body();
  var iconv = require_lib8();
  var onFinished = require_on_finished();
  var zlib = require("zlib");
  module2.exports = read;
  function read(req, res, next, parse2, debug3, options) {
    var length;
    var opts = options;
    var stream;
    req._body = true;
    var encoding = opts.encoding !== null ? opts.encoding : null;
    var verify = opts.verify;
    try {
      stream = contentstream(req, debug3, opts.inflate);
      length = stream.length;
      stream.length = void 0;
    } catch (err) {
      return next(err);
    }
    opts.length = length;
    opts.encoding = verify ? null : encoding;
    if (opts.encoding === null && encoding !== null && !iconv.encodingExists(encoding)) {
      return next(createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
        charset: encoding.toLowerCase(),
        type: "charset.unsupported"
      }));
    }
    debug3("read body");
    getBody(stream, opts, function(error, body) {
      if (error) {
        var _error;
        if (error.type === "encoding.unsupported") {
          _error = createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
            charset: encoding.toLowerCase(),
            type: "charset.unsupported"
          });
        } else {
          _error = createError(400, error);
        }
        stream.resume();
        onFinished(req, function onfinished() {
          next(createError(400, _error));
        });
        return;
      }
      if (verify) {
        try {
          debug3("verify body");
          verify(req, res, body, encoding);
        } catch (err) {
          next(createError(403, err, {
            body,
            type: err.type || "entity.verify.failed"
          }));
          return;
        }
      }
      var str = body;
      try {
        debug3("parse body");
        str = typeof body !== "string" && encoding !== null ? iconv.decode(body, encoding) : body;
        req.body = parse2(str);
      } catch (err) {
        next(createError(400, err, {
          body: str,
          type: err.type || "entity.parse.failed"
        }));
        return;
      }
      next();
    });
  }
  function contentstream(req, debug3, inflate) {
    var encoding = (req.headers["content-encoding"] || "identity").toLowerCase();
    var length = req.headers["content-length"];
    var stream;
    debug3('content-encoding "%s"', encoding);
    if (inflate === false && encoding !== "identity") {
      throw createError(415, "content encoding unsupported", {
        encoding,
        type: "encoding.unsupported"
      });
    }
    switch (encoding) {
      case "deflate":
        stream = zlib.createInflate();
        debug3("inflate body");
        req.pipe(stream);
        break;
      case "gzip":
        stream = zlib.createGunzip();
        debug3("gunzip body");
        req.pipe(stream);
        break;
      case "identity":
        stream = req;
        stream.length = length;
        break;
      default:
        throw createError(415, 'unsupported content encoding "' + encoding + '"', {
          encoding,
          type: "encoding.unsupported"
        });
    }
    return stream;
  }
});

// ../../node_modules/.pnpm/media-typer@0.3.0/node_modules/media-typer/index.js
var require_media_typer = __commonJS((exports2) => {
  /*!
   * media-typer
   * Copyright(c) 2014 Douglas Christopher Wilson
   * MIT Licensed
   */
  var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
  var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/;
  var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/;
  var qescRegExp = /\\([\u0000-\u007f])/g;
  var quoteRegExp = /([\\"])/g;
  var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
  var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
  var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
  exports2.format = format10;
  exports2.parse = parse2;
  function format10(obj) {
    if (!obj || typeof obj !== "object") {
      throw new TypeError("argument obj is required");
    }
    var parameters = obj.parameters;
    var subtype = obj.subtype;
    var suffix = obj.suffix;
    var type = obj.type;
    if (!type || !typeNameRegExp.test(type)) {
      throw new TypeError("invalid type");
    }
    if (!subtype || !subtypeNameRegExp.test(subtype)) {
      throw new TypeError("invalid subtype");
    }
    var string = type + "/" + subtype;
    if (suffix) {
      if (!typeNameRegExp.test(suffix)) {
        throw new TypeError("invalid suffix");
      }
      string += "+" + suffix;
    }
    if (parameters && typeof parameters === "object") {
      var param;
      var params = Object.keys(parameters).sort();
      for (var i = 0; i < params.length; i++) {
        param = params[i];
        if (!tokenRegExp.test(param)) {
          throw new TypeError("invalid parameter name");
        }
        string += "; " + param + "=" + qstring(parameters[param]);
      }
    }
    return string;
  }
  function parse2(string) {
    if (!string) {
      throw new TypeError("argument string is required");
    }
    if (typeof string === "object") {
      string = getcontenttype(string);
    }
    if (typeof string !== "string") {
      throw new TypeError("argument string is required to be a string");
    }
    var index = string.indexOf(";");
    var type = index !== -1 ? string.substr(0, index) : string;
    var key;
    var match;
    var obj = splitType(type);
    var params = {};
    var value;
    paramRegExp.lastIndex = index;
    while (match = paramRegExp.exec(string)) {
      if (match.index !== index) {
        throw new TypeError("invalid parameter format");
      }
      index += match[0].length;
      key = match[1].toLowerCase();
      value = match[2];
      if (value[0] === '"') {
        value = value.substr(1, value.length - 2).replace(qescRegExp, "$1");
      }
      params[key] = value;
    }
    if (index !== -1 && index !== string.length) {
      throw new TypeError("invalid parameter format");
    }
    obj.parameters = params;
    return obj;
  }
  function getcontenttype(obj) {
    if (typeof obj.getHeader === "function") {
      return obj.getHeader("content-type");
    }
    if (typeof obj.headers === "object") {
      return obj.headers && obj.headers["content-type"];
    }
  }
  function qstring(val) {
    var str = String(val);
    if (tokenRegExp.test(str)) {
      return str;
    }
    if (str.length > 0 && !textRegExp.test(str)) {
      throw new TypeError("invalid parameter value");
    }
    return '"' + str.replace(quoteRegExp, "\\$1") + '"';
  }
  function splitType(string) {
    var match = typeRegExp.exec(string.toLowerCase());
    if (!match) {
      throw new TypeError("invalid media type");
    }
    var type = match[1];
    var subtype = match[2];
    var suffix;
    var index = subtype.lastIndexOf("+");
    if (index !== -1) {
      suffix = subtype.substr(index + 1);
      subtype = subtype.substr(0, index);
    }
    var obj = {
      type,
      subtype,
      suffix
    };
    return obj;
  }
});

// ../../node_modules/.pnpm/mime-db@1.49.0/node_modules/mime-db/db.json
var require_db = __commonJS((exports2, module2) => {
  module2.exports = {
    "application/1d-interleaved-parityfec": {
      source: "iana"
    },
    "application/3gpdash-qoe-report+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/3gpp-ims+xml": {
      source: "iana",
      compressible: true
    },
    "application/3gpphal+json": {
      source: "iana",
      compressible: true
    },
    "application/3gpphalforms+json": {
      source: "iana",
      compressible: true
    },
    "application/a2l": {
      source: "iana"
    },
    "application/activemessage": {
      source: "iana"
    },
    "application/activity+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-directory+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcost+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcostparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointprop+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointpropparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-error+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamcontrol+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamparams+json": {
      source: "iana",
      compressible: true
    },
    "application/aml": {
      source: "iana"
    },
    "application/andrew-inset": {
      source: "iana",
      extensions: ["ez"]
    },
    "application/applefile": {
      source: "iana"
    },
    "application/applixware": {
      source: "apache",
      extensions: ["aw"]
    },
    "application/atf": {
      source: "iana"
    },
    "application/atfx": {
      source: "iana"
    },
    "application/atom+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atom"]
    },
    "application/atomcat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomcat"]
    },
    "application/atomdeleted+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomdeleted"]
    },
    "application/atomicmail": {
      source: "iana"
    },
    "application/atomsvc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomsvc"]
    },
    "application/atsc-dwd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dwd"]
    },
    "application/atsc-dynamic-event-message": {
      source: "iana"
    },
    "application/atsc-held+xml": {
      source: "iana",
      compressible: true,
      extensions: ["held"]
    },
    "application/atsc-rdt+json": {
      source: "iana",
      compressible: true
    },
    "application/atsc-rsat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsat"]
    },
    "application/atxml": {
      source: "iana"
    },
    "application/auth-policy+xml": {
      source: "iana",
      compressible: true
    },
    "application/bacnet-xdd+zip": {
      source: "iana",
      compressible: false
    },
    "application/batch-smtp": {
      source: "iana"
    },
    "application/bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/beep+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/calendar+json": {
      source: "iana",
      compressible: true
    },
    "application/calendar+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xcs"]
    },
    "application/call-completion": {
      source: "iana"
    },
    "application/cals-1840": {
      source: "iana"
    },
    "application/captive+json": {
      source: "iana",
      compressible: true
    },
    "application/cbor": {
      source: "iana"
    },
    "application/cbor-seq": {
      source: "iana"
    },
    "application/cccex": {
      source: "iana"
    },
    "application/ccmp+xml": {
      source: "iana",
      compressible: true
    },
    "application/ccxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ccxml"]
    },
    "application/cdfx+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdfx"]
    },
    "application/cdmi-capability": {
      source: "iana",
      extensions: ["cdmia"]
    },
    "application/cdmi-container": {
      source: "iana",
      extensions: ["cdmic"]
    },
    "application/cdmi-domain": {
      source: "iana",
      extensions: ["cdmid"]
    },
    "application/cdmi-object": {
      source: "iana",
      extensions: ["cdmio"]
    },
    "application/cdmi-queue": {
      source: "iana",
      extensions: ["cdmiq"]
    },
    "application/cdni": {
      source: "iana"
    },
    "application/cea": {
      source: "iana"
    },
    "application/cea-2018+xml": {
      source: "iana",
      compressible: true
    },
    "application/cellml+xml": {
      source: "iana",
      compressible: true
    },
    "application/cfw": {
      source: "iana"
    },
    "application/clr": {
      source: "iana"
    },
    "application/clue+xml": {
      source: "iana",
      compressible: true
    },
    "application/clue_info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cms": {
      source: "iana"
    },
    "application/cnrp+xml": {
      source: "iana",
      compressible: true
    },
    "application/coap-group+json": {
      source: "iana",
      compressible: true
    },
    "application/coap-payload": {
      source: "iana"
    },
    "application/commonground": {
      source: "iana"
    },
    "application/conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cose": {
      source: "iana"
    },
    "application/cose-key": {
      source: "iana"
    },
    "application/cose-key-set": {
      source: "iana"
    },
    "application/cpl+xml": {
      source: "iana",
      compressible: true
    },
    "application/csrattrs": {
      source: "iana"
    },
    "application/csta+xml": {
      source: "iana",
      compressible: true
    },
    "application/cstadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/csvm+json": {
      source: "iana",
      compressible: true
    },
    "application/cu-seeme": {
      source: "apache",
      extensions: ["cu"]
    },
    "application/cwt": {
      source: "iana"
    },
    "application/cybercash": {
      source: "iana"
    },
    "application/dart": {
      compressible: true
    },
    "application/dash+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpd"]
    },
    "application/dashdelta": {
      source: "iana"
    },
    "application/davmount+xml": {
      source: "iana",
      compressible: true,
      extensions: ["davmount"]
    },
    "application/dca-rft": {
      source: "iana"
    },
    "application/dcd": {
      source: "iana"
    },
    "application/dec-dx": {
      source: "iana"
    },
    "application/dialog-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/dicom": {
      source: "iana"
    },
    "application/dicom+json": {
      source: "iana",
      compressible: true
    },
    "application/dicom+xml": {
      source: "iana",
      compressible: true
    },
    "application/dii": {
      source: "iana"
    },
    "application/dit": {
      source: "iana"
    },
    "application/dns": {
      source: "iana"
    },
    "application/dns+json": {
      source: "iana",
      compressible: true
    },
    "application/dns-message": {
      source: "iana"
    },
    "application/docbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dbk"]
    },
    "application/dots+cbor": {
      source: "iana"
    },
    "application/dskpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/dssc+der": {
      source: "iana",
      extensions: ["dssc"]
    },
    "application/dssc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdssc"]
    },
    "application/dvcs": {
      source: "iana"
    },
    "application/ecmascript": {
      source: "iana",
      compressible: true,
      extensions: ["es", "ecma"]
    },
    "application/edi-consent": {
      source: "iana"
    },
    "application/edi-x12": {
      source: "iana",
      compressible: false
    },
    "application/edifact": {
      source: "iana",
      compressible: false
    },
    "application/efi": {
      source: "iana"
    },
    "application/elm+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/elm+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.cap+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/emergencycalldata.comment+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.control+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.deviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.ecall.msd": {
      source: "iana"
    },
    "application/emergencycalldata.providerinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.serviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.subscriberinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.veds+xml": {
      source: "iana",
      compressible: true
    },
    "application/emma+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emma"]
    },
    "application/emotionml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emotionml"]
    },
    "application/encaprtp": {
      source: "iana"
    },
    "application/epp+xml": {
      source: "iana",
      compressible: true
    },
    "application/epub+zip": {
      source: "iana",
      compressible: false,
      extensions: ["epub"]
    },
    "application/eshop": {
      source: "iana"
    },
    "application/exi": {
      source: "iana",
      extensions: ["exi"]
    },
    "application/expect-ct-report+json": {
      source: "iana",
      compressible: true
    },
    "application/fastinfoset": {
      source: "iana"
    },
    "application/fastsoap": {
      source: "iana"
    },
    "application/fdt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fdt"]
    },
    "application/fhir+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fhir+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fido.trusted-apps+json": {
      compressible: true
    },
    "application/fits": {
      source: "iana"
    },
    "application/flexfec": {
      source: "iana"
    },
    "application/font-sfnt": {
      source: "iana"
    },
    "application/font-tdpfr": {
      source: "iana",
      extensions: ["pfr"]
    },
    "application/font-woff": {
      source: "iana",
      compressible: false
    },
    "application/framework-attributes+xml": {
      source: "iana",
      compressible: true
    },
    "application/geo+json": {
      source: "iana",
      compressible: true,
      extensions: ["geojson"]
    },
    "application/geo+json-seq": {
      source: "iana"
    },
    "application/geopackage+sqlite3": {
      source: "iana"
    },
    "application/geoxacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/gltf-buffer": {
      source: "iana"
    },
    "application/gml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["gml"]
    },
    "application/gpx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["gpx"]
    },
    "application/gxf": {
      source: "apache",
      extensions: ["gxf"]
    },
    "application/gzip": {
      source: "iana",
      compressible: false,
      extensions: ["gz"]
    },
    "application/h224": {
      source: "iana"
    },
    "application/held+xml": {
      source: "iana",
      compressible: true
    },
    "application/hjson": {
      extensions: ["hjson"]
    },
    "application/http": {
      source: "iana"
    },
    "application/hyperstudio": {
      source: "iana",
      extensions: ["stk"]
    },
    "application/ibe-key-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pkg-reply+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pp-data": {
      source: "iana"
    },
    "application/iges": {
      source: "iana"
    },
    "application/im-iscomposing+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/index": {
      source: "iana"
    },
    "application/index.cmd": {
      source: "iana"
    },
    "application/index.obj": {
      source: "iana"
    },
    "application/index.response": {
      source: "iana"
    },
    "application/index.vnd": {
      source: "iana"
    },
    "application/inkml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ink", "inkml"]
    },
    "application/iotp": {
      source: "iana"
    },
    "application/ipfix": {
      source: "iana",
      extensions: ["ipfix"]
    },
    "application/ipp": {
      source: "iana"
    },
    "application/isup": {
      source: "iana"
    },
    "application/its+xml": {
      source: "iana",
      compressible: true,
      extensions: ["its"]
    },
    "application/java-archive": {
      source: "apache",
      compressible: false,
      extensions: ["jar", "war", "ear"]
    },
    "application/java-serialized-object": {
      source: "apache",
      compressible: false,
      extensions: ["ser"]
    },
    "application/java-vm": {
      source: "apache",
      compressible: false,
      extensions: ["class"]
    },
    "application/javascript": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["js", "mjs"]
    },
    "application/jf2feed+json": {
      source: "iana",
      compressible: true
    },
    "application/jose": {
      source: "iana"
    },
    "application/jose+json": {
      source: "iana",
      compressible: true
    },
    "application/jrd+json": {
      source: "iana",
      compressible: true
    },
    "application/jscalendar+json": {
      source: "iana",
      compressible: true
    },
    "application/json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["json", "map"]
    },
    "application/json-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/json-seq": {
      source: "iana"
    },
    "application/json5": {
      extensions: ["json5"]
    },
    "application/jsonml+json": {
      source: "apache",
      compressible: true,
      extensions: ["jsonml"]
    },
    "application/jwk+json": {
      source: "iana",
      compressible: true
    },
    "application/jwk-set+json": {
      source: "iana",
      compressible: true
    },
    "application/jwt": {
      source: "iana"
    },
    "application/kpml-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/kpml-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/ld+json": {
      source: "iana",
      compressible: true,
      extensions: ["jsonld"]
    },
    "application/lgr+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lgr"]
    },
    "application/link-format": {
      source: "iana"
    },
    "application/load-control+xml": {
      source: "iana",
      compressible: true
    },
    "application/lost+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lostxml"]
    },
    "application/lostsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/lpf+zip": {
      source: "iana",
      compressible: false
    },
    "application/lxf": {
      source: "iana"
    },
    "application/mac-binhex40": {
      source: "iana",
      extensions: ["hqx"]
    },
    "application/mac-compactpro": {
      source: "apache",
      extensions: ["cpt"]
    },
    "application/macwriteii": {
      source: "iana"
    },
    "application/mads+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mads"]
    },
    "application/manifest+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["webmanifest"]
    },
    "application/marc": {
      source: "iana",
      extensions: ["mrc"]
    },
    "application/marcxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mrcx"]
    },
    "application/mathematica": {
      source: "iana",
      extensions: ["ma", "nb", "mb"]
    },
    "application/mathml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mathml"]
    },
    "application/mathml-content+xml": {
      source: "iana",
      compressible: true
    },
    "application/mathml-presentation+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-associated-procedure-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-deregister+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-envelope+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-protection-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-reception-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-schedule+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-user-service-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbox": {
      source: "iana",
      extensions: ["mbox"]
    },
    "application/media-policy-dataset+xml": {
      source: "iana",
      compressible: true
    },
    "application/media_control+xml": {
      source: "iana",
      compressible: true
    },
    "application/mediaservercontrol+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mscml"]
    },
    "application/merge-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/metalink+xml": {
      source: "apache",
      compressible: true,
      extensions: ["metalink"]
    },
    "application/metalink4+xml": {
      source: "iana",
      compressible: true,
      extensions: ["meta4"]
    },
    "application/mets+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mets"]
    },
    "application/mf4": {
      source: "iana"
    },
    "application/mikey": {
      source: "iana"
    },
    "application/mipc": {
      source: "iana"
    },
    "application/missing-blocks+cbor-seq": {
      source: "iana"
    },
    "application/mmt-aei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["maei"]
    },
    "application/mmt-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musd"]
    },
    "application/mods+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mods"]
    },
    "application/moss-keys": {
      source: "iana"
    },
    "application/moss-signature": {
      source: "iana"
    },
    "application/mosskey-data": {
      source: "iana"
    },
    "application/mosskey-request": {
      source: "iana"
    },
    "application/mp21": {
      source: "iana",
      extensions: ["m21", "mp21"]
    },
    "application/mp4": {
      source: "iana",
      extensions: ["mp4s", "m4p"]
    },
    "application/mpeg4-generic": {
      source: "iana"
    },
    "application/mpeg4-iod": {
      source: "iana"
    },
    "application/mpeg4-iod-xmt": {
      source: "iana"
    },
    "application/mrb-consumer+xml": {
      source: "iana",
      compressible: true
    },
    "application/mrb-publish+xml": {
      source: "iana",
      compressible: true
    },
    "application/msc-ivr+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msc-mixer+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msword": {
      source: "iana",
      compressible: false,
      extensions: ["doc", "dot"]
    },
    "application/mud+json": {
      source: "iana",
      compressible: true
    },
    "application/multipart-core": {
      source: "iana"
    },
    "application/mxf": {
      source: "iana",
      extensions: ["mxf"]
    },
    "application/n-quads": {
      source: "iana",
      extensions: ["nq"]
    },
    "application/n-triples": {
      source: "iana",
      extensions: ["nt"]
    },
    "application/nasdata": {
      source: "iana"
    },
    "application/news-checkgroups": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-groupinfo": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-transmission": {
      source: "iana"
    },
    "application/nlsml+xml": {
      source: "iana",
      compressible: true
    },
    "application/node": {
      source: "iana",
      extensions: ["cjs"]
    },
    "application/nss": {
      source: "iana"
    },
    "application/oauth-authz-req+jwt": {
      source: "iana"
    },
    "application/ocsp-request": {
      source: "iana"
    },
    "application/ocsp-response": {
      source: "iana"
    },
    "application/octet-stream": {
      source: "iana",
      compressible: false,
      extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
    },
    "application/oda": {
      source: "iana",
      extensions: ["oda"]
    },
    "application/odm+xml": {
      source: "iana",
      compressible: true
    },
    "application/odx": {
      source: "iana"
    },
    "application/oebps-package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["opf"]
    },
    "application/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogx"]
    },
    "application/omdoc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["omdoc"]
    },
    "application/onenote": {
      source: "apache",
      extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
    },
    "application/opc-nodeset+xml": {
      source: "iana",
      compressible: true
    },
    "application/oscore": {
      source: "iana"
    },
    "application/oxps": {
      source: "iana",
      extensions: ["oxps"]
    },
    "application/p21+zip": {
      source: "iana",
      compressible: false
    },
    "application/p2p-overlay+xml": {
      source: "iana",
      compressible: true,
      extensions: ["relo"]
    },
    "application/parityfec": {
      source: "iana"
    },
    "application/passport": {
      source: "iana"
    },
    "application/patch-ops-error+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xer"]
    },
    "application/pdf": {
      source: "iana",
      compressible: false,
      extensions: ["pdf"]
    },
    "application/pdx": {
      source: "iana"
    },
    "application/pem-certificate-chain": {
      source: "iana"
    },
    "application/pgp-encrypted": {
      source: "iana",
      compressible: false,
      extensions: ["pgp"]
    },
    "application/pgp-keys": {
      source: "iana"
    },
    "application/pgp-signature": {
      source: "iana",
      extensions: ["asc", "sig"]
    },
    "application/pics-rules": {
      source: "apache",
      extensions: ["prf"]
    },
    "application/pidf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pidf-diff+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pkcs10": {
      source: "iana",
      extensions: ["p10"]
    },
    "application/pkcs12": {
      source: "iana"
    },
    "application/pkcs7-mime": {
      source: "iana",
      extensions: ["p7m", "p7c"]
    },
    "application/pkcs7-signature": {
      source: "iana",
      extensions: ["p7s"]
    },
    "application/pkcs8": {
      source: "iana",
      extensions: ["p8"]
    },
    "application/pkcs8-encrypted": {
      source: "iana"
    },
    "application/pkix-attr-cert": {
      source: "iana",
      extensions: ["ac"]
    },
    "application/pkix-cert": {
      source: "iana",
      extensions: ["cer"]
    },
    "application/pkix-crl": {
      source: "iana",
      extensions: ["crl"]
    },
    "application/pkix-pkipath": {
      source: "iana",
      extensions: ["pkipath"]
    },
    "application/pkixcmp": {
      source: "iana",
      extensions: ["pki"]
    },
    "application/pls+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pls"]
    },
    "application/poc-settings+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/postscript": {
      source: "iana",
      compressible: true,
      extensions: ["ai", "eps", "ps"]
    },
    "application/ppsp-tracker+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+xml": {
      source: "iana",
      compressible: true
    },
    "application/provenance+xml": {
      source: "iana",
      compressible: true,
      extensions: ["provx"]
    },
    "application/prs.alvestrand.titrax-sheet": {
      source: "iana"
    },
    "application/prs.cww": {
      source: "iana",
      extensions: ["cww"]
    },
    "application/prs.cyn": {
      source: "iana",
      charset: "7-BIT"
    },
    "application/prs.hpub+zip": {
      source: "iana",
      compressible: false
    },
    "application/prs.nprend": {
      source: "iana"
    },
    "application/prs.plucker": {
      source: "iana"
    },
    "application/prs.rdf-xml-crypt": {
      source: "iana"
    },
    "application/prs.xsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/pskc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pskcxml"]
    },
    "application/pvd+json": {
      source: "iana",
      compressible: true
    },
    "application/qsig": {
      source: "iana"
    },
    "application/raml+yaml": {
      compressible: true,
      extensions: ["raml"]
    },
    "application/raptorfec": {
      source: "iana"
    },
    "application/rdap+json": {
      source: "iana",
      compressible: true
    },
    "application/rdf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rdf", "owl"]
    },
    "application/reginfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rif"]
    },
    "application/relax-ng-compact-syntax": {
      source: "iana",
      extensions: ["rnc"]
    },
    "application/remote-printing": {
      source: "iana"
    },
    "application/reputon+json": {
      source: "iana",
      compressible: true
    },
    "application/resource-lists+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rl"]
    },
    "application/resource-lists-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rld"]
    },
    "application/rfc+xml": {
      source: "iana",
      compressible: true
    },
    "application/riscos": {
      source: "iana"
    },
    "application/rlmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/rls-services+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rs"]
    },
    "application/route-apd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rapd"]
    },
    "application/route-s-tsid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sls"]
    },
    "application/route-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rusd"]
    },
    "application/rpki-ghostbusters": {
      source: "iana",
      extensions: ["gbr"]
    },
    "application/rpki-manifest": {
      source: "iana",
      extensions: ["mft"]
    },
    "application/rpki-publication": {
      source: "iana"
    },
    "application/rpki-roa": {
      source: "iana",
      extensions: ["roa"]
    },
    "application/rpki-updown": {
      source: "iana"
    },
    "application/rsd+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rsd"]
    },
    "application/rss+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rss"]
    },
    "application/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "application/rtploopback": {
      source: "iana"
    },
    "application/rtx": {
      source: "iana"
    },
    "application/samlassertion+xml": {
      source: "iana",
      compressible: true
    },
    "application/samlmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/sarif+json": {
      source: "iana",
      compressible: true
    },
    "application/sarif-external-properties+json": {
      source: "iana",
      compressible: true
    },
    "application/sbe": {
      source: "iana"
    },
    "application/sbml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sbml"]
    },
    "application/scaip+xml": {
      source: "iana",
      compressible: true
    },
    "application/scim+json": {
      source: "iana",
      compressible: true
    },
    "application/scvp-cv-request": {
      source: "iana",
      extensions: ["scq"]
    },
    "application/scvp-cv-response": {
      source: "iana",
      extensions: ["scs"]
    },
    "application/scvp-vp-request": {
      source: "iana",
      extensions: ["spq"]
    },
    "application/scvp-vp-response": {
      source: "iana",
      extensions: ["spp"]
    },
    "application/sdp": {
      source: "iana",
      extensions: ["sdp"]
    },
    "application/secevent+jwt": {
      source: "iana"
    },
    "application/senml+cbor": {
      source: "iana"
    },
    "application/senml+json": {
      source: "iana",
      compressible: true
    },
    "application/senml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["senmlx"]
    },
    "application/senml-etch+cbor": {
      source: "iana"
    },
    "application/senml-etch+json": {
      source: "iana",
      compressible: true
    },
    "application/senml-exi": {
      source: "iana"
    },
    "application/sensml+cbor": {
      source: "iana"
    },
    "application/sensml+json": {
      source: "iana",
      compressible: true
    },
    "application/sensml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sensmlx"]
    },
    "application/sensml-exi": {
      source: "iana"
    },
    "application/sep+xml": {
      source: "iana",
      compressible: true
    },
    "application/sep-exi": {
      source: "iana"
    },
    "application/session-info": {
      source: "iana"
    },
    "application/set-payment": {
      source: "iana"
    },
    "application/set-payment-initiation": {
      source: "iana",
      extensions: ["setpay"]
    },
    "application/set-registration": {
      source: "iana"
    },
    "application/set-registration-initiation": {
      source: "iana",
      extensions: ["setreg"]
    },
    "application/sgml": {
      source: "iana"
    },
    "application/sgml-open-catalog": {
      source: "iana"
    },
    "application/shf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["shf"]
    },
    "application/sieve": {
      source: "iana",
      extensions: ["siv", "sieve"]
    },
    "application/simple-filter+xml": {
      source: "iana",
      compressible: true
    },
    "application/simple-message-summary": {
      source: "iana"
    },
    "application/simplesymbolcontainer": {
      source: "iana"
    },
    "application/sipc": {
      source: "iana"
    },
    "application/slate": {
      source: "iana"
    },
    "application/smil": {
      source: "iana"
    },
    "application/smil+xml": {
      source: "iana",
      compressible: true,
      extensions: ["smi", "smil"]
    },
    "application/smpte336m": {
      source: "iana"
    },
    "application/soap+fastinfoset": {
      source: "iana"
    },
    "application/soap+xml": {
      source: "iana",
      compressible: true
    },
    "application/sparql-query": {
      source: "iana",
      extensions: ["rq"]
    },
    "application/sparql-results+xml": {
      source: "iana",
      compressible: true,
      extensions: ["srx"]
    },
    "application/spirits-event+xml": {
      source: "iana",
      compressible: true
    },
    "application/sql": {
      source: "iana"
    },
    "application/srgs": {
      source: "iana",
      extensions: ["gram"]
    },
    "application/srgs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["grxml"]
    },
    "application/sru+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sru"]
    },
    "application/ssdl+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ssdl"]
    },
    "application/ssml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ssml"]
    },
    "application/stix+json": {
      source: "iana",
      compressible: true
    },
    "application/swid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["swidtag"]
    },
    "application/tamp-apex-update": {
      source: "iana"
    },
    "application/tamp-apex-update-confirm": {
      source: "iana"
    },
    "application/tamp-community-update": {
      source: "iana"
    },
    "application/tamp-community-update-confirm": {
      source: "iana"
    },
    "application/tamp-error": {
      source: "iana"
    },
    "application/tamp-sequence-adjust": {
      source: "iana"
    },
    "application/tamp-sequence-adjust-confirm": {
      source: "iana"
    },
    "application/tamp-status-query": {
      source: "iana"
    },
    "application/tamp-status-response": {
      source: "iana"
    },
    "application/tamp-update": {
      source: "iana"
    },
    "application/tamp-update-confirm": {
      source: "iana"
    },
    "application/tar": {
      compressible: true
    },
    "application/taxii+json": {
      source: "iana",
      compressible: true
    },
    "application/td+json": {
      source: "iana",
      compressible: true
    },
    "application/tei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tei", "teicorpus"]
    },
    "application/tetra_isi": {
      source: "iana"
    },
    "application/thraud+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tfi"]
    },
    "application/timestamp-query": {
      source: "iana"
    },
    "application/timestamp-reply": {
      source: "iana"
    },
    "application/timestamped-data": {
      source: "iana",
      extensions: ["tsd"]
    },
    "application/tlsrpt+gzip": {
      source: "iana"
    },
    "application/tlsrpt+json": {
      source: "iana",
      compressible: true
    },
    "application/tnauthlist": {
      source: "iana"
    },
    "application/toml": {
      compressible: true,
      extensions: ["toml"]
    },
    "application/trickle-ice-sdpfrag": {
      source: "iana"
    },
    "application/trig": {
      source: "iana",
      extensions: ["trig"]
    },
    "application/ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ttml"]
    },
    "application/tve-trigger": {
      source: "iana"
    },
    "application/tzif": {
      source: "iana"
    },
    "application/tzif-leap": {
      source: "iana"
    },
    "application/ubjson": {
      compressible: false,
      extensions: ["ubj"]
    },
    "application/ulpfec": {
      source: "iana"
    },
    "application/urc-grpsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/urc-ressheet+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsheet"]
    },
    "application/urc-targetdesc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["td"]
    },
    "application/urc-uisocketdesc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vcard+json": {
      source: "iana",
      compressible: true
    },
    "application/vcard+xml": {
      source: "iana",
      compressible: true
    },
    "application/vemmi": {
      source: "iana"
    },
    "application/vividence.scriptfile": {
      source: "apache"
    },
    "application/vnd.1000minds.decision-model+xml": {
      source: "iana",
      compressible: true,
      extensions: ["1km"]
    },
    "application/vnd.3gpp-prose+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-prose-pc3ch+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-v2x-local-service-information": {
      source: "iana"
    },
    "application/vnd.3gpp.5gnas": {
      source: "iana"
    },
    "application/vnd.3gpp.access-transfer-events+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.bsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gmop+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gtpc": {
      source: "iana"
    },
    "application/vnd.3gpp.interworking-data": {
      source: "iana"
    },
    "application/vnd.3gpp.lpp": {
      source: "iana"
    },
    "application/vnd.3gpp.mc-signalling-ear": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-payload": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-signalling": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-floor-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-signed+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-init-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-transmission-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mid-call+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ngap": {
      source: "iana"
    },
    "application/vnd.3gpp.pfcp": {
      source: "iana"
    },
    "application/vnd.3gpp.pic-bw-large": {
      source: "iana",
      extensions: ["plb"]
    },
    "application/vnd.3gpp.pic-bw-small": {
      source: "iana",
      extensions: ["psb"]
    },
    "application/vnd.3gpp.pic-bw-var": {
      source: "iana",
      extensions: ["pvb"]
    },
    "application/vnd.3gpp.s1ap": {
      source: "iana"
    },
    "application/vnd.3gpp.sms": {
      source: "iana"
    },
    "application/vnd.3gpp.sms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-ext+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.state-and-event-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ussd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.bcmcsinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.sms": {
      source: "iana"
    },
    "application/vnd.3gpp2.tcap": {
      source: "iana",
      extensions: ["tcap"]
    },
    "application/vnd.3lightssoftware.imagescal": {
      source: "iana"
    },
    "application/vnd.3m.post-it-notes": {
      source: "iana",
      extensions: ["pwn"]
    },
    "application/vnd.accpac.simply.aso": {
      source: "iana",
      extensions: ["aso"]
    },
    "application/vnd.accpac.simply.imp": {
      source: "iana",
      extensions: ["imp"]
    },
    "application/vnd.acucobol": {
      source: "iana",
      extensions: ["acu"]
    },
    "application/vnd.acucorp": {
      source: "iana",
      extensions: ["atc", "acutc"]
    },
    "application/vnd.adobe.air-application-installer-package+zip": {
      source: "apache",
      compressible: false,
      extensions: ["air"]
    },
    "application/vnd.adobe.flash.movie": {
      source: "iana"
    },
    "application/vnd.adobe.formscentral.fcdt": {
      source: "iana",
      extensions: ["fcdt"]
    },
    "application/vnd.adobe.fxp": {
      source: "iana",
      extensions: ["fxp", "fxpl"]
    },
    "application/vnd.adobe.partial-upload": {
      source: "iana"
    },
    "application/vnd.adobe.xdp+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdp"]
    },
    "application/vnd.adobe.xfdf": {
      source: "iana",
      extensions: ["xfdf"]
    },
    "application/vnd.aether.imp": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata-pagedef": {
      source: "iana"
    },
    "application/vnd.afpc.cmoca-cmresource": {
      source: "iana"
    },
    "application/vnd.afpc.foca-charset": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codedfont": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codepage": {
      source: "iana"
    },
    "application/vnd.afpc.modca": {
      source: "iana"
    },
    "application/vnd.afpc.modca-cmtable": {
      source: "iana"
    },
    "application/vnd.afpc.modca-formdef": {
      source: "iana"
    },
    "application/vnd.afpc.modca-mediummap": {
      source: "iana"
    },
    "application/vnd.afpc.modca-objectcontainer": {
      source: "iana"
    },
    "application/vnd.afpc.modca-overlay": {
      source: "iana"
    },
    "application/vnd.afpc.modca-pagesegment": {
      source: "iana"
    },
    "application/vnd.ah-barcode": {
      source: "iana"
    },
    "application/vnd.ahead.space": {
      source: "iana",
      extensions: ["ahead"]
    },
    "application/vnd.airzip.filesecure.azf": {
      source: "iana",
      extensions: ["azf"]
    },
    "application/vnd.airzip.filesecure.azs": {
      source: "iana",
      extensions: ["azs"]
    },
    "application/vnd.amadeus+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.amazon.ebook": {
      source: "apache",
      extensions: ["azw"]
    },
    "application/vnd.amazon.mobi8-ebook": {
      source: "iana"
    },
    "application/vnd.americandynamics.acc": {
      source: "iana",
      extensions: ["acc"]
    },
    "application/vnd.amiga.ami": {
      source: "iana",
      extensions: ["ami"]
    },
    "application/vnd.amundsen.maze+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.android.ota": {
      source: "iana"
    },
    "application/vnd.android.package-archive": {
      source: "apache",
      compressible: false,
      extensions: ["apk"]
    },
    "application/vnd.anki": {
      source: "iana"
    },
    "application/vnd.anser-web-certificate-issue-initiation": {
      source: "iana",
      extensions: ["cii"]
    },
    "application/vnd.anser-web-funds-transfer-initiation": {
      source: "apache",
      extensions: ["fti"]
    },
    "application/vnd.antix.game-component": {
      source: "iana",
      extensions: ["atx"]
    },
    "application/vnd.apache.arrow.file": {
      source: "iana"
    },
    "application/vnd.apache.arrow.stream": {
      source: "iana"
    },
    "application/vnd.apache.thrift.binary": {
      source: "iana"
    },
    "application/vnd.apache.thrift.compact": {
      source: "iana"
    },
    "application/vnd.apache.thrift.json": {
      source: "iana"
    },
    "application/vnd.api+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.aplextor.warrp+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apothekende.reservation+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apple.installer+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpkg"]
    },
    "application/vnd.apple.keynote": {
      source: "iana",
      extensions: ["key"]
    },
    "application/vnd.apple.mpegurl": {
      source: "iana",
      extensions: ["m3u8"]
    },
    "application/vnd.apple.numbers": {
      source: "iana",
      extensions: ["numbers"]
    },
    "application/vnd.apple.pages": {
      source: "iana",
      extensions: ["pages"]
    },
    "application/vnd.apple.pkpass": {
      compressible: false,
      extensions: ["pkpass"]
    },
    "application/vnd.arastra.swi": {
      source: "iana"
    },
    "application/vnd.aristanetworks.swi": {
      source: "iana",
      extensions: ["swi"]
    },
    "application/vnd.artisan+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.artsquare": {
      source: "iana"
    },
    "application/vnd.astraea-software.iota": {
      source: "iana",
      extensions: ["iota"]
    },
    "application/vnd.audiograph": {
      source: "iana",
      extensions: ["aep"]
    },
    "application/vnd.autopackage": {
      source: "iana"
    },
    "application/vnd.avalon+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.avistar+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.balsamiq.bmml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["bmml"]
    },
    "application/vnd.balsamiq.bmpr": {
      source: "iana"
    },
    "application/vnd.banana-accounting": {
      source: "iana"
    },
    "application/vnd.bbf.usp.error": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bekitzur-stech+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bint.med-content": {
      source: "iana"
    },
    "application/vnd.biopax.rdf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.blink-idb-value-wrapper": {
      source: "iana"
    },
    "application/vnd.blueice.multipass": {
      source: "iana",
      extensions: ["mpm"]
    },
    "application/vnd.bluetooth.ep.oob": {
      source: "iana"
    },
    "application/vnd.bluetooth.le.oob": {
      source: "iana"
    },
    "application/vnd.bmi": {
      source: "iana",
      extensions: ["bmi"]
    },
    "application/vnd.bpf": {
      source: "iana"
    },
    "application/vnd.bpf3": {
      source: "iana"
    },
    "application/vnd.businessobjects": {
      source: "iana",
      extensions: ["rep"]
    },
    "application/vnd.byu.uapi+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cab-jscript": {
      source: "iana"
    },
    "application/vnd.canon-cpdl": {
      source: "iana"
    },
    "application/vnd.canon-lips": {
      source: "iana"
    },
    "application/vnd.capasystems-pg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cendio.thinlinc.clientconf": {
      source: "iana"
    },
    "application/vnd.century-systems.tcp_stream": {
      source: "iana"
    },
    "application/vnd.chemdraw+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdxml"]
    },
    "application/vnd.chess-pgn": {
      source: "iana"
    },
    "application/vnd.chipnuts.karaoke-mmd": {
      source: "iana",
      extensions: ["mmd"]
    },
    "application/vnd.ciedi": {
      source: "iana"
    },
    "application/vnd.cinderella": {
      source: "iana",
      extensions: ["cdy"]
    },
    "application/vnd.cirpack.isdn-ext": {
      source: "iana"
    },
    "application/vnd.citationstyles.style+xml": {
      source: "iana",
      compressible: true,
      extensions: ["csl"]
    },
    "application/vnd.claymore": {
      source: "iana",
      extensions: ["cla"]
    },
    "application/vnd.cloanto.rp9": {
      source: "iana",
      extensions: ["rp9"]
    },
    "application/vnd.clonk.c4group": {
      source: "iana",
      extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
    },
    "application/vnd.cluetrust.cartomobile-config": {
      source: "iana",
      extensions: ["c11amc"]
    },
    "application/vnd.cluetrust.cartomobile-config-pkg": {
      source: "iana",
      extensions: ["c11amz"]
    },
    "application/vnd.coffeescript": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet-template": {
      source: "iana"
    },
    "application/vnd.collection+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.doc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.next+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.comicbook+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.comicbook-rar": {
      source: "iana"
    },
    "application/vnd.commerce-battelle": {
      source: "iana"
    },
    "application/vnd.commonspace": {
      source: "iana",
      extensions: ["csp"]
    },
    "application/vnd.contact.cmsg": {
      source: "iana",
      extensions: ["cdbcmsg"]
    },
    "application/vnd.coreos.ignition+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cosmocaller": {
      source: "iana",
      extensions: ["cmc"]
    },
    "application/vnd.crick.clicker": {
      source: "iana",
      extensions: ["clkx"]
    },
    "application/vnd.crick.clicker.keyboard": {
      source: "iana",
      extensions: ["clkk"]
    },
    "application/vnd.crick.clicker.palette": {
      source: "iana",
      extensions: ["clkp"]
    },
    "application/vnd.crick.clicker.template": {
      source: "iana",
      extensions: ["clkt"]
    },
    "application/vnd.crick.clicker.wordbank": {
      source: "iana",
      extensions: ["clkw"]
    },
    "application/vnd.criticaltools.wbs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wbs"]
    },
    "application/vnd.cryptii.pipe+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.crypto-shade-file": {
      source: "iana"
    },
    "application/vnd.cryptomator.encrypted": {
      source: "iana"
    },
    "application/vnd.cryptomator.vault": {
      source: "iana"
    },
    "application/vnd.ctc-posml": {
      source: "iana",
      extensions: ["pml"]
    },
    "application/vnd.ctct.ws+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cups-pdf": {
      source: "iana"
    },
    "application/vnd.cups-postscript": {
      source: "iana"
    },
    "application/vnd.cups-ppd": {
      source: "iana",
      extensions: ["ppd"]
    },
    "application/vnd.cups-raster": {
      source: "iana"
    },
    "application/vnd.cups-raw": {
      source: "iana"
    },
    "application/vnd.curl": {
      source: "iana"
    },
    "application/vnd.curl.car": {
      source: "apache",
      extensions: ["car"]
    },
    "application/vnd.curl.pcurl": {
      source: "apache",
      extensions: ["pcurl"]
    },
    "application/vnd.cyan.dean.root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cybank": {
      source: "iana"
    },
    "application/vnd.cyclonedx+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cyclonedx+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.d2l.coursepackage1p0+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.d3m-dataset": {
      source: "iana"
    },
    "application/vnd.d3m-problem": {
      source: "iana"
    },
    "application/vnd.dart": {
      source: "iana",
      compressible: true,
      extensions: ["dart"]
    },
    "application/vnd.data-vision.rdz": {
      source: "iana",
      extensions: ["rdz"]
    },
    "application/vnd.datapackage+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dataresource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dbf": {
      source: "iana",
      extensions: ["dbf"]
    },
    "application/vnd.debian.binary-package": {
      source: "iana"
    },
    "application/vnd.dece.data": {
      source: "iana",
      extensions: ["uvf", "uvvf", "uvd", "uvvd"]
    },
    "application/vnd.dece.ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uvt", "uvvt"]
    },
    "application/vnd.dece.unspecified": {
      source: "iana",
      extensions: ["uvx", "uvvx"]
    },
    "application/vnd.dece.zip": {
      source: "iana",
      extensions: ["uvz", "uvvz"]
    },
    "application/vnd.denovo.fcselayout-link": {
      source: "iana",
      extensions: ["fe_launch"]
    },
    "application/vnd.desmume.movie": {
      source: "iana"
    },
    "application/vnd.dir-bi.plate-dl-nosuffix": {
      source: "iana"
    },
    "application/vnd.dm.delegation+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dna": {
      source: "iana",
      extensions: ["dna"]
    },
    "application/vnd.document+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dolby.mlp": {
      source: "apache",
      extensions: ["mlp"]
    },
    "application/vnd.dolby.mobile.1": {
      source: "iana"
    },
    "application/vnd.dolby.mobile.2": {
      source: "iana"
    },
    "application/vnd.doremir.scorecloud-binary-document": {
      source: "iana"
    },
    "application/vnd.dpgraph": {
      source: "iana",
      extensions: ["dpg"]
    },
    "application/vnd.dreamfactory": {
      source: "iana",
      extensions: ["dfac"]
    },
    "application/vnd.drive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ds-keypoint": {
      source: "apache",
      extensions: ["kpxx"]
    },
    "application/vnd.dtg.local": {
      source: "iana"
    },
    "application/vnd.dtg.local.flash": {
      source: "iana"
    },
    "application/vnd.dtg.local.html": {
      source: "iana"
    },
    "application/vnd.dvb.ait": {
      source: "iana",
      extensions: ["ait"]
    },
    "application/vnd.dvb.dvbisl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.dvbj": {
      source: "iana"
    },
    "application/vnd.dvb.esgcontainer": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcdftnotifaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess2": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgpdd": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcroaming": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-base": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-enhancement": {
      source: "iana"
    },
    "application/vnd.dvb.notif-aggregate-root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-container+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-generic+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-msglist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-init+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.pfr": {
      source: "iana"
    },
    "application/vnd.dvb.service": {
      source: "iana",
      extensions: ["svc"]
    },
    "application/vnd.dxr": {
      source: "iana"
    },
    "application/vnd.dynageo": {
      source: "iana",
      extensions: ["geo"]
    },
    "application/vnd.dzr": {
      source: "iana"
    },
    "application/vnd.easykaraoke.cdgdownload": {
      source: "iana"
    },
    "application/vnd.ecdis-update": {
      source: "iana"
    },
    "application/vnd.ecip.rlp": {
      source: "iana"
    },
    "application/vnd.ecowin.chart": {
      source: "iana",
      extensions: ["mag"]
    },
    "application/vnd.ecowin.filerequest": {
      source: "iana"
    },
    "application/vnd.ecowin.fileupdate": {
      source: "iana"
    },
    "application/vnd.ecowin.series": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesrequest": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesupdate": {
      source: "iana"
    },
    "application/vnd.efi.img": {
      source: "iana"
    },
    "application/vnd.efi.iso": {
      source: "iana"
    },
    "application/vnd.emclient.accessrequest+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.enliven": {
      source: "iana",
      extensions: ["nml"]
    },
    "application/vnd.enphase.envoy": {
      source: "iana"
    },
    "application/vnd.eprints.data+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.epson.esf": {
      source: "iana",
      extensions: ["esf"]
    },
    "application/vnd.epson.msf": {
      source: "iana",
      extensions: ["msf"]
    },
    "application/vnd.epson.quickanime": {
      source: "iana",
      extensions: ["qam"]
    },
    "application/vnd.epson.salt": {
      source: "iana",
      extensions: ["slt"]
    },
    "application/vnd.epson.ssf": {
      source: "iana",
      extensions: ["ssf"]
    },
    "application/vnd.ericsson.quickcall": {
      source: "iana"
    },
    "application/vnd.espass-espass+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.eszigno3+xml": {
      source: "iana",
      compressible: true,
      extensions: ["es3", "et3"]
    },
    "application/vnd.etsi.aoc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.asic-e+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.asic-s+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.cug+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvcommand+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-bc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-cod+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-npvr+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvservice+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mcid+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mheg5": {
      source: "iana"
    },
    "application/vnd.etsi.overload-control-policy-dataset+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.pstn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.sci+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.simservs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.timestamp-token": {
      source: "iana"
    },
    "application/vnd.etsi.tsl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.tsl.der": {
      source: "iana"
    },
    "application/vnd.eudora.data": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.profile": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.settings": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.theme": {
      source: "iana"
    },
    "application/vnd.exstream-empower+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.exstream-package": {
      source: "iana"
    },
    "application/vnd.ezpix-album": {
      source: "iana",
      extensions: ["ez2"]
    },
    "application/vnd.ezpix-package": {
      source: "iana",
      extensions: ["ez3"]
    },
    "application/vnd.f-secure.mobile": {
      source: "iana"
    },
    "application/vnd.fastcopy-disk-image": {
      source: "iana"
    },
    "application/vnd.fdf": {
      source: "iana",
      extensions: ["fdf"]
    },
    "application/vnd.fdsn.mseed": {
      source: "iana",
      extensions: ["mseed"]
    },
    "application/vnd.fdsn.seed": {
      source: "iana",
      extensions: ["seed", "dataless"]
    },
    "application/vnd.ffsns": {
      source: "iana"
    },
    "application/vnd.ficlab.flb+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.filmit.zfc": {
      source: "iana"
    },
    "application/vnd.fints": {
      source: "iana"
    },
    "application/vnd.firemonkeys.cloudcell": {
      source: "iana"
    },
    "application/vnd.flographit": {
      source: "iana",
      extensions: ["gph"]
    },
    "application/vnd.fluxtime.clip": {
      source: "iana",
      extensions: ["ftc"]
    },
    "application/vnd.font-fontforge-sfd": {
      source: "iana"
    },
    "application/vnd.framemaker": {
      source: "iana",
      extensions: ["fm", "frame", "maker", "book"]
    },
    "application/vnd.frogans.fnc": {
      source: "iana",
      extensions: ["fnc"]
    },
    "application/vnd.frogans.ltf": {
      source: "iana",
      extensions: ["ltf"]
    },
    "application/vnd.fsc.weblaunch": {
      source: "iana",
      extensions: ["fsc"]
    },
    "application/vnd.fujifilm.fb.docuworks": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.binder": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.jfi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fujitsu.oasys": {
      source: "iana",
      extensions: ["oas"]
    },
    "application/vnd.fujitsu.oasys2": {
      source: "iana",
      extensions: ["oa2"]
    },
    "application/vnd.fujitsu.oasys3": {
      source: "iana",
      extensions: ["oa3"]
    },
    "application/vnd.fujitsu.oasysgp": {
      source: "iana",
      extensions: ["fg5"]
    },
    "application/vnd.fujitsu.oasysprs": {
      source: "iana",
      extensions: ["bh2"]
    },
    "application/vnd.fujixerox.art-ex": {
      source: "iana"
    },
    "application/vnd.fujixerox.art4": {
      source: "iana"
    },
    "application/vnd.fujixerox.ddd": {
      source: "iana",
      extensions: ["ddd"]
    },
    "application/vnd.fujixerox.docuworks": {
      source: "iana",
      extensions: ["xdw"]
    },
    "application/vnd.fujixerox.docuworks.binder": {
      source: "iana",
      extensions: ["xbd"]
    },
    "application/vnd.fujixerox.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujixerox.hbpl": {
      source: "iana"
    },
    "application/vnd.fut-misnet": {
      source: "iana"
    },
    "application/vnd.futoin+cbor": {
      source: "iana"
    },
    "application/vnd.futoin+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fuzzysheet": {
      source: "iana",
      extensions: ["fzs"]
    },
    "application/vnd.genomatix.tuxedo": {
      source: "iana",
      extensions: ["txd"]
    },
    "application/vnd.gentics.grd+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geo+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geocube+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geogebra.file": {
      source: "iana",
      extensions: ["ggb"]
    },
    "application/vnd.geogebra.slides": {
      source: "iana"
    },
    "application/vnd.geogebra.tool": {
      source: "iana",
      extensions: ["ggt"]
    },
    "application/vnd.geometry-explorer": {
      source: "iana",
      extensions: ["gex", "gre"]
    },
    "application/vnd.geonext": {
      source: "iana",
      extensions: ["gxt"]
    },
    "application/vnd.geoplan": {
      source: "iana",
      extensions: ["g2w"]
    },
    "application/vnd.geospace": {
      source: "iana",
      extensions: ["g3w"]
    },
    "application/vnd.gerber": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt-response": {
      source: "iana"
    },
    "application/vnd.gmx": {
      source: "iana",
      extensions: ["gmx"]
    },
    "application/vnd.google-apps.document": {
      compressible: false,
      extensions: ["gdoc"]
    },
    "application/vnd.google-apps.presentation": {
      compressible: false,
      extensions: ["gslides"]
    },
    "application/vnd.google-apps.spreadsheet": {
      compressible: false,
      extensions: ["gsheet"]
    },
    "application/vnd.google-earth.kml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["kml"]
    },
    "application/vnd.google-earth.kmz": {
      source: "iana",
      compressible: false,
      extensions: ["kmz"]
    },
    "application/vnd.gov.sk.e-form+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.gov.sk.e-form+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.gov.sk.xmldatacontainer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.grafeq": {
      source: "iana",
      extensions: ["gqf", "gqs"]
    },
    "application/vnd.gridmp": {
      source: "iana"
    },
    "application/vnd.groove-account": {
      source: "iana",
      extensions: ["gac"]
    },
    "application/vnd.groove-help": {
      source: "iana",
      extensions: ["ghf"]
    },
    "application/vnd.groove-identity-message": {
      source: "iana",
      extensions: ["gim"]
    },
    "application/vnd.groove-injector": {
      source: "iana",
      extensions: ["grv"]
    },
    "application/vnd.groove-tool-message": {
      source: "iana",
      extensions: ["gtm"]
    },
    "application/vnd.groove-tool-template": {
      source: "iana",
      extensions: ["tpl"]
    },
    "application/vnd.groove-vcard": {
      source: "iana",
      extensions: ["vcg"]
    },
    "application/vnd.hal+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hal+xml": {
      source: "iana",
      compressible: true,
      extensions: ["hal"]
    },
    "application/vnd.handheld-entertainment+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zmm"]
    },
    "application/vnd.hbci": {
      source: "iana",
      extensions: ["hbci"]
    },
    "application/vnd.hc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hcl-bireports": {
      source: "iana"
    },
    "application/vnd.hdt": {
      source: "iana"
    },
    "application/vnd.heroku+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hhe.lesson-player": {
      source: "iana",
      extensions: ["les"]
    },
    "application/vnd.hp-hpgl": {
      source: "iana",
      extensions: ["hpgl"]
    },
    "application/vnd.hp-hpid": {
      source: "iana",
      extensions: ["hpid"]
    },
    "application/vnd.hp-hps": {
      source: "iana",
      extensions: ["hps"]
    },
    "application/vnd.hp-jlyt": {
      source: "iana",
      extensions: ["jlt"]
    },
    "application/vnd.hp-pcl": {
      source: "iana",
      extensions: ["pcl"]
    },
    "application/vnd.hp-pclxl": {
      source: "iana",
      extensions: ["pclxl"]
    },
    "application/vnd.httphone": {
      source: "iana"
    },
    "application/vnd.hydrostatix.sof-data": {
      source: "iana",
      extensions: ["sfd-hdstx"]
    },
    "application/vnd.hyper+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyper-item+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyperdrive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hzn-3d-crossword": {
      source: "iana"
    },
    "application/vnd.ibm.afplinedata": {
      source: "iana"
    },
    "application/vnd.ibm.electronic-media": {
      source: "iana"
    },
    "application/vnd.ibm.minipay": {
      source: "iana",
      extensions: ["mpy"]
    },
    "application/vnd.ibm.modcap": {
      source: "iana",
      extensions: ["afp", "listafp", "list3820"]
    },
    "application/vnd.ibm.rights-management": {
      source: "iana",
      extensions: ["irm"]
    },
    "application/vnd.ibm.secure-container": {
      source: "iana",
      extensions: ["sc"]
    },
    "application/vnd.iccprofile": {
      source: "iana",
      extensions: ["icc", "icm"]
    },
    "application/vnd.ieee.1905": {
      source: "iana"
    },
    "application/vnd.igloader": {
      source: "iana",
      extensions: ["igl"]
    },
    "application/vnd.imagemeter.folder+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.imagemeter.image+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.immervision-ivp": {
      source: "iana",
      extensions: ["ivp"]
    },
    "application/vnd.immervision-ivu": {
      source: "iana",
      extensions: ["ivu"]
    },
    "application/vnd.ims.imsccv1p1": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p2": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p3": {
      source: "iana"
    },
    "application/vnd.ims.lis.v2.result+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy.id+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings.simple+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informedcontrol.rms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informix-visionary": {
      source: "iana"
    },
    "application/vnd.infotech.project": {
      source: "iana"
    },
    "application/vnd.infotech.project+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.innopath.wamp.notification": {
      source: "iana"
    },
    "application/vnd.insors.igm": {
      source: "iana",
      extensions: ["igm"]
    },
    "application/vnd.intercon.formnet": {
      source: "iana",
      extensions: ["xpw", "xpx"]
    },
    "application/vnd.intergeo": {
      source: "iana",
      extensions: ["i2g"]
    },
    "application/vnd.intertrust.digibox": {
      source: "iana"
    },
    "application/vnd.intertrust.nncp": {
      source: "iana"
    },
    "application/vnd.intu.qbo": {
      source: "iana",
      extensions: ["qbo"]
    },
    "application/vnd.intu.qfx": {
      source: "iana",
      extensions: ["qfx"]
    },
    "application/vnd.iptc.g2.catalogitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.conceptitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.knowledgeitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.packageitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.planningitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ipunplugged.rcprofile": {
      source: "iana",
      extensions: ["rcprofile"]
    },
    "application/vnd.irepository.package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["irp"]
    },
    "application/vnd.is-xpr": {
      source: "iana",
      extensions: ["xpr"]
    },
    "application/vnd.isac.fcs": {
      source: "iana",
      extensions: ["fcs"]
    },
    "application/vnd.iso11783-10+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.jam": {
      source: "iana",
      extensions: ["jam"]
    },
    "application/vnd.japannet-directory-service": {
      source: "iana"
    },
    "application/vnd.japannet-jpnstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-payment-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-registration": {
      source: "iana"
    },
    "application/vnd.japannet-registration-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-setstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-verification": {
      source: "iana"
    },
    "application/vnd.japannet-verification-wakeup": {
      source: "iana"
    },
    "application/vnd.jcp.javame.midlet-rms": {
      source: "iana",
      extensions: ["rms"]
    },
    "application/vnd.jisp": {
      source: "iana",
      extensions: ["jisp"]
    },
    "application/vnd.joost.joda-archive": {
      source: "iana",
      extensions: ["joda"]
    },
    "application/vnd.jsk.isdn-ngn": {
      source: "iana"
    },
    "application/vnd.kahootz": {
      source: "iana",
      extensions: ["ktz", "ktr"]
    },
    "application/vnd.kde.karbon": {
      source: "iana",
      extensions: ["karbon"]
    },
    "application/vnd.kde.kchart": {
      source: "iana",
      extensions: ["chrt"]
    },
    "application/vnd.kde.kformula": {
      source: "iana",
      extensions: ["kfo"]
    },
    "application/vnd.kde.kivio": {
      source: "iana",
      extensions: ["flw"]
    },
    "application/vnd.kde.kontour": {
      source: "iana",
      extensions: ["kon"]
    },
    "application/vnd.kde.kpresenter": {
      source: "iana",
      extensions: ["kpr", "kpt"]
    },
    "application/vnd.kde.kspread": {
      source: "iana",
      extensions: ["ksp"]
    },
    "application/vnd.kde.kword": {
      source: "iana",
      extensions: ["kwd", "kwt"]
    },
    "application/vnd.kenameaapp": {
      source: "iana",
      extensions: ["htke"]
    },
    "application/vnd.kidspiration": {
      source: "iana",
      extensions: ["kia"]
    },
    "application/vnd.kinar": {
      source: "iana",
      extensions: ["kne", "knp"]
    },
    "application/vnd.koan": {
      source: "iana",
      extensions: ["skp", "skd", "skt", "skm"]
    },
    "application/vnd.kodak-descriptor": {
      source: "iana",
      extensions: ["sse"]
    },
    "application/vnd.las": {
      source: "iana"
    },
    "application/vnd.las.las+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.las.las+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lasxml"]
    },
    "application/vnd.laszip": {
      source: "iana"
    },
    "application/vnd.leap+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.liberty-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.llamagraphics.life-balance.desktop": {
      source: "iana",
      extensions: ["lbd"]
    },
    "application/vnd.llamagraphics.life-balance.exchange+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lbe"]
    },
    "application/vnd.logipipe.circuit+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.loom": {
      source: "iana"
    },
    "application/vnd.lotus-1-2-3": {
      source: "iana",
      extensions: ["123"]
    },
    "application/vnd.lotus-approach": {
      source: "iana",
      extensions: ["apr"]
    },
    "application/vnd.lotus-freelance": {
      source: "iana",
      extensions: ["pre"]
    },
    "application/vnd.lotus-notes": {
      source: "iana",
      extensions: ["nsf"]
    },
    "application/vnd.lotus-organizer": {
      source: "iana",
      extensions: ["org"]
    },
    "application/vnd.lotus-screencam": {
      source: "iana",
      extensions: ["scm"]
    },
    "application/vnd.lotus-wordpro": {
      source: "iana",
      extensions: ["lwp"]
    },
    "application/vnd.macports.portpkg": {
      source: "iana",
      extensions: ["portpkg"]
    },
    "application/vnd.mapbox-vector-tile": {
      source: "iana",
      extensions: ["mvt"]
    },
    "application/vnd.marlin.drm.actiontoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.conftoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.license+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.mdcf": {
      source: "iana"
    },
    "application/vnd.mason+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.maxmind.maxmind-db": {
      source: "iana"
    },
    "application/vnd.mcd": {
      source: "iana",
      extensions: ["mcd"]
    },
    "application/vnd.medcalcdata": {
      source: "iana",
      extensions: ["mc1"]
    },
    "application/vnd.mediastation.cdkey": {
      source: "iana",
      extensions: ["cdkey"]
    },
    "application/vnd.meridian-slingshot": {
      source: "iana"
    },
    "application/vnd.mfer": {
      source: "iana",
      extensions: ["mwf"]
    },
    "application/vnd.mfmp": {
      source: "iana",
      extensions: ["mfm"]
    },
    "application/vnd.micro+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.micrografx.flo": {
      source: "iana",
      extensions: ["flo"]
    },
    "application/vnd.micrografx.igx": {
      source: "iana",
      extensions: ["igx"]
    },
    "application/vnd.microsoft.portable-executable": {
      source: "iana"
    },
    "application/vnd.microsoft.windows.thumbnail-cache": {
      source: "iana"
    },
    "application/vnd.miele+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.mif": {
      source: "iana",
      extensions: ["mif"]
    },
    "application/vnd.minisoft-hp3000-save": {
      source: "iana"
    },
    "application/vnd.mitsubishi.misty-guard.trustweb": {
      source: "iana"
    },
    "application/vnd.mobius.daf": {
      source: "iana",
      extensions: ["daf"]
    },
    "application/vnd.mobius.dis": {
      source: "iana",
      extensions: ["dis"]
    },
    "application/vnd.mobius.mbk": {
      source: "iana",
      extensions: ["mbk"]
    },
    "application/vnd.mobius.mqy": {
      source: "iana",
      extensions: ["mqy"]
    },
    "application/vnd.mobius.msl": {
      source: "iana",
      extensions: ["msl"]
    },
    "application/vnd.mobius.plc": {
      source: "iana",
      extensions: ["plc"]
    },
    "application/vnd.mobius.txf": {
      source: "iana",
      extensions: ["txf"]
    },
    "application/vnd.mophun.application": {
      source: "iana",
      extensions: ["mpn"]
    },
    "application/vnd.mophun.certificate": {
      source: "iana",
      extensions: ["mpc"]
    },
    "application/vnd.motorola.flexsuite": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.adsi": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.fis": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.gotap": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.kmr": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.ttc": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.wem": {
      source: "iana"
    },
    "application/vnd.motorola.iprm": {
      source: "iana"
    },
    "application/vnd.mozilla.xul+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xul"]
    },
    "application/vnd.ms-3mfdocument": {
      source: "iana"
    },
    "application/vnd.ms-artgalry": {
      source: "iana",
      extensions: ["cil"]
    },
    "application/vnd.ms-asf": {
      source: "iana"
    },
    "application/vnd.ms-cab-compressed": {
      source: "iana",
      extensions: ["cab"]
    },
    "application/vnd.ms-color.iccprofile": {
      source: "apache"
    },
    "application/vnd.ms-excel": {
      source: "iana",
      compressible: false,
      extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
    },
    "application/vnd.ms-excel.addin.macroenabled.12": {
      source: "iana",
      extensions: ["xlam"]
    },
    "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
      source: "iana",
      extensions: ["xlsb"]
    },
    "application/vnd.ms-excel.sheet.macroenabled.12": {
      source: "iana",
      extensions: ["xlsm"]
    },
    "application/vnd.ms-excel.template.macroenabled.12": {
      source: "iana",
      extensions: ["xltm"]
    },
    "application/vnd.ms-fontobject": {
      source: "iana",
      compressible: true,
      extensions: ["eot"]
    },
    "application/vnd.ms-htmlhelp": {
      source: "iana",
      extensions: ["chm"]
    },
    "application/vnd.ms-ims": {
      source: "iana",
      extensions: ["ims"]
    },
    "application/vnd.ms-lrm": {
      source: "iana",
      extensions: ["lrm"]
    },
    "application/vnd.ms-office.activex+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-officetheme": {
      source: "iana",
      extensions: ["thmx"]
    },
    "application/vnd.ms-opentype": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-outlook": {
      compressible: false,
      extensions: ["msg"]
    },
    "application/vnd.ms-package.obfuscated-opentype": {
      source: "apache"
    },
    "application/vnd.ms-pki.seccat": {
      source: "apache",
      extensions: ["cat"]
    },
    "application/vnd.ms-pki.stl": {
      source: "apache",
      extensions: ["stl"]
    },
    "application/vnd.ms-playready.initiator+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-powerpoint": {
      source: "iana",
      compressible: false,
      extensions: ["ppt", "pps", "pot"]
    },
    "application/vnd.ms-powerpoint.addin.macroenabled.12": {
      source: "iana",
      extensions: ["ppam"]
    },
    "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
      source: "iana",
      extensions: ["pptm"]
    },
    "application/vnd.ms-powerpoint.slide.macroenabled.12": {
      source: "iana",
      extensions: ["sldm"]
    },
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
      source: "iana",
      extensions: ["ppsm"]
    },
    "application/vnd.ms-powerpoint.template.macroenabled.12": {
      source: "iana",
      extensions: ["potm"]
    },
    "application/vnd.ms-printdevicecapabilities+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-printing.printticket+xml": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-printschematicket+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-project": {
      source: "iana",
      extensions: ["mpp", "mpt"]
    },
    "application/vnd.ms-tnef": {
      source: "iana"
    },
    "application/vnd.ms-windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.nwprinting.oob": {
      source: "iana"
    },
    "application/vnd.ms-windows.printerpairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.wsd.oob": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-resp": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-resp": {
      source: "iana"
    },
    "application/vnd.ms-word.document.macroenabled.12": {
      source: "iana",
      extensions: ["docm"]
    },
    "application/vnd.ms-word.template.macroenabled.12": {
      source: "iana",
      extensions: ["dotm"]
    },
    "application/vnd.ms-works": {
      source: "iana",
      extensions: ["wps", "wks", "wcm", "wdb"]
    },
    "application/vnd.ms-wpl": {
      source: "iana",
      extensions: ["wpl"]
    },
    "application/vnd.ms-xpsdocument": {
      source: "iana",
      compressible: false,
      extensions: ["xps"]
    },
    "application/vnd.msa-disk-image": {
      source: "iana"
    },
    "application/vnd.mseq": {
      source: "iana",
      extensions: ["mseq"]
    },
    "application/vnd.msign": {
      source: "iana"
    },
    "application/vnd.multiad.creator": {
      source: "iana"
    },
    "application/vnd.multiad.creator.cif": {
      source: "iana"
    },
    "application/vnd.music-niff": {
      source: "iana"
    },
    "application/vnd.musician": {
      source: "iana",
      extensions: ["mus"]
    },
    "application/vnd.muvee.style": {
      source: "iana",
      extensions: ["msty"]
    },
    "application/vnd.mynfc": {
      source: "iana",
      extensions: ["taglet"]
    },
    "application/vnd.ncd.control": {
      source: "iana"
    },
    "application/vnd.ncd.reference": {
      source: "iana"
    },
    "application/vnd.nearst.inv+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nebumind.line": {
      source: "iana"
    },
    "application/vnd.nervana": {
      source: "iana"
    },
    "application/vnd.netfpx": {
      source: "iana"
    },
    "application/vnd.neurolanguage.nlu": {
      source: "iana",
      extensions: ["nlu"]
    },
    "application/vnd.nimn": {
      source: "iana"
    },
    "application/vnd.nintendo.nitro.rom": {
      source: "iana"
    },
    "application/vnd.nintendo.snes.rom": {
      source: "iana"
    },
    "application/vnd.nitf": {
      source: "iana",
      extensions: ["ntf", "nitf"]
    },
    "application/vnd.noblenet-directory": {
      source: "iana",
      extensions: ["nnd"]
    },
    "application/vnd.noblenet-sealer": {
      source: "iana",
      extensions: ["nns"]
    },
    "application/vnd.noblenet-web": {
      source: "iana",
      extensions: ["nnw"]
    },
    "application/vnd.nokia.catalogs": {
      source: "iana"
    },
    "application/vnd.nokia.conml+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.conml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.iptv.config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.isds-radio-presets": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.landmarkcollection+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.n-gage.ac+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ac"]
    },
    "application/vnd.nokia.n-gage.data": {
      source: "iana",
      extensions: ["ngdat"]
    },
    "application/vnd.nokia.n-gage.symbian.install": {
      source: "iana",
      extensions: ["n-gage"]
    },
    "application/vnd.nokia.ncd": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.radio-preset": {
      source: "iana",
      extensions: ["rpst"]
    },
    "application/vnd.nokia.radio-presets": {
      source: "iana",
      extensions: ["rpss"]
    },
    "application/vnd.novadigm.edm": {
      source: "iana",
      extensions: ["edm"]
    },
    "application/vnd.novadigm.edx": {
      source: "iana",
      extensions: ["edx"]
    },
    "application/vnd.novadigm.ext": {
      source: "iana",
      extensions: ["ext"]
    },
    "application/vnd.ntt-local.content-share": {
      source: "iana"
    },
    "application/vnd.ntt-local.file-transfer": {
      source: "iana"
    },
    "application/vnd.ntt-local.ogw_remote-access": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_remote": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_tcp_stream": {
      source: "iana"
    },
    "application/vnd.oasis.opendocument.chart": {
      source: "iana",
      extensions: ["odc"]
    },
    "application/vnd.oasis.opendocument.chart-template": {
      source: "iana",
      extensions: ["otc"]
    },
    "application/vnd.oasis.opendocument.database": {
      source: "iana",
      extensions: ["odb"]
    },
    "application/vnd.oasis.opendocument.formula": {
      source: "iana",
      extensions: ["odf"]
    },
    "application/vnd.oasis.opendocument.formula-template": {
      source: "iana",
      extensions: ["odft"]
    },
    "application/vnd.oasis.opendocument.graphics": {
      source: "iana",
      compressible: false,
      extensions: ["odg"]
    },
    "application/vnd.oasis.opendocument.graphics-template": {
      source: "iana",
      extensions: ["otg"]
    },
    "application/vnd.oasis.opendocument.image": {
      source: "iana",
      extensions: ["odi"]
    },
    "application/vnd.oasis.opendocument.image-template": {
      source: "iana",
      extensions: ["oti"]
    },
    "application/vnd.oasis.opendocument.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["odp"]
    },
    "application/vnd.oasis.opendocument.presentation-template": {
      source: "iana",
      extensions: ["otp"]
    },
    "application/vnd.oasis.opendocument.spreadsheet": {
      source: "iana",
      compressible: false,
      extensions: ["ods"]
    },
    "application/vnd.oasis.opendocument.spreadsheet-template": {
      source: "iana",
      extensions: ["ots"]
    },
    "application/vnd.oasis.opendocument.text": {
      source: "iana",
      compressible: false,
      extensions: ["odt"]
    },
    "application/vnd.oasis.opendocument.text-master": {
      source: "iana",
      extensions: ["odm"]
    },
    "application/vnd.oasis.opendocument.text-template": {
      source: "iana",
      extensions: ["ott"]
    },
    "application/vnd.oasis.opendocument.text-web": {
      source: "iana",
      extensions: ["oth"]
    },
    "application/vnd.obn": {
      source: "iana"
    },
    "application/vnd.ocf+cbor": {
      source: "iana"
    },
    "application/vnd.oci.image.manifest.v1+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oftn.l10n+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessdownload+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessstreaming+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.cspg-hexbinary": {
      source: "iana"
    },
    "application/vnd.oipf.dae.svg+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.dae.xhtml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.mippvcontrolmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.pae.gem": {
      source: "iana"
    },
    "application/vnd.oipf.spdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.spdlist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.ueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.userprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.olpc-sugar": {
      source: "iana",
      extensions: ["xo"]
    },
    "application/vnd.oma-scws-config": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-request": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-response": {
      source: "iana"
    },
    "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.drm-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.imd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.ltkm": {
      source: "iana"
    },
    "application/vnd.oma.bcast.notification+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.provisioningtrigger": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgboot": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgdd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sgdu": {
      source: "iana"
    },
    "application/vnd.oma.bcast.simple-symbol-container": {
      source: "iana"
    },
    "application/vnd.oma.bcast.smartcard-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sprov+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.stkm": {
      source: "iana"
    },
    "application/vnd.oma.cab-address-book+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-feature-handler+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-pcc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-subs-invite+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-user-prefs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.dcd": {
      source: "iana"
    },
    "application/vnd.oma.dcdc": {
      source: "iana"
    },
    "application/vnd.oma.dd2+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dd2"]
    },
    "application/vnd.oma.drm.risd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.group-usage-list+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+cbor": {
      source: "iana"
    },
    "application/vnd.oma.lwm2m+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+tlv": {
      source: "iana"
    },
    "application/vnd.oma.pal+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.detailed-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.final-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.groups+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.invocation-descriptor+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.optimized-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.push": {
      source: "iana"
    },
    "application/vnd.oma.scidm.messages+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.xcap-directory+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.omads-email+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-file+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-folder+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omaloc-supl-init": {
      source: "iana"
    },
    "application/vnd.onepager": {
      source: "iana"
    },
    "application/vnd.onepagertamp": {
      source: "iana"
    },
    "application/vnd.onepagertamx": {
      source: "iana"
    },
    "application/vnd.onepagertat": {
      source: "iana"
    },
    "application/vnd.onepagertatp": {
      source: "iana"
    },
    "application/vnd.onepagertatx": {
      source: "iana"
    },
    "application/vnd.openblox.game+xml": {
      source: "iana",
      compressible: true,
      extensions: ["obgx"]
    },
    "application/vnd.openblox.game-binary": {
      source: "iana"
    },
    "application/vnd.openeye.oeb": {
      source: "iana"
    },
    "application/vnd.openofficeorg.extension": {
      source: "apache",
      extensions: ["oxt"]
    },
    "application/vnd.openstreetmap.data+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osm"]
    },
    "application/vnd.opentimestamps.ots": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawing+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["pptx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide": {
      source: "iana",
      extensions: ["sldx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
      source: "iana",
      extensions: ["ppsx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template": {
      source: "iana",
      extensions: ["potx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
      source: "iana",
      compressible: false,
      extensions: ["xlsx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
      source: "iana",
      extensions: ["xltx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.theme+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.vmldrawing": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
      source: "iana",
      compressible: false,
      extensions: ["docx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
      source: "iana",
      extensions: ["dotx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.core-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.relationships+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oracle.resource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.orange.indata": {
      source: "iana"
    },
    "application/vnd.osa.netdeploy": {
      source: "iana"
    },
    "application/vnd.osgeo.mapguide.package": {
      source: "iana",
      extensions: ["mgp"]
    },
    "application/vnd.osgi.bundle": {
      source: "iana"
    },
    "application/vnd.osgi.dp": {
      source: "iana",
      extensions: ["dp"]
    },
    "application/vnd.osgi.subsystem": {
      source: "iana",
      extensions: ["esa"]
    },
    "application/vnd.otps.ct-kip+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oxli.countgraph": {
      source: "iana"
    },
    "application/vnd.pagerduty+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.palm": {
      source: "iana",
      extensions: ["pdb", "pqa", "oprc"]
    },
    "application/vnd.panoply": {
      source: "iana"
    },
    "application/vnd.paos.xml": {
      source: "iana"
    },
    "application/vnd.patentdive": {
      source: "iana"
    },
    "application/vnd.patientecommsdoc": {
      source: "iana"
    },
    "application/vnd.pawaafile": {
      source: "iana",
      extensions: ["paw"]
    },
    "application/vnd.pcos": {
      source: "iana"
    },
    "application/vnd.pg.format": {
      source: "iana",
      extensions: ["str"]
    },
    "application/vnd.pg.osasli": {
      source: "iana",
      extensions: ["ei6"]
    },
    "application/vnd.piaccess.application-licence": {
      source: "iana"
    },
    "application/vnd.picsel": {
      source: "iana",
      extensions: ["efif"]
    },
    "application/vnd.pmi.widget": {
      source: "iana",
      extensions: ["wg"]
    },
    "application/vnd.poc.group-advertisement+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.pocketlearn": {
      source: "iana",
      extensions: ["plf"]
    },
    "application/vnd.powerbuilder6": {
      source: "iana",
      extensions: ["pbd"]
    },
    "application/vnd.powerbuilder6-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder7": {
      source: "iana"
    },
    "application/vnd.powerbuilder7-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder75": {
      source: "iana"
    },
    "application/vnd.powerbuilder75-s": {
      source: "iana"
    },
    "application/vnd.preminet": {
      source: "iana"
    },
    "application/vnd.previewsystems.box": {
      source: "iana",
      extensions: ["box"]
    },
    "application/vnd.proteus.magazine": {
      source: "iana",
      extensions: ["mgz"]
    },
    "application/vnd.psfs": {
      source: "iana"
    },
    "application/vnd.publishare-delta-tree": {
      source: "iana",
      extensions: ["qps"]
    },
    "application/vnd.pvi.ptid1": {
      source: "iana",
      extensions: ["ptid"]
    },
    "application/vnd.pwg-multiplexed": {
      source: "iana"
    },
    "application/vnd.pwg-xhtml-print+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.qualcomm.brew-app-res": {
      source: "iana"
    },
    "application/vnd.quarantainenet": {
      source: "iana"
    },
    "application/vnd.quark.quarkxpress": {
      source: "iana",
      extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
    },
    "application/vnd.quobject-quoxdocument": {
      source: "iana"
    },
    "application/vnd.radisys.moml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-stream+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-base+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-detect+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-group+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-speech+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-transform+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rainstor.data": {
      source: "iana"
    },
    "application/vnd.rapid": {
      source: "iana"
    },
    "application/vnd.rar": {
      source: "iana",
      extensions: ["rar"]
    },
    "application/vnd.realvnc.bed": {
      source: "iana",
      extensions: ["bed"]
    },
    "application/vnd.recordare.musicxml": {
      source: "iana",
      extensions: ["mxl"]
    },
    "application/vnd.recordare.musicxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musicxml"]
    },
    "application/vnd.renlearn.rlprint": {
      source: "iana"
    },
    "application/vnd.resilient.logic": {
      source: "iana"
    },
    "application/vnd.restful+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rig.cryptonote": {
      source: "iana",
      extensions: ["cryptonote"]
    },
    "application/vnd.rim.cod": {
      source: "apache",
      extensions: ["cod"]
    },
    "application/vnd.rn-realmedia": {
      source: "apache",
      extensions: ["rm"]
    },
    "application/vnd.rn-realmedia-vbr": {
      source: "apache",
      extensions: ["rmvb"]
    },
    "application/vnd.route66.link66+xml": {
      source: "iana",
      compressible: true,
      extensions: ["link66"]
    },
    "application/vnd.rs-274x": {
      source: "iana"
    },
    "application/vnd.ruckus.download": {
      source: "iana"
    },
    "application/vnd.s3sms": {
      source: "iana"
    },
    "application/vnd.sailingtracker.track": {
      source: "iana",
      extensions: ["st"]
    },
    "application/vnd.sar": {
      source: "iana"
    },
    "application/vnd.sbm.cid": {
      source: "iana"
    },
    "application/vnd.sbm.mid2": {
      source: "iana"
    },
    "application/vnd.scribus": {
      source: "iana"
    },
    "application/vnd.sealed.3df": {
      source: "iana"
    },
    "application/vnd.sealed.csf": {
      source: "iana"
    },
    "application/vnd.sealed.doc": {
      source: "iana"
    },
    "application/vnd.sealed.eml": {
      source: "iana"
    },
    "application/vnd.sealed.mht": {
      source: "iana"
    },
    "application/vnd.sealed.net": {
      source: "iana"
    },
    "application/vnd.sealed.ppt": {
      source: "iana"
    },
    "application/vnd.sealed.tiff": {
      source: "iana"
    },
    "application/vnd.sealed.xls": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.html": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.pdf": {
      source: "iana"
    },
    "application/vnd.seemail": {
      source: "iana",
      extensions: ["see"]
    },
    "application/vnd.seis+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.sema": {
      source: "iana",
      extensions: ["sema"]
    },
    "application/vnd.semd": {
      source: "iana",
      extensions: ["semd"]
    },
    "application/vnd.semf": {
      source: "iana",
      extensions: ["semf"]
    },
    "application/vnd.shade-save-file": {
      source: "iana"
    },
    "application/vnd.shana.informed.formdata": {
      source: "iana",
      extensions: ["ifm"]
    },
    "application/vnd.shana.informed.formtemplate": {
      source: "iana",
      extensions: ["itp"]
    },
    "application/vnd.shana.informed.interchange": {
      source: "iana",
      extensions: ["iif"]
    },
    "application/vnd.shana.informed.package": {
      source: "iana",
      extensions: ["ipk"]
    },
    "application/vnd.shootproof+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shopkick+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shp": {
      source: "iana"
    },
    "application/vnd.shx": {
      source: "iana"
    },
    "application/vnd.sigrok.session": {
      source: "iana"
    },
    "application/vnd.simtech-mindmapper": {
      source: "iana",
      extensions: ["twd", "twds"]
    },
    "application/vnd.siren+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.smaf": {
      source: "iana",
      extensions: ["mmf"]
    },
    "application/vnd.smart.notebook": {
      source: "iana"
    },
    "application/vnd.smart.teacher": {
      source: "iana",
      extensions: ["teacher"]
    },
    "application/vnd.snesdev-page-table": {
      source: "iana"
    },
    "application/vnd.software602.filler.form+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fo"]
    },
    "application/vnd.software602.filler.form-xml-zip": {
      source: "iana"
    },
    "application/vnd.solent.sdkm+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sdkm", "sdkd"]
    },
    "application/vnd.spotfire.dxp": {
      source: "iana",
      extensions: ["dxp"]
    },
    "application/vnd.spotfire.sfs": {
      source: "iana",
      extensions: ["sfs"]
    },
    "application/vnd.sqlite3": {
      source: "iana"
    },
    "application/vnd.sss-cod": {
      source: "iana"
    },
    "application/vnd.sss-dtf": {
      source: "iana"
    },
    "application/vnd.sss-ntf": {
      source: "iana"
    },
    "application/vnd.stardivision.calc": {
      source: "apache",
      extensions: ["sdc"]
    },
    "application/vnd.stardivision.draw": {
      source: "apache",
      extensions: ["sda"]
    },
    "application/vnd.stardivision.impress": {
      source: "apache",
      extensions: ["sdd"]
    },
    "application/vnd.stardivision.math": {
      source: "apache",
      extensions: ["smf"]
    },
    "application/vnd.stardivision.writer": {
      source: "apache",
      extensions: ["sdw", "vor"]
    },
    "application/vnd.stardivision.writer-global": {
      source: "apache",
      extensions: ["sgl"]
    },
    "application/vnd.stepmania.package": {
      source: "iana",
      extensions: ["smzip"]
    },
    "application/vnd.stepmania.stepchart": {
      source: "iana",
      extensions: ["sm"]
    },
    "application/vnd.street-stream": {
      source: "iana"
    },
    "application/vnd.sun.wadl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wadl"]
    },
    "application/vnd.sun.xml.calc": {
      source: "apache",
      extensions: ["sxc"]
    },
    "application/vnd.sun.xml.calc.template": {
      source: "apache",
      extensions: ["stc"]
    },
    "application/vnd.sun.xml.draw": {
      source: "apache",
      extensions: ["sxd"]
    },
    "application/vnd.sun.xml.draw.template": {
      source: "apache",
      extensions: ["std"]
    },
    "application/vnd.sun.xml.impress": {
      source: "apache",
      extensions: ["sxi"]
    },
    "application/vnd.sun.xml.impress.template": {
      source: "apache",
      extensions: ["sti"]
    },
    "application/vnd.sun.xml.math": {
      source: "apache",
      extensions: ["sxm"]
    },
    "application/vnd.sun.xml.writer": {
      source: "apache",
      extensions: ["sxw"]
    },
    "application/vnd.sun.xml.writer.global": {
      source: "apache",
      extensions: ["sxg"]
    },
    "application/vnd.sun.xml.writer.template": {
      source: "apache",
      extensions: ["stw"]
    },
    "application/vnd.sus-calendar": {
      source: "iana",
      extensions: ["sus", "susp"]
    },
    "application/vnd.svd": {
      source: "iana",
      extensions: ["svd"]
    },
    "application/vnd.swiftview-ics": {
      source: "iana"
    },
    "application/vnd.sycle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.symbian.install": {
      source: "apache",
      extensions: ["sis", "sisx"]
    },
    "application/vnd.syncml+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xsm"]
    },
    "application/vnd.syncml.dm+wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["bdm"]
    },
    "application/vnd.syncml.dm+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xdm"]
    },
    "application/vnd.syncml.dm.notification": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["ddf"]
    },
    "application/vnd.syncml.dmtnds+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmtnds+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.syncml.ds.notification": {
      source: "iana"
    },
    "application/vnd.tableschema+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tao.intent-module-archive": {
      source: "iana",
      extensions: ["tao"]
    },
    "application/vnd.tcpdump.pcap": {
      source: "iana",
      extensions: ["pcap", "cap", "dmp"]
    },
    "application/vnd.think-cell.ppttc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tmd.mediaflex.api+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tml": {
      source: "iana"
    },
    "application/vnd.tmobile-livetv": {
      source: "iana",
      extensions: ["tmo"]
    },
    "application/vnd.tri.onesource": {
      source: "iana"
    },
    "application/vnd.trid.tpt": {
      source: "iana",
      extensions: ["tpt"]
    },
    "application/vnd.triscape.mxs": {
      source: "iana",
      extensions: ["mxs"]
    },
    "application/vnd.trueapp": {
      source: "iana",
      extensions: ["tra"]
    },
    "application/vnd.truedoc": {
      source: "iana"
    },
    "application/vnd.ubisoft.webplayer": {
      source: "iana"
    },
    "application/vnd.ufdl": {
      source: "iana",
      extensions: ["ufd", "ufdl"]
    },
    "application/vnd.uiq.theme": {
      source: "iana",
      extensions: ["utz"]
    },
    "application/vnd.umajin": {
      source: "iana",
      extensions: ["umj"]
    },
    "application/vnd.unity": {
      source: "iana",
      extensions: ["unityweb"]
    },
    "application/vnd.uoml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uoml"]
    },
    "application/vnd.uplanet.alert": {
      source: "iana"
    },
    "application/vnd.uplanet.alert-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.channel": {
      source: "iana"
    },
    "application/vnd.uplanet.channel-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.list": {
      source: "iana"
    },
    "application/vnd.uplanet.list-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.signal": {
      source: "iana"
    },
    "application/vnd.uri-map": {
      source: "iana"
    },
    "application/vnd.valve.source.material": {
      source: "iana"
    },
    "application/vnd.vcx": {
      source: "iana",
      extensions: ["vcx"]
    },
    "application/vnd.vd-study": {
      source: "iana"
    },
    "application/vnd.vectorworks": {
      source: "iana"
    },
    "application/vnd.vel+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.verimatrix.vcas": {
      source: "iana"
    },
    "application/vnd.veritone.aion+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.veryant.thin": {
      source: "iana"
    },
    "application/vnd.ves.encrypted": {
      source: "iana"
    },
    "application/vnd.vidsoft.vidconference": {
      source: "iana"
    },
    "application/vnd.visio": {
      source: "iana",
      extensions: ["vsd", "vst", "vss", "vsw"]
    },
    "application/vnd.visionary": {
      source: "iana",
      extensions: ["vis"]
    },
    "application/vnd.vividence.scriptfile": {
      source: "iana"
    },
    "application/vnd.vsf": {
      source: "iana",
      extensions: ["vsf"]
    },
    "application/vnd.wap.sic": {
      source: "iana"
    },
    "application/vnd.wap.slc": {
      source: "iana"
    },
    "application/vnd.wap.wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["wbxml"]
    },
    "application/vnd.wap.wmlc": {
      source: "iana",
      extensions: ["wmlc"]
    },
    "application/vnd.wap.wmlscriptc": {
      source: "iana",
      extensions: ["wmlsc"]
    },
    "application/vnd.webturbo": {
      source: "iana",
      extensions: ["wtb"]
    },
    "application/vnd.wfa.dpp": {
      source: "iana"
    },
    "application/vnd.wfa.p2p": {
      source: "iana"
    },
    "application/vnd.wfa.wsc": {
      source: "iana"
    },
    "application/vnd.windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.wmc": {
      source: "iana"
    },
    "application/vnd.wmf.bootstrap": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica.package": {
      source: "iana"
    },
    "application/vnd.wolfram.player": {
      source: "iana",
      extensions: ["nbp"]
    },
    "application/vnd.wordperfect": {
      source: "iana",
      extensions: ["wpd"]
    },
    "application/vnd.wqd": {
      source: "iana",
      extensions: ["wqd"]
    },
    "application/vnd.wrq-hp3000-labelled": {
      source: "iana"
    },
    "application/vnd.wt.stf": {
      source: "iana",
      extensions: ["stf"]
    },
    "application/vnd.wv.csp+wbxml": {
      source: "iana"
    },
    "application/vnd.wv.csp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.wv.ssp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xacml+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xara": {
      source: "iana",
      extensions: ["xar"]
    },
    "application/vnd.xfdl": {
      source: "iana",
      extensions: ["xfdl"]
    },
    "application/vnd.xfdl.webform": {
      source: "iana"
    },
    "application/vnd.xmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xmpie.cpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.dpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.plan": {
      source: "iana"
    },
    "application/vnd.xmpie.ppkg": {
      source: "iana"
    },
    "application/vnd.xmpie.xlim": {
      source: "iana"
    },
    "application/vnd.yamaha.hv-dic": {
      source: "iana",
      extensions: ["hvd"]
    },
    "application/vnd.yamaha.hv-script": {
      source: "iana",
      extensions: ["hvs"]
    },
    "application/vnd.yamaha.hv-voice": {
      source: "iana",
      extensions: ["hvp"]
    },
    "application/vnd.yamaha.openscoreformat": {
      source: "iana",
      extensions: ["osf"]
    },
    "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osfpvg"]
    },
    "application/vnd.yamaha.remote-setup": {
      source: "iana"
    },
    "application/vnd.yamaha.smaf-audio": {
      source: "iana",
      extensions: ["saf"]
    },
    "application/vnd.yamaha.smaf-phrase": {
      source: "iana",
      extensions: ["spf"]
    },
    "application/vnd.yamaha.through-ngn": {
      source: "iana"
    },
    "application/vnd.yamaha.tunnel-udpencap": {
      source: "iana"
    },
    "application/vnd.yaoweme": {
      source: "iana"
    },
    "application/vnd.yellowriver-custom-menu": {
      source: "iana",
      extensions: ["cmp"]
    },
    "application/vnd.youtube.yt": {
      source: "iana"
    },
    "application/vnd.zul": {
      source: "iana",
      extensions: ["zir", "zirz"]
    },
    "application/vnd.zzazz.deck+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zaz"]
    },
    "application/voicexml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["vxml"]
    },
    "application/voucher-cms+json": {
      source: "iana",
      compressible: true
    },
    "application/vq-rtcpxr": {
      source: "iana"
    },
    "application/wasm": {
      source: "iana",
      compressible: true,
      extensions: ["wasm"]
    },
    "application/watcherinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/webpush-options+json": {
      source: "iana",
      compressible: true
    },
    "application/whoispp-query": {
      source: "iana"
    },
    "application/whoispp-response": {
      source: "iana"
    },
    "application/widget": {
      source: "iana",
      extensions: ["wgt"]
    },
    "application/winhlp": {
      source: "apache",
      extensions: ["hlp"]
    },
    "application/wita": {
      source: "iana"
    },
    "application/wordperfect5.1": {
      source: "iana"
    },
    "application/wsdl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wsdl"]
    },
    "application/wspolicy+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wspolicy"]
    },
    "application/x-7z-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["7z"]
    },
    "application/x-abiword": {
      source: "apache",
      extensions: ["abw"]
    },
    "application/x-ace-compressed": {
      source: "apache",
      extensions: ["ace"]
    },
    "application/x-amf": {
      source: "apache"
    },
    "application/x-apple-diskimage": {
      source: "apache",
      extensions: ["dmg"]
    },
    "application/x-arj": {
      compressible: false,
      extensions: ["arj"]
    },
    "application/x-authorware-bin": {
      source: "apache",
      extensions: ["aab", "x32", "u32", "vox"]
    },
    "application/x-authorware-map": {
      source: "apache",
      extensions: ["aam"]
    },
    "application/x-authorware-seg": {
      source: "apache",
      extensions: ["aas"]
    },
    "application/x-bcpio": {
      source: "apache",
      extensions: ["bcpio"]
    },
    "application/x-bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/x-bittorrent": {
      source: "apache",
      extensions: ["torrent"]
    },
    "application/x-blorb": {
      source: "apache",
      extensions: ["blb", "blorb"]
    },
    "application/x-bzip": {
      source: "apache",
      compressible: false,
      extensions: ["bz"]
    },
    "application/x-bzip2": {
      source: "apache",
      compressible: false,
      extensions: ["bz2", "boz"]
    },
    "application/x-cbr": {
      source: "apache",
      extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
    },
    "application/x-cdlink": {
      source: "apache",
      extensions: ["vcd"]
    },
    "application/x-cfs-compressed": {
      source: "apache",
      extensions: ["cfs"]
    },
    "application/x-chat": {
      source: "apache",
      extensions: ["chat"]
    },
    "application/x-chess-pgn": {
      source: "apache",
      extensions: ["pgn"]
    },
    "application/x-chrome-extension": {
      extensions: ["crx"]
    },
    "application/x-cocoa": {
      source: "nginx",
      extensions: ["cco"]
    },
    "application/x-compress": {
      source: "apache"
    },
    "application/x-conference": {
      source: "apache",
      extensions: ["nsc"]
    },
    "application/x-cpio": {
      source: "apache",
      extensions: ["cpio"]
    },
    "application/x-csh": {
      source: "apache",
      extensions: ["csh"]
    },
    "application/x-deb": {
      compressible: false
    },
    "application/x-debian-package": {
      source: "apache",
      extensions: ["deb", "udeb"]
    },
    "application/x-dgc-compressed": {
      source: "apache",
      extensions: ["dgc"]
    },
    "application/x-director": {
      source: "apache",
      extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
    },
    "application/x-doom": {
      source: "apache",
      extensions: ["wad"]
    },
    "application/x-dtbncx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ncx"]
    },
    "application/x-dtbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dtb"]
    },
    "application/x-dtbresource+xml": {
      source: "apache",
      compressible: true,
      extensions: ["res"]
    },
    "application/x-dvi": {
      source: "apache",
      compressible: false,
      extensions: ["dvi"]
    },
    "application/x-envoy": {
      source: "apache",
      extensions: ["evy"]
    },
    "application/x-eva": {
      source: "apache",
      extensions: ["eva"]
    },
    "application/x-font-bdf": {
      source: "apache",
      extensions: ["bdf"]
    },
    "application/x-font-dos": {
      source: "apache"
    },
    "application/x-font-framemaker": {
      source: "apache"
    },
    "application/x-font-ghostscript": {
      source: "apache",
      extensions: ["gsf"]
    },
    "application/x-font-libgrx": {
      source: "apache"
    },
    "application/x-font-linux-psf": {
      source: "apache",
      extensions: ["psf"]
    },
    "application/x-font-pcf": {
      source: "apache",
      extensions: ["pcf"]
    },
    "application/x-font-snf": {
      source: "apache",
      extensions: ["snf"]
    },
    "application/x-font-speedo": {
      source: "apache"
    },
    "application/x-font-sunos-news": {
      source: "apache"
    },
    "application/x-font-type1": {
      source: "apache",
      extensions: ["pfa", "pfb", "pfm", "afm"]
    },
    "application/x-font-vfont": {
      source: "apache"
    },
    "application/x-freearc": {
      source: "apache",
      extensions: ["arc"]
    },
    "application/x-futuresplash": {
      source: "apache",
      extensions: ["spl"]
    },
    "application/x-gca-compressed": {
      source: "apache",
      extensions: ["gca"]
    },
    "application/x-glulx": {
      source: "apache",
      extensions: ["ulx"]
    },
    "application/x-gnumeric": {
      source: "apache",
      extensions: ["gnumeric"]
    },
    "application/x-gramps-xml": {
      source: "apache",
      extensions: ["gramps"]
    },
    "application/x-gtar": {
      source: "apache",
      extensions: ["gtar"]
    },
    "application/x-gzip": {
      source: "apache"
    },
    "application/x-hdf": {
      source: "apache",
      extensions: ["hdf"]
    },
    "application/x-httpd-php": {
      compressible: true,
      extensions: ["php"]
    },
    "application/x-install-instructions": {
      source: "apache",
      extensions: ["install"]
    },
    "application/x-iso9660-image": {
      source: "apache",
      extensions: ["iso"]
    },
    "application/x-java-archive-diff": {
      source: "nginx",
      extensions: ["jardiff"]
    },
    "application/x-java-jnlp-file": {
      source: "apache",
      compressible: false,
      extensions: ["jnlp"]
    },
    "application/x-javascript": {
      compressible: true
    },
    "application/x-keepass2": {
      extensions: ["kdbx"]
    },
    "application/x-latex": {
      source: "apache",
      compressible: false,
      extensions: ["latex"]
    },
    "application/x-lua-bytecode": {
      extensions: ["luac"]
    },
    "application/x-lzh-compressed": {
      source: "apache",
      extensions: ["lzh", "lha"]
    },
    "application/x-makeself": {
      source: "nginx",
      extensions: ["run"]
    },
    "application/x-mie": {
      source: "apache",
      extensions: ["mie"]
    },
    "application/x-mobipocket-ebook": {
      source: "apache",
      extensions: ["prc", "mobi"]
    },
    "application/x-mpegurl": {
      compressible: false
    },
    "application/x-ms-application": {
      source: "apache",
      extensions: ["application"]
    },
    "application/x-ms-shortcut": {
      source: "apache",
      extensions: ["lnk"]
    },
    "application/x-ms-wmd": {
      source: "apache",
      extensions: ["wmd"]
    },
    "application/x-ms-wmz": {
      source: "apache",
      extensions: ["wmz"]
    },
    "application/x-ms-xbap": {
      source: "apache",
      extensions: ["xbap"]
    },
    "application/x-msaccess": {
      source: "apache",
      extensions: ["mdb"]
    },
    "application/x-msbinder": {
      source: "apache",
      extensions: ["obd"]
    },
    "application/x-mscardfile": {
      source: "apache",
      extensions: ["crd"]
    },
    "application/x-msclip": {
      source: "apache",
      extensions: ["clp"]
    },
    "application/x-msdos-program": {
      extensions: ["exe"]
    },
    "application/x-msdownload": {
      source: "apache",
      extensions: ["exe", "dll", "com", "bat", "msi"]
    },
    "application/x-msmediaview": {
      source: "apache",
      extensions: ["mvb", "m13", "m14"]
    },
    "application/x-msmetafile": {
      source: "apache",
      extensions: ["wmf", "wmz", "emf", "emz"]
    },
    "application/x-msmoney": {
      source: "apache",
      extensions: ["mny"]
    },
    "application/x-mspublisher": {
      source: "apache",
      extensions: ["pub"]
    },
    "application/x-msschedule": {
      source: "apache",
      extensions: ["scd"]
    },
    "application/x-msterminal": {
      source: "apache",
      extensions: ["trm"]
    },
    "application/x-mswrite": {
      source: "apache",
      extensions: ["wri"]
    },
    "application/x-netcdf": {
      source: "apache",
      extensions: ["nc", "cdf"]
    },
    "application/x-ns-proxy-autoconfig": {
      compressible: true,
      extensions: ["pac"]
    },
    "application/x-nzb": {
      source: "apache",
      extensions: ["nzb"]
    },
    "application/x-perl": {
      source: "nginx",
      extensions: ["pl", "pm"]
    },
    "application/x-pilot": {
      source: "nginx",
      extensions: ["prc", "pdb"]
    },
    "application/x-pkcs12": {
      source: "apache",
      compressible: false,
      extensions: ["p12", "pfx"]
    },
    "application/x-pkcs7-certificates": {
      source: "apache",
      extensions: ["p7b", "spc"]
    },
    "application/x-pkcs7-certreqresp": {
      source: "apache",
      extensions: ["p7r"]
    },
    "application/x-pki-message": {
      source: "iana"
    },
    "application/x-rar-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["rar"]
    },
    "application/x-redhat-package-manager": {
      source: "nginx",
      extensions: ["rpm"]
    },
    "application/x-research-info-systems": {
      source: "apache",
      extensions: ["ris"]
    },
    "application/x-sea": {
      source: "nginx",
      extensions: ["sea"]
    },
    "application/x-sh": {
      source: "apache",
      compressible: true,
      extensions: ["sh"]
    },
    "application/x-shar": {
      source: "apache",
      extensions: ["shar"]
    },
    "application/x-shockwave-flash": {
      source: "apache",
      compressible: false,
      extensions: ["swf"]
    },
    "application/x-silverlight-app": {
      source: "apache",
      extensions: ["xap"]
    },
    "application/x-sql": {
      source: "apache",
      extensions: ["sql"]
    },
    "application/x-stuffit": {
      source: "apache",
      compressible: false,
      extensions: ["sit"]
    },
    "application/x-stuffitx": {
      source: "apache",
      extensions: ["sitx"]
    },
    "application/x-subrip": {
      source: "apache",
      extensions: ["srt"]
    },
    "application/x-sv4cpio": {
      source: "apache",
      extensions: ["sv4cpio"]
    },
    "application/x-sv4crc": {
      source: "apache",
      extensions: ["sv4crc"]
    },
    "application/x-t3vm-image": {
      source: "apache",
      extensions: ["t3"]
    },
    "application/x-tads": {
      source: "apache",
      extensions: ["gam"]
    },
    "application/x-tar": {
      source: "apache",
      compressible: true,
      extensions: ["tar"]
    },
    "application/x-tcl": {
      source: "apache",
      extensions: ["tcl", "tk"]
    },
    "application/x-tex": {
      source: "apache",
      extensions: ["tex"]
    },
    "application/x-tex-tfm": {
      source: "apache",
      extensions: ["tfm"]
    },
    "application/x-texinfo": {
      source: "apache",
      extensions: ["texinfo", "texi"]
    },
    "application/x-tgif": {
      source: "apache",
      extensions: ["obj"]
    },
    "application/x-ustar": {
      source: "apache",
      extensions: ["ustar"]
    },
    "application/x-virtualbox-hdd": {
      compressible: true,
      extensions: ["hdd"]
    },
    "application/x-virtualbox-ova": {
      compressible: true,
      extensions: ["ova"]
    },
    "application/x-virtualbox-ovf": {
      compressible: true,
      extensions: ["ovf"]
    },
    "application/x-virtualbox-vbox": {
      compressible: true,
      extensions: ["vbox"]
    },
    "application/x-virtualbox-vbox-extpack": {
      compressible: false,
      extensions: ["vbox-extpack"]
    },
    "application/x-virtualbox-vdi": {
      compressible: true,
      extensions: ["vdi"]
    },
    "application/x-virtualbox-vhd": {
      compressible: true,
      extensions: ["vhd"]
    },
    "application/x-virtualbox-vmdk": {
      compressible: true,
      extensions: ["vmdk"]
    },
    "application/x-wais-source": {
      source: "apache",
      extensions: ["src"]
    },
    "application/x-web-app-manifest+json": {
      compressible: true,
      extensions: ["webapp"]
    },
    "application/x-www-form-urlencoded": {
      source: "iana",
      compressible: true
    },
    "application/x-x509-ca-cert": {
      source: "iana",
      extensions: ["der", "crt", "pem"]
    },
    "application/x-x509-ca-ra-cert": {
      source: "iana"
    },
    "application/x-x509-next-ca-cert": {
      source: "iana"
    },
    "application/x-xfig": {
      source: "apache",
      extensions: ["fig"]
    },
    "application/x-xliff+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/x-xpinstall": {
      source: "apache",
      compressible: false,
      extensions: ["xpi"]
    },
    "application/x-xz": {
      source: "apache",
      extensions: ["xz"]
    },
    "application/x-zmachine": {
      source: "apache",
      extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
    },
    "application/x400-bp": {
      source: "iana"
    },
    "application/xacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/xaml+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xaml"]
    },
    "application/xcap-att+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xav"]
    },
    "application/xcap-caps+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xca"]
    },
    "application/xcap-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdf"]
    },
    "application/xcap-el+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xel"]
    },
    "application/xcap-error+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcap-ns+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xns"]
    },
    "application/xcon-conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcon-conference-info-diff+xml": {
      source: "iana",
      compressible: true
    },
    "application/xenc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xenc"]
    },
    "application/xhtml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xhtml", "xht"]
    },
    "application/xhtml-voice+xml": {
      source: "apache",
      compressible: true
    },
    "application/xliff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml", "xsl", "xsd", "rng"]
    },
    "application/xml-dtd": {
      source: "iana",
      compressible: true,
      extensions: ["dtd"]
    },
    "application/xml-external-parsed-entity": {
      source: "iana"
    },
    "application/xml-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/xmpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/xop+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xop"]
    },
    "application/xproc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xpl"]
    },
    "application/xslt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xsl", "xslt"]
    },
    "application/xspf+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xspf"]
    },
    "application/xv+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mxml", "xhvml", "xvml", "xvm"]
    },
    "application/yang": {
      source: "iana",
      extensions: ["yang"]
    },
    "application/yang-data+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-data+xml": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/yin+xml": {
      source: "iana",
      compressible: true,
      extensions: ["yin"]
    },
    "application/zip": {
      source: "iana",
      compressible: false,
      extensions: ["zip"]
    },
    "application/zlib": {
      source: "iana"
    },
    "application/zstd": {
      source: "iana"
    },
    "audio/1d-interleaved-parityfec": {
      source: "iana"
    },
    "audio/32kadpcm": {
      source: "iana"
    },
    "audio/3gpp": {
      source: "iana",
      compressible: false,
      extensions: ["3gpp"]
    },
    "audio/3gpp2": {
      source: "iana"
    },
    "audio/aac": {
      source: "iana"
    },
    "audio/ac3": {
      source: "iana"
    },
    "audio/adpcm": {
      source: "apache",
      extensions: ["adp"]
    },
    "audio/amr": {
      source: "iana",
      extensions: ["amr"]
    },
    "audio/amr-wb": {
      source: "iana"
    },
    "audio/amr-wb+": {
      source: "iana"
    },
    "audio/aptx": {
      source: "iana"
    },
    "audio/asc": {
      source: "iana"
    },
    "audio/atrac-advanced-lossless": {
      source: "iana"
    },
    "audio/atrac-x": {
      source: "iana"
    },
    "audio/atrac3": {
      source: "iana"
    },
    "audio/basic": {
      source: "iana",
      compressible: false,
      extensions: ["au", "snd"]
    },
    "audio/bv16": {
      source: "iana"
    },
    "audio/bv32": {
      source: "iana"
    },
    "audio/clearmode": {
      source: "iana"
    },
    "audio/cn": {
      source: "iana"
    },
    "audio/dat12": {
      source: "iana"
    },
    "audio/dls": {
      source: "iana"
    },
    "audio/dsr-es201108": {
      source: "iana"
    },
    "audio/dsr-es202050": {
      source: "iana"
    },
    "audio/dsr-es202211": {
      source: "iana"
    },
    "audio/dsr-es202212": {
      source: "iana"
    },
    "audio/dv": {
      source: "iana"
    },
    "audio/dvi4": {
      source: "iana"
    },
    "audio/eac3": {
      source: "iana"
    },
    "audio/encaprtp": {
      source: "iana"
    },
    "audio/evrc": {
      source: "iana"
    },
    "audio/evrc-qcp": {
      source: "iana"
    },
    "audio/evrc0": {
      source: "iana"
    },
    "audio/evrc1": {
      source: "iana"
    },
    "audio/evrcb": {
      source: "iana"
    },
    "audio/evrcb0": {
      source: "iana"
    },
    "audio/evrcb1": {
      source: "iana"
    },
    "audio/evrcnw": {
      source: "iana"
    },
    "audio/evrcnw0": {
      source: "iana"
    },
    "audio/evrcnw1": {
      source: "iana"
    },
    "audio/evrcwb": {
      source: "iana"
    },
    "audio/evrcwb0": {
      source: "iana"
    },
    "audio/evrcwb1": {
      source: "iana"
    },
    "audio/evs": {
      source: "iana"
    },
    "audio/flexfec": {
      source: "iana"
    },
    "audio/fwdred": {
      source: "iana"
    },
    "audio/g711-0": {
      source: "iana"
    },
    "audio/g719": {
      source: "iana"
    },
    "audio/g722": {
      source: "iana"
    },
    "audio/g7221": {
      source: "iana"
    },
    "audio/g723": {
      source: "iana"
    },
    "audio/g726-16": {
      source: "iana"
    },
    "audio/g726-24": {
      source: "iana"
    },
    "audio/g726-32": {
      source: "iana"
    },
    "audio/g726-40": {
      source: "iana"
    },
    "audio/g728": {
      source: "iana"
    },
    "audio/g729": {
      source: "iana"
    },
    "audio/g7291": {
      source: "iana"
    },
    "audio/g729d": {
      source: "iana"
    },
    "audio/g729e": {
      source: "iana"
    },
    "audio/gsm": {
      source: "iana"
    },
    "audio/gsm-efr": {
      source: "iana"
    },
    "audio/gsm-hr-08": {
      source: "iana"
    },
    "audio/ilbc": {
      source: "iana"
    },
    "audio/ip-mr_v2.5": {
      source: "iana"
    },
    "audio/isac": {
      source: "apache"
    },
    "audio/l16": {
      source: "iana"
    },
    "audio/l20": {
      source: "iana"
    },
    "audio/l24": {
      source: "iana",
      compressible: false
    },
    "audio/l8": {
      source: "iana"
    },
    "audio/lpc": {
      source: "iana"
    },
    "audio/melp": {
      source: "iana"
    },
    "audio/melp1200": {
      source: "iana"
    },
    "audio/melp2400": {
      source: "iana"
    },
    "audio/melp600": {
      source: "iana"
    },
    "audio/mhas": {
      source: "iana"
    },
    "audio/midi": {
      source: "apache",
      extensions: ["mid", "midi", "kar", "rmi"]
    },
    "audio/mobile-xmf": {
      source: "iana",
      extensions: ["mxmf"]
    },
    "audio/mp3": {
      compressible: false,
      extensions: ["mp3"]
    },
    "audio/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["m4a", "mp4a"]
    },
    "audio/mp4a-latm": {
      source: "iana"
    },
    "audio/mpa": {
      source: "iana"
    },
    "audio/mpa-robust": {
      source: "iana"
    },
    "audio/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
    },
    "audio/mpeg4-generic": {
      source: "iana"
    },
    "audio/musepack": {
      source: "apache"
    },
    "audio/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["oga", "ogg", "spx", "opus"]
    },
    "audio/opus": {
      source: "iana"
    },
    "audio/parityfec": {
      source: "iana"
    },
    "audio/pcma": {
      source: "iana"
    },
    "audio/pcma-wb": {
      source: "iana"
    },
    "audio/pcmu": {
      source: "iana"
    },
    "audio/pcmu-wb": {
      source: "iana"
    },
    "audio/prs.sid": {
      source: "iana"
    },
    "audio/qcelp": {
      source: "iana"
    },
    "audio/raptorfec": {
      source: "iana"
    },
    "audio/red": {
      source: "iana"
    },
    "audio/rtp-enc-aescm128": {
      source: "iana"
    },
    "audio/rtp-midi": {
      source: "iana"
    },
    "audio/rtploopback": {
      source: "iana"
    },
    "audio/rtx": {
      source: "iana"
    },
    "audio/s3m": {
      source: "apache",
      extensions: ["s3m"]
    },
    "audio/scip": {
      source: "iana"
    },
    "audio/silk": {
      source: "apache",
      extensions: ["sil"]
    },
    "audio/smv": {
      source: "iana"
    },
    "audio/smv-qcp": {
      source: "iana"
    },
    "audio/smv0": {
      source: "iana"
    },
    "audio/sofa": {
      source: "iana"
    },
    "audio/sp-midi": {
      source: "iana"
    },
    "audio/speex": {
      source: "iana"
    },
    "audio/t140c": {
      source: "iana"
    },
    "audio/t38": {
      source: "iana"
    },
    "audio/telephone-event": {
      source: "iana"
    },
    "audio/tetra_acelp": {
      source: "iana"
    },
    "audio/tetra_acelp_bb": {
      source: "iana"
    },
    "audio/tone": {
      source: "iana"
    },
    "audio/tsvcis": {
      source: "iana"
    },
    "audio/uemclip": {
      source: "iana"
    },
    "audio/ulpfec": {
      source: "iana"
    },
    "audio/usac": {
      source: "iana"
    },
    "audio/vdvi": {
      source: "iana"
    },
    "audio/vmr-wb": {
      source: "iana"
    },
    "audio/vnd.3gpp.iufp": {
      source: "iana"
    },
    "audio/vnd.4sb": {
      source: "iana"
    },
    "audio/vnd.audiokoz": {
      source: "iana"
    },
    "audio/vnd.celp": {
      source: "iana"
    },
    "audio/vnd.cisco.nse": {
      source: "iana"
    },
    "audio/vnd.cmles.radio-events": {
      source: "iana"
    },
    "audio/vnd.cns.anp1": {
      source: "iana"
    },
    "audio/vnd.cns.inf1": {
      source: "iana"
    },
    "audio/vnd.dece.audio": {
      source: "iana",
      extensions: ["uva", "uvva"]
    },
    "audio/vnd.digital-winds": {
      source: "iana",
      extensions: ["eol"]
    },
    "audio/vnd.dlna.adts": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.1": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.2": {
      source: "iana"
    },
    "audio/vnd.dolby.mlp": {
      source: "iana"
    },
    "audio/vnd.dolby.mps": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2x": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2z": {
      source: "iana"
    },
    "audio/vnd.dolby.pulse.1": {
      source: "iana"
    },
    "audio/vnd.dra": {
      source: "iana",
      extensions: ["dra"]
    },
    "audio/vnd.dts": {
      source: "iana",
      extensions: ["dts"]
    },
    "audio/vnd.dts.hd": {
      source: "iana",
      extensions: ["dtshd"]
    },
    "audio/vnd.dts.uhd": {
      source: "iana"
    },
    "audio/vnd.dvb.file": {
      source: "iana"
    },
    "audio/vnd.everad.plj": {
      source: "iana"
    },
    "audio/vnd.hns.audio": {
      source: "iana"
    },
    "audio/vnd.lucent.voice": {
      source: "iana",
      extensions: ["lvp"]
    },
    "audio/vnd.ms-playready.media.pya": {
      source: "iana",
      extensions: ["pya"]
    },
    "audio/vnd.nokia.mobile-xmf": {
      source: "iana"
    },
    "audio/vnd.nortel.vbk": {
      source: "iana"
    },
    "audio/vnd.nuera.ecelp4800": {
      source: "iana",
      extensions: ["ecelp4800"]
    },
    "audio/vnd.nuera.ecelp7470": {
      source: "iana",
      extensions: ["ecelp7470"]
    },
    "audio/vnd.nuera.ecelp9600": {
      source: "iana",
      extensions: ["ecelp9600"]
    },
    "audio/vnd.octel.sbc": {
      source: "iana"
    },
    "audio/vnd.presonus.multitrack": {
      source: "iana"
    },
    "audio/vnd.qcelp": {
      source: "iana"
    },
    "audio/vnd.rhetorex.32kadpcm": {
      source: "iana"
    },
    "audio/vnd.rip": {
      source: "iana",
      extensions: ["rip"]
    },
    "audio/vnd.rn-realaudio": {
      compressible: false
    },
    "audio/vnd.sealedmedia.softseal.mpeg": {
      source: "iana"
    },
    "audio/vnd.vmx.cvsd": {
      source: "iana"
    },
    "audio/vnd.wave": {
      compressible: false
    },
    "audio/vorbis": {
      source: "iana",
      compressible: false
    },
    "audio/vorbis-config": {
      source: "iana"
    },
    "audio/wav": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/wave": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/webm": {
      source: "apache",
      compressible: false,
      extensions: ["weba"]
    },
    "audio/x-aac": {
      source: "apache",
      compressible: false,
      extensions: ["aac"]
    },
    "audio/x-aiff": {
      source: "apache",
      extensions: ["aif", "aiff", "aifc"]
    },
    "audio/x-caf": {
      source: "apache",
      compressible: false,
      extensions: ["caf"]
    },
    "audio/x-flac": {
      source: "apache",
      extensions: ["flac"]
    },
    "audio/x-m4a": {
      source: "nginx",
      extensions: ["m4a"]
    },
    "audio/x-matroska": {
      source: "apache",
      extensions: ["mka"]
    },
    "audio/x-mpegurl": {
      source: "apache",
      extensions: ["m3u"]
    },
    "audio/x-ms-wax": {
      source: "apache",
      extensions: ["wax"]
    },
    "audio/x-ms-wma": {
      source: "apache",
      extensions: ["wma"]
    },
    "audio/x-pn-realaudio": {
      source: "apache",
      extensions: ["ram", "ra"]
    },
    "audio/x-pn-realaudio-plugin": {
      source: "apache",
      extensions: ["rmp"]
    },
    "audio/x-realaudio": {
      source: "nginx",
      extensions: ["ra"]
    },
    "audio/x-tta": {
      source: "apache"
    },
    "audio/x-wav": {
      source: "apache",
      extensions: ["wav"]
    },
    "audio/xm": {
      source: "apache",
      extensions: ["xm"]
    },
    "chemical/x-cdx": {
      source: "apache",
      extensions: ["cdx"]
    },
    "chemical/x-cif": {
      source: "apache",
      extensions: ["cif"]
    },
    "chemical/x-cmdf": {
      source: "apache",
      extensions: ["cmdf"]
    },
    "chemical/x-cml": {
      source: "apache",
      extensions: ["cml"]
    },
    "chemical/x-csml": {
      source: "apache",
      extensions: ["csml"]
    },
    "chemical/x-pdb": {
      source: "apache"
    },
    "chemical/x-xyz": {
      source: "apache",
      extensions: ["xyz"]
    },
    "font/collection": {
      source: "iana",
      extensions: ["ttc"]
    },
    "font/otf": {
      source: "iana",
      compressible: true,
      extensions: ["otf"]
    },
    "font/sfnt": {
      source: "iana"
    },
    "font/ttf": {
      source: "iana",
      compressible: true,
      extensions: ["ttf"]
    },
    "font/woff": {
      source: "iana",
      extensions: ["woff"]
    },
    "font/woff2": {
      source: "iana",
      extensions: ["woff2"]
    },
    "image/aces": {
      source: "iana",
      extensions: ["exr"]
    },
    "image/apng": {
      compressible: false,
      extensions: ["apng"]
    },
    "image/avci": {
      source: "iana"
    },
    "image/avcs": {
      source: "iana"
    },
    "image/avif": {
      source: "iana",
      compressible: false,
      extensions: ["avif"]
    },
    "image/bmp": {
      source: "iana",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/cgm": {
      source: "iana",
      extensions: ["cgm"]
    },
    "image/dicom-rle": {
      source: "iana",
      extensions: ["drle"]
    },
    "image/emf": {
      source: "iana",
      extensions: ["emf"]
    },
    "image/fits": {
      source: "iana",
      extensions: ["fits"]
    },
    "image/g3fax": {
      source: "iana",
      extensions: ["g3"]
    },
    "image/gif": {
      source: "iana",
      compressible: false,
      extensions: ["gif"]
    },
    "image/heic": {
      source: "iana",
      extensions: ["heic"]
    },
    "image/heic-sequence": {
      source: "iana",
      extensions: ["heics"]
    },
    "image/heif": {
      source: "iana",
      extensions: ["heif"]
    },
    "image/heif-sequence": {
      source: "iana",
      extensions: ["heifs"]
    },
    "image/hej2k": {
      source: "iana",
      extensions: ["hej2"]
    },
    "image/hsj2": {
      source: "iana",
      extensions: ["hsj2"]
    },
    "image/ief": {
      source: "iana",
      extensions: ["ief"]
    },
    "image/jls": {
      source: "iana",
      extensions: ["jls"]
    },
    "image/jp2": {
      source: "iana",
      compressible: false,
      extensions: ["jp2", "jpg2"]
    },
    "image/jpeg": {
      source: "iana",
      compressible: false,
      extensions: ["jpeg", "jpg", "jpe"]
    },
    "image/jph": {
      source: "iana",
      extensions: ["jph"]
    },
    "image/jphc": {
      source: "iana",
      extensions: ["jhc"]
    },
    "image/jpm": {
      source: "iana",
      compressible: false,
      extensions: ["jpm"]
    },
    "image/jpx": {
      source: "iana",
      compressible: false,
      extensions: ["jpx", "jpf"]
    },
    "image/jxr": {
      source: "iana",
      extensions: ["jxr"]
    },
    "image/jxra": {
      source: "iana",
      extensions: ["jxra"]
    },
    "image/jxrs": {
      source: "iana",
      extensions: ["jxrs"]
    },
    "image/jxs": {
      source: "iana",
      extensions: ["jxs"]
    },
    "image/jxsc": {
      source: "iana",
      extensions: ["jxsc"]
    },
    "image/jxsi": {
      source: "iana",
      extensions: ["jxsi"]
    },
    "image/jxss": {
      source: "iana",
      extensions: ["jxss"]
    },
    "image/ktx": {
      source: "iana",
      extensions: ["ktx"]
    },
    "image/ktx2": {
      source: "iana",
      extensions: ["ktx2"]
    },
    "image/naplps": {
      source: "iana"
    },
    "image/pjpeg": {
      compressible: false
    },
    "image/png": {
      source: "iana",
      compressible: false,
      extensions: ["png"]
    },
    "image/prs.btif": {
      source: "iana",
      extensions: ["btif"]
    },
    "image/prs.pti": {
      source: "iana",
      extensions: ["pti"]
    },
    "image/pwg-raster": {
      source: "iana"
    },
    "image/sgi": {
      source: "apache",
      extensions: ["sgi"]
    },
    "image/svg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["svg", "svgz"]
    },
    "image/t38": {
      source: "iana",
      extensions: ["t38"]
    },
    "image/tiff": {
      source: "iana",
      compressible: false,
      extensions: ["tif", "tiff"]
    },
    "image/tiff-fx": {
      source: "iana",
      extensions: ["tfx"]
    },
    "image/vnd.adobe.photoshop": {
      source: "iana",
      compressible: true,
      extensions: ["psd"]
    },
    "image/vnd.airzip.accelerator.azv": {
      source: "iana",
      extensions: ["azv"]
    },
    "image/vnd.cns.inf2": {
      source: "iana"
    },
    "image/vnd.dece.graphic": {
      source: "iana",
      extensions: ["uvi", "uvvi", "uvg", "uvvg"]
    },
    "image/vnd.djvu": {
      source: "iana",
      extensions: ["djvu", "djv"]
    },
    "image/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "image/vnd.dwg": {
      source: "iana",
      extensions: ["dwg"]
    },
    "image/vnd.dxf": {
      source: "iana",
      extensions: ["dxf"]
    },
    "image/vnd.fastbidsheet": {
      source: "iana",
      extensions: ["fbs"]
    },
    "image/vnd.fpx": {
      source: "iana",
      extensions: ["fpx"]
    },
    "image/vnd.fst": {
      source: "iana",
      extensions: ["fst"]
    },
    "image/vnd.fujixerox.edmics-mmr": {
      source: "iana",
      extensions: ["mmr"]
    },
    "image/vnd.fujixerox.edmics-rlc": {
      source: "iana",
      extensions: ["rlc"]
    },
    "image/vnd.globalgraphics.pgb": {
      source: "iana"
    },
    "image/vnd.microsoft.icon": {
      source: "iana",
      extensions: ["ico"]
    },
    "image/vnd.mix": {
      source: "iana"
    },
    "image/vnd.mozilla.apng": {
      source: "iana"
    },
    "image/vnd.ms-dds": {
      extensions: ["dds"]
    },
    "image/vnd.ms-modi": {
      source: "iana",
      extensions: ["mdi"]
    },
    "image/vnd.ms-photo": {
      source: "apache",
      extensions: ["wdp"]
    },
    "image/vnd.net-fpx": {
      source: "iana",
      extensions: ["npx"]
    },
    "image/vnd.pco.b16": {
      source: "iana",
      extensions: ["b16"]
    },
    "image/vnd.radiance": {
      source: "iana"
    },
    "image/vnd.sealed.png": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.gif": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.jpg": {
      source: "iana"
    },
    "image/vnd.svf": {
      source: "iana"
    },
    "image/vnd.tencent.tap": {
      source: "iana",
      extensions: ["tap"]
    },
    "image/vnd.valve.source.texture": {
      source: "iana",
      extensions: ["vtf"]
    },
    "image/vnd.wap.wbmp": {
      source: "iana",
      extensions: ["wbmp"]
    },
    "image/vnd.xiff": {
      source: "iana",
      extensions: ["xif"]
    },
    "image/vnd.zbrush.pcx": {
      source: "iana",
      extensions: ["pcx"]
    },
    "image/webp": {
      source: "apache",
      extensions: ["webp"]
    },
    "image/wmf": {
      source: "iana",
      extensions: ["wmf"]
    },
    "image/x-3ds": {
      source: "apache",
      extensions: ["3ds"]
    },
    "image/x-cmu-raster": {
      source: "apache",
      extensions: ["ras"]
    },
    "image/x-cmx": {
      source: "apache",
      extensions: ["cmx"]
    },
    "image/x-freehand": {
      source: "apache",
      extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
    },
    "image/x-icon": {
      source: "apache",
      compressible: true,
      extensions: ["ico"]
    },
    "image/x-jng": {
      source: "nginx",
      extensions: ["jng"]
    },
    "image/x-mrsid-image": {
      source: "apache",
      extensions: ["sid"]
    },
    "image/x-ms-bmp": {
      source: "nginx",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/x-pcx": {
      source: "apache",
      extensions: ["pcx"]
    },
    "image/x-pict": {
      source: "apache",
      extensions: ["pic", "pct"]
    },
    "image/x-portable-anymap": {
      source: "apache",
      extensions: ["pnm"]
    },
    "image/x-portable-bitmap": {
      source: "apache",
      extensions: ["pbm"]
    },
    "image/x-portable-graymap": {
      source: "apache",
      extensions: ["pgm"]
    },
    "image/x-portable-pixmap": {
      source: "apache",
      extensions: ["ppm"]
    },
    "image/x-rgb": {
      source: "apache",
      extensions: ["rgb"]
    },
    "image/x-tga": {
      source: "apache",
      extensions: ["tga"]
    },
    "image/x-xbitmap": {
      source: "apache",
      extensions: ["xbm"]
    },
    "image/x-xcf": {
      compressible: false
    },
    "image/x-xpixmap": {
      source: "apache",
      extensions: ["xpm"]
    },
    "image/x-xwindowdump": {
      source: "apache",
      extensions: ["xwd"]
    },
    "message/cpim": {
      source: "iana"
    },
    "message/delivery-status": {
      source: "iana"
    },
    "message/disposition-notification": {
      source: "iana",
      extensions: [
        "disposition-notification"
      ]
    },
    "message/external-body": {
      source: "iana"
    },
    "message/feedback-report": {
      source: "iana"
    },
    "message/global": {
      source: "iana",
      extensions: ["u8msg"]
    },
    "message/global-delivery-status": {
      source: "iana",
      extensions: ["u8dsn"]
    },
    "message/global-disposition-notification": {
      source: "iana",
      extensions: ["u8mdn"]
    },
    "message/global-headers": {
      source: "iana",
      extensions: ["u8hdr"]
    },
    "message/http": {
      source: "iana",
      compressible: false
    },
    "message/imdn+xml": {
      source: "iana",
      compressible: true
    },
    "message/news": {
      source: "iana"
    },
    "message/partial": {
      source: "iana",
      compressible: false
    },
    "message/rfc822": {
      source: "iana",
      compressible: true,
      extensions: ["eml", "mime"]
    },
    "message/s-http": {
      source: "iana"
    },
    "message/sip": {
      source: "iana"
    },
    "message/sipfrag": {
      source: "iana"
    },
    "message/tracking-status": {
      source: "iana"
    },
    "message/vnd.si.simp": {
      source: "iana"
    },
    "message/vnd.wfa.wsc": {
      source: "iana",
      extensions: ["wsc"]
    },
    "model/3mf": {
      source: "iana",
      extensions: ["3mf"]
    },
    "model/e57": {
      source: "iana"
    },
    "model/gltf+json": {
      source: "iana",
      compressible: true,
      extensions: ["gltf"]
    },
    "model/gltf-binary": {
      source: "iana",
      compressible: true,
      extensions: ["glb"]
    },
    "model/iges": {
      source: "iana",
      compressible: false,
      extensions: ["igs", "iges"]
    },
    "model/mesh": {
      source: "iana",
      compressible: false,
      extensions: ["msh", "mesh", "silo"]
    },
    "model/mtl": {
      source: "iana",
      extensions: ["mtl"]
    },
    "model/obj": {
      source: "iana",
      extensions: ["obj"]
    },
    "model/step+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpz"]
    },
    "model/step-xml+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpxz"]
    },
    "model/stl": {
      source: "iana",
      extensions: ["stl"]
    },
    "model/vnd.collada+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dae"]
    },
    "model/vnd.dwf": {
      source: "iana",
      extensions: ["dwf"]
    },
    "model/vnd.flatland.3dml": {
      source: "iana"
    },
    "model/vnd.gdl": {
      source: "iana",
      extensions: ["gdl"]
    },
    "model/vnd.gs-gdl": {
      source: "apache"
    },
    "model/vnd.gs.gdl": {
      source: "iana"
    },
    "model/vnd.gtw": {
      source: "iana",
      extensions: ["gtw"]
    },
    "model/vnd.moml+xml": {
      source: "iana",
      compressible: true
    },
    "model/vnd.mts": {
      source: "iana",
      extensions: ["mts"]
    },
    "model/vnd.opengex": {
      source: "iana",
      extensions: ["ogex"]
    },
    "model/vnd.parasolid.transmit.binary": {
      source: "iana",
      extensions: ["x_b"]
    },
    "model/vnd.parasolid.transmit.text": {
      source: "iana",
      extensions: ["x_t"]
    },
    "model/vnd.pytha.pyox": {
      source: "iana"
    },
    "model/vnd.rosette.annotated-data-model": {
      source: "iana"
    },
    "model/vnd.sap.vds": {
      source: "iana",
      extensions: ["vds"]
    },
    "model/vnd.usdz+zip": {
      source: "iana",
      compressible: false,
      extensions: ["usdz"]
    },
    "model/vnd.valve.source.compiled-map": {
      source: "iana",
      extensions: ["bsp"]
    },
    "model/vnd.vtu": {
      source: "iana",
      extensions: ["vtu"]
    },
    "model/vrml": {
      source: "iana",
      compressible: false,
      extensions: ["wrl", "vrml"]
    },
    "model/x3d+binary": {
      source: "apache",
      compressible: false,
      extensions: ["x3db", "x3dbz"]
    },
    "model/x3d+fastinfoset": {
      source: "iana",
      extensions: ["x3db"]
    },
    "model/x3d+vrml": {
      source: "apache",
      compressible: false,
      extensions: ["x3dv", "x3dvz"]
    },
    "model/x3d+xml": {
      source: "iana",
      compressible: true,
      extensions: ["x3d", "x3dz"]
    },
    "model/x3d-vrml": {
      source: "iana",
      extensions: ["x3dv"]
    },
    "multipart/alternative": {
      source: "iana",
      compressible: false
    },
    "multipart/appledouble": {
      source: "iana"
    },
    "multipart/byteranges": {
      source: "iana"
    },
    "multipart/digest": {
      source: "iana"
    },
    "multipart/encrypted": {
      source: "iana",
      compressible: false
    },
    "multipart/form-data": {
      source: "iana",
      compressible: false
    },
    "multipart/header-set": {
      source: "iana"
    },
    "multipart/mixed": {
      source: "iana"
    },
    "multipart/multilingual": {
      source: "iana"
    },
    "multipart/parallel": {
      source: "iana"
    },
    "multipart/related": {
      source: "iana",
      compressible: false
    },
    "multipart/report": {
      source: "iana"
    },
    "multipart/signed": {
      source: "iana",
      compressible: false
    },
    "multipart/vnd.bint.med-plus": {
      source: "iana"
    },
    "multipart/voice-message": {
      source: "iana"
    },
    "multipart/x-mixed-replace": {
      source: "iana"
    },
    "text/1d-interleaved-parityfec": {
      source: "iana"
    },
    "text/cache-manifest": {
      source: "iana",
      compressible: true,
      extensions: ["appcache", "manifest"]
    },
    "text/calendar": {
      source: "iana",
      extensions: ["ics", "ifb"]
    },
    "text/calender": {
      compressible: true
    },
    "text/cmd": {
      compressible: true
    },
    "text/coffeescript": {
      extensions: ["coffee", "litcoffee"]
    },
    "text/cql": {
      source: "iana"
    },
    "text/cql-expression": {
      source: "iana"
    },
    "text/cql-identifier": {
      source: "iana"
    },
    "text/css": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["css"]
    },
    "text/csv": {
      source: "iana",
      compressible: true,
      extensions: ["csv"]
    },
    "text/csv-schema": {
      source: "iana"
    },
    "text/directory": {
      source: "iana"
    },
    "text/dns": {
      source: "iana"
    },
    "text/ecmascript": {
      source: "iana"
    },
    "text/encaprtp": {
      source: "iana"
    },
    "text/enriched": {
      source: "iana"
    },
    "text/fhirpath": {
      source: "iana"
    },
    "text/flexfec": {
      source: "iana"
    },
    "text/fwdred": {
      source: "iana"
    },
    "text/gff3": {
      source: "iana"
    },
    "text/grammar-ref-list": {
      source: "iana"
    },
    "text/html": {
      source: "iana",
      compressible: true,
      extensions: ["html", "htm", "shtml"]
    },
    "text/jade": {
      extensions: ["jade"]
    },
    "text/javascript": {
      source: "iana",
      compressible: true
    },
    "text/jcr-cnd": {
      source: "iana"
    },
    "text/jsx": {
      compressible: true,
      extensions: ["jsx"]
    },
    "text/less": {
      compressible: true,
      extensions: ["less"]
    },
    "text/markdown": {
      source: "iana",
      compressible: true,
      extensions: ["markdown", "md"]
    },
    "text/mathml": {
      source: "nginx",
      extensions: ["mml"]
    },
    "text/mdx": {
      compressible: true,
      extensions: ["mdx"]
    },
    "text/mizar": {
      source: "iana"
    },
    "text/n3": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["n3"]
    },
    "text/parameters": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/parityfec": {
      source: "iana"
    },
    "text/plain": {
      source: "iana",
      compressible: true,
      extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
    },
    "text/provenance-notation": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/prs.fallenstein.rst": {
      source: "iana"
    },
    "text/prs.lines.tag": {
      source: "iana",
      extensions: ["dsc"]
    },
    "text/prs.prop.logic": {
      source: "iana"
    },
    "text/raptorfec": {
      source: "iana"
    },
    "text/red": {
      source: "iana"
    },
    "text/rfc822-headers": {
      source: "iana"
    },
    "text/richtext": {
      source: "iana",
      compressible: true,
      extensions: ["rtx"]
    },
    "text/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "text/rtp-enc-aescm128": {
      source: "iana"
    },
    "text/rtploopback": {
      source: "iana"
    },
    "text/rtx": {
      source: "iana"
    },
    "text/sgml": {
      source: "iana",
      extensions: ["sgml", "sgm"]
    },
    "text/shaclc": {
      source: "iana"
    },
    "text/shex": {
      source: "iana",
      extensions: ["shex"]
    },
    "text/slim": {
      extensions: ["slim", "slm"]
    },
    "text/spdx": {
      source: "iana",
      extensions: ["spdx"]
    },
    "text/strings": {
      source: "iana"
    },
    "text/stylus": {
      extensions: ["stylus", "styl"]
    },
    "text/t140": {
      source: "iana"
    },
    "text/tab-separated-values": {
      source: "iana",
      compressible: true,
      extensions: ["tsv"]
    },
    "text/troff": {
      source: "iana",
      extensions: ["t", "tr", "roff", "man", "me", "ms"]
    },
    "text/turtle": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["ttl"]
    },
    "text/ulpfec": {
      source: "iana"
    },
    "text/uri-list": {
      source: "iana",
      compressible: true,
      extensions: ["uri", "uris", "urls"]
    },
    "text/vcard": {
      source: "iana",
      compressible: true,
      extensions: ["vcard"]
    },
    "text/vnd.a": {
      source: "iana"
    },
    "text/vnd.abc": {
      source: "iana"
    },
    "text/vnd.ascii-art": {
      source: "iana"
    },
    "text/vnd.curl": {
      source: "iana",
      extensions: ["curl"]
    },
    "text/vnd.curl.dcurl": {
      source: "apache",
      extensions: ["dcurl"]
    },
    "text/vnd.curl.mcurl": {
      source: "apache",
      extensions: ["mcurl"]
    },
    "text/vnd.curl.scurl": {
      source: "apache",
      extensions: ["scurl"]
    },
    "text/vnd.debian.copyright": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.dmclientscript": {
      source: "iana"
    },
    "text/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "text/vnd.esmertec.theme-descriptor": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.ficlab.flt": {
      source: "iana"
    },
    "text/vnd.fly": {
      source: "iana",
      extensions: ["fly"]
    },
    "text/vnd.fmi.flexstor": {
      source: "iana",
      extensions: ["flx"]
    },
    "text/vnd.gml": {
      source: "iana"
    },
    "text/vnd.graphviz": {
      source: "iana",
      extensions: ["gv"]
    },
    "text/vnd.hans": {
      source: "iana"
    },
    "text/vnd.hgl": {
      source: "iana"
    },
    "text/vnd.in3d.3dml": {
      source: "iana",
      extensions: ["3dml"]
    },
    "text/vnd.in3d.spot": {
      source: "iana",
      extensions: ["spot"]
    },
    "text/vnd.iptc.newsml": {
      source: "iana"
    },
    "text/vnd.iptc.nitf": {
      source: "iana"
    },
    "text/vnd.latex-z": {
      source: "iana"
    },
    "text/vnd.motorola.reflex": {
      source: "iana"
    },
    "text/vnd.ms-mediapackage": {
      source: "iana"
    },
    "text/vnd.net2phone.commcenter.command": {
      source: "iana"
    },
    "text/vnd.radisys.msml-basic-layout": {
      source: "iana"
    },
    "text/vnd.senx.warpscript": {
      source: "iana"
    },
    "text/vnd.si.uricatalogue": {
      source: "iana"
    },
    "text/vnd.sosi": {
      source: "iana"
    },
    "text/vnd.sun.j2me.app-descriptor": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["jad"]
    },
    "text/vnd.trolltech.linguist": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.wap.si": {
      source: "iana"
    },
    "text/vnd.wap.sl": {
      source: "iana"
    },
    "text/vnd.wap.wml": {
      source: "iana",
      extensions: ["wml"]
    },
    "text/vnd.wap.wmlscript": {
      source: "iana",
      extensions: ["wmls"]
    },
    "text/vtt": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["vtt"]
    },
    "text/x-asm": {
      source: "apache",
      extensions: ["s", "asm"]
    },
    "text/x-c": {
      source: "apache",
      extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
    },
    "text/x-component": {
      source: "nginx",
      extensions: ["htc"]
    },
    "text/x-fortran": {
      source: "apache",
      extensions: ["f", "for", "f77", "f90"]
    },
    "text/x-gwt-rpc": {
      compressible: true
    },
    "text/x-handlebars-template": {
      extensions: ["hbs"]
    },
    "text/x-java-source": {
      source: "apache",
      extensions: ["java"]
    },
    "text/x-jquery-tmpl": {
      compressible: true
    },
    "text/x-lua": {
      extensions: ["lua"]
    },
    "text/x-markdown": {
      compressible: true,
      extensions: ["mkd"]
    },
    "text/x-nfo": {
      source: "apache",
      extensions: ["nfo"]
    },
    "text/x-opml": {
      source: "apache",
      extensions: ["opml"]
    },
    "text/x-org": {
      compressible: true,
      extensions: ["org"]
    },
    "text/x-pascal": {
      source: "apache",
      extensions: ["p", "pas"]
    },
    "text/x-processing": {
      compressible: true,
      extensions: ["pde"]
    },
    "text/x-sass": {
      extensions: ["sass"]
    },
    "text/x-scss": {
      extensions: ["scss"]
    },
    "text/x-setext": {
      source: "apache",
      extensions: ["etx"]
    },
    "text/x-sfv": {
      source: "apache",
      extensions: ["sfv"]
    },
    "text/x-suse-ymp": {
      compressible: true,
      extensions: ["ymp"]
    },
    "text/x-uuencode": {
      source: "apache",
      extensions: ["uu"]
    },
    "text/x-vcalendar": {
      source: "apache",
      extensions: ["vcs"]
    },
    "text/x-vcard": {
      source: "apache",
      extensions: ["vcf"]
    },
    "text/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml"]
    },
    "text/xml-external-parsed-entity": {
      source: "iana"
    },
    "text/yaml": {
      compressible: true,
      extensions: ["yaml", "yml"]
    },
    "video/1d-interleaved-parityfec": {
      source: "iana"
    },
    "video/3gpp": {
      source: "iana",
      extensions: ["3gp", "3gpp"]
    },
    "video/3gpp-tt": {
      source: "iana"
    },
    "video/3gpp2": {
      source: "iana",
      extensions: ["3g2"]
    },
    "video/av1": {
      source: "iana"
    },
    "video/bmpeg": {
      source: "iana"
    },
    "video/bt656": {
      source: "iana"
    },
    "video/celb": {
      source: "iana"
    },
    "video/dv": {
      source: "iana"
    },
    "video/encaprtp": {
      source: "iana"
    },
    "video/ffv1": {
      source: "iana"
    },
    "video/flexfec": {
      source: "iana"
    },
    "video/h261": {
      source: "iana",
      extensions: ["h261"]
    },
    "video/h263": {
      source: "iana",
      extensions: ["h263"]
    },
    "video/h263-1998": {
      source: "iana"
    },
    "video/h263-2000": {
      source: "iana"
    },
    "video/h264": {
      source: "iana",
      extensions: ["h264"]
    },
    "video/h264-rcdo": {
      source: "iana"
    },
    "video/h264-svc": {
      source: "iana"
    },
    "video/h265": {
      source: "iana"
    },
    "video/iso.segment": {
      source: "iana",
      extensions: ["m4s"]
    },
    "video/jpeg": {
      source: "iana",
      extensions: ["jpgv"]
    },
    "video/jpeg2000": {
      source: "iana"
    },
    "video/jpm": {
      source: "apache",
      extensions: ["jpm", "jpgm"]
    },
    "video/mj2": {
      source: "iana",
      extensions: ["mj2", "mjp2"]
    },
    "video/mp1s": {
      source: "iana"
    },
    "video/mp2p": {
      source: "iana"
    },
    "video/mp2t": {
      source: "iana",
      extensions: ["ts"]
    },
    "video/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["mp4", "mp4v", "mpg4"]
    },
    "video/mp4v-es": {
      source: "iana"
    },
    "video/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
    },
    "video/mpeg4-generic": {
      source: "iana"
    },
    "video/mpv": {
      source: "iana"
    },
    "video/nv": {
      source: "iana"
    },
    "video/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogv"]
    },
    "video/parityfec": {
      source: "iana"
    },
    "video/pointer": {
      source: "iana"
    },
    "video/quicktime": {
      source: "iana",
      compressible: false,
      extensions: ["qt", "mov"]
    },
    "video/raptorfec": {
      source: "iana"
    },
    "video/raw": {
      source: "iana"
    },
    "video/rtp-enc-aescm128": {
      source: "iana"
    },
    "video/rtploopback": {
      source: "iana"
    },
    "video/rtx": {
      source: "iana"
    },
    "video/scip": {
      source: "iana"
    },
    "video/smpte291": {
      source: "iana"
    },
    "video/smpte292m": {
      source: "iana"
    },
    "video/ulpfec": {
      source: "iana"
    },
    "video/vc1": {
      source: "iana"
    },
    "video/vc2": {
      source: "iana"
    },
    "video/vnd.cctv": {
      source: "iana"
    },
    "video/vnd.dece.hd": {
      source: "iana",
      extensions: ["uvh", "uvvh"]
    },
    "video/vnd.dece.mobile": {
      source: "iana",
      extensions: ["uvm", "uvvm"]
    },
    "video/vnd.dece.mp4": {
      source: "iana"
    },
    "video/vnd.dece.pd": {
      source: "iana",
      extensions: ["uvp", "uvvp"]
    },
    "video/vnd.dece.sd": {
      source: "iana",
      extensions: ["uvs", "uvvs"]
    },
    "video/vnd.dece.video": {
      source: "iana",
      extensions: ["uvv", "uvvv"]
    },
    "video/vnd.directv.mpeg": {
      source: "iana"
    },
    "video/vnd.directv.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dlna.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dvb.file": {
      source: "iana",
      extensions: ["dvb"]
    },
    "video/vnd.fvt": {
      source: "iana",
      extensions: ["fvt"]
    },
    "video/vnd.hns.video": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsavc": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsmpeg2": {
      source: "iana"
    },
    "video/vnd.motorola.video": {
      source: "iana"
    },
    "video/vnd.motorola.videop": {
      source: "iana"
    },
    "video/vnd.mpegurl": {
      source: "iana",
      extensions: ["mxu", "m4u"]
    },
    "video/vnd.ms-playready.media.pyv": {
      source: "iana",
      extensions: ["pyv"]
    },
    "video/vnd.nokia.interleaved-multimedia": {
      source: "iana"
    },
    "video/vnd.nokia.mp4vr": {
      source: "iana"
    },
    "video/vnd.nokia.videovoip": {
      source: "iana"
    },
    "video/vnd.objectvideo": {
      source: "iana"
    },
    "video/vnd.radgamettools.bink": {
      source: "iana"
    },
    "video/vnd.radgamettools.smacker": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg1": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg4": {
      source: "iana"
    },
    "video/vnd.sealed.swf": {
      source: "iana"
    },
    "video/vnd.sealedmedia.softseal.mov": {
      source: "iana"
    },
    "video/vnd.uvvu.mp4": {
      source: "iana",
      extensions: ["uvu", "uvvu"]
    },
    "video/vnd.vivo": {
      source: "iana",
      extensions: ["viv"]
    },
    "video/vnd.youtube.yt": {
      source: "iana"
    },
    "video/vp8": {
      source: "iana"
    },
    "video/vp9": {
      source: "iana"
    },
    "video/webm": {
      source: "apache",
      compressible: false,
      extensions: ["webm"]
    },
    "video/x-f4v": {
      source: "apache",
      extensions: ["f4v"]
    },
    "video/x-fli": {
      source: "apache",
      extensions: ["fli"]
    },
    "video/x-flv": {
      source: "apache",
      compressible: false,
      extensions: ["flv"]
    },
    "video/x-m4v": {
      source: "apache",
      extensions: ["m4v"]
    },
    "video/x-matroska": {
      source: "apache",
      compressible: false,
      extensions: ["mkv", "mk3d", "mks"]
    },
    "video/x-mng": {
      source: "apache",
      extensions: ["mng"]
    },
    "video/x-ms-asf": {
      source: "apache",
      extensions: ["asf", "asx"]
    },
    "video/x-ms-vob": {
      source: "apache",
      extensions: ["vob"]
    },
    "video/x-ms-wm": {
      source: "apache",
      extensions: ["wm"]
    },
    "video/x-ms-wmv": {
      source: "apache",
      compressible: false,
      extensions: ["wmv"]
    },
    "video/x-ms-wmx": {
      source: "apache",
      extensions: ["wmx"]
    },
    "video/x-ms-wvx": {
      source: "apache",
      extensions: ["wvx"]
    },
    "video/x-msvideo": {
      source: "apache",
      extensions: ["avi"]
    },
    "video/x-sgi-movie": {
      source: "apache",
      extensions: ["movie"]
    },
    "video/x-smv": {
      source: "apache",
      extensions: ["smv"]
    },
    "x-conference/x-cooltalk": {
      source: "apache",
      extensions: ["ice"]
    },
    "x-shader/x-fragment": {
      compressible: true
    },
    "x-shader/x-vertex": {
      compressible: true
    }
  };
});

// ../../node_modules/.pnpm/mime-db@1.49.0/node_modules/mime-db/index.js
var require_mime_db = __commonJS((exports2, module2) => {
  /*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * MIT Licensed
   */
  module2.exports = require_db();
});

// ../../node_modules/.pnpm/mime-types@2.1.32/node_modules/mime-types/index.js
var require_mime_types = __commonJS((exports2) => {
  /*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var db = require_mime_db();
  var extname = require("path").extname;
  var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
  var TEXT_TYPE_REGEXP = /^text\//i;
  exports2.charset = charset;
  exports2.charsets = {lookup: charset};
  exports2.contentType = contentType;
  exports2.extension = extension;
  exports2.extensions = Object.create(null);
  exports2.lookup = lookup;
  exports2.types = Object.create(null);
  populateMaps(exports2.extensions, exports2.types);
  function charset(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var mime = match && db[match[1].toLowerCase()];
    if (mime && mime.charset) {
      return mime.charset;
    }
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
      return "UTF-8";
    }
    return false;
  }
  function contentType(str) {
    if (!str || typeof str !== "string") {
      return false;
    }
    var mime = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
    if (!mime) {
      return false;
    }
    if (mime.indexOf("charset") === -1) {
      var charset2 = exports2.charset(mime);
      if (charset2)
        mime += "; charset=" + charset2.toLowerCase();
    }
    return mime;
  }
  function extension(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var exts = match && exports2.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
      return false;
    }
    return exts[0];
  }
  function lookup(path10) {
    if (!path10 || typeof path10 !== "string") {
      return false;
    }
    var extension2 = extname("x." + path10).toLowerCase().substr(1);
    if (!extension2) {
      return false;
    }
    return exports2.types[extension2] || false;
  }
  function populateMaps(extensions, types) {
    var preference = ["nginx", "apache", void 0, "iana"];
    Object.keys(db).forEach(function forEachMimeType(type) {
      var mime = db[type];
      var exts = mime.extensions;
      if (!exts || !exts.length) {
        return;
      }
      extensions[type] = exts;
      for (var i = 0; i < exts.length; i++) {
        var extension2 = exts[i];
        if (types[extension2]) {
          var from = preference.indexOf(db[types[extension2]].source);
          var to = preference.indexOf(mime.source);
          if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
            continue;
          }
        }
        types[extension2] = type;
      }
    });
  }
});

// ../../node_modules/.pnpm/type-is@1.6.18/node_modules/type-is/index.js
var require_type_is = __commonJS((exports2, module2) => {
  /*!
   * type-is
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var typer = require_media_typer();
  var mime = require_mime_types();
  module2.exports = typeofrequest;
  module2.exports.is = typeis;
  module2.exports.hasBody = hasbody;
  module2.exports.normalize = normalize;
  module2.exports.match = mimeMatch;
  function typeis(value, types_) {
    var i;
    var types = types_;
    var val = tryNormalizeType(value);
    if (!val) {
      return false;
    }
    if (types && !Array.isArray(types)) {
      types = new Array(arguments.length - 1);
      for (i = 0; i < types.length; i++) {
        types[i] = arguments[i + 1];
      }
    }
    if (!types || !types.length) {
      return val;
    }
    var type;
    for (i = 0; i < types.length; i++) {
      if (mimeMatch(normalize(type = types[i]), val)) {
        return type[0] === "+" || type.indexOf("*") !== -1 ? val : type;
      }
    }
    return false;
  }
  function hasbody(req) {
    return req.headers["transfer-encoding"] !== void 0 || !isNaN(req.headers["content-length"]);
  }
  function typeofrequest(req, types_) {
    var types = types_;
    if (!hasbody(req)) {
      return null;
    }
    if (arguments.length > 2) {
      types = new Array(arguments.length - 1);
      for (var i = 0; i < types.length; i++) {
        types[i] = arguments[i + 1];
      }
    }
    var value = req.headers["content-type"];
    return typeis(value, types);
  }
  function normalize(type) {
    if (typeof type !== "string") {
      return false;
    }
    switch (type) {
      case "urlencoded":
        return "application/x-www-form-urlencoded";
      case "multipart":
        return "multipart/*";
    }
    if (type[0] === "+") {
      return "*/*" + type;
    }
    return type.indexOf("/") === -1 ? mime.lookup(type) : type;
  }
  function mimeMatch(expected, actual) {
    if (expected === false) {
      return false;
    }
    var actualParts = actual.split("/");
    var expectedParts = expected.split("/");
    if (actualParts.length !== 2 || expectedParts.length !== 2) {
      return false;
    }
    if (expectedParts[0] !== "*" && expectedParts[0] !== actualParts[0]) {
      return false;
    }
    if (expectedParts[1].substr(0, 2) === "*+") {
      return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length);
    }
    if (expectedParts[1] !== "*" && expectedParts[1] !== actualParts[1]) {
      return false;
    }
    return true;
  }
  function normalizeType(value) {
    var type = typer.parse(value);
    type.parameters = void 0;
    return typer.format(type);
  }
  function tryNormalizeType(value) {
    if (!value) {
      return null;
    }
    try {
      return normalizeType(value);
    } catch (err) {
      return null;
    }
  }
});

// ../../node_modules/.pnpm/body-parser@1.19.0/node_modules/body-parser/lib/types/json.js
var require_json2 = __commonJS((exports2, module2) => {
  /*!
   * body-parser
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var bytes = require_bytes();
  var contentType = require_content_type();
  var createError = require_http_errors();
  var debug3 = require_src5()("body-parser:json");
  var read = require_read();
  var typeis = require_type_is();
  module2.exports = json;
  var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*(.)/;
  function json(options) {
    var opts = options || {};
    var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
    var inflate = opts.inflate !== false;
    var reviver = opts.reviver;
    var strict = opts.strict !== false;
    var type = opts.type || "application/json";
    var verify = opts.verify || false;
    if (verify !== false && typeof verify !== "function") {
      throw new TypeError("option verify must be function");
    }
    var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
    function parse2(body) {
      if (body.length === 0) {
        return {};
      }
      if (strict) {
        var first = firstchar(body);
        if (first !== "{" && first !== "[") {
          debug3("strict violation");
          throw createStrictSyntaxError(body, first);
        }
      }
      try {
        debug3("parse json");
        return JSON.parse(body, reviver);
      } catch (e) {
        throw normalizeJsonSyntaxError(e, {
          message: e.message,
          stack: e.stack
        });
      }
    }
    return function jsonParser(req, res, next) {
      if (req._body) {
        debug3("body already parsed");
        next();
        return;
      }
      req.body = req.body || {};
      if (!typeis.hasBody(req)) {
        debug3("skip empty body");
        next();
        return;
      }
      debug3("content-type %j", req.headers["content-type"]);
      if (!shouldParse(req)) {
        debug3("skip parsing");
        next();
        return;
      }
      var charset = getCharset(req) || "utf-8";
      if (charset.substr(0, 4) !== "utf-") {
        debug3("invalid charset");
        next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
          charset,
          type: "charset.unsupported"
        }));
        return;
      }
      read(req, res, next, parse2, debug3, {
        encoding: charset,
        inflate,
        limit,
        verify
      });
    };
  }
  function createStrictSyntaxError(str, char) {
    var index = str.indexOf(char);
    var partial = str.substring(0, index) + "#";
    try {
      JSON.parse(partial);
      throw new SyntaxError("strict violation");
    } catch (e) {
      return normalizeJsonSyntaxError(e, {
        message: e.message.replace("#", char),
        stack: e.stack
      });
    }
  }
  function firstchar(str) {
    return FIRST_CHAR_REGEXP.exec(str)[1];
  }
  function getCharset(req) {
    try {
      return (contentType.parse(req).parameters.charset || "").toLowerCase();
    } catch (e) {
      return void 0;
    }
  }
  function normalizeJsonSyntaxError(error, obj) {
    var keys = Object.getOwnPropertyNames(error);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (key !== "stack" && key !== "message") {
        delete error[key];
      }
    }
    error.stack = obj.stack.replace(error.message, obj.message);
    error.message = obj.message;
    return error;
  }
  function typeChecker(type) {
    return function checkType(req) {
      return Boolean(typeis(req, type));
    };
  }
});

// ../../node_modules/.pnpm/body-parser@1.19.0/node_modules/body-parser/lib/types/raw.js
var require_raw = __commonJS((exports2, module2) => {
  /*!
   * body-parser
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var bytes = require_bytes();
  var debug3 = require_src5()("body-parser:raw");
  var read = require_read();
  var typeis = require_type_is();
  module2.exports = raw;
  function raw(options) {
    var opts = options || {};
    var inflate = opts.inflate !== false;
    var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
    var type = opts.type || "application/octet-stream";
    var verify = opts.verify || false;
    if (verify !== false && typeof verify !== "function") {
      throw new TypeError("option verify must be function");
    }
    var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
    function parse2(buf) {
      return buf;
    }
    return function rawParser(req, res, next) {
      if (req._body) {
        debug3("body already parsed");
        next();
        return;
      }
      req.body = req.body || {};
      if (!typeis.hasBody(req)) {
        debug3("skip empty body");
        next();
        return;
      }
      debug3("content-type %j", req.headers["content-type"]);
      if (!shouldParse(req)) {
        debug3("skip parsing");
        next();
        return;
      }
      read(req, res, next, parse2, debug3, {
        encoding: null,
        inflate,
        limit,
        verify
      });
    };
  }
  function typeChecker(type) {
    return function checkType(req) {
      return Boolean(typeis(req, type));
    };
  }
});

// ../../node_modules/.pnpm/body-parser@1.19.0/node_modules/body-parser/lib/types/text.js
var require_text3 = __commonJS((exports2, module2) => {
  /*!
   * body-parser
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var bytes = require_bytes();
  var contentType = require_content_type();
  var debug3 = require_src5()("body-parser:text");
  var read = require_read();
  var typeis = require_type_is();
  module2.exports = text;
  function text(options) {
    var opts = options || {};
    var defaultCharset = opts.defaultCharset || "utf-8";
    var inflate = opts.inflate !== false;
    var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
    var type = opts.type || "text/plain";
    var verify = opts.verify || false;
    if (verify !== false && typeof verify !== "function") {
      throw new TypeError("option verify must be function");
    }
    var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
    function parse2(buf) {
      return buf;
    }
    return function textParser(req, res, next) {
      if (req._body) {
        debug3("body already parsed");
        next();
        return;
      }
      req.body = req.body || {};
      if (!typeis.hasBody(req)) {
        debug3("skip empty body");
        next();
        return;
      }
      debug3("content-type %j", req.headers["content-type"]);
      if (!shouldParse(req)) {
        debug3("skip parsing");
        next();
        return;
      }
      var charset = getCharset(req) || defaultCharset;
      read(req, res, next, parse2, debug3, {
        encoding: charset,
        inflate,
        limit,
        verify
      });
    };
  }
  function getCharset(req) {
    try {
      return (contentType.parse(req).parameters.charset || "").toLowerCase();
    } catch (e) {
      return void 0;
    }
  }
  function typeChecker(type) {
    return function checkType(req) {
      return Boolean(typeis(req, type));
    };
  }
});

// ../../node_modules/.pnpm/qs@6.7.0/node_modules/qs/lib/utils.js
var require_utils7 = __commonJS((exports2, module2) => {
  "use strict";
  var has = Object.prototype.hasOwnProperty;
  var isArray = Array.isArray;
  var hexTable = function() {
    var array = [];
    for (var i = 0; i < 256; ++i) {
      array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
    }
    return array;
  }();
  var compactQueue = function compactQueue2(queue) {
    while (queue.length > 1) {
      var item = queue.pop();
      var obj = item.obj[item.prop];
      if (isArray(obj)) {
        var compacted = [];
        for (var j = 0; j < obj.length; ++j) {
          if (typeof obj[j] !== "undefined") {
            compacted.push(obj[j]);
          }
        }
        item.obj[item.prop] = compacted;
      }
    }
  };
  var arrayToObject = function arrayToObject2(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
      if (typeof source[i] !== "undefined") {
        obj[i] = source[i];
      }
    }
    return obj;
  };
  var merge = function merge2(target, source, options) {
    if (!source) {
      return target;
    }
    if (typeof source !== "object") {
      if (isArray(target)) {
        target.push(source);
      } else if (target && typeof target === "object") {
        if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
          target[source] = true;
        }
      } else {
        return [target, source];
      }
      return target;
    }
    if (!target || typeof target !== "object") {
      return [target].concat(source);
    }
    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
      mergeTarget = arrayToObject(target, options);
    }
    if (isArray(target) && isArray(source)) {
      source.forEach(function(item, i) {
        if (has.call(target, i)) {
          var targetItem = target[i];
          if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
            target[i] = merge2(targetItem, item, options);
          } else {
            target.push(item);
          }
        } else {
          target[i] = item;
        }
      });
      return target;
    }
    return Object.keys(source).reduce(function(acc, key) {
      var value = source[key];
      if (has.call(acc, key)) {
        acc[key] = merge2(acc[key], value, options);
      } else {
        acc[key] = value;
      }
      return acc;
    }, mergeTarget);
  };
  var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function(acc, key) {
      acc[key] = source[key];
      return acc;
    }, target);
  };
  var decode = function(str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, " ");
    if (charset === "iso-8859-1") {
      return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    try {
      return decodeURIComponent(strWithoutPlus);
    } catch (e) {
      return strWithoutPlus;
    }
  };
  var encode = function encode2(str, defaultEncoder, charset) {
    if (str.length === 0) {
      return str;
    }
    var string = typeof str === "string" ? str : String(str);
    if (charset === "iso-8859-1") {
      return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
        return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
      });
    }
    var out = "";
    for (var i = 0; i < string.length; ++i) {
      var c = string.charCodeAt(i);
      if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122) {
        out += string.charAt(i);
        continue;
      }
      if (c < 128) {
        out = out + hexTable[c];
        continue;
      }
      if (c < 2048) {
        out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
        continue;
      }
      if (c < 55296 || c >= 57344) {
        out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
        continue;
      }
      i += 1;
      c = 65536 + ((c & 1023) << 10 | string.charCodeAt(i) & 1023);
      out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
    }
    return out;
  };
  var compact = function compact2(value) {
    var queue = [{obj: {o: value}, prop: "o"}];
    var refs = [];
    for (var i = 0; i < queue.length; ++i) {
      var item = queue[i];
      var obj = item.obj[item.prop];
      var keys = Object.keys(obj);
      for (var j = 0; j < keys.length; ++j) {
        var key = keys[j];
        var val = obj[key];
        if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
          queue.push({obj, prop: key});
          refs.push(val);
        }
      }
    }
    compactQueue(queue);
    return value;
  };
  var isRegExp = function isRegExp2(obj) {
    return Object.prototype.toString.call(obj) === "[object RegExp]";
  };
  var isBuffer = function isBuffer2(obj) {
    if (!obj || typeof obj !== "object") {
      return false;
    }
    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
  };
  var combine = function combine2(a, b) {
    return [].concat(a, b);
  };
  module2.exports = {
    arrayToObject,
    assign,
    combine,
    compact,
    decode,
    encode,
    isBuffer,
    isRegExp,
    merge
  };
});

// ../../node_modules/.pnpm/qs@6.7.0/node_modules/qs/lib/formats.js
var require_formats = __commonJS((exports2, module2) => {
  "use strict";
  var replace = String.prototype.replace;
  var percentTwenties = /%20/g;
  module2.exports = {
    default: "RFC3986",
    formatters: {
      RFC1738: function(value) {
        return replace.call(value, percentTwenties, "+");
      },
      RFC3986: function(value) {
        return value;
      }
    },
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
  };
});

// ../../node_modules/.pnpm/qs@6.7.0/node_modules/qs/lib/stringify.js
var require_stringify2 = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils7();
  var formats = require_formats();
  var has = Object.prototype.hasOwnProperty;
  var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
      return prefix + "[]";
    },
    comma: "comma",
    indices: function indices(prefix, key) {
      return prefix + "[" + key + "]";
    },
    repeat: function repeat(prefix) {
      return prefix;
    }
  };
  var isArray = Array.isArray;
  var push = Array.prototype.push;
  var pushToArray = function(arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
  };
  var toISO = Date.prototype.toISOString;
  var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    charset: "utf-8",
    charsetSentinel: false,
    delimiter: "&",
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    formatter: formats.formatters[formats["default"]],
    indices: false,
    serializeDate: function serializeDate(date) {
      return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
  };
  var stringify2 = function stringify3(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly, charset) {
    var obj = object;
    if (typeof filter === "function") {
      obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
      obj = serializeDate(obj);
    } else if (generateArrayPrefix === "comma" && isArray(obj)) {
      obj = obj.join(",");
    }
    if (obj === null) {
      if (strictNullHandling) {
        return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset) : prefix;
      }
      obj = "";
    }
    if (typeof obj === "string" || typeof obj === "number" || typeof obj === "boolean" || utils.isBuffer(obj)) {
      if (encoder) {
        var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset);
        return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset))];
      }
      return [formatter(prefix) + "=" + formatter(String(obj))];
    }
    var values = [];
    if (typeof obj === "undefined") {
      return values;
    }
    var objKeys;
    if (isArray(filter)) {
      objKeys = filter;
    } else {
      var keys = Object.keys(obj);
      objKeys = sort ? keys.sort(sort) : keys;
    }
    for (var i = 0; i < objKeys.length; ++i) {
      var key = objKeys[i];
      if (skipNulls && obj[key] === null) {
        continue;
      }
      if (isArray(obj)) {
        pushToArray(values, stringify3(obj[key], typeof generateArrayPrefix === "function" ? generateArrayPrefix(prefix, key) : prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly, charset));
      } else {
        pushToArray(values, stringify3(obj[key], prefix + (allowDots ? "." + key : "[" + key + "]"), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly, charset));
      }
    }
    return values;
  };
  var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
    if (!opts) {
      return defaults;
    }
    if (opts.encoder !== null && opts.encoder !== void 0 && typeof opts.encoder !== "function") {
      throw new TypeError("Encoder has to be a function.");
    }
    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    var format10 = formats["default"];
    if (typeof opts.format !== "undefined") {
      if (!has.call(formats.formatters, opts.format)) {
        throw new TypeError("Unknown format option provided.");
      }
      format10 = opts.format;
    }
    var formatter = formats.formatters[format10];
    var filter = defaults.filter;
    if (typeof opts.filter === "function" || isArray(opts.filter)) {
      filter = opts.filter;
    }
    return {
      addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
      allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
      charset,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
      delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
      encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
      encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
      encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
      filter,
      formatter,
      serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
      skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
      sort: typeof opts.sort === "function" ? opts.sort : null,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
    };
  };
  module2.exports = function(object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);
    var objKeys;
    var filter;
    if (typeof options.filter === "function") {
      filter = options.filter;
      obj = filter("", obj);
    } else if (isArray(options.filter)) {
      filter = options.filter;
      objKeys = filter;
    }
    var keys = [];
    if (typeof obj !== "object" || obj === null) {
      return "";
    }
    var arrayFormat;
    if (opts && opts.arrayFormat in arrayPrefixGenerators) {
      arrayFormat = opts.arrayFormat;
    } else if (opts && "indices" in opts) {
      arrayFormat = opts.indices ? "indices" : "repeat";
    } else {
      arrayFormat = "indices";
    }
    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
    if (!objKeys) {
      objKeys = Object.keys(obj);
    }
    if (options.sort) {
      objKeys.sort(options.sort);
    }
    for (var i = 0; i < objKeys.length; ++i) {
      var key = objKeys[i];
      if (options.skipNulls && obj[key] === null) {
        continue;
      }
      pushToArray(keys, stringify2(obj[key], key, generateArrayPrefix, options.strictNullHandling, options.skipNulls, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.formatter, options.encodeValuesOnly, options.charset));
    }
    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? "?" : "";
    if (options.charsetSentinel) {
      if (options.charset === "iso-8859-1") {
        prefix += "utf8=%26%2310003%3B&";
      } else {
        prefix += "utf8=%E2%9C%93&";
      }
    }
    return joined.length > 0 ? prefix + joined : "";
  };
});

// ../../node_modules/.pnpm/qs@6.7.0/node_modules/qs/lib/parse.js
var require_parse6 = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils7();
  var has = Object.prototype.hasOwnProperty;
  var defaults = {
    allowDots: false,
    allowPrototypes: false,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: false,
    comma: false,
    decoder: utils.decode,
    delimiter: "&",
    depth: 5,
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1e3,
    parseArrays: true,
    plainObjects: false,
    strictNullHandling: false
  };
  var interpretNumericEntities = function(str) {
    return str.replace(/&#(\d+);/g, function($0, numberStr) {
      return String.fromCharCode(parseInt(numberStr, 10));
    });
  };
  var isoSentinel = "utf8=%26%2310003%3B";
  var charsetSentinel = "utf8=%E2%9C%93";
  var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
    var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex2 = -1;
    var i;
    var charset = options.charset;
    if (options.charsetSentinel) {
      for (i = 0; i < parts.length; ++i) {
        if (parts[i].indexOf("utf8=") === 0) {
          if (parts[i] === charsetSentinel) {
            charset = "utf-8";
          } else if (parts[i] === isoSentinel) {
            charset = "iso-8859-1";
          }
          skipIndex2 = i;
          i = parts.length;
        }
      }
    }
    for (i = 0; i < parts.length; ++i) {
      if (i === skipIndex2) {
        continue;
      }
      var part = parts[i];
      var bracketEqualsPos = part.indexOf("]=");
      var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
      var key, val;
      if (pos === -1) {
        key = options.decoder(part, defaults.decoder, charset);
        val = options.strictNullHandling ? null : "";
      } else {
        key = options.decoder(part.slice(0, pos), defaults.decoder, charset);
        val = options.decoder(part.slice(pos + 1), defaults.decoder, charset);
      }
      if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
        val = interpretNumericEntities(val);
      }
      if (val && options.comma && val.indexOf(",") > -1) {
        val = val.split(",");
      }
      if (has.call(obj, key)) {
        obj[key] = utils.combine(obj[key], val);
      } else {
        obj[key] = val;
      }
    }
    return obj;
  };
  var parseObject = function(chain, val, options) {
    var leaf = val;
    for (var i = chain.length - 1; i >= 0; --i) {
      var obj;
      var root = chain[i];
      if (root === "[]" && options.parseArrays) {
        obj = [].concat(leaf);
      } else {
        obj = options.plainObjects ? Object.create(null) : {};
        var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
        var index = parseInt(cleanRoot, 10);
        if (!options.parseArrays && cleanRoot === "") {
          obj = {0: leaf};
        } else if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
          obj = [];
          obj[index] = leaf;
        } else {
          obj[cleanRoot] = leaf;
        }
      }
      leaf = obj;
    }
    return leaf;
  };
  var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
    if (!givenKey) {
      return;
    }
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;
    var segment = brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;
    var keys = [];
    if (parent) {
      if (!options.plainObjects && has.call(Object.prototype, parent)) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(parent);
    }
    var i = 0;
    while ((segment = child.exec(key)) !== null && i < options.depth) {
      i += 1;
      if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(segment[1]);
    }
    if (segment) {
      keys.push("[" + key.slice(segment.index) + "]");
    }
    return parseObject(keys, val, options);
  };
  var normalizeParseOptions = function normalizeParseOptions2(opts) {
    if (!opts) {
      return defaults;
    }
    if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
      throw new TypeError("Decoder has to be a function.");
    }
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new Error("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
    return {
      allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
      allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
      arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
      charset,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
      comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
      decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
      delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
      depth: typeof opts.depth === "number" ? opts.depth : defaults.depth,
      ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
      interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
      parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
      parseArrays: opts.parseArrays !== false,
      plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
    };
  };
  module2.exports = function(str, opts) {
    var options = normalizeParseOptions(opts);
    if (str === "" || str === null || typeof str === "undefined") {
      return options.plainObjects ? Object.create(null) : {};
    }
    var tempObj = typeof str === "string" ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};
    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];
      var newObj = parseKeys(key, tempObj[key], options);
      obj = utils.merge(obj, newObj, options);
    }
    return utils.compact(obj);
  };
});

// ../../node_modules/.pnpm/qs@6.7.0/node_modules/qs/lib/index.js
var require_lib9 = __commonJS((exports2, module2) => {
  "use strict";
  var stringify2 = require_stringify2();
  var parse2 = require_parse6();
  var formats = require_formats();
  module2.exports = {
    formats,
    parse: parse2,
    stringify: stringify2
  };
});

// ../../node_modules/.pnpm/body-parser@1.19.0/node_modules/body-parser/lib/types/urlencoded.js
var require_urlencoded = __commonJS((exports2, module2) => {
  /*!
   * body-parser
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var bytes = require_bytes();
  var contentType = require_content_type();
  var createError = require_http_errors();
  var debug3 = require_src5()("body-parser:urlencoded");
  var deprecate = require_depd()("body-parser");
  var read = require_read();
  var typeis = require_type_is();
  module2.exports = urlencoded;
  var parsers = Object.create(null);
  function urlencoded(options) {
    var opts = options || {};
    if (opts.extended === void 0) {
      deprecate("undefined extended: provide extended option");
    }
    var extended = opts.extended !== false;
    var inflate = opts.inflate !== false;
    var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
    var type = opts.type || "application/x-www-form-urlencoded";
    var verify = opts.verify || false;
    if (verify !== false && typeof verify !== "function") {
      throw new TypeError("option verify must be function");
    }
    var queryparse = extended ? extendedparser(opts) : simpleparser(opts);
    var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
    function parse2(body) {
      return body.length ? queryparse(body) : {};
    }
    return function urlencodedParser(req, res, next) {
      if (req._body) {
        debug3("body already parsed");
        next();
        return;
      }
      req.body = req.body || {};
      if (!typeis.hasBody(req)) {
        debug3("skip empty body");
        next();
        return;
      }
      debug3("content-type %j", req.headers["content-type"]);
      if (!shouldParse(req)) {
        debug3("skip parsing");
        next();
        return;
      }
      var charset = getCharset(req) || "utf-8";
      if (charset !== "utf-8") {
        debug3("invalid charset");
        next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
          charset,
          type: "charset.unsupported"
        }));
        return;
      }
      read(req, res, next, parse2, debug3, {
        debug: debug3,
        encoding: charset,
        inflate,
        limit,
        verify
      });
    };
  }
  function extendedparser(options) {
    var parameterLimit = options.parameterLimit !== void 0 ? options.parameterLimit : 1e3;
    var parse2 = parser("qs");
    if (isNaN(parameterLimit) || parameterLimit < 1) {
      throw new TypeError("option parameterLimit must be a positive number");
    }
    if (isFinite(parameterLimit)) {
      parameterLimit = parameterLimit | 0;
    }
    return function queryparse(body) {
      var paramCount = parameterCount(body, parameterLimit);
      if (paramCount === void 0) {
        debug3("too many parameters");
        throw createError(413, "too many parameters", {
          type: "parameters.too.many"
        });
      }
      var arrayLimit = Math.max(100, paramCount);
      debug3("parse extended urlencoding");
      return parse2(body, {
        allowPrototypes: true,
        arrayLimit,
        depth: Infinity,
        parameterLimit
      });
    };
  }
  function getCharset(req) {
    try {
      return (contentType.parse(req).parameters.charset || "").toLowerCase();
    } catch (e) {
      return void 0;
    }
  }
  function parameterCount(body, limit) {
    var count = 0;
    var index = 0;
    while ((index = body.indexOf("&", index)) !== -1) {
      count++;
      index++;
      if (count === limit) {
        return void 0;
      }
    }
    return count;
  }
  function parser(name) {
    var mod = parsers[name];
    if (mod !== void 0) {
      return mod.parse;
    }
    switch (name) {
      case "qs":
        mod = require_lib9();
        break;
      case "querystring":
        mod = require("querystring");
        break;
    }
    parsers[name] = mod;
    return mod.parse;
  }
  function simpleparser(options) {
    var parameterLimit = options.parameterLimit !== void 0 ? options.parameterLimit : 1e3;
    var parse2 = parser("querystring");
    if (isNaN(parameterLimit) || parameterLimit < 1) {
      throw new TypeError("option parameterLimit must be a positive number");
    }
    if (isFinite(parameterLimit)) {
      parameterLimit = parameterLimit | 0;
    }
    return function queryparse(body) {
      var paramCount = parameterCount(body, parameterLimit);
      if (paramCount === void 0) {
        debug3("too many parameters");
        throw createError(413, "too many parameters", {
          type: "parameters.too.many"
        });
      }
      debug3("parse urlencoding");
      return parse2(body, void 0, void 0, {maxKeys: parameterLimit});
    };
  }
  function typeChecker(type) {
    return function checkType(req) {
      return Boolean(typeis(req, type));
    };
  }
});

// ../../node_modules/.pnpm/body-parser@1.19.0/node_modules/body-parser/index.js
var require_body_parser = __commonJS((exports2, module2) => {
  /*!
   * body-parser
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var deprecate = require_depd()("body-parser");
  var parsers = Object.create(null);
  exports2 = module2.exports = deprecate.function(bodyParser, "bodyParser: use individual json/urlencoded middlewares");
  Object.defineProperty(exports2, "json", {
    configurable: true,
    enumerable: true,
    get: createParserGetter("json")
  });
  Object.defineProperty(exports2, "raw", {
    configurable: true,
    enumerable: true,
    get: createParserGetter("raw")
  });
  Object.defineProperty(exports2, "text", {
    configurable: true,
    enumerable: true,
    get: createParserGetter("text")
  });
  Object.defineProperty(exports2, "urlencoded", {
    configurable: true,
    enumerable: true,
    get: createParserGetter("urlencoded")
  });
  function bodyParser(options) {
    var opts = {};
    if (options) {
      for (var prop in options) {
        if (prop !== "type") {
          opts[prop] = options[prop];
        }
      }
    }
    var _urlencoded = exports2.urlencoded(opts);
    var _json = exports2.json(opts);
    return function bodyParser2(req, res, next) {
      _json(req, res, function(err) {
        if (err)
          return next(err);
        _urlencoded(req, res, next);
      });
    };
  }
  function createParserGetter(name) {
    return function get() {
      return loadParser(name);
    };
  }
  function loadParser(parserName) {
    var parser = parsers[parserName];
    if (parser !== void 0) {
      return parser;
    }
    switch (parserName) {
      case "json":
        parser = require_json2();
        break;
      case "raw":
        parser = require_raw();
        break;
      case "text":
        parser = require_text3();
        break;
      case "urlencoded":
        parser = require_urlencoded();
        break;
    }
    return parsers[parserName] = parser;
  }
});

// ../../node_modules/.pnpm/merge-descriptors@1.0.1/node_modules/merge-descriptors/index.js
var require_merge_descriptors = __commonJS((exports2, module2) => {
  /*!
   * merge-descriptors
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  module2.exports = merge;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function merge(dest, src, redefine) {
    if (!dest) {
      throw new TypeError("argument dest is required");
    }
    if (!src) {
      throw new TypeError("argument src is required");
    }
    if (redefine === void 0) {
      redefine = true;
    }
    Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName(name) {
      if (!redefine && hasOwnProperty.call(dest, name)) {
        return;
      }
      var descriptor = Object.getOwnPropertyDescriptor(src, name);
      Object.defineProperty(dest, name, descriptor);
    });
    return dest;
  }
});

// ../../node_modules/.pnpm/encodeurl@1.0.2/node_modules/encodeurl/index.js
var require_encodeurl = __commonJS((exports2, module2) => {
  /*!
   * encodeurl
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  module2.exports = encodeUrl;
  var ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
  var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
  var UNMATCHED_SURROGATE_PAIR_REPLACE = "$1\uFFFD$2";
  function encodeUrl(url) {
    return String(url).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
  }
});

// ../../node_modules/.pnpm/escape-html@1.0.3/node_modules/escape-html/index.js
var require_escape_html = __commonJS((exports2, module2) => {
  /*!
   * escape-html
   * Copyright(c) 2012-2013 TJ Holowaychuk
   * Copyright(c) 2015 Andreas Lubbe
   * Copyright(c) 2015 Tiancheng "Timothy" Gu
   * MIT Licensed
   */
  "use strict";
  var matchHtmlRegExp = /["'&<>]/;
  module2.exports = escapeHtml;
  function escapeHtml(string) {
    var str = "" + string;
    var match = matchHtmlRegExp.exec(str);
    if (!match) {
      return str;
    }
    var escape2;
    var html = "";
    var index = 0;
    var lastIndex = 0;
    for (index = match.index; index < str.length; index++) {
      switch (str.charCodeAt(index)) {
        case 34:
          escape2 = "&quot;";
          break;
        case 38:
          escape2 = "&amp;";
          break;
        case 39:
          escape2 = "&#39;";
          break;
        case 60:
          escape2 = "&lt;";
          break;
        case 62:
          escape2 = "&gt;";
          break;
        default:
          continue;
      }
      if (lastIndex !== index) {
        html += str.substring(lastIndex, index);
      }
      lastIndex = index + 1;
      html += escape2;
    }
    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
  }
});

// ../../node_modules/.pnpm/parseurl@1.3.3/node_modules/parseurl/index.js
var require_parseurl = __commonJS((exports2, module2) => {
  /*!
   * parseurl
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var url = require("url");
  var parse2 = url.parse;
  var Url = url.Url;
  module2.exports = parseurl;
  module2.exports.original = originalurl;
  function parseurl(req) {
    var url2 = req.url;
    if (url2 === void 0) {
      return void 0;
    }
    var parsed = req._parsedUrl;
    if (fresh(url2, parsed)) {
      return parsed;
    }
    parsed = fastparse(url2);
    parsed._raw = url2;
    return req._parsedUrl = parsed;
  }
  function originalurl(req) {
    var url2 = req.originalUrl;
    if (typeof url2 !== "string") {
      return parseurl(req);
    }
    var parsed = req._parsedOriginalUrl;
    if (fresh(url2, parsed)) {
      return parsed;
    }
    parsed = fastparse(url2);
    parsed._raw = url2;
    return req._parsedOriginalUrl = parsed;
  }
  function fastparse(str) {
    if (typeof str !== "string" || str.charCodeAt(0) !== 47) {
      return parse2(str);
    }
    var pathname = str;
    var query = null;
    var search = null;
    for (var i = 1; i < str.length; i++) {
      switch (str.charCodeAt(i)) {
        case 63:
          if (search === null) {
            pathname = str.substring(0, i);
            query = str.substring(i + 1);
            search = str.substring(i);
          }
          break;
        case 9:
        case 10:
        case 12:
        case 13:
        case 32:
        case 35:
        case 160:
        case 65279:
          return parse2(str);
      }
    }
    var url2 = Url !== void 0 ? new Url() : {};
    url2.path = str;
    url2.href = str;
    url2.pathname = pathname;
    if (search !== null) {
      url2.query = query;
      url2.search = search;
    }
    return url2;
  }
  function fresh(url2, parsedUrl) {
    return typeof parsedUrl === "object" && parsedUrl !== null && (Url === void 0 || parsedUrl instanceof Url) && parsedUrl._raw === url2;
  }
});

// ../../node_modules/.pnpm/finalhandler@1.1.2/node_modules/finalhandler/index.js
var require_finalhandler = __commonJS((exports2, module2) => {
  /*!
   * finalhandler
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var debug3 = require_src5()("finalhandler");
  var encodeUrl = require_encodeurl();
  var escapeHtml = require_escape_html();
  var onFinished = require_on_finished();
  var parseUrl = require_parseurl();
  var statuses = require_statuses();
  var unpipe = require_unpipe();
  var DOUBLE_SPACE_REGEXP = /\x20{2}/g;
  var NEWLINE_REGEXP = /\n/g;
  var defer = typeof setImmediate === "function" ? setImmediate : function(fn) {
    process.nextTick(fn.bind.apply(fn, arguments));
  };
  var isFinished = onFinished.isFinished;
  function createHtmlDocument(message) {
    var body = escapeHtml(message).replace(NEWLINE_REGEXP, "<br>").replace(DOUBLE_SPACE_REGEXP, " &nbsp;");
    return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>Error</title>\n</head>\n<body>\n<pre>' + body + "</pre>\n</body>\n</html>\n";
  }
  module2.exports = finalhandler;
  function finalhandler(req, res, options) {
    var opts = options || {};
    var env2 = opts.env || process.env.NODE_ENV || "development";
    var onerror = opts.onerror;
    return function(err) {
      var headers;
      var msg;
      var status;
      if (!err && headersSent(res)) {
        debug3("cannot 404 after headers sent");
        return;
      }
      if (err) {
        status = getErrorStatusCode(err);
        if (status === void 0) {
          status = getResponseStatusCode(res);
        } else {
          headers = getErrorHeaders(err);
        }
        msg = getErrorMessage(err, status, env2);
      } else {
        status = 404;
        msg = "Cannot " + req.method + " " + encodeUrl(getResourceName(req));
      }
      debug3("default %s", status);
      if (err && onerror) {
        defer(onerror, err, req, res);
      }
      if (headersSent(res)) {
        debug3("cannot %d after headers sent", status);
        req.socket.destroy();
        return;
      }
      send(req, res, status, headers, msg);
    };
  }
  function getErrorHeaders(err) {
    if (!err.headers || typeof err.headers !== "object") {
      return void 0;
    }
    var headers = Object.create(null);
    var keys = Object.keys(err.headers);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      headers[key] = err.headers[key];
    }
    return headers;
  }
  function getErrorMessage(err, status, env2) {
    var msg;
    if (env2 !== "production") {
      msg = err.stack;
      if (!msg && typeof err.toString === "function") {
        msg = err.toString();
      }
    }
    return msg || statuses[status];
  }
  function getErrorStatusCode(err) {
    if (typeof err.status === "number" && err.status >= 400 && err.status < 600) {
      return err.status;
    }
    if (typeof err.statusCode === "number" && err.statusCode >= 400 && err.statusCode < 600) {
      return err.statusCode;
    }
    return void 0;
  }
  function getResourceName(req) {
    try {
      return parseUrl.original(req).pathname;
    } catch (e) {
      return "resource";
    }
  }
  function getResponseStatusCode(res) {
    var status = res.statusCode;
    if (typeof status !== "number" || status < 400 || status > 599) {
      status = 500;
    }
    return status;
  }
  function headersSent(res) {
    return typeof res.headersSent !== "boolean" ? Boolean(res._header) : res.headersSent;
  }
  function send(req, res, status, headers, message) {
    function write2() {
      var body = createHtmlDocument(message);
      res.statusCode = status;
      res.statusMessage = statuses[status];
      setHeaders(res, headers);
      res.setHeader("Content-Security-Policy", "default-src 'none'");
      res.setHeader("X-Content-Type-Options", "nosniff");
      res.setHeader("Content-Type", "text/html; charset=utf-8");
      res.setHeader("Content-Length", Buffer.byteLength(body, "utf8"));
      if (req.method === "HEAD") {
        res.end();
        return;
      }
      res.end(body, "utf8");
    }
    if (isFinished(req)) {
      write2();
      return;
    }
    unpipe(req);
    onFinished(req, write2);
    req.resume();
  }
  function setHeaders(res, headers) {
    if (!headers) {
      return;
    }
    var keys = Object.keys(headers);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      res.setHeader(key, headers[key]);
    }
  }
});

// ../../node_modules/.pnpm/array-flatten@1.1.1/node_modules/array-flatten/array-flatten.js
var require_array_flatten = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = arrayFlatten;
  function flattenWithDepth(array, result, depth) {
    for (var i = 0; i < array.length; i++) {
      var value = array[i];
      if (depth > 0 && Array.isArray(value)) {
        flattenWithDepth(value, result, depth - 1);
      } else {
        result.push(value);
      }
    }
    return result;
  }
  function flattenForever(array, result) {
    for (var i = 0; i < array.length; i++) {
      var value = array[i];
      if (Array.isArray(value)) {
        flattenForever(value, result);
      } else {
        result.push(value);
      }
    }
    return result;
  }
  function arrayFlatten(array, depth) {
    if (depth == null) {
      return flattenForever(array, []);
    }
    return flattenWithDepth(array, [], depth);
  }
});

// ../../node_modules/.pnpm/path-to-regexp@0.1.7/node_modules/path-to-regexp/index.js
var require_path_to_regexp = __commonJS((exports2, module2) => {
  module2.exports = pathtoRegexp;
  var MATCHING_GROUP_REGEXP = /\((?!\?)/g;
  function pathtoRegexp(path10, keys, options) {
    options = options || {};
    keys = keys || [];
    var strict = options.strict;
    var end = options.end !== false;
    var flags = options.sensitive ? "" : "i";
    var extraOffset = 0;
    var keysOffset = keys.length;
    var i = 0;
    var name = 0;
    var m2;
    if (path10 instanceof RegExp) {
      while (m2 = MATCHING_GROUP_REGEXP.exec(path10.source)) {
        keys.push({
          name: name++,
          optional: false,
          offset: m2.index
        });
      }
      return path10;
    }
    if (Array.isArray(path10)) {
      path10 = path10.map(function(value) {
        return pathtoRegexp(value, keys, options).source;
      });
      return new RegExp("(?:" + path10.join("|") + ")", flags);
    }
    path10 = ("^" + path10 + (strict ? "" : path10[path10.length - 1] === "/" ? "?" : "/?")).replace(/\/\(/g, "/(?:").replace(/([\/\.])/g, "\\$1").replace(/(\\\/)?(\\\.)?:(\w+)(\(.*?\))?(\*)?(\?)?/g, function(match, slash, format10, key, capture, star, optional, offset) {
      slash = slash || "";
      format10 = format10 || "";
      capture = capture || "([^\\/" + format10 + "]+?)";
      optional = optional || "";
      keys.push({
        name: key,
        optional: !!optional,
        offset: offset + extraOffset
      });
      var result = "" + (optional ? "" : slash) + "(?:" + format10 + (optional ? slash : "") + capture + (star ? "((?:[\\/" + format10 + "].+?)?)" : "") + ")" + optional;
      extraOffset += result.length - match.length;
      return result;
    }).replace(/\*/g, function(star, index2) {
      var len = keys.length;
      while (len-- > keysOffset && keys[len].offset > index2) {
        keys[len].offset += 3;
      }
      return "(.*)";
    });
    while (m2 = MATCHING_GROUP_REGEXP.exec(path10)) {
      var escapeCount = 0;
      var index = m2.index;
      while (path10.charAt(--index) === "\\") {
        escapeCount++;
      }
      if (escapeCount % 2 === 1) {
        continue;
      }
      if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m2.index) {
        keys.splice(keysOffset + i, 0, {
          name: name++,
          optional: false,
          offset: m2.index
        });
      }
      i++;
    }
    path10 += end ? "$" : path10[path10.length - 1] === "/" ? "" : "(?=\\/|$)";
    return new RegExp(path10, flags);
  }
});

// ../../node_modules/.pnpm/express@4.17.1/node_modules/express/lib/router/layer.js
var require_layer = __commonJS((exports2, module2) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var pathRegexp = require_path_to_regexp();
  var debug3 = require_src5()("express:router:layer");
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  module2.exports = Layer;
  function Layer(path10, options, fn) {
    if (!(this instanceof Layer)) {
      return new Layer(path10, options, fn);
    }
    debug3("new %o", path10);
    var opts = options || {};
    this.handle = fn;
    this.name = fn.name || "<anonymous>";
    this.params = void 0;
    this.path = void 0;
    this.regexp = pathRegexp(path10, this.keys = [], opts);
    this.regexp.fast_star = path10 === "*";
    this.regexp.fast_slash = path10 === "/" && opts.end === false;
  }
  Layer.prototype.handle_error = function handle_error(error, req, res, next) {
    var fn = this.handle;
    if (fn.length !== 4) {
      return next(error);
    }
    try {
      fn(error, req, res, next);
    } catch (err) {
      next(err);
    }
  };
  Layer.prototype.handle_request = function handle(req, res, next) {
    var fn = this.handle;
    if (fn.length > 3) {
      return next();
    }
    try {
      fn(req, res, next);
    } catch (err) {
      next(err);
    }
  };
  Layer.prototype.match = function match(path10) {
    var match2;
    if (path10 != null) {
      if (this.regexp.fast_slash) {
        this.params = {};
        this.path = "";
        return true;
      }
      if (this.regexp.fast_star) {
        this.params = {"0": decode_param(path10)};
        this.path = path10;
        return true;
      }
      match2 = this.regexp.exec(path10);
    }
    if (!match2) {
      this.params = void 0;
      this.path = void 0;
      return false;
    }
    this.params = {};
    this.path = match2[0];
    var keys = this.keys;
    var params = this.params;
    for (var i = 1; i < match2.length; i++) {
      var key = keys[i - 1];
      var prop = key.name;
      var val = decode_param(match2[i]);
      if (val !== void 0 || !hasOwnProperty.call(params, prop)) {
        params[prop] = val;
      }
    }
    return true;
  };
  function decode_param(val) {
    if (typeof val !== "string" || val.length === 0) {
      return val;
    }
    try {
      return decodeURIComponent(val);
    } catch (err) {
      if (err instanceof URIError) {
        err.message = "Failed to decode param '" + val + "'";
        err.status = err.statusCode = 400;
      }
      throw err;
    }
  }
});

// ../../node_modules/.pnpm/methods@1.1.2/node_modules/methods/index.js
var require_methods = __commonJS((exports2, module2) => {
  /*!
   * methods
   * Copyright(c) 2013-2014 TJ Holowaychuk
   * Copyright(c) 2015-2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var http = require("http");
  module2.exports = getCurrentNodeMethods() || getBasicNodeMethods();
  function getCurrentNodeMethods() {
    return http.METHODS && http.METHODS.map(function lowerCaseMethod(method) {
      return method.toLowerCase();
    });
  }
  function getBasicNodeMethods() {
    return [
      "get",
      "post",
      "put",
      "head",
      "delete",
      "options",
      "trace",
      "copy",
      "lock",
      "mkcol",
      "move",
      "purge",
      "propfind",
      "proppatch",
      "unlock",
      "report",
      "mkactivity",
      "checkout",
      "merge",
      "m-search",
      "notify",
      "subscribe",
      "unsubscribe",
      "patch",
      "search",
      "connect"
    ];
  }
});

// ../../node_modules/.pnpm/express@4.17.1/node_modules/express/lib/router/route.js
var require_route3 = __commonJS((exports2, module2) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var debug3 = require_src5()("express:router:route");
  var flatten = require_array_flatten();
  var Layer = require_layer();
  var methods = require_methods();
  var slice = Array.prototype.slice;
  var toString = Object.prototype.toString;
  module2.exports = Route;
  function Route(path10) {
    this.path = path10;
    this.stack = [];
    debug3("new %o", path10);
    this.methods = {};
  }
  Route.prototype._handles_method = function _handles_method(method) {
    if (this.methods._all) {
      return true;
    }
    var name = method.toLowerCase();
    if (name === "head" && !this.methods["head"]) {
      name = "get";
    }
    return Boolean(this.methods[name]);
  };
  Route.prototype._options = function _options() {
    var methods2 = Object.keys(this.methods);
    if (this.methods.get && !this.methods.head) {
      methods2.push("head");
    }
    for (var i = 0; i < methods2.length; i++) {
      methods2[i] = methods2[i].toUpperCase();
    }
    return methods2;
  };
  Route.prototype.dispatch = function dispatch(req, res, done) {
    var idx = 0;
    var stack = this.stack;
    if (stack.length === 0) {
      return done();
    }
    var method = req.method.toLowerCase();
    if (method === "head" && !this.methods["head"]) {
      method = "get";
    }
    req.route = this;
    next();
    function next(err) {
      if (err && err === "route") {
        return done();
      }
      if (err && err === "router") {
        return done(err);
      }
      var layer = stack[idx++];
      if (!layer) {
        return done(err);
      }
      if (layer.method && layer.method !== method) {
        return next(err);
      }
      if (err) {
        layer.handle_error(err, req, res, next);
      } else {
        layer.handle_request(req, res, next);
      }
    }
  };
  Route.prototype.all = function all() {
    var handles = flatten(slice.call(arguments));
    for (var i = 0; i < handles.length; i++) {
      var handle = handles[i];
      if (typeof handle !== "function") {
        var type = toString.call(handle);
        var msg = "Route.all() requires a callback function but got a " + type;
        throw new TypeError(msg);
      }
      var layer = Layer("/", {}, handle);
      layer.method = void 0;
      this.methods._all = true;
      this.stack.push(layer);
    }
    return this;
  };
  methods.forEach(function(method) {
    Route.prototype[method] = function() {
      var handles = flatten(slice.call(arguments));
      for (var i = 0; i < handles.length; i++) {
        var handle = handles[i];
        if (typeof handle !== "function") {
          var type = toString.call(handle);
          var msg = "Route." + method + "() requires a callback function but got a " + type;
          throw new Error(msg);
        }
        debug3("%s %o", method, this.path);
        var layer = Layer("/", {}, handle);
        layer.method = method;
        this.methods[method] = true;
        this.stack.push(layer);
      }
      return this;
    };
  });
});

// ../../node_modules/.pnpm/utils-merge@1.0.1/node_modules/utils-merge/index.js
var require_utils_merge = __commonJS((exports2, module2) => {
  exports2 = module2.exports = function(a, b) {
    if (a && b) {
      for (var key in b) {
        a[key] = b[key];
      }
    }
    return a;
  };
});

// ../../node_modules/.pnpm/express@4.17.1/node_modules/express/lib/router/index.js
var require_router2 = __commonJS((exports2, module2) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var Route = require_route3();
  var Layer = require_layer();
  var methods = require_methods();
  var mixin = require_utils_merge();
  var debug3 = require_src5()("express:router");
  var deprecate = require_depd()("express");
  var flatten = require_array_flatten();
  var parseUrl = require_parseurl();
  var setPrototypeOf = require_setprototypeof();
  var objectRegExp = /^\[object (\S+)\]$/;
  var slice = Array.prototype.slice;
  var toString = Object.prototype.toString;
  var proto = module2.exports = function(options) {
    var opts = options || {};
    function router(req, res, next) {
      router.handle(req, res, next);
    }
    setPrototypeOf(router, proto);
    router.params = {};
    router._params = [];
    router.caseSensitive = opts.caseSensitive;
    router.mergeParams = opts.mergeParams;
    router.strict = opts.strict;
    router.stack = [];
    return router;
  };
  proto.param = function param(name, fn) {
    if (typeof name === "function") {
      deprecate("router.param(fn): Refactor to use path params");
      this._params.push(name);
      return;
    }
    var params = this._params;
    var len = params.length;
    var ret;
    if (name[0] === ":") {
      deprecate("router.param(" + JSON.stringify(name) + ", fn): Use router.param(" + JSON.stringify(name.substr(1)) + ", fn) instead");
      name = name.substr(1);
    }
    for (var i = 0; i < len; ++i) {
      if (ret = params[i](name, fn)) {
        fn = ret;
      }
    }
    if (typeof fn !== "function") {
      throw new Error("invalid param() call for " + name + ", got " + fn);
    }
    (this.params[name] = this.params[name] || []).push(fn);
    return this;
  };
  proto.handle = function handle(req, res, out) {
    var self2 = this;
    debug3("dispatching %s %s", req.method, req.url);
    var idx = 0;
    var protohost = getProtohost(req.url) || "";
    var removed = "";
    var slashAdded = false;
    var paramcalled = {};
    var options = [];
    var stack = self2.stack;
    var parentParams = req.params;
    var parentUrl = req.baseUrl || "";
    var done = restore(out, req, "baseUrl", "next", "params");
    req.next = next;
    if (req.method === "OPTIONS") {
      done = wrap(done, function(old, err) {
        if (err || options.length === 0)
          return old(err);
        sendOptionsResponse(res, options, old);
      });
    }
    req.baseUrl = parentUrl;
    req.originalUrl = req.originalUrl || req.url;
    next();
    function next(err) {
      var layerError = err === "route" ? null : err;
      if (slashAdded) {
        req.url = req.url.substr(1);
        slashAdded = false;
      }
      if (removed.length !== 0) {
        req.baseUrl = parentUrl;
        req.url = protohost + removed + req.url.substr(protohost.length);
        removed = "";
      }
      if (layerError === "router") {
        setImmediate(done, null);
        return;
      }
      if (idx >= stack.length) {
        setImmediate(done, layerError);
        return;
      }
      var path10 = getPathname(req);
      if (path10 == null) {
        return done(layerError);
      }
      var layer;
      var match;
      var route;
      while (match !== true && idx < stack.length) {
        layer = stack[idx++];
        match = matchLayer(layer, path10);
        route = layer.route;
        if (typeof match !== "boolean") {
          layerError = layerError || match;
        }
        if (match !== true) {
          continue;
        }
        if (!route) {
          continue;
        }
        if (layerError) {
          match = false;
          continue;
        }
        var method = req.method;
        var has_method = route._handles_method(method);
        if (!has_method && method === "OPTIONS") {
          appendMethods(options, route._options());
        }
        if (!has_method && method !== "HEAD") {
          match = false;
          continue;
        }
      }
      if (match !== true) {
        return done(layerError);
      }
      if (route) {
        req.route = route;
      }
      req.params = self2.mergeParams ? mergeParams(layer.params, parentParams) : layer.params;
      var layerPath = layer.path;
      self2.process_params(layer, paramcalled, req, res, function(err2) {
        if (err2) {
          return next(layerError || err2);
        }
        if (route) {
          return layer.handle_request(req, res, next);
        }
        trim_prefix(layer, layerError, layerPath, path10);
      });
    }
    function trim_prefix(layer, layerError, layerPath, path10) {
      if (layerPath.length !== 0) {
        var c = path10[layerPath.length];
        if (c && c !== "/" && c !== ".")
          return next(layerError);
        debug3("trim prefix (%s) from url %s", layerPath, req.url);
        removed = layerPath;
        req.url = protohost + req.url.substr(protohost.length + removed.length);
        if (!protohost && req.url[0] !== "/") {
          req.url = "/" + req.url;
          slashAdded = true;
        }
        req.baseUrl = parentUrl + (removed[removed.length - 1] === "/" ? removed.substring(0, removed.length - 1) : removed);
      }
      debug3("%s %s : %s", layer.name, layerPath, req.originalUrl);
      if (layerError) {
        layer.handle_error(layerError, req, res, next);
      } else {
        layer.handle_request(req, res, next);
      }
    }
  };
  proto.process_params = function process_params(layer, called, req, res, done) {
    var params = this.params;
    var keys = layer.keys;
    if (!keys || keys.length === 0) {
      return done();
    }
    var i = 0;
    var name;
    var paramIndex = 0;
    var key;
    var paramVal;
    var paramCallbacks;
    var paramCalled;
    function param(err) {
      if (err) {
        return done(err);
      }
      if (i >= keys.length) {
        return done();
      }
      paramIndex = 0;
      key = keys[i++];
      name = key.name;
      paramVal = req.params[name];
      paramCallbacks = params[name];
      paramCalled = called[name];
      if (paramVal === void 0 || !paramCallbacks) {
        return param();
      }
      if (paramCalled && (paramCalled.match === paramVal || paramCalled.error && paramCalled.error !== "route")) {
        req.params[name] = paramCalled.value;
        return param(paramCalled.error);
      }
      called[name] = paramCalled = {
        error: null,
        match: paramVal,
        value: paramVal
      };
      paramCallback();
    }
    function paramCallback(err) {
      var fn = paramCallbacks[paramIndex++];
      paramCalled.value = req.params[key.name];
      if (err) {
        paramCalled.error = err;
        param(err);
        return;
      }
      if (!fn)
        return param();
      try {
        fn(req, res, paramCallback, paramVal, key.name);
      } catch (e) {
        paramCallback(e);
      }
    }
    param();
  };
  proto.use = function use(fn) {
    var offset = 0;
    var path10 = "/";
    if (typeof fn !== "function") {
      var arg10 = fn;
      while (Array.isArray(arg10) && arg10.length !== 0) {
        arg10 = arg10[0];
      }
      if (typeof arg10 !== "function") {
        offset = 1;
        path10 = fn;
      }
    }
    var callbacks = flatten(slice.call(arguments, offset));
    if (callbacks.length === 0) {
      throw new TypeError("Router.use() requires a middleware function");
    }
    for (var i = 0; i < callbacks.length; i++) {
      var fn = callbacks[i];
      if (typeof fn !== "function") {
        throw new TypeError("Router.use() requires a middleware function but got a " + gettype(fn));
      }
      debug3("use %o %s", path10, fn.name || "<anonymous>");
      var layer = new Layer(path10, {
        sensitive: this.caseSensitive,
        strict: false,
        end: false
      }, fn);
      layer.route = void 0;
      this.stack.push(layer);
    }
    return this;
  };
  proto.route = function route(path10) {
    var route2 = new Route(path10);
    var layer = new Layer(path10, {
      sensitive: this.caseSensitive,
      strict: this.strict,
      end: true
    }, route2.dispatch.bind(route2));
    layer.route = route2;
    this.stack.push(layer);
    return route2;
  };
  methods.concat("all").forEach(function(method) {
    proto[method] = function(path10) {
      var route = this.route(path10);
      route[method].apply(route, slice.call(arguments, 1));
      return this;
    };
  });
  function appendMethods(list, addition) {
    for (var i = 0; i < addition.length; i++) {
      var method = addition[i];
      if (list.indexOf(method) === -1) {
        list.push(method);
      }
    }
  }
  function getPathname(req) {
    try {
      return parseUrl(req).pathname;
    } catch (err) {
      return void 0;
    }
  }
  function getProtohost(url) {
    if (typeof url !== "string" || url.length === 0 || url[0] === "/") {
      return void 0;
    }
    var searchIndex = url.indexOf("?");
    var pathLength = searchIndex !== -1 ? searchIndex : url.length;
    var fqdnIndex = url.substr(0, pathLength).indexOf("://");
    return fqdnIndex !== -1 ? url.substr(0, url.indexOf("/", 3 + fqdnIndex)) : void 0;
  }
  function gettype(obj) {
    var type = typeof obj;
    if (type !== "object") {
      return type;
    }
    return toString.call(obj).replace(objectRegExp, "$1");
  }
  function matchLayer(layer, path10) {
    try {
      return layer.match(path10);
    } catch (err) {
      return err;
    }
  }
  function mergeParams(params, parent) {
    if (typeof parent !== "object" || !parent) {
      return params;
    }
    var obj = mixin({}, parent);
    if (!(0 in params) || !(0 in parent)) {
      return mixin(obj, params);
    }
    var i = 0;
    var o = 0;
    while (i in params) {
      i++;
    }
    while (o in parent) {
      o++;
    }
    for (i--; i >= 0; i--) {
      params[i + o] = params[i];
      if (i < o) {
        delete params[i];
      }
    }
    return mixin(obj, params);
  }
  function restore(fn, obj) {
    var props = new Array(arguments.length - 2);
    var vals = new Array(arguments.length - 2);
    for (var i = 0; i < props.length; i++) {
      props[i] = arguments[i + 2];
      vals[i] = obj[props[i]];
    }
    return function() {
      for (var i2 = 0; i2 < props.length; i2++) {
        obj[props[i2]] = vals[i2];
      }
      return fn.apply(this, arguments);
    };
  }
  function sendOptionsResponse(res, options, next) {
    try {
      var body = options.join(",");
      res.set("Allow", body);
      res.send(body);
    } catch (err) {
      next(err);
    }
  }
  function wrap(old, fn) {
    return function proxy() {
      var args2 = new Array(arguments.length + 1);
      args2[0] = old;
      for (var i = 0, len = arguments.length; i < len; i++) {
        args2[i + 1] = arguments[i];
      }
      fn.apply(this, args2);
    };
  }
});

// ../../node_modules/.pnpm/express@4.17.1/node_modules/express/lib/middleware/init.js
var require_init = __commonJS((exports2) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var setPrototypeOf = require_setprototypeof();
  exports2.init = function(app) {
    return function expressInit(req, res, next) {
      if (app.enabled("x-powered-by"))
        res.setHeader("X-Powered-By", "Express");
      req.res = res;
      res.req = req;
      req.next = next;
      setPrototypeOf(req, app.request);
      setPrototypeOf(res, app.response);
      res.locals = res.locals || Object.create(null);
      next();
    };
  };
});

// ../../node_modules/.pnpm/express@4.17.1/node_modules/express/lib/middleware/query.js
var require_query = __commonJS((exports2, module2) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var merge = require_utils_merge();
  var parseUrl = require_parseurl();
  var qs = require_lib9();
  module2.exports = function query(options) {
    var opts = merge({}, options);
    var queryparse = qs.parse;
    if (typeof options === "function") {
      queryparse = options;
      opts = void 0;
    }
    if (opts !== void 0 && opts.allowPrototypes === void 0) {
      opts.allowPrototypes = true;
    }
    return function query2(req, res, next) {
      if (!req.query) {
        var val = parseUrl(req).query;
        req.query = queryparse(val, opts);
      }
      next();
    };
  };
});

// ../../node_modules/.pnpm/express@4.17.1/node_modules/express/lib/view.js
var require_view = __commonJS((exports2, module2) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var debug3 = require_src5()("express:view");
  var path10 = require("path");
  var fs9 = require("fs");
  var dirname2 = path10.dirname;
  var basename = path10.basename;
  var extname = path10.extname;
  var join2 = path10.join;
  var resolve = path10.resolve;
  module2.exports = View;
  function View(name, options) {
    var opts = options || {};
    this.defaultEngine = opts.defaultEngine;
    this.ext = extname(name);
    this.name = name;
    this.root = opts.root;
    if (!this.ext && !this.defaultEngine) {
      throw new Error("No default engine was specified and no extension was provided.");
    }
    var fileName = name;
    if (!this.ext) {
      this.ext = this.defaultEngine[0] !== "." ? "." + this.defaultEngine : this.defaultEngine;
      fileName += this.ext;
    }
    if (!opts.engines[this.ext]) {
      var mod = this.ext.substr(1);
      debug3('require "%s"', mod);
      var fn = require(mod).__express;
      if (typeof fn !== "function") {
        throw new Error('Module "' + mod + '" does not provide a view engine.');
      }
      opts.engines[this.ext] = fn;
    }
    this.engine = opts.engines[this.ext];
    this.path = this.lookup(fileName);
  }
  View.prototype.lookup = function lookup(name) {
    var path11;
    var roots = [].concat(this.root);
    debug3('lookup "%s"', name);
    for (var i = 0; i < roots.length && !path11; i++) {
      var root = roots[i];
      var loc = resolve(root, name);
      var dir = dirname2(loc);
      var file = basename(loc);
      path11 = this.resolve(dir, file);
    }
    return path11;
  };
  View.prototype.render = function render(options, callback) {
    debug3('render "%s"', this.path);
    this.engine(this.path, options, callback);
  };
  View.prototype.resolve = function resolve2(dir, file) {
    var ext = this.ext;
    var path11 = join2(dir, file);
    var stat = tryStat(path11);
    if (stat && stat.isFile()) {
      return path11;
    }
    path11 = join2(dir, basename(file, ext), "index" + ext);
    stat = tryStat(path11);
    if (stat && stat.isFile()) {
      return path11;
    }
  };
  function tryStat(path11) {
    debug3('stat "%s"', path11);
    try {
      return fs9.statSync(path11);
    } catch (e) {
      return void 0;
    }
  }
});

// ../../node_modules/.pnpm/content-disposition@0.5.3/node_modules/content-disposition/index.js
var require_content_disposition = __commonJS((exports2, module2) => {
  /*!
   * content-disposition
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  module2.exports = contentDisposition;
  module2.exports.parse = parse2;
  var basename = require("path").basename;
  var Buffer2 = require_safe_buffer().Buffer;
  var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g;
  var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
  var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;
  var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
  var QESC_REGEXP = /\\([\u0000-\u007f])/g;
  var QUOTE_REGEXP = /([\\"])/g;
  var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g;
  var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
  var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
  var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;
  var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
  function contentDisposition(filename, options) {
    var opts = options || {};
    var type = opts.type || "attachment";
    var params = createparams(filename, opts.fallback);
    return format10(new ContentDisposition(type, params));
  }
  function createparams(filename, fallback) {
    if (filename === void 0) {
      return;
    }
    var params = {};
    if (typeof filename !== "string") {
      throw new TypeError("filename must be a string");
    }
    if (fallback === void 0) {
      fallback = true;
    }
    if (typeof fallback !== "string" && typeof fallback !== "boolean") {
      throw new TypeError("fallback must be a string or boolean");
    }
    if (typeof fallback === "string" && NON_LATIN1_REGEXP.test(fallback)) {
      throw new TypeError("fallback must be ISO-8859-1 string");
    }
    var name = basename(filename);
    var isQuotedString = TEXT_REGEXP.test(name);
    var fallbackName = typeof fallback !== "string" ? fallback && getlatin1(name) : basename(fallback);
    var hasFallback = typeof fallbackName === "string" && fallbackName !== name;
    if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) {
      params["filename*"] = name;
    }
    if (isQuotedString || hasFallback) {
      params.filename = hasFallback ? fallbackName : name;
    }
    return params;
  }
  function format10(obj) {
    var parameters = obj.parameters;
    var type = obj.type;
    if (!type || typeof type !== "string" || !TOKEN_REGEXP.test(type)) {
      throw new TypeError("invalid type");
    }
    var string = String(type).toLowerCase();
    if (parameters && typeof parameters === "object") {
      var param;
      var params = Object.keys(parameters).sort();
      for (var i = 0; i < params.length; i++) {
        param = params[i];
        var val = param.substr(-1) === "*" ? ustring(parameters[param]) : qstring(parameters[param]);
        string += "; " + param + "=" + val;
      }
    }
    return string;
  }
  function decodefield(str) {
    var match = EXT_VALUE_REGEXP.exec(str);
    if (!match) {
      throw new TypeError("invalid extended field value");
    }
    var charset = match[1].toLowerCase();
    var encoded = match[2];
    var value;
    var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);
    switch (charset) {
      case "iso-8859-1":
        value = getlatin1(binary);
        break;
      case "utf-8":
        value = Buffer2.from(binary, "binary").toString("utf8");
        break;
      default:
        throw new TypeError("unsupported charset in extended field");
    }
    return value;
  }
  function getlatin1(val) {
    return String(val).replace(NON_LATIN1_REGEXP, "?");
  }
  function parse2(string) {
    if (!string || typeof string !== "string") {
      throw new TypeError("argument string is required");
    }
    var match = DISPOSITION_TYPE_REGEXP.exec(string);
    if (!match) {
      throw new TypeError("invalid type format");
    }
    var index = match[0].length;
    var type = match[1].toLowerCase();
    var key;
    var names = [];
    var params = {};
    var value;
    index = PARAM_REGEXP.lastIndex = match[0].substr(-1) === ";" ? index - 1 : index;
    while (match = PARAM_REGEXP.exec(string)) {
      if (match.index !== index) {
        throw new TypeError("invalid parameter format");
      }
      index += match[0].length;
      key = match[1].toLowerCase();
      value = match[2];
      if (names.indexOf(key) !== -1) {
        throw new TypeError("invalid duplicate parameter");
      }
      names.push(key);
      if (key.indexOf("*") + 1 === key.length) {
        key = key.slice(0, -1);
        value = decodefield(value);
        params[key] = value;
        continue;
      }
      if (typeof params[key] === "string") {
        continue;
      }
      if (value[0] === '"') {
        value = value.substr(1, value.length - 2).replace(QESC_REGEXP, "$1");
      }
      params[key] = value;
    }
    if (index !== -1 && index !== string.length) {
      throw new TypeError("invalid parameter format");
    }
    return new ContentDisposition(type, params);
  }
  function pdecode(str, hex) {
    return String.fromCharCode(parseInt(hex, 16));
  }
  function pencode(char) {
    return "%" + String(char).charCodeAt(0).toString(16).toUpperCase();
  }
  function qstring(val) {
    var str = String(val);
    return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
  }
  function ustring(val) {
    var str = String(val);
    var encoded = encodeURIComponent(str).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
    return "UTF-8''" + encoded;
  }
  function ContentDisposition(type, parameters) {
    this.type = type;
    this.parameters = parameters;
  }
});

// ../../node_modules/.pnpm/http-errors@1.7.3/node_modules/http-errors/index.js
var require_http_errors2 = __commonJS((exports2, module2) => {
  /*!
   * http-errors
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var deprecate = require_depd()("http-errors");
  var setPrototypeOf = require_setprototypeof();
  var statuses = require_statuses();
  var inherits = require_inherits();
  var toIdentifier = require_toidentifier();
  module2.exports = createError;
  module2.exports.HttpError = createHttpErrorConstructor();
  populateConstructorExports(module2.exports, statuses.codes, module2.exports.HttpError);
  function codeClass(status) {
    return Number(String(status).charAt(0) + "00");
  }
  function createError() {
    var err;
    var msg;
    var status = 500;
    var props = {};
    for (var i = 0; i < arguments.length; i++) {
      var arg10 = arguments[i];
      if (arg10 instanceof Error) {
        err = arg10;
        status = err.status || err.statusCode || status;
        continue;
      }
      switch (typeof arg10) {
        case "string":
          msg = arg10;
          break;
        case "number":
          status = arg10;
          if (i !== 0) {
            deprecate("non-first-argument status code; replace with createError(" + arg10 + ", ...)");
          }
          break;
        case "object":
          props = arg10;
          break;
      }
    }
    if (typeof status === "number" && (status < 400 || status >= 600)) {
      deprecate("non-error status code; use only 4xx or 5xx status codes");
    }
    if (typeof status !== "number" || !statuses[status] && (status < 400 || status >= 600)) {
      status = 500;
    }
    var HttpError = createError[status] || createError[codeClass(status)];
    if (!err) {
      err = HttpError ? new HttpError(msg) : new Error(msg || statuses[status]);
      Error.captureStackTrace(err, createError);
    }
    if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
      err.expose = status < 500;
      err.status = err.statusCode = status;
    }
    for (var key in props) {
      if (key !== "status" && key !== "statusCode") {
        err[key] = props[key];
      }
    }
    return err;
  }
  function createHttpErrorConstructor() {
    function HttpError() {
      throw new TypeError("cannot construct abstract class");
    }
    inherits(HttpError, Error);
    return HttpError;
  }
  function createClientErrorConstructor(HttpError, name, code) {
    var className = name.match(/Error$/) ? name : name + "Error";
    function ClientError(message) {
      var msg = message != null ? message : statuses[code];
      var err = new Error(msg);
      Error.captureStackTrace(err, ClientError);
      setPrototypeOf(err, ClientError.prototype);
      Object.defineProperty(err, "message", {
        enumerable: true,
        configurable: true,
        value: msg,
        writable: true
      });
      Object.defineProperty(err, "name", {
        enumerable: false,
        configurable: true,
        value: className,
        writable: true
      });
      return err;
    }
    inherits(ClientError, HttpError);
    nameFunc(ClientError, className);
    ClientError.prototype.status = code;
    ClientError.prototype.statusCode = code;
    ClientError.prototype.expose = true;
    return ClientError;
  }
  function createServerErrorConstructor(HttpError, name, code) {
    var className = name.match(/Error$/) ? name : name + "Error";
    function ServerError(message) {
      var msg = message != null ? message : statuses[code];
      var err = new Error(msg);
      Error.captureStackTrace(err, ServerError);
      setPrototypeOf(err, ServerError.prototype);
      Object.defineProperty(err, "message", {
        enumerable: true,
        configurable: true,
        value: msg,
        writable: true
      });
      Object.defineProperty(err, "name", {
        enumerable: false,
        configurable: true,
        value: className,
        writable: true
      });
      return err;
    }
    inherits(ServerError, HttpError);
    nameFunc(ServerError, className);
    ServerError.prototype.status = code;
    ServerError.prototype.statusCode = code;
    ServerError.prototype.expose = false;
    return ServerError;
  }
  function nameFunc(func, name) {
    var desc = Object.getOwnPropertyDescriptor(func, "name");
    if (desc && desc.configurable) {
      desc.value = name;
      Object.defineProperty(func, "name", desc);
    }
  }
  function populateConstructorExports(exports3, codes, HttpError) {
    codes.forEach(function forEachCode(code) {
      var CodeError;
      var name = toIdentifier(statuses[code]);
      switch (codeClass(code)) {
        case 400:
          CodeError = createClientErrorConstructor(HttpError, name, code);
          break;
        case 500:
          CodeError = createServerErrorConstructor(HttpError, name, code);
          break;
      }
      if (CodeError) {
        exports3[code] = CodeError;
        exports3[name] = CodeError;
      }
    });
    exports3["I'mateapot"] = deprecate.function(exports3.ImATeapot, `"I'mateapot"; use "ImATeapot" instead`);
  }
});

// ../../node_modules/.pnpm/destroy@1.0.4/node_modules/destroy/index.js
var require_destroy3 = __commonJS((exports2, module2) => {
  /*!
   * destroy
   * Copyright(c) 2014 Jonathan Ong
   * MIT Licensed
   */
  "use strict";
  var ReadStream = require("fs").ReadStream;
  var Stream = require("stream");
  module2.exports = destroy;
  function destroy(stream) {
    if (stream instanceof ReadStream) {
      return destroyReadStream(stream);
    }
    if (!(stream instanceof Stream)) {
      return stream;
    }
    if (typeof stream.destroy === "function") {
      stream.destroy();
    }
    return stream;
  }
  function destroyReadStream(stream) {
    stream.destroy();
    if (typeof stream.close === "function") {
      stream.on("open", onOpenClose);
    }
    return stream;
  }
  function onOpenClose() {
    if (typeof this.fd === "number") {
      this.close();
    }
  }
});

// ../../node_modules/.pnpm/etag@1.8.1/node_modules/etag/index.js
var require_etag = __commonJS((exports2, module2) => {
  /*!
   * etag
   * Copyright(c) 2014-2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  module2.exports = etag;
  var crypto2 = require("crypto");
  var Stats = require("fs").Stats;
  var toString = Object.prototype.toString;
  function entitytag(entity) {
    if (entity.length === 0) {
      return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"';
    }
    var hash = crypto2.createHash("sha1").update(entity, "utf8").digest("base64").substring(0, 27);
    var len = typeof entity === "string" ? Buffer.byteLength(entity, "utf8") : entity.length;
    return '"' + len.toString(16) + "-" + hash + '"';
  }
  function etag(entity, options) {
    if (entity == null) {
      throw new TypeError("argument entity is required");
    }
    var isStats = isstats(entity);
    var weak = options && typeof options.weak === "boolean" ? options.weak : isStats;
    if (!isStats && typeof entity !== "string" && !Buffer.isBuffer(entity)) {
      throw new TypeError("argument entity must be string, Buffer, or fs.Stats");
    }
    var tag = isStats ? stattag(entity) : entitytag(entity);
    return weak ? "W/" + tag : tag;
  }
  function isstats(obj) {
    if (typeof Stats === "function" && obj instanceof Stats) {
      return true;
    }
    return obj && typeof obj === "object" && "ctime" in obj && toString.call(obj.ctime) === "[object Date]" && "mtime" in obj && toString.call(obj.mtime) === "[object Date]" && "ino" in obj && typeof obj.ino === "number" && "size" in obj && typeof obj.size === "number";
  }
  function stattag(stat) {
    var mtime = stat.mtime.getTime().toString(16);
    var size = stat.size.toString(16);
    return '"' + size + "-" + mtime + '"';
  }
});

// ../../node_modules/.pnpm/fresh@0.5.2/node_modules/fresh/index.js
var require_fresh = __commonJS((exports2, module2) => {
  /*!
   * fresh
   * Copyright(c) 2012 TJ Holowaychuk
   * Copyright(c) 2016-2017 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;
  module2.exports = fresh;
  function fresh(reqHeaders, resHeaders) {
    var modifiedSince = reqHeaders["if-modified-since"];
    var noneMatch = reqHeaders["if-none-match"];
    if (!modifiedSince && !noneMatch) {
      return false;
    }
    var cacheControl = reqHeaders["cache-control"];
    if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {
      return false;
    }
    if (noneMatch && noneMatch !== "*") {
      var etag = resHeaders["etag"];
      if (!etag) {
        return false;
      }
      var etagStale = true;
      var matches = parseTokenList(noneMatch);
      for (var i = 0; i < matches.length; i++) {
        var match = matches[i];
        if (match === etag || match === "W/" + etag || "W/" + match === etag) {
          etagStale = false;
          break;
        }
      }
      if (etagStale) {
        return false;
      }
    }
    if (modifiedSince) {
      var lastModified = resHeaders["last-modified"];
      var modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince));
      if (modifiedStale) {
        return false;
      }
    }
    return true;
  }
  function parseHttpDate(date) {
    var timestamp = date && Date.parse(date);
    return typeof timestamp === "number" ? timestamp : NaN;
  }
  function parseTokenList(str) {
    var end = 0;
    var list = [];
    var start = 0;
    for (var i = 0, len = str.length; i < len; i++) {
      switch (str.charCodeAt(i)) {
        case 32:
          if (start === end) {
            start = end = i + 1;
          }
          break;
        case 44:
          list.push(str.substring(start, end));
          start = end = i + 1;
          break;
        default:
          end = i + 1;
          break;
      }
    }
    list.push(str.substring(start, end));
    return list;
  }
});

// ../../node_modules/.pnpm/mime@1.6.0/node_modules/mime/types.json
var require_types6 = __commonJS((exports2, module2) => {
  module2.exports = {"application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomsvc+xml": ["atomsvc"], "application/bdoc": ["bdoc"], "application/ccxml+xml": ["ccxml"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["ecma"], "application/emma+xml": ["emma"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/font-tdpfr": ["pfr"], "application/font-woff": [], "application/font-woff2": [], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/prs.cww": ["cww"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["xfdf"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.apple.pkpass": ["pkpass"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-apps.document": ["gdoc"], "application/vnd.google-apps.presentation": ["gslides"], "application/vnd.google-apps.spreadsheet": ["gsheet"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-outlook": ["msg"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.n-gage.symbian.install": ["n-gage"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.wadl+xml": ["wadl"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": [], "application/x-arj": ["arj"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bdoc": [], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-cocoa": ["cco"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-httpd-php": ["php"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": [], "application/x-java-archive-diff": ["jardiff"], "application/x-java-jnlp-file": ["jnlp"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-makeself": ["run"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdos-program": [], "application/x-msdownload": ["com", "bat"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["wmf", "emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-ns-proxy-autoconfig": ["pac"], "application/x-nzb": ["nzb"], "application/x-perl": ["pl", "pm"], "application/x-pilot": [], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["rar"], "application/x-redhat-package-manager": ["rpm"], "application/x-research-info-systems": ["ris"], "application/x-sea": ["sea"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl", "tk"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["obj"], "application/x-ustar": ["ustar"], "application/x-virtualbox-hdd": ["hdd"], "application/x-virtualbox-ova": ["ova"], "application/x-virtualbox-ovf": ["ovf"], "application/x-virtualbox-vbox": ["vbox"], "application/x-virtualbox-vbox-extpack": ["vbox-extpack"], "application/x-virtualbox-vdi": ["vdi"], "application/x-virtualbox-vhd": ["vhd"], "application/x-virtualbox-vmdk": ["vmdk"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt", "pem"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "application/xaml+xml": ["xaml"], "application/xcap-diff+xml": ["xdf"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": [], "audio/adpcm": ["adp"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mp3": [], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/wav": ["wav"], "audio/wave": [], "audio/webm": ["weba"], "audio/x-aac": ["aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-m4a": [], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-realaudio": [], "audio/x-wav": [], "audio/xm": ["xm"], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/apng": ["apng"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/ief": ["ief"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/ktx": ["ktx"], "image/png": ["png"], "image/prs.btif": ["btif"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/tiff": ["tiff", "tif"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": [], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/webp": ["webp"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["ico"], "image/x-jng": ["jng"], "image/x-mrsid-image": ["sid"], "image/x-ms-bmp": [], "image/x-pcx": ["pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "message/rfc822": ["eml", "mime"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.vtu": ["vtu"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["x3db", "x3dbz"], "model/x3d+vrml": ["x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/hjson": ["hjson"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/prs.lines.tag": ["dsc"], "text/richtext": ["rtx"], "text/rtf": [], "text/sgml": ["sgml", "sgm"], "text/slim": ["slim", "slm"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/vtt": ["vtt"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-org": [], "text/x-pascal": ["p", "pas"], "text/x-processing": ["pde"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-suse-ymp": ["ymp"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "text/xml": [], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/jpeg": ["jpgv"], "video/jpm": ["jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/webm": ["webm"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"]};
});

// ../../node_modules/.pnpm/mime@1.6.0/node_modules/mime/mime.js
var require_mime = __commonJS((exports2, module2) => {
  var path10 = require("path");
  var fs9 = require("fs");
  function Mime() {
    this.types = Object.create(null);
    this.extensions = Object.create(null);
  }
  Mime.prototype.define = function(map) {
    for (var type in map) {
      var exts = map[type];
      for (var i = 0; i < exts.length; i++) {
        if (process.env.DEBUG_MIME && this.types[exts[i]]) {
          console.warn((this._loading || "define()").replace(/.*\//, ""), 'changes "' + exts[i] + '" extension type from ' + this.types[exts[i]] + " to " + type);
        }
        this.types[exts[i]] = type;
      }
      if (!this.extensions[type]) {
        this.extensions[type] = exts[0];
      }
    }
  };
  Mime.prototype.load = function(file) {
    this._loading = file;
    var map = {}, content = fs9.readFileSync(file, "ascii"), lines = content.split(/[\r\n]+/);
    lines.forEach(function(line) {
      var fields = line.replace(/\s*#.*|^\s*|\s*$/g, "").split(/\s+/);
      map[fields.shift()] = fields;
    });
    this.define(map);
    this._loading = null;
  };
  Mime.prototype.lookup = function(path11, fallback) {
    var ext = path11.replace(/^.*[\.\/\\]/, "").toLowerCase();
    return this.types[ext] || fallback || this.default_type;
  };
  Mime.prototype.extension = function(mimeType) {
    var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
    return this.extensions[type];
  };
  var mime = new Mime();
  mime.define(require_types6());
  mime.default_type = mime.lookup("bin");
  mime.Mime = Mime;
  mime.charsets = {
    lookup: function(mimeType, fallback) {
      return /^text\/|^application\/(javascript|json)/.test(mimeType) ? "UTF-8" : fallback;
    }
  };
  module2.exports = mime;
});

// ../../node_modules/.pnpm/ms@2.1.1/node_modules/ms/index.js
var require_ms4 = __commonJS((exports2, module2) => {
  var s2 = 1e3;
  var m2 = s2 * 60;
  var h2 = m2 * 60;
  var d2 = h2 * 24;
  var w2 = d2 * 7;
  var y2 = d2 * 365.25;
  module2.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse2(val);
    } else if (type === "number" && isNaN(val) === false) {
      return options.long ? fmtLong2(val) : fmtShort2(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^((?:\d+)?\-?\d?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y2;
      case "weeks":
      case "week":
      case "w":
        return n * w2;
      case "days":
      case "day":
      case "d":
        return n * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort2(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return Math.round(ms2 / d2) + "d";
    }
    if (msAbs >= h2) {
      return Math.round(ms2 / h2) + "h";
    }
    if (msAbs >= m2) {
      return Math.round(ms2 / m2) + "m";
    }
    if (msAbs >= s2) {
      return Math.round(ms2 / s2) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong2(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return plural2(ms2, msAbs, d2, "day");
    }
    if (msAbs >= h2) {
      return plural2(ms2, msAbs, h2, "hour");
    }
    if (msAbs >= m2) {
      return plural2(ms2, msAbs, m2, "minute");
    }
    if (msAbs >= s2) {
      return plural2(ms2, msAbs, s2, "second");
    }
    return ms2 + " ms";
  }
  function plural2(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
});

// ../../node_modules/.pnpm/range-parser@1.2.1/node_modules/range-parser/index.js
var require_range_parser = __commonJS((exports2, module2) => {
  /*!
   * range-parser
   * Copyright(c) 2012-2014 TJ Holowaychuk
   * Copyright(c) 2015-2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  module2.exports = rangeParser;
  function rangeParser(size, str, options) {
    if (typeof str !== "string") {
      throw new TypeError("argument str must be a string");
    }
    var index = str.indexOf("=");
    if (index === -1) {
      return -2;
    }
    var arr = str.slice(index + 1).split(",");
    var ranges = [];
    ranges.type = str.slice(0, index);
    for (var i = 0; i < arr.length; i++) {
      var range = arr[i].split("-");
      var start = parseInt(range[0], 10);
      var end = parseInt(range[1], 10);
      if (isNaN(start)) {
        start = size - end;
        end = size - 1;
      } else if (isNaN(end)) {
        end = size - 1;
      }
      if (end > size - 1) {
        end = size - 1;
      }
      if (isNaN(start) || isNaN(end) || start > end || start < 0) {
        continue;
      }
      ranges.push({
        start,
        end
      });
    }
    if (ranges.length < 1) {
      return -1;
    }
    return options && options.combine ? combineRanges(ranges) : ranges;
  }
  function combineRanges(ranges) {
    var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);
    for (var j = 0, i = 1; i < ordered.length; i++) {
      var range = ordered[i];
      var current = ordered[j];
      if (range.start > current.end + 1) {
        ordered[++j] = range;
      } else if (range.end > current.end) {
        current.end = range.end;
        current.index = Math.min(current.index, range.index);
      }
    }
    ordered.length = j + 1;
    var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);
    combined.type = ranges.type;
    return combined;
  }
  function mapWithIndex(range, index) {
    return {
      start: range.start,
      end: range.end,
      index
    };
  }
  function mapWithoutIndex(range) {
    return {
      start: range.start,
      end: range.end
    };
  }
  function sortByRangeIndex(a, b) {
    return a.index - b.index;
  }
  function sortByRangeStart(a, b) {
    return a.start - b.start;
  }
});

// ../../node_modules/.pnpm/send@0.17.1/node_modules/send/index.js
var require_send = __commonJS((exports2, module2) => {
  /*!
   * send
   * Copyright(c) 2012 TJ Holowaychuk
   * Copyright(c) 2014-2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var createError = require_http_errors2();
  var debug3 = require_src5()("send");
  var deprecate = require_depd()("send");
  var destroy = require_destroy3();
  var encodeUrl = require_encodeurl();
  var escapeHtml = require_escape_html();
  var etag = require_etag();
  var fresh = require_fresh();
  var fs9 = require("fs");
  var mime = require_mime();
  var ms2 = require_ms4();
  var onFinished = require_on_finished();
  var parseRange = require_range_parser();
  var path10 = require("path");
  var statuses = require_statuses();
  var Stream = require("stream");
  var util2 = require("util");
  var extname = path10.extname;
  var join2 = path10.join;
  var normalize = path10.normalize;
  var resolve = path10.resolve;
  var sep = path10.sep;
  var BYTES_RANGE_REGEXP = /^ *bytes=/;
  var MAX_MAXAGE = 60 * 60 * 24 * 365 * 1e3;
  var UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
  module2.exports = send;
  module2.exports.mime = mime;
  function send(req, path11, options) {
    return new SendStream(req, path11, options);
  }
  function SendStream(req, path11, options) {
    Stream.call(this);
    var opts = options || {};
    this.options = opts;
    this.path = path11;
    this.req = req;
    this._acceptRanges = opts.acceptRanges !== void 0 ? Boolean(opts.acceptRanges) : true;
    this._cacheControl = opts.cacheControl !== void 0 ? Boolean(opts.cacheControl) : true;
    this._etag = opts.etag !== void 0 ? Boolean(opts.etag) : true;
    this._dotfiles = opts.dotfiles !== void 0 ? opts.dotfiles : "ignore";
    if (this._dotfiles !== "ignore" && this._dotfiles !== "allow" && this._dotfiles !== "deny") {
      throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"');
    }
    this._hidden = Boolean(opts.hidden);
    if (opts.hidden !== void 0) {
      deprecate("hidden: use dotfiles: '" + (this._hidden ? "allow" : "ignore") + "' instead");
    }
    if (opts.dotfiles === void 0) {
      this._dotfiles = void 0;
    }
    this._extensions = opts.extensions !== void 0 ? normalizeList(opts.extensions, "extensions option") : [];
    this._immutable = opts.immutable !== void 0 ? Boolean(opts.immutable) : false;
    this._index = opts.index !== void 0 ? normalizeList(opts.index, "index option") : ["index.html"];
    this._lastModified = opts.lastModified !== void 0 ? Boolean(opts.lastModified) : true;
    this._maxage = opts.maxAge || opts.maxage;
    this._maxage = typeof this._maxage === "string" ? ms2(this._maxage) : Number(this._maxage);
    this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
    this._root = opts.root ? resolve(opts.root) : null;
    if (!this._root && opts.from) {
      this.from(opts.from);
    }
  }
  util2.inherits(SendStream, Stream);
  SendStream.prototype.etag = deprecate.function(function etag2(val) {
    this._etag = Boolean(val);
    debug3("etag %s", this._etag);
    return this;
  }, "send.etag: pass etag as option");
  SendStream.prototype.hidden = deprecate.function(function hidden(val) {
    this._hidden = Boolean(val);
    this._dotfiles = void 0;
    debug3("hidden %s", this._hidden);
    return this;
  }, "send.hidden: use dotfiles option");
  SendStream.prototype.index = deprecate.function(function index(paths) {
    var index2 = !paths ? [] : normalizeList(paths, "paths argument");
    debug3("index %o", paths);
    this._index = index2;
    return this;
  }, "send.index: pass index as option");
  SendStream.prototype.root = function root(path11) {
    this._root = resolve(String(path11));
    debug3("root %s", this._root);
    return this;
  };
  SendStream.prototype.from = deprecate.function(SendStream.prototype.root, "send.from: pass root as option");
  SendStream.prototype.root = deprecate.function(SendStream.prototype.root, "send.root: pass root as option");
  SendStream.prototype.maxage = deprecate.function(function maxage(maxAge) {
    this._maxage = typeof maxAge === "string" ? ms2(maxAge) : Number(maxAge);
    this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
    debug3("max-age %d", this._maxage);
    return this;
  }, "send.maxage: pass maxAge as option");
  SendStream.prototype.error = function error(status, err) {
    if (hasListeners(this, "error")) {
      return this.emit("error", createError(status, err, {
        expose: false
      }));
    }
    var res = this.res;
    var msg = statuses[status] || String(status);
    var doc = createHtmlDocument("Error", escapeHtml(msg));
    clearHeaders(res);
    if (err && err.headers) {
      setHeaders(res, err.headers);
    }
    res.statusCode = status;
    res.setHeader("Content-Type", "text/html; charset=UTF-8");
    res.setHeader("Content-Length", Buffer.byteLength(doc));
    res.setHeader("Content-Security-Policy", "default-src 'none'");
    res.setHeader("X-Content-Type-Options", "nosniff");
    res.end(doc);
  };
  SendStream.prototype.hasTrailingSlash = function hasTrailingSlash() {
    return this.path[this.path.length - 1] === "/";
  };
  SendStream.prototype.isConditionalGET = function isConditionalGET() {
    return this.req.headers["if-match"] || this.req.headers["if-unmodified-since"] || this.req.headers["if-none-match"] || this.req.headers["if-modified-since"];
  };
  SendStream.prototype.isPreconditionFailure = function isPreconditionFailure() {
    var req = this.req;
    var res = this.res;
    var match = req.headers["if-match"];
    if (match) {
      var etag2 = res.getHeader("ETag");
      return !etag2 || match !== "*" && parseTokenList(match).every(function(match2) {
        return match2 !== etag2 && match2 !== "W/" + etag2 && "W/" + match2 !== etag2;
      });
    }
    var unmodifiedSince = parseHttpDate(req.headers["if-unmodified-since"]);
    if (!isNaN(unmodifiedSince)) {
      var lastModified = parseHttpDate(res.getHeader("Last-Modified"));
      return isNaN(lastModified) || lastModified > unmodifiedSince;
    }
    return false;
  };
  SendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields() {
    var res = this.res;
    var headers = getHeaderNames(res);
    for (var i = 0; i < headers.length; i++) {
      var header = headers[i];
      if (header.substr(0, 8) === "content-" && header !== "content-location") {
        res.removeHeader(header);
      }
    }
  };
  SendStream.prototype.notModified = function notModified() {
    var res = this.res;
    debug3("not modified");
    this.removeContentHeaderFields();
    res.statusCode = 304;
    res.end();
  };
  SendStream.prototype.headersAlreadySent = function headersAlreadySent() {
    var err = new Error("Can't set headers after they are sent.");
    debug3("headers already sent");
    this.error(500, err);
  };
  SendStream.prototype.isCachable = function isCachable() {
    var statusCode = this.res.statusCode;
    return statusCode >= 200 && statusCode < 300 || statusCode === 304;
  };
  SendStream.prototype.onStatError = function onStatError(error) {
    switch (error.code) {
      case "ENAMETOOLONG":
      case "ENOENT":
      case "ENOTDIR":
        this.error(404, error);
        break;
      default:
        this.error(500, error);
        break;
    }
  };
  SendStream.prototype.isFresh = function isFresh() {
    return fresh(this.req.headers, {
      etag: this.res.getHeader("ETag"),
      "last-modified": this.res.getHeader("Last-Modified")
    });
  };
  SendStream.prototype.isRangeFresh = function isRangeFresh() {
    var ifRange = this.req.headers["if-range"];
    if (!ifRange) {
      return true;
    }
    if (ifRange.indexOf('"') !== -1) {
      var etag2 = this.res.getHeader("ETag");
      return Boolean(etag2 && ifRange.indexOf(etag2) !== -1);
    }
    var lastModified = this.res.getHeader("Last-Modified");
    return parseHttpDate(lastModified) <= parseHttpDate(ifRange);
  };
  SendStream.prototype.redirect = function redirect(path11) {
    var res = this.res;
    if (hasListeners(this, "directory")) {
      this.emit("directory", res, path11);
      return;
    }
    if (this.hasTrailingSlash()) {
      this.error(403);
      return;
    }
    var loc = encodeUrl(collapseLeadingSlashes(this.path + "/"));
    var doc = createHtmlDocument("Redirecting", 'Redirecting to <a href="' + escapeHtml(loc) + '">' + escapeHtml(loc) + "</a>");
    res.statusCode = 301;
    res.setHeader("Content-Type", "text/html; charset=UTF-8");
    res.setHeader("Content-Length", Buffer.byteLength(doc));
    res.setHeader("Content-Security-Policy", "default-src 'none'");
    res.setHeader("X-Content-Type-Options", "nosniff");
    res.setHeader("Location", loc);
    res.end(doc);
  };
  SendStream.prototype.pipe = function pipe(res) {
    var root = this._root;
    this.res = res;
    var path11 = decode(this.path);
    if (path11 === -1) {
      this.error(400);
      return res;
    }
    if (~path11.indexOf("\0")) {
      this.error(400);
      return res;
    }
    var parts;
    if (root !== null) {
      if (path11) {
        path11 = normalize("." + sep + path11);
      }
      if (UP_PATH_REGEXP.test(path11)) {
        debug3('malicious path "%s"', path11);
        this.error(403);
        return res;
      }
      parts = path11.split(sep);
      path11 = normalize(join2(root, path11));
    } else {
      if (UP_PATH_REGEXP.test(path11)) {
        debug3('malicious path "%s"', path11);
        this.error(403);
        return res;
      }
      parts = normalize(path11).split(sep);
      path11 = resolve(path11);
    }
    if (containsDotFile(parts)) {
      var access = this._dotfiles;
      if (access === void 0) {
        access = parts[parts.length - 1][0] === "." ? this._hidden ? "allow" : "ignore" : "allow";
      }
      debug3('%s dotfile "%s"', access, path11);
      switch (access) {
        case "allow":
          break;
        case "deny":
          this.error(403);
          return res;
        case "ignore":
        default:
          this.error(404);
          return res;
      }
    }
    if (this._index.length && this.hasTrailingSlash()) {
      this.sendIndex(path11);
      return res;
    }
    this.sendFile(path11);
    return res;
  };
  SendStream.prototype.send = function send2(path11, stat) {
    var len = stat.size;
    var options = this.options;
    var opts = {};
    var res = this.res;
    var req = this.req;
    var ranges = req.headers.range;
    var offset = options.start || 0;
    if (headersSent(res)) {
      this.headersAlreadySent();
      return;
    }
    debug3('pipe "%s"', path11);
    this.setHeader(path11, stat);
    this.type(path11);
    if (this.isConditionalGET()) {
      if (this.isPreconditionFailure()) {
        this.error(412);
        return;
      }
      if (this.isCachable() && this.isFresh()) {
        this.notModified();
        return;
      }
    }
    len = Math.max(0, len - offset);
    if (options.end !== void 0) {
      var bytes = options.end - offset + 1;
      if (len > bytes)
        len = bytes;
    }
    if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {
      ranges = parseRange(len, ranges, {
        combine: true
      });
      if (!this.isRangeFresh()) {
        debug3("range stale");
        ranges = -2;
      }
      if (ranges === -1) {
        debug3("range unsatisfiable");
        res.setHeader("Content-Range", contentRange("bytes", len));
        return this.error(416, {
          headers: {"Content-Range": res.getHeader("Content-Range")}
        });
      }
      if (ranges !== -2 && ranges.length === 1) {
        debug3("range %j", ranges);
        res.statusCode = 206;
        res.setHeader("Content-Range", contentRange("bytes", len, ranges[0]));
        offset += ranges[0].start;
        len = ranges[0].end - ranges[0].start + 1;
      }
    }
    for (var prop in options) {
      opts[prop] = options[prop];
    }
    opts.start = offset;
    opts.end = Math.max(offset, offset + len - 1);
    res.setHeader("Content-Length", len);
    if (req.method === "HEAD") {
      res.end();
      return;
    }
    this.stream(path11, opts);
  };
  SendStream.prototype.sendFile = function sendFile(path11) {
    var i = 0;
    var self2 = this;
    debug3('stat "%s"', path11);
    fs9.stat(path11, function onstat(err, stat) {
      if (err && err.code === "ENOENT" && !extname(path11) && path11[path11.length - 1] !== sep) {
        return next(err);
      }
      if (err)
        return self2.onStatError(err);
      if (stat.isDirectory())
        return self2.redirect(path11);
      self2.emit("file", path11, stat);
      self2.send(path11, stat);
    });
    function next(err) {
      if (self2._extensions.length <= i) {
        return err ? self2.onStatError(err) : self2.error(404);
      }
      var p = path11 + "." + self2._extensions[i++];
      debug3('stat "%s"', p);
      fs9.stat(p, function(err2, stat) {
        if (err2)
          return next(err2);
        if (stat.isDirectory())
          return next();
        self2.emit("file", p, stat);
        self2.send(p, stat);
      });
    }
  };
  SendStream.prototype.sendIndex = function sendIndex(path11) {
    var i = -1;
    var self2 = this;
    function next(err) {
      if (++i >= self2._index.length) {
        if (err)
          return self2.onStatError(err);
        return self2.error(404);
      }
      var p = join2(path11, self2._index[i]);
      debug3('stat "%s"', p);
      fs9.stat(p, function(err2, stat) {
        if (err2)
          return next(err2);
        if (stat.isDirectory())
          return next();
        self2.emit("file", p, stat);
        self2.send(p, stat);
      });
    }
    next();
  };
  SendStream.prototype.stream = function stream(path11, options) {
    var finished = false;
    var self2 = this;
    var res = this.res;
    var stream2 = fs9.createReadStream(path11, options);
    this.emit("stream", stream2);
    stream2.pipe(res);
    onFinished(res, function onfinished() {
      finished = true;
      destroy(stream2);
    });
    stream2.on("error", function onerror(err) {
      if (finished)
        return;
      finished = true;
      destroy(stream2);
      self2.onStatError(err);
    });
    stream2.on("end", function onend() {
      self2.emit("end");
    });
  };
  SendStream.prototype.type = function type(path11) {
    var res = this.res;
    if (res.getHeader("Content-Type"))
      return;
    var type2 = mime.lookup(path11);
    if (!type2) {
      debug3("no content-type");
      return;
    }
    var charset = mime.charsets.lookup(type2);
    debug3("content-type %s", type2);
    res.setHeader("Content-Type", type2 + (charset ? "; charset=" + charset : ""));
  };
  SendStream.prototype.setHeader = function setHeader(path11, stat) {
    var res = this.res;
    this.emit("headers", res, path11, stat);
    if (this._acceptRanges && !res.getHeader("Accept-Ranges")) {
      debug3("accept ranges");
      res.setHeader("Accept-Ranges", "bytes");
    }
    if (this._cacheControl && !res.getHeader("Cache-Control")) {
      var cacheControl = "public, max-age=" + Math.floor(this._maxage / 1e3);
      if (this._immutable) {
        cacheControl += ", immutable";
      }
      debug3("cache-control %s", cacheControl);
      res.setHeader("Cache-Control", cacheControl);
    }
    if (this._lastModified && !res.getHeader("Last-Modified")) {
      var modified = stat.mtime.toUTCString();
      debug3("modified %s", modified);
      res.setHeader("Last-Modified", modified);
    }
    if (this._etag && !res.getHeader("ETag")) {
      var val = etag(stat);
      debug3("etag %s", val);
      res.setHeader("ETag", val);
    }
  };
  function clearHeaders(res) {
    var headers = getHeaderNames(res);
    for (var i = 0; i < headers.length; i++) {
      res.removeHeader(headers[i]);
    }
  }
  function collapseLeadingSlashes(str) {
    for (var i = 0; i < str.length; i++) {
      if (str[i] !== "/") {
        break;
      }
    }
    return i > 1 ? "/" + str.substr(i) : str;
  }
  function containsDotFile(parts) {
    for (var i = 0; i < parts.length; i++) {
      var part = parts[i];
      if (part.length > 1 && part[0] === ".") {
        return true;
      }
    }
    return false;
  }
  function contentRange(type, size, range) {
    return type + " " + (range ? range.start + "-" + range.end : "*") + "/" + size;
  }
  function createHtmlDocument(title, body) {
    return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>' + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
  }
  function decode(path11) {
    try {
      return decodeURIComponent(path11);
    } catch (err) {
      return -1;
    }
  }
  function getHeaderNames(res) {
    return typeof res.getHeaderNames !== "function" ? Object.keys(res._headers || {}) : res.getHeaderNames();
  }
  function hasListeners(emitter, type) {
    var count = typeof emitter.listenerCount !== "function" ? emitter.listeners(type).length : emitter.listenerCount(type);
    return count > 0;
  }
  function headersSent(res) {
    return typeof res.headersSent !== "boolean" ? Boolean(res._header) : res.headersSent;
  }
  function normalizeList(val, name) {
    var list = [].concat(val || []);
    for (var i = 0; i < list.length; i++) {
      if (typeof list[i] !== "string") {
        throw new TypeError(name + " must be array of strings or false");
      }
    }
    return list;
  }
  function parseHttpDate(date) {
    var timestamp = date && Date.parse(date);
    return typeof timestamp === "number" ? timestamp : NaN;
  }
  function parseTokenList(str) {
    var end = 0;
    var list = [];
    var start = 0;
    for (var i = 0, len = str.length; i < len; i++) {
      switch (str.charCodeAt(i)) {
        case 32:
          if (start === end) {
            start = end = i + 1;
          }
          break;
        case 44:
          list.push(str.substring(start, end));
          start = end = i + 1;
          break;
        default:
          end = i + 1;
          break;
      }
    }
    list.push(str.substring(start, end));
    return list;
  }
  function setHeaders(res, headers) {
    var keys = Object.keys(headers);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      res.setHeader(key, headers[key]);
    }
  }
});

// ../../node_modules/.pnpm/forwarded@0.2.0/node_modules/forwarded/index.js
var require_forwarded = __commonJS((exports2, module2) => {
  /*!
   * forwarded
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  module2.exports = forwarded;
  function forwarded(req) {
    if (!req) {
      throw new TypeError("argument req is required");
    }
    var proxyAddrs = parse2(req.headers["x-forwarded-for"] || "");
    var socketAddr = getSocketAddr(req);
    var addrs = [socketAddr].concat(proxyAddrs);
    return addrs;
  }
  function getSocketAddr(req) {
    return req.socket ? req.socket.remoteAddress : req.connection.remoteAddress;
  }
  function parse2(header) {
    var end = header.length;
    var list = [];
    var start = header.length;
    for (var i = header.length - 1; i >= 0; i--) {
      switch (header.charCodeAt(i)) {
        case 32:
          if (start === end) {
            start = end = i;
          }
          break;
        case 44:
          if (start !== end) {
            list.push(header.substring(start, end));
          }
          start = end = i;
          break;
        default:
          start = i;
          break;
      }
    }
    if (start !== end) {
      list.push(header.substring(start, end));
    }
    return list;
  }
});

// ../../node_modules/.pnpm/ipaddr.js@1.9.1/node_modules/ipaddr.js/lib/ipaddr.js
var require_ipaddr = __commonJS((exports2, module2) => {
  (function() {
    var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root, zoneIndex;
    ipaddr = {};
    root = this;
    if (typeof module2 !== "undefined" && module2 !== null && module2.exports) {
      module2.exports = ipaddr;
    } else {
      root["ipaddr"] = ipaddr;
    }
    matchCIDR = function(first, second, partSize, cidrBits) {
      var part, shift;
      if (first.length !== second.length) {
        throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
      }
      part = 0;
      while (cidrBits > 0) {
        shift = partSize - cidrBits;
        if (shift < 0) {
          shift = 0;
        }
        if (first[part] >> shift !== second[part] >> shift) {
          return false;
        }
        cidrBits -= partSize;
        part += 1;
      }
      return true;
    };
    ipaddr.subnetMatch = function(address, rangeList, defaultName) {
      var k, len, rangeName, rangeSubnets, subnet;
      if (defaultName == null) {
        defaultName = "unicast";
      }
      for (rangeName in rangeList) {
        rangeSubnets = rangeList[rangeName];
        if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
          rangeSubnets = [rangeSubnets];
        }
        for (k = 0, len = rangeSubnets.length; k < len; k++) {
          subnet = rangeSubnets[k];
          if (address.kind() === subnet[0].kind()) {
            if (address.match.apply(address, subnet)) {
              return rangeName;
            }
          }
        }
      }
      return defaultName;
    };
    ipaddr.IPv4 = function() {
      function IPv4(octets) {
        var k, len, octet;
        if (octets.length !== 4) {
          throw new Error("ipaddr: ipv4 octet count should be 4");
        }
        for (k = 0, len = octets.length; k < len; k++) {
          octet = octets[k];
          if (!(0 <= octet && octet <= 255)) {
            throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
          }
        }
        this.octets = octets;
      }
      IPv4.prototype.kind = function() {
        return "ipv4";
      };
      IPv4.prototype.toString = function() {
        return this.octets.join(".");
      };
      IPv4.prototype.toNormalizedString = function() {
        return this.toString();
      };
      IPv4.prototype.toByteArray = function() {
        return this.octets.slice(0);
      };
      IPv4.prototype.match = function(other, cidrRange) {
        var ref;
        if (cidrRange === void 0) {
          ref = other, other = ref[0], cidrRange = ref[1];
        }
        if (other.kind() !== "ipv4") {
          throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
        }
        return matchCIDR(this.octets, other.octets, 8, cidrRange);
      };
      IPv4.prototype.SpecialRanges = {
        unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
        broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
        multicast: [[new IPv4([224, 0, 0, 0]), 4]],
        linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
        loopback: [[new IPv4([127, 0, 0, 0]), 8]],
        carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
        private: [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
        reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
      };
      IPv4.prototype.range = function() {
        return ipaddr.subnetMatch(this, this.SpecialRanges);
      };
      IPv4.prototype.toIPv4MappedAddress = function() {
        return ipaddr.IPv6.parse("::ffff:" + this.toString());
      };
      IPv4.prototype.prefixLengthFromSubnetMask = function() {
        var cidr, i, k, octet, stop, zeros, zerotable;
        zerotable = {
          0: 8,
          128: 7,
          192: 6,
          224: 5,
          240: 4,
          248: 3,
          252: 2,
          254: 1,
          255: 0
        };
        cidr = 0;
        stop = false;
        for (i = k = 3; k >= 0; i = k += -1) {
          octet = this.octets[i];
          if (octet in zerotable) {
            zeros = zerotable[octet];
            if (stop && zeros !== 0) {
              return null;
            }
            if (zeros !== 8) {
              stop = true;
            }
            cidr += zeros;
          } else {
            return null;
          }
        }
        return 32 - cidr;
      };
      return IPv4;
    }();
    ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
    ipv4Regexes = {
      fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", "i"),
      longValue: new RegExp("^" + ipv4Part + "$", "i")
    };
    ipaddr.IPv4.parser = function(string) {
      var match, parseIntAuto, part, shift, value;
      parseIntAuto = function(string2) {
        if (string2[0] === "0" && string2[1] !== "x") {
          return parseInt(string2, 8);
        } else {
          return parseInt(string2);
        }
      };
      if (match = string.match(ipv4Regexes.fourOctet)) {
        return function() {
          var k, len, ref, results;
          ref = match.slice(1, 6);
          results = [];
          for (k = 0, len = ref.length; k < len; k++) {
            part = ref[k];
            results.push(parseIntAuto(part));
          }
          return results;
        }();
      } else if (match = string.match(ipv4Regexes.longValue)) {
        value = parseIntAuto(match[1]);
        if (value > 4294967295 || value < 0) {
          throw new Error("ipaddr: address outside defined range");
        }
        return function() {
          var k, results;
          results = [];
          for (shift = k = 0; k <= 24; shift = k += 8) {
            results.push(value >> shift & 255);
          }
          return results;
        }().reverse();
      } else {
        return null;
      }
    };
    ipaddr.IPv6 = function() {
      function IPv6(parts, zoneId) {
        var i, k, l, len, part, ref;
        if (parts.length === 16) {
          this.parts = [];
          for (i = k = 0; k <= 14; i = k += 2) {
            this.parts.push(parts[i] << 8 | parts[i + 1]);
          }
        } else if (parts.length === 8) {
          this.parts = parts;
        } else {
          throw new Error("ipaddr: ipv6 part count should be 8 or 16");
        }
        ref = this.parts;
        for (l = 0, len = ref.length; l < len; l++) {
          part = ref[l];
          if (!(0 <= part && part <= 65535)) {
            throw new Error("ipaddr: ipv6 part should fit in 16 bits");
          }
        }
        if (zoneId) {
          this.zoneId = zoneId;
        }
      }
      IPv6.prototype.kind = function() {
        return "ipv6";
      };
      IPv6.prototype.toString = function() {
        return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
      };
      IPv6.prototype.toRFC5952String = function() {
        var bestMatchIndex, bestMatchLength, match, regex, string;
        regex = /((^|:)(0(:|$)){2,})/g;
        string = this.toNormalizedString();
        bestMatchIndex = 0;
        bestMatchLength = -1;
        while (match = regex.exec(string)) {
          if (match[0].length > bestMatchLength) {
            bestMatchIndex = match.index;
            bestMatchLength = match[0].length;
          }
        }
        if (bestMatchLength < 0) {
          return string;
        }
        return string.substring(0, bestMatchIndex) + "::" + string.substring(bestMatchIndex + bestMatchLength);
      };
      IPv6.prototype.toByteArray = function() {
        var bytes, k, len, part, ref;
        bytes = [];
        ref = this.parts;
        for (k = 0, len = ref.length; k < len; k++) {
          part = ref[k];
          bytes.push(part >> 8);
          bytes.push(part & 255);
        }
        return bytes;
      };
      IPv6.prototype.toNormalizedString = function() {
        var addr, part, suffix;
        addr = function() {
          var k, len, ref, results;
          ref = this.parts;
          results = [];
          for (k = 0, len = ref.length; k < len; k++) {
            part = ref[k];
            results.push(part.toString(16));
          }
          return results;
        }.call(this).join(":");
        suffix = "";
        if (this.zoneId) {
          suffix = "%" + this.zoneId;
        }
        return addr + suffix;
      };
      IPv6.prototype.toFixedLengthString = function() {
        var addr, part, suffix;
        addr = function() {
          var k, len, ref, results;
          ref = this.parts;
          results = [];
          for (k = 0, len = ref.length; k < len; k++) {
            part = ref[k];
            results.push(part.toString(16).padStart(4, "0"));
          }
          return results;
        }.call(this).join(":");
        suffix = "";
        if (this.zoneId) {
          suffix = "%" + this.zoneId;
        }
        return addr + suffix;
      };
      IPv6.prototype.match = function(other, cidrRange) {
        var ref;
        if (cidrRange === void 0) {
          ref = other, other = ref[0], cidrRange = ref[1];
        }
        if (other.kind() !== "ipv6") {
          throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
        }
        return matchCIDR(this.parts, other.parts, 16, cidrRange);
      };
      IPv6.prototype.SpecialRanges = {
        unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
        linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
        multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
        loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
        uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
        ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
        rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
        rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
        "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
        teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
        reserved: [[new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]]
      };
      IPv6.prototype.range = function() {
        return ipaddr.subnetMatch(this, this.SpecialRanges);
      };
      IPv6.prototype.isIPv4MappedAddress = function() {
        return this.range() === "ipv4Mapped";
      };
      IPv6.prototype.toIPv4Address = function() {
        var high, low, ref;
        if (!this.isIPv4MappedAddress()) {
          throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
        }
        ref = this.parts.slice(-2), high = ref[0], low = ref[1];
        return new ipaddr.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
      };
      IPv6.prototype.prefixLengthFromSubnetMask = function() {
        var cidr, i, k, part, stop, zeros, zerotable;
        zerotable = {
          0: 16,
          32768: 15,
          49152: 14,
          57344: 13,
          61440: 12,
          63488: 11,
          64512: 10,
          65024: 9,
          65280: 8,
          65408: 7,
          65472: 6,
          65504: 5,
          65520: 4,
          65528: 3,
          65532: 2,
          65534: 1,
          65535: 0
        };
        cidr = 0;
        stop = false;
        for (i = k = 7; k >= 0; i = k += -1) {
          part = this.parts[i];
          if (part in zerotable) {
            zeros = zerotable[part];
            if (stop && zeros !== 0) {
              return null;
            }
            if (zeros !== 16) {
              stop = true;
            }
            cidr += zeros;
          } else {
            return null;
          }
        }
        return 128 - cidr;
      };
      return IPv6;
    }();
    ipv6Part = "(?:[0-9a-f]+::?)+";
    zoneIndex = "%[0-9a-z]{1,}";
    ipv6Regexes = {
      zoneIndex: new RegExp(zoneIndex, "i"),
      native: new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", "i"),
      transitional: new RegExp("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)" + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + ("(" + zoneIndex + ")?$"), "i")
    };
    expandIPv6 = function(string, parts) {
      var colonCount, lastColon, part, replacement, replacementCount, zoneId;
      if (string.indexOf("::") !== string.lastIndexOf("::")) {
        return null;
      }
      zoneId = (string.match(ipv6Regexes["zoneIndex"]) || [])[0];
      if (zoneId) {
        zoneId = zoneId.substring(1);
        string = string.replace(/%.+$/, "");
      }
      colonCount = 0;
      lastColon = -1;
      while ((lastColon = string.indexOf(":", lastColon + 1)) >= 0) {
        colonCount++;
      }
      if (string.substr(0, 2) === "::") {
        colonCount--;
      }
      if (string.substr(-2, 2) === "::") {
        colonCount--;
      }
      if (colonCount > parts) {
        return null;
      }
      replacementCount = parts - colonCount;
      replacement = ":";
      while (replacementCount--) {
        replacement += "0:";
      }
      string = string.replace("::", replacement);
      if (string[0] === ":") {
        string = string.slice(1);
      }
      if (string[string.length - 1] === ":") {
        string = string.slice(0, -1);
      }
      parts = function() {
        var k, len, ref, results;
        ref = string.split(":");
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          part = ref[k];
          results.push(parseInt(part, 16));
        }
        return results;
      }();
      return {
        parts,
        zoneId
      };
    };
    ipaddr.IPv6.parser = function(string) {
      var addr, k, len, match, octet, octets, zoneId;
      if (ipv6Regexes["native"].test(string)) {
        return expandIPv6(string, 8);
      } else if (match = string.match(ipv6Regexes["transitional"])) {
        zoneId = match[6] || "";
        addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
        if (addr.parts) {
          octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];
          for (k = 0, len = octets.length; k < len; k++) {
            octet = octets[k];
            if (!(0 <= octet && octet <= 255)) {
              return null;
            }
          }
          addr.parts.push(octets[0] << 8 | octets[1]);
          addr.parts.push(octets[2] << 8 | octets[3]);
          return {
            parts: addr.parts,
            zoneId: addr.zoneId
          };
        }
      }
      return null;
    };
    ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string) {
      return this.parser(string) !== null;
    };
    ipaddr.IPv4.isValid = function(string) {
      var e;
      try {
        new this(this.parser(string));
        return true;
      } catch (error1) {
        e = error1;
        return false;
      }
    };
    ipaddr.IPv4.isValidFourPartDecimal = function(string) {
      if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
        return true;
      } else {
        return false;
      }
    };
    ipaddr.IPv6.isValid = function(string) {
      var addr, e;
      if (typeof string === "string" && string.indexOf(":") === -1) {
        return false;
      }
      try {
        addr = this.parser(string);
        new this(addr.parts, addr.zoneId);
        return true;
      } catch (error1) {
        e = error1;
        return false;
      }
    };
    ipaddr.IPv4.parse = function(string) {
      var parts;
      parts = this.parser(string);
      if (parts === null) {
        throw new Error("ipaddr: string is not formatted like ip address");
      }
      return new this(parts);
    };
    ipaddr.IPv6.parse = function(string) {
      var addr;
      addr = this.parser(string);
      if (addr.parts === null) {
        throw new Error("ipaddr: string is not formatted like ip address");
      }
      return new this(addr.parts, addr.zoneId);
    };
    ipaddr.IPv4.parseCIDR = function(string) {
      var maskLength, match, parsed;
      if (match = string.match(/^(.+)\/(\d+)$/)) {
        maskLength = parseInt(match[2]);
        if (maskLength >= 0 && maskLength <= 32) {
          parsed = [this.parse(match[1]), maskLength];
          Object.defineProperty(parsed, "toString", {
            value: function() {
              return this.join("/");
            }
          });
          return parsed;
        }
      }
      throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
    };
    ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
      var filledOctetCount, j, octets;
      prefix = parseInt(prefix);
      if (prefix < 0 || prefix > 32) {
        throw new Error("ipaddr: invalid IPv4 prefix length");
      }
      octets = [0, 0, 0, 0];
      j = 0;
      filledOctetCount = Math.floor(prefix / 8);
      while (j < filledOctetCount) {
        octets[j] = 255;
        j++;
      }
      if (filledOctetCount < 4) {
        octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
      }
      return new this(octets);
    };
    ipaddr.IPv4.broadcastAddressFromCIDR = function(string) {
      var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;
      try {
        cidr = this.parseCIDR(string);
        ipInterfaceOctets = cidr[0].toByteArray();
        subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        octets = [];
        i = 0;
        while (i < 4) {
          octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
          i++;
        }
        return new this(octets);
      } catch (error1) {
        error = error1;
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
    };
    ipaddr.IPv4.networkAddressFromCIDR = function(string) {
      var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;
      try {
        cidr = this.parseCIDR(string);
        ipInterfaceOctets = cidr[0].toByteArray();
        subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        octets = [];
        i = 0;
        while (i < 4) {
          octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
          i++;
        }
        return new this(octets);
      } catch (error1) {
        error = error1;
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
    };
    ipaddr.IPv6.parseCIDR = function(string) {
      var maskLength, match, parsed;
      if (match = string.match(/^(.+)\/(\d+)$/)) {
        maskLength = parseInt(match[2]);
        if (maskLength >= 0 && maskLength <= 128) {
          parsed = [this.parse(match[1]), maskLength];
          Object.defineProperty(parsed, "toString", {
            value: function() {
              return this.join("/");
            }
          });
          return parsed;
        }
      }
      throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
    };
    ipaddr.isValid = function(string) {
      return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
    };
    ipaddr.parse = function(string) {
      if (ipaddr.IPv6.isValid(string)) {
        return ipaddr.IPv6.parse(string);
      } else if (ipaddr.IPv4.isValid(string)) {
        return ipaddr.IPv4.parse(string);
      } else {
        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
      }
    };
    ipaddr.parseCIDR = function(string) {
      var e;
      try {
        return ipaddr.IPv6.parseCIDR(string);
      } catch (error1) {
        e = error1;
        try {
          return ipaddr.IPv4.parseCIDR(string);
        } catch (error12) {
          e = error12;
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
        }
      }
    };
    ipaddr.fromByteArray = function(bytes) {
      var length;
      length = bytes.length;
      if (length === 4) {
        return new ipaddr.IPv4(bytes);
      } else if (length === 16) {
        return new ipaddr.IPv6(bytes);
      } else {
        throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
      }
    };
    ipaddr.process = function(string) {
      var addr;
      addr = this.parse(string);
      if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
        return addr.toIPv4Address();
      } else {
        return addr;
      }
    };
  }).call(exports2);
});

// ../../node_modules/.pnpm/proxy-addr@2.0.7/node_modules/proxy-addr/index.js
var require_proxy_addr = __commonJS((exports2, module2) => {
  /*!
   * proxy-addr
   * Copyright(c) 2014-2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  module2.exports = proxyaddr;
  module2.exports.all = alladdrs;
  module2.exports.compile = compile;
  var forwarded = require_forwarded();
  var ipaddr = require_ipaddr();
  var DIGIT_REGEXP = /^[0-9]+$/;
  var isip = ipaddr.isValid;
  var parseip = ipaddr.parse;
  var IP_RANGES = {
    linklocal: ["169.254.0.0/16", "fe80::/10"],
    loopback: ["127.0.0.1/8", "::1/128"],
    uniquelocal: ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7"]
  };
  function alladdrs(req, trust) {
    var addrs = forwarded(req);
    if (!trust) {
      return addrs;
    }
    if (typeof trust !== "function") {
      trust = compile(trust);
    }
    for (var i = 0; i < addrs.length - 1; i++) {
      if (trust(addrs[i], i))
        continue;
      addrs.length = i + 1;
    }
    return addrs;
  }
  function compile(val) {
    if (!val) {
      throw new TypeError("argument is required");
    }
    var trust;
    if (typeof val === "string") {
      trust = [val];
    } else if (Array.isArray(val)) {
      trust = val.slice();
    } else {
      throw new TypeError("unsupported trust argument");
    }
    for (var i = 0; i < trust.length; i++) {
      val = trust[i];
      if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {
        continue;
      }
      val = IP_RANGES[val];
      trust.splice.apply(trust, [i, 1].concat(val));
      i += val.length - 1;
    }
    return compileTrust(compileRangeSubnets(trust));
  }
  function compileRangeSubnets(arr) {
    var rangeSubnets = new Array(arr.length);
    for (var i = 0; i < arr.length; i++) {
      rangeSubnets[i] = parseipNotation(arr[i]);
    }
    return rangeSubnets;
  }
  function compileTrust(rangeSubnets) {
    var len = rangeSubnets.length;
    return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
  }
  function parseipNotation(note) {
    var pos = note.lastIndexOf("/");
    var str = pos !== -1 ? note.substring(0, pos) : note;
    if (!isip(str)) {
      throw new TypeError("invalid IP address: " + str);
    }
    var ip = parseip(str);
    if (pos === -1 && ip.kind() === "ipv6" && ip.isIPv4MappedAddress()) {
      ip = ip.toIPv4Address();
    }
    var max = ip.kind() === "ipv6" ? 128 : 32;
    var range = pos !== -1 ? note.substring(pos + 1, note.length) : null;
    if (range === null) {
      range = max;
    } else if (DIGIT_REGEXP.test(range)) {
      range = parseInt(range, 10);
    } else if (ip.kind() === "ipv4" && isip(range)) {
      range = parseNetmask(range);
    } else {
      range = null;
    }
    if (range <= 0 || range > max) {
      throw new TypeError("invalid range on address: " + note);
    }
    return [ip, range];
  }
  function parseNetmask(netmask) {
    var ip = parseip(netmask);
    var kind = ip.kind();
    return kind === "ipv4" ? ip.prefixLengthFromSubnetMask() : null;
  }
  function proxyaddr(req, trust) {
    if (!req) {
      throw new TypeError("req argument is required");
    }
    if (!trust) {
      throw new TypeError("trust argument is required");
    }
    var addrs = alladdrs(req, trust);
    var addr = addrs[addrs.length - 1];
    return addr;
  }
  function trustNone() {
    return false;
  }
  function trustMulti(subnets) {
    return function trust(addr) {
      if (!isip(addr))
        return false;
      var ip = parseip(addr);
      var ipconv;
      var kind = ip.kind();
      for (var i = 0; i < subnets.length; i++) {
        var subnet = subnets[i];
        var subnetip = subnet[0];
        var subnetkind = subnetip.kind();
        var subnetrange = subnet[1];
        var trusted = ip;
        if (kind !== subnetkind) {
          if (subnetkind === "ipv4" && !ip.isIPv4MappedAddress()) {
            continue;
          }
          if (!ipconv) {
            ipconv = subnetkind === "ipv4" ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
          }
          trusted = ipconv;
        }
        if (trusted.match(subnetip, subnetrange)) {
          return true;
        }
      }
      return false;
    };
  }
  function trustSingle(subnet) {
    var subnetip = subnet[0];
    var subnetkind = subnetip.kind();
    var subnetisipv4 = subnetkind === "ipv4";
    var subnetrange = subnet[1];
    return function trust(addr) {
      if (!isip(addr))
        return false;
      var ip = parseip(addr);
      var kind = ip.kind();
      if (kind !== subnetkind) {
        if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
          return false;
        }
        ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
      }
      return ip.match(subnetip, subnetrange);
    };
  }
});

// ../../node_modules/.pnpm/express@4.17.1/node_modules/express/lib/utils.js
var require_utils8 = __commonJS((exports2) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var Buffer2 = require_safe_buffer().Buffer;
  var contentDisposition = require_content_disposition();
  var contentType = require_content_type();
  var deprecate = require_depd()("express");
  var flatten = require_array_flatten();
  var mime = require_send().mime;
  var etag = require_etag();
  var proxyaddr = require_proxy_addr();
  var qs = require_lib9();
  var querystring = require("querystring");
  exports2.etag = createETagGenerator({weak: false});
  exports2.wetag = createETagGenerator({weak: true});
  exports2.isAbsolute = function(path10) {
    if (path10[0] === "/")
      return true;
    if (path10[1] === ":" && (path10[2] === "\\" || path10[2] === "/"))
      return true;
    if (path10.substring(0, 2) === "\\\\")
      return true;
  };
  exports2.flatten = deprecate.function(flatten, "utils.flatten: use array-flatten npm module instead");
  exports2.normalizeType = function(type) {
    return ~type.indexOf("/") ? acceptParams(type) : {value: mime.lookup(type), params: {}};
  };
  exports2.normalizeTypes = function(types) {
    var ret = [];
    for (var i = 0; i < types.length; ++i) {
      ret.push(exports2.normalizeType(types[i]));
    }
    return ret;
  };
  exports2.contentDisposition = deprecate.function(contentDisposition, "utils.contentDisposition: use content-disposition npm module instead");
  function acceptParams(str, index) {
    var parts = str.split(/ *; */);
    var ret = {value: parts[0], quality: 1, params: {}, originalIndex: index};
    for (var i = 1; i < parts.length; ++i) {
      var pms = parts[i].split(/ *= */);
      if (pms[0] === "q") {
        ret.quality = parseFloat(pms[1]);
      } else {
        ret.params[pms[0]] = pms[1];
      }
    }
    return ret;
  }
  exports2.compileETag = function(val) {
    var fn;
    if (typeof val === "function") {
      return val;
    }
    switch (val) {
      case true:
        fn = exports2.wetag;
        break;
      case false:
        break;
      case "strong":
        fn = exports2.etag;
        break;
      case "weak":
        fn = exports2.wetag;
        break;
      default:
        throw new TypeError("unknown value for etag function: " + val);
    }
    return fn;
  };
  exports2.compileQueryParser = function compileQueryParser(val) {
    var fn;
    if (typeof val === "function") {
      return val;
    }
    switch (val) {
      case true:
        fn = querystring.parse;
        break;
      case false:
        fn = newObject;
        break;
      case "extended":
        fn = parseExtendedQueryString;
        break;
      case "simple":
        fn = querystring.parse;
        break;
      default:
        throw new TypeError("unknown value for query parser function: " + val);
    }
    return fn;
  };
  exports2.compileTrust = function(val) {
    if (typeof val === "function")
      return val;
    if (val === true) {
      return function() {
        return true;
      };
    }
    if (typeof val === "number") {
      return function(a, i) {
        return i < val;
      };
    }
    if (typeof val === "string") {
      val = val.split(/ *, */);
    }
    return proxyaddr.compile(val || []);
  };
  exports2.setCharset = function setCharset(type, charset) {
    if (!type || !charset) {
      return type;
    }
    var parsed = contentType.parse(type);
    parsed.parameters.charset = charset;
    return contentType.format(parsed);
  };
  function createETagGenerator(options) {
    return function generateETag(body, encoding) {
      var buf = !Buffer2.isBuffer(body) ? Buffer2.from(body, encoding) : body;
      return etag(buf, options);
    };
  }
  function parseExtendedQueryString(str) {
    return qs.parse(str, {
      allowPrototypes: true
    });
  }
  function newObject() {
    return {};
  }
});

// ../../node_modules/.pnpm/express@4.17.1/node_modules/express/lib/application.js
var require_application = __commonJS((exports2, module2) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var finalhandler = require_finalhandler();
  var Router = require_router2();
  var methods = require_methods();
  var middleware = require_init();
  var query = require_query();
  var debug3 = require_src5()("express:application");
  var View = require_view();
  var http = require("http");
  var compileETag = require_utils8().compileETag;
  var compileQueryParser = require_utils8().compileQueryParser;
  var compileTrust = require_utils8().compileTrust;
  var deprecate = require_depd()("express");
  var flatten = require_array_flatten();
  var merge = require_utils_merge();
  var resolve = require("path").resolve;
  var setPrototypeOf = require_setprototypeof();
  var slice = Array.prototype.slice;
  var app = exports2 = module2.exports = {};
  var trustProxyDefaultSymbol = "@@symbol:trust_proxy_default";
  app.init = function init() {
    this.cache = {};
    this.engines = {};
    this.settings = {};
    this.defaultConfiguration();
  };
  app.defaultConfiguration = function defaultConfiguration() {
    var env2 = process.env.NODE_ENV || "development";
    this.enable("x-powered-by");
    this.set("etag", "weak");
    this.set("env", env2);
    this.set("query parser", "extended");
    this.set("subdomain offset", 2);
    this.set("trust proxy", false);
    Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
      configurable: true,
      value: true
    });
    debug3("booting in %s mode", env2);
    this.on("mount", function onmount(parent) {
      if (this.settings[trustProxyDefaultSymbol] === true && typeof parent.settings["trust proxy fn"] === "function") {
        delete this.settings["trust proxy"];
        delete this.settings["trust proxy fn"];
      }
      setPrototypeOf(this.request, parent.request);
      setPrototypeOf(this.response, parent.response);
      setPrototypeOf(this.engines, parent.engines);
      setPrototypeOf(this.settings, parent.settings);
    });
    this.locals = Object.create(null);
    this.mountpath = "/";
    this.locals.settings = this.settings;
    this.set("view", View);
    this.set("views", resolve("views"));
    this.set("jsonp callback name", "callback");
    if (env2 === "production") {
      this.enable("view cache");
    }
    Object.defineProperty(this, "router", {
      get: function() {
        throw new Error("'app.router' is deprecated!\nPlease see the 3.x to 4.x migration guide for details on how to update your app.");
      }
    });
  };
  app.lazyrouter = function lazyrouter() {
    if (!this._router) {
      this._router = new Router({
        caseSensitive: this.enabled("case sensitive routing"),
        strict: this.enabled("strict routing")
      });
      this._router.use(query(this.get("query parser fn")));
      this._router.use(middleware.init(this));
    }
  };
  app.handle = function handle(req, res, callback) {
    var router = this._router;
    var done = callback || finalhandler(req, res, {
      env: this.get("env"),
      onerror: logerror.bind(this)
    });
    if (!router) {
      debug3("no routes defined on app");
      done();
      return;
    }
    router.handle(req, res, done);
  };
  app.use = function use(fn) {
    var offset = 0;
    var path10 = "/";
    if (typeof fn !== "function") {
      var arg10 = fn;
      while (Array.isArray(arg10) && arg10.length !== 0) {
        arg10 = arg10[0];
      }
      if (typeof arg10 !== "function") {
        offset = 1;
        path10 = fn;
      }
    }
    var fns = flatten(slice.call(arguments, offset));
    if (fns.length === 0) {
      throw new TypeError("app.use() requires a middleware function");
    }
    this.lazyrouter();
    var router = this._router;
    fns.forEach(function(fn2) {
      if (!fn2 || !fn2.handle || !fn2.set) {
        return router.use(path10, fn2);
      }
      debug3(".use app under %s", path10);
      fn2.mountpath = path10;
      fn2.parent = this;
      router.use(path10, function mounted_app(req, res, next) {
        var orig = req.app;
        fn2.handle(req, res, function(err) {
          setPrototypeOf(req, orig.request);
          setPrototypeOf(res, orig.response);
          next(err);
        });
      });
      fn2.emit("mount", this);
    }, this);
    return this;
  };
  app.route = function route(path10) {
    this.lazyrouter();
    return this._router.route(path10);
  };
  app.engine = function engine(ext, fn) {
    if (typeof fn !== "function") {
      throw new Error("callback function required");
    }
    var extension = ext[0] !== "." ? "." + ext : ext;
    this.engines[extension] = fn;
    return this;
  };
  app.param = function param(name, fn) {
    this.lazyrouter();
    if (Array.isArray(name)) {
      for (var i = 0; i < name.length; i++) {
        this.param(name[i], fn);
      }
      return this;
    }
    this._router.param(name, fn);
    return this;
  };
  app.set = function set(setting, val) {
    if (arguments.length === 1) {
      return this.settings[setting];
    }
    debug3('set "%s" to %o', setting, val);
    this.settings[setting] = val;
    switch (setting) {
      case "etag":
        this.set("etag fn", compileETag(val));
        break;
      case "query parser":
        this.set("query parser fn", compileQueryParser(val));
        break;
      case "trust proxy":
        this.set("trust proxy fn", compileTrust(val));
        Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
          configurable: true,
          value: false
        });
        break;
    }
    return this;
  };
  app.path = function path10() {
    return this.parent ? this.parent.path() + this.mountpath : "";
  };
  app.enabled = function enabled(setting) {
    return Boolean(this.set(setting));
  };
  app.disabled = function disabled(setting) {
    return !this.set(setting);
  };
  app.enable = function enable(setting) {
    return this.set(setting, true);
  };
  app.disable = function disable(setting) {
    return this.set(setting, false);
  };
  methods.forEach(function(method) {
    app[method] = function(path10) {
      if (method === "get" && arguments.length === 1) {
        return this.set(path10);
      }
      this.lazyrouter();
      var route = this._router.route(path10);
      route[method].apply(route, slice.call(arguments, 1));
      return this;
    };
  });
  app.all = function all(path10) {
    this.lazyrouter();
    var route = this._router.route(path10);
    var args2 = slice.call(arguments, 1);
    for (var i = 0; i < methods.length; i++) {
      route[methods[i]].apply(route, args2);
    }
    return this;
  };
  app.del = deprecate.function(app.delete, "app.del: Use app.delete instead");
  app.render = function render(name, options, callback) {
    var cache = this.cache;
    var done = callback;
    var engines2 = this.engines;
    var opts = options;
    var renderOptions = {};
    var view;
    if (typeof options === "function") {
      done = options;
      opts = {};
    }
    merge(renderOptions, this.locals);
    if (opts._locals) {
      merge(renderOptions, opts._locals);
    }
    merge(renderOptions, opts);
    if (renderOptions.cache == null) {
      renderOptions.cache = this.enabled("view cache");
    }
    if (renderOptions.cache) {
      view = cache[name];
    }
    if (!view) {
      var View2 = this.get("view");
      view = new View2(name, {
        defaultEngine: this.get("view engine"),
        root: this.get("views"),
        engines: engines2
      });
      if (!view.path) {
        var dirs = Array.isArray(view.root) && view.root.length > 1 ? 'directories "' + view.root.slice(0, -1).join('", "') + '" or "' + view.root[view.root.length - 1] + '"' : 'directory "' + view.root + '"';
        var err = new Error('Failed to lookup view "' + name + '" in views ' + dirs);
        err.view = view;
        return done(err);
      }
      if (renderOptions.cache) {
        cache[name] = view;
      }
    }
    tryRender(view, renderOptions, done);
  };
  app.listen = function listen() {
    var server = http.createServer(this);
    return server.listen.apply(server, arguments);
  };
  function logerror(err) {
    if (this.get("env") !== "test")
      console.error(err.stack || err.toString());
  }
  function tryRender(view, options, callback) {
    try {
      view.render(options, callback);
    } catch (err) {
      callback(err);
    }
  }
});

// ../../node_modules/.pnpm/negotiator@0.6.2/node_modules/negotiator/lib/charset.js
var require_charset = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = preferredCharsets;
  module2.exports.preferredCharsets = preferredCharsets;
  var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
  function parseAcceptCharset(accept) {
    var accepts = accept.split(",");
    for (var i = 0, j = 0; i < accepts.length; i++) {
      var charset = parseCharset(accepts[i].trim(), i);
      if (charset) {
        accepts[j++] = charset;
      }
    }
    accepts.length = j;
    return accepts;
  }
  function parseCharset(str, i) {
    var match = simpleCharsetRegExp.exec(str);
    if (!match)
      return null;
    var charset = match[1];
    var q = 1;
    if (match[2]) {
      var params = match[2].split(";");
      for (var j = 0; j < params.length; j++) {
        var p = params[j].trim().split("=");
        if (p[0] === "q") {
          q = parseFloat(p[1]);
          break;
        }
      }
    }
    return {
      charset,
      q,
      i
    };
  }
  function getCharsetPriority(charset, accepted, index) {
    var priority = {o: -1, q: 0, s: 0};
    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(charset, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(charset, spec, index) {
    var s2 = 0;
    if (spec.charset.toLowerCase() === charset.toLowerCase()) {
      s2 |= 1;
    } else if (spec.charset !== "*") {
      return null;
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s: s2
    };
  }
  function preferredCharsets(accept, provided) {
    var accepts = parseAcceptCharset(accept === void 0 ? "*" : accept || "");
    if (!provided) {
      return accepts.filter(isQuality).sort(compareSpecs).map(getFullCharset);
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getCharsetPriority(type, accepts, index);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }
  function getFullCharset(spec) {
    return spec.charset;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
});

// ../../node_modules/.pnpm/negotiator@0.6.2/node_modules/negotiator/lib/encoding.js
var require_encoding = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = preferredEncodings;
  module2.exports.preferredEncodings = preferredEncodings;
  var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
  function parseAcceptEncoding(accept) {
    var accepts = accept.split(",");
    var hasIdentity = false;
    var minQuality = 1;
    for (var i = 0, j = 0; i < accepts.length; i++) {
      var encoding = parseEncoding(accepts[i].trim(), i);
      if (encoding) {
        accepts[j++] = encoding;
        hasIdentity = hasIdentity || specify("identity", encoding);
        minQuality = Math.min(minQuality, encoding.q || 1);
      }
    }
    if (!hasIdentity) {
      accepts[j++] = {
        encoding: "identity",
        q: minQuality,
        i
      };
    }
    accepts.length = j;
    return accepts;
  }
  function parseEncoding(str, i) {
    var match = simpleEncodingRegExp.exec(str);
    if (!match)
      return null;
    var encoding = match[1];
    var q = 1;
    if (match[2]) {
      var params = match[2].split(";");
      for (var j = 0; j < params.length; j++) {
        var p = params[j].trim().split("=");
        if (p[0] === "q") {
          q = parseFloat(p[1]);
          break;
        }
      }
    }
    return {
      encoding,
      q,
      i
    };
  }
  function getEncodingPriority(encoding, accepted, index) {
    var priority = {o: -1, q: 0, s: 0};
    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(encoding, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(encoding, spec, index) {
    var s2 = 0;
    if (spec.encoding.toLowerCase() === encoding.toLowerCase()) {
      s2 |= 1;
    } else if (spec.encoding !== "*") {
      return null;
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s: s2
    };
  }
  function preferredEncodings(accept, provided) {
    var accepts = parseAcceptEncoding(accept || "");
    if (!provided) {
      return accepts.filter(isQuality).sort(compareSpecs).map(getFullEncoding);
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getEncodingPriority(type, accepts, index);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }
  function getFullEncoding(spec) {
    return spec.encoding;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
});

// ../../node_modules/.pnpm/negotiator@0.6.2/node_modules/negotiator/lib/language.js
var require_language = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = preferredLanguages;
  module2.exports.preferredLanguages = preferredLanguages;
  var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
  function parseAcceptLanguage(accept) {
    var accepts = accept.split(",");
    for (var i = 0, j = 0; i < accepts.length; i++) {
      var language = parseLanguage(accepts[i].trim(), i);
      if (language) {
        accepts[j++] = language;
      }
    }
    accepts.length = j;
    return accepts;
  }
  function parseLanguage(str, i) {
    var match = simpleLanguageRegExp.exec(str);
    if (!match)
      return null;
    var prefix = match[1], suffix = match[2], full = prefix;
    if (suffix)
      full += "-" + suffix;
    var q = 1;
    if (match[3]) {
      var params = match[3].split(";");
      for (var j = 0; j < params.length; j++) {
        var p = params[j].split("=");
        if (p[0] === "q")
          q = parseFloat(p[1]);
      }
    }
    return {
      prefix,
      suffix,
      q,
      i,
      full
    };
  }
  function getLanguagePriority(language, accepted, index) {
    var priority = {o: -1, q: 0, s: 0};
    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(language, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(language, spec, index) {
    var p = parseLanguage(language);
    if (!p)
      return null;
    var s2 = 0;
    if (spec.full.toLowerCase() === p.full.toLowerCase()) {
      s2 |= 4;
    } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
      s2 |= 2;
    } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
      s2 |= 1;
    } else if (spec.full !== "*") {
      return null;
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s: s2
    };
  }
  function preferredLanguages(accept, provided) {
    var accepts = parseAcceptLanguage(accept === void 0 ? "*" : accept || "");
    if (!provided) {
      return accepts.filter(isQuality).sort(compareSpecs).map(getFullLanguage);
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getLanguagePriority(type, accepts, index);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }
  function getFullLanguage(spec) {
    return spec.full;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
});

// ../../node_modules/.pnpm/negotiator@0.6.2/node_modules/negotiator/lib/mediaType.js
var require_mediaType = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = preferredMediaTypes;
  module2.exports.preferredMediaTypes = preferredMediaTypes;
  var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
  function parseAccept(accept) {
    var accepts = splitMediaTypes(accept);
    for (var i = 0, j = 0; i < accepts.length; i++) {
      var mediaType = parseMediaType(accepts[i].trim(), i);
      if (mediaType) {
        accepts[j++] = mediaType;
      }
    }
    accepts.length = j;
    return accepts;
  }
  function parseMediaType(str, i) {
    var match = simpleMediaTypeRegExp.exec(str);
    if (!match)
      return null;
    var params = Object.create(null);
    var q = 1;
    var subtype = match[2];
    var type = match[1];
    if (match[3]) {
      var kvps = splitParameters(match[3]).map(splitKeyValuePair);
      for (var j = 0; j < kvps.length; j++) {
        var pair = kvps[j];
        var key = pair[0].toLowerCase();
        var val = pair[1];
        var value = val && val[0] === '"' && val[val.length - 1] === '"' ? val.substr(1, val.length - 2) : val;
        if (key === "q") {
          q = parseFloat(value);
          break;
        }
        params[key] = value;
      }
    }
    return {
      type,
      subtype,
      params,
      q,
      i
    };
  }
  function getMediaTypePriority(type, accepted, index) {
    var priority = {o: -1, q: 0, s: 0};
    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(type, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(type, spec, index) {
    var p = parseMediaType(type);
    var s2 = 0;
    if (!p) {
      return null;
    }
    if (spec.type.toLowerCase() == p.type.toLowerCase()) {
      s2 |= 4;
    } else if (spec.type != "*") {
      return null;
    }
    if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
      s2 |= 2;
    } else if (spec.subtype != "*") {
      return null;
    }
    var keys = Object.keys(spec.params);
    if (keys.length > 0) {
      if (keys.every(function(k) {
        return spec.params[k] == "*" || (spec.params[k] || "").toLowerCase() == (p.params[k] || "").toLowerCase();
      })) {
        s2 |= 1;
      } else {
        return null;
      }
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s: s2
    };
  }
  function preferredMediaTypes(accept, provided) {
    var accepts = parseAccept(accept === void 0 ? "*/*" : accept || "");
    if (!provided) {
      return accepts.filter(isQuality).sort(compareSpecs).map(getFullType);
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getMediaTypePriority(type, accepts, index);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }
  function getFullType(spec) {
    return spec.type + "/" + spec.subtype;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
  function quoteCount(string) {
    var count = 0;
    var index = 0;
    while ((index = string.indexOf('"', index)) !== -1) {
      count++;
      index++;
    }
    return count;
  }
  function splitKeyValuePair(str) {
    var index = str.indexOf("=");
    var key;
    var val;
    if (index === -1) {
      key = str;
    } else {
      key = str.substr(0, index);
      val = str.substr(index + 1);
    }
    return [key, val];
  }
  function splitMediaTypes(accept) {
    var accepts = accept.split(",");
    for (var i = 1, j = 0; i < accepts.length; i++) {
      if (quoteCount(accepts[j]) % 2 == 0) {
        accepts[++j] = accepts[i];
      } else {
        accepts[j] += "," + accepts[i];
      }
    }
    accepts.length = j + 1;
    return accepts;
  }
  function splitParameters(str) {
    var parameters = str.split(";");
    for (var i = 1, j = 0; i < parameters.length; i++) {
      if (quoteCount(parameters[j]) % 2 == 0) {
        parameters[++j] = parameters[i];
      } else {
        parameters[j] += ";" + parameters[i];
      }
    }
    parameters.length = j + 1;
    for (var i = 0; i < parameters.length; i++) {
      parameters[i] = parameters[i].trim();
    }
    return parameters;
  }
});

// ../../node_modules/.pnpm/negotiator@0.6.2/node_modules/negotiator/index.js
var require_negotiator = __commonJS((exports2, module2) => {
  /*!
   * negotiator
   * Copyright(c) 2012 Federico Romero
   * Copyright(c) 2012-2014 Isaac Z. Schlueter
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var modules = Object.create(null);
  module2.exports = Negotiator;
  module2.exports.Negotiator = Negotiator;
  function Negotiator(request) {
    if (!(this instanceof Negotiator)) {
      return new Negotiator(request);
    }
    this.request = request;
  }
  Negotiator.prototype.charset = function charset(available) {
    var set = this.charsets(available);
    return set && set[0];
  };
  Negotiator.prototype.charsets = function charsets(available) {
    var preferredCharsets = loadModule("charset").preferredCharsets;
    return preferredCharsets(this.request.headers["accept-charset"], available);
  };
  Negotiator.prototype.encoding = function encoding(available) {
    var set = this.encodings(available);
    return set && set[0];
  };
  Negotiator.prototype.encodings = function encodings(available) {
    var preferredEncodings = loadModule("encoding").preferredEncodings;
    return preferredEncodings(this.request.headers["accept-encoding"], available);
  };
  Negotiator.prototype.language = function language(available) {
    var set = this.languages(available);
    return set && set[0];
  };
  Negotiator.prototype.languages = function languages(available) {
    var preferredLanguages = loadModule("language").preferredLanguages;
    return preferredLanguages(this.request.headers["accept-language"], available);
  };
  Negotiator.prototype.mediaType = function mediaType(available) {
    var set = this.mediaTypes(available);
    return set && set[0];
  };
  Negotiator.prototype.mediaTypes = function mediaTypes(available) {
    var preferredMediaTypes = loadModule("mediaType").preferredMediaTypes;
    return preferredMediaTypes(this.request.headers.accept, available);
  };
  Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
  Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
  Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
  Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
  Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
  Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
  Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
  Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;
  function loadModule(moduleName) {
    var module3 = modules[moduleName];
    if (module3 !== void 0) {
      return module3;
    }
    switch (moduleName) {
      case "charset":
        module3 = require_charset();
        break;
      case "encoding":
        module3 = require_encoding();
        break;
      case "language":
        module3 = require_language();
        break;
      case "mediaType":
        module3 = require_mediaType();
        break;
      default:
        throw new Error("Cannot find module '" + moduleName + "'");
    }
    modules[moduleName] = module3;
    return module3;
  }
});

// ../../node_modules/.pnpm/accepts@1.3.7/node_modules/accepts/index.js
var require_accepts = __commonJS((exports2, module2) => {
  /*!
   * accepts
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var Negotiator = require_negotiator();
  var mime = require_mime_types();
  module2.exports = Accepts;
  function Accepts(req) {
    if (!(this instanceof Accepts)) {
      return new Accepts(req);
    }
    this.headers = req.headers;
    this.negotiator = new Negotiator(req);
  }
  Accepts.prototype.type = Accepts.prototype.types = function(types_) {
    var types = types_;
    if (types && !Array.isArray(types)) {
      types = new Array(arguments.length);
      for (var i = 0; i < types.length; i++) {
        types[i] = arguments[i];
      }
    }
    if (!types || types.length === 0) {
      return this.negotiator.mediaTypes();
    }
    if (!this.headers.accept) {
      return types[0];
    }
    var mimes = types.map(extToMime);
    var accepts = this.negotiator.mediaTypes(mimes.filter(validMime));
    var first = accepts[0];
    return first ? types[mimes.indexOf(first)] : false;
  };
  Accepts.prototype.encoding = Accepts.prototype.encodings = function(encodings_) {
    var encodings = encodings_;
    if (encodings && !Array.isArray(encodings)) {
      encodings = new Array(arguments.length);
      for (var i = 0; i < encodings.length; i++) {
        encodings[i] = arguments[i];
      }
    }
    if (!encodings || encodings.length === 0) {
      return this.negotiator.encodings();
    }
    return this.negotiator.encodings(encodings)[0] || false;
  };
  Accepts.prototype.charset = Accepts.prototype.charsets = function(charsets_) {
    var charsets = charsets_;
    if (charsets && !Array.isArray(charsets)) {
      charsets = new Array(arguments.length);
      for (var i = 0; i < charsets.length; i++) {
        charsets[i] = arguments[i];
      }
    }
    if (!charsets || charsets.length === 0) {
      return this.negotiator.charsets();
    }
    return this.negotiator.charsets(charsets)[0] || false;
  };
  Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function(languages_) {
    var languages = languages_;
    if (languages && !Array.isArray(languages)) {
      languages = new Array(arguments.length);
      for (var i = 0; i < languages.length; i++) {
        languages[i] = arguments[i];
      }
    }
    if (!languages || languages.length === 0) {
      return this.negotiator.languages();
    }
    return this.negotiator.languages(languages)[0] || false;
  };
  function extToMime(type) {
    return type.indexOf("/") === -1 ? mime.lookup(type) : type;
  }
  function validMime(type) {
    return typeof type === "string";
  }
});

// ../../node_modules/.pnpm/express@4.17.1/node_modules/express/lib/request.js
var require_request4 = __commonJS((exports2, module2) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var accepts = require_accepts();
  var deprecate = require_depd()("express");
  var isIP = require("net").isIP;
  var typeis = require_type_is();
  var http = require("http");
  var fresh = require_fresh();
  var parseRange = require_range_parser();
  var parse2 = require_parseurl();
  var proxyaddr = require_proxy_addr();
  var req = Object.create(http.IncomingMessage.prototype);
  module2.exports = req;
  req.get = req.header = function header(name) {
    if (!name) {
      throw new TypeError("name argument is required to req.get");
    }
    if (typeof name !== "string") {
      throw new TypeError("name must be a string to req.get");
    }
    var lc = name.toLowerCase();
    switch (lc) {
      case "referer":
      case "referrer":
        return this.headers.referrer || this.headers.referer;
      default:
        return this.headers[lc];
    }
  };
  req.accepts = function() {
    var accept = accepts(this);
    return accept.types.apply(accept, arguments);
  };
  req.acceptsEncodings = function() {
    var accept = accepts(this);
    return accept.encodings.apply(accept, arguments);
  };
  req.acceptsEncoding = deprecate.function(req.acceptsEncodings, "req.acceptsEncoding: Use acceptsEncodings instead");
  req.acceptsCharsets = function() {
    var accept = accepts(this);
    return accept.charsets.apply(accept, arguments);
  };
  req.acceptsCharset = deprecate.function(req.acceptsCharsets, "req.acceptsCharset: Use acceptsCharsets instead");
  req.acceptsLanguages = function() {
    var accept = accepts(this);
    return accept.languages.apply(accept, arguments);
  };
  req.acceptsLanguage = deprecate.function(req.acceptsLanguages, "req.acceptsLanguage: Use acceptsLanguages instead");
  req.range = function range(size, options) {
    var range2 = this.get("Range");
    if (!range2)
      return;
    return parseRange(size, range2, options);
  };
  req.param = function param(name, defaultValue) {
    var params = this.params || {};
    var body = this.body || {};
    var query = this.query || {};
    var args2 = arguments.length === 1 ? "name" : "name, default";
    deprecate("req.param(" + args2 + "): Use req.params, req.body, or req.query instead");
    if (params[name] != null && params.hasOwnProperty(name))
      return params[name];
    if (body[name] != null)
      return body[name];
    if (query[name] != null)
      return query[name];
    return defaultValue;
  };
  req.is = function is(types) {
    var arr = types;
    if (!Array.isArray(types)) {
      arr = new Array(arguments.length);
      for (var i = 0; i < arr.length; i++) {
        arr[i] = arguments[i];
      }
    }
    return typeis(this, arr);
  };
  defineGetter(req, "protocol", function protocol() {
    var proto = this.connection.encrypted ? "https" : "http";
    var trust = this.app.get("trust proxy fn");
    if (!trust(this.connection.remoteAddress, 0)) {
      return proto;
    }
    var header = this.get("X-Forwarded-Proto") || proto;
    var index = header.indexOf(",");
    return index !== -1 ? header.substring(0, index).trim() : header.trim();
  });
  defineGetter(req, "secure", function secure() {
    return this.protocol === "https";
  });
  defineGetter(req, "ip", function ip() {
    var trust = this.app.get("trust proxy fn");
    return proxyaddr(this, trust);
  });
  defineGetter(req, "ips", function ips() {
    var trust = this.app.get("trust proxy fn");
    var addrs = proxyaddr.all(this, trust);
    addrs.reverse().pop();
    return addrs;
  });
  defineGetter(req, "subdomains", function subdomains() {
    var hostname = this.hostname;
    if (!hostname)
      return [];
    var offset = this.app.get("subdomain offset");
    var subdomains2 = !isIP(hostname) ? hostname.split(".").reverse() : [hostname];
    return subdomains2.slice(offset);
  });
  defineGetter(req, "path", function path10() {
    return parse2(this).pathname;
  });
  defineGetter(req, "hostname", function hostname() {
    var trust = this.app.get("trust proxy fn");
    var host = this.get("X-Forwarded-Host");
    if (!host || !trust(this.connection.remoteAddress, 0)) {
      host = this.get("Host");
    } else if (host.indexOf(",") !== -1) {
      host = host.substring(0, host.indexOf(",")).trimRight();
    }
    if (!host)
      return;
    var offset = host[0] === "[" ? host.indexOf("]") + 1 : 0;
    var index = host.indexOf(":", offset);
    return index !== -1 ? host.substring(0, index) : host;
  });
  defineGetter(req, "host", deprecate.function(function host() {
    return this.hostname;
  }, "req.host: Use req.hostname instead"));
  defineGetter(req, "fresh", function() {
    var method = this.method;
    var res = this.res;
    var status = res.statusCode;
    if (method !== "GET" && method !== "HEAD")
      return false;
    if (status >= 200 && status < 300 || status === 304) {
      return fresh(this.headers, {
        etag: res.get("ETag"),
        "last-modified": res.get("Last-Modified")
      });
    }
    return false;
  });
  defineGetter(req, "stale", function stale() {
    return !this.fresh;
  });
  defineGetter(req, "xhr", function xhr() {
    var val = this.get("X-Requested-With") || "";
    return val.toLowerCase() === "xmlhttprequest";
  });
  function defineGetter(obj, name, getter) {
    Object.defineProperty(obj, name, {
      configurable: true,
      enumerable: true,
      get: getter
    });
  }
});

// ../../node_modules/.pnpm/cookie-signature@1.0.6/node_modules/cookie-signature/index.js
var require_cookie_signature = __commonJS((exports2) => {
  var crypto2 = require("crypto");
  exports2.sign = function(val, secret) {
    if (typeof val != "string")
      throw new TypeError("Cookie value must be provided as a string.");
    if (typeof secret != "string")
      throw new TypeError("Secret string must be provided.");
    return val + "." + crypto2.createHmac("sha256", secret).update(val).digest("base64").replace(/\=+$/, "");
  };
  exports2.unsign = function(val, secret) {
    if (typeof val != "string")
      throw new TypeError("Signed cookie string must be provided.");
    if (typeof secret != "string")
      throw new TypeError("Secret string must be provided.");
    var str = val.slice(0, val.lastIndexOf(".")), mac = exports2.sign(str, secret);
    return sha1(mac) == sha1(val) ? str : false;
  };
  function sha1(str) {
    return crypto2.createHash("sha1").update(str).digest("hex");
  }
});

// ../../node_modules/.pnpm/cookie@0.4.0/node_modules/cookie/index.js
var require_cookie2 = __commonJS((exports2) => {
  /*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  exports2.parse = parse2;
  exports2.serialize = serialize;
  var decode = decodeURIComponent;
  var encode = encodeURIComponent;
  var pairSplitRegExp = /; */;
  var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
  function parse2(str, options) {
    if (typeof str !== "string") {
      throw new TypeError("argument str must be a string");
    }
    var obj = {};
    var opt = options || {};
    var pairs = str.split(pairSplitRegExp);
    var dec = opt.decode || decode;
    for (var i = 0; i < pairs.length; i++) {
      var pair = pairs[i];
      var eq_idx = pair.indexOf("=");
      if (eq_idx < 0) {
        continue;
      }
      var key = pair.substr(0, eq_idx).trim();
      var val = pair.substr(++eq_idx, pair.length).trim();
      if (val[0] == '"') {
        val = val.slice(1, -1);
      }
      if (obj[key] == void 0) {
        obj[key] = tryDecode(val, dec);
      }
    }
    return obj;
  }
  function serialize(name, val, options) {
    var opt = options || {};
    var enc = opt.encode || encode;
    if (typeof enc !== "function") {
      throw new TypeError("option encode is invalid");
    }
    if (!fieldContentRegExp.test(name)) {
      throw new TypeError("argument name is invalid");
    }
    var value = enc(val);
    if (value && !fieldContentRegExp.test(value)) {
      throw new TypeError("argument val is invalid");
    }
    var str = name + "=" + value;
    if (opt.maxAge != null) {
      var maxAge = opt.maxAge - 0;
      if (isNaN(maxAge))
        throw new Error("maxAge should be a Number");
      str += "; Max-Age=" + Math.floor(maxAge);
    }
    if (opt.domain) {
      if (!fieldContentRegExp.test(opt.domain)) {
        throw new TypeError("option domain is invalid");
      }
      str += "; Domain=" + opt.domain;
    }
    if (opt.path) {
      if (!fieldContentRegExp.test(opt.path)) {
        throw new TypeError("option path is invalid");
      }
      str += "; Path=" + opt.path;
    }
    if (opt.expires) {
      if (typeof opt.expires.toUTCString !== "function") {
        throw new TypeError("option expires is invalid");
      }
      str += "; Expires=" + opt.expires.toUTCString();
    }
    if (opt.httpOnly) {
      str += "; HttpOnly";
    }
    if (opt.secure) {
      str += "; Secure";
    }
    if (opt.sameSite) {
      var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
      switch (sameSite) {
        case true:
          str += "; SameSite=Strict";
          break;
        case "lax":
          str += "; SameSite=Lax";
          break;
        case "strict":
          str += "; SameSite=Strict";
          break;
        case "none":
          str += "; SameSite=None";
          break;
        default:
          throw new TypeError("option sameSite is invalid");
      }
    }
    return str;
  }
  function tryDecode(str, decode2) {
    try {
      return decode2(str);
    } catch (e) {
      return str;
    }
  }
});

// ../../node_modules/.pnpm/vary@1.1.2/node_modules/vary/index.js
var require_vary = __commonJS((exports2, module2) => {
  /*!
   * vary
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  module2.exports = vary;
  module2.exports.append = append;
  var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
  function append(header, field) {
    if (typeof header !== "string") {
      throw new TypeError("header argument is required");
    }
    if (!field) {
      throw new TypeError("field argument is required");
    }
    var fields = !Array.isArray(field) ? parse2(String(field)) : field;
    for (var j = 0; j < fields.length; j++) {
      if (!FIELD_NAME_REGEXP.test(fields[j])) {
        throw new TypeError("field argument contains an invalid header name");
      }
    }
    if (header === "*") {
      return header;
    }
    var val = header;
    var vals = parse2(header.toLowerCase());
    if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) {
      return "*";
    }
    for (var i = 0; i < fields.length; i++) {
      var fld = fields[i].toLowerCase();
      if (vals.indexOf(fld) === -1) {
        vals.push(fld);
        val = val ? val + ", " + fields[i] : fields[i];
      }
    }
    return val;
  }
  function parse2(header) {
    var end = 0;
    var list = [];
    var start = 0;
    for (var i = 0, len = header.length; i < len; i++) {
      switch (header.charCodeAt(i)) {
        case 32:
          if (start === end) {
            start = end = i + 1;
          }
          break;
        case 44:
          list.push(header.substring(start, end));
          start = end = i + 1;
          break;
        default:
          end = i + 1;
          break;
      }
    }
    list.push(header.substring(start, end));
    return list;
  }
  function vary(res, field) {
    if (!res || !res.getHeader || !res.setHeader) {
      throw new TypeError("res argument is required");
    }
    var val = res.getHeader("Vary") || "";
    var header = Array.isArray(val) ? val.join(", ") : String(val);
    if (val = append(header, field)) {
      res.setHeader("Vary", val);
    }
  }
});

// ../../node_modules/.pnpm/express@4.17.1/node_modules/express/lib/response.js
var require_response = __commonJS((exports2, module2) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var Buffer2 = require_safe_buffer().Buffer;
  var contentDisposition = require_content_disposition();
  var deprecate = require_depd()("express");
  var encodeUrl = require_encodeurl();
  var escapeHtml = require_escape_html();
  var http = require("http");
  var isAbsolute = require_utils8().isAbsolute;
  var onFinished = require_on_finished();
  var path10 = require("path");
  var statuses = require_statuses();
  var merge = require_utils_merge();
  var sign = require_cookie_signature().sign;
  var normalizeType = require_utils8().normalizeType;
  var normalizeTypes = require_utils8().normalizeTypes;
  var setCharset = require_utils8().setCharset;
  var cookie = require_cookie2();
  var send = require_send();
  var extname = path10.extname;
  var mime = send.mime;
  var resolve = path10.resolve;
  var vary = require_vary();
  var res = Object.create(http.ServerResponse.prototype);
  module2.exports = res;
  var charsetRegExp = /;\s*charset\s*=/;
  res.status = function status(code) {
    this.statusCode = code;
    return this;
  };
  res.links = function(links) {
    var link5 = this.get("Link") || "";
    if (link5)
      link5 += ", ";
    return this.set("Link", link5 + Object.keys(links).map(function(rel) {
      return "<" + links[rel] + '>; rel="' + rel + '"';
    }).join(", "));
  };
  res.send = function send2(body) {
    var chunk = body;
    var encoding;
    var req = this.req;
    var type;
    var app = this.app;
    if (arguments.length === 2) {
      if (typeof arguments[0] !== "number" && typeof arguments[1] === "number") {
        deprecate("res.send(body, status): Use res.status(status).send(body) instead");
        this.statusCode = arguments[1];
      } else {
        deprecate("res.send(status, body): Use res.status(status).send(body) instead");
        this.statusCode = arguments[0];
        chunk = arguments[1];
      }
    }
    if (typeof chunk === "number" && arguments.length === 1) {
      if (!this.get("Content-Type")) {
        this.type("txt");
      }
      deprecate("res.send(status): Use res.sendStatus(status) instead");
      this.statusCode = chunk;
      chunk = statuses[chunk];
    }
    switch (typeof chunk) {
      case "string":
        if (!this.get("Content-Type")) {
          this.type("html");
        }
        break;
      case "boolean":
      case "number":
      case "object":
        if (chunk === null) {
          chunk = "";
        } else if (Buffer2.isBuffer(chunk)) {
          if (!this.get("Content-Type")) {
            this.type("bin");
          }
        } else {
          return this.json(chunk);
        }
        break;
    }
    if (typeof chunk === "string") {
      encoding = "utf8";
      type = this.get("Content-Type");
      if (typeof type === "string") {
        this.set("Content-Type", setCharset(type, "utf-8"));
      }
    }
    var etagFn = app.get("etag fn");
    var generateETag = !this.get("ETag") && typeof etagFn === "function";
    var len;
    if (chunk !== void 0) {
      if (Buffer2.isBuffer(chunk)) {
        len = chunk.length;
      } else if (!generateETag && chunk.length < 1e3) {
        len = Buffer2.byteLength(chunk, encoding);
      } else {
        chunk = Buffer2.from(chunk, encoding);
        encoding = void 0;
        len = chunk.length;
      }
      this.set("Content-Length", len);
    }
    var etag;
    if (generateETag && len !== void 0) {
      if (etag = etagFn(chunk, encoding)) {
        this.set("ETag", etag);
      }
    }
    if (req.fresh)
      this.statusCode = 304;
    if (this.statusCode === 204 || this.statusCode === 304) {
      this.removeHeader("Content-Type");
      this.removeHeader("Content-Length");
      this.removeHeader("Transfer-Encoding");
      chunk = "";
    }
    if (req.method === "HEAD") {
      this.end();
    } else {
      this.end(chunk, encoding);
    }
    return this;
  };
  res.json = function json(obj) {
    var val = obj;
    if (arguments.length === 2) {
      if (typeof arguments[1] === "number") {
        deprecate("res.json(obj, status): Use res.status(status).json(obj) instead");
        this.statusCode = arguments[1];
      } else {
        deprecate("res.json(status, obj): Use res.status(status).json(obj) instead");
        this.statusCode = arguments[0];
        val = arguments[1];
      }
    }
    var app = this.app;
    var escape2 = app.get("json escape");
    var replacer = app.get("json replacer");
    var spaces = app.get("json spaces");
    var body = stringify2(val, replacer, spaces, escape2);
    if (!this.get("Content-Type")) {
      this.set("Content-Type", "application/json");
    }
    return this.send(body);
  };
  res.jsonp = function jsonp(obj) {
    var val = obj;
    if (arguments.length === 2) {
      if (typeof arguments[1] === "number") {
        deprecate("res.jsonp(obj, status): Use res.status(status).json(obj) instead");
        this.statusCode = arguments[1];
      } else {
        deprecate("res.jsonp(status, obj): Use res.status(status).jsonp(obj) instead");
        this.statusCode = arguments[0];
        val = arguments[1];
      }
    }
    var app = this.app;
    var escape2 = app.get("json escape");
    var replacer = app.get("json replacer");
    var spaces = app.get("json spaces");
    var body = stringify2(val, replacer, spaces, escape2);
    var callback = this.req.query[app.get("jsonp callback name")];
    if (!this.get("Content-Type")) {
      this.set("X-Content-Type-Options", "nosniff");
      this.set("Content-Type", "application/json");
    }
    if (Array.isArray(callback)) {
      callback = callback[0];
    }
    if (typeof callback === "string" && callback.length !== 0) {
      this.set("X-Content-Type-Options", "nosniff");
      this.set("Content-Type", "text/javascript");
      callback = callback.replace(/[^\[\]\w$.]/g, "");
      body = body.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
      body = "/**/ typeof " + callback + " === 'function' && " + callback + "(" + body + ");";
    }
    return this.send(body);
  };
  res.sendStatus = function sendStatus(statusCode) {
    var body = statuses[statusCode] || String(statusCode);
    this.statusCode = statusCode;
    this.type("txt");
    return this.send(body);
  };
  res.sendFile = function sendFile(path11, options, callback) {
    var done = callback;
    var req = this.req;
    var res2 = this;
    var next = req.next;
    var opts = options || {};
    if (!path11) {
      throw new TypeError("path argument is required to res.sendFile");
    }
    if (typeof path11 !== "string") {
      throw new TypeError("path must be a string to res.sendFile");
    }
    if (typeof options === "function") {
      done = options;
      opts = {};
    }
    if (!opts.root && !isAbsolute(path11)) {
      throw new TypeError("path must be absolute or specify root to res.sendFile");
    }
    var pathname = encodeURI(path11);
    var file = send(req, pathname, opts);
    sendfile(res2, file, opts, function(err) {
      if (done)
        return done(err);
      if (err && err.code === "EISDIR")
        return next();
      if (err && err.code !== "ECONNABORTED" && err.syscall !== "write") {
        next(err);
      }
    });
  };
  res.sendfile = function(path11, options, callback) {
    var done = callback;
    var req = this.req;
    var res2 = this;
    var next = req.next;
    var opts = options || {};
    if (typeof options === "function") {
      done = options;
      opts = {};
    }
    var file = send(req, path11, opts);
    sendfile(res2, file, opts, function(err) {
      if (done)
        return done(err);
      if (err && err.code === "EISDIR")
        return next();
      if (err && err.code !== "ECONNABORTED" && err.syscall !== "write") {
        next(err);
      }
    });
  };
  res.sendfile = deprecate.function(res.sendfile, "res.sendfile: Use res.sendFile instead");
  res.download = function download2(path11, filename, options, callback) {
    var done = callback;
    var name = filename;
    var opts = options || null;
    if (typeof filename === "function") {
      done = filename;
      name = null;
      opts = null;
    } else if (typeof options === "function") {
      done = options;
      opts = null;
    }
    var headers = {
      "Content-Disposition": contentDisposition(name || path11)
    };
    if (opts && opts.headers) {
      var keys = Object.keys(opts.headers);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.toLowerCase() !== "content-disposition") {
          headers[key] = opts.headers[key];
        }
      }
    }
    opts = Object.create(opts);
    opts.headers = headers;
    var fullPath = resolve(path11);
    return this.sendFile(fullPath, opts, done);
  };
  res.contentType = res.type = function contentType(type) {
    var ct = type.indexOf("/") === -1 ? mime.lookup(type) : type;
    return this.set("Content-Type", ct);
  };
  res.format = function(obj) {
    var req = this.req;
    var next = req.next;
    var fn = obj.default;
    if (fn)
      delete obj.default;
    var keys = Object.keys(obj);
    var key = keys.length > 0 ? req.accepts(keys) : false;
    this.vary("Accept");
    if (key) {
      this.set("Content-Type", normalizeType(key).value);
      obj[key](req, this, next);
    } else if (fn) {
      fn();
    } else {
      var err = new Error("Not Acceptable");
      err.status = err.statusCode = 406;
      err.types = normalizeTypes(keys).map(function(o) {
        return o.value;
      });
      next(err);
    }
    return this;
  };
  res.attachment = function attachment(filename) {
    if (filename) {
      this.type(extname(filename));
    }
    this.set("Content-Disposition", contentDisposition(filename));
    return this;
  };
  res.append = function append(field, val) {
    var prev = this.get(field);
    var value = val;
    if (prev) {
      value = Array.isArray(prev) ? prev.concat(val) : Array.isArray(val) ? [prev].concat(val) : [prev, val];
    }
    return this.set(field, value);
  };
  res.set = res.header = function header(field, val) {
    if (arguments.length === 2) {
      var value = Array.isArray(val) ? val.map(String) : String(val);
      if (field.toLowerCase() === "content-type") {
        if (Array.isArray(value)) {
          throw new TypeError("Content-Type cannot be set to an Array");
        }
        if (!charsetRegExp.test(value)) {
          var charset = mime.charsets.lookup(value.split(";")[0]);
          if (charset)
            value += "; charset=" + charset.toLowerCase();
        }
      }
      this.setHeader(field, value);
    } else {
      for (var key in field) {
        this.set(key, field[key]);
      }
    }
    return this;
  };
  res.get = function(field) {
    return this.getHeader(field);
  };
  res.clearCookie = function clearCookie(name, options) {
    var opts = merge({expires: new Date(1), path: "/"}, options);
    return this.cookie(name, "", opts);
  };
  res.cookie = function(name, value, options) {
    var opts = merge({}, options);
    var secret = this.req.secret;
    var signed = opts.signed;
    if (signed && !secret) {
      throw new Error('cookieParser("secret") required for signed cookies');
    }
    var val = typeof value === "object" ? "j:" + JSON.stringify(value) : String(value);
    if (signed) {
      val = "s:" + sign(val, secret);
    }
    if ("maxAge" in opts) {
      opts.expires = new Date(Date.now() + opts.maxAge);
      opts.maxAge /= 1e3;
    }
    if (opts.path == null) {
      opts.path = "/";
    }
    this.append("Set-Cookie", cookie.serialize(name, String(val), opts));
    return this;
  };
  res.location = function location(url) {
    var loc = url;
    if (url === "back") {
      loc = this.req.get("Referrer") || "/";
    }
    return this.set("Location", encodeUrl(loc));
  };
  res.redirect = function redirect(url) {
    var address = url;
    var body;
    var status = 302;
    if (arguments.length === 2) {
      if (typeof arguments[0] === "number") {
        status = arguments[0];
        address = arguments[1];
      } else {
        deprecate("res.redirect(url, status): Use res.redirect(status, url) instead");
        status = arguments[1];
      }
    }
    address = this.location(address).get("Location");
    this.format({
      text: function() {
        body = statuses[status] + ". Redirecting to " + address;
      },
      html: function() {
        var u = escapeHtml(address);
        body = "<p>" + statuses[status] + '. Redirecting to <a href="' + u + '">' + u + "</a></p>";
      },
      default: function() {
        body = "";
      }
    });
    this.statusCode = status;
    this.set("Content-Length", Buffer2.byteLength(body));
    if (this.req.method === "HEAD") {
      this.end();
    } else {
      this.end(body);
    }
  };
  res.vary = function(field) {
    if (!field || Array.isArray(field) && !field.length) {
      deprecate("res.vary(): Provide a field name");
      return this;
    }
    vary(this, field);
    return this;
  };
  res.render = function render(view, options, callback) {
    var app = this.req.app;
    var done = callback;
    var opts = options || {};
    var req = this.req;
    var self2 = this;
    if (typeof options === "function") {
      done = options;
      opts = {};
    }
    opts._locals = self2.locals;
    done = done || function(err, str) {
      if (err)
        return req.next(err);
      self2.send(str);
    };
    app.render(view, opts, done);
  };
  function sendfile(res2, file, options, callback) {
    var done = false;
    var streaming;
    function onaborted() {
      if (done)
        return;
      done = true;
      var err = new Error("Request aborted");
      err.code = "ECONNABORTED";
      callback(err);
    }
    function ondirectory() {
      if (done)
        return;
      done = true;
      var err = new Error("EISDIR, read");
      err.code = "EISDIR";
      callback(err);
    }
    function onerror(err) {
      if (done)
        return;
      done = true;
      callback(err);
    }
    function onend() {
      if (done)
        return;
      done = true;
      callback();
    }
    function onfile() {
      streaming = false;
    }
    function onfinish(err) {
      if (err && err.code === "ECONNRESET")
        return onaborted();
      if (err)
        return onerror(err);
      if (done)
        return;
      setImmediate(function() {
        if (streaming !== false && !done) {
          onaborted();
          return;
        }
        if (done)
          return;
        done = true;
        callback();
      });
    }
    function onstream() {
      streaming = true;
    }
    file.on("directory", ondirectory);
    file.on("end", onend);
    file.on("error", onerror);
    file.on("file", onfile);
    file.on("stream", onstream);
    onFinished(res2, onfinish);
    if (options.headers) {
      file.on("headers", function headers(res3) {
        var obj = options.headers;
        var keys = Object.keys(obj);
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          res3.setHeader(k, obj[k]);
        }
      });
    }
    file.pipe(res2);
  }
  function stringify2(value, replacer, spaces, escape2) {
    var json = replacer || spaces ? JSON.stringify(value, replacer, spaces) : JSON.stringify(value);
    if (escape2) {
      json = json.replace(/[<>&]/g, function(c) {
        switch (c.charCodeAt(0)) {
          case 60:
            return "\\u003c";
          case 62:
            return "\\u003e";
          case 38:
            return "\\u0026";
          default:
            return c;
        }
      });
    }
    return json;
  }
});

// ../../node_modules/.pnpm/serve-static@1.14.1/node_modules/serve-static/index.js
var require_serve_static = __commonJS((exports2, module2) => {
  /*!
   * serve-static
   * Copyright(c) 2010 Sencha Inc.
   * Copyright(c) 2011 TJ Holowaychuk
   * Copyright(c) 2014-2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var encodeUrl = require_encodeurl();
  var escapeHtml = require_escape_html();
  var parseUrl = require_parseurl();
  var resolve = require("path").resolve;
  var send = require_send();
  var url = require("url");
  module2.exports = serveStatic;
  module2.exports.mime = send.mime;
  function serveStatic(root, options) {
    if (!root) {
      throw new TypeError("root path required");
    }
    if (typeof root !== "string") {
      throw new TypeError("root path must be a string");
    }
    var opts = Object.create(options || null);
    var fallthrough = opts.fallthrough !== false;
    var redirect = opts.redirect !== false;
    var setHeaders = opts.setHeaders;
    if (setHeaders && typeof setHeaders !== "function") {
      throw new TypeError("option setHeaders must be function");
    }
    opts.maxage = opts.maxage || opts.maxAge || 0;
    opts.root = resolve(root);
    var onDirectory = redirect ? createRedirectDirectoryListener() : createNotFoundDirectoryListener();
    return function serveStatic2(req, res, next) {
      if (req.method !== "GET" && req.method !== "HEAD") {
        if (fallthrough) {
          return next();
        }
        res.statusCode = 405;
        res.setHeader("Allow", "GET, HEAD");
        res.setHeader("Content-Length", "0");
        res.end();
        return;
      }
      var forwardError = !fallthrough;
      var originalUrl = parseUrl.original(req);
      var path10 = parseUrl(req).pathname;
      if (path10 === "/" && originalUrl.pathname.substr(-1) !== "/") {
        path10 = "";
      }
      var stream = send(req, path10, opts);
      stream.on("directory", onDirectory);
      if (setHeaders) {
        stream.on("headers", setHeaders);
      }
      if (fallthrough) {
        stream.on("file", function onFile() {
          forwardError = true;
        });
      }
      stream.on("error", function error(err) {
        if (forwardError || !(err.statusCode < 500)) {
          next(err);
          return;
        }
        next();
      });
      stream.pipe(res);
    };
  }
  function collapseLeadingSlashes(str) {
    for (var i = 0; i < str.length; i++) {
      if (str.charCodeAt(i) !== 47) {
        break;
      }
    }
    return i > 1 ? "/" + str.substr(i) : str;
  }
  function createHtmlDocument(title, body) {
    return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>' + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
  }
  function createNotFoundDirectoryListener() {
    return function notFound() {
      this.error(404);
    };
  }
  function createRedirectDirectoryListener() {
    return function redirect(res) {
      if (this.hasTrailingSlash()) {
        this.error(404);
        return;
      }
      var originalUrl = parseUrl.original(this.req);
      originalUrl.path = null;
      originalUrl.pathname = collapseLeadingSlashes(originalUrl.pathname + "/");
      var loc = encodeUrl(url.format(originalUrl));
      var doc = createHtmlDocument("Redirecting", 'Redirecting to <a href="' + escapeHtml(loc) + '">' + escapeHtml(loc) + "</a>");
      res.statusCode = 301;
      res.setHeader("Content-Type", "text/html; charset=UTF-8");
      res.setHeader("Content-Length", Buffer.byteLength(doc));
      res.setHeader("Content-Security-Policy", "default-src 'none'");
      res.setHeader("X-Content-Type-Options", "nosniff");
      res.setHeader("Location", loc);
      res.end(doc);
    };
  }
});

// ../../node_modules/.pnpm/express@4.17.1/node_modules/express/lib/express.js
var require_express2 = __commonJS((exports2, module2) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var bodyParser = require_body_parser();
  var EventEmitter = require("events").EventEmitter;
  var mixin = require_merge_descriptors();
  var proto = require_application();
  var Route = require_route3();
  var Router = require_router2();
  var req = require_request4();
  var res = require_response();
  exports2 = module2.exports = createApplication;
  function createApplication() {
    var app = function(req2, res2, next) {
      app.handle(req2, res2, next);
    };
    mixin(app, EventEmitter.prototype, false);
    mixin(app, proto, false);
    app.request = Object.create(req, {
      app: {configurable: true, enumerable: true, writable: true, value: app}
    });
    app.response = Object.create(res, {
      app: {configurable: true, enumerable: true, writable: true, value: app}
    });
    app.init();
    return app;
  }
  exports2.application = proto;
  exports2.request = req;
  exports2.response = res;
  exports2.Route = Route;
  exports2.Router = Router;
  exports2.json = bodyParser.json;
  exports2.query = require_query();
  exports2.raw = bodyParser.raw;
  exports2.static = require_serve_static();
  exports2.text = bodyParser.text;
  exports2.urlencoded = bodyParser.urlencoded;
  var removedMiddlewares = [
    "bodyParser",
    "compress",
    "cookieSession",
    "session",
    "logger",
    "cookieParser",
    "favicon",
    "responseTime",
    "errorHandler",
    "timeout",
    "methodOverride",
    "vhost",
    "csrf",
    "directory",
    "limit",
    "multipart",
    "staticCache"
  ];
  removedMiddlewares.forEach(function(name) {
    Object.defineProperty(exports2, name, {
      get: function() {
        throw new Error("Most middleware (like " + name + ") is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.");
      },
      configurable: true
    });
  });
});

// ../../node_modules/.pnpm/express@4.17.1/node_modules/express/index.js
var require_express3 = __commonJS((exports2, module2) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  module2.exports = require_express2();
});

// ../../node_modules/.pnpm/object-assign@4.1.1/node_modules/object-assign/index.js
var require_object_assign = __commonJS((exports2, module2) => {
  /*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  */
  "use strict";
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;
  function toObject(val) {
    if (val === null || val === void 0) {
      throw new TypeError("Object.assign cannot be called with null or undefined");
    }
    return Object(val);
  }
  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      }
      var test1 = new String("abc");
      test1[5] = "de";
      if (Object.getOwnPropertyNames(test1)[0] === "5") {
        return false;
      }
      var test2 = {};
      for (var i = 0; i < 10; i++) {
        test2["_" + String.fromCharCode(i)] = i;
      }
      var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
        return test2[n];
      });
      if (order2.join("") !== "0123456789") {
        return false;
      }
      var test3 = {};
      "abcdefghijklmnopqrst".split("").forEach(function(letter) {
        test3[letter] = letter;
      });
      if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }
  module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
    var from;
    var to = toObject(target);
    var symbols;
    for (var s2 = 1; s2 < arguments.length; s2++) {
      from = Object(arguments[s2]);
      for (var key in from) {
        if (hasOwnProperty.call(from, key)) {
          to[key] = from[key];
        }
      }
      if (getOwnPropertySymbols) {
        symbols = getOwnPropertySymbols(from);
        for (var i = 0; i < symbols.length; i++) {
          if (propIsEnumerable.call(from, symbols[i])) {
            to[symbols[i]] = from[symbols[i]];
          }
        }
      }
    }
    return to;
  };
});

// ../../node_modules/.pnpm/cors@2.8.5/node_modules/cors/lib/index.js
var require_lib10 = __commonJS((exports2, module2) => {
  (function() {
    "use strict";
    var assign = require_object_assign();
    var vary = require_vary();
    var defaults = {
      origin: "*",
      methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
      preflightContinue: false,
      optionsSuccessStatus: 204
    };
    function isString(s2) {
      return typeof s2 === "string" || s2 instanceof String;
    }
    function isOriginAllowed(origin, allowedOrigin) {
      if (Array.isArray(allowedOrigin)) {
        for (var i = 0; i < allowedOrigin.length; ++i) {
          if (isOriginAllowed(origin, allowedOrigin[i])) {
            return true;
          }
        }
        return false;
      } else if (isString(allowedOrigin)) {
        return origin === allowedOrigin;
      } else if (allowedOrigin instanceof RegExp) {
        return allowedOrigin.test(origin);
      } else {
        return !!allowedOrigin;
      }
    }
    function configureOrigin(options, req) {
      var requestOrigin = req.headers.origin, headers = [], isAllowed;
      if (!options.origin || options.origin === "*") {
        headers.push([{
          key: "Access-Control-Allow-Origin",
          value: "*"
        }]);
      } else if (isString(options.origin)) {
        headers.push([{
          key: "Access-Control-Allow-Origin",
          value: options.origin
        }]);
        headers.push([{
          key: "Vary",
          value: "Origin"
        }]);
      } else {
        isAllowed = isOriginAllowed(requestOrigin, options.origin);
        headers.push([{
          key: "Access-Control-Allow-Origin",
          value: isAllowed ? requestOrigin : false
        }]);
        headers.push([{
          key: "Vary",
          value: "Origin"
        }]);
      }
      return headers;
    }
    function configureMethods(options) {
      var methods = options.methods;
      if (methods.join) {
        methods = options.methods.join(",");
      }
      return {
        key: "Access-Control-Allow-Methods",
        value: methods
      };
    }
    function configureCredentials(options) {
      if (options.credentials === true) {
        return {
          key: "Access-Control-Allow-Credentials",
          value: "true"
        };
      }
      return null;
    }
    function configureAllowedHeaders(options, req) {
      var allowedHeaders = options.allowedHeaders || options.headers;
      var headers = [];
      if (!allowedHeaders) {
        allowedHeaders = req.headers["access-control-request-headers"];
        headers.push([{
          key: "Vary",
          value: "Access-Control-Request-Headers"
        }]);
      } else if (allowedHeaders.join) {
        allowedHeaders = allowedHeaders.join(",");
      }
      if (allowedHeaders && allowedHeaders.length) {
        headers.push([{
          key: "Access-Control-Allow-Headers",
          value: allowedHeaders
        }]);
      }
      return headers;
    }
    function configureExposedHeaders(options) {
      var headers = options.exposedHeaders;
      if (!headers) {
        return null;
      } else if (headers.join) {
        headers = headers.join(",");
      }
      if (headers && headers.length) {
        return {
          key: "Access-Control-Expose-Headers",
          value: headers
        };
      }
      return null;
    }
    function configureMaxAge(options) {
      var maxAge = (typeof options.maxAge === "number" || options.maxAge) && options.maxAge.toString();
      if (maxAge && maxAge.length) {
        return {
          key: "Access-Control-Max-Age",
          value: maxAge
        };
      }
      return null;
    }
    function applyHeaders(headers, res) {
      for (var i = 0, n = headers.length; i < n; i++) {
        var header = headers[i];
        if (header) {
          if (Array.isArray(header)) {
            applyHeaders(header, res);
          } else if (header.key === "Vary" && header.value) {
            vary(res, header.value);
          } else if (header.value) {
            res.setHeader(header.key, header.value);
          }
        }
      }
    }
    function cors(options, req, res, next) {
      var headers = [], method = req.method && req.method.toUpperCase && req.method.toUpperCase();
      if (method === "OPTIONS") {
        headers.push(configureOrigin(options, req));
        headers.push(configureCredentials(options, req));
        headers.push(configureMethods(options, req));
        headers.push(configureAllowedHeaders(options, req));
        headers.push(configureMaxAge(options, req));
        headers.push(configureExposedHeaders(options, req));
        applyHeaders(headers, res);
        if (options.preflightContinue) {
          next();
        } else {
          res.statusCode = options.optionsSuccessStatus;
          res.setHeader("Content-Length", "0");
          res.end();
        }
      } else {
        headers.push(configureOrigin(options, req));
        headers.push(configureCredentials(options, req));
        headers.push(configureExposedHeaders(options, req));
        applyHeaders(headers, res);
        next();
      }
    }
    function middlewareWrapper(o) {
      var optionsCallback = null;
      if (typeof o === "function") {
        optionsCallback = o;
      } else {
        optionsCallback = function(req, cb) {
          cb(null, o);
        };
      }
      return function corsMiddleware(req, res, next) {
        optionsCallback(req, function(err, options) {
          if (err) {
            next(err);
          } else {
            var corsOptions = assign({}, defaults, options);
            var originCallback = null;
            if (corsOptions.origin && typeof corsOptions.origin === "function") {
              originCallback = corsOptions.origin;
            } else if (corsOptions.origin) {
              originCallback = function(origin, cb) {
                cb(null, corsOptions.origin);
              };
            }
            if (originCallback) {
              originCallback(req.headers.origin, function(err2, origin) {
                if (err2 || !origin) {
                  next(err2);
                } else {
                  corsOptions.origin = origin;
                  cors(corsOptions, req, res, next);
                }
              });
            } else {
              next();
            }
          }
        });
      };
    }
    module2.exports = middlewareWrapper;
  })();
});

// ../../node_modules/.pnpm/@prisma+studio-transports@0.423.0/node_modules/@prisma/studio-transports/dist/http/node.mjs
var require_node8 = __commonJS((exports2) => {
  __markAsModule2(exports2);
  __export2(exports2, {
    HTTPNodeTransport: () => HTTPNodeTransport
  });
  var import_zlib = __toModule2(require("zlib"));
  var BIGINT_PREFIX = "PrismaBigInt::";
  var BYTES_PREFIX = "PrismaBytes::";
  function serialize(msg) {
    return JSON.stringify(msg, (_2, value) => {
      if (typeof value === "bigint") {
        return BIGINT_PREFIX + value;
      }
      if ((value == null ? void 0 : value.type) === "Buffer" && Array.isArray(value == null ? void 0 : value.data)) {
        return BYTES_PREFIX + Buffer.from(value.data).toString("base64");
      }
      return value;
    });
  }
  var HTTPNodeTransport = class {
    async respond(responseObject, response) {
      responseObject.status(200);
      responseObject.setHeader("Content-Type", "text/plain");
      const serializedResponse = serialize(response);
      if (!process.env.PRISMA_STUDIO_DISABLE_GZIP) {
        responseObject.setHeader("Content-Encoding", "gzip");
        const gzippedResponse = import_zlib.gzipSync(Buffer.from(serializedResponse, "utf8"));
        responseObject.send(gzippedResponse);
      } else {
        responseObject.send(serializedResponse);
      }
      return Promise.resolve(serializedResponse);
    }
  };
});

// ../../node_modules/.pnpm/debug@4.3.1/node_modules/debug/src/common.js
var require_common8 = __commonJS((exports2, module2) => {
  function setup(env2) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env2).forEach((key) => {
      createDebug[key] = env2[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      function debug3(...args2) {
        if (!debug3.enabled) {
          return;
        }
        const self2 = debug3;
        const curr = Number(new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args2[0] = createDebug.coerce(args2[0]);
        if (typeof args2[0] !== "string") {
          args2.unshift("%O");
        }
        let index = 0;
        args2[0] = args2[0].replace(/%([a-zA-Z%])/g, (match, format10) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format10];
          if (typeof formatter === "function") {
            const val = args2[index];
            match = formatter.call(self2, val);
            args2.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args2);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args2);
      }
      debug3.namespace = namespace;
      debug3.useColors = createDebug.useColors();
      debug3.color = createDebug.selectColor(namespace);
      debug3.extend = extend;
      debug3.destroy = createDebug.destroy;
      Object.defineProperty(debug3, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug3);
      }
      return debug3;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module2.exports = setup;
});

// ../../node_modules/.pnpm/debug@4.3.1/node_modules/debug/src/browser.js
var require_browser5 = __commonJS((exports2, module2) => {
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load2;
  exports2.useColors = useColors;
  exports2.storage = localstorage();
  exports2.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports2.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args2) {
    args2[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args2[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args2.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args2[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args2.splice(lastC, 0, c);
  }
  exports2.log = console.debug || console.log || (() => {
  });
  function save(namespaces) {
    try {
      if (namespaces) {
        exports2.storage.setItem("debug", namespaces);
      } else {
        exports2.storage.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load2() {
    let r;
    try {
      r = exports2.storage.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  module2.exports = require_common8()(exports2);
  var {formatters} = module2.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// ../../node_modules/.pnpm/debug@4.3.1/node_modules/debug/src/node.js
var require_node9 = __commonJS((exports2, module2) => {
  var tty = require("tty");
  var util2 = require("util");
  exports2.init = init;
  exports2.log = log2;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load2;
  exports2.useColors = useColors;
  exports2.destroy = util2.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports2.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports2.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {
  }
  exports2.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_2, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args2) {
    const {namespace: name, useColors: useColors2} = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} [0m`;
      args2[0] = prefix + args2[0].split("\n").join("\n" + prefix);
      args2.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
    } else {
      args2[0] = getDate() + name + " " + args2[0];
    }
  }
  function getDate() {
    if (exports2.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log2(...args2) {
    return process.stderr.write(util2.format(...args2) + "\n");
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load2() {
    return process.env.DEBUG;
  }
  function init(debug3) {
    debug3.inspectOpts = {};
    const keys = Object.keys(exports2.inspectOpts);
    for (let i = 0; i < keys.length; i++) {
      debug3.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
    }
  }
  module2.exports = require_common8()(exports2);
  var {formatters} = module2.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v, this.inspectOpts);
  };
});

// ../../node_modules/.pnpm/debug@4.3.1/node_modules/debug/src/index.js
var require_src6 = __commonJS((exports2, module2) => {
  if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
    module2.exports = require_browser5();
  } else {
    module2.exports = require_node9();
  }
});

// ../../node_modules/.pnpm/@prisma+studio-pcw@0.423.0_e71e9f4190c270e7c2163e3230782422/node_modules/@prisma/studio-pcw/dist/utils/debug.js
var require_debug2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.debug = void 0;
  var debug_12 = require_src6();
  exports2.debug = debug_12.debug("prisma:studio-pcw");
});

// ../../node_modules/.pnpm/@prisma+studio-pcw@0.423.0_e71e9f4190c270e7c2163e3230782422/node_modules/@prisma/studio-pcw/dist/generators.js
var require_generators = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getGenerator = void 0;
  var sdk_1 = require_dist12();
  var debug_12 = require_debug2();
  async function getGenerator2({schemaPath, forceBinary, forceLibrary, paths}) {
    debug_12.debug("[getDMMF] Calling getGenerator with:", {
      paths
    });
    const prismaGenerators = await sdk_1.getGenerators({
      schemaPath,
      skipDownload: forceLibrary || forceBinary || false,
      overrideGenerators: [
        {
          name: "studio-client",
          provider: {fromEnvVar: "", value: "prisma-client-js"},
          previewFeatures: [],
          output: {fromEnvVar: "", value: ""},
          binaryTargets: [],
          config: {}
        }
      ],
      binaryPathsOverride: paths.queryEngine ? {
        [paths.queryEngine.type === "binary" ? "queryEngine" : "libqueryEngine"]: paths.queryEngine.path
      } : void 0,
      providerAliases: {
        "prisma-client-js": {
          generatorPath: `${paths.prismaClient}/generator-build/index.js`,
          outputPath: "",
          isNode: true
        }
      }
    });
    const prismaClientGenerator = prismaGenerators.find((g) => g.config.provider.value === "prisma-client-js");
    if (!prismaClientGenerator) {
      throw new Error("Unable to get Prisma Client generator. This is a bug.");
    }
    prismaGenerators.filter((g) => g.config.provider.value !== "prisma-client-js").forEach((g) => g.stop());
    return prismaClientGenerator;
  }
  exports2.getGenerator = getGenerator2;
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/lodash.js
var require_lodash7 = __commonJS((exports2, module2) => {
  /**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */
  (function() {
    var undefined2;
    var VERSION = "4.17.21";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrimStart = /^\s+/;
    var reWhitespace = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      \u00C0: "A",
      \u00C1: "A",
      \u00C2: "A",
      \u00C3: "A",
      \u00C4: "A",
      \u00C5: "A",
      \u00E0: "a",
      \u00E1: "a",
      \u00E2: "a",
      \u00E3: "a",
      \u00E4: "a",
      \u00E5: "a",
      \u00C7: "C",
      \u00E7: "c",
      \u00D0: "D",
      \u00F0: "d",
      \u00C8: "E",
      \u00C9: "E",
      \u00CA: "E",
      \u00CB: "E",
      \u00E8: "e",
      \u00E9: "e",
      \u00EA: "e",
      \u00EB: "e",
      \u00CC: "I",
      \u00CD: "I",
      \u00CE: "I",
      \u00CF: "I",
      \u00EC: "i",
      \u00ED: "i",
      \u00EE: "i",
      \u00EF: "i",
      \u00D1: "N",
      \u00F1: "n",
      \u00D2: "O",
      \u00D3: "O",
      \u00D4: "O",
      \u00D5: "O",
      \u00D6: "O",
      \u00D8: "O",
      \u00F2: "o",
      \u00F3: "o",
      \u00F4: "o",
      \u00F5: "o",
      \u00F6: "o",
      \u00F8: "o",
      \u00D9: "U",
      \u00DA: "U",
      \u00DB: "U",
      \u00DC: "U",
      \u00F9: "u",
      \u00FA: "u",
      \u00FB: "u",
      \u00FC: "u",
      \u00DD: "Y",
      \u00FD: "y",
      \u00FF: "y",
      \u00C6: "Ae",
      \u00E6: "ae",
      \u00DE: "Th",
      \u00FE: "th",
      \u00DF: "ss",
      \u0100: "A",
      \u0102: "A",
      \u0104: "A",
      \u0101: "a",
      \u0103: "a",
      \u0105: "a",
      \u0106: "C",
      \u0108: "C",
      \u010A: "C",
      \u010C: "C",
      \u0107: "c",
      \u0109: "c",
      \u010B: "c",
      \u010D: "c",
      \u010E: "D",
      \u0110: "D",
      \u010F: "d",
      \u0111: "d",
      \u0112: "E",
      \u0114: "E",
      \u0116: "E",
      \u0118: "E",
      \u011A: "E",
      \u0113: "e",
      \u0115: "e",
      \u0117: "e",
      \u0119: "e",
      \u011B: "e",
      \u011C: "G",
      \u011E: "G",
      \u0120: "G",
      \u0122: "G",
      \u011D: "g",
      \u011F: "g",
      \u0121: "g",
      \u0123: "g",
      \u0124: "H",
      \u0126: "H",
      \u0125: "h",
      \u0127: "h",
      \u0128: "I",
      \u012A: "I",
      \u012C: "I",
      \u012E: "I",
      \u0130: "I",
      \u0129: "i",
      \u012B: "i",
      \u012D: "i",
      \u012F: "i",
      \u0131: "i",
      \u0134: "J",
      \u0135: "j",
      \u0136: "K",
      \u0137: "k",
      \u0138: "k",
      \u0139: "L",
      \u013B: "L",
      \u013D: "L",
      \u013F: "L",
      \u0141: "L",
      \u013A: "l",
      \u013C: "l",
      \u013E: "l",
      \u0140: "l",
      \u0142: "l",
      \u0143: "N",
      \u0145: "N",
      \u0147: "N",
      \u014A: "N",
      \u0144: "n",
      \u0146: "n",
      \u0148: "n",
      \u014B: "n",
      \u014C: "O",
      \u014E: "O",
      \u0150: "O",
      \u014D: "o",
      \u014F: "o",
      \u0151: "o",
      \u0154: "R",
      \u0156: "R",
      \u0158: "R",
      \u0155: "r",
      \u0157: "r",
      \u0159: "r",
      \u015A: "S",
      \u015C: "S",
      \u015E: "S",
      \u0160: "S",
      \u015B: "s",
      \u015D: "s",
      \u015F: "s",
      \u0161: "s",
      \u0162: "T",
      \u0164: "T",
      \u0166: "T",
      \u0163: "t",
      \u0165: "t",
      \u0167: "t",
      \u0168: "U",
      \u016A: "U",
      \u016C: "U",
      \u016E: "U",
      \u0170: "U",
      \u0172: "U",
      \u0169: "u",
      \u016B: "u",
      \u016D: "u",
      \u016F: "u",
      \u0171: "u",
      \u0173: "u",
      \u0174: "W",
      \u0175: "w",
      \u0176: "Y",
      \u0177: "y",
      \u0178: "Y",
      \u0179: "Z",
      \u017B: "Z",
      \u017D: "Z",
      \u017A: "z",
      \u017C: "z",
      \u017E: "z",
      \u0132: "IJ",
      \u0133: "ij",
      \u0152: "Oe",
      \u0153: "oe",
      \u0149: "'n",
      \u017F: "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args2) {
      switch (args2.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args2[0]);
        case 2:
          return func.call(thisArg, args2[0], args2[1]);
        case 3:
          return func.call(thisArg, args2[0], args2[1], args2[2]);
      }
      return func.apply(thisArg, args2);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEachRight(array, iteratee) {
      var length = array == null ? 0 : array.length;
      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEvery(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value, key, collection2) {
        if (predicate(value, key, collection2)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (comparator(array[index], value)) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array, iteratee) {
      var length = array == null ? 0 : array.length;
      return length ? baseSum(array, iteratee) / length : NAN;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined2 : object[key];
      };
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined2 : object[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    function baseSum(array, iteratee) {
      var result, index = -1, length = array.length;
      while (++index < length) {
        var current = iteratee(array[index]);
        if (current !== undefined2) {
          result = result === undefined2 ? current : result + current;
        }
      }
      return result;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseToPairs(object, props) {
      return arrayMap(props, function(key) {
        return [key, object[key]];
      });
    }
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index = -1, length = strSymbols.length;
      while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index = strSymbols.length;
      while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function countHolders(array, placeholder) {
      var length = array.length, result = 0;
      while (length--) {
        if (array[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue(object, key) {
      return object == null ? undefined2 : object[key];
    }
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function iteratorToArray(iterator) {
      var data, result = [];
      while (!(data = iterator.next()).done) {
        result.push(data.value);
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg10) {
        return func(transform(arg10));
      };
    }
    function replaceHolders(array, placeholder) {
      var index = -1, length = array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (value === placeholder || value === PLACEHOLDER) {
          array[index] = PLACEHOLDER;
          result[resIndex++] = index;
        }
      }
      return result;
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    function setToPairs(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = [value, value];
      });
      return result;
    }
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array, value, fromIndex) {
      var index = fromIndex + 1;
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return index;
    }
    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function trimmedEndIndex(string) {
      var index = string.length;
      while (index-- && reWhitespace.test(string.charAt(index))) {
      }
      return index;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext2(context) {
      context = context == null ? root : _2.defaults(root.Object(), context, _2.pick(root, contextProps));
      var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
      var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
      var coreJsData = context["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object2);
      var oldDash = root._;
      var reIsNative = RegExp2("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
      var defineProperty = function() {
        try {
          var func = getNative(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
      var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
      var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
      var metaMap = WeakMap2 && new WeakMap2();
      var realNames = {};
      var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
      function lodash(value) {
        if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate = function() {
        function object() {
        }
        return function(proto) {
          if (!isObject(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result2 = new object();
          object.prototype = undefined2;
          return result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined2;
      }
      lodash.templateSettings = {
        escape: reEscape,
        evaluate: reEvaluate,
        interpolate: reInterpolate,
        variable: "",
        imports: {
          _: lodash
        }
      };
      lodash.prototype = baseLodash.prototype;
      lodash.prototype.constructor = lodash;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index += dir;
            var iterIndex = -1, value = array[index];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result2 = data[key];
          return result2 === HASH_UNDEFINED ? undefined2 : result2;
        }
        return hasOwnProperty.call(data, key) ? data[key] : undefined2;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? undefined2 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          hash: new Hash(),
          map: new (Map2 || ListCache)(),
          string: new Hash()
        };
      }
      function mapCacheDelete(key) {
        var result2 = getMapData(this, key)["delete"](key);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size2 = data.size;
        data.set(key, value);
        this.size += data.size == size2 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values2) {
        var index = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values2[index]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result2 = data["delete"](key);
        this.size = data.size;
        return result2;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function arraySample(array) {
        var length = array.length;
        return length ? array[baseRandom(0, length - 1)] : undefined2;
      }
      function arraySampleSize(array, n) {
        return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
      }
      function arrayShuffle(array) {
        return shuffleSelf(copyArray(array));
      }
      function assignMergeValue(object, key, value) {
        if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value, key, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        });
        return accumulator;
      }
      function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object);
      }
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        } else {
          object[key] = value;
        }
      }
      function baseAt(object, paths) {
        var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
        while (++index < length) {
          result2[index] = skip ? undefined2 : get(object, paths[index]);
        }
        return result2;
      }
      function baseClamp(number, lower, upper) {
        if (number === number) {
          if (upper !== undefined2) {
            number = number <= upper ? number : upper;
          }
          if (lower !== undefined2) {
            number = number >= lower ? number : lower;
          }
        }
        return number;
      }
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result2 = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result2 !== undefined2) {
          return result2;
        }
        if (!isObject(value)) {
          return value;
        }
        var isArr = isArray(value);
        if (isArr) {
          result2 = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result2);
          }
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result2 = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result2);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap(value)) {
          value.forEach(function(subValue, key2) {
            result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? undefined2 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result2;
      }
      function baseConforms(source) {
        var props = keys(source);
        return function(object) {
          return baseConformsTo(object, source, props);
        };
      }
      function baseConformsTo(object, source, props) {
        var length = props.length;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (length--) {
          var key = props[length], predicate = source[key], value = object[key];
          if (value === undefined2 && !(key in object) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args2) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func.apply(undefined2, args2);
        }, wait);
      }
      function baseDifference(array, values2, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
        if (!length) {
          return result2;
        }
        if (iteratee2) {
          values2 = arrayMap(values2, baseUnary(iteratee2));
        }
        if (comparator) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values2.length >= LARGE_ARRAY_SIZE) {
          includes2 = cacheHas;
          isCommon = false;
          values2 = new SetCache(values2);
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes2(values2, computed, comparator)) {
              result2.push(value);
            }
          }
        return result2;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach(collection, function(value, index, collection2) {
          result2 = !!predicate(value, index, collection2);
          return result2;
        });
        return result2;
      }
      function baseExtremum(array, iteratee2, comparator) {
        var index = -1, length = array.length;
        while (++index < length) {
          var value = array[index], current = iteratee2(value);
          if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
            var computed = current, result2 = value;
          }
        }
        return result2;
      }
      function baseFill(array, value, start, end) {
        var length = array.length;
        start = toInteger(start);
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end === undefined2 || end > length ? length : toInteger(end);
        if (end < 0) {
          end += length;
        }
        end = start > end ? 0 : toLength(end);
        while (start < end) {
          array[start++] = value;
        }
        return array;
      }
      function baseFilter(collection, predicate) {
        var result2 = [];
        baseEach(collection, function(value, index, collection2) {
          if (predicate(value, index, collection2)) {
            result2.push(value);
          }
        });
        return result2;
      }
      function baseFlatten(array, depth, predicate, isStrict, result2) {
        var index = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index < length) {
          var value = array[index];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush(result2, value);
            }
          } else if (!isStrict) {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object, iteratee2) {
        return object && baseFor(object, iteratee2, keys);
      }
      function baseForOwnRight(object, iteratee2) {
        return object && baseForRight(object, iteratee2, keys);
      }
      function baseFunctions(object, props) {
        return arrayFilter(props, function(key) {
          return isFunction(object[key]);
        });
      }
      function baseGet(object, path10) {
        path10 = castPath(path10, object);
        var index = 0, length = path10.length;
        while (object != null && index < length) {
          object = object[toKey(path10[index++])];
        }
        return index && index == length ? object : undefined2;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object);
        return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
      }
      function baseGetTag(value) {
        if (value == null) {
          return value === undefined2 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object, key) {
        return object != null && hasOwnProperty.call(object, key);
      }
      function baseHasIn(object, key) {
        return object != null && key in Object2(object);
      }
      function baseInRange(number, start, end) {
        return number >= nativeMin(start, end) && number < nativeMax(start, end);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee2) {
            array = arrayMap(array, baseUnary(iteratee2));
          }
          maxLength = nativeMin(array.length, maxLength);
          caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
        }
        array = arrays[0];
        var index = -1, seen = caches[0];
        outer:
          while (++index < length && result2.length < maxLength) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseInverter(object, setter, iteratee2, accumulator) {
        baseForOwn(object, function(value, key, object2) {
          setter(accumulator, iteratee2(value), key, object2);
        });
        return accumulator;
      }
      function baseInvoke(object, path10, args2) {
        path10 = castPath(path10, object);
        object = parent(object, path10);
        var func = object == null ? object : object[toKey(last(path10))];
        return func == null ? undefined2 : apply(func, object, args2);
      }
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
      }
      function baseIsDate(value) {
        return isObjectLike(value) && baseGetTag(value) == dateTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }
      function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (index--) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === undefined2 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack();
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike(value) && baseGetTag(value) == regexpTag;
      }
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result2 = [];
        for (var key in Object2(object)) {
          if (hasOwnProperty.call(object, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseKeysIn(object) {
        if (!isObject(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result2 = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result2[++index] = iteratee2(value, key, collection2);
        });
        return result2;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseMatchesProperty(path10, srcValue) {
        if (isKey(path10) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path10), srcValue);
        }
        return function(object) {
          var objValue = get(object, path10);
          return objValue === undefined2 && objValue === srcValue ? hasIn(object, path10) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack());
          if (isObject(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
            if (newValue === undefined2) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
        var isCommon = newValue === undefined2;
        if (isCommon) {
          var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject(objValue) || isFunction(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function baseNth(array, n) {
        var length = array.length;
        if (!length) {
          return;
        }
        n += n < 0 ? length : 0;
        return isIndex(n, length) ? array[n] : undefined2;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray(iteratee2)) {
              return function(value) {
                return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity];
        }
        var index = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return {criteria, index: ++index, value};
        });
        return baseSortBy(result2, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path10) {
          return hasIn(object, path10);
        });
      }
      function basePickBy(object, paths, predicate) {
        var index = -1, length = paths.length, result2 = {};
        while (++index < length) {
          var path10 = paths[index], value = baseGet(object, path10);
          if (predicate(value, path10)) {
            baseSet(result2, castPath(path10, object), value);
          }
        }
        return result2;
      }
      function basePropertyDeep(path10) {
        return function(object) {
          return baseGet(object, path10);
        };
      }
      function basePullAll(array, values2, iteratee2, comparator) {
        var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
        if (array === values2) {
          values2 = copyArray(values2);
        }
        if (iteratee2) {
          seen = arrayMap(array, baseUnary(iteratee2));
        }
        while (++index < length) {
          var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
            if (seen !== array) {
              splice.call(seen, fromIndex, 1);
            }
            splice.call(array, fromIndex, 1);
          }
        }
        return array;
      }
      function basePullAt(array, indexes) {
        var length = array ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index = indexes[length];
          if (length == lastIndex || index !== previous) {
            var previous = index;
            if (isIndex(index)) {
              splice.call(array, index, 1);
            } else {
              baseUnset(array, index);
            }
          }
        }
        return array;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start, end, step, fromRight) {
        var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
        while (length--) {
          result2[fromRight ? length : ++index] = start;
          start += step;
        }
        return result2;
      }
      function baseRepeat(string, n) {
        var result2 = "";
        if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
          return result2;
        }
        do {
          if (n % 2) {
            result2 += string;
          }
          n = nativeFloor(n / 2);
          if (n) {
            string += string;
          }
        } while (n);
        return result2;
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + "");
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function baseSampleSize(collection, n) {
        var array = values(collection);
        return shuffleSelf(array, baseClamp(n, 0, array.length));
      }
      function baseSet(object, path10, value, customizer) {
        if (!isObject(object)) {
          return object;
        }
        path10 = castPath(path10, object);
        var index = -1, length = path10.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index < length) {
          var key = toKey(path10[index]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined2;
            if (newValue === undefined2) {
              newValue = isObject(objValue) ? objValue : isIndex(path10[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      var baseSetData = !metaMap ? identity : function(func, data) {
        metaMap.set(func, data);
        return func;
      };
      var baseSetToString = !defineProperty ? identity : function(func, string) {
        return defineProperty(func, "toString", {
          configurable: true,
          enumerable: false,
          value: constant(string),
          writable: true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      function baseSlice(array, start, end) {
        var index = -1, length = array.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result2 = Array2(length);
        while (++index < length) {
          result2[index] = array[index + start];
        }
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        baseEach(collection, function(value, index, collection2) {
          result2 = predicate(value, index, collection2);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array, value, retHighest) {
        var low = 0, high = array == null ? low : array.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed = array[mid];
            if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array, value, identity, retHighest);
      }
      function baseSortedIndexBy(array, value, iteratee2, retHighest) {
        var low = 0, high = array == null ? 0 : array.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed <= value : computed < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array, iteratee2) {
        var index = -1, length = array.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
          if (!index || !eq(computed, seen)) {
            var seen = computed;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        return +value;
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function baseUniq(array, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
        if (comparator) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set2 = iteratee2 ? null : createSet(array);
          if (set2) {
            return setToArray(set2);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen = new SetCache();
        } else {
          seen = iteratee2 ? [] : result2;
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed);
              }
              result2.push(value);
            } else if (!includes2(seen, computed, comparator)) {
              if (seen !== result2) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseUnset(object, path10) {
        path10 = castPath(path10, object);
        object = parent(object, path10);
        return object == null || delete object[toKey(last(path10))];
      }
      function baseUpdate(object, path10, updater, customizer) {
        return baseSet(object, path10, updater(baseGet(object, path10)), customizer);
      }
      function baseWhile(array, predicate, isDrop, fromRight) {
        var length = array.length, index = fromRight ? length : -1;
        while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
        }
        return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
      }
      function baseWrapperValue(value, actions) {
        var result2 = value;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index = -1, result2 = Array2(length);
        while (++index < length) {
          var array = arrays[index], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index) {
              result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
      }
      function baseZipObject(props, values2, assignFunc) {
        var index = -1, length = props.length, valsLength = values2.length, result2 = {};
        while (++index < length) {
          var value = index < valsLength ? values2[index] : undefined2;
          assignFunc(result2, props[index], value);
        }
        return result2;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity;
      }
      function castPath(value, object) {
        if (isArray(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString(value));
      }
      var castRest = baseRest;
      function castSlice(array, start, end) {
        var length = array.length;
        end = end === undefined2 ? length : end;
        return !start && end >= length ? array : baseSlice(array, start, end);
      }
      var clearTimeout2 = ctxClearTimeout || function(id) {
        return root.clearTimeout(id);
      };
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result2);
        return result2;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
        return result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
          var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index < length) {
          var result2 = compareAscending(objCriteria[index], othCriteria[index]);
          if (result2) {
            if (index >= ordersLength) {
              return result2;
            }
            var order = orders[index];
            return result2 * (order == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function composeArgs(args2, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args2.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args2[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args2[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args2, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args2.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args2[argsIndex];
        }
        var offset = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset + holders[holdersIndex]] = args2[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray(source, array) {
        var index = -1, length = source.length;
        array || (array = Array2(length));
        while (++index < length) {
          array[index] = source[index];
        }
        return array;
      }
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
          if (newValue === undefined2) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined2 : customizer;
            length = 1;
          }
          object = Object2(object);
          while (++index < length) {
            var source = sources[index];
            if (source) {
              assigner(object, source, index, customizer);
            }
          }
          return object;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
          while (fromRight ? index-- : ++index < length) {
            if (iteratee2(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee2, keysFunc) {
          var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string) {
          string = toString(string);
          var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string) {
          return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args2 = arguments;
          switch (args2.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args2[0]);
            case 2:
              return new Ctor(args2[0], args2[1]);
            case 3:
              return new Ctor(args2[0], args2[1], args2[2]);
            case 4:
              return new Ctor(args2[0], args2[1], args2[2], args2[3]);
            case 5:
              return new Ctor(args2[0], args2[1], args2[2], args2[3], args2[4]);
            case 6:
              return new Ctor(args2[0], args2[1], args2[2], args2[3], args2[4], args2[5]);
            case 7:
              return new Ctor(args2[0], args2[1], args2[2], args2[3], args2[4], args2[5], args2[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args2);
          return isObject(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args2 = Array2(length), index = length, placeholder = getHolder(wrapper);
          while (index--) {
            args2[index] = arguments[index];
          }
          var holders = length < 3 && args2[0] !== placeholder && args2[length - 1] !== placeholder ? [] : replaceHolders(args2, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined2, args2, holders, undefined2, undefined2, arity - length);
          }
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return apply(fn, this, args2);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys(collection);
            predicate = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index = findIndexFunc(collection, predicate, fromIndex);
          return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index--) {
            var func = funcs[index];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index = wrapper ? index : length;
          while (++index < length) {
            func = funcs[index];
            var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
            if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
              wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args2 = arguments, value = args2[0];
            if (wrapper && args2.length == 1 && isArray(value)) {
              return wrapper.plant(value).value();
            }
            var index2 = 0, result2 = length ? funcs[index2].apply(this, args2) : value;
            while (++index2 < length) {
              result2 = funcs[index2].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args2 = Array2(length), index = length;
          while (index--) {
            args2[index] = arguments[index];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args2, placeholder);
          }
          if (partials) {
            args2 = composeArgs(args2, partials, holders, isCurried);
          }
          if (partialsRight) {
            args2 = composeArgsRight(args2, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args2, placeholder);
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args2, newHolders, argPos, ary2, arity - length);
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
          length = args2.length;
          if (argPos) {
            args2 = reorder(args2, argPos);
          } else if (isFlip && length > 1) {
            args2.reverse();
          }
          if (isAry && ary2 < length) {
            args2.length = ary2;
          }
          if (this && this !== root && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
          }
          return fn.apply(thisBinding, args2);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object, iteratee2) {
          return baseInverter(object, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === undefined2 && other === undefined2) {
            return defaultValue;
          }
          if (value !== undefined2) {
            result2 = value;
          }
          if (other !== undefined2) {
            if (result2 === undefined2) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString(value);
              other = baseToString(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result2 = operator(value, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args2) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args2);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined2 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args2 = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args2[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args2[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn, isBind ? thisArg : this, args2);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start, end, step) {
          if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
            end = step = undefined2;
          }
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
          return baseRange(start, end, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber(value);
            other = toNumber(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined2, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number, precision) {
          number = toNumber(number);
          precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
          if (precision && nativeIsFinite(number)) {
            var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number);
        };
      }
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
        return new Set2(values2);
      };
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = getTag(object);
          if (tag == mapTag) {
            return mapToArray(object);
          }
          if (tag == setTag) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined2;
        }
        ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
        arity = arity === undefined2 ? arity : toInteger(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined2;
        }
        var data = isBindKey ? undefined2 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data) {
          mergeData(newData, data);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined2, newData);
        }
        var setter = data ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
        if (isObject(objValue) && isObject(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value) {
        return isPlainObject(value) ? undefined2 : value;
      }
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
        stack.set(array, other);
        stack.set(other, array);
        while (++index < arrLength) {
          var arrValue = array[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
          }
          if (compared !== undefined2) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result2 = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result2;
      }
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other);
            var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result2;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result2 = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result2;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined2, flatten), func + "");
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      var getData = !metaMap ? noop : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
        while (length--) {
          var data = array[length], otherFunc = data.func;
          if (otherFunc == null || otherFunc == func) {
            return data.name;
          }
        }
        return result2;
      }
      function getHolder(func) {
        var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
        return object.placeholder;
      }
      function getIteratee() {
        var result2 = lodash.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData(map2, key) {
        var data = map2.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getMatchData(object) {
        var result2 = keys(object), length = result2.length;
        while (length--) {
          var key = result2[length], value = object[key];
          result2[length] = [key, value, isStrictComparable(value)];
        }
        return result2;
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : undefined2;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = undefined2;
          var unmasked = true;
        } catch (e) {
        }
        var result2 = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result2;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object2(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result2 = [];
        while (object) {
          arrayPush(result2, getSymbols(object));
          object = getPrototype(object);
        }
        return result2;
      };
      var getTag = baseGetTag;
      if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
        getTag = function(value) {
          var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result2;
        };
      }
      function getView(start, end, transforms) {
        var index = -1, length = transforms.length;
        while (++index < length) {
          var data = transforms[index], size2 = data.size;
          switch (data.type) {
            case "drop":
              start += size2;
              break;
            case "dropRight":
              end -= size2;
              break;
            case "take":
              end = nativeMin(end, start + size2);
              break;
            case "takeRight":
              start = nativeMax(start, end - size2);
              break;
          }
        }
        return {start, end};
      }
      function getWrapDetails(source) {
        var match = source.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }
      function hasPath(object, path10, hasFunc) {
        path10 = castPath(path10, object);
        var index = -1, length = path10.length, result2 = false;
        while (++index < length) {
          var key = toKey(path10[index]);
          if (!(result2 = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result2 || ++index != length) {
          return result2;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
      }
      function initCloneArray(array) {
        var length = array.length, result2 = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
          result2.index = array.index;
          result2.input = array.input;
        }
        return result2;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      function insertWrapDetails(source, details) {
        var length = details.length;
        if (!length) {
          return source;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable(value) {
        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isIterateeCall(value, index, object) {
        if (!isObject(object)) {
          return false;
        }
        var type = typeof index;
        if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
          return eq(object[index], value);
        }
        return false;
      }
      function isKey(value, object) {
        if (isArray(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data = getData(other);
        return !!data && func === data[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var isMaskable = coreJsData ? isFunction : stubFalse;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
        };
      }
      function memoizeCapped(func) {
        var result2 = memoize(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result2.cache;
        return result2;
      }
      function mergeData(data, source) {
        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source[3];
        if (value) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value, source[4]) : value;
          data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
        }
        value = source[5];
        if (value) {
          partials = data[5];
          data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
          data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
        }
        value = source[7];
        if (value) {
          data[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
        }
        if (data[9] == null) {
          data[9] = source[9];
        }
        data[0] = source[0];
        data[1] = newBitmask;
        return data;
      }
      function nativeKeysIn(object) {
        var result2 = [];
        if (object != null) {
          for (var key in Object2(object)) {
            result2.push(key);
          }
        }
        return result2;
      }
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      function overRest(func, start, transform2) {
        start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
        return function() {
          var args2 = arguments, index = -1, length = nativeMax(args2.length - start, 0), array = Array2(length);
          while (++index < length) {
            array[index] = args2[start + index];
          }
          index = -1;
          var otherArgs = Array2(start + 1);
          while (++index < start) {
            otherArgs[index] = args2[index];
          }
          otherArgs[start] = transform2(array);
          return apply(func, this, otherArgs);
        };
      }
      function parent(object, path10) {
        return path10.length < 2 ? object : baseGet(object, baseSlice(path10, 0, -1));
      }
      function reorder(array, indexes) {
        var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
        while (length--) {
          var index = indexes[length];
          array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
        }
        return array;
      }
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask) {
        var source = reference + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined2, arguments);
        };
      }
      function shuffleSelf(array, size2) {
        var index = -1, length = array.length, lastIndex = length - 1;
        size2 = size2 === undefined2 ? length : size2;
        while (++index < size2) {
          var rand = baseRandom(index, lastIndex), value = array[rand];
          array[rand] = array[index];
          array[index] = value;
        }
        array.length = size2;
        return array;
      }
      var stringToPath = memoizeCapped(function(string) {
        var result2 = [];
        if (string.charCodeAt(0) === 46) {
          result2.push("");
        }
        string.replace(rePropName, function(match, number, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
        });
        return result2;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      function chunk(array, size2, guard) {
        if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
          size2 = 1;
        } else {
          size2 = nativeMax(toInteger(size2), 0);
        }
        var length = array == null ? 0 : array.length;
        if (!length || size2 < 1) {
          return [];
        }
        var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
        while (index < length) {
          result2[resIndex++] = baseSlice(array, index, index += size2);
        }
        return result2;
      }
      function compact(array) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value = array[index];
          if (value) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function concat() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args2 = Array2(length - 1), array = arguments[0], index = length;
        while (index--) {
          args2[index - 1] = arguments[index];
        }
        return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args2, 1));
      }
      var difference = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array, values2) {
        var iteratee2 = last(values2);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array, values2) {
        var comparator = last(values2);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined2;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
      });
      function drop(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger(n);
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function dropRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function dropRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
      }
      function fill(array, value, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
          start = 0;
          end = length;
        }
        return baseFill(array, value, start, end);
      }
      function findIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index);
      }
      function findLastIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length - 1;
        if (fromIndex !== undefined2) {
          index = toInteger(fromIndex);
          index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index, true);
      }
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      function flattenDeep(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, INFINITY) : [];
      }
      function flattenDepth(array, depth) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined2 ? 1 : toInteger(depth);
        return baseFlatten(array, depth);
      }
      function fromPairs(pairs) {
        var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
        while (++index < length) {
          var pair = pairs[index];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array) {
        return array && array.length ? array[0] : undefined2;
      }
      function indexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseIndexOf(array, value, index);
      }
      function initial(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last(mapped)) {
          iteratee2 = undefined2;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        if (comparator) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
      });
      function join2(array, separator) {
        return array == null ? "" : nativeJoin.call(array, separator);
      }
      function last(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : undefined2;
      }
      function lastIndexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length;
        if (fromIndex !== undefined2) {
          index = toInteger(fromIndex);
          index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
      }
      function nth(array, n) {
        return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
      }
      var pull = baseRest(pullAll);
      function pullAll(array, values2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
      }
      function pullAllBy(array, values2, iteratee2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
      }
      function pullAllWith(array, values2, comparator) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
      }
      var pullAt = flatRest(function(array, indexes) {
        var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
        basePullAt(array, arrayMap(indexes, function(index) {
          return isIndex(index, length) ? +index : index;
        }).sort(compareAscending));
        return result2;
      });
      function remove(array, predicate) {
        var result2 = [];
        if (!(array && array.length)) {
          return result2;
        }
        var index = -1, indexes = [], length = array.length;
        predicate = getIteratee(predicate, 3);
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result2.push(value);
            indexes.push(index);
          }
        }
        basePullAt(array, indexes);
        return result2;
      }
      function reverse(array) {
        return array == null ? array : nativeReverse.call(array);
      }
      function slice(array, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
          start = 0;
          end = length;
        } else {
          start = start == null ? 0 : toInteger(start);
          end = end === undefined2 ? length : toInteger(end);
        }
        return baseSlice(array, start, end);
      }
      function sortedIndex(array, value) {
        return baseSortedIndex(array, value);
      }
      function sortedIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value);
          if (index < length && eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedLastIndex(array, value) {
        return baseSortedIndex(array, value, true);
      }
      function sortedLastIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value, true) - 1;
          if (eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedUniq(array) {
        return array && array.length ? baseSortedUniq(array) : [];
      }
      function sortedUniqBy(array, iteratee2) {
        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 1, length) : [];
      }
      function take(array, n, guard) {
        if (!(array && array.length)) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger(n);
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function takeRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function takeRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
      });
      function uniq(array) {
        return array && array.length ? baseUniq(array) : [];
      }
      function uniqBy(array, iteratee2) {
        return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return array && array.length ? baseUniq(array, undefined2, comparator) : [];
      }
      function unzip(array) {
        if (!(array && array.length)) {
          return [];
        }
        var length = 0;
        array = arrayFilter(array, function(group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index) {
          return arrayMap(array, baseProperty(index));
        });
      }
      function unzipWith(array, iteratee2) {
        if (!(array && array.length)) {
          return [];
        }
        var result2 = unzip(array);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap(result2, function(group) {
          return apply(iteratee2, undefined2, group);
        });
      }
      var without = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
      });
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values2) {
        return baseZipObject(props || [], values2 || [], assignValue);
      }
      function zipObjectDeep(props, values2) {
        return baseZipObject(props || [], values2 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value) {
        var result2 = lodash(value);
        result2.__chain__ = true;
        return result2;
      }
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
          return baseAt(object, paths);
        };
        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
          return this.thru(interceptor);
        }
        value = value.slice(start, +start + (length ? 1 : 0));
        value.__actions__.push({
          func: thru,
          args: [interceptor],
          thisArg: undefined2
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array) {
          if (length && !array.length) {
            array.push(undefined2);
          }
          return array;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined2) {
          this.__values__ = toArray(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
        return {done, value};
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result2, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone2 = wrapperClone(parent2);
          clone2.__index__ = 0;
          clone2.__values__ = undefined2;
          if (result2) {
            previous.__wrapped__ = clone2;
          } else {
            result2 = clone2;
          }
          var previous = clone2;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result2;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            func: thru,
            args: [reverse],
            thisArg: undefined2
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty.call(result2, key)) {
          ++result2[key];
        } else {
          baseAssignValue(result2, key, 1);
        }
      });
      function every(collection, predicate, guard) {
        var func = isArray(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined2;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find = createFind(findIndex);
      var findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), INFINITY);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined2 ? 1 : toInteger(depth);
        return baseFlatten(map(collection, iteratee2), depth);
      }
      function forEach(collection, iteratee2) {
        var func = isArray(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty.call(result2, key)) {
          result2[key].push(value);
        } else {
          baseAssignValue(result2, key, [value]);
        }
      });
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path10, args2) {
        var index = -1, isFunc = typeof path10 == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value) {
          result2[++index] = isFunc ? apply(path10, value, args2) : baseInvoke(value, path10, args2);
        });
        return result2;
      });
      var keyBy3 = createAggregator(function(result2, value, key) {
        baseAssignValue(result2, key, value);
      });
      function map(collection, iteratee2) {
        var func = isArray(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined2 : orders;
        if (!isArray(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition = createAggregator(function(result2, value, key) {
        result2[key ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n, guard) {
        if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        var func = isArray(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n);
      }
      function shuffle(collection) {
        var func = isArray(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      function some(collection, predicate, guard) {
        var func = isArray(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined2;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now = ctxNow || function() {
        return root.Date.now();
      };
      function after(n, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n, guard) {
        n = guard ? undefined2 : n;
        n = func && n == null ? func.length : n;
        return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
      }
      function before(n, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n <= 1) {
            func = undefined2;
          }
          return result2;
        };
      }
      var bind = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined2 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined2 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args2 = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined2;
          lastInvokeTime = time;
          result2 = func.apply(thisArg, args2);
          return result2;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined2;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined2;
          return result2;
        }
        function cancel() {
          if (timerId !== undefined2) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined2;
        }
        function flush() {
          return timerId === undefined2 ? result2 : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined2) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined2) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function(func, args2) {
        return baseDelay(func, 1, args2);
      });
      var delay = baseRest(function(func, wait, args2) {
        return baseDelay(func, toNumber(wait) || 0, args2);
      });
      function flip(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args2 = arguments, key = resolver ? resolver.apply(this, args2) : args2[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result2 = func.apply(this, args2);
          memoized.cache = cache.set(key, result2) || cache;
          return result2;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args2 = arguments;
          switch (args2.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args2[0]);
            case 2:
              return !predicate.call(this, args2[0], args2[1]);
            case 3:
              return !predicate.call(this, args2[0], args2[1], args2[2]);
          }
          return !predicate.apply(this, args2);
        };
      }
      function once(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args2) {
          var index = -1, length = nativeMin(args2.length, funcsLength);
          while (++index < length) {
            args2[index] = transforms[index].call(this, args2[index]);
          }
          return apply(func, this, args2);
        });
      });
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
      });
      function rest(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start === undefined2 ? start : toInteger(start);
        return baseRest(func, start);
      }
      function spread(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start == null ? 0 : nativeMax(toInteger(start), 0);
        return baseRest(function(args2) {
          var array = args2[start], otherArgs = castSlice(args2, 0, start);
          if (array) {
            arrayPush(otherArgs, array);
          }
          return apply(func, this, otherArgs);
        });
      }
      function throttle(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce(func, wait, {
          leading,
          maxWait: wait,
          trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray(value) ? value : [value];
      }
      function clone(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object, source) {
        return source == null || baseConformsTo(object, source, keys(source));
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray = Array2.isArray;
      var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function isBoolean(value) {
        return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
      }
      var isBuffer = nativeIsBuffer || stubFalse;
      var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement(value) {
        return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
      }
      function isEmpty(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
          return !value.length;
        }
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        var result2 = customizer ? customizer(value, other) : undefined2;
        return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
      }
      function isError7(value) {
        if (!isObjectLike(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
      }
      function isFinite2(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction(value) {
        if (!isObject(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isInteger(value) {
        return typeof value == "number" && value == toInteger(value);
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object, source) {
        return object === source || baseIsMatch(object, source, getMatchData(source));
      }
      function isMatchWith(object, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseIsMatch(object, source, getMatchData(source), customizer);
      }
      function isNaN2(value) {
        return isNumber(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value);
      }
      function isNull(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber(value) {
        return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
      }
      function isPlainObject(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
      }
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString(value) {
        return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined(value) {
        return value === undefined2;
      }
      function isWeakMap(value) {
        return isObjectLike(value) && getTag(value) == weakMapTag;
      }
      function isWeakSet(value) {
        return isObjectLike(value) && baseGetTag(value) == weakSetTag;
      }
      var lt = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike(value)) {
          return isString(value) ? stringToArray(value) : copyArray(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
        return func(value);
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result2 = toFinite(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
      }
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      var assign = createAssigner(function(object, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys(source), object);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            assignValue(object, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner(function(object, source) {
        copyObject(source, keysIn(source), object);
      });
      var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object, customizer);
      });
      var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keys(source), object, customizer);
      });
      var at = flatRest(baseAt);
      function create(prototype, properties) {
        var result2 = baseCreate(prototype);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      var defaults = baseRest(function(object, sources) {
        object = Object2(object);
        var index = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined2;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index < length) {
          var source = sources[index];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object[key];
            if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
              object[key] = source[key];
            }
          }
        }
        return object;
      });
      var defaultsDeep = baseRest(function(args2) {
        args2.push(undefined2, customDefaultsMerge);
        return apply(mergeWith, undefined2, args2);
      });
      function findKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object, iteratee2) {
        return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object, iteratee2) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object, iteratee2) {
        return object && baseForOwn(object, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object, iteratee2) {
        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
      }
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys(object));
      }
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }
      function get(object, path10, defaultValue) {
        var result2 = object == null ? undefined2 : baseGet(object, path10);
        return result2 === undefined2 ? defaultValue : result2;
      }
      function has(object, path10) {
        return object != null && hasPath(object, path10, baseHas);
      }
      function hasIn(object, path10) {
        return object != null && hasPath(object, path10, baseHasIn);
      }
      var invert = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        result2[value] = key;
      }, constant(identity));
      var invertBy = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        if (hasOwnProperty.call(result2, value)) {
          result2[value].push(key);
        } else {
          result2[value] = [key];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      function mapKeys2(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, iteratee2(value, key, object2), value);
        });
        return result2;
      }
      function mapValues(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, key, iteratee2(value, key, object2));
        });
        return result2;
      }
      var merge = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
        baseMerge(object, source, srcIndex, customizer);
      });
      var omit = flatRest(function(object, paths) {
        var result2 = {};
        if (object == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path10) {
          path10 = castPath(path10, object);
          isDeep || (isDeep = path10.length > 1);
          return path10;
        });
        copyObject(object, getAllKeysIn(object), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result2, paths[length]);
        }
        return result2;
      });
      function omitBy(object, predicate) {
        return pickBy(object, negate(getIteratee(predicate)));
      }
      var pick3 = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function pickBy(object, predicate) {
        if (object == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object, props, function(value, path10) {
          return predicate(value, path10[0]);
        });
      }
      function result(object, path10, defaultValue) {
        path10 = castPath(path10, object);
        var index = -1, length = path10.length;
        if (!length) {
          length = 1;
          object = undefined2;
        }
        while (++index < length) {
          var value = object == null ? undefined2 : object[toKey(path10[index])];
          if (value === undefined2) {
            index = length;
            value = defaultValue;
          }
          object = isFunction(value) ? value.call(object) : value;
        }
        return object;
      }
      function set(object, path10, value) {
        return object == null ? object : baseSet(object, path10, value);
      }
      function setWith(object, path10, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return object == null ? object : baseSet(object, path10, value, customizer);
      }
      var toPairs = createToPairs(keys);
      var toPairsIn = createToPairs(keysIn);
      function transform(object, iteratee2, accumulator) {
        var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject(object)) {
            accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
          return iteratee2(accumulator, value, index, object2);
        });
        return accumulator;
      }
      function unset(object, path10) {
        return object == null ? true : baseUnset(object, path10);
      }
      function update(object, path10, updater) {
        return object == null ? object : baseUpdate(object, path10, castFunction(updater));
      }
      function updateWith(object, path10, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return object == null ? object : baseUpdate(object, path10, castFunction(updater), customizer);
      }
      function values(object) {
        return object == null ? [] : baseValues(object, keys(object));
      }
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn(object));
      }
      function clamp(number, lower, upper) {
        if (upper === undefined2) {
          upper = lower;
          lower = undefined2;
        }
        if (upper !== undefined2) {
          upper = toNumber(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined2) {
          lower = toNumber(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber(number), lower, upper);
      }
      function inRange(number, start, end) {
        start = toFinite(start);
        if (end === undefined2) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        number = toNumber(number);
        return baseInRange(number, start, end);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined2;
        }
        if (floating === undefined2) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined2;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined2;
          }
        }
        if (lower === undefined2 && upper === undefined2) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined2) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result2, word, index) {
        word = word.toLowerCase();
        return result2 + (index ? capitalize(word) : word);
      });
      function capitalize(string) {
        return upperFirst(toString(string).toLowerCase());
      }
      function deburr(string) {
        string = toString(string);
        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith(string, target, position) {
        string = toString(string);
        target = baseToString(target);
        var length = string.length;
        position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
        var end = position;
        position -= target.length;
        return position >= 0 && string.slice(position, end) == target;
      }
      function escape2(string) {
        string = toString(string);
        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }
      function escapeRegExp(string) {
        string = toString(string);
        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
      }
      var kebabCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        if (!length || strLength >= length) {
          return string;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
      }
      function padEnd(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
      }
      function padStart(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
      }
      function parseInt2(string, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
      }
      function repeat(string, n, guard) {
        if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        return baseRepeat(toString(string), n);
      }
      function replace() {
        var args2 = arguments, string = toString(args2[0]);
        return args2.length < 3 ? string : string.replace(args2[1], args2[2]);
      }
      var snakeCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "_" : "") + word.toLowerCase();
      });
      function split(string, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
          separator = limit = undefined2;
        }
        limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string = toString(string);
        if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
          separator = baseToString(separator);
          if (!separator && hasUnicode(string)) {
            return castSlice(stringToArray(string), 0, limit);
          }
        }
        return string.split(separator, limit);
      }
      var startCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + upperFirst(word);
      });
      function startsWith(string, target, position) {
        string = toString(string);
        position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
        target = baseToString(target);
        return string.slice(position, position + target.length) == target;
      }
      function template(string, options, guard) {
        var settings = lodash.templateSettings;
        if (guard && isIterateeCall(string, options, guard)) {
          options = undefined2;
        }
        string = toString(string);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp2((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
        var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index = offset + match.length;
          return match;
        });
        source += "';\n";
        var variable = hasOwnProperty.call(options, "variable") && options.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
        });
        result2.source = source;
        if (isError7(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value) {
        return toString(value).toLowerCase();
      }
      function toUpper(value) {
        return toString(value).toUpperCase();
      }
      function trim(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined2)) {
          return baseTrim(string);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join("");
      }
      function trimEnd(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined2)) {
          return string.slice(0, trimmedEndIndex(string) + 1);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      function trimStart(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined2)) {
          return string.replace(reTrimStart, "");
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start).join("");
      }
      function truncate(string, options) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length = "length" in options ? toInteger(options.length) : length;
          omission = "omission" in options ? baseToString(options.omission) : omission;
        }
        string = toString(string);
        var strLength = string.length;
        if (hasUnicode(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string;
        }
        var end = length - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
        if (separator === undefined2) {
          return result2 + omission;
        }
        if (strSymbols) {
          end += result2.length - end;
        }
        if (isRegExp(separator)) {
          if (string.slice(end).search(separator)) {
            var match, substring = result2;
            if (!separator.global) {
              separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match = separator.exec(substring)) {
              var newEnd = match.index;
            }
            result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
          }
        } else if (string.indexOf(baseToString(separator), end) != end) {
          var index = result2.lastIndexOf(separator);
          if (index > -1) {
            result2 = result2.slice(0, index);
          }
        }
        return result2 + omission;
      }
      function unescape2(string) {
        string = toString(string);
        return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }
      var upperCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string, pattern, guard) {
        string = toString(string);
        pattern = guard ? undefined2 : pattern;
        if (pattern === undefined2) {
          return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
        }
        return string.match(pattern) || [];
      }
      var attempt = baseRest(function(func, args2) {
        try {
          return apply(func, undefined2, args2);
        } catch (e) {
          return isError7(e) ? e : new Error2(e);
        }
      });
      var bindAll = flatRest(function(object, methodNames) {
        arrayEach(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue(object, key, bind(object[key], object));
        });
        return object;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args2) {
          var index = -1;
          while (++index < length) {
            var pair = pairs[index];
            if (apply(pair[0], this, args2)) {
              return apply(pair[1], this, args2);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path10, srcValue) {
        return baseMatchesProperty(path10, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path10, args2) {
        return function(object) {
          return baseInvoke(object, path10, args2);
        };
      });
      var methodOf = baseRest(function(object, args2) {
        return function(path10) {
          return baseInvoke(object, path10, args2);
        };
      });
      function mixin(object, source, options) {
        var props = keys(source), methodNames = baseFunctions(source, props);
        if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
          options = source;
          source = object;
          object = this;
          methodNames = baseFunctions(source, keys(source));
        }
        var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
        arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                actions.push({func, args: arguments, thisArg: object});
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }
        });
        return object;
      }
      function noConflict() {
        if (root._ === this) {
          root._ = oldDash;
        }
        return this;
      }
      function noop() {
      }
      function nthArg(n) {
        n = toInteger(n);
        return baseRest(function(args2) {
          return baseNth(args2, n);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path10) {
        return isKey(path10) ? baseProperty(toKey(path10)) : basePropertyDeep(path10);
      }
      function propertyOf(object) {
        return function(path10) {
          return object == null ? undefined2 : baseGet(object, path10);
        };
      }
      var range = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n, iteratee2) {
        n = toInteger(n);
        if (n < 1 || n > MAX_SAFE_INTEGER) {
          return [];
        }
        var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n -= MAX_ARRAY_LENGTH;
        var result2 = baseTimes(length, iteratee2);
        while (++index < n) {
          iteratee2(index);
        }
        return result2;
      }
      function toPath(value) {
        if (isArray(value)) {
          return arrayMap(value, toKey);
        }
        return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
      }
      function uniqueId(prefix) {
        var id = ++idCounter;
        return toString(prefix) + id;
      }
      var add = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max(array) {
        return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
      }
      function maxBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
      }
      function mean(array) {
        return baseMean(array, identity);
      }
      function meanBy(array, iteratee2) {
        return baseMean(array, getIteratee(iteratee2, 2));
      }
      function min(array) {
        return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
      }
      function minBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round = createRound("round");
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array) {
        return array && array.length ? baseSum(array, identity) : 0;
      }
      function sumBy(array, iteratee2) {
        return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
      }
      lodash.after = after;
      lodash.ary = ary;
      lodash.assign = assign;
      lodash.assignIn = assignIn;
      lodash.assignInWith = assignInWith;
      lodash.assignWith = assignWith;
      lodash.at = at;
      lodash.before = before;
      lodash.bind = bind;
      lodash.bindAll = bindAll;
      lodash.bindKey = bindKey;
      lodash.castArray = castArray;
      lodash.chain = chain;
      lodash.chunk = chunk;
      lodash.compact = compact;
      lodash.concat = concat;
      lodash.cond = cond;
      lodash.conforms = conforms;
      lodash.constant = constant;
      lodash.countBy = countBy;
      lodash.create = create;
      lodash.curry = curry;
      lodash.curryRight = curryRight;
      lodash.debounce = debounce;
      lodash.defaults = defaults;
      lodash.defaultsDeep = defaultsDeep;
      lodash.defer = defer;
      lodash.delay = delay;
      lodash.difference = difference;
      lodash.differenceBy = differenceBy;
      lodash.differenceWith = differenceWith;
      lodash.drop = drop;
      lodash.dropRight = dropRight;
      lodash.dropRightWhile = dropRightWhile;
      lodash.dropWhile = dropWhile;
      lodash.fill = fill;
      lodash.filter = filter;
      lodash.flatMap = flatMap;
      lodash.flatMapDeep = flatMapDeep;
      lodash.flatMapDepth = flatMapDepth;
      lodash.flatten = flatten;
      lodash.flattenDeep = flattenDeep;
      lodash.flattenDepth = flattenDepth;
      lodash.flip = flip;
      lodash.flow = flow;
      lodash.flowRight = flowRight;
      lodash.fromPairs = fromPairs;
      lodash.functions = functions;
      lodash.functionsIn = functionsIn;
      lodash.groupBy = groupBy;
      lodash.initial = initial;
      lodash.intersection = intersection;
      lodash.intersectionBy = intersectionBy;
      lodash.intersectionWith = intersectionWith;
      lodash.invert = invert;
      lodash.invertBy = invertBy;
      lodash.invokeMap = invokeMap;
      lodash.iteratee = iteratee;
      lodash.keyBy = keyBy3;
      lodash.keys = keys;
      lodash.keysIn = keysIn;
      lodash.map = map;
      lodash.mapKeys = mapKeys2;
      lodash.mapValues = mapValues;
      lodash.matches = matches;
      lodash.matchesProperty = matchesProperty;
      lodash.memoize = memoize;
      lodash.merge = merge;
      lodash.mergeWith = mergeWith;
      lodash.method = method;
      lodash.methodOf = methodOf;
      lodash.mixin = mixin;
      lodash.negate = negate;
      lodash.nthArg = nthArg;
      lodash.omit = omit;
      lodash.omitBy = omitBy;
      lodash.once = once;
      lodash.orderBy = orderBy;
      lodash.over = over;
      lodash.overArgs = overArgs;
      lodash.overEvery = overEvery;
      lodash.overSome = overSome;
      lodash.partial = partial;
      lodash.partialRight = partialRight;
      lodash.partition = partition;
      lodash.pick = pick3;
      lodash.pickBy = pickBy;
      lodash.property = property;
      lodash.propertyOf = propertyOf;
      lodash.pull = pull;
      lodash.pullAll = pullAll;
      lodash.pullAllBy = pullAllBy;
      lodash.pullAllWith = pullAllWith;
      lodash.pullAt = pullAt;
      lodash.range = range;
      lodash.rangeRight = rangeRight;
      lodash.rearg = rearg;
      lodash.reject = reject;
      lodash.remove = remove;
      lodash.rest = rest;
      lodash.reverse = reverse;
      lodash.sampleSize = sampleSize;
      lodash.set = set;
      lodash.setWith = setWith;
      lodash.shuffle = shuffle;
      lodash.slice = slice;
      lodash.sortBy = sortBy;
      lodash.sortedUniq = sortedUniq;
      lodash.sortedUniqBy = sortedUniqBy;
      lodash.split = split;
      lodash.spread = spread;
      lodash.tail = tail;
      lodash.take = take;
      lodash.takeRight = takeRight;
      lodash.takeRightWhile = takeRightWhile;
      lodash.takeWhile = takeWhile;
      lodash.tap = tap;
      lodash.throttle = throttle;
      lodash.thru = thru;
      lodash.toArray = toArray;
      lodash.toPairs = toPairs;
      lodash.toPairsIn = toPairsIn;
      lodash.toPath = toPath;
      lodash.toPlainObject = toPlainObject;
      lodash.transform = transform;
      lodash.unary = unary;
      lodash.union = union;
      lodash.unionBy = unionBy;
      lodash.unionWith = unionWith;
      lodash.uniq = uniq;
      lodash.uniqBy = uniqBy;
      lodash.uniqWith = uniqWith;
      lodash.unset = unset;
      lodash.unzip = unzip;
      lodash.unzipWith = unzipWith;
      lodash.update = update;
      lodash.updateWith = updateWith;
      lodash.values = values;
      lodash.valuesIn = valuesIn;
      lodash.without = without;
      lodash.words = words;
      lodash.wrap = wrap;
      lodash.xor = xor;
      lodash.xorBy = xorBy;
      lodash.xorWith = xorWith;
      lodash.zip = zip;
      lodash.zipObject = zipObject;
      lodash.zipObjectDeep = zipObjectDeep;
      lodash.zipWith = zipWith;
      lodash.entries = toPairs;
      lodash.entriesIn = toPairsIn;
      lodash.extend = assignIn;
      lodash.extendWith = assignInWith;
      mixin(lodash, lodash);
      lodash.add = add;
      lodash.attempt = attempt;
      lodash.camelCase = camelCase;
      lodash.capitalize = capitalize;
      lodash.ceil = ceil;
      lodash.clamp = clamp;
      lodash.clone = clone;
      lodash.cloneDeep = cloneDeep;
      lodash.cloneDeepWith = cloneDeepWith;
      lodash.cloneWith = cloneWith;
      lodash.conformsTo = conformsTo;
      lodash.deburr = deburr;
      lodash.defaultTo = defaultTo;
      lodash.divide = divide;
      lodash.endsWith = endsWith;
      lodash.eq = eq;
      lodash.escape = escape2;
      lodash.escapeRegExp = escapeRegExp;
      lodash.every = every;
      lodash.find = find;
      lodash.findIndex = findIndex;
      lodash.findKey = findKey;
      lodash.findLast = findLast;
      lodash.findLastIndex = findLastIndex;
      lodash.findLastKey = findLastKey;
      lodash.floor = floor;
      lodash.forEach = forEach;
      lodash.forEachRight = forEachRight;
      lodash.forIn = forIn;
      lodash.forInRight = forInRight;
      lodash.forOwn = forOwn;
      lodash.forOwnRight = forOwnRight;
      lodash.get = get;
      lodash.gt = gt;
      lodash.gte = gte;
      lodash.has = has;
      lodash.hasIn = hasIn;
      lodash.head = head;
      lodash.identity = identity;
      lodash.includes = includes;
      lodash.indexOf = indexOf;
      lodash.inRange = inRange;
      lodash.invoke = invoke;
      lodash.isArguments = isArguments;
      lodash.isArray = isArray;
      lodash.isArrayBuffer = isArrayBuffer;
      lodash.isArrayLike = isArrayLike;
      lodash.isArrayLikeObject = isArrayLikeObject;
      lodash.isBoolean = isBoolean;
      lodash.isBuffer = isBuffer;
      lodash.isDate = isDate;
      lodash.isElement = isElement;
      lodash.isEmpty = isEmpty;
      lodash.isEqual = isEqual;
      lodash.isEqualWith = isEqualWith;
      lodash.isError = isError7;
      lodash.isFinite = isFinite2;
      lodash.isFunction = isFunction;
      lodash.isInteger = isInteger;
      lodash.isLength = isLength;
      lodash.isMap = isMap;
      lodash.isMatch = isMatch;
      lodash.isMatchWith = isMatchWith;
      lodash.isNaN = isNaN2;
      lodash.isNative = isNative;
      lodash.isNil = isNil;
      lodash.isNull = isNull;
      lodash.isNumber = isNumber;
      lodash.isObject = isObject;
      lodash.isObjectLike = isObjectLike;
      lodash.isPlainObject = isPlainObject;
      lodash.isRegExp = isRegExp;
      lodash.isSafeInteger = isSafeInteger;
      lodash.isSet = isSet;
      lodash.isString = isString;
      lodash.isSymbol = isSymbol;
      lodash.isTypedArray = isTypedArray;
      lodash.isUndefined = isUndefined;
      lodash.isWeakMap = isWeakMap;
      lodash.isWeakSet = isWeakSet;
      lodash.join = join2;
      lodash.kebabCase = kebabCase;
      lodash.last = last;
      lodash.lastIndexOf = lastIndexOf;
      lodash.lowerCase = lowerCase;
      lodash.lowerFirst = lowerFirst;
      lodash.lt = lt;
      lodash.lte = lte;
      lodash.max = max;
      lodash.maxBy = maxBy;
      lodash.mean = mean;
      lodash.meanBy = meanBy;
      lodash.min = min;
      lodash.minBy = minBy;
      lodash.stubArray = stubArray;
      lodash.stubFalse = stubFalse;
      lodash.stubObject = stubObject;
      lodash.stubString = stubString;
      lodash.stubTrue = stubTrue;
      lodash.multiply = multiply;
      lodash.nth = nth;
      lodash.noConflict = noConflict;
      lodash.noop = noop;
      lodash.now = now;
      lodash.pad = pad;
      lodash.padEnd = padEnd;
      lodash.padStart = padStart;
      lodash.parseInt = parseInt2;
      lodash.random = random;
      lodash.reduce = reduce;
      lodash.reduceRight = reduceRight;
      lodash.repeat = repeat;
      lodash.replace = replace;
      lodash.result = result;
      lodash.round = round;
      lodash.runInContext = runInContext2;
      lodash.sample = sample;
      lodash.size = size;
      lodash.snakeCase = snakeCase;
      lodash.some = some;
      lodash.sortedIndex = sortedIndex;
      lodash.sortedIndexBy = sortedIndexBy;
      lodash.sortedIndexOf = sortedIndexOf;
      lodash.sortedLastIndex = sortedLastIndex;
      lodash.sortedLastIndexBy = sortedLastIndexBy;
      lodash.sortedLastIndexOf = sortedLastIndexOf;
      lodash.startCase = startCase;
      lodash.startsWith = startsWith;
      lodash.subtract = subtract;
      lodash.sum = sum;
      lodash.sumBy = sumBy;
      lodash.template = template;
      lodash.times = times;
      lodash.toFinite = toFinite;
      lodash.toInteger = toInteger;
      lodash.toLength = toLength;
      lodash.toLower = toLower;
      lodash.toNumber = toNumber;
      lodash.toSafeInteger = toSafeInteger;
      lodash.toString = toString;
      lodash.toUpper = toUpper;
      lodash.trim = trim;
      lodash.trimEnd = trimEnd;
      lodash.trimStart = trimStart;
      lodash.truncate = truncate;
      lodash.unescape = unescape2;
      lodash.uniqueId = uniqueId;
      lodash.upperCase = upperCase;
      lodash.upperFirst = upperFirst;
      lodash.each = forEach;
      lodash.eachRight = forEachRight;
      lodash.first = head;
      mixin(lodash, function() {
        var source = {};
        baseForOwn(lodash, function(func, methodName) {
          if (!hasOwnProperty.call(lodash.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), {chain: false});
      lodash.VERSION = VERSION;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash[methodName].placeholder = lodash;
      });
      arrayEach(["drop", "take"], function(methodName, index) {
        LazyWrapper.prototype[methodName] = function(n) {
          n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
          var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
          } else {
            result2.__views__.push({
              size: nativeMin(n, MAX_ARRAY_LENGTH),
              type: methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n) {
          return this.reverse()[methodName](n).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
        var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            iteratee: getIteratee(iteratee2, 3),
            type
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach(["head", "last"], function(methodName, index) {
        var takeName = "take" + (index ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index) {
        var dropName = "drop" + (index ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path10, args2) {
        if (typeof path10 == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path10, args2);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start, end) {
        start = toInteger(start);
        var result2 = this;
        if (result2.__filtered__ && (start > 0 || end < 0)) {
          return new LazyWrapper(result2);
        }
        if (start < 0) {
          result2 = result2.takeRight(-start);
        } else if (start) {
          result2 = result2.drop(start);
        }
        if (end !== undefined2) {
          end = toInteger(end);
          result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash.prototype[methodName] = function() {
          var value = this.__wrapped__, args2 = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args2[0], useLazy = isLazy || isArray(value);
          var interceptor = function(value2) {
            var result3 = lodashFunc.apply(lodash, arrayPush([value2], args2));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func.apply(value, args2);
            result2.__actions__.push({func: thru, args: [interceptor], thisArg: undefined2});
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args2);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash.prototype[methodName] = function() {
          var args2 = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray(value) ? value : [], args2);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray(value2) ? value2 : [], args2);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({name: methodName, func: lodashFunc});
        }
      });
      realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
        name: "wrapper",
        func: undefined2
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash.prototype.at = wrapperAt;
      lodash.prototype.chain = wrapperChain;
      lodash.prototype.commit = wrapperCommit;
      lodash.prototype.next = wrapperNext;
      lodash.prototype.plant = wrapperPlant;
      lodash.prototype.reverse = wrapperReverse;
      lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
      lodash.prototype.first = lodash.prototype.head;
      if (symIterator) {
        lodash.prototype[symIterator] = wrapperToIterator;
      }
      return lodash;
    };
    var _2 = runInContext();
    if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
      root._ = _2;
      define(function() {
        return _2;
      });
    } else if (freeModule) {
      (freeModule.exports = _2)._ = _2;
      freeExports._ = _2;
    } else {
      root._ = _2;
    }
  }).call(exports2);
});

// ../../node_modules/.pnpm/@prisma+studio-pcw@0.423.0_e71e9f4190c270e7c2163e3230782422/node_modules/@prisma/studio-pcw/dist/client.js
var require_client3 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getPrismaClientTypes = exports2.getPrismaClient = void 0;
  var path10 = require("path");
  var lodash_1 = require_lodash7();
  var debug_12 = require_debug2();
  async function getPrismaClient({schemaPath, dmmf, datasourceProvider, previewFeatures, paths}) {
    const {getPrismaClient: SDKGetPrismaClient, PrismaClientKnownRequestError: PrismaClientKnownRequestError2, PrismaClientRustPanicError: PrismaClientRustPanicError2, PrismaClientInitializationError: PrismaClientInitializationError2, PrismaClientValidationError} = require(`${paths.prismaClient}/runtime`);
    const PrismaClient = SDKGetPrismaClient({
      document: lodash_1.cloneDeep(dmmf),
      generator: {
        name: "studio-client",
        provider: {value: "prisma-client-js", fromEnvVar: null},
        output: null,
        binaryTargets: [],
        previewFeatures,
        config: {}
      },
      clientVersion: "in-memory",
      engineVersion: "in-memory",
      dirname: path10.dirname(schemaPath),
      activeProvider: datasourceProvider,
      datasourceNames: [""],
      relativePath: "",
      relativeEnvPaths: {
        rootEnvPath: "",
        schemaEnvPath: ""
      }
    });
    debug_12.debug("[getPrismaClient]", {
      prismaClientPath: paths.prismaClient,
      queryEngine: paths.queryEngine,
      previewFeatures
    });
    const prisma = new PrismaClient({
      errorFormat: "colorless",
      __internal: {
        engine: {
          binaryPath: paths.queryEngine.path
        }
      }
    });
    return {
      prisma,
      PrismaClient,
      PrismaClientKnownRequestError: PrismaClientKnownRequestError2,
      PrismaClientRustPanicError: PrismaClientRustPanicError2,
      PrismaClientInitializationError: PrismaClientInitializationError2,
      PrismaClientValidationError
    };
  }
  exports2.getPrismaClient = getPrismaClient;
  async function getPrismaClientTypes({generator}) {
    const {fileMap} = await generator.generate();
    return fileMap["index.d.ts"];
  }
  exports2.getPrismaClientTypes = getPrismaClientTypes;
});

// ../../node_modules/.pnpm/@prisma+studio-pcw@0.423.0_e71e9f4190c270e7c2163e3230782422/node_modules/@prisma/studio-pcw/dist/utils/getPlatform.js
var require_getPlatform2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getPlatform = void 0;
  var sdk_1 = require_dist12();
  var platform;
  async function getPlatform3() {
    if (platform) {
      return platform;
    }
    platform = await sdk_1.getPlatform();
    return platform;
  }
  exports2.getPlatform = getPlatform3;
});

// ../../node_modules/.pnpm/@prisma+studio-pcw@0.423.0_e71e9f4190c270e7c2163e3230782422/node_modules/@prisma/studio-pcw/dist/dmmf.js
var require_dmmf2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getDMMF = void 0;
  function getDMMF5({generator, forceBinary, forceLibrary, paths}) {
    var _a, _b;
    const {externalToInternalDmmf} = require(`${paths.prismaClient}/generator-build/index.js`);
    const dmmf = externalToInternalDmmf(generator.options.dmmf);
    const datasourceProvider = (_b = (_a = generator.options.datasources) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.activeProvider;
    if (!datasourceProvider) {
      throw new Error("Could not find a `datasource` declaration in your Prisma Schema. Please declare one, then try again. Read more about the Prisma Schema: https://pris.ly/prisma-schema");
    }
    let previewFeatures = generator.config.previewFeatures || [];
    if (forceLibrary) {
      !previewFeatures.includes("nApi") && previewFeatures.push("nApi");
    } else if (forceBinary) {
      previewFeatures = previewFeatures.filter((p) => p !== "nApi");
    }
    return {
      dmmf,
      datasourceProvider,
      previewFeatures
    };
  }
  exports2.getDMMF = getDMMF5;
});

// ../../node_modules/.pnpm/@prisma+studio-pcw@0.423.0_e71e9f4190c270e7c2163e3230782422/node_modules/@prisma/studio-pcw/dist/utils/prismaEngineName.js
var require_prismaEngineName = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.prismaEngineName = void 0;
  var sdk_1 = require_dist12();
  var getPlatform_1 = require_getPlatform2();
  async function prismaEngineName(engine, type) {
    const platform = await getPlatform_1.getPlatform();
    const extension = platform === "windows" ? ".exe" : "";
    if (type === "library") {
      return sdk_1.getNodeAPIName(platform, "fs");
    } else if (type === "binary") {
      return `${engine}-${platform}${extension}`;
    } else {
      throw new Error(`Unknown engine type: ${type}`);
    }
  }
  exports2.prismaEngineName = prismaEngineName;
});

// ../../node_modules/.pnpm/@prisma+studio-pcw@0.423.0_e71e9f4190c270e7c2163e3230782422/node_modules/@prisma/studio-pcw/dist/paths.js
var require_paths = __commonJS((exports, module) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.guessPrismaClientPath = exports.guessEnginePaths = void 0;
  var path = require("path");
  var prismaEngineName_1 = require_prismaEngineName();
  async function guessEnginePaths({forceBinary, forceLibrary, resolveOverrides}) {
    let queryEngineName;
    let queryEngineType;
    if (forceLibrary) {
      queryEngineName = await prismaEngineName_1.prismaEngineName("query-engine", "library");
      queryEngineType = "library";
    } else if (forceBinary) {
      queryEngineName = await prismaEngineName_1.prismaEngineName("query-engine", "binary");
      queryEngineType = "binary";
    } else {
      queryEngineName = void 0;
      queryEngineType = void 0;
    }
    if (!queryEngineName || !queryEngineType) {
      return {queryEngine: void 0};
    }
    let queryEnginePath;
    if (resolveOverrides["@prisma/engines"]) {
      queryEnginePath = path.resolve(resolveOverrides["@prisma/engines"], `../../${queryEngineName}`);
    } else if (resolveOverrides[".prisma/client"]) {
      queryEnginePath = path.resolve(resolveOverrides[".prisma/client"], `../${queryEngineName}`);
    } else {
      queryEnginePath = path.resolve(eval("require.resolve('@prisma/engines')"), `../../${queryEngineName}`);
    }
    return {
      queryEngine: {type: queryEngineType, path: queryEnginePath}
    };
  }
  exports.guessEnginePaths = guessEnginePaths;
  function guessPrismaClientPath({resolveOverrides}) {
    const prismaClientPath = resolveOverrides["@prisma/client"] || eval("require.resolve('@prisma/client')");
    return path.resolve(prismaClientPath, "../");
  }
  exports.guessPrismaClientPath = guessPrismaClientPath;
});

// ../../node_modules/.pnpm/@prisma+studio-pcw@0.423.0_e71e9f4190c270e7c2163e3230782422/node_modules/@prisma/studio-pcw/dist/pcw.js
var require_pcw = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var crypto_1 = require("crypto");
  var generators_1 = require_generators();
  var client_1 = require_client3();
  var getPlatform_1 = require_getPlatform2();
  var debug_12 = require_debug2();
  var dmmf_1 = require_dmmf2();
  var paths_1 = require_paths();
  var MUTATING_PRISMA_ACTIONS = [
    "create",
    "createMany",
    "delete",
    "deleteMany",
    "executeRaw",
    "queryRaw",
    "update",
    "updateMany",
    "upsert"
  ];
  var PCW = class {
    constructor(schema, schemaPath, env2 = {}, options = {}) {
      var _a, _b, _c;
      this.getDMMF = async () => {
        if (this.dmmf && this.datasourceProvider && this.previewFeatures) {
          return Promise.resolve({
            dmmf: this.dmmf,
            datasourceProvider: this.datasourceProvider,
            previewFeatures: this.previewFeatures
          });
        }
        this.setupProcessEnv();
        try {
          const prismaClientPath = this.resolvePrismaClient();
          const {queryEngine} = await this.resolvePrismaEngines();
          debug_12.debug("[getDMMF] Calling getGenerator with:", {
            queryEngine,
            prismaClientPath
          });
          const prismaClientGenerator = await generators_1.getGenerator({
            schemaPath: this.schemaPath,
            forceBinary: this.forcePrismaBinary,
            forceLibrary: this.forcePrismaLibrary,
            paths: {
              queryEngine,
              prismaClient: prismaClientPath
            }
          });
          if (!this.forcePrismaBinary && !this.forcePrismaLibrary) {
            const platform = await getPlatform_1.getPlatform();
            let resolvedQueryEngineType;
            let resolvedQueryEnginePath;
            if (prismaClientGenerator.options.binaryPaths.queryEngine) {
              resolvedQueryEngineType = "binary";
              resolvedQueryEnginePath = prismaClientGenerator.options.binaryPaths.queryEngine[platform];
            } else if (prismaClientGenerator.options.binaryPaths.libqueryEngine) {
              resolvedQueryEngineType = "library";
              resolvedQueryEnginePath = prismaClientGenerator.options.binaryPaths.libqueryEngine[platform];
            } else {
              throw new Error("Unable to resolve Prisma Query Engine. This is a bug.");
            }
            this.resolvedPrismaEngines = {
              queryEngine: {
                type: resolvedQueryEngineType,
                path: resolvedQueryEnginePath
              }
            };
          }
          const {dmmf, datasourceProvider, previewFeatures} = dmmf_1.getDMMF({
            generator: prismaClientGenerator,
            forceBinary: this.forcePrismaBinary,
            forceLibrary: this.forcePrismaLibrary,
            paths: {
              prismaClient: prismaClientPath
            }
          });
          this.dmmf = dmmf;
          this.datasourceProvider = datasourceProvider;
          this.previewFeatures = previewFeatures;
          prismaClientGenerator.stop();
          debug_12.debug("[getDMMF] finished", {
            prismaClientPath,
            prismaEngines: this.resolvedPrismaEngines,
            previewFeatures
          });
          this.restoreProcessEnv();
        } catch (e) {
          console.error("Unable to get DMMF from Prisma Client: ", e);
          this.restoreProcessEnv();
          throw e;
        }
        return {
          dmmf: this.dmmf,
          datasourceProvider: this.datasourceProvider,
          previewFeatures: this.previewFeatures
        };
      };
      this.request = async (query) => {
        query = query.trim();
        const {prisma, PrismaClientKnownRequestError: PrismaClientKnownRequestError2, PrismaClientRustPanicError: PrismaClientRustPanicError2, PrismaClientInitializationError: PrismaClientInitializationError2, PrismaClientValidationError} = await this.getPrismaClient();
        prisma.$use(async (params, next) => {
          try {
            return await next(params);
          } catch (e) {
            const type = e instanceof PrismaClientKnownRequestError2 ? "PrismaClientKnownRequestError" : e instanceof PrismaClientRustPanicError2 ? "PrismaClientRustPanicError" : e instanceof PrismaClientInitializationError2 ? "PrismaClientInitializationError" : e instanceof PrismaClientValidationError ? "PrismaClientValidationError" : "PrismaClientUnknownRequestError";
            return {
              error: {
                type,
                code: e.code,
                meta: e.meta,
                message: e.message,
                stack: e.stack
              }
            };
          }
        });
        prisma.$use(async (params, next) => {
          const response = await next(params);
          return {
            params,
            response
          };
        });
        if (this.readOnly) {
          prisma.$use(async (params, next) => {
            if (MUTATING_PRISMA_ACTIONS.includes(params.action)) {
              throw new Error("You are not permitted to perform this action");
            }
            return await next(params);
          });
        }
        this.setupProcessEnv();
        try {
          const AsyncFunction = Object.getPrototypeOf(async function() {
          }).constructor;
          const prismaClientResponse = await new AsyncFunction("prisma", `return await ${query}`)(prisma);
          await prisma.$disconnect();
          this.restoreProcessEnv();
          if (Array.isArray(prismaClientResponse)) {
            const {error: firstError} = prismaClientResponse.find((r) => !!r.error) || {};
            if (firstError) {
              throw {
                type: firstError.type,
                code: firstError.code,
                message: firstError.message,
                stack: firstError.stack
              };
            } else {
              return prismaClientResponse;
            }
          }
          const {error, params, response} = prismaClientResponse;
          if (error) {
            throw {
              type: error.type,
              code: error.code,
              message: error.message,
              stack: error.stack
            };
          }
          if (response === void 0 && error === void 0) {
            throw {
              message: "Invalid query",
              stack: null
            };
          }
          return {
            params,
            response
          };
        } catch (e) {
          await prisma.$disconnect();
          this.restoreProcessEnv();
          throw e;
        }
      };
      debug_12.debug("[constructor]", options);
      this.setSchema(schema, schemaPath);
      this.modifiedEnv = Object.assign({}, env2);
      this.resolveOverrides = options.resolve || {};
      this.forcePrismaBinary = (_a = !!options.forcePrismaBinary) !== null && _a !== void 0 ? _a : false;
      this.forcePrismaLibrary = (_b = !!options.forcePrismaLibrary) !== null && _b !== void 0 ? _b : false;
      this.readOnly = (_c = !!options.readOnly) !== null && _c !== void 0 ? _c : false;
      if (this.forcePrismaLibrary && this.forcePrismaBinary) {
        throw new Error("Invalid params: `forcePrismaBinary` and `forcePrismaLibrary` cannot both be truthy");
      }
    }
    async resolvePrismaEngines() {
      if (this.resolvedPrismaEngines) {
        return this.resolvedPrismaEngines;
      }
      const {queryEngine} = await paths_1.guessEnginePaths({
        forceBinary: this.forcePrismaBinary,
        forceLibrary: this.forcePrismaLibrary,
        resolveOverrides: this.resolveOverrides
      });
      this.resolvedPrismaEngines = {
        queryEngine
      };
      return this.resolvedPrismaEngines;
    }
    setupProcessEnv() {
      if (this.forcePrismaLibrary) {
        process.env.PRISMA_FORCE_NAPI = "true";
        process.env.PRISMA_CLIENT_ENGINE_TYPE = "library";
      } else if (this.forcePrismaBinary) {
        process.env.PRISMA_CLIENT_ENGINE_TYPE = "binary";
      }
      this.originalProcessEnv = Object.assign({}, process.env);
      process.env = Object.assign(Object.assign({}, process.env), this.modifiedEnv);
    }
    restoreProcessEnv() {
      process.env = this.originalProcessEnv;
    }
    resolvePrismaClient() {
      return paths_1.guessPrismaClientPath({resolveOverrides: this.resolveOverrides});
    }
    async setSchema(schema, schemaPath) {
      this.schema = schema;
      this.schemaPath = schemaPath;
      this.schemaHash = crypto_1.createHash("md5").update(this.schema).digest("hex");
    }
    async getPrismaClientTypes() {
      const prismaClientPath = this.resolvePrismaClient();
      const {queryEngine} = await this.resolvePrismaEngines();
      const generator = await generators_1.getGenerator({
        schemaPath: this.schemaPath,
        forceBinary: this.forcePrismaBinary,
        forceLibrary: this.forcePrismaLibrary,
        paths: {
          queryEngine,
          prismaClient: prismaClientPath
        }
      });
      return client_1.getPrismaClientTypes({generator});
    }
    async getPrismaClient() {
      this.setupProcessEnv();
      const {dmmf, datasourceProvider, previewFeatures} = await this.getDMMF();
      const {queryEngine} = await this.resolvePrismaEngines();
      const prismaClientPath = this.resolvePrismaClient();
      const {prisma, PrismaClient, PrismaClientKnownRequestError: PrismaClientKnownRequestError2, PrismaClientRustPanicError: PrismaClientRustPanicError2, PrismaClientInitializationError: PrismaClientInitializationError2, PrismaClientValidationError} = await client_1.getPrismaClient({
        schemaPath: this.schemaPath,
        dmmf,
        datasourceProvider,
        previewFeatures,
        paths: {
          queryEngine,
          prismaClient: prismaClientPath
        }
      });
      this.restoreProcessEnv();
      return {
        prisma,
        meta: {
          engines: {queryEngine},
          prismaClient: {path: prismaClientPath}
        },
        PrismaClient,
        PrismaClientKnownRequestError: PrismaClientKnownRequestError2,
        PrismaClientRustPanicError: PrismaClientRustPanicError2,
        PrismaClientInitializationError: PrismaClientInitializationError2,
        PrismaClientValidationError
      };
    }
  };
  exports2.default = PCW;
});

// ../../node_modules/.pnpm/@prisma+studio-pcw@0.423.0_e71e9f4190c270e7c2163e3230782422/node_modules/@prisma/studio-pcw/dist/utils/loadEnvironment.js
var require_loadEnvironment = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.loadEnvironment = void 0;
  var path10 = require("path");
  var sdk_1 = require_dist12();
  function loadEnvironment(schemaPath) {
    sdk_1.tryLoadEnvs(sdk_1.getEnvPaths(schemaPath, {
      cwd: path10.resolve(schemaPath, "../")
    }), {conflictCheck: "error"});
  }
  exports2.loadEnvironment = loadEnvironment;
});

// ../../node_modules/.pnpm/@prisma+studio-pcw@0.423.0_e71e9f4190c270e7c2163e3230782422/node_modules/@prisma/studio-pcw/dist/utils/parseDatasourceUrl.js
var require_parseDatasourceUrl = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.parseDatasourceUrl = void 0;
  function parseDatasourceUrl(schema) {
    const matches = schema.match(/^(?!(\s+\/\/\s+))\s+url\s+\=\s+(?<usesEnv>env\()?\"(?<url>.*)\"/im);
    const {usesEnv, url} = matches.groups;
    if (usesEnv) {
      return {
        env: url
      };
    }
    return {url};
  }
  exports2.parseDatasourceUrl = parseDatasourceUrl;
});

// ../../node_modules/.pnpm/@prisma+studio-pcw@0.423.0_e71e9f4190c270e7c2163e3230782422/node_modules/@prisma/studio-pcw/dist/index.js
var require_dist23 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.parseDatasourceUrl = exports2.loadEnvironment = exports2.PCW = void 0;
  var pcw_1 = require_pcw();
  Object.defineProperty(exports2, "PCW", {enumerable: true, get: function() {
    return pcw_1.default;
  }});
  var loadEnvironment_1 = require_loadEnvironment();
  Object.defineProperty(exports2, "loadEnvironment", {enumerable: true, get: function() {
    return loadEnvironment_1.loadEnvironment;
  }});
  var parseDatasourceUrl_1 = require_parseDatasourceUrl();
  Object.defineProperty(exports2, "parseDatasourceUrl", {enumerable: true, get: function() {
    return parseDatasourceUrl_1.parseDatasourceUrl;
  }});
});

// ../../node_modules/.pnpm/@prisma+studio-server@0.423.0_@prisma+client@2.30.2/node_modules/@prisma/studio-server/dist/services/PrismaService.js
var require_PrismaService = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var fs_12 = require("fs");
  var studio_pcw_1 = require_dist23();
  var PrismaService = class {
    constructor() {
      this.init = async (options) => {
        this.options = options;
        this.schema = fs_12.readFileSync(options.schemaPath, "utf-8");
        studio_pcw_1.loadEnvironment(this.options.schemaPath);
        this.pcw = new studio_pcw_1.PCW(this.schema, options.schemaPath, {}, Object.assign({}, options.prismaClient));
      };
      this.respond = async (action, {data}) => {
        const responsePayload = {
          error: null,
          data: null
        };
        try {
          switch (action) {
            case "getDMMF":
              const {dmmf, datasourceProvider} = await this.pcw.getDMMF();
              responsePayload.data = {
                dmmf,
                datasourceProvider,
                schemaHash: this.pcw.schemaHash
              };
              break;
            case "clientRequest":
              if (data.schemaHash !== this.pcw.schemaHash) {
                responsePayload.error = {
                  type: "PrismaClientSchemaDriftedError",
                  code: "P500",
                  message: "The underlying schema has changed. Please reload Studio.",
                  stack: ""
                };
              } else {
                responsePayload.data = await this.pcw.request(data.query);
              }
              break;
          }
        } catch (e) {
          responsePayload.error = Object.getOwnPropertyNames(e).reduce((acc, key) => {
            acc[key] = e[key];
            return acc;
          }, {});
        }
        return responsePayload;
      };
    }
  };
  exports2.default = new PrismaService();
});

// ../../node_modules/.pnpm/@prisma+studio-server@0.423.0_@prisma+client@2.30.2/node_modules/@prisma/studio-server/dist/utils/getProjectHash.js
var require_getProjectHash = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var crypto_1 = require("crypto");
  var getProjectHash4 = (schemaPath) => {
    return crypto_1.createHash("sha256").update(schemaPath).digest("hex").substring(0, 8);
  };
  exports2.default = getProjectHash4;
});

// ../../node_modules/.pnpm/@prisma+studio-server@0.423.0_@prisma+client@2.30.2/node_modules/@prisma/studio-server/dist/utils/isDevelopment.js
var require_isDevelopment = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var isDevelopment = process.env.STUDIO_DEVELOPMENT === "true";
  exports2.default = isDevelopment;
});

// ../../node_modules/.pnpm/@prisma+studio-server@0.423.0_@prisma+client@2.30.2/node_modules/@prisma/studio-server/dist/services/TelemetryService.js
var require_TelemetryService = __commonJS((exports2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  var checkpoint_client_1 = require_dist11();
  var getProjectHash_1 = __importDefault2(require_getProjectHash());
  var isDevelopment_1 = __importDefault2(require_isDevelopment());
  var TelemetryService = class {
    constructor() {
      this.respond = async (action, payload) => {
        const responsePayload = {
          error: null,
          data: null
        };
        try {
          switch (action) {
            case "send":
              await this.send(payload.data);
              break;
          }
        } catch (e) {
          responsePayload.error = e;
        }
        return responsePayload;
      };
      this.send = async ({command, commandDetails, commandContext}) => {
        if (isDevelopment_1.default) {
          return;
        }
        if (!this.options.telemetry) {
          return;
        }
        checkpoint_client_1.check({
          product: "prisma-studio",
          command,
          version: this.options.versions.prisma2,
          project_hash: getProjectHash_1.default(this.options.schemaPath)
        });
      };
    }
    async init(options) {
      var _a;
      this.options = {
        schemaPath: options.schemaPath,
        telemetry: (_a = options.telemetry) !== null && _a !== void 0 ? _a : true,
        versions: options.versions
      };
      await checkpoint_client_1.getSignature();
      this.send({
        command: "studio_launch",
        commandDetails: {},
        commandContext: "{}"
      });
    }
  };
  exports2.default = new TelemetryService();
});

// ../../node_modules/.pnpm/@prisma+studio-server@0.423.0_@prisma+client@2.30.2/node_modules/@prisma/studio-server/dist/utils/debug.js
var require_debug3 = __commonJS((exports2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  var debug_12 = __importDefault2(require_src6());
  var debug3 = debug_12.default("prisma:studio-server");
  exports2.default = debug3;
});

// ../../node_modules/.pnpm/@prisma+studio-server@0.423.0_@prisma+client@2.30.2/node_modules/@prisma/studio-server/dist/services/ExpressService.js
var require_ExpressService = __commonJS((exports2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  var path_12 = __importDefault2(require("path"));
  var http_1 = __importDefault2(require("http"));
  var express_1 = __importDefault2(require_express3());
  var cors_1 = __importDefault2(require_lib10());
  var node_1 = require_node8();
  var ProjectService_1 = __importDefault2(require_ProjectService());
  var PrismaService_1 = __importDefault2(require_PrismaService());
  var TelemetryService_1 = __importDefault2(require_TelemetryService());
  var debug_12 = __importDefault2(require_debug3());
  var isDevelopment_1 = __importDefault2(require_isDevelopment());
  var ExpressService = class {
    constructor() {
      this.init = (options) => {
        return new Promise(async (resolve, _reject) => {
          const app = express_1.default();
          app.use(express_1.default.json());
          app.use(cors_1.default({origin: "http://localhost:3001"}));
          if (!isDevelopment_1.default) {
            app.use(function(req, _res, next) {
              if (req.url === "/") {
                req.url = `/pages/databrowser.html`;
              }
              next();
            });
            const staticAssetDir = options.staticAssetDir || path_12.default.resolve(__dirname, "../../public");
            app.use(express_1.default.static(staticAssetDir, {
              etag: false,
              setHeaders: (res) => {
                res.set("Cache-Control", "no-cache");
                res.set("Last-Modified", new Date().toUTCString());
              }
            }));
          }
          app.post("/api", async (req, res) => {
            debug_12.default("Incoming request: ", req.body);
            const {requestId, channel: channel2, action, payload} = req.body;
            let responsePayload;
            switch (channel2) {
              case "project":
                responsePayload = await ProjectService_1.default.respond(action, payload);
                break;
              case "prisma":
                responsePayload = await PrismaService_1.default.respond(action, payload);
                break;
              case "telemetry":
                responsePayload = await TelemetryService_1.default.respond(action, payload);
                break;
              default:
                console.error("Unimplemented `channel`, ignoring request:", req.body);
                break;
            }
            const transport = new node_1.HTTPNodeTransport();
            const response = {
              requestId,
              channel: `-${channel2}`,
              action,
              payload: responsePayload
            };
            const serializedResponse = await transport.respond(res, response);
            debug_12.default("Outgoing response: ", serializedResponse);
          });
          this.server = http_1.default.createServer(app);
          const hostname = options.hostname || "::";
          this.server.listen(options.port, hostname, () => {
            resolve();
            debug_12.default(`Studio server is up at http://localhost:${options.port}/`);
          });
        });
      };
      this.destroy = async () => {
        return new Promise((resolve) => {
          if (this.server) {
            this.server.close((err) => {
              if (err) {
                debug_12.default("Unable to close server: ", err);
              } else {
                debug_12.default("Closed out remaining connections");
              }
              return resolve();
            });
          } else {
            return resolve();
          }
        });
      };
    }
  };
  exports2.default = new ExpressService();
});

// ../../node_modules/.pnpm/@prisma+studio-server@0.423.0_@prisma+client@2.30.2/node_modules/@prisma/studio-server/dist/StudioServer.js
var require_StudioServer = __commonJS((exports2) => {
  "use strict";
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, {enumerable: true, get: function() {
      return m2[k];
    }});
  } : function(o, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m2[k];
  });
  var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {enumerable: true, value: v});
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.StudioServer = void 0;
  var Sentry = __importStar(require_dist22());
  var untildify_1 = __importDefault2(require_untildify());
  var ProjectService_1 = __importDefault2(require_ProjectService());
  var ExpressService_1 = __importDefault2(require_ExpressService());
  var PrismaService_1 = __importDefault2(require_PrismaService());
  var TelemetryService_1 = __importDefault2(require_TelemetryService());
  var debug_12 = __importDefault2(require_debug3());
  var isDevelopment_1 = __importDefault2(require_isDevelopment());
  if (!isDevelopment_1.default) {
    Sentry.init({
      dsn: "https://77e775402e30484c845a8c26b660a9ad@sentry.io/1762789"
    });
  }
  var StudioServer2 = class {
    constructor(options) {
      this.start = async () => {
        try {
          await PrismaService_1.default.init({
            schemaPath: this.options.schemaPath,
            prismaClient: this.options.prismaClient
          });
          await TelemetryService_1.default.init({
            telemetry: this.options.telemetry,
            versions: this.options.versions,
            schemaPath: this.options.schemaPath
          });
          await ExpressService_1.default.init({
            port: this.options.port,
            hostname: this.options.hostname,
            staticAssetDir: this.options.staticAssetDir
          });
        } catch (e) {
          console.log("An error occured while starting Studio:\n\n", e);
          process.exit(1);
        }
      };
      this.stop = async (reason) => {
        try {
          debug_12.default("Stopping Studio server. Reason:", reason);
          await ExpressService_1.default.destroy();
        } catch (e) {
          Sentry.captureException(e);
        }
      };
      this.options = options;
      this.options.schemaPath = untildify_1.default(this.options.schemaPath);
      debug_12.default("Starting Studio server");
      ProjectService_1.default.init({
        name: "Prisma Studio",
        schemaPath: this.options.schemaPath
      });
    }
  };
  exports2.StudioServer = StudioServer2;
});

// ../../node_modules/.pnpm/@prisma+studio-server@0.423.0_@prisma+client@2.30.2/node_modules/@prisma/studio-server/dist/index.js
var require_dist24 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.StudioServer = void 0;
  var StudioServer_1 = require_StudioServer();
  Object.defineProperty(exports2, "StudioServer", {enumerable: true, get: function() {
    return StudioServer_1.StudioServer;
  }});
  exports2.default = StudioServer_1.StudioServer;
});

// ../../node_modules/.pnpm/get-port@5.1.1/node_modules/get-port/index.js
var require_get_port = __commonJS((exports2, module2) => {
  "use strict";
  var net = require("net");
  var Locked = class extends Error {
    constructor(port) {
      super(`${port} is locked`);
    }
  };
  var lockedPorts = {
    old: new Set(),
    young: new Set()
  };
  var releaseOldLockedPortsIntervalMs = 1e3 * 15;
  var interval;
  var getAvailablePort = (options) => new Promise((resolve, reject) => {
    const server = net.createServer();
    server.unref();
    server.on("error", reject);
    server.listen(options, () => {
      const {port} = server.address();
      server.close(() => {
        resolve(port);
      });
    });
  });
  var portCheckSequence = function* (ports) {
    if (ports) {
      yield* ports;
    }
    yield 0;
  };
  module2.exports = async (options) => {
    let ports;
    if (options) {
      ports = typeof options.port === "number" ? [options.port] : options.port;
    }
    if (interval === void 0) {
      interval = setInterval(() => {
        lockedPorts.old = lockedPorts.young;
        lockedPorts.young = new Set();
      }, releaseOldLockedPortsIntervalMs);
      if (interval.unref) {
        interval.unref();
      }
    }
    for (const port of portCheckSequence(ports)) {
      try {
        let availablePort = await getAvailablePort({...options, port});
        while (lockedPorts.old.has(availablePort) || lockedPorts.young.has(availablePort)) {
          if (port !== 0) {
            throw new Locked(port);
          }
          availablePort = await getAvailablePort({...options, port});
        }
        lockedPorts.young.add(availablePort);
        return availablePort;
      } catch (error) {
        if (!["EADDRINUSE", "EACCES"].includes(error.code) && !(error instanceof Locked)) {
          throw error;
        }
      }
    }
    throw new Error("No available ports found");
  };
  module2.exports.makeRange = (from, to) => {
    if (!Number.isInteger(from) || !Number.isInteger(to)) {
      throw new TypeError("`from` and `to` must be integer numbers");
    }
    if (from < 1024 || from > 65535) {
      throw new RangeError("`from` must be between 1024 and 65535");
    }
    if (to < 1024 || to > 65536) {
      throw new RangeError("`to` must be between 1024 and 65536");
    }
    if (to < from) {
      throw new RangeError("`to` must be greater than or equal to `from`");
    }
    const generator = function* (from2, to2) {
      for (let port = from2; port <= to2; port++) {
        yield port;
      }
    };
    return generator(from, to);
  };
});

// src/bin.ts
var import_sdk15 = __toModule2(require_dist12());
var import_chalk13 = __toModule2(require_source());
var import_debug2 = __toModule2(require_dist13());
var checkpoint2 = __toModule2(require_dist11());
var import_sdk16 = __toModule2(require_dist12());
var import_migrate = __toModule2(require_dist15());

// src/CLI.ts
var import_chalk3 = __toModule2(require_source());
var import_sdk4 = __toModule2(require_dist12());

// src/Version.ts
var import_engines2 = __toModule2(require("@prisma/engines"));
var import_get_platform2 = __toModule2(require_dist4());
var import_sdk3 = __toModule2(require_dist12());
var import_chalk2 = __toModule2(require_source());
var import_fs3 = __toModule2(require("fs"));
var import_path2 = __toModule2(require("path"));

// src/utils/getClientVersion.ts
var import_fs2 = __toModule2(require("fs"));
var import_module = __toModule2(require("module"));
var import_pkg_up = __toModule2(require_pkg_up());
var import_util3 = __toModule2(require("util"));
var readFileAsync = import_util3.promisify(import_fs2.default.readFile);
async function getInstalledPrismaClientVersion(cwd = process.cwd()) {
  var _a;
  return (_a = await getPrismaClientVersionFromNodeModules(cwd)) != null ? _a : await getPrismaClientVersionFromLocalPackageJson(cwd);
}
async function getPrismaClientVersionFromNodeModules(cwd = process.cwd()) {
  try {
    const pkgJsonPath = requireResolveFrom("@prisma/client/package.json", cwd);
    if (!pkgJsonPath) {
      return null;
    }
    const pkgJsonString = await readFileAsync(pkgJsonPath, "utf-8");
    const pkgJson = JSON.parse(pkgJsonString);
    if (!pkgJson.version) {
      return null;
    }
    return pkgJson.version;
  } catch (e) {
    return null;
  }
}
async function getPrismaClientVersionFromLocalPackageJson(cwd = process.cwd()) {
  var _a, _b, _c;
  try {
    const pkgJsonPath = await import_pkg_up.default({cwd});
    if (!pkgJsonPath) {
      return null;
    }
    const pkgJsonString = await readFileAsync(pkgJsonPath, "utf-8");
    const pkgJson = JSON.parse(pkgJsonString);
    const clientVersion = (_c = (_a = pkgJson.dependencies) == null ? void 0 : _a["@prisma/client"]) != null ? _c : (_b = pkgJson.devDependencies) == null ? void 0 : _b["@prisma/client"];
    if (!clientVersion) {
      return null;
    }
    return clientVersion;
  } catch (e) {
    return null;
  }
}
function requireResolveFrom(moduleId, fromDir) {
  try {
    const resolvedPath = require.resolve(moduleId, {
      paths: import_module.default._nodeModulePaths(fromDir)
    });
    return resolvedPath;
  } catch (e) {
    return null;
  }
}

// src/Version.ts
var packageJson2 = require_package2();
var _Version = class {
  static new() {
    return new _Version();
  }
  async parse(argv) {
    const args2 = import_sdk3.arg(argv, {
      "--help": Boolean,
      "-h": "--help",
      "--version": Boolean,
      "-v": "--version",
      "--json": Boolean,
      "--telemetry-information": String
    });
    if (import_sdk3.isError(args2)) {
      return this.help(args2.message);
    }
    if (args2["--help"]) {
      return this.help();
    }
    const platform = await import_get_platform2.getPlatform();
    const cliQueryEngineBinaryType = import_engines2.getCliQueryEngineBinaryType();
    const introspectionEngine = await this.resolveEngine(import_sdk3.BinaryType.introspectionEngine);
    const migrationEngine = await this.resolveEngine(import_sdk3.BinaryType.migrationEngine);
    const queryEngine = await this.resolveEngine(cliQueryEngineBinaryType);
    const fmtBinary = await this.resolveEngine(import_sdk3.BinaryType.prismaFmt);
    const prismaClientVersion = await getInstalledPrismaClientVersion();
    const rows = [
      [packageJson2.name, packageJson2.version],
      ["@prisma/client", prismaClientVersion != null ? prismaClientVersion : "Not found"],
      ["Current platform", platform],
      [
        `Query Engine${cliQueryEngineBinaryType === import_sdk3.BinaryType.libqueryEngine ? " (Node-API)" : " (Binary)"}`,
        this.printBinaryInfo(queryEngine)
      ],
      ["Migration Engine", this.printBinaryInfo(migrationEngine)],
      ["Introspection Engine", this.printBinaryInfo(introspectionEngine)],
      ["Format Binary", this.printBinaryInfo(fmtBinary)],
      [
        "Default Engines Hash",
        packageJson2.dependencies["@prisma/engines"].split(".").pop()
      ],
      ["Studio", packageJson2.devDependencies["@prisma/studio-server"]]
    ];
    const schemaPath = await import_sdk3.getSchemaPath();
    const featureFlags = await this.getFeatureFlags(schemaPath);
    if (featureFlags && featureFlags.length > 0) {
      rows.push(["Preview Features", featureFlags.join(", ")]);
    }
    return this.printTable(rows, args2["--json"]);
  }
  async getFeatureFlags(schemaPath) {
    if (!schemaPath) {
      return [];
    }
    try {
      const datamodel = await import_sdk3.getSchema();
      const config = await import_sdk3.getConfig({
        datamodel
      });
      const generator = config.generators.find((g) => g.previewFeatures.length > 0);
      if (generator) {
        return generator.previewFeatures;
      }
    } catch (e) {
    }
    return [];
  }
  printBinaryInfo({
    path: absolutePath,
    version,
    fromEnvVar
  }) {
    const resolved = fromEnvVar ? `, resolved by ${fromEnvVar}` : "";
    return `${version} (at ${import_path2.default.relative(process.cwd(), absolutePath)}${resolved})`;
  }
  async resolveEngine(binaryName) {
    const envVar = import_sdk3.engineEnvVarMap[binaryName];
    const pathFromEnv = process.env[envVar];
    if (pathFromEnv && import_fs3.default.existsSync(pathFromEnv)) {
      const version2 = await import_sdk3.getVersion(pathFromEnv, binaryName);
      return {version: version2, path: pathFromEnv, fromEnvVar: envVar};
    }
    const binaryPath = await import_sdk3.resolveBinary(binaryName);
    const version = await import_sdk3.getVersion(binaryPath, binaryName);
    return {path: binaryPath, version};
  }
  printTable(rows, json = false) {
    if (json) {
      const result = rows.reduce((acc, [name, value]) => {
        acc[slugify(name)] = value;
        return acc;
      }, {});
      return JSON.stringify(result, null, 2);
    }
    const maxPad = rows.reduce((acc, curr) => Math.max(acc, curr[0].length), 0);
    return rows.map(([left, right]) => `${left.padEnd(maxPad)} : ${right}`).join("\n");
  }
  help(error) {
    if (error) {
      return new import_sdk3.HelpError(`
${import_chalk2.default.bold.red(`!`)} ${error}
${_Version.help}`);
    }
    return _Version.help;
  }
};
var Version = _Version;
Version.help = import_sdk3.format(`
  Print current version of Prisma components

  ${import_chalk2.default.bold("Usage")}

    ${import_chalk2.default.dim("$")} prisma -v [options]
    ${import_chalk2.default.dim("$")} prisma version [options]

  ${import_chalk2.default.bold("Options")}

    -h, --help     Display this help message
        --json     Output JSON
`);
function slugify(str) {
  return str.toString().toLowerCase().replace(/\s+/g, "-");
}

// src/CLI.ts
var import_sdk5 = __toModule2(require_dist12());
var import_engines3 = __toModule2(require("@prisma/engines"));
var _CLI = class {
  constructor(cmds, ensureBinaries) {
    this.cmds = cmds;
    this.ensureBinaries = ensureBinaries;
  }
  static new(cmds, ensureBinaries) {
    return new _CLI(cmds, ensureBinaries);
  }
  async parse(argv) {
    const args2 = import_sdk4.arg(argv, {
      "--help": Boolean,
      "-h": "--help",
      "--version": Boolean,
      "-v": "--version",
      "--json": Boolean,
      "--experimental": Boolean,
      "--preview-feature": Boolean,
      "--early-access-feature": Boolean,
      "--telemetry-information": String
    });
    if (import_sdk4.isError(args2)) {
      return this.help(args2.message);
    }
    if (args2["--version"]) {
      await import_engines3.ensureBinariesExist();
      return Version.new().parse(argv);
    }
    if (args2._.length === 0 || args2["--help"]) {
      return this.help();
    }
    const cmdName = args2._[0];
    if (cmdName === "lift") {
      throw new Error(`${import_chalk3.default.red("prisma lift")} has been renamed to ${import_chalk3.default.green("prisma migrate")}`);
    } else if (cmdName === "introspect") {
      import_sdk4.logger.warn("");
      import_sdk4.logger.warn(`${import_chalk3.default.bold(`The ${import_chalk3.default.underline("prisma introspect")} command is deprecated. Please use ${import_chalk3.default.green("prisma db pull")} instead.`)}`);
      import_sdk4.logger.warn("");
    }
    const cmd = this.cmds[cmdName];
    if (cmd) {
      if (this.ensureBinaries.includes(cmdName)) {
        await import_engines3.ensureBinariesExist();
      }
      let argsForCmd;
      if (args2["--experimental"]) {
        argsForCmd = [
          ...args2._.slice(1),
          `--experimental=${args2["--experimental"]}`
        ];
      } else if (args2["--preview-feature"]) {
        argsForCmd = argsForCmd = [
          ...args2._.slice(1),
          `--preview-feature=${args2["--preview-feature"]}`
        ];
      } else if (args2["--early-access-feature"]) {
        argsForCmd = argsForCmd = [
          ...args2._.slice(1),
          `--early-access-feature=${args2["--early-access-feature"]}`
        ];
      } else {
        argsForCmd = args2._.slice(1);
      }
      return cmd.parse(argsForCmd);
    }
    return import_sdk4.unknownCommand(this.help(), args2._[0]);
  }
  help(error) {
    if (error) {
      return new import_sdk4.HelpError(`
${import_chalk3.default.bold.red(`!`)} ${error}
${_CLI.help}`);
    }
    return _CLI.help;
  }
};
var CLI = _CLI;
CLI.help = import_sdk4.format(`
    ${process.platform === "win32" ? "" : import_chalk3.default.bold.green("\u25ED  ")}Prisma is a modern DB toolkit to query, migrate and model your database (${import_sdk5.link("https://prisma.io")})

    ${import_chalk3.default.bold("Usage")}

      ${import_chalk3.default.dim("$")} prisma [command]

    ${import_chalk3.default.bold("Commands")}

                init   Setup Prisma for your app
            generate   Generate artifacts (e.g. Prisma Client)
                  db   Manage your database schema and lifecycle
             migrate   Migrate your database
              studio   Browse your data with Prisma Studio
              format   Format your schema

    ${import_chalk3.default.bold("Flags")}

         --preview-feature   Run Preview Prisma commands

    ${import_chalk3.default.bold("Examples")}

      Setup a new Prisma project
      ${import_chalk3.default.dim("$")} prisma init

      Generate artifacts (e.g. Prisma Client)
      ${import_chalk3.default.dim("$")} prisma generate

      Browse your data
      ${import_chalk3.default.dim("$")} prisma studio

      Create migrations from your Prisma schema, apply them to the database, generate artifacts (e.g. Prisma Client)
      ${import_chalk3.default.dim("$")} prisma migrate dev
  
      Pull the schema from an existing database, updating the Prisma schema
      ${import_chalk3.default.dim("$")} prisma db pull

      Push the Prisma schema state to the database
      ${import_chalk3.default.dim("$")} prisma db push
  `);

// src/Init.ts
var import_sdk6 = __toModule2(require_dist12());
var import_convertCredentials = __toModule2(require_convertCredentials());
var import_chalk5 = __toModule2(require_source());
var import_dotenv = __toModule2(require_main2());
var import_fs4 = __toModule2(require("fs"));
var import_path3 = __toModule2(require("path"));
var import_util4 = __toModule2(require("util"));

// src/utils/prompt/utils/print.ts
var import_chalk4 = __toModule2(require_source());
function printError(text) {
  return import_chalk4.default.bold.bgRed(" ERROR ") + " " + import_chalk4.default.red(text);
}

// src/Init.ts
var defaultSchema2 = (provider = "postgresql") => {
  if (provider === "sqlserver" || provider === "mongodb") {
    return `// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

datasource db {
  provider = "${provider}"
  url      = env("DATABASE_URL")
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["${provider === "sqlserver" ? "microsoftSqlServer" : "mongoDb"}"]
}
`;
  } else {
    return `// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

datasource db {
  provider = "${provider}"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}
`;
  }
};
var defaultEnv = (url = "postgresql://johndoe:randompassword@localhost:5432/mydb?schema=public", comments = true) => {
  let env2 = comments ? `# Environment variables declared in this file are automatically made available to Prisma.
# See the documentation for more detail: https://pris.ly/d/prisma-schema#using-environment-variables

# Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server (Preview) and MongoDB (Preview).
# See the documentation for all the connection string options: https://pris.ly/d/connection-strings

` : "";
  env2 += `DATABASE_URL="${url}"`;
  return env2;
};
var defaultPort = (provider) => {
  switch (provider) {
    case "mysql":
      return 3306;
    case "sqlserver":
      return 1433;
    case "mongodb":
      return 27017;
    case "postgresql":
      return 5432;
  }
  return void 0;
};
var defaultURL = (provider, port = defaultPort(provider), schema = "public") => {
  switch (provider) {
    case "postgresql":
      return `postgresql://johndoe:randompassword@localhost:${port}/mydb?schema=${schema}`;
    case "mysql":
      return `mysql://johndoe:randompassword@localhost:${port}/mydb`;
    case "sqlserver":
      return `sqlserver://localhost:${port};database=mydb;user=SA;password=randompassword;`;
    case "mongodb":
      return `mongodb+srv://root:randompassword@cluster0.ab1cd.mongodb.net/mydb?retryWrites=true&w=majority`;
    case "sqlite":
      return "file:./dev.db";
  }
};
var defaultGitIgnore = () => {
  return `node_modules
# Keep environment variables out of version control
.env
`;
};
var _Init = class {
  static new() {
    return new _Init();
  }
  async parse(argv) {
    const args2 = import_sdk6.arg(argv, {
      "--help": Boolean,
      "-h": "--help",
      "--url": String,
      "--datasource-provider": String
    });
    if (import_util4.isError(args2) || args2["--help"]) {
      return this.help();
    }
    const outputDirName = args2._[0];
    if (outputDirName) {
      throw Error("The init command does not take any argument.");
    }
    const outputDir = process.cwd();
    const prismaFolder = import_path3.default.join(outputDir, "prisma");
    if (import_fs4.default.existsSync(import_path3.default.join(outputDir, "schema.prisma"))) {
      console.log(printError(`File ${import_chalk5.default.bold("schema.prisma")} already exists in your project.
        Please try again in a project that is not yet using Prisma.
      `));
      process.exit(1);
    }
    if (import_fs4.default.existsSync(prismaFolder)) {
      console.log(printError(`A folder called ${import_chalk5.default.bold("prisma")} already exists in your project.
        Please try again in a project that is not yet using Prisma.
      `));
      process.exit(1);
    }
    if (import_fs4.default.existsSync(import_path3.default.join(prismaFolder, "schema.prisma"))) {
      console.log(printError(`File ${import_chalk5.default.bold("prisma/schema.prisma")} already exists in your project.
        Please try again in a project that is not yet using Prisma.
      `));
      process.exit(1);
    }
    let provider;
    let url;
    if (args2["--url"]) {
      const canConnect = await import_sdk6.canConnectToDatabase(args2["--url"]);
      if (canConnect !== true) {
        const {code, message} = canConnect;
        if (code !== "P1003") {
          if (code) {
            throw new Error(`${code}: ${message}`);
          } else {
            throw new Error(message);
          }
        }
      }
      provider = import_convertCredentials.protocolToConnectorType(`${args2["--url"].split(":")[0]}:`);
      url = args2["--url"];
    } else if (args2["--datasource-provider"]) {
      const providerLowercase = args2["--datasource-provider"].toLowerCase();
      if (!["postgresql", "mysql", "sqlserver", "sqlite", "mongodb"].includes(providerLowercase)) {
        throw new Error(`Provider "${args2["--datasource-provider"]}" is invalid or not supported. Try again with "postgresql", "mysql", "sqlite", "sqlserver" or "mongodb".`);
      }
      provider = providerLowercase;
      url = defaultURL(provider);
    } else {
      provider = "postgresql";
    }
    if (!import_fs4.default.existsSync(outputDir)) {
      import_fs4.default.mkdirSync(outputDir);
    }
    if (!import_fs4.default.existsSync(prismaFolder)) {
      import_fs4.default.mkdirSync(prismaFolder);
    }
    import_fs4.default.writeFileSync(import_path3.default.join(prismaFolder, "schema.prisma"), defaultSchema2(provider));
    let warning;
    const envPath = import_path3.default.join(outputDir, ".env");
    if (!import_fs4.default.existsSync(envPath)) {
      import_fs4.default.writeFileSync(envPath, defaultEnv(url));
    } else {
      const envFile = import_fs4.default.readFileSync(envPath, {encoding: "utf8"});
      const config = import_dotenv.default.parse(envFile);
      if (Object.keys(config).includes("DATABASE_URL")) {
        warning = `${import_chalk5.default.yellow("warn")} Prisma would have added ${defaultEnv(url, false)} but this environment variable already exists in ${import_chalk5.default.bold(import_path3.default.relative(outputDir, envPath))}`;
      } else {
        import_fs4.default.appendFileSync(envPath, `

# This was inserted by \`prisma init\`:
` + defaultEnv(url));
      }
    }
    try {
      import_fs4.default.writeFileSync(import_path3.default.join(outputDir, ".gitignore"), defaultGitIgnore());
    } catch (error) {
      console.error("Failed to write .gitignore file, reason: ", error);
    }
    const steps = [];
    if (provider === "mongodb") {
      steps.push(`Define models in the prisma.schema file.`);
    } else {
      steps.push(`Run ${import_chalk5.default.green(import_sdk6.getCommandWithExecutor("prisma db pull"))} to turn your database schema into a Prisma schema.`);
    }
    steps.push(`Run ${import_chalk5.default.green(import_sdk6.getCommandWithExecutor("prisma generate"))} to generate the Prisma Client. You can then start querying your database.`);
    if (!url || args2["--datasource-provider"]) {
      if (!args2["--datasource-provider"]) {
        steps.unshift(`Set the ${import_chalk5.default.green("provider")} of the ${import_chalk5.default.green("datasource")} block in ${import_chalk5.default.green("schema.prisma")} to match your database: ${import_chalk5.default.green("postgresql")}, ${import_chalk5.default.green("mysql")}, ${import_chalk5.default.green("sqlite")}, ${import_chalk5.default.green("sqlserver")} (Preview) or ${import_chalk5.default.green("mongodb")} (Preview).`);
      }
      steps.unshift(`Set the ${import_chalk5.default.green("DATABASE_URL")} in the ${import_chalk5.default.green(".env")} file to point to your existing database. If your database has no tables yet, read https://pris.ly/d/getting-started`);
    }
    return `
\u2714 Your Prisma schema was created at ${import_chalk5.default.green("prisma/schema.prisma")}
  You can now open it in your favorite editor.
${warning && import_sdk6.logger.should.warn ? "\n" + warning + "\n" : ""}
Next steps:
${steps.map((s2, i) => `${i + 1}. ${s2}`).join("\n")}

More information in our documentation:
${import_sdk6.link("https://pris.ly/d/getting-started")}
    `;
  }
  help(error) {
    if (error) {
      return new import_sdk6.HelpError(`
${import_chalk5.default.bold.red(`!`)} ${error}
${_Init.help}`);
    }
    return _Init.help;
  }
};
var Init = _Init;
Init.help = import_sdk6.format(`
  Setup a new Prisma project
    
  ${import_chalk5.default.bold("Usage")}

    ${import_chalk5.default.dim("$")} prisma init [options]
  ${import_chalk5.default.bold("Options")}
    
             -h, --help   Display this help message
  --datasource-provider   Define the datasource provider to use: PostgreSQL, MySQL, SQLite, SQLServer (Preview) or MongoDB (Preview)
                  --url   Define a custom datasource url

  ${import_chalk5.default.bold("Examples")}

  Setup a new Prisma project with PostgreSQL (default)
    ${import_chalk5.default.dim("$")} prisma init

  Setup a new Prisma project and specify MySQL as the datasource provider to use
    ${import_chalk5.default.dim("$")} prisma init --datasource-provider mysql
  
  Setup a new Prisma project and specify the url that will be used
    ${import_chalk5.default.dim("$")} prisma init --url mysql://user:password@localhost:3306/mydb
  `);

// src/Dev.ts
var import_sdk7 = __toModule2(require_dist12());
var import_chalk6 = __toModule2(require_source());
var Dev = class {
  static new() {
    return new Dev();
  }
  async parse(argv) {
    return import_sdk7.format(`
      ${import_chalk6.default.redBright("Prisma CLI does not include a `dev` command any more right now.")}

      If you want to run Prisma Studio, use ${import_chalk6.default.green("prisma studio")}.
      If you want to generate the Prisma Client, use ${import_chalk6.default.green("prisma generate")} (or ${import_chalk6.default.green("prisma generate --watch")})
      If you want to update your schema, use ${import_chalk6.default.green("prisma db pull")}.
      If you want to migrate your database, use ${import_chalk6.default.green("prisma migrate")}.
    `);
  }
};

// src/utils/breakingChanges.ts
var import_sdk8 = __toModule2(require_dist12());
var import_chalk7 = __toModule2(require_source());
var breakingChangesMessage = `${import_chalk7.default.yellow.bold("warn")} Prisma 2.12.0 has breaking changes.
You can update your code with
${import_chalk7.default.bold("`npx @prisma/codemods update-2.12 ./`")}
Read more at ${import_sdk8.link("https://pris.ly/2.12")}`;

// src/utils/formatms.ts
function formatms(ms2) {
  if (ms2 < 1e3) {
    return `${ms2}ms`;
  }
  return (ms2 / 1e3).toFixed(2) + "s";
}

// src/utils/simpleDebounce.ts
function simpleDebounce(fn) {
  let executing = false;
  let pendingExecution = null;
  return async (...args2) => {
    if (executing) {
      pendingExecution = args2;
      return null;
    }
    executing = true;
    await fn(...args2).catch((e) => console.error(e));
    if (pendingExecution) {
      await fn(...args2).catch((e) => console.error(e));
      pendingExecution = null;
    }
    executing = false;
  };
}

// src/bin.ts
var import_Generate = __toModule2(require_Generate());
var import_sdk17 = __toModule2(require_dist12());

// src/Validate.ts
var import_sdk9 = __toModule2(require_dist12());
var import_chalk8 = __toModule2(require_source());
var import_fs5 = __toModule2(require("fs"));
var import_path4 = __toModule2(require("path"));
var _Validate = class {
  static new() {
    return new _Validate();
  }
  async parse(argv) {
    const args2 = import_sdk9.arg(argv, {
      "--help": Boolean,
      "-h": "--help",
      "--schema": String,
      "--telemetry-information": String
    });
    if (args2 instanceof Error) {
      return this.help(args2.message);
    }
    if (args2["--help"]) {
      return this.help();
    }
    const schemaPath = await import_sdk9.getSchemaPath(args2["--schema"]);
    if (!schemaPath) {
      throw new Error(`Could not find a ${import_chalk8.default.bold("schema.prisma")} file that is required for this command.
You can either provide it with ${import_chalk8.default.greenBright("--schema")}, set it as \`prisma.schema\` in your package.json or put it into the default location ${import_chalk8.default.greenBright("./prisma/schema.prisma")} https://pris.ly/d/prisma-schema-location`);
    }
    console.log(import_chalk8.default.dim(`Prisma schema loaded from ${import_path4.default.relative(process.cwd(), schemaPath)}`));
    const schema = import_fs5.default.readFileSync(schemaPath, "utf-8");
    await import_sdk9.getDMMF({
      datamodel: schema
    });
    await import_sdk9.getConfig({
      datamodel: schema
    });
    return `The schema at ${import_chalk8.default.underline(schemaPath)} is valid \u{1F680}`;
  }
  help(error) {
    if (error) {
      return new import_sdk9.HelpError(`
${import_chalk8.default.bold.red(`!`)} ${error}
${_Validate.help}`);
    }
    return _Validate.help;
  }
};
var Validate = _Validate;
Validate.help = import_sdk9.format(`
Validate a Prisma schema.

${import_chalk8.default.bold("Usage")}

  ${import_chalk8.default.dim("$")} prisma validate [options]

${import_chalk8.default.bold("Options")}

  -h, --help   Display this help message
    --schema   Custom path to your Prisma schema

${import_chalk8.default.bold("Examples")}

  With an existing Prisma schema
    ${import_chalk8.default.dim("$")} prisma validate

  Or specify a Prisma schema path
    ${import_chalk8.default.dim("$")} prisma validate --schema=./schema.prisma

`);

// src/Format.ts
var import_sdk10 = __toModule2(require_dist12());
var import_chalk9 = __toModule2(require_source());
var import_fs6 = __toModule2(require("fs"));
var import_os = __toModule2(require("os"));
var import_path5 = __toModule2(require("path"));
var _Format = class {
  static new() {
    return new _Format();
  }
  async parse(argv) {
    const before = Date.now();
    const args2 = import_sdk10.arg(argv, {
      "--help": Boolean,
      "-h": "--help",
      "--schema": String,
      "--telemetry-information": String
    });
    if (args2 instanceof Error) {
      return this.help(args2.message);
    }
    if (args2["--help"]) {
      return this.help();
    }
    const schemaPath = await import_sdk10.getSchemaPath(args2["--schema"]);
    if (!schemaPath) {
      throw new Error(`Could not find a ${import_chalk9.default.bold("schema.prisma")} file that is required for this command.
You can either provide it with ${import_chalk9.default.greenBright("--schema")}, set it as \`prisma.schema\` in your package.json or put it into the default location ${import_chalk9.default.greenBright("./prisma/schema.prisma")} https://pris.ly/d/prisma-schema-location`);
    }
    console.log(import_chalk9.default.dim(`Prisma schema loaded from ${import_path5.default.relative(process.cwd(), schemaPath)}`));
    let output = await import_sdk10.formatSchema({
      schemaPath
    });
    await import_sdk10.getDMMF({
      datamodel: output
    });
    output = output.trimEnd() + import_os.default.EOL;
    import_fs6.default.writeFileSync(schemaPath, output);
    const after = Date.now();
    return `Formatted ${import_chalk9.default.underline(schemaPath)} in ${formatms(after - before)} \u{1F680}`;
  }
  help(error) {
    if (error) {
      return new import_sdk10.HelpError(`
${import_chalk9.default.bold.red(`!`)} ${error}
${_Format.help}`);
    }
    return _Format.help;
  }
};
var Format = _Format;
Format.help = import_sdk10.format(`
Format a Prisma schema.

${import_chalk9.default.bold("Usage")}

  ${import_chalk9.default.dim("$")} prisma format [options]

${import_chalk9.default.bold("Options")}

  -h, --help   Display this help message
    --schema   Custom path to your Prisma schema

${import_chalk9.default.bold("Examples")}

With an existing Prisma schema
  ${import_chalk9.default.dim("$")} prisma format

Or specify a Prisma schema path
  ${import_chalk9.default.dim("$")} prisma format --schema=./schema.prisma

  `);

// src/Doctor.ts
var import_sdk11 = __toModule2(require_dist12());
var import_chalk10 = __toModule2(require_source());
var import_fs7 = __toModule2(require("fs"));
var import_path6 = __toModule2(require("path"));
var import_util5 = __toModule2(require("util"));
var import_fast_deep_equal = __toModule2(require_fast_deep_equal());
var readFile2 = import_util5.promisify(import_fs7.default.readFile);
var _Doctor = class {
  static new() {
    return new _Doctor();
  }
  async parse(argv) {
    const args2 = import_sdk11.arg(argv, {
      "--help": Boolean,
      "-h": "--help",
      "--schema": String,
      "--telemetry-information": String
    });
    if (args2 instanceof Error) {
      return this.help(args2.message);
    }
    if (args2["--help"]) {
      return this.help();
    }
    const schemaPath = await import_sdk11.getSchemaPath(args2["--schema"]);
    if (!schemaPath) {
      throw new Error(`Could not find a ${import_chalk10.default.bold("schema.prisma")} file that is required for this command.
You can either provide it with ${import_chalk10.default.greenBright("--schema")}, set it as \`prisma.schema\` in your package.json or put it into the default location ${import_chalk10.default.greenBright("./prisma/schema.prisma")} https://pris.ly/d/prisma-schema-location`);
    }
    console.log(import_chalk10.default.dim(`Prisma schema loaded from ${import_path6.default.relative(process.cwd(), schemaPath)}`));
    const schema = await readFile2(schemaPath, "utf-8");
    const localDmmf = await import_sdk11.getDMMF({datamodel: schema});
    const config = await import_sdk11.getConfig({datamodel: schema});
    console.error(`\u{1F469}\u200D\u2695\uFE0F\u{1F3E5} Prisma Doctor checking the database...`);
    const connectionString = config.datasources[0].url;
    const canConnect = await import_sdk11.canConnectToDatabase(connectionString.value, import_path6.default.dirname(schemaPath));
    if (typeof canConnect !== "boolean") {
      throw new Error(`${canConnect.code}: ${canConnect.message}`);
    }
    const engine = new import_sdk11.IntrospectionEngine({
      cwd: import_path6.default.dirname(schemaPath)
    });
    let datamodel;
    try {
      const result = await engine.introspect(schema);
      datamodel = result.datamodel;
    } finally {
      engine.stop();
    }
    const remoteDmmf = await import_sdk11.getDMMF({datamodel});
    const remoteModels = import_sdk11.keyBy(remoteDmmf.datamodel.models, (m2) => {
      var _a;
      return (_a = m2.dbName) != null ? _a : m2.name;
    });
    const modelPairs = localDmmf.datamodel.models.map((localModel) => {
      var _a;
      return {
        localModel,
        remoteModel: remoteModels[(_a = localModel.dbName) != null ? _a : localModel.name]
      };
    });
    const getFieldName = (f) => f.dbNames && f.dbNames.length > 0 ? f.dbNames[0] : f.name;
    const messages = [];
    for (const {localModel, remoteModel} of modelPairs) {
      let missingModel = false;
      const missingFields = [];
      const incorrectFieldType = [];
      if (!remoteModel) {
        missingModel = true;
      } else {
        const remoteFields = import_sdk11.keyBy(remoteModel.fields, getFieldName);
        for (const localField of localModel.fields) {
          const remoteField = remoteFields[getFieldName(localField)];
          if (!remoteField) {
            missingFields.push(localField);
          } else if (!import_fast_deep_equal.default(import_sdk11.pick(localField, ["type", "isList"]), import_sdk11.pick(remoteField, ["type", "isList"]))) {
            incorrectFieldType.push({localField, remoteField});
          }
        }
      }
      const msg = printModelMessage({
        model: localModel,
        missingModel,
        missingFields,
        incorrectFieldType
      });
      if (msg) {
        messages.push(msg);
      }
    }
    if (messages.length > 0) {
      throw new Error("\n\n" + messages.join("\n\n"));
    }
    return `Everything in sync \u{1F504}`;
  }
  help(error) {
    if (error) {
      return new import_sdk11.HelpError(`
${import_chalk10.default.bold.red(`!`)} ${error}
${_Doctor.help}`);
    }
    return _Doctor.help;
  }
};
var Doctor = _Doctor;
Doctor.help = import_sdk11.format(`
Check, if the schema and the database are in sync.

${import_chalk10.default.bold("Usage")}

  ${import_chalk10.default.dim("$")} prisma doctor [options]

${import_chalk10.default.bold("Options")}

  -h, --help   Display this help message
    --schema   Custom path to your Prisma schema

${import_chalk10.default.bold("Examples")}

  With an existing schema.prisma
    ${import_chalk10.default.dim("$")} prisma doctor

  Or specify a schema
    ${import_chalk10.default.dim("$")} prisma doctor --schema=./schema.prisma

  `);
function printModelMessage({
  model,
  missingModel,
  missingFields,
  incorrectFieldType
}) {
  if (!missingModel && missingFields.length === 0 && incorrectFieldType.length === 0) {
    return null;
  }
  let msg = `${import_chalk10.default.bold.underline(model.name)}
`;
  if (missingModel) {
    msg += `\u21AA Model is missing in database
`;
  }
  for (const field of missingFields) {
    msg += `\u21AA Field ${import_chalk10.default.bold(field.name)} is missing in database
`;
  }
  for (const {localField, remoteField} of incorrectFieldType) {
    const printFieldType = (f) => f.type + (f.isList ? "[]" : "");
    msg += `\u21AA Field ${localField.name} has type ${import_chalk10.default.greenBright(printFieldType(localField))} locally, but ${import_chalk10.default.redBright(printFieldType(remoteField))} remote
`;
  }
  return msg;
}

// src/Studio.ts
var import_engines4 = __toModule2(require("@prisma/engines"));
var import_sdk12 = __toModule2(require_dist12());
var import_studio_server = __toModule2(require_dist24());
var import_chalk11 = __toModule2(require_source());
var import_get_port = __toModule2(require_get_port());
var import_open = __toModule2(require_open());
var import_path7 = __toModule2(require("path"));
var packageJson3 = require_package2();
var _Studio = class {
  static new() {
    return new _Studio();
  }
  async parse(argv) {
    const args2 = import_sdk12.arg(argv, {
      "--help": Boolean,
      "-h": "--help",
      "--port": Number,
      "-p": "--port",
      "--browser": String,
      "-b": "--browser",
      "--hostname": String,
      "-n": "--hostname",
      "--schema": String,
      "--telemetry-information": String
    });
    if (import_sdk12.isError(args2)) {
      return this.help(args2.message);
    }
    if (args2["--help"]) {
      return this.help();
    }
    const schemaPath = await import_sdk12.getSchemaPath(args2["--schema"]);
    if (!schemaPath) {
      throw new Error(`Could not find a ${import_chalk11.default.bold("schema.prisma")} file that is required for this command.
You can either provide it with ${import_chalk11.default.greenBright("--schema")}, set it as \`prisma.schema\` in your package.json or put it into the default location ${import_chalk11.default.greenBright("./prisma/schema.prisma")} https://pris.ly/d/prisma-schema-location`);
    }
    console.log(import_chalk11.default.dim(`Prisma schema loaded from ${import_path7.default.relative(process.cwd(), schemaPath)}`));
    const hostname = args2["--hostname"];
    const port = args2["--port"] || await import_get_port.default({port: import_get_port.default.makeRange(5555, 5600)});
    const browser = args2["--browser"] || process.env.BROWSER;
    const staticAssetDir = import_path7.default.resolve(__dirname, "../build/public");
    const studio = new import_studio_server.default({
      schemaPath,
      hostname,
      port,
      staticAssetDir,
      prismaClient: {
        resolve: {
          "@prisma/client": import_path7.default.resolve(__dirname, "../prisma-client/index.js"),
          "@prisma/engines": require.resolve("@prisma/engines")
        }
      },
      versions: {
        prisma2: packageJson3.version,
        queryEngine: import_engines4.enginesVersion
      }
    });
    await studio.start();
    const serverUrl = `http://localhost:${port}`;
    if (!browser || browser.toLowerCase() !== "none") {
      try {
        await import_open.default(serverUrl, {
          app: browser,
          url: true
        });
      } catch (e) {
      }
    }
    this.instance = studio;
    return `Prisma Studio is up on ${serverUrl}`;
  }
  help(error) {
    if (error) {
      return new import_sdk12.HelpError(`
${import_chalk11.default.bold.red(`!`)} ${error}
${_Studio.help}`);
    }
    return _Studio.help;
  }
};
var Studio = _Studio;
Studio.help = import_sdk12.format(`
Browse your data with Prisma Studio

${import_chalk11.default.bold("Usage")}

  ${import_chalk11.default.dim("$")} prisma studio [options]

${import_chalk11.default.bold("Options")}

  -h, --help        Display this help message
  -p, --port        Port to start Studio on
  -b, --browser     Browser to open Studio in
  -n, --hostname    Hostname to bind the Express server to
  --schema          Custom path to your Prisma schema

${import_chalk11.default.bold("Examples")}

  Start Studio on the default port
    ${import_chalk11.default.dim("$")} prisma studio

  Start Studio on a custom port
    ${import_chalk11.default.dim("$")} prisma studio --port 5555

  Start Studio in a specific browser
    ${import_chalk11.default.dim("$")} prisma studio --port 5555 --browser firefox
    ${import_chalk11.default.dim("$")} BROWSER=firefox prisma studio --port 5555

  Start Studio without opening in a browser
    ${import_chalk11.default.dim("$")} prisma studio --port 5555 --browser none
    ${import_chalk11.default.dim("$")} BROWSER=none prisma studio --port 5555

  Specify a schema
    ${import_chalk11.default.dim("$")} prisma studio --schema=./schema.prisma
`);

// src/Telemetry.ts
var checkpoint = __toModule2(require_dist11());
var import_sdk13 = __toModule2(require_dist12());
var Telemetry = class {
  static new() {
    return new Telemetry();
  }
  async parse() {
    const info = await checkpoint.getInfo();
    const projectPathHash = await import_sdk13.getProjectHash();
    const cliPathHash = import_sdk13.getCLIPathHash();
    const cacheItems = info.cacheItems.map((it) => {
      return {
        product: it.output.product,
        version: it.version,
        package: it.output.package,
        release_tag: it.output.release_tag,
        cli_path: it.cli_path,
        cli_path_hash: it.output.cli_path_hash,
        last_reminder: it.last_reminder,
        cached_at: it.cached_at
      };
    });
    return JSON.stringify({
      signature: info.signature,
      cachePath: info.cachePath,
      current: {
        projectPathHash,
        cliPathHash
      },
      cacheItems
    }, void 0, 2);
  }
};

// src/utils/printUpdateMessage.ts
var import_sdk14 = __toModule2(require_dist12());
var import_chalk12 = __toModule2(require_source());
var isPrismaInstalledGlobally = import_sdk14.isCurrentBinInstalledGlobally();
function printUpdateMessage(checkResult) {
  let boxHeight = 4;
  let majorText = "";
  const currentVersionInstalled = checkResult.data.previous_version;
  const latestVersionAvailable = checkResult.data.current_version;
  const prismaCLICommand = makeInstallCommand(checkResult.data.package, checkResult.data.release_tag);
  const prismaClientCommand = makeInstallCommand("@prisma/client", checkResult.data.release_tag, {
    canBeGlobal: false,
    canBeDev: false
  });
  try {
    const [majorInstalled] = currentVersionInstalled.split(".");
    const [majorLatest] = latestVersionAvailable.split(".");
    if (majorInstalled < majorLatest) {
      majorText = `
This is a major update - please follow the guide at
https://pris.ly/d/major-version-upgrade

`;
      boxHeight = boxHeight + 4;
    }
  } catch (e) {
  }
  const boxText = `
${import_chalk12.default.blue("Update available")} ${currentVersionInstalled} -> ${latestVersionAvailable}
${majorText}Run the following to update
  ${import_chalk12.default.bold(prismaCLICommand)}
  ${import_chalk12.default.bold(prismaClientCommand)}`;
  const boxedMessage = import_sdk14.drawBox({
    height: boxHeight,
    width: 59,
    str: boxText,
    horizontalPadding: 2
  });
  console.error(boxedMessage);
}
function makeInstallCommand(packageName, tag, options = {
  canBeGlobal: true,
  canBeDev: true
}) {
  var _a;
  const yarnUsed = (_a = process.env.npm_config_user_agent) == null ? void 0 : _a.includes("yarn");
  let command = "";
  if (isPrismaInstalledGlobally === "yarn" && options.canBeGlobal) {
    command = `yarn global add ${packageName}`;
  } else if (isPrismaInstalledGlobally === "npm" && options.canBeGlobal) {
    command = `npm i -g ${packageName}`;
  } else if (yarnUsed && options.canBeDev) {
    command = `yarn add --dev ${packageName}`;
  } else if (options.canBeDev) {
    command = `npm i --save-dev ${packageName}`;
  } else if (yarnUsed) {
    command = `yarn add ${packageName}`;
  } else {
    command = `npm i ${packageName}`;
  }
  command += `@${tag}`;
  return command;
}

// src/bin.ts
var import_engines5 = __toModule2(require("@prisma/engines"));
var import_path9 = __toModule2(require("path"));

// src/utils/detectPrisma1.ts
var import_fs8 = __toModule2(require("fs"));
var import_path8 = __toModule2(require("path"));
function detectPrisma1() {
  if (import_fs8.default.existsSync(import_path8.default.join(process.cwd(), "prisma.yml"))) {
    throw new Error(`We detected a Prisma 1 project. For Prisma 1, please use the \`prisma1\` CLI instead.
You can install it with \`npm install -g prisma1\`.
If you want to upgrade to Prisma 2, please have a look at our upgrade guide:
http://pris.ly/d/upgrading-to-prisma2`);
  }
}

// src/bin.ts
process.env.NODE_NO_WARNINGS = "1";
var packageJson4 = require_package2();
var commandArray = process.argv.slice(2);
process.removeAllListeners("warning");
var debug2 = import_debug2.default("prisma:cli");
process.on("uncaughtException", (e) => {
  debug2(e);
});
process.on("unhandledRejection", (e) => {
  debug2(e);
});
if (process.argv.length > 1 && process.argv[1].endsWith("prisma2")) {
  console.log(import_chalk13.default.yellow("deprecated") + `  The ${import_chalk13.default.redBright("prisma2")} command is deprecated and has been renamed to ${import_chalk13.default.greenBright("prisma")}.
Please execute ${import_chalk13.default.bold.greenBright("prisma" + (commandArray.length ? " " + commandArray.join(" ") : ""))} instead.
`);
}
var args = import_sdk15.arg(commandArray, {
  "--schema": String,
  "--telemetry-information": String
}, false, true);
if (commandArray.length) {
  try {
    const envPaths2 = import_sdk15.getEnvPaths(args["--schema"]);
    const envData = import_sdk15.tryLoadEnvs(envPaths2, {conflictCheck: "error"});
    envData && envData.message && console.log(envData.message);
  } catch (e) {
    handleIndividualError(e);
  }
}
if (process.env.NO_COLOR) {
  import_chalk13.default.level = 0;
}
var isPrismaInstalledGlobally2 = import_sdk17.isCurrentBinInstalledGlobally();
async function main() {
  detectPrisma1();
  const cli = CLI.new({
    init: Init.new(),
    migrate: import_migrate.MigrateCommand.new({
      dev: import_migrate.MigrateDev.new(),
      status: import_migrate.MigrateStatus.new(),
      resolve: import_migrate.MigrateResolve.new(),
      reset: import_migrate.MigrateReset.new(),
      deploy: import_migrate.MigrateDeploy.new()
    }),
    db: import_migrate.DbCommand.new({
      pull: import_migrate.DbPull.new(),
      push: import_migrate.DbPush.new(),
      seed: import_migrate.DbSeed.new()
    }),
    introspect: import_migrate.DbPull.new(),
    dev: Dev.new(),
    studio: Studio.new(),
    generate: import_Generate.Generate.new(),
    version: Version.new(),
    validate: Validate.new(),
    format: Format.new(),
    doctor: Doctor.new(),
    telemetry: Telemetry.new()
  }, [
    "version",
    "init",
    "migrate",
    "db",
    "introspect",
    "dev",
    "studio",
    "generate",
    "validate",
    "format",
    "doctor",
    "telemetry"
  ]);
  const result = await cli.parse(commandArray);
  if (result instanceof import_sdk16.HelpError) {
    console.error(result.message);
    return 1;
  } else if (import_sdk16.isError(result)) {
    console.error(result);
    return 1;
  }
  console.log(result);
  try {
    const projectPathHash = await import_sdk15.getProjectHash();
    const cliPathHash = import_sdk15.getCLIPathHash();
    let schemaProvider;
    let schemaPreviewFeatures;
    let schemaGeneratorsProviders;
    try {
      const schema = await import_sdk15.getSchema(args["--schema"]);
      const config = await import_sdk15.getConfig({
        datamodel: schema,
        ignoreEnvVarErrors: true
      });
      if (config.datasources.length > 0) {
        schemaProvider = config.datasources[0].provider;
      }
      const generator = config.generators.find((gen) => gen.previewFeatures.length > 0);
      if (generator) {
        schemaPreviewFeatures = generator.previewFeatures;
      }
      schemaGeneratorsProviders = config.generators.map((gen) => import_sdk15.parseEnvValue(gen.provider));
    } catch (e) {
      debug2("Error from cli/src/bin.ts");
      debug2(e);
    }
    const checkResult = await checkpoint2.check({
      product: "prisma",
      cli_path_hash: cliPathHash,
      project_hash: projectPathHash,
      version: packageJson4.version,
      schema_providers: schemaProvider ? [schemaProvider] : void 0,
      schema_preview_features: schemaPreviewFeatures,
      schema_generators_providers: schemaGeneratorsProviders,
      cli_path: process.argv[1],
      cli_install_type: isPrismaInstalledGlobally2 ? "global" : "local",
      command: commandArray.join(" "),
      information: args["--telemetry-information"] || process.env.PRISMA_TELEMETRY_INFORMATION
    });
    const shouldHide = process.env.PRISMA_HIDE_UPDATE_MESSAGE;
    if (checkResult.status === "ok" && checkResult.data.outdated && !shouldHide) {
      printUpdateMessage(checkResult);
    }
  } catch (e) {
    debug2(e);
  }
  return 0;
}
process.on("SIGINT", () => {
  process.exit(0);
});
if (require.main === module) {
  main().then((code) => {
    if (code !== 0) {
      process.exit(code);
    }
  }).catch((err) => {
    if (typeof err[Symbol.iterator] === "function") {
      for (const individualError of err) {
        handleIndividualError(individualError);
      }
    } else {
      handleIndividualError(err);
    }
  });
}
function handleIndividualError(error) {
  if (error.rustStack) {
    import_migrate.handlePanic(error, packageJson4.version, import_engines5.enginesVersion, commandArray.join(" ")).catch((e) => {
      if (import_debug2.default.enabled("prisma")) {
        console.error(import_chalk13.default.redBright.bold("Error: ") + e.stack);
      } else {
        console.error(import_chalk13.default.redBright.bold("Error: ") + e.message);
      }
    }).finally(() => {
      process.exit(1);
    });
  } else {
    if (import_debug2.default.enabled("prisma")) {
      console.error(import_chalk13.default.redBright.bold("Error: ") + error.stack);
    } else {
      console.error(import_chalk13.default.redBright.bold("Error: ") + error.message);
    }
    process.exit(1);
  }
}
import_path9.default.join(__dirname, "../../engines/query-engine-darwin");
import_path9.default.join(__dirname, "../../engines/introspection-engine-darwin");
import_path9.default.join(__dirname, "../../engines/prisma-fmt-darwin");
import_path9.default.join(__dirname, "../../engines/query-engine-debian-openssl-1.0.x");
import_path9.default.join(__dirname, "../../engines/introspection-engine-debian-openssl-1.0.x");
import_path9.default.join(__dirname, "../../engines/prisma-fmt-debian-openssl-1.0.x");
import_path9.default.join(__dirname, "../../engines/query-engine-debian-openssl-1.1.x");
import_path9.default.join(__dirname, "../../engines/introspection-engine-debian-openssl-1.1.x");
import_path9.default.join(__dirname, "../../engines/prisma-fmt-debian-openssl-1.1.x");
import_path9.default.join(__dirname, "../../engines/query-engine-rhel-openssl-1.0.x");
import_path9.default.join(__dirname, "../../engines/introspection-engine-rhel-openssl-1.0.x");
import_path9.default.join(__dirname, "../../engines/prisma-fmt-rhel-openssl-1.0.x");
import_path9.default.join(__dirname, "../../engines/query-engine-rhel-openssl-1.1.x");
import_path9.default.join(__dirname, "../../engines/introspection-engine-rhel-openssl-1.1.x");
import_path9.default.join(__dirname, "../../engines/prisma-fmt-rhel-openssl-1.1.x");
