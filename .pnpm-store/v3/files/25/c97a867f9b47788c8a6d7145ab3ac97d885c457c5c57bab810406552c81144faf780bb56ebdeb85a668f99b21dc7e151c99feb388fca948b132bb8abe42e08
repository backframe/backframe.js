{
  "version": 3,
  "sources": ["../../src/binary/BinaryEngine.ts"],
  "sourcesContent": ["import Debug from '@prisma/debug'\nimport { getEnginesPath } from '@prisma/engines'\nimport { ConnectorType, GeneratorConfig } from '@prisma/generator-helper'\nimport { getPlatform, Platform, platforms } from '@prisma/get-platform'\nimport chalk from 'chalk'\nimport { ChildProcessByStdio, spawn } from 'child_process'\nimport EventEmitter from 'events'\nimport execa from 'execa'\nimport fs from 'fs'\nimport net from 'net'\nimport pRetry from 'p-retry'\nimport path from 'path'\nimport { Readable } from 'stream'\nimport { URL } from 'url'\nimport { promisify } from 'util'\nimport byline from '../tools/byline'\nimport {\n  DatasourceOverwrite,\n  Engine,\n  EngineConfig,\n  EngineEventType,\n  GetConfigResult,\n} from '../common/Engine'\nimport { RequestError } from '../common/errors/types/RequestError'\nimport { PrismaClientKnownRequestError } from '../common/errors/PrismaClientKnownRequestError'\nimport { PrismaClientInitializationError } from '../common/errors/PrismaClientInitializationError'\nimport { PrismaClientRustError } from '../common/errors/PrismaClientRustError'\nimport { PrismaClientRustPanicError } from '../common/errors/PrismaClientRustPanicError'\nimport { PrismaClientUnknownRequestError } from '../common/errors/PrismaClientUnknownRequestError'\nimport { getErrorMessageWithLink } from '../common/errors/utils/getErrorMessageWithLink'\nimport {\n  convertLog,\n  getMessage,\n  isRustError,\n  isRustErrorLog,\n  RustError,\n  RustLog,\n} from '../common/errors/utils/log'\nimport { omit } from '../tools/omit'\nimport { printGeneratorConfig } from '../common/utils/printGeneratorConfig'\nimport { Connection, Result } from './Connection'\nimport { fixBinaryTargets, getRandomString, plusX } from '../common/utils/util'\nimport type * as Tx from '../common/types/Transaction'\nimport {\n  QueryEngineRequestHeaders,\n  QueryEngineResult,\n} from '../common/types/QueryEngine'\nimport type { IncomingHttpHeaders } from 'http'\n\nconst debug = Debug('prisma:engine')\nconst exists = promisify(fs.exists)\n\n// eslint-disable-next-line\nconst logger = (...args) => {\n  // console.log(chalk.red.bold('logger '), ...args)\n}\n\n/**\n * Node.js based wrapper to run the Prisma binary\n */\n\nconst knownPlatforms: Platform[] = [...platforms, 'native']\n\nexport type Deferred = {\n  resolve: () => void\n  reject: (err: Error) => void\n}\n\nexport type StopDeferred = {\n  resolve: (code: number | null) => void\n  reject: (err: Error) => void\n}\n\nconst engines: BinaryEngine[] = []\nconst socketPaths: string[] = []\n\nconst MAX_STARTS = process.env.PRISMA_CLIENT_NO_RETRY ? 1 : 2\nconst MAX_REQUEST_RETRIES = process.env.PRISMA_CLIENT_NO_RETRY ? 1 : 2\n\nexport class BinaryEngine extends Engine {\n  private logEmitter: EventEmitter\n  private showColors: boolean\n  private logQueries: boolean\n  private logLevel?: 'info' | 'warn'\n  private env?: Record<string, string>\n  private flags: string[]\n  private port?: number\n  private enableDebugLogs: boolean\n  private enableEngineDebugMode: boolean\n  private child?: ChildProcessByStdio<null, Readable, Readable>\n  private clientVersion?: string\n  private lastPanic?: Error\n  private globalKillSignalReceived?: string\n  private startCount = 0\n  private previewFeatures: string[] = []\n  private engineEndpoint?: string\n  private lastErrorLog?: RustLog\n  private lastRustError?: RustError\n  private useUds = false\n  private socketPath?: string\n  private getConfigPromise?: Promise<GetConfigResult>\n  private stopPromise?: Promise<void>\n  private beforeExitListener?: () => Promise<void>\n  private dirname?: string\n  private cwd: string\n  private datamodelPath: string\n  private prismaPath?: string\n  private stderrLogs = ''\n  private currentRequestPromise?: any\n  private platformPromise?: Promise<Platform>\n  private platform?: Platform | string\n  private generator?: GeneratorConfig\n  private incorrectlyPinnedBinaryTarget?: string\n  private datasources?: DatasourceOverwrite[]\n  private startPromise?: Promise<void>\n  private versionPromise?: Promise<string>\n  private engineStartDeferred?: Deferred\n  private engineStopDeferred?: StopDeferred\n  private connection: Connection\n  private lastQuery?: string\n  private lastVersion?: string\n  private lastActiveProvider?: ConnectorType\n  private activeProvider?: string\n  /**\n   * exiting is used to tell the .on('exit') hook, if the exit came from our script.\n   * As soon as the Prisma binary returns a correct return code (like 1 or 0), we don't need this anymore\n   */\n  constructor({\n    cwd,\n    datamodelPath,\n    prismaPath,\n    generator,\n    datasources,\n    showColors,\n    logLevel,\n    logQueries,\n    env,\n    flags,\n    clientVersion,\n    previewFeatures,\n    engineEndpoint,\n    enableDebugLogs,\n    enableEngineDebugMode,\n    dirname,\n    useUds,\n    activeProvider,\n  }: EngineConfig) {\n    super()\n\n    this.dirname = dirname\n    this.useUds = useUds ?? false // === undefined ? process.platform !== 'win32' : useUds\n    this.env = env\n    this.cwd = this.resolveCwd(cwd)\n    this.enableDebugLogs = enableDebugLogs ?? false\n    this.enableEngineDebugMode = enableEngineDebugMode ?? false\n    this.datamodelPath = datamodelPath\n    this.prismaPath = process.env.PRISMA_QUERY_ENGINE_BINARY ?? prismaPath\n    this.generator = generator\n    this.datasources = datasources\n    this.logEmitter = new EventEmitter()\n    this.logEmitter.on('error', () => {\n      // to prevent unhandled error events\n    })\n    this.showColors = showColors ?? false\n    this.logLevel = logLevel\n    this.logQueries = logQueries ?? false\n    this.clientVersion = clientVersion\n    this.flags = flags ?? []\n    this.previewFeatures = previewFeatures ?? []\n    this.activeProvider = activeProvider\n    this.connection = new Connection()\n\n    initHooks()\n    const removedFlags = [\n      'middlewares',\n      'aggregateApi',\n      'distinct',\n      'aggregations',\n      'insensitiveFilters',\n      'atomicNumberOperations',\n      'transactionApi',\n      'transaction',\n      'connectOrCreate',\n      'uncheckedScalarInputs',\n      'nativeTypes',\n      'createMany',\n      'groupBy',\n    ]\n    const removedFlagsUsed = this.previewFeatures.filter((e) =>\n      removedFlags.includes(e),\n    )\n\n    if (\n      removedFlagsUsed.length > 0 &&\n      !process.env.PRISMA_HIDE_PREVIEW_FLAG_WARNINGS\n    ) {\n      console.log(\n        `${chalk.blueBright(\n          'info',\n        )} The preview flags \\`${removedFlagsUsed.join(\n          '`, `',\n        )}\\` were removed, you can now safely remove them from your schema.prisma.`,\n      )\n    }\n\n    this.previewFeatures = this.previewFeatures.filter(\n      (e) => !removedFlags.includes(e),\n    )\n    this.engineEndpoint = engineEndpoint\n\n    if (engineEndpoint) {\n      const url = new URL(engineEndpoint)\n      this.port = Number(url.port)\n    }\n\n    if (this.platform) {\n      if (\n        !knownPlatforms.includes(this.platform as Platform) &&\n        !fs.existsSync(this.platform)\n      ) {\n        throw new PrismaClientInitializationError(\n          `Unknown ${chalk.red(\n            'PRISMA_QUERY_ENGINE_BINARY',\n          )} ${chalk.redBright.bold(\n            this.platform,\n          )}. Possible binaryTargets: ${chalk.greenBright(\n            knownPlatforms.join(', '),\n          )} or a path to the query engine binary.\nYou may have to run ${chalk.greenBright(\n            'prisma generate',\n          )} for your changes to take effect.`,\n          this.clientVersion!,\n        )\n      }\n    } else {\n      void this.getPlatform()\n    }\n    if (this.enableDebugLogs) {\n      Debug.enable('*')\n    }\n    engines.push(this)\n    this.checkForTooManyEngines()\n  }\n\n  private setError(err: Error | RustLog | RustError) {\n    if (isRustError(err)) {\n      this.lastRustError = err\n      this.logEmitter.emit(\n        'error',\n        new PrismaClientRustError({\n          clientVersion: this.clientVersion!,\n          error: err,\n        }),\n      )\n      if (err.is_panic) {\n        this.handlePanic()\n      }\n    } else if (isRustErrorLog(err)) {\n      this.lastErrorLog = err\n      this.logEmitter.emit(\n        'error',\n        new PrismaClientRustError({\n          clientVersion: this.clientVersion!,\n          log: err,\n        }),\n      )\n      if (err.fields?.message === 'PANIC') {\n        this.handlePanic()\n      }\n    } else {\n      this.logEmitter.emit('error', err)\n    }\n  }\n\n  private checkForTooManyEngines() {\n    if (engines.length >= 10) {\n      const runningEngines = engines.filter((e) => e.child)\n      if (runningEngines.length === 10) {\n        console.warn(\n          `${chalk.yellow(\n            'warn(prisma-client)',\n          )} Already 10 Prisma Clients are actively running.`,\n        )\n      }\n    }\n  }\n\n  private resolveCwd(cwd?: string): string {\n    if (cwd && fs.existsSync(cwd) && fs.lstatSync(cwd).isDirectory()) {\n      return cwd\n    }\n\n    return process.cwd()\n  }\n\n  on(event: EngineEventType, listener: (args?: any) => any): void {\n    if (event === 'beforeExit') {\n      this.beforeExitListener = listener\n    } else {\n      this.logEmitter.on(event, listener)\n    }\n  }\n\n  async emitExit() {\n    if (this.beforeExitListener) {\n      try {\n        await this.beforeExitListener()\n      } catch (e) {\n        console.error(e)\n      }\n    }\n  }\n\n  private async getPlatform(): Promise<Platform> {\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    if (this.platformPromise) {\n      return this.platformPromise\n    }\n\n    this.platformPromise = getPlatform()\n\n    return this.platformPromise\n  }\n\n  private getQueryEnginePath(\n    platform: string,\n    prefix: string = __dirname,\n  ): string {\n    let queryEnginePath = path.join(prefix, `query-engine-${platform}`)\n\n    if (platform === 'windows') {\n      queryEnginePath = `${queryEnginePath}.exe`\n    }\n\n    return queryEnginePath\n  }\n\n  private handlePanic(): void {\n    this.child?.kill()\n    if (this.currentRequestPromise?.cancel) {\n      this.currentRequestPromise.cancel()\n    }\n  }\n\n  private async resolvePrismaPath(): Promise<{\n    prismaPath: string\n    searchedLocations: string[]\n  }> {\n    const searchedLocations: string[] = []\n    let enginePath\n    if (this.prismaPath) {\n      return { prismaPath: this.prismaPath, searchedLocations }\n    }\n\n    const platform = await this.getPlatform()\n    if (this.platform && this.platform !== platform) {\n      this.incorrectlyPinnedBinaryTarget = this.platform\n    }\n\n    this.platform = this.platform || platform\n\n    if (__filename.includes('BinaryEngine')) {\n      enginePath = this.getQueryEnginePath(this.platform, getEnginesPath())\n      return { prismaPath: enginePath, searchedLocations }\n    }\n    const searchLocations: string[] = [\n      eval(`require('path').join(__dirname, '../../../.prisma/client')`), // Dot Prisma Path\n      this.generator?.output?.value ?? eval('__dirname'), // Custom Generator Path\n      path.join(eval('__dirname'), '..'), // parentDirName\n      path.dirname(this.datamodelPath), // Datamodel Dir\n      this.cwd, //cwdPath\n      '/tmp/prisma-engines',\n    ]\n\n    if (this.dirname) {\n      searchLocations.push(this.dirname)\n    }\n\n    for (const location of searchLocations) {\n      searchedLocations.push(location)\n      debug(`Search for Query Engine in ${location}`)\n      enginePath = this.getQueryEnginePath(this.platform, location)\n      if (fs.existsSync(enginePath)) {\n        return { prismaPath: enginePath, searchedLocations }\n      }\n    }\n    enginePath = this.getQueryEnginePath(this.platform)\n\n    return { prismaPath: enginePath ?? '', searchedLocations }\n  }\n\n  // get prisma path\n  private async getPrismaPath(): Promise<string> {\n    const { prismaPath, searchedLocations } = await this.resolvePrismaPath()\n    const platform = await this.getPlatform()\n    // If path to query engine doesn't exist, throw\n    if (!(await exists(prismaPath))) {\n      const pinnedStr = this.incorrectlyPinnedBinaryTarget\n        ? `\\nYou incorrectly pinned it to ${chalk.redBright.bold(\n            `${this.incorrectlyPinnedBinaryTarget}`,\n          )}\\n`\n        : ''\n\n      let errorText = `Query engine binary for current platform \"${chalk.bold(\n        platform,\n      )}\" could not be found.${pinnedStr}\nThis probably happens, because you built Prisma Client on a different platform.\n(Prisma Client looked in \"${chalk.underline(prismaPath)}\")\n\nSearched Locations:\n\n${searchedLocations\n  .map((f) => {\n    let msg = `  ${f}`\n    if (\n      process.env.DEBUG === 'node-engine-search-locations' &&\n      fs.existsSync(f)\n    ) {\n      const dir = fs.readdirSync(f)\n      msg += dir.map((d) => `    ${d}`).join('\\n')\n    }\n    return msg\n  })\n  .join(\n    '\\n' + (process.env.DEBUG === 'node-engine-search-locations' ? '\\n' : ''),\n  )}\\n`\n      // The generator should always be there during normal usage\n      if (this.generator) {\n        // The user already added it, but it still doesn't work \uD83E\uDD37\u200D\u2640\uFE0F\n        // That means, that some build system just deleted the files \uD83E\uDD14\n        if (\n          this.generator.binaryTargets.find(\n            (object) => object.value === this.platform!,\n          ) ||\n          this.generator.binaryTargets.find(\n            (object) => object.value === 'native',\n          )\n        ) {\n          errorText += `\nYou already added the platform${\n            this.generator.binaryTargets.length > 1 ? 's' : ''\n          } ${this.generator.binaryTargets\n            .map((t) => `\"${chalk.bold(t.value)}\"`)\n            .join(', ')} to the \"${chalk.underline('generator')}\" block\nin the \"schema.prisma\" file as described in https://pris.ly/d/client-generator,\nbut something went wrong. That's suboptimal.\n\nPlease create an issue at https://github.com/prisma/prisma/issues/new`\n          errorText += ``\n        } else {\n          // If they didn't even have the current running platform in the schema.prisma file, it's easy\n          // Just add it\n          errorText += `\\n\\nTo solve this problem, add the platform \"${\n            this.platform\n          }\" to the \"${chalk.underline(\n            'binaryTargets',\n          )}\" attribute in the \"${chalk.underline(\n            'generator',\n          )}\" block in the \"schema.prisma\" file:\n${chalk.greenBright(this.getFixedGenerator())}\n\nThen run \"${chalk.greenBright(\n            'prisma generate',\n          )}\" for your changes to take effect.\nRead more about deploying Prisma Client: https://pris.ly/d/client-generator`\n        }\n      } else {\n        errorText += `\\n\\nRead more about deploying Prisma Client: https://pris.ly/d/client-generator\\n`\n      }\n\n      throw new PrismaClientInitializationError(errorText, this.clientVersion!)\n    }\n\n    if (this.incorrectlyPinnedBinaryTarget) {\n      console.error(`${chalk.yellow(\n        'Warning:',\n      )} You pinned the platform ${chalk.bold(\n        this.incorrectlyPinnedBinaryTarget,\n      )}, but Prisma Client detects ${chalk.bold(await this.getPlatform())}.\nThis means you should very likely pin the platform ${chalk.greenBright(\n        await this.getPlatform(),\n      )} instead.\n${chalk.dim(\"In case we're mistaken, please report this to us \uD83D\uDE4F.\")}`)\n    }\n\n    if (process.platform !== 'win32') {\n      plusX(prismaPath)\n    }\n\n    return prismaPath\n  }\n\n  private getFixedGenerator(): string {\n    const fixedGenerator = {\n      ...this.generator!,\n      binaryTargets: fixBinaryTargets(\n        this.generator!.binaryTargets,\n        this.platform!,\n      ),\n    }\n\n    return printGeneratorConfig(fixedGenerator)\n  }\n\n  private printDatasources(): string {\n    if (this.datasources) {\n      return JSON.stringify(this.datasources)\n    }\n\n    return '[]'\n  }\n\n  /**\n   * Starts the engine, returns the url that it runs on\n   */\n  async start(): Promise<void> {\n    if (this.stopPromise) {\n      await this.stopPromise\n    }\n\n    if (!this.startPromise) {\n      this.startCount++\n      this.startPromise = this.internalStart()\n    }\n\n    await this.startPromise\n\n    if (!this.child && !this.engineEndpoint) {\n      throw new PrismaClientUnknownRequestError(\n        `Can't perform request, as the Engine has already been stopped`,\n        this.clientVersion!,\n      )\n    }\n\n    return this.startPromise\n  }\n\n  private getEngineEnvVars() {\n    const env: any = {\n      PRISMA_DML_PATH: this.datamodelPath,\n      RUST_BACKTRACE: '1',\n      RUST_LOG: 'info',\n    }\n\n    if (this.logQueries || this.logLevel === 'info') {\n      env.RUST_LOG = 'info'\n      if (this.logQueries) {\n        env.LOG_QUERIES = 'true'\n      }\n    }\n\n    if (this.datasources) {\n      env.OVERWRITE_DATASOURCES = this.printDatasources()\n    }\n\n    if (!process.env.NO_COLOR && this.showColors) {\n      env.CLICOLOR_FORCE = '1'\n    }\n\n    return {\n      ...this.env, // user-provided env vars\n      ...process.env,\n      ...env,\n    }\n  }\n\n  private internalStart(): Promise<void> {\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises, no-async-promise-executor\n    return new Promise(async (resolve, reject) => {\n      await new Promise((r) => process.nextTick(r))\n      if (this.stopPromise) {\n        await this.stopPromise\n      }\n      if (this.engineEndpoint) {\n        try {\n          await pRetry(() => this.connection.get('/'), {\n            retries: 10,\n          })\n        } catch (e) {\n          return reject(e)\n        }\n        return resolve()\n      }\n      try {\n        if (this.child?.connected || (this.child && !this.child?.killed)) {\n          debug(`There is a child that still runs and we want to start again`)\n        }\n\n        // reset last panic\n        this.lastRustError = undefined\n        this.lastErrorLog = undefined\n        this.lastPanic = undefined\n        logger('startin & resettin')\n        this.globalKillSignalReceived = undefined\n\n        if (this.useUds) {\n          this.socketPath = `/tmp/prisma-${getRandomString()}.sock`\n          socketPaths.push(this.socketPath)\n        }\n\n        debug({ cwd: this.cwd })\n\n        const prismaPath = await this.getPrismaPath()\n\n        const debugFlag = this.enableEngineDebugMode ? ['--debug'] : []\n\n        const flags = [...debugFlag, '--enable-raw-queries', ...this.flags]\n\n        if (this.useUds) {\n          flags.push('--unix-path', this.socketPath!)\n        } else {\n          this.port = await this.getFreePort()\n          flags.push('--port', String(this.port))\n        }\n\n        debug({ flags })\n\n        const env = this.getEngineEnvVars()\n\n        this.child = spawn(prismaPath, flags, {\n          env,\n          cwd: this.cwd,\n          windowsHide: true,\n          stdio: ['ignore', 'pipe', 'pipe'],\n        })\n\n        byline(this.child.stderr).on('data', (msg) => {\n          const data = String(msg)\n          debug('stderr', data)\n\n          try {\n            const json = JSON.parse(data)\n            if (typeof json.is_panic !== 'undefined') {\n              debug(json)\n              this.setError(json)\n              if (this.engineStartDeferred) {\n                const err = new PrismaClientInitializationError(\n                  json.message,\n                  this.clientVersion!,\n                )\n                this.engineStartDeferred.reject(err)\n              }\n            }\n          } catch (e) {\n            if (\n              !data.includes('Printing to stderr') &&\n              !data.includes('Listening on ')\n            ) {\n              this.stderrLogs += '\\n' + data\n            }\n          }\n        })\n\n        byline(this.child.stdout).on('data', (msg) => {\n          const data = String(msg)\n          try {\n            const json = JSON.parse(data)\n            debug('stdout', getMessage(json))\n            if (\n              this.engineStartDeferred &&\n              json.level === 'INFO' &&\n              json.target === 'query_engine::server' &&\n              json.fields?.message?.startsWith('Started http server')\n            ) {\n              if (this.useUds) {\n                this.connection.open('http://localhost', {\n                  socketPath: this.socketPath,\n                })\n              } else {\n                this.connection.open(`http://localhost:${this.port}`)\n              }\n              this.engineStartDeferred.resolve()\n              this.engineStartDeferred = undefined\n            }\n\n            // only emit logs, if they're in the from of a log\n            // they could also be a RustError, which has is_panic\n            // these logs can still include error logs\n            if (typeof json.is_panic === 'undefined') {\n              const log = convertLog(json)\n              // boolean cast needed, because of TS. We return ` is RustLog`, useful in other context, but not here\n              const logIsRustErrorLog: boolean = isRustErrorLog(log)\n              if (logIsRustErrorLog) {\n                this.setError(log)\n              } else {\n                this.logEmitter.emit(log.level, log)\n              }\n            } else {\n              this.setError(json)\n            }\n          } catch (e) {\n            debug(e, data)\n          }\n        })\n\n        this.child.on('exit', (code): void => {\n          logger('removing startPromise')\n          this.startPromise = undefined\n          if (this.engineStopDeferred) {\n            this.engineStopDeferred.resolve(code)\n            return\n          }\n          this.connection.close()\n\n          // don't error in restarts\n          if (code !== 0 && this.engineStartDeferred && this.startCount === 1) {\n            let err\n            let msg = this.stderrLogs\n            if (this.lastRustError) {\n              msg = getMessage(this.lastRustError)\n            } else if (this.lastErrorLog) {\n              msg = getMessage(this.lastErrorLog)\n            }\n            if (code !== null) {\n              err = new PrismaClientInitializationError(\n                `Query engine exited with code ${code}\\n` + msg,\n                this.clientVersion!,\n              )\n            } else if (this.child?.signalCode) {\n              err = new PrismaClientInitializationError(\n                `Query engine process killed with signal ${this.child.signalCode} for unknown reason.\nMake sure that the engine binary at ${prismaPath} is not corrupt.\\n` + msg,\n                this.clientVersion!,\n              )\n            } else {\n              err = new PrismaClientInitializationError(\n                msg,\n                this.clientVersion!,\n              )\n            }\n\n            this.engineStartDeferred.reject(err)\n          }\n          if (!this.child) {\n            return\n          }\n          if (this.lastRustError) {\n            return\n          }\n          if (code === 126) {\n            this.setError({\n              timestamp: new Date(),\n              target: 'exit',\n              level: 'error',\n              fields: {\n                message: `Couldn't start query engine as it's not executable on this operating system.\nYou very likely have the wrong \"binaryTarget\" defined in the schema.prisma file.`,\n              },\n            })\n          }\n        })\n\n        this.child.on('error', (err): void => {\n          this.setError({\n            message: err.message,\n            backtrace: 'Could not start query engine',\n            is_panic: false,\n          })\n          reject(err)\n        })\n\n        this.child.on('close', (code, signal): void => {\n          this.connection.close()\n          if (code === null && signal === 'SIGABRT' && this.child) {\n            const error = new PrismaClientRustPanicError(\n              this.getErrorMessageWithLink(\n                'Panic in Query Engine with SIGABRT signal',\n              ),\n              this.clientVersion!,\n            )\n            this.logEmitter.emit('error', error)\n          } else if (\n            code === 255 &&\n            signal === null &&\n            // if there is a \"this.lastPanic\", the panic has already been handled, so we don't need\n            // to look into it anymore\n            this.lastErrorLog?.fields.message === 'PANIC' &&\n            !this.lastPanic\n          ) {\n            const error = new PrismaClientRustPanicError(\n              this.getErrorMessageWithLink(\n                `${this.lastErrorLog.fields.message}: ${this.lastErrorLog.fields.reason} in ${this.lastErrorLog.fields.file}:${this.lastErrorLog.fields.line}:${this.lastErrorLog.fields.column}`,\n              ),\n              this.clientVersion!,\n            )\n            this.setError(error)\n          }\n        })\n\n        if (this.lastRustError) {\n          return reject(\n            new PrismaClientInitializationError(\n              getMessage(this.lastRustError),\n              this.clientVersion!,\n            ),\n          )\n        }\n\n        if (this.lastErrorLog) {\n          return reject(\n            new PrismaClientInitializationError(\n              getMessage(this.lastErrorLog),\n              this.clientVersion!,\n            ),\n          )\n        }\n\n        try {\n          await new Promise<void>((resolve, reject) => {\n            this.engineStartDeferred = { resolve, reject }\n          })\n        } catch (err) {\n          this.child?.kill()\n          throw err\n        }\n\n        // don't wait for this\n        void (async () => {\n          try {\n            const engineVersion = await this.version(true)\n            debug(`Client Version: ${this.clientVersion}`)\n            debug(`Engine Version: ${engineVersion}`)\n            debug(`Active provider: ${this.activeProvider}`)\n          } catch (e) {\n            debug(e)\n          }\n        })()\n\n        this.stopPromise = undefined\n        resolve()\n      } catch (e) {\n        reject(e)\n      }\n    })\n  }\n\n  async stop(): Promise<void> {\n    if (!this.stopPromise) {\n      this.stopPromise = this._stop()\n    }\n\n    return this.stopPromise\n  }\n\n  /**\n   * If Prisma runs, stop it\n   */\n  async _stop(): Promise<void> {\n    if (this.startPromise) {\n      await this.startPromise\n    }\n    // not sure yet if this is a good idea\n    await new Promise((resolve) => process.nextTick(resolve))\n    if (this.currentRequestPromise) {\n      try {\n        await this.currentRequestPromise\n      } catch (e) {\n        //\n      }\n    }\n    this.getConfigPromise = undefined\n    let stopChildPromise\n    if (this.child) {\n      debug(`Stopping Prisma engine4`)\n      if (this.startPromise) {\n        debug(`Waiting for start promise`)\n        await this.startPromise\n      }\n      debug(`Done waiting for start promise`)\n      stopChildPromise = new Promise((resolve, reject) => {\n        this.engineStopDeferred = { resolve, reject }\n      })\n      this.connection.close()\n      this.child?.kill()\n      this.child = undefined\n    }\n    if (stopChildPromise) {\n      await stopChildPromise\n    }\n    await new Promise((r) => process.nextTick(r))\n    this.startPromise = undefined\n    this.engineStopDeferred = undefined\n  }\n\n  kill(signal: string): void {\n    this.getConfigPromise = undefined\n    this.globalKillSignalReceived = signal\n    this.child?.kill()\n    this.connection.close()\n  }\n\n  /**\n   * Use the port 0 trick to get a new port\n   */\n  private getFreePort(): Promise<number> {\n    return new Promise((resolve, reject) => {\n      const server = net.createServer((s) => s.end(''))\n      server.unref()\n      server.on('error', reject)\n      server.listen(0, () => {\n        const address = server.address()\n        const port =\n          typeof address === 'string'\n            ? parseInt(address.split(':').slice(-1)[0], 10)\n            : address!.port\n        server.close((e) => {\n          if (e) {\n            reject(e)\n          }\n          resolve(port)\n        })\n      })\n    })\n  }\n\n  async getConfig(): Promise<GetConfigResult> {\n    if (!this.getConfigPromise) {\n      this.getConfigPromise = this._getConfig()\n    }\n    return this.getConfigPromise\n  }\n\n  private async _getConfig(): Promise<GetConfigResult> {\n    const prismaPath = await this.getPrismaPath()\n\n    const env = await this.getEngineEnvVars()\n\n    const result = await execa(prismaPath, ['cli', 'get-config'], {\n      env: omit(env, ['PORT']),\n      cwd: this.cwd,\n    })\n\n    return JSON.parse(result.stdout)\n  }\n\n  async version(forceRun = false) {\n    if (this.versionPromise && !forceRun) {\n      return this.versionPromise\n    }\n    this.versionPromise = this.internalVersion()\n    return this.versionPromise\n  }\n\n  async internalVersion() {\n    const prismaPath = await this.getPrismaPath()\n\n    const result = await execa(prismaPath, ['--version'])\n\n    this.lastVersion = result.stdout\n    return this.lastVersion\n  }\n\n  async request<T>(\n    query: string,\n    headers: QueryEngineRequestHeaders = {},\n    numTry = 1,\n  ): Promise<QueryEngineResult<T>> {\n    await this.start()\n\n    this.currentRequestPromise = this.connection.post(\n      '/',\n      stringifyQuery(query),\n      runtimeHeadersToHttpHeaders(headers),\n    )\n    this.lastQuery = query\n\n    try {\n      const { data, headers } = await this.currentRequestPromise\n      if (data.errors) {\n        if (data.errors.length === 1) {\n          throw this.graphQLToJSError(data.errors[0])\n        }\n        // this case should not happen, as the query engine only returns one error\n        throw new PrismaClientUnknownRequestError(\n          JSON.stringify(data.errors),\n          this.clientVersion!,\n        )\n      }\n\n      // Rust engine returns time in microseconds and we want it in miliseconds\n      const elapsed = parseInt(headers['x-elapsed']) / 1000\n\n      // reset restart count after successful request\n      if (this.startCount > 0) {\n        this.startCount = 0\n      }\n\n      this.currentRequestPromise = undefined\n      return { data, elapsed } as any\n    } catch (error) {\n      logger('req - e', error)\n      if (error instanceof PrismaClientKnownRequestError) {\n        throw error\n      }\n\n      await this.handleRequestError(error, numTry <= MAX_REQUEST_RETRIES)\n      // retry\n      if (numTry <= MAX_REQUEST_RETRIES) {\n        logger('trying a retry now')\n        return this.request(query, headers, numTry + 1)\n      }\n    }\n\n    return null as any // needed to make TS happy\n  }\n\n  async requestBatch<T>(\n    queries: string[],\n    headers: QueryEngineRequestHeaders = {},\n    transaction = false,\n    numTry = 1,\n  ): Promise<QueryEngineResult<T>[]> {\n    await this.start()\n\n    const request = {\n      batch: queries.map((query) => ({ query, variables: {} })),\n      transaction,\n    }\n\n    this.lastQuery = JSON.stringify(request)\n    this.currentRequestPromise = this.connection.post(\n      '/',\n      this.lastQuery,\n      runtimeHeadersToHttpHeaders(headers),\n    )\n\n    return this.currentRequestPromise\n      .then(({ data, headers }) => {\n        // Rust engine returns time in microseconds and we want it in miliseconds\n        const elapsed = parseInt(headers['x-elapsed']) / 1000\n        const { batchResult, errors } = data\n        if (Array.isArray(batchResult)) {\n          return batchResult.map((result) => {\n            if (result.errors) {\n              throw this.graphQLToJSError(result.errors[0])\n            }\n            return {\n              data: result,\n              elapsed,\n            }\n          })\n        } else {\n          throw this.graphQLToJSError(errors[0])\n        }\n      })\n      .catch(async (e) => {\n        const isError = await this.handleRequestError(e, numTry < 3)\n        if (!isError) {\n          // retry\n          if (numTry <= MAX_REQUEST_RETRIES) {\n            return this.requestBatch(queries, headers, transaction, numTry + 1)\n          }\n        }\n\n        throw isError\n      })\n  }\n\n  /**\n   * Send START, COMMIT, or ROLLBACK to the Query Engine\n   * @param action START, COMMIT, or ROLLBACK\n   * @param options to change the default timeouts\n   * @param info transaction information for the QE\n   */\n  async transaction(action: 'start', options?: Tx.Options): Promise<Tx.Info>\n  async transaction(action: 'commit', info: Tx.Info): Promise<undefined>\n  async transaction(action: 'rollback', info: Tx.Info): Promise<undefined>\n  async transaction(action: any, arg?: any) {\n    await this.start()\n\n    try {\n      if (action === 'start') {\n        const jsonOptions = JSON.stringify({\n          max_wait: arg?.maxWait ?? 2000, // default\n          timeout: arg?.timeout ?? 5000, // default\n        })\n\n        const result = await Connection.onHttpError(\n          this.connection.post<Tx.Info>('/transaction/start', jsonOptions),\n          transactionHttpErrorHandler,\n        )\n\n        return result.data\n      } else if (action === 'commit') {\n        await Connection.onHttpError(\n          this.connection.post(`/transaction/${arg.id}/commit`),\n          transactionHttpErrorHandler,\n        )\n      } else if (action === 'rollback') {\n        await Connection.onHttpError(\n          this.connection.post(`/transaction/${arg.id}/rollback`),\n          transactionHttpErrorHandler,\n        )\n      }\n    } catch (error) {\n      this.setError(error)\n    }\n\n    return undefined\n  }\n\n  private get hasMaxRestarts() {\n    return this.startCount >= MAX_STARTS\n  }\n\n  /**\n   * If we have request errors like \"ECONNRESET\", we need to get the error from a\n   * different place, not the request itself. This different place can either be\n   * this.lastRustError or this.lastErrorLog\n   */\n  private throwAsyncErrorIfExists(forceThrow = false) {\n    logger('throwAsyncErrorIfExists', this.startCount, this.hasMaxRestarts)\n    if (this.lastRustError) {\n      const err = new PrismaClientRustPanicError(\n        this.getErrorMessageWithLink(getMessage(this.lastRustError)),\n        this.clientVersion!,\n      )\n      if (this.lastRustError.is_panic) {\n        this.lastPanic = err\n      }\n      if (this.hasMaxRestarts || forceThrow) {\n        throw err\n      }\n    }\n\n    if (this.lastErrorLog && isRustErrorLog(this.lastErrorLog)) {\n      const err = new PrismaClientUnknownRequestError(\n        this.getErrorMessageWithLink(getMessage(this.lastErrorLog)),\n        this.clientVersion!,\n      )\n\n      if (this.lastErrorLog?.fields?.message === 'PANIC') {\n        this.lastPanic = err\n      }\n\n      if (this.hasMaxRestarts || forceThrow) {\n        throw err\n      }\n    }\n  }\n\n  private getErrorMessageWithLink(title: string) {\n    return getErrorMessageWithLink({\n      platform: this.platform,\n      title,\n      version: this.clientVersion!,\n      engineVersion: this.lastVersion,\n      database: this.lastActiveProvider,\n      query: this.lastQuery!,\n    })\n  }\n\n  private handleRequestError = async (\n    error: Error & { code?: string },\n    graceful = false,\n  ) => {\n    debug({ error })\n    // if we are starting, wait for it before we handle any error\n    if (this.startPromise) {\n      await this.startPromise\n    }\n\n    this.throwAsyncErrorIfExists()\n\n    // A currentRequestPromise is only being canceled by the sendPanic function\n    if (this.currentRequestPromise?.isCanceled) {\n      this.throwAsyncErrorIfExists()\n    } else if (\n      // matching on all relevant error codes from\n      // https://github.com/nodejs/undici/blob/2.x/lib/core/errors.js\n      error.code === 'ECONNRESET' ||\n      error.code === 'ECONNREFUSED' ||\n      error.code === 'UND_ERR_CLOSED' ||\n      error.code === 'UND_ERR_SOCKET' ||\n      error.code === 'UND_ERR_DESTROYED' ||\n      error.code === 'UND_ERR_ABORTED' ||\n      error.message.toLowerCase().includes('client is destroyed') ||\n      error.message.toLowerCase().includes('other side closed') ||\n      error.message.toLowerCase().includes('the client is closed')\n    ) {\n      if (this.globalKillSignalReceived && !this.child?.connected) {\n        throw new PrismaClientUnknownRequestError(\n          `The Node.js process already received a ${this.globalKillSignalReceived} signal, therefore the Prisma query engine exited\nand your request can't be processed.\nYou probably have some open handle that prevents your process from exiting.\nIt could be an open http server or stream that didn't close yet.\nWe recommend using the \\`wtfnode\\` package to debug open handles.`,\n          this.clientVersion!,\n        )\n      }\n\n      this.throwAsyncErrorIfExists()\n\n      if (this.startCount > MAX_STARTS) {\n        // if we didn't throw yet, which is unlikely, we want to poll on stderr / stdout here\n        // to get an error first\n        for (let i = 0; i < 5; i++) {\n          await new Promise((r) => setTimeout(r, 50))\n          this.throwAsyncErrorIfExists(true)\n        }\n        throw new Error(`Query engine is trying to restart, but can't.\nPlease look into the logs or turn on the env var DEBUG=* to debug the constantly restarting query engine.`)\n      }\n    }\n\n    if (!graceful) {\n      this.throwAsyncErrorIfExists(true)\n      throw error\n    }\n\n    return false\n  }\n\n  private graphQLToJSError(\n    error: RequestError,\n  ): PrismaClientKnownRequestError | PrismaClientUnknownRequestError {\n    if (error.user_facing_error.error_code) {\n      return new PrismaClientKnownRequestError(\n        error.user_facing_error.message,\n        error.user_facing_error.error_code,\n        this.clientVersion!,\n        error.user_facing_error.meta,\n      )\n    }\n\n    return new PrismaClientUnknownRequestError(\n      error.user_facing_error.message,\n      this.clientVersion!,\n    )\n  }\n}\n\n// faster than creating a new object and JSON.stringify it all the time\nfunction stringifyQuery(q: string) {\n  return `{\"variables\":{},\"query\":${JSON.stringify(q)}}`\n}\n\nfunction hookProcess(handler: string, exit = false) {\n  process.once(handler as any, async () => {\n    for (const engine of engines) {\n      await engine.emitExit()\n      engine.kill(handler)\n    }\n    engines.splice(0, engines.length)\n\n    if (socketPaths.length > 0) {\n      for (const socketPath of socketPaths) {\n        try {\n          fs.unlinkSync(socketPath)\n        } catch (e) {\n          //\n        }\n      }\n    }\n\n    // only exit, if only we are listening\n    // if there is another listener, that other listener is responsible\n    if (exit && process.listenerCount(handler) === 0) {\n      process.exit()\n    }\n  })\n}\n\nlet hooksInitialized = false\nfunction initHooks() {\n  if (!hooksInitialized) {\n    hookProcess('beforeExit')\n    hookProcess('exit')\n    hookProcess('SIGINT', true)\n    hookProcess('SIGUSR1', true)\n    hookProcess('SIGUSR2', true)\n    hookProcess('SIGTERM', true)\n    hooksInitialized = true\n  }\n}\n\n/**\n * Decides how to handle error reponses for transactions\n * @param result\n */\nfunction transactionHttpErrorHandler<R>(result: Result<R>): never {\n  throw result.data\n}\n\n/**\n * Takes runtime data headers and turns it into QE HTTP headers\n * @param headers to transform\n * @returns\n */\nfunction runtimeHeadersToHttpHeaders(\n  headers: QueryEngineRequestHeaders,\n): IncomingHttpHeaders {\n  return Object.keys(headers).reduce((acc, runtimeHeaderKey) => {\n    let httpHeaderKey = runtimeHeaderKey\n\n    if (runtimeHeaderKey === 'transactionId') {\n      httpHeaderKey = 'X-transaction-id'\n    }\n    // if header key isn't changed, a copy happens\n\n    acc[httpHeaderKey] = headers[runtimeHeaderKey]\n\n    return acc\n  }, {} as IncomingHttpHeaders)\n}\n"],
  "mappings": "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",
  "names": []
}
