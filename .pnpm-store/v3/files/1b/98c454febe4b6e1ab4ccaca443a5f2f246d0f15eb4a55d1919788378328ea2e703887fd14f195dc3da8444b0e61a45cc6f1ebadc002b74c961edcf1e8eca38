{
  "version": 3,
  "sources": ["../src/getGenerators.ts"],
  "sourcesContent": ["import Debug from '@prisma/debug'\nimport {\n  fixBinaryTargets,\n  getOriginalBinaryTargetsValue,\n  printGeneratorConfig,\n} from '@prisma/engine-core'\nimport { enginesVersion, getCliQueryEngineBinaryType } from '@prisma/engines'\nimport {\n  BinaryDownloadConfiguration,\n  BinaryType,\n  download,\n  DownloadOptions,\n} from '@prisma/fetch-engine'\nimport {\n  BinaryPaths,\n  BinaryTargetsEnvValue,\n  EngineType,\n  GeneratorConfig,\n  GeneratorManifest,\n  GeneratorOptions,\n} from '@prisma/generator-helper'\nimport { getPlatform, Platform, platforms } from '@prisma/get-platform'\nimport chalk from 'chalk'\nimport fs from 'fs'\nimport makeDir from 'make-dir'\nimport pMap from 'p-map'\nimport path from 'path'\nimport { getConfig, getDMMF } from '.'\nimport { Generator } from './Generator'\nimport { engineVersions } from './getAllVersions'\nimport { pick } from './pick'\nimport {\n  GeneratorPaths,\n  predefinedGeneratorResolvers,\n} from './predefinedGeneratorResolvers'\nimport { resolveOutput } from './resolveOutput'\nimport { extractPreviewFeatures } from './utils/extractPreviewFeatures'\nimport { mapPreviewFeatures } from './utils/mapPreviewFeatures'\nimport { missingDatasource } from './utils/missingDatasource'\nimport {\n  missingModelMessage,\n  missingModelMessageMongoDB,\n} from './utils/missingGeneratorMessage'\nimport { mongoFeatureFlagMissingMessage } from './utils/mongoFeatureFlagMissingMessage'\nimport {\n  parseBinaryTargetsEnvValue,\n  parseEnvValue,\n} from './utils/parseEnvValue'\nimport { printConfigWarnings } from './utils/printConfigWarnings'\n\nconst debug = Debug('prisma:getGenerators')\n\nexport type ProviderAliases = { [alias: string]: GeneratorPaths }\n\ntype BinaryPathsOverride = {\n  [P in EngineType]?: string\n}\n\nexport type GetGeneratorOptions = {\n  schemaPath: string\n  providerAliases?: ProviderAliases\n  cliVersion?: string\n  version?: string\n  printDownloadProgress?: boolean\n  baseDir?: string // useful in tests to resolve the base dir from which `output` is resolved\n  overrideGenerators?: GeneratorConfig[]\n  skipDownload?: boolean\n  binaryPathsOverride?: BinaryPathsOverride\n}\n/**\n * Makes sure that all generators have the binaries they deserve and returns a\n * `Generator` class per generator defined in the schema.prisma file.\n * In other words, this is basically a generator factory function.\n * @param schemaPath Path to schema.prisma\n * @param aliases Aliases like `prisma-client-js` -> `node_modules/@prisma/client/generator-build/index.js`\n */\nexport async function getGenerators({\n  schemaPath,\n  providerAliases: aliases, // do you get the pun?\n  version,\n  cliVersion,\n  printDownloadProgress,\n  baseDir = path.dirname(schemaPath),\n  overrideGenerators,\n  skipDownload,\n  binaryPathsOverride,\n}: GetGeneratorOptions): Promise<Generator[]> {\n  if (!schemaPath) {\n    throw new Error(\n      `schemaPath for getGenerators got invalid value ${schemaPath}`,\n    )\n  }\n\n  if (!fs.existsSync(schemaPath)) {\n    throw new Error(`${schemaPath} does not exist`)\n  }\n  const platform = await getPlatform()\n\n  const queryEngineBinaryType = getCliQueryEngineBinaryType()\n\n  const queryEngineType = binaryTypeToEngineType(queryEngineBinaryType)\n  let prismaPath: string | undefined = binaryPathsOverride?.[queryEngineType]\n\n  // overwrite query engine if the version is provided\n  if (version && !prismaPath) {\n    const potentialPath = eval(`require('path').join(__dirname, '..')`)\n    // for pkg we need to make an exception\n    if (!potentialPath.startsWith('/snapshot/')) {\n      const downloadParams: DownloadOptions = {\n        binaries: {\n          [queryEngineBinaryType]: potentialPath,\n        },\n        binaryTargets: [platform],\n        showProgress: false,\n        version,\n        skipDownload,\n      }\n\n      const binaryPathsWithEngineType = await download(downloadParams)\n      prismaPath = binaryPathsWithEngineType[queryEngineBinaryType]![platform]\n    }\n  }\n\n  const datamodel = fs.readFileSync(schemaPath, 'utf-8')\n\n  const config = await getConfig({\n    datamodel,\n    datamodelPath: schemaPath,\n    prismaPath,\n    ignoreEnvVarErrors: true,\n  })\n\n  if (config.datasources.length === 0) {\n    throw new Error(missingDatasource)\n  }\n\n  printConfigWarnings(config.warnings)\n\n  // TODO: This needs a better abstraction, but we don't have any better right now\n  const previewFeatures = mapPreviewFeatures(extractPreviewFeatures(config))\n\n  const dmmf = await getDMMF({\n    datamodel,\n    datamodelPath: schemaPath,\n    prismaPath,\n    previewFeatures,\n  })\n\n  if (dmmf.datamodel.models.length === 0) {\n    // MongoDB needs extras for @id: @map(\"_id\") @db.ObjectId\n    if (config.datasources.some((d) => d.provider === 'mongodb')) {\n      throw new Error(missingModelMessageMongoDB)\n    }\n\n    throw new Error(missingModelMessage)\n  }\n\n  if (\n    config.datasources.some((d) => d.provider === 'mongodb') &&\n    !previewFeatures.includes('mongoDb')\n  ) {\n    throw new Error(mongoFeatureFlagMissingMessage)\n  }\n\n  const generatorConfigs = overrideGenerators || config.generators\n\n  await validateGenerators(generatorConfigs)\n\n  const runningGenerators: Generator[] = []\n  try {\n    // 1. Get all generators\n    const generators = await pMap(\n      generatorConfigs,\n      async (generator, index) => {\n        let generatorPath = parseEnvValue(generator.provider)\n        let paths: GeneratorPaths | undefined\n\n        // as of now mostly used by studio\n        const providerValue = parseEnvValue(generator.provider)\n        if (aliases && aliases[providerValue]) {\n          generatorPath = aliases[providerValue].generatorPath\n          paths = aliases[providerValue]\n        } else if (predefinedGeneratorResolvers[providerValue]) {\n          paths = await predefinedGeneratorResolvers[providerValue](\n            baseDir,\n            cliVersion,\n          )\n          generatorPath = paths.generatorPath\n        }\n\n        const generatorInstance = new Generator(\n          generatorPath,\n          generator,\n          paths?.isNode,\n        )\n\n        await generatorInstance.init()\n\n        // resolve output path\n        if (generator.output) {\n          generator.output = {\n            value: path.resolve(baseDir, parseEnvValue(generator.output)),\n            fromEnvVar: null,\n          }\n          generator.isCustomOutput = true\n        } else if (paths) {\n          generator.output = {\n            value: paths.outputPath,\n            fromEnvVar: null,\n          }\n        } else {\n          if (\n            !generatorInstance.manifest ||\n            !generatorInstance.manifest.defaultOutput\n          ) {\n            throw new Error(\n              `Can't resolve output dir for generator ${chalk.bold(\n                generator.name,\n              )} with provider ${chalk.bold(generator.provider)}.\nThe generator needs to either define the \\`defaultOutput\\` path in the manifest or you need to define \\`output\\` in the datamodel.prisma file.`,\n            )\n          }\n\n          generator.output = {\n            value: await resolveOutput({\n              defaultOutput: generatorInstance.manifest.defaultOutput,\n              baseDir,\n            }),\n            fromEnvVar: 'null',\n          }\n        }\n\n        const options: GeneratorOptions = {\n          datamodel,\n          datasources: config.datasources,\n          generator,\n          dmmf,\n          otherGenerators: skipIndex(generatorConfigs, index),\n          schemaPath,\n          version: version || enginesVersion, // this version makes no sense anymore and should be ignored\n        }\n\n        // we set the options here a bit later after instantiating the Generator,\n        // as we need the generator manifest to resolve the `output` dir\n        generatorInstance.setOptions(options)\n\n        runningGenerators.push(generatorInstance)\n\n        return generatorInstance\n      },\n      {\n        stopOnError: false, // needed so we can first make sure all generators are created properly, then cleaned up properly\n      },\n    )\n\n    // 2. Check, if all required generators are there.\n    // Generators can say in their \"requiresGenerators\" property in the manifest, which other generators they depend on\n    // This has mostly been introduced for 3rd party generators, which rely on `prisma-client-js`.\n    const generatorProviders: string[] = generatorConfigs.map((g) =>\n      parseEnvValue(g.provider),\n    )\n\n    for (const g of generators) {\n      if (\n        g?.manifest?.requiresGenerators &&\n        g?.manifest?.requiresGenerators.length > 0\n      ) {\n        for (const neededGenerator of g?.manifest?.requiresGenerators) {\n          if (!generatorProviders.includes(neededGenerator)) {\n            throw new Error(\n              `Generator \"${g.manifest.prettyName}\" requires generator \"${neededGenerator}\", but it is missing in your schema.prisma.\nPlease add it to your schema.prisma:\n\ngenerator gen {\n  provider = \"${neededGenerator}\"\n}\n`,\n            )\n          }\n        }\n      }\n    }\n\n    // 3. Download all binaries and binary targets needed\n\n    const neededVersions = Object.create(null)\n    for (const g of generators) {\n      if (\n        g.manifest?.requiresEngines &&\n        Array.isArray(g.manifest?.requiresEngines) &&\n        g.manifest.requiresEngines.length > 0\n      ) {\n        const neededVersion = getEngineVersionForGenerator(g.manifest, version)\n        if (!neededVersions[neededVersion]) {\n          neededVersions[neededVersion] = { engines: [], binaryTargets: [] }\n        }\n\n        for (const engine of g.manifest?.requiresEngines) {\n          if (!neededVersions[neededVersion].engines.includes(engine)) {\n            neededVersions[neededVersion].engines.push(engine)\n          }\n        }\n\n        const generatorBinaryTargets = g.options?.generator?.binaryTargets\n\n        if (generatorBinaryTargets && generatorBinaryTargets.length > 0) {\n          const binaryTarget0 = generatorBinaryTargets[0]\n          // If set from env var, there is only one item\n          // and we need to read the env var\n          if (binaryTarget0.fromEnvVar !== null) {\n            const parsedBinaryTargetsEnvValue =\n              parseBinaryTargetsEnvValue(binaryTarget0)\n\n            // remove item and replace with parsed values\n            // value is an array\n            // so we create one new iteam for each element in the array\n            generatorBinaryTargets.shift()\n\n            if (Array.isArray(parsedBinaryTargetsEnvValue)) {\n              for (const platformName of parsedBinaryTargetsEnvValue) {\n                generatorBinaryTargets.push({\n                  fromEnvVar: binaryTarget0.fromEnvVar,\n                  value: platformName,\n                })\n              }\n            } else {\n              generatorBinaryTargets.push({\n                fromEnvVar: binaryTarget0.fromEnvVar,\n                value: parsedBinaryTargetsEnvValue,\n              })\n            }\n          }\n\n          for (const binaryTarget of generatorBinaryTargets) {\n            if (binaryTarget.value === 'native') {\n              binaryTarget.value = platform\n            }\n\n            if (\n              !neededVersions[neededVersion].binaryTargets.find(\n                (object) => object.value === binaryTarget.value,\n              )\n            ) {\n              neededVersions[neededVersion].binaryTargets.push(binaryTarget)\n            }\n          }\n        }\n      }\n    }\n    debug('neededVersions', JSON.stringify(neededVersions, null, 2))\n    const binaryPathsByVersion = await getBinaryPathsByVersion({\n      neededVersions,\n      platform,\n      version,\n      printDownloadProgress,\n      skipDownload,\n      binaryPathsOverride,\n    })\n    for (const generator of generators) {\n      if (generator.manifest && generator.manifest.requiresEngines) {\n        const engineVersion = getEngineVersionForGenerator(\n          generator.manifest,\n          version,\n        )\n        const binaryPaths = binaryPathsByVersion[engineVersion]\n        // pick only the engines that we need for this generator\n        const generatorBinaryPaths = pick(\n          binaryPaths,\n          generator.manifest.requiresEngines,\n        )\n        debug({ generatorBinaryPaths })\n        generator.setBinaryPaths(generatorBinaryPaths)\n\n        // in case cli engine version !== client engine version\n        // we need to re-generate the dmmf and pass it in to the generator\n        if (\n          engineVersion !== version &&\n          generator.options &&\n          generator.manifest.requiresEngines.includes(queryEngineType) &&\n          generatorBinaryPaths[queryEngineType] &&\n          generatorBinaryPaths[queryEngineType]?.[platform]\n        ) {\n          const customDmmf = await getDMMF({\n            datamodel,\n            datamodelPath: schemaPath,\n            prismaPath: generatorBinaryPaths[queryEngineType]?.[platform],\n            previewFeatures,\n          })\n          const options = { ...generator.options, dmmf: customDmmf }\n          debug('generator.manifest.prettyName', generator.manifest.prettyName)\n          debug('options', options)\n          debug(\n            'options.generator.binaryTargets',\n            options.generator.binaryTargets,\n          )\n          generator.setOptions(options)\n        }\n      }\n    }\n\n    return generators\n  } catch (e) {\n    // make sure all generators that are already running are being stopped\n    runningGenerators.forEach((g) => g.stop())\n    throw e\n  }\n}\n\ntype NeededVersions = {\n  [key: string]: {\n    engines: EngineType[]\n    binaryTargets: BinaryTargetsEnvValue[]\n  }\n}\n\ntype GetBinaryPathsByVersionInput = {\n  neededVersions: NeededVersions\n  platform: Platform\n  version?: string\n  printDownloadProgress?: boolean\n  skipDownload?: boolean\n  binaryPathsOverride?: BinaryPathsOverride\n}\n\nasync function getBinaryPathsByVersion({\n  neededVersions,\n  platform,\n  version,\n  printDownloadProgress,\n  skipDownload,\n  binaryPathsOverride,\n}: GetBinaryPathsByVersionInput): Promise<Record<string, BinaryPaths>> {\n  const binaryPathsByVersion: Record<string, BinaryPaths> = Object.create(null)\n\n  // make sure, that at least the current platform is being fetched\n  for (const currentVersion in neededVersions) {\n    binaryPathsByVersion[currentVersion] = {}\n\n    // ensure binaryTargets are set correctly\n    const neededVersion = neededVersions[currentVersion]\n\n    if (neededVersion.binaryTargets.length === 0) {\n      neededVersion.binaryTargets = [{ fromEnvVar: null, value: platform }]\n    }\n\n    if (\n      process.env.NETLIFY &&\n      !neededVersion.binaryTargets.find(\n        (object) => object.value === 'rhel-openssl-1.0.x',\n      )\n    ) {\n      neededVersion.binaryTargets.push({\n        fromEnvVar: null,\n        value: 'rhel-openssl-1.0.x',\n      })\n    }\n\n    // download\n    let binaryTargetBaseDir = eval(`require('path').join(__dirname, '..')`)\n\n    if (version !== currentVersion) {\n      binaryTargetBaseDir = path.join(\n        binaryTargetBaseDir,\n        `./engines/${currentVersion}/`,\n      )\n      await makeDir(binaryTargetBaseDir).catch((e) => console.error(e))\n    }\n\n    const binariesConfig: BinaryDownloadConfiguration =\n      neededVersion.engines.reduce((acc, curr) => {\n        // only download the binary, of not already covered by the `binaryPathsOverride`\n        if (!binaryPathsOverride?.[curr]) {\n          acc[engineTypeToBinaryType(curr)] = binaryTargetBaseDir\n        }\n        return acc\n      }, Object.create(null))\n\n    if (Object.values(binariesConfig).length > 0) {\n      // Convert BinaryTargetsEnvValue[] to Platform[]\n      const platforms: Platform[] = neededVersion.binaryTargets.map(\n        (binaryTarget: BinaryTargetsEnvValue) => binaryTarget.value as Platform,\n      )\n\n      const downloadParams: DownloadOptions = {\n        binaries: binariesConfig,\n        binaryTargets: platforms,\n        showProgress:\n          typeof printDownloadProgress === 'boolean'\n            ? printDownloadProgress\n            : true,\n        version:\n          currentVersion && currentVersion !== 'latest'\n            ? currentVersion\n            : enginesVersion,\n        skipDownload,\n      }\n\n      const binaryPathsWithEngineType = await download(downloadParams)\n      const binaryPaths: BinaryPaths = mapKeys(\n        binaryPathsWithEngineType,\n        binaryTypeToEngineType,\n      )\n      binaryPathsByVersion[currentVersion] = binaryPaths\n    }\n\n    if (binaryPathsOverride) {\n      const overrideEngines = Object.keys(binaryPathsOverride)\n      const enginesCoveredByOverride = neededVersion.engines.filter((engine) =>\n        overrideEngines.includes(engine),\n      )\n      if (enginesCoveredByOverride.length > 0) {\n        for (const engine of enginesCoveredByOverride) {\n          const enginePath = binaryPathsOverride[engine]!\n          binaryPathsByVersion[currentVersion][engine] = {\n            [platform]: enginePath,\n          }\n        }\n      }\n    }\n  }\n\n  return binaryPathsByVersion\n}\n\n/**\n * Shortcut for getGenerators, if there is only one generator defined. Useful for testing.\n * @param schemaPath path to schema.prisma\n * @param aliases Aliases like `photonjs` -> `node_modules/photonjs/gen.js`\n * @param version Version of the binary, commit hash of https://github.com/prisma/prisma-engine/commits/master\n * @param printDownloadProgress `boolean` to print download progress or not\n */\nexport async function getGenerator(\n  options: GetGeneratorOptions,\n): Promise<Generator> {\n  const generators = await getGenerators(options)\n  return generators[0]\n}\n\nexport function skipIndex<T = any>(arr: T[], index: number): T[] {\n  return [...arr.slice(0, index), ...arr.slice(index + 1)]\n}\n\nexport const knownBinaryTargets: Platform[] = [...platforms, 'native']\n\nconst oldToNewBinaryTargetsMapping = {\n  'linux-glibc-libssl1.0.1': 'debian-openssl-1.0.x',\n  'linux-glibc-libssl1.0.2': 'debian-openssl-1.0.x',\n  'linux-glibc-libssl1.1.0': 'debian-openssl1.1.x',\n}\n\nasync function validateGenerators(\n  generators: GeneratorConfig[],\n): Promise<void> {\n  const platform = await getPlatform()\n\n  for (const generator of generators) {\n    if (parseEnvValue(generator.provider) === 'photonjs') {\n      throw new Error(`Oops! Photon has been renamed to Prisma Client. Please make the following adjustments:\n  1. Rename ${chalk.red('provider = \"photonjs\"')} to ${chalk.green(\n        'provider = \"prisma-client-js\"',\n      )} in your ${chalk.bold('schema.prisma')} file.\n  2. Replace your ${chalk.bold('package.json')}'s ${chalk.red(\n        '@prisma/photon',\n      )} dependency to ${chalk.green('@prisma/client')}\n  3. Replace ${chalk.red(\n    \"import { Photon } from '@prisma/photon'\",\n  )} with ${chalk.green(\n        \"import { PrismaClient } from '@prisma/client'\",\n      )} in your code.\n  4. Run ${chalk.green('prisma generate')} again.\n      `)\n    }\n\n    if (generator.config.platforms) {\n      throw new Error(\n        `The \\`platforms\\` field on the generator definition is deprecated. Please rename it to \\`binaryTargets\\`.`,\n      )\n    }\n\n    if (generator.config.pinnedBinaryTargets) {\n      throw new Error(\n        `The \\`pinnedBinaryTargets\\` field on the generator definition is deprecated.\nPlease use the PRISMA_QUERY_ENGINE_BINARY env var instead to pin the binary target.`,\n      )\n    }\n\n    if (generator.binaryTargets) {\n      const binaryTargets =\n        generator.binaryTargets && generator.binaryTargets.length > 0\n          ? generator.binaryTargets\n          : [{ fromEnvVar: null, value: 'native' }]\n\n      const resolvedBinaryTargets: string[] = binaryTargets\n        .flatMap((object) => parseBinaryTargetsEnvValue(object))\n        .map((p) => (p === 'native' ? platform : p))\n\n      for (const resolvedBinaryTarget of resolvedBinaryTargets) {\n        if (oldToNewBinaryTargetsMapping[resolvedBinaryTarget]) {\n          throw new Error(\n            `Binary target ${chalk.red.bold(\n              resolvedBinaryTarget,\n            )} is deprecated. Please use ${chalk.green.bold(\n              oldToNewBinaryTargetsMapping[resolvedBinaryTarget],\n            )} instead.`,\n          )\n        }\n        if (!knownBinaryTargets.includes(resolvedBinaryTarget as Platform)) {\n          throw new Error(\n            `Unknown binary target ${chalk.red(\n              resolvedBinaryTarget,\n            )} in generator ${chalk.bold(generator.name)}.\nPossible binaryTargets: ${chalk.greenBright(knownBinaryTargets.join(', '))}`,\n          )\n        }\n      }\n\n      // Only show warning if resolvedBinaryTargets\n      // is missing current platform\n      if (!resolvedBinaryTargets.includes(platform)) {\n        const originalBinaryTargetsConfig = getOriginalBinaryTargetsValue(\n          generator.binaryTargets,\n        )\n\n        if (generator) {\n          console.log(`${chalk.yellow(\n            'Warning:',\n          )} Your current platform \\`${chalk.bold(\n            platform,\n          )}\\` is not included in your generator's \\`binaryTargets\\` configuration ${JSON.stringify(\n            originalBinaryTargetsConfig,\n          )}.\n    To fix it, use this generator config in your ${chalk.bold('schema.prisma')}:\n    ${chalk.greenBright(\n      printGeneratorConfig({\n        ...generator,\n        binaryTargets: fixBinaryTargets(generator.binaryTargets, platform),\n      }),\n    )}\n    ${chalk.gray(\n      `Note, that by providing \\`native\\`, Prisma Client automatically resolves \\`${platform}\\`.\n    Read more about deploying Prisma Client: ${chalk.underline(\n      'https://github.com/prisma/prisma/blob/main/docs/core/generators/prisma-client-js.md',\n    )}`,\n    )}\\n`)\n        } else {\n          console.log(\n            `${chalk.yellow('Warning')} The binaryTargets ${JSON.stringify(\n              originalBinaryTargetsConfig,\n            )} don't include your local platform ${platform}, which you can also point to with \\`native\\`.\n    In case you want to fix this, you can provide ${chalk.greenBright(\n      `binaryTargets: ${JSON.stringify(['native', ...(binaryTargets || [])])}`,\n    )} in the schema.prisma file.`,\n          )\n        }\n      }\n    }\n  }\n}\n\nfunction engineTypeToBinaryType(engineType: EngineType): BinaryType {\n  if (engineType === 'introspectionEngine') {\n    return BinaryType.introspectionEngine\n  }\n\n  if (engineType === 'migrationEngine') {\n    return BinaryType.migrationEngine\n  }\n\n  if (engineType === 'queryEngine') {\n    return BinaryType.queryEngine\n  }\n  if (engineType === 'libqueryEngine') {\n    return BinaryType.libqueryEngine\n  }\n  if (engineType === 'prismaFmt') {\n    return BinaryType.prismaFmt\n  }\n\n  throw new Error(`Could not convert engine type ${engineType}`)\n}\n\nfunction binaryTypeToEngineType(binaryType: string): EngineType {\n  if (binaryType === BinaryType.introspectionEngine) {\n    return 'introspectionEngine'\n  }\n\n  if (binaryType === BinaryType.migrationEngine) {\n    return 'migrationEngine'\n  }\n  if (binaryType === BinaryType.libqueryEngine) {\n    return 'libqueryEngine'\n  }\n  if (binaryType === BinaryType.queryEngine) {\n    return 'queryEngine'\n  }\n\n  if (binaryType === BinaryType.prismaFmt) {\n    return 'prismaFmt'\n  }\n\n  throw new Error(`Could not convert binary type ${binaryType}`)\n}\n\nfunction mapKeys<T extends object>(\n  obj: T,\n  mapper: (key: keyof T) => string,\n): any {\n  return Object.entries(obj).reduce((acc, [key, value]) => {\n    acc[mapper(key as keyof T)] = value\n    return acc\n  }, {})\n}\n\nfunction getEngineVersionForGenerator(\n  manifest?: GeneratorManifest,\n  defaultVersion?: string | undefined,\n): string {\n  let neededVersion: string = manifest!.requiresEngineVersion!\n  if (manifest?.version && engineVersions[manifest?.version]) {\n    neededVersion = engineVersions[manifest?.version]\n  }\n  neededVersion = neededVersion ?? defaultVersion // default to CLI version otherwise, if not provided\n  return neededVersion ?? 'latest'\n}\n"],
  "mappings": "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",
  "names": []
}
