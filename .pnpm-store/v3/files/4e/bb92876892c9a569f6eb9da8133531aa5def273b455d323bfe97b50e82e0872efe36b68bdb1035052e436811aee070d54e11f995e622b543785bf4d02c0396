{"version":3,"sources":["../../src/swc/sources.ts"],"sourcesContent":["import glob from \"fast-glob\";\nimport slash from \"slash\";\nimport { stat } from \"fs\";\nimport { join, basename, extname } from \"path\";\n\n/**\n * Find all input files based on source globs\n */\nexport async function globSources(\n  sources: string[],\n  includeDotfiles = false\n): Promise<string[]> {\n  const globConfig = {\n    dot: includeDotfiles,\n    nodir: true,\n  };\n\n  const files = await Promise.all(\n    sources\n      .filter(source => includeDotfiles || !basename(source).startsWith(\".\"))\n      .map(source => {\n        return new Promise<string[]>(resolve => {\n          stat(source, (err, stat) => {\n            if (err) {\n              resolve([]);\n              return;\n            }\n            if (!stat.isDirectory()) {\n              resolve([source]);\n            } else {\n              glob(slash(join(source, \"**\")), globConfig)\n                .then(matches => resolve(matches))\n                .catch(() => resolve([]));\n            }\n          });\n        });\n      })\n  );\n\n  return Array.from(new Set<string>(files.flat()));\n}\n\ntype Split = [compilable: string[], copyable: string[]];\n\n/**\n * Test if a filename ends with a compilable extension.\n */\nexport function isCompilableExtension(\n  filename: string,\n  allowedExtension: string[]\n): boolean {\n  const ext = extname(filename);\n  return allowedExtension.includes(ext);\n}\n\n/**\n * Split file list to files that can be compiled and copied\n */\nexport function splitCompilableAndCopyable(\n  files: string[],\n  allowedExtension: string[],\n  copyFiles: boolean\n): Split {\n  const compilable: string[] = [];\n  const copyable: string[] = [];\n\n  for (const file of files) {\n    const isCompilable = isCompilableExtension(file, allowedExtension);\n\n    if (isCompilable) {\n      compilable.push(file);\n    } else if (copyFiles) {\n      copyable.push(file);\n    }\n  }\n\n  return [compilable, copyable];\n}\n\nexport async function requireChokidar() {\n  try {\n    const { default: chokidar } = await import(\"chokidar\");\n    return chokidar;\n  } catch (err) {\n    console.error(\n      \"The optional dependency chokidar is not installed and is required for \" +\n        \"--watch. Chokidar is likely not supported on your platform.\"\n    );\n    throw err;\n  }\n}\n\nexport async function watchSources(sources: string[], includeDotfiles = false) {\n  const chokidar = await requireChokidar();\n\n  return chokidar.watch(sources, {\n    ignored: includeDotfiles\n      ? undefined\n      : (filename: string) => basename(filename).startsWith(\".\"),\n    ignoreInitial: true,\n    awaitWriteFinish: {\n      stabilityThreshold: 50,\n      pollInterval: 10,\n    },\n  });\n}\n"],"names":["globSources","isCompilableExtension","splitCompilableAndCopyable","requireChokidar","watchSources","sources","includeDotfiles","globConfig","dot","nodir","files","Promise","all","filter","source","basename","startsWith","map","resolve","stat","err","isDirectory","glob","slash","join","then","matches","catch","Array","from","Set","flat","filename","allowedExtension","ext","extname","includes","copyFiles","compilable","copyable","file","isCompilable","push","default","chokidar","console","error","watch","ignored","undefined","ignoreInitial","awaitWriteFinish","stabilityThreshold","pollInterval"],"mappings":"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"}