{
  "version": 3,
  "sources": ["../../src/library/LibraryEngine.ts"],
  "sourcesContent": ["import Debug from '@prisma/debug'\nimport { getEnginesPath } from '@prisma/engines'\nimport {\n  getNodeAPIName,\n  getPlatform,\n  isNodeAPISupported,\n  Platform,\n  platforms,\n} from '@prisma/get-platform'\nimport chalk from 'chalk'\nimport EventEmitter from 'events'\nimport fs from 'fs'\nimport path from 'path'\nimport {\n  DatasourceOverwrite,\n  Engine,\n  EngineConfig,\n  EngineEventType,\n} from '../common/Engine'\nimport { RequestError } from '../common/errors/types/RequestError'\nimport { PrismaClientKnownRequestError } from '../common/errors/PrismaClientKnownRequestError'\nimport { PrismaClientInitializationError } from '../common/errors/PrismaClientInitializationError'\nimport { PrismaClientRustPanicError } from '../common/errors/PrismaClientRustPanicError'\nimport { PrismaClientUnknownRequestError } from '../common/errors/PrismaClientUnknownRequestError'\nimport { getErrorMessageWithLink } from '../common/errors/utils/getErrorMessageWithLink'\nimport {\n  ConfigMetaFormat,\n  QueryEngineBatchRequest,\n  QueryEngineEvent,\n  QueryEngineLogLevel,\n  QueryEnginePanicEvent,\n  QueryEngineQueryEvent,\n  QueryEngineRequest,\n  QueryEngineRequestHeaders,\n  QueryEngineResult,\n  RustRequestError,\n  SyncRustError,\n} from '../common/types/QueryEngine'\nimport { QueryEngineInstance, QueryEngineConstructor } from './types/Library'\nimport { Library } from './types/Library'\nimport { printGeneratorConfig } from '../common/utils/printGeneratorConfig'\nimport { fixBinaryTargets } from '../common/utils/util'\nimport type * as Tx from '../common/types/Transaction'\n\nconst debug = Debug('prisma:client:libraryEngine')\n\nfunction isQueryEvent(event: QueryEngineEvent): event is QueryEngineQueryEvent {\n  return event['item_type'] === 'query' && 'query' in event\n}\nfunction isPanicEvent(event: QueryEngineEvent): event is QueryEnginePanicEvent {\n  return event.level === 'error' && event['message'] === 'PANIC'\n}\n\nconst knownPlatforms: Platform[] = [...platforms, 'native']\nconst engines: LibraryEngine[] = []\n\nexport class LibraryEngine extends Engine {\n  private engine?: QueryEngineInstance\n  private libraryInstantiationPromise?: Promise<void>\n  private libraryStartingPromise?: Promise<void>\n  private libraryStoppingPromise?: Promise<void>\n  private libraryStarted: boolean\n  private executingQueryPromise?: Promise<any>\n  private config: EngineConfig\n  private QueryEngineConstructor?: QueryEngineConstructor\n  private library?: Library\n  private logEmitter: EventEmitter\n  libQueryEnginePath?: string\n  platform?: Platform\n  datasourceOverrides: Record<string, string>\n  datamodel: string\n  logQueries: boolean\n  logLevel: QueryEngineLogLevel\n  lastQuery?: string\n  loggerRustPanic?: any\n\n  beforeExitListener?: (args?: any) => any\n  versionInfo?: {\n    commit: string\n    version: string\n  }\n\n  constructor(config: EngineConfig) {\n    super()\n\n    this.datamodel = fs.readFileSync(config.datamodelPath, 'utf-8')\n    this.config = config\n    this.libraryStarted = false\n    this.logQueries = config.logQueries ?? false\n    this.logLevel = config.logLevel ?? 'error'\n    this.logEmitter = new EventEmitter()\n    this.logEmitter.on('error', (e) => {\n      // to prevent unhandled error events\n    })\n    this.datasourceOverrides = config.datasources\n      ? this.convertDatasources(config.datasources)\n      : {}\n    if (config.enableEngineDebugMode) {\n      this.logLevel = 'debug'\n      // Debug.enable('*')\n    }\n    this.libraryInstantiationPromise = this.instantiateLibrary()\n\n    initHooks()\n    engines.push(this)\n    this.checkForTooManyEngines()\n  }\n  private checkForTooManyEngines() {\n    if (engines.length >= 10) {\n      const runningEngines = engines.filter((e) => e.engine)\n      if (runningEngines.length === 10) {\n        console.warn(\n          `${chalk.yellow(\n            'warn(prisma-client)',\n          )} Already 10 Prisma Clients are actively running.`,\n        )\n      }\n    }\n  }\n  async transaction(action: 'start', options?: Tx.Options): Promise<Tx.Info>\n  async transaction(action: 'commit', info: Tx.Info): Promise<undefined>\n  async transaction(action: 'rollback', info: Tx.Info): Promise<undefined>\n  async transaction(action: any, arg?: any) {\n    await this.start()\n\n    if (action === 'start') {\n      const jsonOptions = JSON.stringify({\n        max_wait: arg?.maxWait ?? 2000, // default\n        timeout: arg?.timeout ?? 5000, // default\n      })\n\n      const result = await this.engine?.startTransaction(jsonOptions, '{}')\n      return this.parseEngineResponse<Tx.Info>(result)\n    } else if (action === 'commit') {\n      await this.engine?.commitTransaction(arg.id, '{}')\n    } else if (action === 'rollback') {\n      await this.engine?.rollbackTransaction(arg.id, '{}')\n    }\n\n    return undefined\n  }\n\n  private async instantiateLibrary(): Promise<void> {\n    debug('internalSetup')\n    if (this.libraryInstantiationPromise) {\n      return this.libraryInstantiationPromise\n    }\n\n    await isNodeAPISupported()\n    this.platform = await this.getPlatform()\n    await this.loadEngine()\n    this.version()\n  }\n\n  private async getPlatform() {\n    if (this.platform) return this.platform\n    const platform = await getPlatform()\n    if (!knownPlatforms.includes(platform)) {\n      throw new PrismaClientInitializationError(\n        `Unknown ${chalk.red(\n          'PRISMA_QUERY_ENGINE_LIBRARY',\n        )} ${chalk.redBright.bold(\n          this.platform,\n        )}. Possible binaryTargets: ${chalk.greenBright(\n          knownPlatforms.join(', '),\n        )} or a path to the query engine library.\nYou may have to run ${chalk.greenBright(\n          'prisma generate',\n        )} for your changes to take effect.`,\n        this.config.clientVersion!,\n      )\n    }\n    return platform\n  }\n\n  private parseEngineResponse<T>(response?: string): T {\n    if (!response) {\n      throw new PrismaClientUnknownRequestError(\n        `Response from the Engine was empty`,\n        this.config.clientVersion!,\n      )\n    }\n    try {\n      const config = JSON.parse(response)\n      return config as T\n    } catch (err) {\n      throw new PrismaClientUnknownRequestError(\n        `Unable to JSON.parse response from engine`,\n        this.config.clientVersion!,\n      )\n    }\n  }\n\n  private convertDatasources(\n    datasources: DatasourceOverwrite[],\n  ): Record<string, string> {\n    const obj = Object.create(null)\n    for (const { name, url } of datasources) {\n      obj[name] = url\n    }\n    return obj\n  }\n\n  private async loadEngine(): Promise<void> {\n    if (!this.libQueryEnginePath) {\n      this.libQueryEnginePath = await this.getLibQueryEnginePath()\n    }\n    debug(`loadEngine using ${this.libQueryEnginePath}`)\n    if (!this.engine) {\n      if (!this.QueryEngineConstructor) {\n        try {\n          // this require needs to be resolved at runtime, tell webpack to ignore it\n          this.library = eval('require')(this.libQueryEnginePath) as Library\n          this.QueryEngineConstructor = this.library.QueryEngine\n        } catch (e) {\n          if (fs.existsSync(this.libQueryEnginePath)) {\n            if (this.libQueryEnginePath.endsWith('.node')) {\n              throw new PrismaClientInitializationError(\n                `Unable to load Node-API Library from ${chalk.dim(\n                  this.libQueryEnginePath,\n                )}, Library may be corrupt`,\n                this.config.clientVersion!,\n              )\n            } else {\n              throw new PrismaClientInitializationError(\n                `Expected an Node-API Library but received ${chalk.dim(\n                  this.libQueryEnginePath,\n                )}`,\n                this.config.clientVersion!,\n              )\n            }\n          } else {\n            throw new PrismaClientInitializationError(\n              `Unable to load Node-API Library from ${chalk.dim(\n                this.libQueryEnginePath,\n              )}, It does not exist`,\n              this.config.clientVersion!,\n            )\n          }\n        }\n      }\n      if (this.QueryEngineConstructor) {\n        try {\n          this.engine = new this.QueryEngineConstructor(\n            {\n              datamodel: this.datamodel,\n              env: process.env,\n              logQueries: this.config.logQueries ?? false,\n              ignoreEnvVarErrors: false,\n              datasourceOverrides: this.datasourceOverrides,\n              logLevel: this.logLevel,\n              configDir: this.config.cwd!,\n            },\n            (err, log) => this.logger(err, log),\n          )\n        } catch (e) {\n          const error = this.parseInitError(e.message)\n          if (typeof error === 'string') {\n            throw e\n          } else {\n            throw new PrismaClientInitializationError(\n              error.message,\n              this.config.clientVersion!,\n              error.error_code,\n            )\n          }\n        }\n      }\n    }\n  }\n\n  private logger(err: string, log: string) {\n    if (err) {\n      throw err\n    }\n    const event = this.parseEngineResponse<QueryEngineEvent | null>(log)\n    if (!event) return\n\n    event.level = event?.level.toLowerCase() ?? 'unknown'\n    if (isQueryEvent(event)) {\n      this.logEmitter.emit('query', {\n        timestamp: Date.now(),\n        query: event.query,\n        params: event.params,\n        duration: event.duration_ms,\n        target: event.module_path,\n      })\n    } else if (isPanicEvent(event)) {\n      this.loggerRustPanic = new PrismaClientRustPanicError(\n        this.getErrorMessageWithLink(\n          `${event.message}: ${event.reason} in ${event.file}:${event.line}:${event.column}`,\n        ),\n        this.config.clientVersion!,\n      )\n      this.logEmitter.emit('error', this.loggerRustPanic)\n    } else {\n      this.logEmitter.emit(event.level, event)\n    }\n  }\n\n  private getErrorMessageWithLink(title: string) {\n    return getErrorMessageWithLink({\n      platform: this.platform,\n      title,\n      version: this.config.clientVersion!,\n      engineVersion: this.versionInfo?.version,\n      database: this.config.activeProvider as any,\n      query: this.lastQuery!,\n    })\n  }\n\n  private parseInitError(str: string): SyncRustError | string {\n    try {\n      const error = JSON.parse(str)\n      if (typeof error.is_panic !== 'undefined') {\n        return error\n      }\n    } catch (e) {\n      //\n    }\n    return str\n  }\n\n  private parseRequestError(str: string): RustRequestError | string {\n    try {\n      const error = JSON.parse(str)\n      if (typeof error.is_panic !== 'undefined') {\n        return error\n      }\n    } catch (e) {\n      //\n    }\n    return str\n  }\n\n  on(event: EngineEventType, listener: (args?: any) => any): void {\n    if (event === 'beforeExit') {\n      this.beforeExitListener = listener\n    } else {\n      this.logEmitter.on(event, listener)\n    }\n  }\n\n  async runBeforeExit() {\n    debug('runBeforeExit')\n    if (this.beforeExitListener) {\n      try {\n        await this.beforeExitListener()\n      } catch (e) {\n        console.error(e)\n      }\n    }\n  }\n\n  async start(): Promise<void> {\n    await this.libraryInstantiationPromise\n    await this.libraryStoppingPromise\n    if (this.libraryStartingPromise) {\n      debug(\n        `library already starting, this.libraryStarted: ${this.libraryStarted}`,\n      )\n      await this.libraryStartingPromise\n      if (this.libraryStarted) {\n        return\n      }\n    }\n    if (!this.libraryStarted) {\n      // eslint-disable-next-line no-async-promise-executor\n      this.libraryStartingPromise = new Promise(async (res) => {\n        debug('library starting')\n        await this.engine?.connect({ enableRawQueries: true })\n        this.libraryStarted = true\n        debug('library started')\n        res()\n      })\n      return this.libraryStartingPromise\n    }\n  }\n\n  async stop(): Promise<void> {\n    await this.libraryStartingPromise\n    await this.executingQueryPromise\n    debug(`library stopping, this.libraryStarted: ${this.libraryStarted}`)\n    if (this.libraryStoppingPromise) {\n      debug('library is already disconnecting')\n      await this.libraryStoppingPromise\n      if (!this.libraryStarted) {\n        this.libraryStoppingPromise = undefined\n        return\n      }\n    }\n\n    if (this.libraryStarted) {\n      // eslint-disable-next-line no-async-promise-executor\n      this.libraryStoppingPromise = new Promise(async (res) => {\n        await new Promise((r) => setTimeout(r, 5))\n        debug('library stopping')\n        await this.engine?.disconnect()\n        this.libraryStarted = false\n        debug('library stopped')\n        res()\n      })\n    }\n    return this.libraryStoppingPromise\n  }\n\n  getConfig(): Promise<ConfigMetaFormat> {\n    return this.library!.getConfig({\n      datamodel: this.datamodel,\n      datasourceOverrides: this.datasourceOverrides,\n      ignoreEnvVarErrors: true,\n      env: process.env,\n    })\n  }\n\n  version(): string {\n    this.versionInfo = this.library?.version()\n    return this.versionInfo?.version ?? 'unknown'\n  }\n\n  private prismaGraphQLToJSError(\n    error: RequestError,\n  ): PrismaClientKnownRequestError | PrismaClientUnknownRequestError {\n    debug('graphQLToJSError')\n\n    if (error.user_facing_error.error_code) {\n      return new PrismaClientKnownRequestError(\n        error.user_facing_error.message,\n        error.user_facing_error.error_code,\n        this.config.clientVersion!,\n        error.user_facing_error.meta,\n      )\n    }\n\n    return new PrismaClientUnknownRequestError(\n      error.error,\n      this.config.clientVersion!,\n    )\n  }\n\n  async request<T>(\n    query: string,\n    headers: QueryEngineRequestHeaders = {},\n    numTry = 1,\n  ): Promise<{ data: T; elapsed: number }> {\n    try {\n      debug(`sending request, this.libraryStarted: ${this.libraryStarted}`)\n      const request: QueryEngineRequest = { query, variables: {} }\n      const queryStr = JSON.stringify(request)\n      const headerStr = JSON.stringify(headers)\n\n      await this.start()\n      this.executingQueryPromise = this.engine?.query(\n        queryStr,\n        headerStr,\n        headers.transactionId,\n      )\n\n      this.lastQuery = queryStr\n      const data = this.parseEngineResponse<any>(\n        await this.executingQueryPromise,\n      )\n\n      if (data.errors) {\n        if (data.errors.length === 1) {\n          throw this.prismaGraphQLToJSError(data.errors[0])\n        }\n        // this case should not happen, as the query engine only returns one error\n        throw new PrismaClientUnknownRequestError(\n          JSON.stringify(data.errors),\n          this.config.clientVersion!,\n        )\n      } else if (this.loggerRustPanic) {\n        throw this.loggerRustPanic\n      }\n      // TODO Implement Elapsed: https://github.com/prisma/prisma/issues/7726\n      return { data, elapsed: 0 }\n    } catch (e) {\n      const error = this.parseRequestError(e.message)\n      if (typeof error === 'string') {\n        throw e\n      } else {\n        throw new PrismaClientUnknownRequestError(\n          `${error.message}\\n${error.backtrace}`,\n          this.config.clientVersion!,\n        )\n      }\n    }\n  }\n\n  async requestBatch<T>(\n    queries: string[],\n    headers: QueryEngineRequestHeaders = {},\n    transaction = false,\n    numTry = 1,\n  ): Promise<QueryEngineResult<T>[]> {\n    debug('requestBatch')\n    const request: QueryEngineBatchRequest = {\n      batch: queries.map((query) => ({ query, variables: {} })),\n      transaction,\n    }\n    await this.start()\n\n    this.lastQuery = JSON.stringify(request)\n    this.executingQueryPromise = this.engine!.query(\n      this.lastQuery,\n      JSON.stringify(headers), // TODO these aren't headers on the engine side\n      headers.transactionId,\n    )\n    const result = await this.executingQueryPromise\n    const data = this.parseEngineResponse<any>(result)\n\n    if (data.errors) {\n      if (data.errors.length === 1) {\n        throw this.prismaGraphQLToJSError(data.errors[0])\n      }\n      // this case should not happen, as the query engine only returns one error\n      throw new PrismaClientUnknownRequestError(\n        JSON.stringify(data.errors),\n        this.config.clientVersion!,\n      )\n    }\n\n    const { batchResult, errors } = data\n    if (Array.isArray(batchResult)) {\n      return batchResult.map((result) => {\n        if (result.errors) {\n          return (\n            this.loggerRustPanic ??\n            this.prismaGraphQLToJSError(result.errors[0])\n          )\n        }\n        return {\n          data: result,\n          elapsed: 0, // TODO Implement Elapsed: https://github.com/prisma/prisma/issues/7726\n        }\n      })\n    } else {\n      if (errors && errors.length === 1) {\n        throw new Error(errors[0].error)\n      }\n      throw new Error(JSON.stringify(data))\n    }\n  }\n\n  private async resolveEnginePath(): Promise<{\n    enginePath: string\n    searchedLocations: string[]\n  }> {\n    const searchedLocations: string[] = []\n    let enginePath\n    if (this.libQueryEnginePath) {\n      return { enginePath: this.libQueryEnginePath, searchedLocations }\n    }\n\n    this.platform = this.platform ?? (await getPlatform())\n\n    if (__filename.includes('LibraryEngine')) {\n      enginePath = path.join(\n        getEnginesPath(),\n        getNodeAPIName(this.platform, 'fs'),\n      )\n      return { enginePath, searchedLocations }\n    }\n    const searchLocations: string[] = [\n      eval(`require('path').join(__dirname, '../../../.prisma/client')`), // Dot Prisma Path\n      this.config.generator?.output?.value ?? eval('__dirname'), // Custom Generator Path\n      path.join(eval('__dirname'), '..'), // parentDirName\n      path.dirname(this.config.datamodelPath), // Datamodel Dir\n      this.config.cwd, //cwdPath\n      '/tmp/prisma-engines',\n    ]\n\n    if (this.config.dirname) {\n      searchLocations.push(this.config.dirname)\n    }\n\n    for (const location of searchLocations) {\n      searchedLocations.push(location)\n      debug(`Search for Query Engine Library in ${location}`)\n      enginePath = path.join(location, getNodeAPIName(this.platform, 'fs'))\n      if (fs.existsSync(enginePath)) {\n        return { enginePath, searchedLocations }\n      }\n    }\n    enginePath = path.join(__dirname, getNodeAPIName(this.platform, 'fs'))\n\n    return { enginePath: enginePath ?? '', searchedLocations }\n  }\n\n  private async getLibQueryEnginePath(): Promise<string> {\n    // TODO Document ENV VAR\n    const libPath =\n      process.env.PRISMA_QUERY_ENGINE_LIBRARY ?? this.config.prismaPath\n    if (libPath && fs.existsSync(libPath) && libPath.endsWith('.node')) {\n      return libPath\n    }\n    this.platform = this.platform ?? (await getPlatform())\n    const { enginePath, searchedLocations } = await this.resolveEnginePath()\n    // If path to query engine doesn't exist, throw\n    if (!fs.existsSync(enginePath)) {\n      const incorrectPinnedPlatformErrorStr = this.platform\n        ? `\\nYou incorrectly pinned it to ${chalk.redBright.bold(\n            `${this.platform}`,\n          )}\\n`\n        : ''\n      // TODO Improve search engine logic possibly using findSync\n      let errorText = `Query engine library for current platform \"${chalk.bold(\n        this.platform,\n      )}\" could not be found.${incorrectPinnedPlatformErrorStr}\nThis probably happens, because you built Prisma Client on a different platform.\n(Prisma Client looked in \"${chalk.underline(enginePath)}\")\n\nSearched Locations:\n\n${searchedLocations\n  .map((f) => {\n    let msg = `  ${f}`\n    if (\n      process.env.DEBUG === 'node-engine-search-locations' &&\n      fs.existsSync(f)\n    ) {\n      const dir = fs.readdirSync(f)\n      msg += dir.map((d) => `    ${d}`).join('\\n')\n    }\n    return msg\n  })\n  .join(\n    '\\n' + (process.env.DEBUG === 'node-engine-search-locations' ? '\\n' : ''),\n  )}\\n`\n      // The generator should always be there during normal usage\n      if (this.config.generator) {\n        // The user already added it, but it still doesn't work \uD83E\uDD37\u200D\u2640\uFE0F\n        // That means, that some build system just deleted the files \uD83E\uDD14\n        this.platform = this.platform ?? (await getPlatform())\n        if (\n          this.config.generator.binaryTargets.find(\n            (object) => object.value === this.platform!,\n          ) ||\n          this.config.generator.binaryTargets.find(\n            (object) => object.value === 'native',\n          )\n        ) {\n          errorText += `\nYou already added the platform${\n            this.config.generator.binaryTargets.length > 1 ? 's' : ''\n          } ${this.config.generator.binaryTargets\n            .map((t) => `\"${chalk.bold(t.value)}\"`)\n            .join(', ')} to the \"${chalk.underline('generator')}\" block\nin the \"schema.prisma\" file as described in https://pris.ly/d/client-generator,\nbut something went wrong. That's suboptimal.\n\nPlease create an issue at https://github.com/prisma/prisma/issues/new`\n          errorText += ``\n        } else {\n          // If they didn't even have the current running platform in the schema.prisma file, it's easy\n          // Just add it\n          errorText += `\\n\\nTo solve this problem, add the platform \"${\n            this.platform\n          }\" to the \"${chalk.underline(\n            'binaryTargets',\n          )}\" attribute in the \"${chalk.underline(\n            'generator',\n          )}\" block in the \"schema.prisma\" file:\n${chalk.greenBright(this.getFixedGenerator())}\n\nThen run \"${chalk.greenBright(\n            'prisma generate',\n          )}\" for your changes to take effect.\nRead more about deploying Prisma Client: https://pris.ly/d/client-generator`\n        }\n      } else {\n        errorText += `\\n\\nRead more about deploying Prisma Client: https://pris.ly/d/client-generator\\n`\n      }\n\n      throw new PrismaClientInitializationError(\n        errorText,\n        this.config.clientVersion!,\n      )\n    }\n    this.platform = this.platform ?? (await getPlatform())\n    return enginePath\n  }\n\n  private getFixedGenerator(): string {\n    const fixedGenerator = {\n      ...this.config.generator!,\n      binaryTargets: fixBinaryTargets(\n        this.config.generator!.binaryTargets,\n        this.platform!,\n      ),\n    }\n\n    return printGeneratorConfig(fixedGenerator)\n  }\n}\n\nfunction hookProcess(handler: string, exit = false) {\n  process.once(handler as any, async () => {\n    debug(`hookProcess received: ${handler}`)\n    for (const engine of engines) {\n      await engine.runBeforeExit()\n    }\n    engines.splice(0, engines.length)\n    // only exit, if only we are listening\n    // if there is another listener, that other listener is responsible\n    if (exit && process.listenerCount(handler) === 0) {\n      process.exit()\n    }\n  })\n}\nlet hooksInitialized = false\nfunction initHooks() {\n  if (!hooksInitialized) {\n    hookProcess('beforeExit')\n    hookProcess('exit')\n    hookProcess('SIGINT', true)\n    hookProcess('SIGUSR1', true)\n    hookProcess('SIGUSR2', true)\n    hookProcess('SIGTERM', true)\n    hooksInitialized = true\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
