{
  "version": 3,
  "sources": ["../../src/cli/getSchema.ts"],
  "sourcesContent": ["import chalk from 'chalk'\nimport execa from 'execa'\nimport fs from 'fs'\nimport path from 'path'\nimport readPkgUp, { NormalizedPackageJson } from 'read-pkg-up'\nimport { promisify } from 'util'\n\nconst exists = promisify(fs.exists)\nconst readFile = promisify(fs.readFile)\n\n/**\n * Async\n */\n\nexport async function getSchemaPath(\n  schemaPathFromArgs?: string,\n  opts: { cwd: string } = {\n    cwd: process.cwd(),\n  },\n): Promise<string | null> {\n  return getSchemaPathInternal(schemaPathFromArgs, {\n    cwd: opts.cwd,\n  })\n}\n\nexport async function getSchemaPathInternal(\n  schemaPathFromArgs?: string,\n  opts: { cwd: string } = {\n    cwd: process.cwd(),\n  },\n): Promise<string | null> {\n  if (schemaPathFromArgs) {\n    // 1. try the user custom path\n    const customSchemaPath = await getAbsoluteSchemaPath(\n      path.resolve(schemaPathFromArgs),\n    )\n    if (!customSchemaPath) {\n      throw new Error(\n        `Provided --schema at ${schemaPathFromArgs} doesn't exist.`,\n      )\n    }\n\n    return customSchemaPath\n  }\n\n  // 2. Try the package.json `prisma.schema` custom path\n  // 3. Try the conventional ./schema.prisma or ./prisma/schema.prisma paths\n  // 4. Try resolving yarn workspaces and looking for a schema.prisma file there\n  const schemaPath =\n    (await getSchemaPathFromPackageJson(opts.cwd)) ??\n    (await getRelativeSchemaPath(opts.cwd)) ??\n    (await resolveYarnSchema(opts.cwd))\n\n  if (schemaPath) {\n    return schemaPath\n  }\n\n  return null\n}\n\nexport async function getSchemaPathFromPackageJson(\n  cwd: string,\n): Promise<string | null> {\n  const pkgJson = await readPkgUp({ cwd })\n  const schemaPathFromPkgJson = pkgJson?.packageJson?.prisma?.schema as unknown\n\n  if (!schemaPathFromPkgJson || !pkgJson) {\n    return null\n  }\n\n  if (typeof schemaPathFromPkgJson !== 'string') {\n    throw new Error(\n      `Provided schema path \\`${schemaPathFromPkgJson}\\` from \\`${path.relative(\n        cwd,\n        pkgJson.path,\n      )}\\` must be of type string`,\n    )\n  }\n\n  const absoluteSchemaPath = path.isAbsolute(schemaPathFromPkgJson)\n    ? schemaPathFromPkgJson\n    : path.resolve(path.dirname(pkgJson.path), schemaPathFromPkgJson)\n\n  if ((await exists(absoluteSchemaPath)) === false) {\n    throw new Error(\n      `Provided schema path \\`${path.relative(\n        cwd,\n        absoluteSchemaPath,\n      )}\\` from \\`${path.relative(cwd, pkgJson.path)}\\` doesn't exist.`,\n    )\n  }\n\n  return absoluteSchemaPath\n}\n\nasync function resolveYarnSchema(cwd: string): Promise<string | null> {\n  if (process.env.npm_config_user_agent?.includes('yarn')) {\n    try {\n      const { stdout: version } = await execa.command('yarn --version', {\n        cwd,\n      })\n\n      if (version.startsWith('2')) {\n        return null\n      }\n\n      const { stdout } = await execa.command('yarn workspaces info --json', {\n        cwd,\n      })\n      const json = getJson(stdout)\n      const workspaces = Object.values<{ location: string }>(json)\n      const workspaceRootDir = await findWorkspaceRoot(cwd)\n\n      if (!workspaceRootDir) {\n        return null\n      }\n\n      // Iterate over the workspaces\n      for (const workspace of workspaces) {\n        const workspacePath = path.join(workspaceRootDir, workspace.location)\n        const workspaceSchemaPath =\n          getSchemaPathFromPackageJsonSync(workspacePath) ??\n          getRelativeSchemaPathSync(workspacePath)\n\n        if (workspaceSchemaPath) {\n          return workspaceSchemaPath\n        }\n      }\n\n      const workspaceSchemaPathFromRoot =\n        getSchemaPathFromPackageJsonSync(workspaceRootDir) ??\n        getRelativeSchemaPathSync(workspaceRootDir)\n\n      if (workspaceSchemaPathFromRoot) {\n        return workspaceSchemaPathFromRoot\n      }\n    } catch (e) {\n      return null\n    }\n  }\n  return null\n}\n\nfunction resolveYarnSchemaSync(cwd: string): string | null {\n  if (process.env.npm_config_user_agent?.includes('yarn')) {\n    try {\n      const { stdout: version } = execa.commandSync('yarn --version', {\n        cwd,\n      })\n\n      if (version.startsWith('2')) {\n        return null\n      }\n\n      const { stdout } = execa.commandSync('yarn workspaces info --json', {\n        cwd,\n      })\n      const json = getJson(stdout)\n      const workspaces = Object.values<{ location: string }>(json)\n      const workspaceRootDir = findWorkspaceRootSync(cwd)\n\n      if (!workspaceRootDir) {\n        return null\n      }\n\n      // Iterate over the workspaces\n      for (const workspace of workspaces) {\n        const workspacePath = path.join(workspaceRootDir, workspace.location)\n        const workspaceSchemaPath =\n          getSchemaPathFromPackageJsonSync(workspacePath) ??\n          getRelativeSchemaPathSync(workspacePath)\n\n        if (workspaceSchemaPath) {\n          return workspaceSchemaPath\n        }\n      }\n\n      const workspaceSchemaPathFromRoot =\n        getSchemaPathFromPackageJsonSync(workspaceRootDir) ??\n        getRelativeSchemaPathSync(workspaceRootDir)\n\n      if (workspaceSchemaPathFromRoot) {\n        return workspaceSchemaPathFromRoot\n      }\n    } catch (e) {\n      return null\n    }\n  }\n  return null\n}\n\nasync function getAbsoluteSchemaPath(\n  schemaPath: string,\n): Promise<string | null> {\n  if (await exists(schemaPath)) {\n    return schemaPath\n  }\n\n  return null\n}\n\nexport async function getRelativeSchemaPath(\n  cwd: string,\n): Promise<string | null> {\n  let schemaPath = path.join(cwd, 'schema.prisma')\n  if (await exists(schemaPath)) {\n    return schemaPath\n  }\n\n  schemaPath = path.join(cwd, `prisma/schema.prisma`)\n\n  if (await exists(schemaPath)) {\n    return schemaPath\n  }\n\n  return null\n}\n\n/**\n * Small helper that returns the directory which contains the `schema.prisma` file\n */\nexport async function getSchemaDir(\n  schemaPathFromArgs?: string,\n): Promise<string | null> {\n  if (schemaPathFromArgs) {\n    return path.resolve(path.dirname(schemaPathFromArgs))\n  }\n\n  const schemaPath = await getSchemaPath(schemaPathFromArgs)\n\n  if (!schemaPath) {\n    return null\n  }\n\n  return path.dirname(schemaPath)\n}\n\n// TODO: This should probably return string | null to stay consistent with the other functions\nexport async function getSchema(schemaPathFromArgs?: string): Promise<string> {\n  const schemaPath = await getSchemaPath(schemaPathFromArgs)\n\n  if (!schemaPath) {\n    throw new Error(\n      `Could not find a ${chalk.bold(\n        'schema.prisma',\n      )} file that is required for this command.\\nYou can either provide it with ${chalk.greenBright(\n        '--schema',\n      )}, set it as \\`prisma.schema\\` in your package.json or put it into the default location ${chalk.greenBright(\n        './prisma/schema.prisma',\n      )} https://pris.ly/d/prisma-schema-location`,\n    )\n  }\n\n  return readFile(schemaPath, 'utf-8')\n}\n\n/**\n * Sync\n */\n\nexport function getSchemaPathSync(schemaPathFromArgs?: string): string | null {\n  return getSchemaPathSyncInternal(schemaPathFromArgs, {\n    cwd: process.cwd(),\n  })\n}\n\nexport function getSchemaPathSyncInternal(\n  schemaPathFromArgs?: string,\n  opts: { cwd: string } = {\n    cwd: process.cwd(),\n  },\n): string | null {\n  if (schemaPathFromArgs) {\n    // 1. Try the user custom path\n    const customSchemaPath = getAbsoluteSchemaPathSync(\n      path.resolve(schemaPathFromArgs),\n    )\n    if (!customSchemaPath) {\n      throw new Error(\n        `Provided --schema at ${schemaPathFromArgs} doesn't exist.`,\n      )\n    }\n\n    return customSchemaPath\n  }\n\n  // 2. Try the package.json `prisma.schema` custom path\n  // 3. Try the conventional `./schema.prisma` or `./prisma/schema.prisma` paths\n  // 4. Try resolving yarn workspaces and looking for a schema.prisma file there\n  const schemaPath =\n    getSchemaPathFromPackageJsonSync(opts.cwd) ??\n    getRelativeSchemaPathSync(opts.cwd) ??\n    resolveYarnSchemaSync(opts.cwd)\n\n  if (schemaPath) {\n    return schemaPath\n  }\n\n  return null\n}\n\nexport function getSchemaPathFromPackageJsonSync(cwd: string): string | null {\n  const pkgJson = readPkgUp.sync({ cwd })\n  const schemaPathFromPkgJson: string | undefined =\n    pkgJson?.packageJson?.prisma?.schema\n\n  if (!schemaPathFromPkgJson || !pkgJson) {\n    return null\n  }\n\n  if (typeof schemaPathFromPkgJson !== 'string') {\n    throw new Error(\n      `Provided schema path \\`${schemaPathFromPkgJson}\\` from \\`${path.relative(\n        cwd,\n        pkgJson.path,\n      )}\\` must be of type string`,\n    )\n  }\n\n  const absoluteSchemaPath = path.isAbsolute(schemaPathFromPkgJson)\n    ? schemaPathFromPkgJson\n    : path.resolve(path.dirname(pkgJson.path), schemaPathFromPkgJson)\n\n  if (fs.existsSync(absoluteSchemaPath) === false) {\n    throw new Error(\n      `Provided schema path \\`${path.relative(\n        cwd,\n        absoluteSchemaPath,\n      )}\\` from \\`${path.relative(cwd, pkgJson.path)}\\` doesn't exist.`,\n    )\n  }\n\n  return absoluteSchemaPath\n}\n\nfunction getAbsoluteSchemaPathSync(schemaPath: string): string | null {\n  if (fs.existsSync(schemaPath)) {\n    return schemaPath\n  }\n\n  return null\n}\n\nfunction getRelativeSchemaPathSync(cwd: string): string | null {\n  let schemaPath = path.join(cwd, 'schema.prisma')\n\n  if (fs.existsSync(schemaPath)) {\n    return schemaPath\n  }\n\n  schemaPath = path.join(cwd, `prisma/schema.prisma`)\n\n  if (fs.existsSync(schemaPath)) {\n    return schemaPath\n  }\n\n  return null\n}\n\n/**\n * Sync version of the small helper that returns the directory which contains the `schema.prisma` file\n */\nexport function getSchemaDirSync(schemaPathFromArgs?: string): string | null {\n  if (schemaPathFromArgs) {\n    return path.resolve(path.dirname(schemaPathFromArgs))\n  }\n\n  const schemaPath = getSchemaPathSync(schemaPathFromArgs)\n  if (schemaPath) {\n    return path.dirname(schemaPath)\n  }\n\n  return null\n}\n\n// TODO: This should probably return string | null to stay consistent with the other functions\nexport function getSchemaSync(schemaPathFromArgs?: string): string {\n  const schemaPath = getSchemaPathSync(schemaPathFromArgs)\n\n  if (!schemaPath) {\n    throw new Error(\n      `Could not find a ${chalk.bold(\n        'schema.prisma',\n      )} file that is required for this command.\\nYou can either provide it with ${chalk.greenBright(\n        '--schema',\n      )}, set it as \\`prisma.schema\\` in your package.json or put it into the default location ${chalk.greenBright(\n        './prisma/schema.prisma',\n      )} https://pris.ly/d/prisma-schema-location`,\n    )\n  }\n\n  return fs.readFileSync(schemaPath, 'utf-8')\n}\n\nfunction getJson(stdout: string): any {\n  const firstCurly = stdout.indexOf('{')\n  const lastCurly = stdout.lastIndexOf('}')\n  const sliced = stdout.slice(firstCurly, lastCurly + 1)\n  return JSON.parse(sliced)\n}\n\nfunction isPkgJsonWorkspaceRoot(pkgJson: NormalizedPackageJson) {\n  const workspaces = pkgJson.workspaces\n\n  if (!workspaces) {\n    return false\n  }\n\n  return Array.isArray(workspaces) || workspaces.packages !== undefined\n}\n\nasync function isNearestPkgJsonWorkspaceRoot(cwd: string) {\n  const pkgJson = await readPkgUp({ cwd })\n\n  if (!pkgJson) {\n    return null\n  }\n\n  return {\n    isRoot: isPkgJsonWorkspaceRoot(pkgJson.packageJson),\n    path: pkgJson.path,\n  }\n}\n\nfunction isNearestPkgJsonWorkspaceRootSync(cwd: string) {\n  const pkgJson = readPkgUp.sync({ cwd })\n\n  if (!pkgJson) {\n    return null\n  }\n\n  return {\n    isRoot: isPkgJsonWorkspaceRoot(pkgJson.packageJson),\n    path: pkgJson.path,\n  }\n}\n\nasync function findWorkspaceRoot(cwd: string): Promise<string | null> {\n  let pkgJson = await isNearestPkgJsonWorkspaceRoot(cwd)\n\n  if (!pkgJson) {\n    return null\n  }\n\n  if (pkgJson.isRoot === true) {\n    return path.dirname(pkgJson.path)\n  }\n\n  const pkgJsonParentDir = path.dirname(path.dirname(pkgJson.path))\n\n  pkgJson = await isNearestPkgJsonWorkspaceRoot(pkgJsonParentDir)\n\n  if (!pkgJson || pkgJson.isRoot === false) {\n    return null\n  }\n\n  return path.dirname(pkgJson.path)\n}\n\nfunction findWorkspaceRootSync(cwd: string): string | null {\n  let pkgJson = isNearestPkgJsonWorkspaceRootSync(cwd)\n\n  if (!pkgJson) {\n    return null\n  }\n\n  if (pkgJson.isRoot === true) {\n    return path.dirname(pkgJson.path)\n  }\n\n  const pkgJsonParentDir = path.dirname(path.dirname(pkgJson.path))\n\n  pkgJson = isNearestPkgJsonWorkspaceRootSync(pkgJsonParentDir)\n\n  if (!pkgJson || pkgJson.isRoot === false) {\n    return null\n  }\n\n  return path.dirname(pkgJson.path)\n}\n"],
  "mappings": "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",
  "names": []
}
