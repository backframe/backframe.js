"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dmmfEnumsDeserializer = exports.generatorsDeserializer = exports.datasourcesDeserializer = exports.dmmfModelsdeserializer = void 0;
const handlers = (type, kind) => {
    return {
        default: value => {
            if (kind === 'enum') {
                return `@default(${value})`;
            }
            if (type === 'Boolean') {
                return `@default(${value})`;
            }
            if (!value) {
                return '';
            }
            if (typeof (value) === 'object') {
                return `@default(${value.name}(${value.args}))`;
            }
            if (typeof (value) === 'number') {
                return `@default(${value})`;
            }
            if (typeof (value) === 'string') {
                return `@default("${value}")`;
            }
            throw new Error(`Unsupported field attribute ${value}`);
        },
        isId: value => value ? '@id' : '',
        isUnique: value => value ? '@unique' : '',
        dbNames: value => { },
        relationToFields: value => { },
        relationOnDelete: value => { },
        hasDefaultValue: value => { },
        relationName: value => { },
        documentation: value => { },
        isReadOnly: value => { },
        isGenerated: value => { },
        isUpdatedAt: value => value ? '@updatedAt' : '',
        columnName: value => value ? `@map("${value}")` : ''
    };
};
// Handler for Attributes
// https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-schema/data-model#attributes
function handleAttributes(attributes, kind, type) {
    const { relationFromFields, relationToFields, relationName } = attributes;
    if (kind === 'scalar') {
        return `${Object.keys(attributes).map(each => handlers(type, kind)[each](attributes[each])).join(' ')}`;
    }
    if (kind === 'object' && relationFromFields) {
        return relationFromFields.length > 0 ?
            `@relation(name: "${relationName}", fields: [${relationFromFields}], references: [${relationToFields}])` :
            `@relation(name: "${relationName}")`;
    }
    if (kind === 'enum')
        return `${Object.keys(attributes).map(each => handlers(type, kind)[each](attributes[each])).join(' ')}`;
    return '';
}
function handleFields(fields) {
    return fields
        .map(fields => {
        const { name, kind, type, isRequired, isList, ...attributes } = fields;
        if (kind === 'scalar') {
            return `  ${name} ${type}${isRequired ? '' : '?'} ${handleAttributes(attributes, kind, type)}`;
        }
        if (kind === 'object') {
            return `  ${name} ${type}${isList ? '[]' : (isRequired ? '' : '?')} ${handleAttributes(attributes, kind, type)}`;
        }
        if (kind === 'enum') {
            return `  ${name} ${type}${isList ? '[]' : (isRequired ? '' : '?')} ${handleAttributes(attributes, kind, type)}`;
        }
        throw new Error(`Unsupported field kind "${kind}"`);
    }).join('\n');
}
function handleIdFields(idFields) {
    return idFields.length > 0 ? `@@id([${idFields.join(', ')}])` : '';
}
function handleUniqueFieds(uniqueFields) {
    return uniqueFields.length > 0 ? uniqueFields.map(eachUniqueField => `@@unique([${eachUniqueField.join(', ')}])`).join('\n') : '';
}
function handleDbName(dbName) {
    return dbName ? `@@map("${dbName}")` : '';
}
function handleUrl(envValue) {
    const value = envValue.fromEnvVar ? `env("${envValue.fromEnvVar}")` : envValue.value;
    return `url = ${value}`;
}
function handleProvider(provider) {
    return `provider = "${provider}"`;
}
function handleOutput(path) {
    return path ? `output = "${path}"` : '';
}
function handleBinaryTargets(binaryTargets) {
    return (binaryTargets === null || binaryTargets === void 0 ? void 0 : binaryTargets.length) ? `binaryTargets = ${JSON.stringify(binaryTargets)}` : '';
}
function handlePreviewFeatures(previewFeatures) {
    return previewFeatures.length ? `previewFeatures = ${JSON.stringify(previewFeatures)}` : '';
}
function deserializeModel(model) {
    const { name, uniqueFields, dbName, idFields } = model;
    const fields = model.fields;
    const output = `
model ${name} {
${handleFields(fields)}
${handleUniqueFieds(uniqueFields)}
${handleDbName(dbName)}
${handleIdFields(idFields)}
}`;
    return output;
}
function deserializeDatasource(datasource) {
    const { activeProvider: provider, name, url } = datasource;
    return `
datasource ${name} {
	${handleProvider(provider)}
	${handleUrl(url)}
}`;
}
function deserializeGenerator(generator) {
    const { binaryTargets, name, output, provider, previewFeatures } = generator;
    return `
generator ${name} {
	${handleProvider(provider.value)}
	${handleOutput((output === null || output === void 0 ? void 0 : output.value) || null)}
	${handleBinaryTargets(binaryTargets)}
	${handlePreviewFeatures(previewFeatures)}
}`;
}
function deserializeEnum({ name, values, dbName }) {
    const outputValues = values.map(({ name, dbName }) => {
        let result = name;
        if (name !== dbName && dbName)
            result += `@map("${dbName}")`;
        return result;
    });
    return `
enum ${name} {
	${outputValues.join('\n\t')}
	${handleDbName(dbName || null)}
}`;
}
/**
 * Deserialize DMMF.Model[] into prisma schema file
 */
async function dmmfModelsdeserializer(models) {
    return models.map(model => deserializeModel(model)).join('\n');
}
exports.dmmfModelsdeserializer = dmmfModelsdeserializer;
async function datasourcesDeserializer(datasources) {
    return datasources.map(datasource => deserializeDatasource(datasource)).join('\n');
}
exports.datasourcesDeserializer = datasourcesDeserializer;
async function generatorsDeserializer(generators) {
    return generators.map(generator => deserializeGenerator(generator)).join('\n');
}
exports.generatorsDeserializer = generatorsDeserializer;
async function dmmfEnumsDeserializer(enums) {
    return enums.map(each => deserializeEnum(each)).join('\n');
}
exports.dmmfEnumsDeserializer = dmmfEnumsDeserializer;
//# sourceMappingURL=deserializer.js.map