var __create2 = Object.create;
var __defProp2 = Object.defineProperty;
var __getProtoOf2 = Object.getPrototypeOf;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __markAsModule2 = (target) => __defProp2(target, "__esModule", {value: true});
var __commonJS2 = (callback, module2) => () => {
  if (!module2) {
    module2 = {exports: {}};
    callback(module2.exports, module2);
  }
  return module2.exports;
};
var __export2 = (target, all) => {
  for (var name in all)
    __defProp2(target, name, {get: all[name], enumerable: true});
};
var __exportStar2 = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames2(module2))
      if (!__hasOwnProp2.call(target, key) && key !== "default")
        __defProp2(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc2(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule2 = (module2) => {
  if (module2 && module2.__esModule)
    return module2;
  return __exportStar2(__markAsModule2(__defProp2(module2 != null ? __create2(__getProtoOf2(module2)) : {}, "default", {value: module2, enumerable: true})), module2);
};

// ../../node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js
var require_ms2 = __commonJS2((exports2, module2) => {
  var s2 = 1e3;
  var m2 = s2 * 60;
  var h2 = m2 * 60;
  var d2 = h2 * 24;
  var w2 = d2 * 7;
  var y2 = d2 * 365.25;
  module2.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse2(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong2(val) : fmtShort2(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y2;
      case "weeks":
      case "week":
      case "w":
        return n * w2;
      case "days":
      case "day":
      case "d":
        return n * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort2(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return Math.round(ms2 / d2) + "d";
    }
    if (msAbs >= h2) {
      return Math.round(ms2 / h2) + "h";
    }
    if (msAbs >= m2) {
      return Math.round(ms2 / m2) + "m";
    }
    if (msAbs >= s2) {
      return Math.round(ms2 / s2) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong2(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return plural2(ms2, msAbs, d2, "day");
    }
    if (msAbs >= h2) {
      return plural2(ms2, msAbs, h2, "hour");
    }
    if (msAbs >= m2) {
      return plural2(ms2, msAbs, m2, "minute");
    }
    if (msAbs >= s2) {
      return plural2(ms2, msAbs, s2, "second");
    }
    return ms2 + " ms";
  }
  function plural2(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
});

// ../../node_modules/.pnpm/debug@4.3.2/node_modules/debug/src/common.js
var require_common6 = __commonJS2((exports2, module2) => {
  function setup(env2) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms2();
    createDebug.destroy = destroy;
    Object.keys(env2).forEach((key) => {
      createDebug[key] = env2[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug4(...args) {
        if (!debug4.enabled) {
          return;
        }
        const self2 = debug4;
        const curr = Number(new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format2];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug4.namespace = namespace;
      debug4.useColors = createDebug.useColors();
      debug4.color = createDebug.selectColor(namespace);
      debug4.extend = extend;
      debug4.destroy = createDebug.destroy;
      Object.defineProperty(debug4, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug4);
      }
      return debug4;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module2.exports = setup;
});

// ../../node_modules/.pnpm/debug@4.3.2/node_modules/debug/src/browser.js
var require_browser2 = __commonJS2((exports2, module2) => {
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load2;
  exports2.useColors = useColors;
  exports2.storage = localstorage();
  exports2.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports2.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports2.log = console.debug || console.log || (() => {
  });
  function save(namespaces) {
    try {
      if (namespaces) {
        exports2.storage.setItem("debug", namespaces);
      } else {
        exports2.storage.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load2() {
    let r;
    try {
      r = exports2.storage.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  module2.exports = require_common6()(exports2);
  var {formatters} = module2.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// ../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js
var require_has_flag2 = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
});

// ../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js
var require_supports_color2 = __commonJS2((exports2, module2) => {
  "use strict";
  var os2 = require("os");
  var tty = require("tty");
  var hasFlag = require_has_flag2();
  var {env: env2} = process;
  var forceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
    forceColor = 0;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env2) {
    if (env2.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env2.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env2.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env2.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === void 0) {
      return 0;
    }
    const min2 = forceColor || 0;
    if (env2.TERM === "dumb") {
      return min2;
    }
    if (process.platform === "win32") {
      const osRelease = os2.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env2) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign2) => sign2 in env2) || env2.CI_NAME === "codeship") {
        return 1;
      }
      return min2;
    }
    if ("TEAMCITY_VERSION" in env2) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env2.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env2) {
      const version = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env2.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env2.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env2) {
      return 1;
    }
    return min2;
  }
  function getSupportLevel(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
  }
  module2.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };
});

// ../../node_modules/.pnpm/debug@4.3.2/node_modules/debug/src/node.js
var require_node3 = __commonJS2((exports2, module2) => {
  var tty = require("tty");
  var util2 = require("util");
  exports2.init = init;
  exports2.log = log3;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load2;
  exports2.useColors = useColors;
  exports2.destroy = util2.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports2.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color2();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports2.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {
  }
  exports2.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_2, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const {namespace: name, useColors: useColors2} = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} [0m`;
      args[0] = prefix + args[0].split("\n").join("\n" + prefix);
      args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports2.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log3(...args) {
    return process.stderr.write(util2.format(...args) + "\n");
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load2() {
    return process.env.DEBUG;
  }
  function init(debug4) {
    debug4.inspectOpts = {};
    const keys = Object.keys(exports2.inspectOpts);
    for (let i = 0; i < keys.length; i++) {
      debug4.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
    }
  }
  module2.exports = require_common6()(exports2);
  var {formatters} = module2.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v, this.inspectOpts);
  };
});

// ../../node_modules/.pnpm/debug@4.3.2/node_modules/debug/src/index.js
var require_src3 = __commonJS2((exports2, module2) => {
  if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
    module2.exports = require_browser2();
  } else {
    module2.exports = require_node3();
  }
});

// ../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js
var require_ms3 = __commonJS2((exports2, module2) => {
  var s2 = 1e3;
  var m2 = s2 * 60;
  var h2 = m2 * 60;
  var d2 = h2 * 24;
  var w2 = d2 * 7;
  var y2 = d2 * 365.25;
  module2.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse2(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong2(val) : fmtShort2(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y2;
      case "weeks":
      case "week":
      case "w":
        return n * w2;
      case "days":
      case "day":
      case "d":
        return n * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort2(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return Math.round(ms2 / d2) + "d";
    }
    if (msAbs >= h2) {
      return Math.round(ms2 / h2) + "h";
    }
    if (msAbs >= m2) {
      return Math.round(ms2 / m2) + "m";
    }
    if (msAbs >= s2) {
      return Math.round(ms2 / s2) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong2(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return plural2(ms2, msAbs, d2, "day");
    }
    if (msAbs >= h2) {
      return plural2(ms2, msAbs, h2, "hour");
    }
    if (msAbs >= m2) {
      return plural2(ms2, msAbs, m2, "minute");
    }
    if (msAbs >= s2) {
      return plural2(ms2, msAbs, s2, "second");
    }
    return ms2 + " ms";
  }
  function plural2(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
});

// ../debug/dist/common.js
var require_common7 = __commonJS2((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    setup: () => setup
  });
  function setup(env2) {
    const createDebug = (namespace, logger2) => {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      const debug4 = (...args) => {
        const self2 = debug4;
        const curr = Number(new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format2];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        if (logger2 && typeof logger2 === "function") {
          logger2.apply(self2, args);
        }
        if (debug4.enabled) {
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
      };
      debug4.namespace = namespace;
      debug4.useColors = createDebug.useColors();
      debug4.color = createDebug.selectColor(namespace);
      debug4.extend = extend;
      debug4.destroy = createDebug.destroy;
      Object.defineProperty(debug4, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug4);
      }
      return debug4;
    };
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms3();
    createDebug.destroy = destroy;
    Object.keys(env2).forEach((key) => {
      createDebug[key] = env2[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
});

// ../debug/dist/node.js
var require_node4 = __commonJS2((exports2, module2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    default: () => node_default
  });
  var import_common10 = __toModule3(require_common7());
  var tty = require("tty");
  var util2 = require("util");
  exports2.init = init;
  exports2.log = log3;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load2;
  exports2.useColors = useColors;
  exports2.destroy = util2.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports2.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require("supports-color");
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports2.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {
  }
  exports2.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_2, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const {namespace: name, useColors: useColors2} = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} [0m`;
      args[0] = prefix + args[0].split("\n").join("\n" + prefix);
      args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports2.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log3(...args) {
    return process.stderr.write(util2.format(...args) + "\n");
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load2() {
    return process.env.DEBUG;
  }
  function init(debug4) {
    debug4.inspectOpts = {};
    const keys = Object.keys(exports2.inspectOpts);
    for (let i = 0; i < keys.length; i++) {
      debug4.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
    }
  }
  var mod2 = (0, import_common10.setup)(exports2);
  module2.exports = mod2;
  var node_default = mod2;
  var {formatters} = mod2;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v, this.inspectOpts);
  };
});

// ../debug/dist/index.js
var require_dist7 = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    Debug: () => Debug2,
    default: () => Debug2,
    getLogs: () => getLogs
  });
  var import_debug3 = __toModule3(require_src3());
  var import_node = __toModule3(require_node4());
  var cache = [];
  var MAX_LOGS = 100;
  function Debug2(namespace) {
    const debug4 = (0, import_node.default)(namespace, (...args) => {
      cache.push(args);
      if (cache.length > MAX_LOGS) {
        cache.shift();
      }
    });
    return debug4;
  }
  Debug2.enable = (namespace) => {
    import_node.default.enable(namespace);
  };
  Debug2.enabled = (namespace) => import_node.default.enabled(namespace);
  function getLogs(numChars = 7500) {
    const output = cache.map((c) => c.map((item) => {
      if (typeof item === "string") {
        return item;
      }
      return JSON.stringify(item);
    }).join("  ")).join("\n");
    if (output.length < numChars) {
      return output;
    }
    return output.slice(-numChars);
  }
});

// ../../node_modules/.pnpm/@prisma+engines-version@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/engines-version/package.json
var require_package2 = __commonJS2((exports2, module2) => {
  module2.exports = {
    name: "@prisma/engines-version",
    version: "2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20",
    main: "index.js",
    types: "index.d.ts",
    license: "Apache-2.0",
    author: "Tim Suchanek <suchanek@prisma.io>",
    prisma: {
      enginesVersion: "b8c35d44de987a9691890b3ddf3e2e7effb9bf20"
    },
    devDependencies: {
      "@types/node": "14.17.11",
      typescript: "4.3.5"
    },
    files: [
      "index.js",
      "index.d.ts"
    ],
    scripts: {
      build: "tsc -d"
    }
  };
});

// ../../node_modules/.pnpm/@prisma+engines-version@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/engines-version/index.js
var require_engines_version2 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.enginesVersion = void 0;
  exports2.enginesVersion = require_package2().prisma.enginesVersion;
});

// ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js
var require_windows2 = __commonJS2((exports2, module2) => {
  module2.exports = isexe;
  isexe.sync = sync2;
  var fs2 = require("fs");
  function checkPathExt(path4, options) {
    var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
    if (!pathext) {
      return true;
    }
    pathext = pathext.split(";");
    if (pathext.indexOf("") !== -1) {
      return true;
    }
    for (var i = 0; i < pathext.length; i++) {
      var p = pathext[i].toLowerCase();
      if (p && path4.substr(-p.length).toLowerCase() === p) {
        return true;
      }
    }
    return false;
  }
  function checkStat(stat2, path4, options) {
    if (!stat2.isSymbolicLink() && !stat2.isFile()) {
      return false;
    }
    return checkPathExt(path4, options);
  }
  function isexe(path4, options, cb) {
    fs2.stat(path4, function(er, stat2) {
      cb(er, er ? false : checkStat(stat2, path4, options));
    });
  }
  function sync2(path4, options) {
    return checkStat(fs2.statSync(path4), path4, options);
  }
});

// ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js
var require_mode2 = __commonJS2((exports2, module2) => {
  module2.exports = isexe;
  isexe.sync = sync2;
  var fs2 = require("fs");
  function isexe(path4, options, cb) {
    fs2.stat(path4, function(er, stat2) {
      cb(er, er ? false : checkStat(stat2, options));
    });
  }
  function sync2(path4, options) {
    return checkStat(fs2.statSync(path4), options);
  }
  function checkStat(stat2, options) {
    return stat2.isFile() && checkMode(stat2, options);
  }
  function checkMode(stat2, options) {
    var mod2 = stat2.mode;
    var uid = stat2.uid;
    var gid = stat2.gid;
    var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
    var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
    var u = parseInt("100", 8);
    var g = parseInt("010", 8);
    var o = parseInt("001", 8);
    var ug = u | g;
    var ret = mod2 & o || mod2 & g && gid === myGid || mod2 & u && uid === myUid || mod2 & ug && myUid === 0;
    return ret;
  }
});

// ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js
var require_isexe2 = __commonJS2((exports2, module2) => {
  var fs2 = require("fs");
  var core;
  if (process.platform === "win32" || global.TESTING_WINDOWS) {
    core = require_windows2();
  } else {
    core = require_mode2();
  }
  module2.exports = isexe;
  isexe.sync = sync2;
  function isexe(path4, options, cb) {
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    if (!cb) {
      if (typeof Promise !== "function") {
        throw new TypeError("callback not provided");
      }
      return new Promise(function(resolve, reject) {
        isexe(path4, options || {}, function(er, is) {
          if (er) {
            reject(er);
          } else {
            resolve(is);
          }
        });
      });
    }
    core(path4, options || {}, function(er, is) {
      if (er) {
        if (er.code === "EACCES" || options && options.ignoreErrors) {
          er = null;
          is = false;
        }
      }
      cb(er, is);
    });
  }
  function sync2(path4, options) {
    try {
      return core.sync(path4, options || {});
    } catch (er) {
      if (options && options.ignoreErrors || er.code === "EACCES") {
        return false;
      } else {
        throw er;
      }
    }
  }
});

// ../../node_modules/.pnpm/which@2.0.2/node_modules/which/which.js
var require_which2 = __commonJS2((exports2, module2) => {
  var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
  var path4 = require("path");
  var COLON = isWindows ? ";" : ":";
  var isexe = require_isexe2();
  var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), {code: "ENOENT"});
  var getPathInfo = (cmd, opt) => {
    const colon = opt.colon || COLON;
    const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
      ...isWindows ? [process.cwd()] : [],
      ...(opt.path || process.env.PATH || "").split(colon)
    ];
    const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
    const pathExt = isWindows ? pathExtExe.split(colon) : [""];
    if (isWindows) {
      if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
        pathExt.unshift("");
    }
    return {
      pathEnv,
      pathExt,
      pathExtExe
    };
  };
  var which = (cmd, opt, cb) => {
    if (typeof opt === "function") {
      cb = opt;
      opt = {};
    }
    if (!opt)
      opt = {};
    const {pathEnv, pathExt, pathExtExe} = getPathInfo(cmd, opt);
    const found = [];
    const step = (i) => new Promise((resolve, reject) => {
      if (i === pathEnv.length)
        return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
      const ppRaw = pathEnv[i];
      const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
      const pCmd = path4.join(pathPart, cmd);
      const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      resolve(subStep(p, i, 0));
    });
    const subStep = (p, i, ii) => new Promise((resolve, reject) => {
      if (ii === pathExt.length)
        return resolve(step(i + 1));
      const ext = pathExt[ii];
      isexe(p + ext, {pathExt: pathExtExe}, (er, is) => {
        if (!er && is) {
          if (opt.all)
            found.push(p + ext);
          else
            return resolve(p + ext);
        }
        return resolve(subStep(p, i, ii + 1));
      });
    });
    return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
  };
  var whichSync = (cmd, opt) => {
    opt = opt || {};
    const {pathEnv, pathExt, pathExtExe} = getPathInfo(cmd, opt);
    const found = [];
    for (let i = 0; i < pathEnv.length; i++) {
      const ppRaw = pathEnv[i];
      const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
      const pCmd = path4.join(pathPart, cmd);
      const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      for (let j = 0; j < pathExt.length; j++) {
        const cur = p + pathExt[j];
        try {
          const is = isexe.sync(cur, {pathExt: pathExtExe});
          if (is) {
            if (opt.all)
              found.push(cur);
            else
              return cur;
          }
        } catch (ex) {
        }
      }
    }
    if (opt.all && found.length)
      return found;
    if (opt.nothrow)
      return null;
    throw getNotFoundError(cmd);
  };
  module2.exports = which;
  which.sync = whichSync;
});

// ../../node_modules/.pnpm/path-key@3.1.1/node_modules/path-key/index.js
var require_path_key2 = __commonJS2((exports2, module2) => {
  "use strict";
  var pathKey = (options = {}) => {
    const environment = options.env || process.env;
    const platform = options.platform || process.platform;
    if (platform !== "win32") {
      return "PATH";
    }
    return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
  };
  module2.exports = pathKey;
  module2.exports.default = pathKey;
});

// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand2 = __commonJS2((exports2, module2) => {
  "use strict";
  var path4 = require("path");
  var which = require_which2();
  var getPathKey = require_path_key2();
  function resolveCommandAttempt(parsed, withoutPathExt) {
    const env2 = parsed.options.env || process.env;
    const cwd = process.cwd();
    const hasCustomCwd = parsed.options.cwd != null;
    const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
    if (shouldSwitchCwd) {
      try {
        process.chdir(parsed.options.cwd);
      } catch (err) {
      }
    }
    let resolved;
    try {
      resolved = which.sync(parsed.command, {
        path: env2[getPathKey({env: env2})],
        pathExt: withoutPathExt ? path4.delimiter : void 0
      });
    } catch (e) {
    } finally {
      if (shouldSwitchCwd) {
        process.chdir(cwd);
      }
    }
    if (resolved) {
      resolved = path4.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
    }
    return resolved;
  }
  function resolveCommand(parsed) {
    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
  }
  module2.exports = resolveCommand;
});

// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/escape.js
var require_escape2 = __commonJS2((exports2, module2) => {
  "use strict";
  var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
  function escapeCommand(arg2) {
    arg2 = arg2.replace(metaCharsRegExp, "^$1");
    return arg2;
  }
  function escapeArgument(arg2, doubleEscapeMetaChars) {
    arg2 = `${arg2}`;
    arg2 = arg2.replace(/(\\*)"/g, '$1$1\\"');
    arg2 = arg2.replace(/(\\*)$/, "$1$1");
    arg2 = `"${arg2}"`;
    arg2 = arg2.replace(metaCharsRegExp, "^$1");
    if (doubleEscapeMetaChars) {
      arg2 = arg2.replace(metaCharsRegExp, "^$1");
    }
    return arg2;
  }
  module2.exports.command = escapeCommand;
  module2.exports.argument = escapeArgument;
});

// ../../node_modules/.pnpm/shebang-regex@3.0.0/node_modules/shebang-regex/index.js
var require_shebang_regex2 = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = /^#!(.*)/;
});

// ../../node_modules/.pnpm/shebang-command@2.0.0/node_modules/shebang-command/index.js
var require_shebang_command2 = __commonJS2((exports2, module2) => {
  "use strict";
  var shebangRegex = require_shebang_regex2();
  module2.exports = (string = "") => {
    const match = string.match(shebangRegex);
    if (!match) {
      return null;
    }
    const [path4, argument] = match[0].replace(/#! ?/, "").split(" ");
    const binary = path4.split("/").pop();
    if (binary === "env") {
      return argument;
    }
    return argument ? `${binary} ${argument}` : binary;
  };
});

// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang2 = __commonJS2((exports2, module2) => {
  "use strict";
  var fs2 = require("fs");
  var shebangCommand = require_shebang_command2();
  function readShebang(command) {
    const size = 150;
    const buffer = Buffer.alloc(size);
    let fd;
    try {
      fd = fs2.openSync(command, "r");
      fs2.readSync(fd, buffer, 0, size, 0);
      fs2.closeSync(fd);
    } catch (e) {
    }
    return shebangCommand(buffer.toString());
  }
  module2.exports = readShebang;
});

// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/parse.js
var require_parse5 = __commonJS2((exports2, module2) => {
  "use strict";
  var path4 = require("path");
  var resolveCommand = require_resolveCommand2();
  var escape = require_escape2();
  var readShebang = require_readShebang2();
  var isWin = process.platform === "win32";
  var isExecutableRegExp = /\.(?:com|exe)$/i;
  var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
  function detectShebang(parsed) {
    parsed.file = resolveCommand(parsed);
    const shebang = parsed.file && readShebang(parsed.file);
    if (shebang) {
      parsed.args.unshift(parsed.file);
      parsed.command = shebang;
      return resolveCommand(parsed);
    }
    return parsed.file;
  }
  function parseNonShell(parsed) {
    if (!isWin) {
      return parsed;
    }
    const commandFile = detectShebang(parsed);
    const needsShell = !isExecutableRegExp.test(commandFile);
    if (parsed.options.forceShell || needsShell) {
      const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
      parsed.command = path4.normalize(parsed.command);
      parsed.command = escape.command(parsed.command);
      parsed.args = parsed.args.map((arg2) => escape.argument(arg2, needsDoubleEscapeMetaChars));
      const shellCommand = [parsed.command].concat(parsed.args).join(" ");
      parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
      parsed.command = process.env.comspec || "cmd.exe";
      parsed.options.windowsVerbatimArguments = true;
    }
    return parsed;
  }
  function parse2(command, args, options) {
    if (args && !Array.isArray(args)) {
      options = args;
      args = null;
    }
    args = args ? args.slice(0) : [];
    options = Object.assign({}, options);
    const parsed = {
      command,
      args,
      options,
      file: void 0,
      original: {
        command,
        args
      }
    };
    return options.shell ? parsed : parseNonShell(parsed);
  }
  module2.exports = parse2;
});

// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/enoent.js
var require_enoent2 = __commonJS2((exports2, module2) => {
  "use strict";
  var isWin = process.platform === "win32";
  function notFoundError(original, syscall) {
    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
      code: "ENOENT",
      errno: "ENOENT",
      syscall: `${syscall} ${original.command}`,
      path: original.command,
      spawnargs: original.args
    });
  }
  function hookChildProcess(cp, parsed) {
    if (!isWin) {
      return;
    }
    const originalEmit = cp.emit;
    cp.emit = function(name, arg1) {
      if (name === "exit") {
        const err = verifyENOENT(arg1, parsed, "spawn");
        if (err) {
          return originalEmit.call(cp, "error", err);
        }
      }
      return originalEmit.apply(cp, arguments);
    };
  }
  function verifyENOENT(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
      return notFoundError(parsed.original, "spawn");
    }
    return null;
  }
  function verifyENOENTSync(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
      return notFoundError(parsed.original, "spawnSync");
    }
    return null;
  }
  module2.exports = {
    hookChildProcess,
    verifyENOENT,
    verifyENOENTSync,
    notFoundError
  };
});

// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/index.js
var require_cross_spawn2 = __commonJS2((exports2, module2) => {
  "use strict";
  var cp = require("child_process");
  var parse2 = require_parse5();
  var enoent = require_enoent2();
  function spawn2(command, args, options) {
    const parsed = parse2(command, args, options);
    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
    enoent.hookChildProcess(spawned, parsed);
    return spawned;
  }
  function spawnSync(command, args, options) {
    const parsed = parse2(command, args, options);
    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
    return result;
  }
  module2.exports = spawn2;
  module2.exports.spawn = spawn2;
  module2.exports.sync = spawnSync;
  module2.exports._parse = parse2;
  module2.exports._enoent = enoent;
});

// ../generator-helper/dist/byline.js
var require_byline = __commonJS2((exports2, module2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    createLineStream: () => createLineStream,
    default: () => byline
  });
  var stream = require("stream");
  var util2 = require("util");
  function byline(readStream, options) {
    return module2.exports.createStream(readStream, options);
  }
  module2.exports.createStream = function(readStream, options) {
    if (readStream) {
      return createLineStream(readStream, options);
    } else {
      return new LineStream(options);
    }
  };
  function createLineStream(readStream, options) {
    if (!readStream) {
      throw new Error("expected readStream");
    }
    if (!readStream.readable) {
      throw new Error("readStream must be readable");
    }
    const ls = new LineStream(options);
    readStream.pipe(ls);
    return ls;
  }
  module2.exports.LineStream = LineStream;
  function LineStream(options) {
    stream.Transform.call(this, options);
    options = options || {};
    this._readableState.objectMode = true;
    this._lineBuffer = [];
    this._keepEmptyLines = options.keepEmptyLines || false;
    this._lastChunkEndedWithCR = false;
    this.on("pipe", function(src) {
      if (!this.encoding) {
        if (src instanceof stream.Readable) {
          this.encoding = src._readableState.encoding;
        }
      }
    });
  }
  util2.inherits(LineStream, stream.Transform);
  LineStream.prototype._transform = function(chunk, encoding, done) {
    encoding = encoding || "utf8";
    if (Buffer.isBuffer(chunk)) {
      if (encoding == "buffer") {
        chunk = chunk.toString();
        encoding = "utf8";
      } else {
        chunk = chunk.toString(encoding);
      }
    }
    this._chunkEncoding = encoding;
    const lines = chunk.split(/\r\n|\r|\n/g);
    if (this._lastChunkEndedWithCR && chunk[0] == "\n") {
      lines.shift();
    }
    if (this._lineBuffer.length > 0) {
      this._lineBuffer[this._lineBuffer.length - 1] += lines[0];
      lines.shift();
    }
    this._lastChunkEndedWithCR = chunk[chunk.length - 1] == "\r";
    this._lineBuffer = this._lineBuffer.concat(lines);
    this._pushBuffer(encoding, 1, done);
  };
  LineStream.prototype._pushBuffer = function(encoding, keep, done) {
    while (this._lineBuffer.length > keep) {
      const line = this._lineBuffer.shift();
      if (this._keepEmptyLines || line.length > 0) {
        if (!this.push(this._reencode(line, encoding))) {
          const self2 = this;
          setImmediate(function() {
            self2._pushBuffer(encoding, keep, done);
          });
          return;
        }
      }
    }
    done();
  };
  LineStream.prototype._flush = function(done) {
    this._pushBuffer(this._chunkEncoding, 0, done);
  };
  LineStream.prototype._reencode = function(line, chunkEncoding) {
    if (this.encoding && this.encoding != chunkEncoding) {
      return Buffer.from(line, chunkEncoding).toString(this.encoding);
    } else if (this.encoding) {
      return line;
    } else {
      return Buffer.from(line, chunkEncoding);
    }
  };
});

// ../../node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js
var require_color_name2 = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
});

// ../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js
var require_conversions2 = __commonJS2((exports2, module2) => {
  var cssKeywords = require_color_name2();
  var reverseKeywords = {};
  for (const key of Object.keys(cssKeywords)) {
    reverseKeywords[cssKeywords[key]] = key;
  }
  var convert = {
    rgb: {channels: 3, labels: "rgb"},
    hsl: {channels: 3, labels: "hsl"},
    hsv: {channels: 3, labels: "hsv"},
    hwb: {channels: 3, labels: "hwb"},
    cmyk: {channels: 4, labels: "cmyk"},
    xyz: {channels: 3, labels: "xyz"},
    lab: {channels: 3, labels: "lab"},
    lch: {channels: 3, labels: "lch"},
    hex: {channels: 1, labels: ["hex"]},
    keyword: {channels: 1, labels: ["keyword"]},
    ansi16: {channels: 1, labels: ["ansi16"]},
    ansi256: {channels: 1, labels: ["ansi256"]},
    hcg: {channels: 3, labels: ["h", "c", "g"]},
    apple: {channels: 3, labels: ["r16", "g16", "b16"]},
    gray: {channels: 1, labels: ["gray"]}
  };
  module2.exports = convert;
  for (const model of Object.keys(convert)) {
    if (!("channels" in convert[model])) {
      throw new Error("missing channels property: " + model);
    }
    if (!("labels" in convert[model])) {
      throw new Error("missing channel labels property: " + model);
    }
    if (convert[model].labels.length !== convert[model].channels) {
      throw new Error("channel and label counts mismatch: " + model);
    }
    const {channels, labels} = convert[model];
    delete convert[model].channels;
    delete convert[model].labels;
    Object.defineProperty(convert[model], "channels", {value: channels});
    Object.defineProperty(convert[model], "labels", {value: labels});
  }
  convert.rgb.hsl = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const min2 = Math.min(r, g, b);
    const max2 = Math.max(r, g, b);
    const delta = max2 - min2;
    let h2;
    let s2;
    if (max2 === min2) {
      h2 = 0;
    } else if (r === max2) {
      h2 = (g - b) / delta;
    } else if (g === max2) {
      h2 = 2 + (b - r) / delta;
    } else if (b === max2) {
      h2 = 4 + (r - g) / delta;
    }
    h2 = Math.min(h2 * 60, 360);
    if (h2 < 0) {
      h2 += 360;
    }
    const l = (min2 + max2) / 2;
    if (max2 === min2) {
      s2 = 0;
    } else if (l <= 0.5) {
      s2 = delta / (max2 + min2);
    } else {
      s2 = delta / (2 - max2 - min2);
    }
    return [h2, s2 * 100, l * 100];
  };
  convert.rgb.hsv = function(rgb) {
    let rdif;
    let gdif;
    let bdif;
    let h2;
    let s2;
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const v = Math.max(r, g, b);
    const diff = v - Math.min(r, g, b);
    const diffc = function(c) {
      return (v - c) / 6 / diff + 1 / 2;
    };
    if (diff === 0) {
      h2 = 0;
      s2 = 0;
    } else {
      s2 = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);
      if (r === v) {
        h2 = bdif - gdif;
      } else if (g === v) {
        h2 = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h2 = 2 / 3 + gdif - rdif;
      }
      if (h2 < 0) {
        h2 += 1;
      } else if (h2 > 1) {
        h2 -= 1;
      }
    }
    return [
      h2 * 360,
      s2 * 100,
      v * 100
    ];
  };
  convert.rgb.hwb = function(rgb) {
    const r = rgb[0];
    const g = rgb[1];
    let b = rgb[2];
    const h2 = convert.rgb.hsl(rgb)[0];
    const w2 = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h2, w2 * 100, b * 100];
  };
  convert.rgb.cmyk = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const k = Math.min(1 - r, 1 - g, 1 - b);
    const c = (1 - r - k) / (1 - k) || 0;
    const m2 = (1 - g - k) / (1 - k) || 0;
    const y2 = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m2 * 100, y2 * 100, k * 100];
  };
  function comparativeDistance(x, y2) {
    return (x[0] - y2[0]) ** 2 + (x[1] - y2[1]) ** 2 + (x[2] - y2[2]) ** 2;
  }
  convert.rgb.keyword = function(rgb) {
    const reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    let currentClosestDistance = Infinity;
    let currentClosestKeyword;
    for (const keyword of Object.keys(cssKeywords)) {
      const value = cssKeywords[keyword];
      const distance = comparativeDistance(rgb, value);
      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }
    return currentClosestKeyword;
  };
  convert.keyword.rgb = function(keyword) {
    return cssKeywords[keyword];
  };
  convert.rgb.xyz = function(rgb) {
    let r = rgb[0] / 255;
    let g = rgb[1] / 255;
    let b = rgb[2] / 255;
    r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
    g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
    b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
    const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    const y2 = r * 0.2126 + g * 0.7152 + b * 0.0722;
    const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y2 * 100, z * 100];
  };
  convert.rgb.lab = function(rgb) {
    const xyz = convert.rgb.xyz(rgb);
    let x = xyz[0];
    let y2 = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y2 /= 100;
    z /= 108.883;
    x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y2 = y2 > 8856e-6 ? y2 ** (1 / 3) : 7.787 * y2 + 16 / 116;
    z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y2 - 16;
    const a = 500 * (x - y2);
    const b = 200 * (y2 - z);
    return [l, a, b];
  };
  convert.hsl.rgb = function(hsl) {
    const h2 = hsl[0] / 360;
    const s2 = hsl[1] / 100;
    const l = hsl[2] / 100;
    let t2;
    let t3;
    let val;
    if (s2 === 0) {
      val = l * 255;
      return [val, val, val];
    }
    if (l < 0.5) {
      t2 = l * (1 + s2);
    } else {
      t2 = l + s2 - l * s2;
    }
    const t1 = 2 * l - t2;
    const rgb = [0, 0, 0];
    for (let i = 0; i < 3; i++) {
      t3 = h2 + 1 / 3 * -(i - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }
      rgb[i] = val * 255;
    }
    return rgb;
  };
  convert.hsl.hsv = function(hsl) {
    const h2 = hsl[0];
    let s2 = hsl[1] / 100;
    let l = hsl[2] / 100;
    let smin = s2;
    const lmin = Math.max(l, 0.01);
    l *= 2;
    s2 *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v = (l + s2) / 2;
    const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s2 / (l + s2);
    return [h2, sv * 100, v * 100];
  };
  convert.hsv.rgb = function(hsv) {
    const h2 = hsv[0] / 60;
    const s2 = hsv[1] / 100;
    let v = hsv[2] / 100;
    const hi = Math.floor(h2) % 6;
    const f = h2 - Math.floor(h2);
    const p = 255 * v * (1 - s2);
    const q = 255 * v * (1 - s2 * f);
    const t = 255 * v * (1 - s2 * (1 - f));
    v *= 255;
    switch (hi) {
      case 0:
        return [v, t, p];
      case 1:
        return [q, v, p];
      case 2:
        return [p, v, t];
      case 3:
        return [p, q, v];
      case 4:
        return [t, p, v];
      case 5:
        return [v, p, q];
    }
  };
  convert.hsv.hsl = function(hsv) {
    const h2 = hsv[0];
    const s2 = hsv[1] / 100;
    const v = hsv[2] / 100;
    const vmin = Math.max(v, 0.01);
    let sl;
    let l;
    l = (2 - s2) * v;
    const lmin = (2 - s2) * vmin;
    sl = s2 * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h2, sl * 100, l * 100];
  };
  convert.hwb.rgb = function(hwb) {
    const h2 = hwb[0] / 360;
    let wh = hwb[1] / 100;
    let bl = hwb[2] / 100;
    const ratio = wh + bl;
    let f;
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    const i = Math.floor(6 * h2);
    const v = 1 - bl;
    f = 6 * h2 - i;
    if ((i & 1) !== 0) {
      f = 1 - f;
    }
    const n = wh + f * (v - wh);
    let r;
    let g;
    let b;
    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;
      case 1:
        r = n;
        g = v;
        b = wh;
        break;
      case 2:
        r = wh;
        g = v;
        b = n;
        break;
      case 3:
        r = wh;
        g = n;
        b = v;
        break;
      case 4:
        r = n;
        g = wh;
        b = v;
        break;
      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }
    return [r * 255, g * 255, b * 255];
  };
  convert.cmyk.rgb = function(cmyk) {
    const c = cmyk[0] / 100;
    const m2 = cmyk[1] / 100;
    const y2 = cmyk[2] / 100;
    const k = cmyk[3] / 100;
    const r = 1 - Math.min(1, c * (1 - k) + k);
    const g = 1 - Math.min(1, m2 * (1 - k) + k);
    const b = 1 - Math.min(1, y2 * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.rgb = function(xyz) {
    const x = xyz[0] / 100;
    const y2 = xyz[1] / 100;
    const z = xyz[2] / 100;
    let r;
    let g;
    let b;
    r = x * 3.2406 + y2 * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y2 * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y2 * -0.204 + z * 1.057;
    r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
    g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
    b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.lab = function(xyz) {
    let x = xyz[0];
    let y2 = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y2 /= 100;
    z /= 108.883;
    x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y2 = y2 > 8856e-6 ? y2 ** (1 / 3) : 7.787 * y2 + 16 / 116;
    z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y2 - 16;
    const a = 500 * (x - y2);
    const b = 200 * (y2 - z);
    return [l, a, b];
  };
  convert.lab.xyz = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let x;
    let y2;
    let z;
    y2 = (l + 16) / 116;
    x = a / 500 + y2;
    z = y2 - b / 200;
    const y22 = y2 ** 3;
    const x2 = x ** 3;
    const z2 = z ** 3;
    y2 = y22 > 8856e-6 ? y22 : (y2 - 16 / 116) / 7.787;
    x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y2 *= 100;
    z *= 108.883;
    return [x, y2, z];
  };
  convert.lab.lch = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let h2;
    const hr = Math.atan2(b, a);
    h2 = hr * 360 / 2 / Math.PI;
    if (h2 < 0) {
      h2 += 360;
    }
    const c = Math.sqrt(a * a + b * b);
    return [l, c, h2];
  };
  convert.lch.lab = function(lch) {
    const l = lch[0];
    const c = lch[1];
    const h2 = lch[2];
    const hr = h2 / 360 * 2 * Math.PI;
    const a = c * Math.cos(hr);
    const b = c * Math.sin(hr);
    return [l, a, b];
  };
  convert.rgb.ansi16 = function(args, saturation = null) {
    const [r, g, b] = args;
    let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
    value = Math.round(value / 50);
    if (value === 0) {
      return 30;
    }
    let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value === 2) {
      ansi += 60;
    }
    return ansi;
  };
  convert.hsv.ansi16 = function(args) {
    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
  };
  convert.rgb.ansi256 = function(args) {
    const r = args[0];
    const g = args[1];
    const b = args[2];
    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }
      if (r > 248) {
        return 231;
      }
      return Math.round((r - 8) / 247 * 24) + 232;
    }
    const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };
  convert.ansi16.rgb = function(args) {
    let color = args % 10;
    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }
      color = color / 10.5 * 255;
      return [color, color, color];
    }
    const mult = (~~(args > 50) + 1) * 0.5;
    const r = (color & 1) * mult * 255;
    const g = (color >> 1 & 1) * mult * 255;
    const b = (color >> 2 & 1) * mult * 255;
    return [r, g, b];
  };
  convert.ansi256.rgb = function(args) {
    if (args >= 232) {
      const c = (args - 232) * 10 + 8;
      return [c, c, c];
    }
    args -= 16;
    let rem;
    const r = Math.floor(args / 36) / 5 * 255;
    const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    const b = rem % 6 / 5 * 255;
    return [r, g, b];
  };
  convert.rgb.hex = function(args) {
    const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.hex.rgb = function(args) {
    const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match) {
      return [0, 0, 0];
    }
    let colorString = match[0];
    if (match[0].length === 3) {
      colorString = colorString.split("").map((char) => {
        return char + char;
      }).join("");
    }
    const integer = parseInt(colorString, 16);
    const r = integer >> 16 & 255;
    const g = integer >> 8 & 255;
    const b = integer & 255;
    return [r, g, b];
  };
  convert.rgb.hcg = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const max2 = Math.max(Math.max(r, g), b);
    const min2 = Math.min(Math.min(r, g), b);
    const chroma = max2 - min2;
    let grayscale;
    let hue;
    if (chroma < 1) {
      grayscale = min2 / (1 - chroma);
    } else {
      grayscale = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max2 === r) {
      hue = (g - b) / chroma % 6;
    } else if (max2 === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert.hsl.hcg = function(hsl) {
    const s2 = hsl[1] / 100;
    const l = hsl[2] / 100;
    const c = l < 0.5 ? 2 * s2 * l : 2 * s2 * (1 - l);
    let f = 0;
    if (c < 1) {
      f = (l - 0.5 * c) / (1 - c);
    }
    return [hsl[0], c * 100, f * 100];
  };
  convert.hsv.hcg = function(hsv) {
    const s2 = hsv[1] / 100;
    const v = hsv[2] / 100;
    const c = s2 * v;
    let f = 0;
    if (c < 1) {
      f = (v - c) / (1 - c);
    }
    return [hsv[0], c * 100, f * 100];
  };
  convert.hcg.rgb = function(hcg) {
    const h2 = hcg[0] / 360;
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    if (c === 0) {
      return [g * 255, g * 255, g * 255];
    }
    const pure = [0, 0, 0];
    const hi = h2 % 1 * 6;
    const v = hi % 1;
    const w2 = 1 - v;
    let mg = 0;
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w2;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w2;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w2;
    }
    mg = (1 - c) * g;
    return [
      (c * pure[0] + mg) * 255,
      (c * pure[1] + mg) * 255,
      (c * pure[2] + mg) * 255
    ];
  };
  convert.hcg.hsv = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    let f = 0;
    if (v > 0) {
      f = c / v;
    }
    return [hcg[0], f * 100, v * 100];
  };
  convert.hcg.hsl = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const l = g * (1 - c) + 0.5 * c;
    let s2 = 0;
    if (l > 0 && l < 0.5) {
      s2 = c / (2 * l);
    } else if (l >= 0.5 && l < 1) {
      s2 = c / (2 * (1 - l));
    }
    return [hcg[0], s2 * 100, l * 100];
  };
  convert.hcg.hwb = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };
  convert.hwb.hcg = function(hwb) {
    const w2 = hwb[1] / 100;
    const b = hwb[2] / 100;
    const v = 1 - b;
    const c = v - w2;
    let g = 0;
    if (c < 1) {
      g = (v - c) / (1 - c);
    }
    return [hwb[0], c * 100, g * 100];
  };
  convert.apple.rgb = function(apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert.rgb.apple = function(rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert.gray.rgb = function(args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };
  convert.gray.hsl = function(args) {
    return [0, 0, args[0]];
  };
  convert.gray.hsv = convert.gray.hsl;
  convert.gray.hwb = function(gray) {
    return [0, 100, gray[0]];
  };
  convert.gray.cmyk = function(gray) {
    return [0, 0, 0, gray[0]];
  };
  convert.gray.lab = function(gray) {
    return [gray[0], 0, 0];
  };
  convert.gray.hex = function(gray) {
    const val = Math.round(gray[0] / 100 * 255) & 255;
    const integer = (val << 16) + (val << 8) + val;
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.rgb.gray = function(rgb) {
    const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
});

// ../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js
var require_route2 = __commonJS2((exports2, module2) => {
  var conversions = require_conversions2();
  function buildGraph() {
    const graph = {};
    const models = Object.keys(conversions);
    for (let len = models.length, i = 0; i < len; i++) {
      graph[models[i]] = {
        distance: -1,
        parent: null
      };
    }
    return graph;
  }
  function deriveBFS(fromModel) {
    const graph = buildGraph();
    const queue = [fromModel];
    graph[fromModel].distance = 0;
    while (queue.length) {
      const current = queue.pop();
      const adjacents = Object.keys(conversions[current]);
      for (let len = adjacents.length, i = 0; i < len; i++) {
        const adjacent = adjacents[i];
        const node = graph[adjacent];
        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  }
  function link2(from, to) {
    return function(args) {
      return to(from(args));
    };
  }
  function wrapConversion(toModel, graph) {
    const path4 = [graph[toModel].parent, toModel];
    let fn = conversions[graph[toModel].parent][toModel];
    let cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path4.unshift(graph[cur].parent);
      fn = link2(conversions[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path4;
    return fn;
  }
  module2.exports = function(fromModel) {
    const graph = deriveBFS(fromModel);
    const conversion = {};
    const models = Object.keys(graph);
    for (let len = models.length, i = 0; i < len; i++) {
      const toModel = models[i];
      const node = graph[toModel];
      if (node.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  };
});

// ../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js
var require_color_convert2 = __commonJS2((exports2, module2) => {
  var conversions = require_conversions2();
  var route = require_route2();
  var convert = {};
  var models = Object.keys(conversions);
  function wrapRaw(fn) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === void 0 || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      return fn(args);
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  function wrapRounded(fn) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === void 0 || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      const result = fn(args);
      if (typeof result === "object") {
        for (let len = result.length, i = 0; i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }
      return result;
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  models.forEach((fromModel) => {
    convert[fromModel] = {};
    Object.defineProperty(convert[fromModel], "channels", {value: conversions[fromModel].channels});
    Object.defineProperty(convert[fromModel], "labels", {value: conversions[fromModel].labels});
    const routes = route(fromModel);
    const routeModels = Object.keys(routes);
    routeModels.forEach((toModel) => {
      const fn = routes[toModel];
      convert[fromModel][toModel] = wrapRounded(fn);
      convert[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  module2.exports = convert;
});

// ../../node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js
var require_ansi_styles2 = __commonJS2((exports2, module2) => {
  "use strict";
  var wrapAnsi16 = (fn, offset) => (...args) => {
    const code = fn(...args);
    return `[${code + offset}m`;
  };
  var wrapAnsi256 = (fn, offset) => (...args) => {
    const code = fn(...args);
    return `[${38 + offset};5;${code}m`;
  };
  var wrapAnsi16m = (fn, offset) => (...args) => {
    const rgb = fn(...args);
    return `[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
  };
  var ansi2ansi = (n) => n;
  var rgb2rgb = (r, g, b) => [r, g, b];
  var setLazyProperty = (object, property, get) => {
    Object.defineProperty(object, property, {
      get: () => {
        const value = get();
        Object.defineProperty(object, property, {
          value,
          enumerable: true,
          configurable: true
        });
        return value;
      },
      enumerable: true,
      configurable: true
    });
  };
  var colorConvert;
  var makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
    if (colorConvert === void 0) {
      colorConvert = require_color_convert2();
    }
    const offset = isBackground ? 10 : 0;
    const styles = {};
    for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
      const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
      if (sourceSpace === targetSpace) {
        styles[name] = wrap(identity, offset);
      } else if (typeof suite === "object") {
        styles[name] = wrap(suite[targetSpace], offset);
      }
    }
    return styles;
  };
  function assembleStyles() {
    const codes = new Map();
    const styles = {
      modifier: {
        reset: [0, 0],
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        blackBright: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    styles.color.gray = styles.color.blackBright;
    styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
    styles.color.grey = styles.color.blackBright;
    styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
    for (const [groupName, group] of Object.entries(styles)) {
      for (const [styleName, style] of Object.entries(group)) {
        styles[styleName] = {
          open: `[${style[0]}m`,
          close: `[${style[1]}m`
        };
        group[styleName] = styles[styleName];
        codes.set(style[0], style[1]);
      }
      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false
      });
    }
    Object.defineProperty(styles, "codes", {
      value: codes,
      enumerable: false
    });
    styles.color.close = "[39m";
    styles.bgColor.close = "[49m";
    setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
    setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
    setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
    setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
    setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
    setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
    return styles;
  }
  Object.defineProperty(module2, "exports", {
    enumerable: true,
    get: assembleStyles
  });
});

// ../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/util.js
var require_util3 = __commonJS2((exports2, module2) => {
  "use strict";
  var stringReplaceAll = (string, substring, replacer) => {
    let index = string.indexOf(substring);
    if (index === -1) {
      return string;
    }
    const substringLength = substring.length;
    let endIndex = 0;
    let returnValue = "";
    do {
      returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
      endIndex = index + substringLength;
      index = string.indexOf(substring, endIndex);
    } while (index !== -1);
    returnValue += string.substr(endIndex);
    return returnValue;
  };
  var stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
    let endIndex = 0;
    let returnValue = "";
    do {
      const gotCR = string[index - 1] === "\r";
      returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
      endIndex = index + 1;
      index = string.indexOf("\n", endIndex);
    } while (index !== -1);
    returnValue += string.substr(endIndex);
    return returnValue;
  };
  module2.exports = {
    stringReplaceAll,
    stringEncaseCRLFWithFirstIndex
  };
});

// ../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/templates.js
var require_templates2 = __commonJS2((exports2, module2) => {
  "use strict";
  var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
  var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
  var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
  var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
  var ESCAPES = new Map([
    ["n", "\n"],
    ["r", "\r"],
    ["t", "	"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", ""],
    ["a", "\x07"]
  ]);
  function unescape(c) {
    const u = c[0] === "u";
    const bracket = c[1] === "{";
    if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
      return String.fromCharCode(parseInt(c.slice(1), 16));
    }
    if (u && bracket) {
      return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
    }
    return ESCAPES.get(c) || c;
  }
  function parseArguments(name, arguments_) {
    const results = [];
    const chunks = arguments_.trim().split(/\s*,\s*/g);
    let matches;
    for (const chunk of chunks) {
      const number = Number(chunk);
      if (!Number.isNaN(number)) {
        results.push(number);
      } else if (matches = chunk.match(STRING_REGEX)) {
        results.push(matches[2].replace(ESCAPE_REGEX, (m2, escape, character) => escape ? unescape(escape) : character));
      } else {
        throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
      }
    }
    return results;
  }
  function parseStyle(style) {
    STYLE_REGEX.lastIndex = 0;
    const results = [];
    let matches;
    while ((matches = STYLE_REGEX.exec(style)) !== null) {
      const name = matches[1];
      if (matches[2]) {
        const args = parseArguments(name, matches[2]);
        results.push([name].concat(args));
      } else {
        results.push([name]);
      }
    }
    return results;
  }
  function buildStyle(chalk3, styles) {
    const enabled = {};
    for (const layer of styles) {
      for (const style of layer.styles) {
        enabled[style[0]] = layer.inverse ? null : style.slice(1);
      }
    }
    let current = chalk3;
    for (const [styleName, styles2] of Object.entries(enabled)) {
      if (!Array.isArray(styles2)) {
        continue;
      }
      if (!(styleName in current)) {
        throw new Error(`Unknown Chalk style: ${styleName}`);
      }
      current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
    }
    return current;
  }
  module2.exports = (chalk3, temporary) => {
    const styles = [];
    const chunks = [];
    let chunk = [];
    temporary.replace(TEMPLATE_REGEX, (m2, escapeCharacter, inverse, style, close2, character) => {
      if (escapeCharacter) {
        chunk.push(unescape(escapeCharacter));
      } else if (style) {
        const string = chunk.join("");
        chunk = [];
        chunks.push(styles.length === 0 ? string : buildStyle(chalk3, styles)(string));
        styles.push({inverse, styles: parseStyle(style)});
      } else if (close2) {
        if (styles.length === 0) {
          throw new Error("Found extraneous } in Chalk template literal");
        }
        chunks.push(buildStyle(chalk3, styles)(chunk.join("")));
        chunk = [];
        styles.pop();
      } else {
        chunk.push(character);
      }
    });
    chunks.push(chunk.join(""));
    if (styles.length > 0) {
      const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(errMessage);
    }
    return chunks.join("");
  };
});

// ../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/index.js
var require_source2 = __commonJS2((exports2, module2) => {
  "use strict";
  var ansiStyles = require_ansi_styles2();
  var {stdout: stdoutColor, stderr: stderrColor} = require_supports_color2();
  var {
    stringReplaceAll,
    stringEncaseCRLFWithFirstIndex
  } = require_util3();
  var {isArray} = Array;
  var levelMapping = [
    "ansi",
    "ansi",
    "ansi256",
    "ansi16m"
  ];
  var styles = Object.create(null);
  var applyOptions = (object, options = {}) => {
    if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
      throw new Error("The `level` option should be an integer from 0 to 3");
    }
    const colorLevel = stdoutColor ? stdoutColor.level : 0;
    object.level = options.level === void 0 ? colorLevel : options.level;
  };
  var ChalkClass = class {
    constructor(options) {
      return chalkFactory(options);
    }
  };
  var chalkFactory = (options) => {
    const chalk4 = {};
    applyOptions(chalk4, options);
    chalk4.template = (...arguments_) => chalkTag(chalk4.template, ...arguments_);
    Object.setPrototypeOf(chalk4, Chalk.prototype);
    Object.setPrototypeOf(chalk4.template, chalk4);
    chalk4.template.constructor = () => {
      throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
    };
    chalk4.template.Instance = ChalkClass;
    return chalk4.template;
  };
  function Chalk(options) {
    return chalkFactory(options);
  }
  for (const [styleName, style] of Object.entries(ansiStyles)) {
    styles[styleName] = {
      get() {
        const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
        Object.defineProperty(this, styleName, {value: builder});
        return builder;
      }
    };
  }
  styles.visible = {
    get() {
      const builder = createBuilder(this, this._styler, true);
      Object.defineProperty(this, "visible", {value: builder});
      return builder;
    }
  };
  var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
  for (const model of usedModels) {
    styles[model] = {
      get() {
        const {level} = this;
        return function(...arguments_) {
          const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
          return createBuilder(this, styler, this._isEmpty);
        };
      }
    };
  }
  for (const model of usedModels) {
    const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
    styles[bgModel] = {
      get() {
        const {level} = this;
        return function(...arguments_) {
          const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
          return createBuilder(this, styler, this._isEmpty);
        };
      }
    };
  }
  var proto = Object.defineProperties(() => {
  }, {
    ...styles,
    level: {
      enumerable: true,
      get() {
        return this._generator.level;
      },
      set(level) {
        this._generator.level = level;
      }
    }
  });
  var createStyler = (open2, close2, parent) => {
    let openAll;
    let closeAll;
    if (parent === void 0) {
      openAll = open2;
      closeAll = close2;
    } else {
      openAll = parent.openAll + open2;
      closeAll = close2 + parent.closeAll;
    }
    return {
      open: open2,
      close: close2,
      openAll,
      closeAll,
      parent
    };
  };
  var createBuilder = (self2, _styler, _isEmpty) => {
    const builder = (...arguments_) => {
      if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
        return applyStyle(builder, chalkTag(builder, ...arguments_));
      }
      return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
    };
    Object.setPrototypeOf(builder, proto);
    builder._generator = self2;
    builder._styler = _styler;
    builder._isEmpty = _isEmpty;
    return builder;
  };
  var applyStyle = (self2, string) => {
    if (self2.level <= 0 || !string) {
      return self2._isEmpty ? "" : string;
    }
    let styler = self2._styler;
    if (styler === void 0) {
      return string;
    }
    const {openAll, closeAll} = styler;
    if (string.indexOf("") !== -1) {
      while (styler !== void 0) {
        string = stringReplaceAll(string, styler.close, styler.open);
        styler = styler.parent;
      }
    }
    const lfIndex = string.indexOf("\n");
    if (lfIndex !== -1) {
      string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
    }
    return openAll + string + closeAll;
  };
  var template;
  var chalkTag = (chalk4, ...strings) => {
    const [firstString] = strings;
    if (!isArray(firstString) || !isArray(firstString.raw)) {
      return strings.join(" ");
    }
    const arguments_ = strings.slice(1);
    const parts = [firstString.raw[0]];
    for (let i = 1; i < firstString.length; i++) {
      parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i]));
    }
    if (template === void 0) {
      template = require_templates2();
    }
    return template(chalk4, parts.join(""));
  };
  Object.defineProperties(Chalk.prototype, styles);
  var chalk3 = Chalk();
  chalk3.supportsColor = stdoutColor;
  chalk3.stderr = Chalk({level: stderrColor ? stderrColor.level : 0});
  chalk3.stderr.supportsColor = stderrColor;
  module2.exports = chalk3;
});

// ../generator-helper/dist/GeneratorProcess.js
var require_GeneratorProcess = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    GeneratorError: () => GeneratorError2,
    GeneratorProcess: () => GeneratorProcess2
  });
  var import_child_process2 = __toModule3(require("child_process"));
  var import_cross_spawn = __toModule3(require_cross_spawn2());
  var import_byline2 = __toModule3(require_byline());
  var import_chalk3 = __toModule3(require_source2());
  var import_debug3 = __toModule3(require_dist7());
  var debug4 = (0, import_debug3.default)("prisma:GeneratorProcess");
  var globalMessageId = 1;
  var GeneratorError2 = class extends Error {
    constructor(message, code, data) {
      super(message);
      this.code = code;
      this.data = data;
    }
  };
  var GeneratorProcess2 = class {
    constructor(executablePath, isNode) {
      this.executablePath = executablePath;
      this.isNode = isNode;
      this.listeners = {};
      this.exitCode = null;
      this.stderrLogs = "";
    }
    async init() {
      if (!this.initPromise) {
        this.initPromise = this.initSingleton();
      }
      return this.initPromise;
    }
    initSingleton() {
      return new Promise((resolve, reject) => {
        try {
          if (this.isNode) {
            this.child = (0, import_child_process2.fork)(this.executablePath, [], {
              stdio: ["pipe", "inherit", "pipe", "ipc"],
              env: {
                ...process.env,
                PRISMA_GENERATOR_INVOCATION: "true"
              },
              execArgv: ["--max-old-space-size=8096"]
            });
          } else {
            this.child = (0, import_cross_spawn.spawn)(this.executablePath, {
              stdio: ["pipe", "inherit", "pipe"],
              env: {
                ...process.env,
                PRISMA_GENERATOR_INVOCATION: "true"
              },
              shell: true
            });
          }
          this.child.on("exit", (code) => {
            this.exitCode = code;
            if (code && code > 0 && this.currentGenerateDeferred) {
              this.currentGenerateDeferred.reject(new Error(this.stderrLogs.split("\n").slice(-5).join("\n")));
            }
          });
          this.child.on("error", (err) => {
            this.lastError = err;
            if (err.message.includes("EACCES")) {
              reject(new Error(`The executable at ${this.executablePath} lacks the right chmod. Please use ${import_chalk3.default.bold(`chmod +x ${this.executablePath}`)}`));
            } else {
              reject(err);
            }
          });
          (0, import_byline2.default)(this.child.stderr).on("data", (line) => {
            const response = String(line);
            this.stderrLogs += response + "\n";
            let data;
            try {
              data = JSON.parse(response);
            } catch (e) {
              debug4(response);
            }
            if (data) {
              this.handleResponse(data);
            }
          });
          setTimeout(() => {
            if (this.exitCode && this.exitCode > 0) {
              reject(new Error(`Generator at ${this.executablePath} could not start:

${this.stderrLogs}`));
            } else {
              resolve();
            }
          }, 200);
        } catch (e) {
          reject(e);
        }
      });
    }
    handleResponse(data) {
      if (data.jsonrpc && data.id) {
        if (typeof data.id !== "number") {
          throw new Error(`message.id has to be a number. Found value ${data.id}`);
        }
        if (this.listeners[data.id]) {
          if (data.error) {
            const error = new GeneratorError2(data.error.message, data.error.code, data.error.data);
            this.listeners[data.id](null, error);
          } else {
            this.listeners[data.id](data.result);
          }
          delete this.listeners[data.id];
        }
      }
    }
    registerListener(messageId, cb) {
      this.listeners[messageId] = cb;
    }
    sendMessage(message) {
      this.child.stdin.write(JSON.stringify(message) + "\n");
    }
    getMessageId() {
      return globalMessageId++;
    }
    stop() {
      if (!this.child.killed) {
        this.child.kill();
      }
    }
    getManifest(config2) {
      return new Promise((resolve, reject) => {
        const messageId = this.getMessageId();
        this.registerListener(messageId, (result, error) => {
          if (error) {
            return reject(error);
          }
          if (result.manifest) {
            resolve(result.manifest);
          } else {
            resolve(null);
          }
        });
        this.sendMessage({
          jsonrpc: "2.0",
          method: "getManifest",
          params: config2,
          id: messageId
        });
      });
    }
    generate(options) {
      return new Promise((resolve, reject) => {
        const messageId = this.getMessageId();
        this.currentGenerateDeferred = {resolve, reject};
        this.registerListener(messageId, (result, error) => {
          if (error) {
            reject(error);
            this.currentGenerateDeferred = void 0;
            return;
          }
          resolve(result);
          this.currentGenerateDeferred = void 0;
        });
        this.sendMessage({
          jsonrpc: "2.0",
          method: "generate",
          params: options,
          id: messageId
        });
      });
    }
  };
});

// ../generator-helper/dist/generatorHandler.js
var require_generatorHandler = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    generatorHandler: () => generatorHandler3
  });
  var import_byline2 = __toModule3(require_byline());
  function generatorHandler3(handler) {
    (0, import_byline2.default)(process.stdin).on("data", async (line) => {
      const json = JSON.parse(String(line));
      if (json.method === "generate" && json.params) {
        try {
          const result = await handler.onGenerate(json.params);
          respond({
            jsonrpc: "2.0",
            result,
            id: json.id
          });
        } catch (e) {
          respond({
            jsonrpc: "2.0",
            error: {
              code: -32e3,
              message: e.stack || e.message,
              data: null
            },
            id: json.id
          });
        }
      }
      if (json.method === "getManifest") {
        if (handler.onManifest) {
          try {
            const manifest = handler.onManifest(json.params);
            respond({
              jsonrpc: "2.0",
              result: {
                manifest
              },
              id: json.id
            });
          } catch (e) {
            respond({
              jsonrpc: "2.0",
              error: {
                code: -32e3,
                message: e.stack || e.message,
                data: null
              },
              id: json.id
            });
          }
        } else {
          respond({
            jsonrpc: "2.0",
            result: {
              manifest: null
            },
            id: json.id
          });
        }
      }
    });
    process.stdin.resume();
  }
  function respond(response) {
    console.error(JSON.stringify(response));
  }
});

// ../generator-helper/dist/types.js
var require_types = __commonJS2((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  __markAsModule3(exports2);
});

// ../generator-helper/dist/dmmf.js
var require_dmmf = __commonJS2((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    DMMF: () => DMMF3
  });
  var DMMF3;
  (function(DMMF22) {
    let ModelAction;
    (function(ModelAction2) {
      ModelAction2["findUnique"] = "findUnique";
      ModelAction2["findFirst"] = "findFirst";
      ModelAction2["findMany"] = "findMany";
      ModelAction2["create"] = "create";
      ModelAction2["createMany"] = "createMany";
      ModelAction2["update"] = "update";
      ModelAction2["updateMany"] = "updateMany";
      ModelAction2["upsert"] = "upsert";
      ModelAction2["delete"] = "delete";
      ModelAction2["deleteMany"] = "deleteMany";
      ModelAction2["groupBy"] = "groupBy";
      ModelAction2["count"] = "count";
      ModelAction2["aggregate"] = "aggregate";
    })(ModelAction = DMMF22.ModelAction || (DMMF22.ModelAction = {}));
  })(DMMF3 || (DMMF3 = {}));
});

// ../generator-helper/dist/index.js
var require_dist8 = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    GeneratorError: () => import_GeneratorProcess.GeneratorError,
    GeneratorProcess: () => import_GeneratorProcess.GeneratorProcess,
    generatorHandler: () => import_generatorHandler.generatorHandler
  });
  var import_GeneratorProcess = __toModule3(require_GeneratorProcess());
  var import_generatorHandler = __toModule3(require_generatorHandler());
  __reExport2(exports2, __toModule3(require_types()));
  __reExport2(exports2, __toModule3(require_dmmf()));
});

// ../../node_modules/.pnpm/strip-final-newline@2.0.0/node_modules/strip-final-newline/index.js
var require_strip_final_newline2 = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = (input) => {
    const LF = typeof input === "string" ? "\n" : "\n".charCodeAt();
    const CR = typeof input === "string" ? "\r" : "\r".charCodeAt();
    if (input[input.length - 1] === LF) {
      input = input.slice(0, input.length - 1);
    }
    if (input[input.length - 1] === CR) {
      input = input.slice(0, input.length - 1);
    }
    return input;
  };
});

// ../../node_modules/.pnpm/npm-run-path@4.0.1/node_modules/npm-run-path/index.js
var require_npm_run_path2 = __commonJS2((exports2, module2) => {
  "use strict";
  var path4 = require("path");
  var pathKey = require_path_key2();
  var npmRunPath = (options) => {
    options = {
      cwd: process.cwd(),
      path: process.env[pathKey()],
      execPath: process.execPath,
      ...options
    };
    let previous;
    let cwdPath = path4.resolve(options.cwd);
    const result = [];
    while (previous !== cwdPath) {
      result.push(path4.join(cwdPath, "node_modules/.bin"));
      previous = cwdPath;
      cwdPath = path4.resolve(cwdPath, "..");
    }
    const execPathDir = path4.resolve(options.cwd, options.execPath, "..");
    result.push(execPathDir);
    return result.concat(options.path).join(path4.delimiter);
  };
  module2.exports = npmRunPath;
  module2.exports.default = npmRunPath;
  module2.exports.env = (options) => {
    options = {
      env: process.env,
      ...options
    };
    const env2 = {...options.env};
    const path5 = pathKey({env: env2});
    options.path = env2[path5];
    env2[path5] = module2.exports(options);
    return env2;
  };
});

// ../../node_modules/.pnpm/mimic-fn@2.1.0/node_modules/mimic-fn/index.js
var require_mimic_fn2 = __commonJS2((exports2, module2) => {
  "use strict";
  var mimicFn = (to, from) => {
    for (const prop of Reflect.ownKeys(from)) {
      Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
    }
    return to;
  };
  module2.exports = mimicFn;
  module2.exports.default = mimicFn;
});

// ../../node_modules/.pnpm/onetime@5.1.2/node_modules/onetime/index.js
var require_onetime2 = __commonJS2((exports2, module2) => {
  "use strict";
  var mimicFn = require_mimic_fn2();
  var calledFunctions = new WeakMap();
  var onetime = (function_, options = {}) => {
    if (typeof function_ !== "function") {
      throw new TypeError("Expected a function");
    }
    let returnValue;
    let callCount = 0;
    const functionName = function_.displayName || function_.name || "<anonymous>";
    const onetime2 = function(...arguments_) {
      calledFunctions.set(onetime2, ++callCount);
      if (callCount === 1) {
        returnValue = function_.apply(this, arguments_);
        function_ = null;
      } else if (options.throw === true) {
        throw new Error(`Function \`${functionName}\` can only be called once`);
      }
      return returnValue;
    };
    mimicFn(onetime2, function_);
    calledFunctions.set(onetime2, callCount);
    return onetime2;
  };
  module2.exports = onetime;
  module2.exports.default = onetime;
  module2.exports.callCount = (function_) => {
    if (!calledFunctions.has(function_)) {
      throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
    }
    return calledFunctions.get(function_);
  };
});

// ../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/core.js
var require_core2 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.SIGNALS = void 0;
  var SIGNALS = [
    {
      name: "SIGHUP",
      number: 1,
      action: "terminate",
      description: "Terminal closed",
      standard: "posix"
    },
    {
      name: "SIGINT",
      number: 2,
      action: "terminate",
      description: "User interruption with CTRL-C",
      standard: "ansi"
    },
    {
      name: "SIGQUIT",
      number: 3,
      action: "core",
      description: "User interruption with CTRL-\\",
      standard: "posix"
    },
    {
      name: "SIGILL",
      number: 4,
      action: "core",
      description: "Invalid machine instruction",
      standard: "ansi"
    },
    {
      name: "SIGTRAP",
      number: 5,
      action: "core",
      description: "Debugger breakpoint",
      standard: "posix"
    },
    {
      name: "SIGABRT",
      number: 6,
      action: "core",
      description: "Aborted",
      standard: "ansi"
    },
    {
      name: "SIGIOT",
      number: 6,
      action: "core",
      description: "Aborted",
      standard: "bsd"
    },
    {
      name: "SIGBUS",
      number: 7,
      action: "core",
      description: "Bus error due to misaligned, non-existing address or paging error",
      standard: "bsd"
    },
    {
      name: "SIGEMT",
      number: 7,
      action: "terminate",
      description: "Command should be emulated but is not implemented",
      standard: "other"
    },
    {
      name: "SIGFPE",
      number: 8,
      action: "core",
      description: "Floating point arithmetic error",
      standard: "ansi"
    },
    {
      name: "SIGKILL",
      number: 9,
      action: "terminate",
      description: "Forced termination",
      standard: "posix",
      forced: true
    },
    {
      name: "SIGUSR1",
      number: 10,
      action: "terminate",
      description: "Application-specific signal",
      standard: "posix"
    },
    {
      name: "SIGSEGV",
      number: 11,
      action: "core",
      description: "Segmentation fault",
      standard: "ansi"
    },
    {
      name: "SIGUSR2",
      number: 12,
      action: "terminate",
      description: "Application-specific signal",
      standard: "posix"
    },
    {
      name: "SIGPIPE",
      number: 13,
      action: "terminate",
      description: "Broken pipe or socket",
      standard: "posix"
    },
    {
      name: "SIGALRM",
      number: 14,
      action: "terminate",
      description: "Timeout or timer",
      standard: "posix"
    },
    {
      name: "SIGTERM",
      number: 15,
      action: "terminate",
      description: "Termination",
      standard: "ansi"
    },
    {
      name: "SIGSTKFLT",
      number: 16,
      action: "terminate",
      description: "Stack is empty or overflowed",
      standard: "other"
    },
    {
      name: "SIGCHLD",
      number: 17,
      action: "ignore",
      description: "Child process terminated, paused or unpaused",
      standard: "posix"
    },
    {
      name: "SIGCLD",
      number: 17,
      action: "ignore",
      description: "Child process terminated, paused or unpaused",
      standard: "other"
    },
    {
      name: "SIGCONT",
      number: 18,
      action: "unpause",
      description: "Unpaused",
      standard: "posix",
      forced: true
    },
    {
      name: "SIGSTOP",
      number: 19,
      action: "pause",
      description: "Paused",
      standard: "posix",
      forced: true
    },
    {
      name: "SIGTSTP",
      number: 20,
      action: "pause",
      description: 'Paused using CTRL-Z or "suspend"',
      standard: "posix"
    },
    {
      name: "SIGTTIN",
      number: 21,
      action: "pause",
      description: "Background process cannot read terminal input",
      standard: "posix"
    },
    {
      name: "SIGBREAK",
      number: 21,
      action: "terminate",
      description: "User interruption with CTRL-BREAK",
      standard: "other"
    },
    {
      name: "SIGTTOU",
      number: 22,
      action: "pause",
      description: "Background process cannot write to terminal output",
      standard: "posix"
    },
    {
      name: "SIGURG",
      number: 23,
      action: "ignore",
      description: "Socket received out-of-band data",
      standard: "bsd"
    },
    {
      name: "SIGXCPU",
      number: 24,
      action: "core",
      description: "Process timed out",
      standard: "bsd"
    },
    {
      name: "SIGXFSZ",
      number: 25,
      action: "core",
      description: "File too big",
      standard: "bsd"
    },
    {
      name: "SIGVTALRM",
      number: 26,
      action: "terminate",
      description: "Timeout or timer",
      standard: "bsd"
    },
    {
      name: "SIGPROF",
      number: 27,
      action: "terminate",
      description: "Timeout or timer",
      standard: "bsd"
    },
    {
      name: "SIGWINCH",
      number: 28,
      action: "ignore",
      description: "Terminal window size changed",
      standard: "bsd"
    },
    {
      name: "SIGIO",
      number: 29,
      action: "terminate",
      description: "I/O is available",
      standard: "other"
    },
    {
      name: "SIGPOLL",
      number: 29,
      action: "terminate",
      description: "Watched event",
      standard: "other"
    },
    {
      name: "SIGINFO",
      number: 29,
      action: "ignore",
      description: "Request for process information",
      standard: "other"
    },
    {
      name: "SIGPWR",
      number: 30,
      action: "terminate",
      description: "Device running out of power",
      standard: "systemv"
    },
    {
      name: "SIGSYS",
      number: 31,
      action: "core",
      description: "Invalid system call",
      standard: "other"
    },
    {
      name: "SIGUNUSED",
      number: 31,
      action: "terminate",
      description: "Invalid system call",
      standard: "other"
    }
  ];
  exports2.SIGNALS = SIGNALS;
});

// ../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/realtime.js
var require_realtime2 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.SIGRTMAX = exports2.getRealtimeSignals = void 0;
  var getRealtimeSignals = function() {
    const length = SIGRTMAX - SIGRTMIN + 1;
    return Array.from({length}, getRealtimeSignal);
  };
  exports2.getRealtimeSignals = getRealtimeSignals;
  var getRealtimeSignal = function(value, index) {
    return {
      name: `SIGRT${index + 1}`,
      number: SIGRTMIN + index,
      action: "terminate",
      description: "Application-specific signal (realtime)",
      standard: "posix"
    };
  };
  var SIGRTMIN = 34;
  var SIGRTMAX = 64;
  exports2.SIGRTMAX = SIGRTMAX;
});

// ../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/signals.js
var require_signals3 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getSignals = void 0;
  var _os = require("os");
  var _core = require_core2();
  var _realtime = require_realtime2();
  var getSignals = function() {
    const realtimeSignals = (0, _realtime.getRealtimeSignals)();
    const signals = [..._core.SIGNALS, ...realtimeSignals].map(normalizeSignal);
    return signals;
  };
  exports2.getSignals = getSignals;
  var normalizeSignal = function({
    name,
    number: defaultNumber,
    description,
    action,
    forced = false,
    standard
  }) {
    const {
      signals: {[name]: constantSignal}
    } = _os.constants;
    const supported = constantSignal !== void 0;
    const number = supported ? constantSignal : defaultNumber;
    return {name, number, description, supported, action, forced, standard};
  };
});

// ../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/main.js
var require_main2 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.signalsByNumber = exports2.signalsByName = void 0;
  var _os = require("os");
  var _signals = require_signals3();
  var _realtime = require_realtime2();
  var getSignalsByName = function() {
    const signals = (0, _signals.getSignals)();
    return signals.reduce(getSignalByName, {});
  };
  var getSignalByName = function(signalByNameMemo, {name, number, description, supported, action, forced, standard}) {
    return {
      ...signalByNameMemo,
      [name]: {name, number, description, supported, action, forced, standard}
    };
  };
  var signalsByName = getSignalsByName();
  exports2.signalsByName = signalsByName;
  var getSignalsByNumber = function() {
    const signals = (0, _signals.getSignals)();
    const length = _realtime.SIGRTMAX + 1;
    const signalsA = Array.from({length}, (value, number) => getSignalByNumber(number, signals));
    return Object.assign({}, ...signalsA);
  };
  var getSignalByNumber = function(number, signals) {
    const signal = findSignalByNumber(number, signals);
    if (signal === void 0) {
      return {};
    }
    const {name, description, supported, action, forced, standard} = signal;
    return {
      [number]: {
        name,
        number,
        description,
        supported,
        action,
        forced,
        standard
      }
    };
  };
  var findSignalByNumber = function(number, signals) {
    const signal = signals.find(({name}) => _os.constants.signals[name] === number);
    if (signal !== void 0) {
      return signal;
    }
    return signals.find((signalA) => signalA.number === number);
  };
  var signalsByNumber = getSignalsByNumber();
  exports2.signalsByNumber = signalsByNumber;
});

// ../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/error.js
var require_error3 = __commonJS2((exports2, module2) => {
  "use strict";
  var {signalsByName} = require_main2();
  var getErrorPrefix = ({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled}) => {
    if (timedOut) {
      return `timed out after ${timeout} milliseconds`;
    }
    if (isCanceled) {
      return "was canceled";
    }
    if (errorCode !== void 0) {
      return `failed with ${errorCode}`;
    }
    if (signal !== void 0) {
      return `was killed with ${signal} (${signalDescription})`;
    }
    if (exitCode !== void 0) {
      return `failed with exit code ${exitCode}`;
    }
    return "failed";
  };
  var makeError = ({
    stdout,
    stderr,
    all,
    error,
    signal,
    exitCode,
    command,
    escapedCommand,
    timedOut,
    isCanceled,
    killed,
    parsed: {options: {timeout}}
  }) => {
    exitCode = exitCode === null ? void 0 : exitCode;
    signal = signal === null ? void 0 : signal;
    const signalDescription = signal === void 0 ? void 0 : signalsByName[signal].description;
    const errorCode = error && error.code;
    const prefix = getErrorPrefix({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled});
    const execaMessage = `Command ${prefix}: ${command}`;
    const isError2 = Object.prototype.toString.call(error) === "[object Error]";
    const shortMessage = isError2 ? `${execaMessage}
${error.message}` : execaMessage;
    const message = [shortMessage, stderr, stdout].filter(Boolean).join("\n");
    if (isError2) {
      error.originalMessage = error.message;
      error.message = message;
    } else {
      error = new Error(message);
    }
    error.shortMessage = shortMessage;
    error.command = command;
    error.escapedCommand = escapedCommand;
    error.exitCode = exitCode;
    error.signal = signal;
    error.signalDescription = signalDescription;
    error.stdout = stdout;
    error.stderr = stderr;
    if (all !== void 0) {
      error.all = all;
    }
    if ("bufferedData" in error) {
      delete error.bufferedData;
    }
    error.failed = true;
    error.timedOut = Boolean(timedOut);
    error.isCanceled = isCanceled;
    error.killed = killed && !timedOut;
    return error;
  };
  module2.exports = makeError;
});

// ../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/stdio.js
var require_stdio2 = __commonJS2((exports2, module2) => {
  "use strict";
  var aliases = ["stdin", "stdout", "stderr"];
  var hasAlias = (options) => aliases.some((alias) => options[alias] !== void 0);
  var normalizeStdio = (options) => {
    if (!options) {
      return;
    }
    const {stdio} = options;
    if (stdio === void 0) {
      return aliases.map((alias) => options[alias]);
    }
    if (hasAlias(options)) {
      throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${aliases.map((alias) => `\`${alias}\``).join(", ")}`);
    }
    if (typeof stdio === "string") {
      return stdio;
    }
    if (!Array.isArray(stdio)) {
      throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
    }
    const length = Math.max(stdio.length, aliases.length);
    return Array.from({length}, (value, index) => stdio[index]);
  };
  module2.exports = normalizeStdio;
  module2.exports.node = (options) => {
    const stdio = normalizeStdio(options);
    if (stdio === "ipc") {
      return "ipc";
    }
    if (stdio === void 0 || typeof stdio === "string") {
      return [stdio, stdio, stdio, "ipc"];
    }
    if (stdio.includes("ipc")) {
      return stdio;
    }
    return [...stdio, "ipc"];
  };
});

// ../../node_modules/.pnpm/signal-exit@3.0.3/node_modules/signal-exit/signals.js
var require_signals4 = __commonJS2((exports2, module2) => {
  module2.exports = [
    "SIGABRT",
    "SIGALRM",
    "SIGHUP",
    "SIGINT",
    "SIGTERM"
  ];
  if (process.platform !== "win32") {
    module2.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
  }
  if (process.platform === "linux") {
    module2.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");
  }
});

// ../../node_modules/.pnpm/signal-exit@3.0.3/node_modules/signal-exit/index.js
var require_signal_exit2 = __commonJS2((exports2, module2) => {
  var assert = require("assert");
  var signals = require_signals4();
  var isWin = /^win/i.test(process.platform);
  var EE = require("events");
  if (typeof EE !== "function") {
    EE = EE.EventEmitter;
  }
  var emitter;
  if (process.__signal_exit_emitter__) {
    emitter = process.__signal_exit_emitter__;
  } else {
    emitter = process.__signal_exit_emitter__ = new EE();
    emitter.count = 0;
    emitter.emitted = {};
  }
  if (!emitter.infinite) {
    emitter.setMaxListeners(Infinity);
    emitter.infinite = true;
  }
  module2.exports = function(cb, opts) {
    assert.equal(typeof cb, "function", "a callback must be provided for exit handler");
    if (loaded === false) {
      load2();
    }
    var ev = "exit";
    if (opts && opts.alwaysLast) {
      ev = "afterexit";
    }
    var remove2 = function() {
      emitter.removeListener(ev, cb);
      if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
        unload();
      }
    };
    emitter.on(ev, cb);
    return remove2;
  };
  module2.exports.unload = unload;
  function unload() {
    if (!loaded) {
      return;
    }
    loaded = false;
    signals.forEach(function(sig) {
      try {
        process.removeListener(sig, sigListeners[sig]);
      } catch (er) {
      }
    });
    process.emit = originalProcessEmit;
    process.reallyExit = originalProcessReallyExit;
    emitter.count -= 1;
  }
  function emit(event, code, signal) {
    if (emitter.emitted[event]) {
      return;
    }
    emitter.emitted[event] = true;
    emitter.emit(event, code, signal);
  }
  var sigListeners = {};
  signals.forEach(function(sig) {
    sigListeners[sig] = function listener() {
      var listeners = process.listeners(sig);
      if (listeners.length === emitter.count) {
        unload();
        emit("exit", null, sig);
        emit("afterexit", null, sig);
        if (isWin && sig === "SIGHUP") {
          sig = "SIGINT";
        }
        process.kill(process.pid, sig);
      }
    };
  });
  module2.exports.signals = function() {
    return signals;
  };
  module2.exports.load = load2;
  var loaded = false;
  function load2() {
    if (loaded) {
      return;
    }
    loaded = true;
    emitter.count += 1;
    signals = signals.filter(function(sig) {
      try {
        process.on(sig, sigListeners[sig]);
        return true;
      } catch (er) {
        return false;
      }
    });
    process.emit = processEmit;
    process.reallyExit = processReallyExit;
  }
  var originalProcessReallyExit = process.reallyExit;
  function processReallyExit(code) {
    process.exitCode = code || 0;
    emit("exit", process.exitCode, null);
    emit("afterexit", process.exitCode, null);
    originalProcessReallyExit.call(process, process.exitCode);
  }
  var originalProcessEmit = process.emit;
  function processEmit(ev, arg2) {
    if (ev === "exit") {
      if (arg2 !== void 0) {
        process.exitCode = arg2;
      }
      var ret = originalProcessEmit.apply(this, arguments);
      emit("exit", process.exitCode, null);
      emit("afterexit", process.exitCode, null);
      return ret;
    } else {
      return originalProcessEmit.apply(this, arguments);
    }
  }
});

// ../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/kill.js
var require_kill2 = __commonJS2((exports2, module2) => {
  "use strict";
  var os2 = require("os");
  var onExit = require_signal_exit2();
  var DEFAULT_FORCE_KILL_TIMEOUT = 1e3 * 5;
  var spawnedKill = (kill, signal = "SIGTERM", options = {}) => {
    const killResult = kill(signal);
    setKillTimeout(kill, signal, options, killResult);
    return killResult;
  };
  var setKillTimeout = (kill, signal, options, killResult) => {
    if (!shouldForceKill(signal, options, killResult)) {
      return;
    }
    const timeout = getForceKillAfterTimeout(options);
    const t = setTimeout(() => {
      kill("SIGKILL");
    }, timeout);
    if (t.unref) {
      t.unref();
    }
  };
  var shouldForceKill = (signal, {forceKillAfterTimeout}, killResult) => {
    return isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
  };
  var isSigterm = (signal) => {
    return signal === os2.constants.signals.SIGTERM || typeof signal === "string" && signal.toUpperCase() === "SIGTERM";
  };
  var getForceKillAfterTimeout = ({forceKillAfterTimeout = true}) => {
    if (forceKillAfterTimeout === true) {
      return DEFAULT_FORCE_KILL_TIMEOUT;
    }
    if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {
      throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
    }
    return forceKillAfterTimeout;
  };
  var spawnedCancel = (spawned, context) => {
    const killResult = spawned.kill();
    if (killResult) {
      context.isCanceled = true;
    }
  };
  var timeoutKill = (spawned, signal, reject) => {
    spawned.kill(signal);
    reject(Object.assign(new Error("Timed out"), {timedOut: true, signal}));
  };
  var setupTimeout = (spawned, {timeout, killSignal = "SIGTERM"}, spawnedPromise) => {
    if (timeout === 0 || timeout === void 0) {
      return spawnedPromise;
    }
    let timeoutId;
    const timeoutPromise = new Promise((resolve, reject) => {
      timeoutId = setTimeout(() => {
        timeoutKill(spawned, killSignal, reject);
      }, timeout);
    });
    const safeSpawnedPromise = spawnedPromise.finally(() => {
      clearTimeout(timeoutId);
    });
    return Promise.race([timeoutPromise, safeSpawnedPromise]);
  };
  var validateTimeout = ({timeout}) => {
    if (timeout !== void 0 && (!Number.isFinite(timeout) || timeout < 0)) {
      throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
    }
  };
  var setExitHandler = async (spawned, {cleanup: cleanup2, detached}, timedPromise) => {
    if (!cleanup2 || detached) {
      return timedPromise;
    }
    const removeExitHandler = onExit(() => {
      spawned.kill();
    });
    return timedPromise.finally(() => {
      removeExitHandler();
    });
  };
  module2.exports = {
    spawnedKill,
    spawnedCancel,
    setupTimeout,
    validateTimeout,
    setExitHandler
  };
});

// ../../node_modules/.pnpm/is-stream@2.0.1/node_modules/is-stream/index.js
var require_is_stream2 = __commonJS2((exports2, module2) => {
  "use strict";
  var isStream = (stream) => stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
  isStream.writable = (stream) => isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
  isStream.readable = (stream) => isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
  isStream.duplex = (stream) => isStream.writable(stream) && isStream.readable(stream);
  isStream.transform = (stream) => isStream.duplex(stream) && typeof stream._transform === "function";
  module2.exports = isStream;
});

// ../../node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/buffer-stream.js
var require_buffer_stream2 = __commonJS2((exports2, module2) => {
  "use strict";
  var {PassThrough: PassThroughStream} = require("stream");
  module2.exports = (options) => {
    options = {...options};
    const {array} = options;
    let {encoding} = options;
    const isBuffer = encoding === "buffer";
    let objectMode = false;
    if (array) {
      objectMode = !(encoding || isBuffer);
    } else {
      encoding = encoding || "utf8";
    }
    if (isBuffer) {
      encoding = null;
    }
    const stream = new PassThroughStream({objectMode});
    if (encoding) {
      stream.setEncoding(encoding);
    }
    let length = 0;
    const chunks = [];
    stream.on("data", (chunk) => {
      chunks.push(chunk);
      if (objectMode) {
        length = chunks.length;
      } else {
        length += chunk.length;
      }
    });
    stream.getBufferedValue = () => {
      if (array) {
        return chunks;
      }
      return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
    };
    stream.getBufferedLength = () => length;
    return stream;
  };
});

// ../../node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/index.js
var require_get_stream2 = __commonJS2((exports2, module2) => {
  "use strict";
  var {constants: BufferConstants} = require("buffer");
  var stream = require("stream");
  var {promisify: promisify2} = require("util");
  var bufferStream = require_buffer_stream2();
  var streamPipelinePromisified = promisify2(stream.pipeline);
  var MaxBufferError = class extends Error {
    constructor() {
      super("maxBuffer exceeded");
      this.name = "MaxBufferError";
    }
  };
  async function getStream(inputStream, options) {
    if (!inputStream) {
      throw new Error("Expected a stream");
    }
    options = {
      maxBuffer: Infinity,
      ...options
    };
    const {maxBuffer} = options;
    const stream2 = bufferStream(options);
    await new Promise((resolve, reject) => {
      const rejectPromise = (error) => {
        if (error && stream2.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
          error.bufferedData = stream2.getBufferedValue();
        }
        reject(error);
      };
      (async () => {
        try {
          await streamPipelinePromisified(inputStream, stream2);
          resolve();
        } catch (error) {
          rejectPromise(error);
        }
      })();
      stream2.on("data", () => {
        if (stream2.getBufferedLength() > maxBuffer) {
          rejectPromise(new MaxBufferError());
        }
      });
    });
    return stream2.getBufferedValue();
  }
  module2.exports = getStream;
  module2.exports.buffer = (stream2, options) => getStream(stream2, {...options, encoding: "buffer"});
  module2.exports.array = (stream2, options) => getStream(stream2, {...options, array: true});
  module2.exports.MaxBufferError = MaxBufferError;
});

// ../../node_modules/.pnpm/merge-stream@2.0.0/node_modules/merge-stream/index.js
var require_merge_stream2 = __commonJS2((exports2, module2) => {
  "use strict";
  var {PassThrough} = require("stream");
  module2.exports = function() {
    var sources = [];
    var output = new PassThrough({objectMode: true});
    output.setMaxListeners(0);
    output.add = add2;
    output.isEmpty = isEmpty;
    output.on("unpipe", remove2);
    Array.prototype.slice.call(arguments).forEach(add2);
    return output;
    function add2(source) {
      if (Array.isArray(source)) {
        source.forEach(add2);
        return this;
      }
      sources.push(source);
      source.once("end", remove2.bind(null, source));
      source.once("error", output.emit.bind(output, "error"));
      source.pipe(output, {end: false});
      return this;
    }
    function isEmpty() {
      return sources.length == 0;
    }
    function remove2(source) {
      sources = sources.filter(function(it) {
        return it !== source;
      });
      if (!sources.length && output.readable) {
        output.end();
      }
    }
  };
});

// ../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/stream.js
var require_stream6 = __commonJS2((exports2, module2) => {
  "use strict";
  var isStream = require_is_stream2();
  var getStream = require_get_stream2();
  var mergeStream = require_merge_stream2();
  var handleInput = (spawned, input) => {
    if (input === void 0 || spawned.stdin === void 0) {
      return;
    }
    if (isStream(input)) {
      input.pipe(spawned.stdin);
    } else {
      spawned.stdin.end(input);
    }
  };
  var makeAllStream = (spawned, {all}) => {
    if (!all || !spawned.stdout && !spawned.stderr) {
      return;
    }
    const mixed = mergeStream();
    if (spawned.stdout) {
      mixed.add(spawned.stdout);
    }
    if (spawned.stderr) {
      mixed.add(spawned.stderr);
    }
    return mixed;
  };
  var getBufferedData = async (stream, streamPromise) => {
    if (!stream) {
      return;
    }
    stream.destroy();
    try {
      return await streamPromise;
    } catch (error) {
      return error.bufferedData;
    }
  };
  var getStreamPromise = (stream, {encoding, buffer, maxBuffer}) => {
    if (!stream || !buffer) {
      return;
    }
    if (encoding) {
      return getStream(stream, {encoding, maxBuffer});
    }
    return getStream.buffer(stream, {maxBuffer});
  };
  var getSpawnedResult = async ({stdout, stderr, all}, {encoding, buffer, maxBuffer}, processDone) => {
    const stdoutPromise = getStreamPromise(stdout, {encoding, buffer, maxBuffer});
    const stderrPromise = getStreamPromise(stderr, {encoding, buffer, maxBuffer});
    const allPromise = getStreamPromise(all, {encoding, buffer, maxBuffer: maxBuffer * 2});
    try {
      return await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);
    } catch (error) {
      return Promise.all([
        {error, signal: error.signal, timedOut: error.timedOut},
        getBufferedData(stdout, stdoutPromise),
        getBufferedData(stderr, stderrPromise),
        getBufferedData(all, allPromise)
      ]);
    }
  };
  var validateInputSync = ({input}) => {
    if (isStream(input)) {
      throw new TypeError("The `input` option cannot be a stream in sync mode");
    }
  };
  module2.exports = {
    handleInput,
    makeAllStream,
    getSpawnedResult,
    validateInputSync
  };
});

// ../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/promise.js
var require_promise2 = __commonJS2((exports2, module2) => {
  "use strict";
  var nativePromisePrototype = (async () => {
  })().constructor.prototype;
  var descriptors = ["then", "catch", "finally"].map((property) => [
    property,
    Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
  ]);
  var mergePromise = (spawned, promise) => {
    for (const [property, descriptor] of descriptors) {
      const value = typeof promise === "function" ? (...args) => Reflect.apply(descriptor.value, promise(), args) : descriptor.value.bind(promise);
      Reflect.defineProperty(spawned, property, {...descriptor, value});
    }
    return spawned;
  };
  var getSpawnedPromise = (spawned) => {
    return new Promise((resolve, reject) => {
      spawned.on("exit", (exitCode, signal) => {
        resolve({exitCode, signal});
      });
      spawned.on("error", (error) => {
        reject(error);
      });
      if (spawned.stdin) {
        spawned.stdin.on("error", (error) => {
          reject(error);
        });
      }
    });
  };
  module2.exports = {
    mergePromise,
    getSpawnedPromise
  };
});

// ../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/command.js
var require_command2 = __commonJS2((exports2, module2) => {
  "use strict";
  var normalizeArgs = (file, args = []) => {
    if (!Array.isArray(args)) {
      return [file];
    }
    return [file, ...args];
  };
  var NO_ESCAPE_REGEXP = /^[\w.-]+$/;
  var DOUBLE_QUOTES_REGEXP = /"/g;
  var escapeArg = (arg2) => {
    if (typeof arg2 !== "string" || NO_ESCAPE_REGEXP.test(arg2)) {
      return arg2;
    }
    return `"${arg2.replace(DOUBLE_QUOTES_REGEXP, '\\"')}"`;
  };
  var joinCommand = (file, args) => {
    return normalizeArgs(file, args).join(" ");
  };
  var getEscapedCommand = (file, args) => {
    return normalizeArgs(file, args).map((arg2) => escapeArg(arg2)).join(" ");
  };
  var SPACES_REGEXP = / +/g;
  var parseCommand = (command) => {
    const tokens = [];
    for (const token of command.trim().split(SPACES_REGEXP)) {
      const previousToken = tokens[tokens.length - 1];
      if (previousToken && previousToken.endsWith("\\")) {
        tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
      } else {
        tokens.push(token);
      }
    }
    return tokens;
  };
  module2.exports = {
    joinCommand,
    getEscapedCommand,
    parseCommand
  };
});

// ../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/index.js
var require_execa2 = __commonJS2((exports2, module2) => {
  "use strict";
  var path4 = require("path");
  var childProcess = require("child_process");
  var crossSpawn = require_cross_spawn2();
  var stripFinalNewline = require_strip_final_newline2();
  var npmRunPath = require_npm_run_path2();
  var onetime = require_onetime2();
  var makeError = require_error3();
  var normalizeStdio = require_stdio2();
  var {spawnedKill, spawnedCancel, setupTimeout, validateTimeout, setExitHandler} = require_kill2();
  var {handleInput, getSpawnedResult, makeAllStream, validateInputSync} = require_stream6();
  var {mergePromise, getSpawnedPromise} = require_promise2();
  var {joinCommand, parseCommand, getEscapedCommand} = require_command2();
  var DEFAULT_MAX_BUFFER = 1e3 * 1e3 * 100;
  var getEnv = ({env: envOption, extendEnv, preferLocal, localDir, execPath}) => {
    const env2 = extendEnv ? {...process.env, ...envOption} : envOption;
    if (preferLocal) {
      return npmRunPath.env({env: env2, cwd: localDir, execPath});
    }
    return env2;
  };
  var handleArguments = (file, args, options = {}) => {
    const parsed = crossSpawn._parse(file, args, options);
    file = parsed.command;
    args = parsed.args;
    options = parsed.options;
    options = {
      maxBuffer: DEFAULT_MAX_BUFFER,
      buffer: true,
      stripFinalNewline: true,
      extendEnv: true,
      preferLocal: false,
      localDir: options.cwd || process.cwd(),
      execPath: process.execPath,
      encoding: "utf8",
      reject: true,
      cleanup: true,
      all: false,
      windowsHide: true,
      ...options
    };
    options.env = getEnv(options);
    options.stdio = normalizeStdio(options);
    if (process.platform === "win32" && path4.basename(file, ".exe") === "cmd") {
      args.unshift("/q");
    }
    return {file, args, options, parsed};
  };
  var handleOutput = (options, value, error) => {
    if (typeof value !== "string" && !Buffer.isBuffer(value)) {
      return error === void 0 ? void 0 : "";
    }
    if (options.stripFinalNewline) {
      return stripFinalNewline(value);
    }
    return value;
  };
  var execa = (file, args, options) => {
    const parsed = handleArguments(file, args, options);
    const command = joinCommand(file, args);
    const escapedCommand = getEscapedCommand(file, args);
    validateTimeout(parsed.options);
    let spawned;
    try {
      spawned = childProcess.spawn(parsed.file, parsed.args, parsed.options);
    } catch (error) {
      const dummySpawned = new childProcess.ChildProcess();
      const errorPromise = Promise.reject(makeError({
        error,
        stdout: "",
        stderr: "",
        all: "",
        command,
        escapedCommand,
        parsed,
        timedOut: false,
        isCanceled: false,
        killed: false
      }));
      return mergePromise(dummySpawned, errorPromise);
    }
    const spawnedPromise = getSpawnedPromise(spawned);
    const timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);
    const processDone = setExitHandler(spawned, parsed.options, timedPromise);
    const context = {isCanceled: false};
    spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));
    spawned.cancel = spawnedCancel.bind(null, spawned, context);
    const handlePromise = async () => {
      const [{error, exitCode, signal, timedOut}, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone);
      const stdout = handleOutput(parsed.options, stdoutResult);
      const stderr = handleOutput(parsed.options, stderrResult);
      const all = handleOutput(parsed.options, allResult);
      if (error || exitCode !== 0 || signal !== null) {
        const returnedError = makeError({
          error,
          exitCode,
          signal,
          stdout,
          stderr,
          all,
          command,
          escapedCommand,
          parsed,
          timedOut,
          isCanceled: context.isCanceled,
          killed: spawned.killed
        });
        if (!parsed.options.reject) {
          return returnedError;
        }
        throw returnedError;
      }
      return {
        command,
        escapedCommand,
        exitCode: 0,
        stdout,
        stderr,
        all,
        failed: false,
        timedOut: false,
        isCanceled: false,
        killed: false
      };
    };
    const handlePromiseOnce = onetime(handlePromise);
    handleInput(spawned, parsed.options.input);
    spawned.all = makeAllStream(spawned, parsed.options);
    return mergePromise(spawned, handlePromiseOnce);
  };
  module2.exports = execa;
  module2.exports.sync = (file, args, options) => {
    const parsed = handleArguments(file, args, options);
    const command = joinCommand(file, args);
    const escapedCommand = getEscapedCommand(file, args);
    validateInputSync(parsed.options);
    let result;
    try {
      result = childProcess.spawnSync(parsed.file, parsed.args, parsed.options);
    } catch (error) {
      throw makeError({
        error,
        stdout: "",
        stderr: "",
        all: "",
        command,
        escapedCommand,
        parsed,
        timedOut: false,
        isCanceled: false,
        killed: false
      });
    }
    const stdout = handleOutput(parsed.options, result.stdout, result.error);
    const stderr = handleOutput(parsed.options, result.stderr, result.error);
    if (result.error || result.status !== 0 || result.signal !== null) {
      const error = makeError({
        stdout,
        stderr,
        error: result.error,
        signal: result.signal,
        exitCode: result.status,
        command,
        escapedCommand,
        parsed,
        timedOut: result.error && result.error.code === "ETIMEDOUT",
        isCanceled: false,
        killed: result.signal !== null
      });
      if (!parsed.options.reject) {
        return error;
      }
      throw error;
    }
    return {
      command,
      escapedCommand,
      exitCode: 0,
      stdout,
      stderr,
      failed: false,
      timedOut: false,
      isCanceled: false,
      killed: false
    };
  };
  module2.exports.command = (command, options) => {
    const [file, ...args] = parseCommand(command);
    return execa(file, args, options);
  };
  module2.exports.commandSync = (command, options) => {
    const [file, ...args] = parseCommand(command);
    return execa.sync(file, args, options);
  };
  module2.exports.node = (scriptPath, args, options = {}) => {
    if (args && !Array.isArray(args) && typeof args === "object") {
      options = args;
      args = [];
    }
    const stdio = normalizeStdio.node(options);
    const defaultExecArgv = process.execArgv.filter((arg2) => !arg2.startsWith("--inspect"));
    const {
      nodePath = process.execPath,
      nodeOptions = defaultExecArgv
    } = options;
    return execa(nodePath, [
      ...nodeOptions,
      scriptPath,
      ...Array.isArray(args) ? args : []
    ], {
      ...options,
      stdin: void 0,
      stdout: void 0,
      stderr: void 0,
      stdio,
      shell: false
    });
  };
});

// ../../node_modules/.pnpm/p-try@2.2.0/node_modules/p-try/index.js
var require_p_try2 = __commonJS2((exports2, module2) => {
  "use strict";
  var pTry = (fn, ...arguments_) => new Promise((resolve) => {
    resolve(fn(...arguments_));
  });
  module2.exports = pTry;
  module2.exports.default = pTry;
});

// ../../node_modules/.pnpm/p-limit@2.3.0/node_modules/p-limit/index.js
var require_p_limit2 = __commonJS2((exports2, module2) => {
  "use strict";
  var pTry = require_p_try2();
  var pLimit = (concurrency) => {
    if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
      return Promise.reject(new TypeError("Expected `concurrency` to be a number from 1 and up"));
    }
    const queue = [];
    let activeCount = 0;
    const next = () => {
      activeCount--;
      if (queue.length > 0) {
        queue.shift()();
      }
    };
    const run = (fn, resolve, ...args) => {
      activeCount++;
      const result = pTry(fn, ...args);
      resolve(result);
      result.then(next, next);
    };
    const enqueue = (fn, resolve, ...args) => {
      if (activeCount < concurrency) {
        run(fn, resolve, ...args);
      } else {
        queue.push(run.bind(null, fn, resolve, ...args));
      }
    };
    const generator = (fn, ...args) => new Promise((resolve) => enqueue(fn, resolve, ...args));
    Object.defineProperties(generator, {
      activeCount: {
        get: () => activeCount
      },
      pendingCount: {
        get: () => queue.length
      },
      clearQueue: {
        value: () => {
          queue.length = 0;
        }
      }
    });
    return generator;
  };
  module2.exports = pLimit;
  module2.exports.default = pLimit;
});

// ../../node_modules/.pnpm/p-locate@4.1.0/node_modules/p-locate/index.js
var require_p_locate2 = __commonJS2((exports2, module2) => {
  "use strict";
  var pLimit = require_p_limit2();
  var EndError = class extends Error {
    constructor(value) {
      super();
      this.value = value;
    }
  };
  var testElement = async (element, tester) => tester(await element);
  var finder = async (element) => {
    const values = await Promise.all(element);
    if (values[1] === true) {
      throw new EndError(values[0]);
    }
    return false;
  };
  var pLocate = async (iterable, tester, options) => {
    options = {
      concurrency: Infinity,
      preserveOrder: true,
      ...options
    };
    const limit = pLimit(options.concurrency);
    const items = [...iterable].map((element) => [element, limit(testElement, element, tester)]);
    const checkLimit = pLimit(options.preserveOrder ? 1 : Infinity);
    try {
      await Promise.all(items.map((element) => checkLimit(finder, element)));
    } catch (error) {
      if (error instanceof EndError) {
        return error.value;
      }
      throw error;
    }
  };
  module2.exports = pLocate;
  module2.exports.default = pLocate;
});

// ../../node_modules/.pnpm/locate-path@5.0.0/node_modules/locate-path/index.js
var require_locate_path2 = __commonJS2((exports2, module2) => {
  "use strict";
  var path4 = require("path");
  var fs2 = require("fs");
  var {promisify: promisify2} = require("util");
  var pLocate = require_p_locate2();
  var fsStat = promisify2(fs2.stat);
  var fsLStat = promisify2(fs2.lstat);
  var typeMappings = {
    directory: "isDirectory",
    file: "isFile"
  };
  function checkType({type}) {
    if (type in typeMappings) {
      return;
    }
    throw new Error(`Invalid type specified: ${type}`);
  }
  var matchType = (type, stat2) => type === void 0 || stat2[typeMappings[type]]();
  module2.exports = async (paths, options) => {
    options = {
      cwd: process.cwd(),
      type: "file",
      allowSymlinks: true,
      ...options
    };
    checkType(options);
    const statFn = options.allowSymlinks ? fsStat : fsLStat;
    return pLocate(paths, async (path_) => {
      try {
        const stat2 = await statFn(path4.resolve(options.cwd, path_));
        return matchType(options.type, stat2);
      } catch (_2) {
        return false;
      }
    }, options);
  };
  module2.exports.sync = (paths, options) => {
    options = {
      cwd: process.cwd(),
      allowSymlinks: true,
      type: "file",
      ...options
    };
    checkType(options);
    const statFn = options.allowSymlinks ? fs2.statSync : fs2.lstatSync;
    for (const path_ of paths) {
      try {
        const stat2 = statFn(path4.resolve(options.cwd, path_));
        if (matchType(options.type, stat2)) {
          return path_;
        }
      } catch (_2) {
      }
    }
  };
});

// ../../node_modules/.pnpm/path-exists@4.0.0/node_modules/path-exists/index.js
var require_path_exists2 = __commonJS2((exports2, module2) => {
  "use strict";
  var fs2 = require("fs");
  var {promisify: promisify2} = require("util");
  var pAccess = promisify2(fs2.access);
  module2.exports = async (path4) => {
    try {
      await pAccess(path4);
      return true;
    } catch (_2) {
      return false;
    }
  };
  module2.exports.sync = (path4) => {
    try {
      fs2.accessSync(path4);
      return true;
    } catch (_2) {
      return false;
    }
  };
});

// ../../node_modules/.pnpm/find-up@4.1.0/node_modules/find-up/index.js
var require_find_up2 = __commonJS2((exports2, module2) => {
  "use strict";
  var path4 = require("path");
  var locatePath = require_locate_path2();
  var pathExists = require_path_exists2();
  var stop = Symbol("findUp.stop");
  module2.exports = async (name, options = {}) => {
    let directory = path4.resolve(options.cwd || "");
    const {root} = path4.parse(directory);
    const paths = [].concat(name);
    const runMatcher = async (locateOptions) => {
      if (typeof name !== "function") {
        return locatePath(paths, locateOptions);
      }
      const foundPath = await name(locateOptions.cwd);
      if (typeof foundPath === "string") {
        return locatePath([foundPath], locateOptions);
      }
      return foundPath;
    };
    while (true) {
      const foundPath = await runMatcher({...options, cwd: directory});
      if (foundPath === stop) {
        return;
      }
      if (foundPath) {
        return path4.resolve(directory, foundPath);
      }
      if (directory === root) {
        return;
      }
      directory = path4.dirname(directory);
    }
  };
  module2.exports.sync = (name, options = {}) => {
    let directory = path4.resolve(options.cwd || "");
    const {root} = path4.parse(directory);
    const paths = [].concat(name);
    const runMatcher = (locateOptions) => {
      if (typeof name !== "function") {
        return locatePath.sync(paths, locateOptions);
      }
      const foundPath = name(locateOptions.cwd);
      if (typeof foundPath === "string") {
        return locatePath.sync([foundPath], locateOptions);
      }
      return foundPath;
    };
    while (true) {
      const foundPath = runMatcher({...options, cwd: directory});
      if (foundPath === stop) {
        return;
      }
      if (foundPath) {
        return path4.resolve(directory, foundPath);
      }
      if (directory === root) {
        return;
      }
      directory = path4.dirname(directory);
    }
  };
  module2.exports.exists = pathExists;
  module2.exports.sync.exists = pathExists.sync;
  module2.exports.stop = stop;
});

// ../../node_modules/.pnpm/is-arrayish@0.2.1/node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = function isArrayish(obj) {
    if (!obj) {
      return false;
    }
    return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && obj.splice instanceof Function;
  };
});

// ../../node_modules/.pnpm/error-ex@1.3.2/node_modules/error-ex/index.js
var require_error_ex = __commonJS2((exports2, module2) => {
  "use strict";
  var util2 = require("util");
  var isArrayish = require_is_arrayish();
  var errorEx = function errorEx2(name, properties) {
    if (!name || name.constructor !== String) {
      properties = name || {};
      name = Error.name;
    }
    var errorExError = function ErrorEXError(message) {
      if (!this) {
        return new ErrorEXError(message);
      }
      message = message instanceof Error ? message.message : message || this.message;
      Error.call(this, message);
      Error.captureStackTrace(this, errorExError);
      this.name = name;
      Object.defineProperty(this, "message", {
        configurable: true,
        enumerable: false,
        get: function() {
          var newMessage = message.split(/\r?\n/g);
          for (var key in properties) {
            if (!properties.hasOwnProperty(key)) {
              continue;
            }
            var modifier = properties[key];
            if ("message" in modifier) {
              newMessage = modifier.message(this[key], newMessage) || newMessage;
              if (!isArrayish(newMessage)) {
                newMessage = [newMessage];
              }
            }
          }
          return newMessage.join("\n");
        },
        set: function(v) {
          message = v;
        }
      });
      var overwrittenStack = null;
      var stackDescriptor = Object.getOwnPropertyDescriptor(this, "stack");
      var stackGetter = stackDescriptor.get;
      var stackValue = stackDescriptor.value;
      delete stackDescriptor.value;
      delete stackDescriptor.writable;
      stackDescriptor.set = function(newstack) {
        overwrittenStack = newstack;
      };
      stackDescriptor.get = function() {
        var stack = (overwrittenStack || (stackGetter ? stackGetter.call(this) : stackValue)).split(/\r?\n+/g);
        if (!overwrittenStack) {
          stack[0] = this.name + ": " + this.message;
        }
        var lineCount = 1;
        for (var key in properties) {
          if (!properties.hasOwnProperty(key)) {
            continue;
          }
          var modifier = properties[key];
          if ("line" in modifier) {
            var line = modifier.line(this[key]);
            if (line) {
              stack.splice(lineCount++, 0, "    " + line);
            }
          }
          if ("stack" in modifier) {
            modifier.stack(this[key], stack);
          }
        }
        return stack.join("\n");
      };
      Object.defineProperty(this, "stack", stackDescriptor);
    };
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(errorExError.prototype, Error.prototype);
      Object.setPrototypeOf(errorExError, Error);
    } else {
      util2.inherits(errorExError, Error);
    }
    return errorExError;
  };
  errorEx.append = function(str, def) {
    return {
      message: function(v, message) {
        v = v || def;
        if (v) {
          message[0] += " " + str.replace("%s", v.toString());
        }
        return message;
      }
    };
  };
  errorEx.line = function(str, def) {
    return {
      line: function(v) {
        v = v || def;
        if (v) {
          return str.replace("%s", v.toString());
        }
        return null;
      }
    };
  };
  module2.exports = errorEx;
});

// ../../node_modules/.pnpm/json-parse-even-better-errors@2.3.1/node_modules/json-parse-even-better-errors/index.js
var require_json_parse_even_better_errors = __commonJS2((exports2, module2) => {
  "use strict";
  var hexify = (char) => {
    const h2 = char.charCodeAt(0).toString(16).toUpperCase();
    return "0x" + (h2.length % 2 ? "0" : "") + h2;
  };
  var parseError = (e, txt, context) => {
    if (!txt) {
      return {
        message: e.message + " while parsing empty string",
        position: 0
      };
    }
    const badToken = e.message.match(/^Unexpected token (.) .*position\s+(\d+)/i);
    const errIdx = badToken ? +badToken[2] : e.message.match(/^Unexpected end of JSON.*/i) ? txt.length - 1 : null;
    const msg = badToken ? e.message.replace(/^Unexpected token ./, `Unexpected token ${JSON.stringify(badToken[1])} (${hexify(badToken[1])})`) : e.message;
    if (errIdx !== null && errIdx !== void 0) {
      const start = errIdx <= context ? 0 : errIdx - context;
      const end = errIdx + context >= txt.length ? txt.length : errIdx + context;
      const slice = (start === 0 ? "" : "...") + txt.slice(start, end) + (end === txt.length ? "" : "...");
      const near = txt === slice ? "" : "near ";
      return {
        message: msg + ` while parsing ${near}${JSON.stringify(slice)}`,
        position: errIdx
      };
    } else {
      return {
        message: msg + ` while parsing '${txt.slice(0, context * 2)}'`,
        position: 0
      };
    }
  };
  var JSONParseError = class extends SyntaxError {
    constructor(er, txt, context, caller) {
      context = context || 20;
      const metadata = parseError(er, txt, context);
      super(metadata.message);
      Object.assign(this, metadata);
      this.code = "EJSONPARSE";
      this.systemError = er;
      Error.captureStackTrace(this, caller || this.constructor);
    }
    get name() {
      return this.constructor.name;
    }
    set name(n) {
    }
    get [Symbol.toStringTag]() {
      return this.constructor.name;
    }
  };
  var kIndent = Symbol.for("indent");
  var kNewline = Symbol.for("newline");
  var formatRE = /^\s*[{\[]((?:\r?\n)+)([\s\t]*)/;
  var emptyRE = /^(?:\{\}|\[\])((?:\r?\n)+)?$/;
  var parseJson = (txt, reviver, context) => {
    const parseText = stripBOM(txt);
    context = context || 20;
    try {
      const [, newline = "\n", indent14 = "  "] = parseText.match(emptyRE) || parseText.match(formatRE) || [, "", ""];
      const result = JSON.parse(parseText, reviver);
      if (result && typeof result === "object") {
        result[kNewline] = newline;
        result[kIndent] = indent14;
      }
      return result;
    } catch (e) {
      if (typeof txt !== "string" && !Buffer.isBuffer(txt)) {
        const isEmptyArray = Array.isArray(txt) && txt.length === 0;
        throw Object.assign(new TypeError(`Cannot parse ${isEmptyArray ? "an empty array" : String(txt)}`), {
          code: "EJSONPARSE",
          systemError: e
        });
      }
      throw new JSONParseError(e, parseText, context, parseJson);
    }
  };
  var stripBOM = (txt) => String(txt).replace(/^\uFEFF/, "");
  module2.exports = parseJson;
  parseJson.JSONParseError = JSONParseError;
  parseJson.noExceptions = (txt, reviver) => {
    try {
      return JSON.parse(stripBOM(txt), reviver);
    } catch (e) {
    }
  };
});

// ../../node_modules/.pnpm/lines-and-columns@1.1.6/node_modules/lines-and-columns/dist/index.js
var require_dist9 = __commonJS2((exports2) => {
  "use strict";
  var LF = "\n";
  var CR = "\r";
  var LinesAndColumns = function() {
    function LinesAndColumns2(string) {
      this.string = string;
      var offsets = [0];
      for (var offset = 0; offset < string.length; ) {
        switch (string[offset]) {
          case LF:
            offset += LF.length;
            offsets.push(offset);
            break;
          case CR:
            offset += CR.length;
            if (string[offset] === LF) {
              offset += LF.length;
            }
            offsets.push(offset);
            break;
          default:
            offset++;
            break;
        }
      }
      this.offsets = offsets;
    }
    LinesAndColumns2.prototype.locationForIndex = function(index) {
      if (index < 0 || index > this.string.length) {
        return null;
      }
      var line = 0;
      var offsets = this.offsets;
      while (offsets[line + 1] <= index) {
        line++;
      }
      var column = index - offsets[line];
      return {line, column};
    };
    LinesAndColumns2.prototype.indexForLocation = function(location) {
      var line = location.line, column = location.column;
      if (line < 0 || line >= this.offsets.length) {
        return null;
      }
      if (column < 0 || column > this.lengthOfLine(line)) {
        return null;
      }
      return this.offsets[line] + column;
    };
    LinesAndColumns2.prototype.lengthOfLine = function(line) {
      var offset = this.offsets[line];
      var nextOffset = line === this.offsets.length - 1 ? this.string.length : this.offsets[line + 1];
      return nextOffset - offset;
    };
    return LinesAndColumns2;
  }();
  exports2.__esModule = true;
  exports2["default"] = LinesAndColumns;
});

// ../../node_modules/.pnpm/js-tokens@4.0.0/node_modules/js-tokens/index.js
var require_js_tokens = __commonJS2((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
  exports2.matchToToken = function(match) {
    var token = {type: "invalid", value: match[0], closed: void 0};
    if (match[1])
      token.type = "string", token.closed = !!(match[3] || match[4]);
    else if (match[5])
      token.type = "comment";
    else if (match[6])
      token.type = "comment", token.closed = !!match[7];
    else if (match[8])
      token.type = "regex";
    else if (match[9])
      token.type = "number";
    else if (match[10])
      token.type = "name";
    else if (match[11])
      token.type = "punctuator";
    else if (match[12])
      token.type = "whitespace";
    return token;
  };
});

// ../../node_modules/.pnpm/@babel+helper-validator-identifier@7.14.8/node_modules/@babel/helper-validator-identifier/lib/identifier.js
var require_identifier = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.isIdentifierStart = isIdentifierStart;
  exports2.isIdentifierChar = isIdentifierChar;
  exports2.isIdentifierName = isIdentifierName;
  var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
  var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
  var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
  var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function isInAstralSet(code, set) {
    let pos = 65536;
    for (let i = 0, length = set.length; i < length; i += 2) {
      pos += set[i];
      if (pos > code)
        return false;
      pos += set[i + 1];
      if (pos >= code)
        return true;
    }
    return false;
  }
  function isIdentifierStart(code) {
    if (code < 65)
      return code === 36;
    if (code <= 90)
      return true;
    if (code < 97)
      return code === 95;
    if (code <= 122)
      return true;
    if (code <= 65535) {
      return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
    }
    return isInAstralSet(code, astralIdentifierStartCodes);
  }
  function isIdentifierChar(code) {
    if (code < 48)
      return code === 36;
    if (code < 58)
      return true;
    if (code < 65)
      return false;
    if (code <= 90)
      return true;
    if (code < 97)
      return code === 95;
    if (code <= 122)
      return true;
    if (code <= 65535) {
      return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
    }
    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
  }
  function isIdentifierName(name) {
    let isFirst = true;
    for (let i = 0; i < name.length; i++) {
      let cp = name.charCodeAt(i);
      if ((cp & 64512) === 55296 && i + 1 < name.length) {
        const trail = name.charCodeAt(++i);
        if ((trail & 64512) === 56320) {
          cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
        }
      }
      if (isFirst) {
        isFirst = false;
        if (!isIdentifierStart(cp)) {
          return false;
        }
      } else if (!isIdentifierChar(cp)) {
        return false;
      }
    }
    return !isFirst;
  }
});

// ../../node_modules/.pnpm/@babel+helper-validator-identifier@7.14.8/node_modules/@babel/helper-validator-identifier/lib/keyword.js
var require_keyword = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.isReservedWord = isReservedWord;
  exports2.isStrictReservedWord = isStrictReservedWord;
  exports2.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
  exports2.isStrictBindReservedWord = isStrictBindReservedWord;
  exports2.isKeyword = isKeyword;
  var reservedWords = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  };
  var keywords = new Set(reservedWords.keyword);
  var reservedWordsStrictSet = new Set(reservedWords.strict);
  var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
  function isReservedWord(word, inModule) {
    return inModule && word === "await" || word === "enum";
  }
  function isStrictReservedWord(word, inModule) {
    return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
  }
  function isStrictBindOnlyReservedWord(word) {
    return reservedWordsStrictBindSet.has(word);
  }
  function isStrictBindReservedWord(word, inModule) {
    return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
  }
  function isKeyword(word) {
    return keywords.has(word);
  }
});

// ../../node_modules/.pnpm/@babel+helper-validator-identifier@7.14.8/node_modules/@babel/helper-validator-identifier/lib/index.js
var require_lib2 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  Object.defineProperty(exports2, "isIdentifierName", {
    enumerable: true,
    get: function() {
      return _identifier.isIdentifierName;
    }
  });
  Object.defineProperty(exports2, "isIdentifierChar", {
    enumerable: true,
    get: function() {
      return _identifier.isIdentifierChar;
    }
  });
  Object.defineProperty(exports2, "isIdentifierStart", {
    enumerable: true,
    get: function() {
      return _identifier.isIdentifierStart;
    }
  });
  Object.defineProperty(exports2, "isReservedWord", {
    enumerable: true,
    get: function() {
      return _keyword.isReservedWord;
    }
  });
  Object.defineProperty(exports2, "isStrictBindOnlyReservedWord", {
    enumerable: true,
    get: function() {
      return _keyword.isStrictBindOnlyReservedWord;
    }
  });
  Object.defineProperty(exports2, "isStrictBindReservedWord", {
    enumerable: true,
    get: function() {
      return _keyword.isStrictBindReservedWord;
    }
  });
  Object.defineProperty(exports2, "isStrictReservedWord", {
    enumerable: true,
    get: function() {
      return _keyword.isStrictReservedWord;
    }
  });
  Object.defineProperty(exports2, "isKeyword", {
    enumerable: true,
    get: function() {
      return _keyword.isKeyword;
    }
  });
  var _identifier = require_identifier();
  var _keyword = require_keyword();
});

// ../../node_modules/.pnpm/escape-string-regexp@1.0.5/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS2((exports2, module2) => {
  "use strict";
  var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
  module2.exports = function(str) {
    if (typeof str !== "string") {
      throw new TypeError("Expected a string");
    }
    return str.replace(matchOperatorsRe, "\\$&");
  };
});

// ../../node_modules/.pnpm/color-name@1.1.3/node_modules/color-name/index.js
var require_color_name3 = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
});

// ../../node_modules/.pnpm/color-convert@1.9.3/node_modules/color-convert/conversions.js
var require_conversions3 = __commonJS2((exports2, module2) => {
  var cssKeywords = require_color_name3();
  var reverseKeywords = {};
  for (var key in cssKeywords) {
    if (cssKeywords.hasOwnProperty(key)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
  }
  var convert = module2.exports = {
    rgb: {channels: 3, labels: "rgb"},
    hsl: {channels: 3, labels: "hsl"},
    hsv: {channels: 3, labels: "hsv"},
    hwb: {channels: 3, labels: "hwb"},
    cmyk: {channels: 4, labels: "cmyk"},
    xyz: {channels: 3, labels: "xyz"},
    lab: {channels: 3, labels: "lab"},
    lch: {channels: 3, labels: "lch"},
    hex: {channels: 1, labels: ["hex"]},
    keyword: {channels: 1, labels: ["keyword"]},
    ansi16: {channels: 1, labels: ["ansi16"]},
    ansi256: {channels: 1, labels: ["ansi256"]},
    hcg: {channels: 3, labels: ["h", "c", "g"]},
    apple: {channels: 3, labels: ["r16", "g16", "b16"]},
    gray: {channels: 1, labels: ["gray"]}
  };
  for (var model in convert) {
    if (convert.hasOwnProperty(model)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      channels = convert[model].channels;
      labels = convert[model].labels;
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", {value: channels});
      Object.defineProperty(convert[model], "labels", {value: labels});
    }
  }
  var channels;
  var labels;
  convert.rgb.hsl = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var min2 = Math.min(r, g, b);
    var max2 = Math.max(r, g, b);
    var delta = max2 - min2;
    var h2;
    var s2;
    var l;
    if (max2 === min2) {
      h2 = 0;
    } else if (r === max2) {
      h2 = (g - b) / delta;
    } else if (g === max2) {
      h2 = 2 + (b - r) / delta;
    } else if (b === max2) {
      h2 = 4 + (r - g) / delta;
    }
    h2 = Math.min(h2 * 60, 360);
    if (h2 < 0) {
      h2 += 360;
    }
    l = (min2 + max2) / 2;
    if (max2 === min2) {
      s2 = 0;
    } else if (l <= 0.5) {
      s2 = delta / (max2 + min2);
    } else {
      s2 = delta / (2 - max2 - min2);
    }
    return [h2, s2 * 100, l * 100];
  };
  convert.rgb.hsv = function(rgb) {
    var rdif;
    var gdif;
    var bdif;
    var h2;
    var s2;
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var v = Math.max(r, g, b);
    var diff = v - Math.min(r, g, b);
    var diffc = function(c) {
      return (v - c) / 6 / diff + 1 / 2;
    };
    if (diff === 0) {
      h2 = s2 = 0;
    } else {
      s2 = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);
      if (r === v) {
        h2 = bdif - gdif;
      } else if (g === v) {
        h2 = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h2 = 2 / 3 + gdif - rdif;
      }
      if (h2 < 0) {
        h2 += 1;
      } else if (h2 > 1) {
        h2 -= 1;
      }
    }
    return [
      h2 * 360,
      s2 * 100,
      v * 100
    ];
  };
  convert.rgb.hwb = function(rgb) {
    var r = rgb[0];
    var g = rgb[1];
    var b = rgb[2];
    var h2 = convert.rgb.hsl(rgb)[0];
    var w2 = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h2, w2 * 100, b * 100];
  };
  convert.rgb.cmyk = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var c;
    var m2;
    var y2;
    var k;
    k = Math.min(1 - r, 1 - g, 1 - b);
    c = (1 - r - k) / (1 - k) || 0;
    m2 = (1 - g - k) / (1 - k) || 0;
    y2 = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m2 * 100, y2 * 100, k * 100];
  };
  function comparativeDistance(x, y2) {
    return Math.pow(x[0] - y2[0], 2) + Math.pow(x[1] - y2[1], 2) + Math.pow(x[2] - y2[2], 2);
  }
  convert.rgb.keyword = function(rgb) {
    var reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    var currentClosestDistance = Infinity;
    var currentClosestKeyword;
    for (var keyword in cssKeywords) {
      if (cssKeywords.hasOwnProperty(keyword)) {
        var value = cssKeywords[keyword];
        var distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
    }
    return currentClosestKeyword;
  };
  convert.keyword.rgb = function(keyword) {
    return cssKeywords[keyword];
  };
  convert.rgb.xyz = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
    g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
    b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
    var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    var y2 = r * 0.2126 + g * 0.7152 + b * 0.0722;
    var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y2 * 100, z * 100];
  };
  convert.rgb.lab = function(rgb) {
    var xyz = convert.rgb.xyz(rgb);
    var x = xyz[0];
    var y2 = xyz[1];
    var z = xyz[2];
    var l;
    var a;
    var b;
    x /= 95.047;
    y2 /= 100;
    z /= 108.883;
    x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y2 = y2 > 8856e-6 ? Math.pow(y2, 1 / 3) : 7.787 * y2 + 16 / 116;
    z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
    l = 116 * y2 - 16;
    a = 500 * (x - y2);
    b = 200 * (y2 - z);
    return [l, a, b];
  };
  convert.hsl.rgb = function(hsl) {
    var h2 = hsl[0] / 360;
    var s2 = hsl[1] / 100;
    var l = hsl[2] / 100;
    var t1;
    var t2;
    var t3;
    var rgb;
    var val;
    if (s2 === 0) {
      val = l * 255;
      return [val, val, val];
    }
    if (l < 0.5) {
      t2 = l * (1 + s2);
    } else {
      t2 = l + s2 - l * s2;
    }
    t1 = 2 * l - t2;
    rgb = [0, 0, 0];
    for (var i = 0; i < 3; i++) {
      t3 = h2 + 1 / 3 * -(i - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }
      rgb[i] = val * 255;
    }
    return rgb;
  };
  convert.hsl.hsv = function(hsl) {
    var h2 = hsl[0];
    var s2 = hsl[1] / 100;
    var l = hsl[2] / 100;
    var smin = s2;
    var lmin = Math.max(l, 0.01);
    var sv;
    var v;
    l *= 2;
    s2 *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    v = (l + s2) / 2;
    sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s2 / (l + s2);
    return [h2, sv * 100, v * 100];
  };
  convert.hsv.rgb = function(hsv) {
    var h2 = hsv[0] / 60;
    var s2 = hsv[1] / 100;
    var v = hsv[2] / 100;
    var hi = Math.floor(h2) % 6;
    var f = h2 - Math.floor(h2);
    var p = 255 * v * (1 - s2);
    var q = 255 * v * (1 - s2 * f);
    var t = 255 * v * (1 - s2 * (1 - f));
    v *= 255;
    switch (hi) {
      case 0:
        return [v, t, p];
      case 1:
        return [q, v, p];
      case 2:
        return [p, v, t];
      case 3:
        return [p, q, v];
      case 4:
        return [t, p, v];
      case 5:
        return [v, p, q];
    }
  };
  convert.hsv.hsl = function(hsv) {
    var h2 = hsv[0];
    var s2 = hsv[1] / 100;
    var v = hsv[2] / 100;
    var vmin = Math.max(v, 0.01);
    var lmin;
    var sl;
    var l;
    l = (2 - s2) * v;
    lmin = (2 - s2) * vmin;
    sl = s2 * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h2, sl * 100, l * 100];
  };
  convert.hwb.rgb = function(hwb) {
    var h2 = hwb[0] / 360;
    var wh = hwb[1] / 100;
    var bl = hwb[2] / 100;
    var ratio = wh + bl;
    var i;
    var v;
    var f;
    var n;
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    i = Math.floor(6 * h2);
    v = 1 - bl;
    f = 6 * h2 - i;
    if ((i & 1) !== 0) {
      f = 1 - f;
    }
    n = wh + f * (v - wh);
    var r;
    var g;
    var b;
    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;
      case 1:
        r = n;
        g = v;
        b = wh;
        break;
      case 2:
        r = wh;
        g = v;
        b = n;
        break;
      case 3:
        r = wh;
        g = n;
        b = v;
        break;
      case 4:
        r = n;
        g = wh;
        b = v;
        break;
      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }
    return [r * 255, g * 255, b * 255];
  };
  convert.cmyk.rgb = function(cmyk) {
    var c = cmyk[0] / 100;
    var m2 = cmyk[1] / 100;
    var y2 = cmyk[2] / 100;
    var k = cmyk[3] / 100;
    var r;
    var g;
    var b;
    r = 1 - Math.min(1, c * (1 - k) + k);
    g = 1 - Math.min(1, m2 * (1 - k) + k);
    b = 1 - Math.min(1, y2 * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.rgb = function(xyz) {
    var x = xyz[0] / 100;
    var y2 = xyz[1] / 100;
    var z = xyz[2] / 100;
    var r;
    var g;
    var b;
    r = x * 3.2406 + y2 * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y2 * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y2 * -0.204 + z * 1.057;
    r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
    g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
    b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.lab = function(xyz) {
    var x = xyz[0];
    var y2 = xyz[1];
    var z = xyz[2];
    var l;
    var a;
    var b;
    x /= 95.047;
    y2 /= 100;
    z /= 108.883;
    x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y2 = y2 > 8856e-6 ? Math.pow(y2, 1 / 3) : 7.787 * y2 + 16 / 116;
    z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
    l = 116 * y2 - 16;
    a = 500 * (x - y2);
    b = 200 * (y2 - z);
    return [l, a, b];
  };
  convert.lab.xyz = function(lab) {
    var l = lab[0];
    var a = lab[1];
    var b = lab[2];
    var x;
    var y2;
    var z;
    y2 = (l + 16) / 116;
    x = a / 500 + y2;
    z = y2 - b / 200;
    var y22 = Math.pow(y2, 3);
    var x2 = Math.pow(x, 3);
    var z2 = Math.pow(z, 3);
    y2 = y22 > 8856e-6 ? y22 : (y2 - 16 / 116) / 7.787;
    x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y2 *= 100;
    z *= 108.883;
    return [x, y2, z];
  };
  convert.lab.lch = function(lab) {
    var l = lab[0];
    var a = lab[1];
    var b = lab[2];
    var hr;
    var h2;
    var c;
    hr = Math.atan2(b, a);
    h2 = hr * 360 / 2 / Math.PI;
    if (h2 < 0) {
      h2 += 360;
    }
    c = Math.sqrt(a * a + b * b);
    return [l, c, h2];
  };
  convert.lch.lab = function(lch) {
    var l = lch[0];
    var c = lch[1];
    var h2 = lch[2];
    var a;
    var b;
    var hr;
    hr = h2 / 360 * 2 * Math.PI;
    a = c * Math.cos(hr);
    b = c * Math.sin(hr);
    return [l, a, b];
  };
  convert.rgb.ansi16 = function(args) {
    var r = args[0];
    var g = args[1];
    var b = args[2];
    var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
    value = Math.round(value / 50);
    if (value === 0) {
      return 30;
    }
    var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value === 2) {
      ansi += 60;
    }
    return ansi;
  };
  convert.hsv.ansi16 = function(args) {
    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
  };
  convert.rgb.ansi256 = function(args) {
    var r = args[0];
    var g = args[1];
    var b = args[2];
    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }
      if (r > 248) {
        return 231;
      }
      return Math.round((r - 8) / 247 * 24) + 232;
    }
    var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };
  convert.ansi16.rgb = function(args) {
    var color = args % 10;
    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }
      color = color / 10.5 * 255;
      return [color, color, color];
    }
    var mult = (~~(args > 50) + 1) * 0.5;
    var r = (color & 1) * mult * 255;
    var g = (color >> 1 & 1) * mult * 255;
    var b = (color >> 2 & 1) * mult * 255;
    return [r, g, b];
  };
  convert.ansi256.rgb = function(args) {
    if (args >= 232) {
      var c = (args - 232) * 10 + 8;
      return [c, c, c];
    }
    args -= 16;
    var rem;
    var r = Math.floor(args / 36) / 5 * 255;
    var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    var b = rem % 6 / 5 * 255;
    return [r, g, b];
  };
  convert.rgb.hex = function(args) {
    var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
    var string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.hex.rgb = function(args) {
    var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match) {
      return [0, 0, 0];
    }
    var colorString = match[0];
    if (match[0].length === 3) {
      colorString = colorString.split("").map(function(char) {
        return char + char;
      }).join("");
    }
    var integer = parseInt(colorString, 16);
    var r = integer >> 16 & 255;
    var g = integer >> 8 & 255;
    var b = integer & 255;
    return [r, g, b];
  };
  convert.rgb.hcg = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var max2 = Math.max(Math.max(r, g), b);
    var min2 = Math.min(Math.min(r, g), b);
    var chroma = max2 - min2;
    var grayscale;
    var hue;
    if (chroma < 1) {
      grayscale = min2 / (1 - chroma);
    } else {
      grayscale = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max2 === r) {
      hue = (g - b) / chroma % 6;
    } else if (max2 === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma + 4;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert.hsl.hcg = function(hsl) {
    var s2 = hsl[1] / 100;
    var l = hsl[2] / 100;
    var c = 1;
    var f = 0;
    if (l < 0.5) {
      c = 2 * s2 * l;
    } else {
      c = 2 * s2 * (1 - l);
    }
    if (c < 1) {
      f = (l - 0.5 * c) / (1 - c);
    }
    return [hsl[0], c * 100, f * 100];
  };
  convert.hsv.hcg = function(hsv) {
    var s2 = hsv[1] / 100;
    var v = hsv[2] / 100;
    var c = s2 * v;
    var f = 0;
    if (c < 1) {
      f = (v - c) / (1 - c);
    }
    return [hsv[0], c * 100, f * 100];
  };
  convert.hcg.rgb = function(hcg) {
    var h2 = hcg[0] / 360;
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    if (c === 0) {
      return [g * 255, g * 255, g * 255];
    }
    var pure = [0, 0, 0];
    var hi = h2 % 1 * 6;
    var v = hi % 1;
    var w2 = 1 - v;
    var mg = 0;
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w2;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w2;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w2;
    }
    mg = (1 - c) * g;
    return [
      (c * pure[0] + mg) * 255,
      (c * pure[1] + mg) * 255,
      (c * pure[2] + mg) * 255
    ];
  };
  convert.hcg.hsv = function(hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var v = c + g * (1 - c);
    var f = 0;
    if (v > 0) {
      f = c / v;
    }
    return [hcg[0], f * 100, v * 100];
  };
  convert.hcg.hsl = function(hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var l = g * (1 - c) + 0.5 * c;
    var s2 = 0;
    if (l > 0 && l < 0.5) {
      s2 = c / (2 * l);
    } else if (l >= 0.5 && l < 1) {
      s2 = c / (2 * (1 - l));
    }
    return [hcg[0], s2 * 100, l * 100];
  };
  convert.hcg.hwb = function(hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var v = c + g * (1 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };
  convert.hwb.hcg = function(hwb) {
    var w2 = hwb[1] / 100;
    var b = hwb[2] / 100;
    var v = 1 - b;
    var c = v - w2;
    var g = 0;
    if (c < 1) {
      g = (v - c) / (1 - c);
    }
    return [hwb[0], c * 100, g * 100];
  };
  convert.apple.rgb = function(apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert.rgb.apple = function(rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert.gray.rgb = function(args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };
  convert.gray.hsl = convert.gray.hsv = function(args) {
    return [0, 0, args[0]];
  };
  convert.gray.hwb = function(gray) {
    return [0, 100, gray[0]];
  };
  convert.gray.cmyk = function(gray) {
    return [0, 0, 0, gray[0]];
  };
  convert.gray.lab = function(gray) {
    return [gray[0], 0, 0];
  };
  convert.gray.hex = function(gray) {
    var val = Math.round(gray[0] / 100 * 255) & 255;
    var integer = (val << 16) + (val << 8) + val;
    var string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.rgb.gray = function(rgb) {
    var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
});

// ../../node_modules/.pnpm/color-convert@1.9.3/node_modules/color-convert/route.js
var require_route3 = __commonJS2((exports2, module2) => {
  var conversions = require_conversions3();
  function buildGraph() {
    var graph = {};
    var models = Object.keys(conversions);
    for (var len = models.length, i = 0; i < len; i++) {
      graph[models[i]] = {
        distance: -1,
        parent: null
      };
    }
    return graph;
  }
  function deriveBFS(fromModel) {
    var graph = buildGraph();
    var queue = [fromModel];
    graph[fromModel].distance = 0;
    while (queue.length) {
      var current = queue.pop();
      var adjacents = Object.keys(conversions[current]);
      for (var len = adjacents.length, i = 0; i < len; i++) {
        var adjacent = adjacents[i];
        var node = graph[adjacent];
        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  }
  function link2(from, to) {
    return function(args) {
      return to(from(args));
    };
  }
  function wrapConversion(toModel, graph) {
    var path4 = [graph[toModel].parent, toModel];
    var fn = conversions[graph[toModel].parent][toModel];
    var cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path4.unshift(graph[cur].parent);
      fn = link2(conversions[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path4;
    return fn;
  }
  module2.exports = function(fromModel) {
    var graph = deriveBFS(fromModel);
    var conversion = {};
    var models = Object.keys(graph);
    for (var len = models.length, i = 0; i < len; i++) {
      var toModel = models[i];
      var node = graph[toModel];
      if (node.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  };
});

// ../../node_modules/.pnpm/color-convert@1.9.3/node_modules/color-convert/index.js
var require_color_convert3 = __commonJS2((exports2, module2) => {
  var conversions = require_conversions3();
  var route = require_route3();
  var convert = {};
  var models = Object.keys(conversions);
  function wrapRaw(fn) {
    var wrappedFn = function(args) {
      if (args === void 0 || args === null) {
        return args;
      }
      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }
      return fn(args);
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  function wrapRounded(fn) {
    var wrappedFn = function(args) {
      if (args === void 0 || args === null) {
        return args;
      }
      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }
      var result = fn(args);
      if (typeof result === "object") {
        for (var len = result.length, i = 0; i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }
      return result;
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  models.forEach(function(fromModel) {
    convert[fromModel] = {};
    Object.defineProperty(convert[fromModel], "channels", {value: conversions[fromModel].channels});
    Object.defineProperty(convert[fromModel], "labels", {value: conversions[fromModel].labels});
    var routes = route(fromModel);
    var routeModels = Object.keys(routes);
    routeModels.forEach(function(toModel) {
      var fn = routes[toModel];
      convert[fromModel][toModel] = wrapRounded(fn);
      convert[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  module2.exports = convert;
});

// ../../node_modules/.pnpm/ansi-styles@3.2.1/node_modules/ansi-styles/index.js
var require_ansi_styles3 = __commonJS2((exports2, module2) => {
  "use strict";
  var colorConvert = require_color_convert3();
  var wrapAnsi16 = (fn, offset) => function() {
    const code = fn.apply(colorConvert, arguments);
    return `[${code + offset}m`;
  };
  var wrapAnsi256 = (fn, offset) => function() {
    const code = fn.apply(colorConvert, arguments);
    return `[${38 + offset};5;${code}m`;
  };
  var wrapAnsi16m = (fn, offset) => function() {
    const rgb = fn.apply(colorConvert, arguments);
    return `[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
  };
  function assembleStyles() {
    const codes = new Map();
    const styles = {
      modifier: {
        reset: [0, 0],
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        gray: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    styles.color.grey = styles.color.gray;
    for (const groupName of Object.keys(styles)) {
      const group = styles[groupName];
      for (const styleName of Object.keys(group)) {
        const style = group[styleName];
        styles[styleName] = {
          open: `[${style[0]}m`,
          close: `[${style[1]}m`
        };
        group[styleName] = styles[styleName];
        codes.set(style[0], style[1]);
      }
      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false
      });
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
    }
    const ansi2ansi = (n) => n;
    const rgb2rgb = (r, g, b) => [r, g, b];
    styles.color.close = "[39m";
    styles.bgColor.close = "[49m";
    styles.color.ansi = {
      ansi: wrapAnsi16(ansi2ansi, 0)
    };
    styles.color.ansi256 = {
      ansi256: wrapAnsi256(ansi2ansi, 0)
    };
    styles.color.ansi16m = {
      rgb: wrapAnsi16m(rgb2rgb, 0)
    };
    styles.bgColor.ansi = {
      ansi: wrapAnsi16(ansi2ansi, 10)
    };
    styles.bgColor.ansi256 = {
      ansi256: wrapAnsi256(ansi2ansi, 10)
    };
    styles.bgColor.ansi16m = {
      rgb: wrapAnsi16m(rgb2rgb, 10)
    };
    for (let key of Object.keys(colorConvert)) {
      if (typeof colorConvert[key] !== "object") {
        continue;
      }
      const suite = colorConvert[key];
      if (key === "ansi16") {
        key = "ansi";
      }
      if ("ansi16" in suite) {
        styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
        styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
      }
      if ("ansi256" in suite) {
        styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
        styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
      }
      if ("rgb" in suite) {
        styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
        styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
      }
    }
    return styles;
  }
  Object.defineProperty(module2, "exports", {
    enumerable: true,
    get: assembleStyles
  });
});

// ../../node_modules/.pnpm/has-flag@3.0.0/node_modules/has-flag/index.js
var require_has_flag3 = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = (flag, argv) => {
    argv = argv || process.argv;
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const pos = argv.indexOf(prefix + flag);
    const terminatorPos = argv.indexOf("--");
    return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
  };
});

// ../../node_modules/.pnpm/supports-color@5.5.0/node_modules/supports-color/index.js
var require_supports_color3 = __commonJS2((exports2, module2) => {
  "use strict";
  var os2 = require("os");
  var hasFlag = require_has_flag3();
  var env2 = process.env;
  var forceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
    forceColor = false;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = true;
  }
  if ("FORCE_COLOR" in env2) {
    forceColor = env2.FORCE_COLOR.length === 0 || parseInt(env2.FORCE_COLOR, 10) !== 0;
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(stream) {
    if (forceColor === false) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (stream && !stream.isTTY && forceColor !== true) {
      return 0;
    }
    const min2 = forceColor ? 1 : 0;
    if (process.platform === "win32") {
      const osRelease = os2.release().split(".");
      if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env2) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign2) => sign2 in env2) || env2.CI_NAME === "codeship") {
        return 1;
      }
      return min2;
    }
    if ("TEAMCITY_VERSION" in env2) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env2.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env2) {
      const version = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env2.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env2.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env2) {
      return 1;
    }
    if (env2.TERM === "dumb") {
      return min2;
    }
    return min2;
  }
  function getSupportLevel(stream) {
    const level = supportsColor(stream);
    return translateLevel(level);
  }
  module2.exports = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel(process.stdout),
    stderr: getSupportLevel(process.stderr)
  };
});

// ../../node_modules/.pnpm/chalk@2.4.2/node_modules/chalk/templates.js
var require_templates3 = __commonJS2((exports2, module2) => {
  "use strict";
  var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
  var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
  var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
  var ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
  var ESCAPES = new Map([
    ["n", "\n"],
    ["r", "\r"],
    ["t", "	"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", ""],
    ["a", "\x07"]
  ]);
  function unescape(c) {
    if (c[0] === "u" && c.length === 5 || c[0] === "x" && c.length === 3) {
      return String.fromCharCode(parseInt(c.slice(1), 16));
    }
    return ESCAPES.get(c) || c;
  }
  function parseArguments(name, args) {
    const results = [];
    const chunks = args.trim().split(/\s*,\s*/g);
    let matches;
    for (const chunk of chunks) {
      if (!isNaN(chunk)) {
        results.push(Number(chunk));
      } else if (matches = chunk.match(STRING_REGEX)) {
        results.push(matches[2].replace(ESCAPE_REGEX, (m2, escape, chr) => escape ? unescape(escape) : chr));
      } else {
        throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
      }
    }
    return results;
  }
  function parseStyle(style) {
    STYLE_REGEX.lastIndex = 0;
    const results = [];
    let matches;
    while ((matches = STYLE_REGEX.exec(style)) !== null) {
      const name = matches[1];
      if (matches[2]) {
        const args = parseArguments(name, matches[2]);
        results.push([name].concat(args));
      } else {
        results.push([name]);
      }
    }
    return results;
  }
  function buildStyle(chalk3, styles) {
    const enabled = {};
    for (const layer of styles) {
      for (const style of layer.styles) {
        enabled[style[0]] = layer.inverse ? null : style.slice(1);
      }
    }
    let current = chalk3;
    for (const styleName of Object.keys(enabled)) {
      if (Array.isArray(enabled[styleName])) {
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        if (enabled[styleName].length > 0) {
          current = current[styleName].apply(current, enabled[styleName]);
        } else {
          current = current[styleName];
        }
      }
    }
    return current;
  }
  module2.exports = (chalk3, tmp) => {
    const styles = [];
    const chunks = [];
    let chunk = [];
    tmp.replace(TEMPLATE_REGEX, (m2, escapeChar, inverse, style, close2, chr) => {
      if (escapeChar) {
        chunk.push(unescape(escapeChar));
      } else if (style) {
        const str = chunk.join("");
        chunk = [];
        chunks.push(styles.length === 0 ? str : buildStyle(chalk3, styles)(str));
        styles.push({inverse, styles: parseStyle(style)});
      } else if (close2) {
        if (styles.length === 0) {
          throw new Error("Found extraneous } in Chalk template literal");
        }
        chunks.push(buildStyle(chalk3, styles)(chunk.join("")));
        chunk = [];
        styles.pop();
      } else {
        chunk.push(chr);
      }
    });
    chunks.push(chunk.join(""));
    if (styles.length > 0) {
      const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(errMsg);
    }
    return chunks.join("");
  };
});

// ../../node_modules/.pnpm/chalk@2.4.2/node_modules/chalk/index.js
var require_chalk = __commonJS2((exports2, module2) => {
  "use strict";
  var escapeStringRegexp = require_escape_string_regexp();
  var ansiStyles = require_ansi_styles3();
  var stdoutColor = require_supports_color3().stdout;
  var template = require_templates3();
  var isSimpleWindowsTerm = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm");
  var levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];
  var skipModels = new Set(["gray"]);
  var styles = Object.create(null);
  function applyOptions(obj, options) {
    options = options || {};
    const scLevel = stdoutColor ? stdoutColor.level : 0;
    obj.level = options.level === void 0 ? scLevel : options.level;
    obj.enabled = "enabled" in options ? options.enabled : obj.level > 0;
  }
  function Chalk(options) {
    if (!this || !(this instanceof Chalk) || this.template) {
      const chalk3 = {};
      applyOptions(chalk3, options);
      chalk3.template = function() {
        const args = [].slice.call(arguments);
        return chalkTag.apply(null, [chalk3.template].concat(args));
      };
      Object.setPrototypeOf(chalk3, Chalk.prototype);
      Object.setPrototypeOf(chalk3.template, chalk3);
      chalk3.template.constructor = Chalk;
      return chalk3.template;
    }
    applyOptions(this, options);
  }
  if (isSimpleWindowsTerm) {
    ansiStyles.blue.open = "[94m";
  }
  for (const key of Object.keys(ansiStyles)) {
    ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
    styles[key] = {
      get() {
        const codes = ansiStyles[key];
        return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
      }
    };
  }
  styles.visible = {
    get() {
      return build.call(this, this._styles || [], true, "visible");
    }
  };
  ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), "g");
  for (const model of Object.keys(ansiStyles.color.ansi)) {
    if (skipModels.has(model)) {
      continue;
    }
    styles[model] = {
      get() {
        const level = this.level;
        return function() {
          const open2 = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
          const codes = {
            open: open2,
            close: ansiStyles.color.close,
            closeRe: ansiStyles.color.closeRe
          };
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
        };
      }
    };
  }
  ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), "g");
  for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
    if (skipModels.has(model)) {
      continue;
    }
    const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
    styles[bgModel] = {
      get() {
        const level = this.level;
        return function() {
          const open2 = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
          const codes = {
            open: open2,
            close: ansiStyles.bgColor.close,
            closeRe: ansiStyles.bgColor.closeRe
          };
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
        };
      }
    };
  }
  var proto = Object.defineProperties(() => {
  }, styles);
  function build(_styles, _empty, key) {
    const builder = function() {
      return applyStyle.apply(builder, arguments);
    };
    builder._styles = _styles;
    builder._empty = _empty;
    const self2 = this;
    Object.defineProperty(builder, "level", {
      enumerable: true,
      get() {
        return self2.level;
      },
      set(level) {
        self2.level = level;
      }
    });
    Object.defineProperty(builder, "enabled", {
      enumerable: true,
      get() {
        return self2.enabled;
      },
      set(enabled) {
        self2.enabled = enabled;
      }
    });
    builder.hasGrey = this.hasGrey || key === "gray" || key === "grey";
    builder.__proto__ = proto;
    return builder;
  }
  function applyStyle() {
    const args = arguments;
    const argsLen = args.length;
    let str = String(arguments[0]);
    if (argsLen === 0) {
      return "";
    }
    if (argsLen > 1) {
      for (let a = 1; a < argsLen; a++) {
        str += " " + args[a];
      }
    }
    if (!this.enabled || this.level <= 0 || !str) {
      return this._empty ? "" : str;
    }
    const originalDim = ansiStyles.dim.open;
    if (isSimpleWindowsTerm && this.hasGrey) {
      ansiStyles.dim.open = "";
    }
    for (const code of this._styles.slice().reverse()) {
      str = code.open + str.replace(code.closeRe, code.open) + code.close;
      str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
    }
    ansiStyles.dim.open = originalDim;
    return str;
  }
  function chalkTag(chalk3, strings) {
    if (!Array.isArray(strings)) {
      return [].slice.call(arguments, 1).join(" ");
    }
    const args = [].slice.call(arguments, 2);
    const parts = [strings.raw[0]];
    for (let i = 1; i < strings.length; i++) {
      parts.push(String(args[i - 1]).replace(/[{}\\]/g, "\\$&"));
      parts.push(String(strings.raw[i]));
    }
    return template(chalk3, parts.join(""));
  }
  Object.defineProperties(Chalk.prototype, styles);
  module2.exports = Chalk();
  module2.exports.supportsColor = stdoutColor;
  module2.exports.default = module2.exports;
});

// ../../node_modules/.pnpm/@babel+highlight@7.14.5/node_modules/@babel/highlight/lib/index.js
var require_lib3 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.shouldHighlight = shouldHighlight;
  exports2.getChalk = getChalk;
  exports2.default = highlight;
  var _jsTokens = require_js_tokens();
  var _helperValidatorIdentifier = require_lib2();
  var _chalk = require_chalk();
  var sometimesKeywords = new Set(["as", "async", "from", "get", "of", "set"]);
  function getDefs(chalk3) {
    return {
      keyword: chalk3.cyan,
      capitalized: chalk3.yellow,
      jsxIdentifier: chalk3.yellow,
      punctuator: chalk3.yellow,
      number: chalk3.magenta,
      string: chalk3.green,
      regex: chalk3.magenta,
      comment: chalk3.grey,
      invalid: chalk3.white.bgRed.bold
    };
  }
  var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
  var BRACKET = /^[()[\]{}]$/;
  var tokenize;
  {
    const JSX_TAG = /^[a-z][\w-]*$/i;
    const getTokenType = function(token, offset, text) {
      if (token.type === "name") {
        if ((0, _helperValidatorIdentifier.isKeyword)(token.value) || (0, _helperValidatorIdentifier.isStrictReservedWord)(token.value, true) || sometimesKeywords.has(token.value)) {
          return "keyword";
        }
        if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.substr(offset - 2, 2) == "</")) {
          return "jsxIdentifier";
        }
        if (token.value[0] !== token.value[0].toLowerCase()) {
          return "capitalized";
        }
      }
      if (token.type === "punctuator" && BRACKET.test(token.value)) {
        return "bracket";
      }
      if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
        return "punctuator";
      }
      return token.type;
    };
    tokenize = function* (text) {
      let match;
      while (match = _jsTokens.default.exec(text)) {
        const token = _jsTokens.matchToToken(match);
        yield {
          type: getTokenType(token, match.index, text),
          value: token.value
        };
      }
    };
  }
  function highlightTokens(defs, text) {
    let highlighted = "";
    for (const {
      type,
      value
    } of tokenize(text)) {
      const colorize = defs[type];
      if (colorize) {
        highlighted += value.split(NEWLINE).map((str) => colorize(str)).join("\n");
      } else {
        highlighted += value;
      }
    }
    return highlighted;
  }
  function shouldHighlight(options) {
    return !!_chalk.supportsColor || options.forceColor;
  }
  function getChalk(options) {
    return options.forceColor ? new _chalk.constructor({
      enabled: true,
      level: 1
    }) : _chalk;
  }
  function highlight(code, options = {}) {
    if (shouldHighlight(options)) {
      const chalk3 = getChalk(options);
      const defs = getDefs(chalk3);
      return highlightTokens(defs, code);
    } else {
      return code;
    }
  }
});

// ../../node_modules/.pnpm/@babel+code-frame@7.14.5/node_modules/@babel/code-frame/lib/index.js
var require_lib4 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.codeFrameColumns = codeFrameColumns;
  exports2.default = _default2;
  var _highlight = require_lib3();
  var deprecationWarningShown = false;
  function getDefs(chalk3) {
    return {
      gutter: chalk3.grey,
      marker: chalk3.red.bold,
      message: chalk3.red.bold
    };
  }
  var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
  function getMarkerLines(loc, source, opts) {
    const startLoc = Object.assign({
      column: 0,
      line: -1
    }, loc.start);
    const endLoc = Object.assign({}, startLoc, loc.end);
    const {
      linesAbove = 2,
      linesBelow = 3
    } = opts || {};
    const startLine = startLoc.line;
    const startColumn = startLoc.column;
    const endLine = endLoc.line;
    const endColumn = endLoc.column;
    let start = Math.max(startLine - (linesAbove + 1), 0);
    let end = Math.min(source.length, endLine + linesBelow);
    if (startLine === -1) {
      start = 0;
    }
    if (endLine === -1) {
      end = source.length;
    }
    const lineDiff = endLine - startLine;
    const markerLines = {};
    if (lineDiff) {
      for (let i = 0; i <= lineDiff; i++) {
        const lineNumber = i + startLine;
        if (!startColumn) {
          markerLines[lineNumber] = true;
        } else if (i === 0) {
          const sourceLength = source[lineNumber - 1].length;
          markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
        } else if (i === lineDiff) {
          markerLines[lineNumber] = [0, endColumn];
        } else {
          const sourceLength = source[lineNumber - i].length;
          markerLines[lineNumber] = [0, sourceLength];
        }
      }
    } else {
      if (startColumn === endColumn) {
        if (startColumn) {
          markerLines[startLine] = [startColumn, 0];
        } else {
          markerLines[startLine] = true;
        }
      } else {
        markerLines[startLine] = [startColumn, endColumn - startColumn];
      }
    }
    return {
      start,
      end,
      markerLines
    };
  }
  function codeFrameColumns(rawLines, loc, opts = {}) {
    const highlighted = (opts.highlightCode || opts.forceColor) && (0, _highlight.shouldHighlight)(opts);
    const chalk3 = (0, _highlight.getChalk)(opts);
    const defs = getDefs(chalk3);
    const maybeHighlight = (chalkFn, string) => {
      return highlighted ? chalkFn(string) : string;
    };
    const lines = rawLines.split(NEWLINE);
    const {
      start,
      end,
      markerLines
    } = getMarkerLines(loc, lines, opts);
    const hasColumns = loc.start && typeof loc.start.column === "number";
    const numberMaxWidth = String(end).length;
    const highlightedLines = highlighted ? (0, _highlight.default)(rawLines, opts) : rawLines;
    let frame = highlightedLines.split(NEWLINE).slice(start, end).map((line, index) => {
      const number = start + 1 + index;
      const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
      const gutter = ` ${paddedNumber} |`;
      const hasMarker = markerLines[number];
      const lastMarkerLine = !markerLines[number + 1];
      if (hasMarker) {
        let markerLine = "";
        if (Array.isArray(hasMarker)) {
          const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
          const numberOfMarkers = hasMarker[1] || 1;
          markerLine = ["\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), " ", markerSpacing, maybeHighlight(defs.marker, "^").repeat(numberOfMarkers)].join("");
          if (lastMarkerLine && opts.message) {
            markerLine += " " + maybeHighlight(defs.message, opts.message);
          }
        }
        return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line.length > 0 ? ` ${line}` : "", markerLine].join("");
      } else {
        return ` ${maybeHighlight(defs.gutter, gutter)}${line.length > 0 ? ` ${line}` : ""}`;
      }
    }).join("\n");
    if (opts.message && !hasColumns) {
      frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}
${frame}`;
    }
    if (highlighted) {
      return chalk3.reset(frame);
    } else {
      return frame;
    }
  }
  function _default2(rawLines, lineNumber, colNumber, opts = {}) {
    if (!deprecationWarningShown) {
      deprecationWarningShown = true;
      const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      if (process.emitWarning) {
        process.emitWarning(message, "DeprecationWarning");
      } else {
        const deprecationError = new Error(message);
        deprecationError.name = "DeprecationWarning";
        console.warn(new Error(message));
      }
    }
    colNumber = Math.max(colNumber, 0);
    const location = {
      start: {
        column: colNumber,
        line: lineNumber
      }
    };
    return codeFrameColumns(rawLines, location, opts);
  }
});

// ../../node_modules/.pnpm/parse-json@5.2.0/node_modules/parse-json/index.js
var require_parse_json = __commonJS2((exports2, module2) => {
  "use strict";
  var errorEx = require_error_ex();
  var fallback = require_json_parse_even_better_errors();
  var {default: LinesAndColumns} = require_dist9();
  var {codeFrameColumns} = require_lib4();
  var JSONError = errorEx("JSONError", {
    fileName: errorEx.append("in %s"),
    codeFrame: errorEx.append("\n\n%s\n")
  });
  var parseJson = (string, reviver, filename) => {
    if (typeof reviver === "string") {
      filename = reviver;
      reviver = null;
    }
    try {
      try {
        return JSON.parse(string, reviver);
      } catch (error) {
        fallback(string, reviver);
        throw error;
      }
    } catch (error) {
      error.message = error.message.replace(/\n/g, "");
      const indexMatch = error.message.match(/in JSON at position (\d+) while parsing/);
      const jsonError = new JSONError(error);
      if (filename) {
        jsonError.fileName = filename;
      }
      if (indexMatch && indexMatch.length > 0) {
        const lines = new LinesAndColumns(string);
        const index = Number(indexMatch[1]);
        const location = lines.locationForIndex(index);
        const codeFrame = codeFrameColumns(string, {start: {line: location.line + 1, column: location.column + 1}}, {highlightCode: true});
        jsonError.codeFrame = codeFrame;
      }
      throw jsonError;
    }
  };
  parseJson.JSONError = JSONError;
  module2.exports = parseJson;
});

// ../../node_modules/.pnpm/semver@5.7.1/node_modules/semver/semver.js
var require_semver3 = __commonJS2((exports2, module2) => {
  exports2 = module2.exports = SemVer;
  var debug4;
  if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
    debug4 = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift("SEMVER");
      console.log.apply(console, args);
    };
  } else {
    debug4 = function() {
    };
  }
  exports2.SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER2 = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var re = exports2.re = [];
  var src = exports2.src = [];
  var R = 0;
  var NUMERICIDENTIFIER = R++;
  src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
  var NUMERICIDENTIFIERLOOSE = R++;
  src[NUMERICIDENTIFIERLOOSE] = "[0-9]+";
  var NONNUMERICIDENTIFIER = R++;
  src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
  var MAINVERSION = R++;
  src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
  var MAINVERSIONLOOSE = R++;
  src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
  var PRERELEASEIDENTIFIER = R++;
  src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
  var PRERELEASEIDENTIFIERLOOSE = R++;
  src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
  var PRERELEASE = R++;
  src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
  var PRERELEASELOOSE = R++;
  src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
  var BUILDIDENTIFIER = R++;
  src[BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
  var BUILD = R++;
  src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
  var FULL = R++;
  var FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
  src[FULL] = "^" + FULLPLAIN + "$";
  var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?";
  var LOOSE = R++;
  src[LOOSE] = "^" + LOOSEPLAIN + "$";
  var GTLT = R++;
  src[GTLT] = "((?:<|>)?=?)";
  var XRANGEIDENTIFIERLOOSE = R++;
  src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
  var XRANGEIDENTIFIER = R++;
  src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
  var XRANGEPLAIN = R++;
  src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
  var XRANGEPLAINLOOSE = R++;
  src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
  var XRANGE = R++;
  src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
  var XRANGELOOSE = R++;
  src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
  var COERCE = R++;
  src[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
  var LONETILDE = R++;
  src[LONETILDE] = "(?:~>?)";
  var TILDETRIM = R++;
  src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
  re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
  var tildeTrimReplace = "$1~";
  var TILDE = R++;
  src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
  var TILDELOOSE = R++;
  src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
  var LONECARET = R++;
  src[LONECARET] = "(?:\\^)";
  var CARETTRIM = R++;
  src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
  re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
  var caretTrimReplace = "$1^";
  var CARET = R++;
  src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
  var CARETLOOSE = R++;
  src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
  var COMPARATORLOOSE = R++;
  src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
  var COMPARATOR = R++;
  src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
  var COMPARATORTRIM = R++;
  src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")";
  re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
  var comparatorTrimReplace = "$1$2$3";
  var HYPHENRANGE = R++;
  src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
  var HYPHENRANGELOOSE = R++;
  src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
  var STAR = R++;
  src[STAR] = "(<|>)?=?\\s*\\*";
  for (var i = 0; i < R; i++) {
    debug4(i, src[i]);
    if (!re[i]) {
      re[i] = new RegExp(src[i]);
    }
  }
  exports2.parse = parse2;
  function parse2(version, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version !== "string") {
      return null;
    }
    if (version.length > MAX_LENGTH) {
      return null;
    }
    var r = options.loose ? re[LOOSE] : re[FULL];
    if (!r.test(version)) {
      return null;
    }
    try {
      return new SemVer(version, options);
    } catch (er) {
      return null;
    }
  }
  exports2.valid = valid;
  function valid(version, options) {
    var v = parse2(version, options);
    return v ? v.version : null;
  }
  exports2.clean = clean;
  function clean(version, options) {
    var s2 = parse2(version.trim().replace(/^[=v]+/, ""), options);
    return s2 ? s2.version : null;
  }
  exports2.SemVer = SemVer;
  function SemVer(version, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      if (version.loose === options.loose) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== "string") {
      throw new TypeError("Invalid Version: " + version);
    }
    if (version.length > MAX_LENGTH) {
      throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
    }
    if (!(this instanceof SemVer)) {
      return new SemVer(version, options);
    }
    debug4("SemVer", version, options);
    this.options = options;
    this.loose = !!options.loose;
    var m2 = version.trim().match(options.loose ? re[LOOSE] : re[FULL]);
    if (!m2) {
      throw new TypeError("Invalid Version: " + version);
    }
    this.raw = version;
    this.major = +m2[1];
    this.minor = +m2[2];
    this.patch = +m2[3];
    if (this.major > MAX_SAFE_INTEGER2 || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER2 || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER2 || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m2[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m2[4].split(".").map(function(id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER2) {
            return num;
          }
        }
        return id;
      });
    }
    this.build = m2[5] ? m2[5].split(".") : [];
    this.format();
  }
  SemVer.prototype.format = function() {
    this.version = this.major + "." + this.minor + "." + this.patch;
    if (this.prerelease.length) {
      this.version += "-" + this.prerelease.join(".");
    }
    return this.version;
  };
  SemVer.prototype.toString = function() {
    return this.version;
  };
  SemVer.prototype.compare = function(other) {
    debug4("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return this.compareMain(other) || this.comparePre(other);
  };
  SemVer.prototype.compareMain = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  };
  SemVer.prototype.comparePre = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    var i2 = 0;
    do {
      var a = this.prerelease[i2];
      var b = other.prerelease[i2];
      debug4("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  };
  SemVer.prototype.inc = function(release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier);
        this.inc("pre", identifier);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier);
        }
        this.inc("pre", identifier);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          var i2 = this.prerelease.length;
          while (--i2 >= 0) {
            if (typeof this.prerelease[i2] === "number") {
              this.prerelease[i2]++;
              i2 = -2;
            }
          }
          if (i2 === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error("invalid increment argument: " + release);
    }
    this.format();
    this.raw = this.version;
    return this;
  };
  exports2.inc = inc;
  function inc(version, release, loose, identifier) {
    if (typeof loose === "string") {
      identifier = loose;
      loose = void 0;
    }
    try {
      return new SemVer(version, loose).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  }
  exports2.diff = diff;
  function diff(version1, version2) {
    if (eq(version1, version2)) {
      return null;
    } else {
      var v1 = parse2(version1);
      var v2 = parse2(version2);
      var prefix = "";
      if (v1.prerelease.length || v2.prerelease.length) {
        prefix = "pre";
        var defaultResult = "prerelease";
      }
      for (var key in v1) {
        if (key === "major" || key === "minor" || key === "patch") {
          if (v1[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }
      return defaultResult;
    }
  }
  exports2.compareIdentifiers = compareIdentifiers;
  var numeric = /^[0-9]+$/;
  function compareIdentifiers(a, b) {
    var anum = numeric.test(a);
    var bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  }
  exports2.rcompareIdentifiers = rcompareIdentifiers;
  function rcompareIdentifiers(a, b) {
    return compareIdentifiers(b, a);
  }
  exports2.major = major;
  function major(a, loose) {
    return new SemVer(a, loose).major;
  }
  exports2.minor = minor;
  function minor(a, loose) {
    return new SemVer(a, loose).minor;
  }
  exports2.patch = patch;
  function patch(a, loose) {
    return new SemVer(a, loose).patch;
  }
  exports2.compare = compare;
  function compare(a, b, loose) {
    return new SemVer(a, loose).compare(new SemVer(b, loose));
  }
  exports2.compareLoose = compareLoose;
  function compareLoose(a, b) {
    return compare(a, b, true);
  }
  exports2.rcompare = rcompare;
  function rcompare(a, b, loose) {
    return compare(b, a, loose);
  }
  exports2.sort = sort;
  function sort(list, loose) {
    return list.sort(function(a, b) {
      return exports2.compare(a, b, loose);
    });
  }
  exports2.rsort = rsort;
  function rsort(list, loose) {
    return list.sort(function(a, b) {
      return exports2.rcompare(a, b, loose);
    });
  }
  exports2.gt = gt;
  function gt(a, b, loose) {
    return compare(a, b, loose) > 0;
  }
  exports2.lt = lt;
  function lt(a, b, loose) {
    return compare(a, b, loose) < 0;
  }
  exports2.eq = eq;
  function eq(a, b, loose) {
    return compare(a, b, loose) === 0;
  }
  exports2.neq = neq;
  function neq(a, b, loose) {
    return compare(a, b, loose) !== 0;
  }
  exports2.gte = gte;
  function gte(a, b, loose) {
    return compare(a, b, loose) >= 0;
  }
  exports2.lte = lte;
  function lte(a, b, loose) {
    return compare(a, b, loose) <= 0;
  }
  exports2.cmp = cmp;
  function cmp(a, op, b, loose) {
    switch (op) {
      case "===":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a === b;
      case "!==":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError("Invalid operator: " + op);
    }
  }
  exports2.Comparator = Comparator;
  function Comparator(comp, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }
    if (!(this instanceof Comparator)) {
      return new Comparator(comp, options);
    }
    debug4("comparator", comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);
    if (this.semver === ANY) {
      this.value = "";
    } else {
      this.value = this.operator + this.semver.version;
    }
    debug4("comp", this);
  }
  var ANY = {};
  Comparator.prototype.parse = function(comp) {
    var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
    var m2 = comp.match(r);
    if (!m2) {
      throw new TypeError("Invalid comparator: " + comp);
    }
    this.operator = m2[1];
    if (this.operator === "=") {
      this.operator = "";
    }
    if (!m2[2]) {
      this.semver = ANY;
    } else {
      this.semver = new SemVer(m2[2], this.options.loose);
    }
  };
  Comparator.prototype.toString = function() {
    return this.value;
  };
  Comparator.prototype.test = function(version) {
    debug4("Comparator.test", version, this.options.loose);
    if (this.semver === ANY) {
      return true;
    }
    if (typeof version === "string") {
      version = new SemVer(version, this.options);
    }
    return cmp(version, this.operator, this.semver, this.options);
  };
  Comparator.prototype.intersects = function(comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError("a Comparator is required");
    }
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    var rangeTmp;
    if (this.operator === "") {
      rangeTmp = new Range(comp.value, options);
      return satisfies(this.value, rangeTmp, options);
    } else if (comp.operator === "") {
      rangeTmp = new Range(this.value, options);
      return satisfies(comp.semver, rangeTmp, options);
    }
    var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
    var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
    var sameSemVer = this.semver.version === comp.semver.version;
    var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
    var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
    var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  };
  exports2.Range = Range;
  function Range(range, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (range instanceof Range) {
      if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
        return range;
      } else {
        return new Range(range.raw, options);
      }
    }
    if (range instanceof Comparator) {
      return new Range(range.value, options);
    }
    if (!(this instanceof Range)) {
      return new Range(range, options);
    }
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    this.raw = range;
    this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
      return this.parseRange(range2.trim());
    }, this).filter(function(c) {
      return c.length;
    });
    if (!this.set.length) {
      throw new TypeError("Invalid SemVer Range: " + range);
    }
    this.format();
  }
  Range.prototype.format = function() {
    this.range = this.set.map(function(comps) {
      return comps.join(" ").trim();
    }).join("||").trim();
    return this.range;
  };
  Range.prototype.toString = function() {
    return this.range;
  };
  Range.prototype.parseRange = function(range) {
    var loose = this.options.loose;
    range = range.trim();
    var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
    range = range.replace(hr, hyphenReplace);
    debug4("hyphen replace", range);
    range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
    debug4("comparator trim", range, re[COMPARATORTRIM]);
    range = range.replace(re[TILDETRIM], tildeTrimReplace);
    range = range.replace(re[CARETTRIM], caretTrimReplace);
    range = range.split(/\s+/).join(" ");
    var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
    var set = range.split(" ").map(function(comp) {
      return parseComparator(comp, this.options);
    }, this).join(" ").split(/\s+/);
    if (this.options.loose) {
      set = set.filter(function(comp) {
        return !!comp.match(compRe);
      });
    }
    set = set.map(function(comp) {
      return new Comparator(comp, this.options);
    }, this);
    return set;
  };
  Range.prototype.intersects = function(range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError("a Range is required");
    }
    return this.set.some(function(thisComparators) {
      return thisComparators.every(function(thisComparator) {
        return range.set.some(function(rangeComparators) {
          return rangeComparators.every(function(rangeComparator) {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  };
  exports2.toComparators = toComparators;
  function toComparators(range, options) {
    return new Range(range, options).set.map(function(comp) {
      return comp.map(function(c) {
        return c.value;
      }).join(" ").trim().split(" ");
    });
  }
  function parseComparator(comp, options) {
    debug4("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug4("caret", comp);
    comp = replaceTildes(comp, options);
    debug4("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug4("xrange", comp);
    comp = replaceStars(comp, options);
    debug4("stars", comp);
    return comp;
  }
  function isX(id) {
    return !id || id.toLowerCase() === "x" || id === "*";
  }
  function replaceTildes(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceTilde(comp2, options);
    }).join(" ");
  }
  function replaceTilde(comp, options) {
    var r = options.loose ? re[TILDELOOSE] : re[TILDE];
    return comp.replace(r, function(_2, M, m2, p, pr) {
      debug4("tilde", comp, _2, M, m2, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m2)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        ret = ">=" + M + "." + m2 + ".0 <" + M + "." + (+m2 + 1) + ".0";
      } else if (pr) {
        debug4("replaceTilde pr", pr);
        ret = ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + M + "." + (+m2 + 1) + ".0";
      } else {
        ret = ">=" + M + "." + m2 + "." + p + " <" + M + "." + (+m2 + 1) + ".0";
      }
      debug4("tilde return", ret);
      return ret;
    });
  }
  function replaceCarets(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceCaret(comp2, options);
    }).join(" ");
  }
  function replaceCaret(comp, options) {
    debug4("caret", comp, options);
    var r = options.loose ? re[CARETLOOSE] : re[CARET];
    return comp.replace(r, function(_2, M, m2, p, pr) {
      debug4("caret", comp, _2, M, m2, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m2)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        if (M === "0") {
          ret = ">=" + M + "." + m2 + ".0 <" + M + "." + (+m2 + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m2 + ".0 <" + (+M + 1) + ".0.0";
        }
      } else if (pr) {
        debug4("replaceCaret pr", pr);
        if (M === "0") {
          if (m2 === "0") {
            ret = ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + M + "." + m2 + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + M + "." + (+m2 + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
        }
      } else {
        debug4("no pr");
        if (M === "0") {
          if (m2 === "0") {
            ret = ">=" + M + "." + m2 + "." + p + " <" + M + "." + m2 + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m2 + "." + p + " <" + M + "." + (+m2 + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m2 + "." + p + " <" + (+M + 1) + ".0.0";
        }
      }
      debug4("caret return", ret);
      return ret;
    });
  }
  function replaceXRanges(comp, options) {
    debug4("replaceXRanges", comp, options);
    return comp.split(/\s+/).map(function(comp2) {
      return replaceXRange(comp2, options);
    }).join(" ");
  }
  function replaceXRange(comp, options) {
    comp = comp.trim();
    var r = options.loose ? re[XRANGELOOSE] : re[XRANGE];
    return comp.replace(r, function(ret, gtlt, M, m2, p, pr) {
      debug4("xRange", comp, ret, gtlt, M, m2, p, pr);
      var xM = isX(M);
      var xm = xM || isX(m2);
      var xp = xm || isX(p);
      var anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m2 = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m2 = 0;
            p = 0;
          } else {
            m2 = +m2 + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m2 = +m2 + 1;
          }
        }
        ret = gtlt + M + "." + m2 + "." + p;
      } else if (xm) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (xp) {
        ret = ">=" + M + "." + m2 + ".0 <" + M + "." + (+m2 + 1) + ".0";
      }
      debug4("xRange return", ret);
      return ret;
    });
  }
  function replaceStars(comp, options) {
    debug4("replaceStars", comp, options);
    return comp.trim().replace(re[STAR], "");
  }
  function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = ">=" + fM + ".0.0";
    } else if (isX(fp)) {
      from = ">=" + fM + "." + fm + ".0";
    } else {
      from = ">=" + from;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = "<" + (+tM + 1) + ".0.0";
    } else if (isX(tp)) {
      to = "<" + tM + "." + (+tm + 1) + ".0";
    } else if (tpr) {
      to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
    } else {
      to = "<=" + to;
    }
    return (from + " " + to).trim();
  }
  Range.prototype.test = function(version) {
    if (!version) {
      return false;
    }
    if (typeof version === "string") {
      version = new SemVer(version, this.options);
    }
    for (var i2 = 0; i2 < this.set.length; i2++) {
      if (testSet(this.set[i2], version, this.options)) {
        return true;
      }
    }
    return false;
  };
  function testSet(set, version, options) {
    for (var i2 = 0; i2 < set.length; i2++) {
      if (!set[i2].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (i2 = 0; i2 < set.length; i2++) {
        debug4(set[i2].semver);
        if (set[i2].semver === ANY) {
          continue;
        }
        if (set[i2].semver.prerelease.length > 0) {
          var allowed = set[i2].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  }
  exports2.satisfies = satisfies;
  function satisfies(version, range, options) {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version);
  }
  exports2.maxSatisfying = maxSatisfying;
  function maxSatisfying(versions, range, options) {
    var max2 = null;
    var maxSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!max2 || maxSV.compare(v) === -1) {
          max2 = v;
          maxSV = new SemVer(max2, options);
        }
      }
    });
    return max2;
  }
  exports2.minSatisfying = minSatisfying;
  function minSatisfying(versions, range, options) {
    var min2 = null;
    var minSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!min2 || minSV.compare(v) === 1) {
          min2 = v;
          minSV = new SemVer(min2, options);
        }
      }
    });
    return min2;
  }
  exports2.minVersion = minVersion;
  function minVersion(range, loose) {
    range = new Range(range, loose);
    var minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (var i2 = 0; i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      comparators.forEach(function(comparator) {
        var compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!minver || gt(minver, compver)) {
              minver = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + comparator.operator);
        }
      });
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  }
  exports2.validRange = validRange;
  function validRange(range, options) {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  }
  exports2.ltr = ltr;
  function ltr(version, range, options) {
    return outside(version, range, "<", options);
  }
  exports2.gtr = gtr;
  function gtr(version, range, options) {
    return outside(version, range, ">", options);
  }
  exports2.outside = outside;
  function outside(version, range, hilo, options) {
    version = new SemVer(version, options);
    range = new Range(range, options);
    var gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) {
      return false;
    }
    for (var i2 = 0; i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      var high = null;
      var low = null;
      comparators.forEach(function(comparator) {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }
    return true;
  }
  exports2.prerelease = prerelease;
  function prerelease(version, options) {
    var parsed = parse2(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  }
  exports2.intersects = intersects;
  function intersects(r1, r2, options) {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2);
  }
  exports2.coerce = coerce;
  function coerce(version) {
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version !== "string") {
      return null;
    }
    var match = version.match(re[COERCE]);
    if (match == null) {
      return null;
    }
    return parse2(match[1] + "." + (match[2] || "0") + "." + (match[3] || "0"));
  }
});

// ../../node_modules/.pnpm/spdx-license-ids@3.0.9/node_modules/spdx-license-ids/index.json
var require_spdx_license_ids = __commonJS2((exports2, module2) => {
  module2.exports = [
    "0BSD",
    "AAL",
    "ADSL",
    "AFL-1.1",
    "AFL-1.2",
    "AFL-2.0",
    "AFL-2.1",
    "AFL-3.0",
    "AGPL-1.0-only",
    "AGPL-1.0-or-later",
    "AGPL-3.0-only",
    "AGPL-3.0-or-later",
    "AMDPLPA",
    "AML",
    "AMPAS",
    "ANTLR-PD",
    "ANTLR-PD-fallback",
    "APAFML",
    "APL-1.0",
    "APSL-1.0",
    "APSL-1.1",
    "APSL-1.2",
    "APSL-2.0",
    "Abstyles",
    "Adobe-2006",
    "Adobe-Glyph",
    "Afmparse",
    "Aladdin",
    "Apache-1.0",
    "Apache-1.1",
    "Apache-2.0",
    "Artistic-1.0",
    "Artistic-1.0-Perl",
    "Artistic-1.0-cl8",
    "Artistic-2.0",
    "BSD-1-Clause",
    "BSD-2-Clause",
    "BSD-2-Clause-Patent",
    "BSD-2-Clause-Views",
    "BSD-3-Clause",
    "BSD-3-Clause-Attribution",
    "BSD-3-Clause-Clear",
    "BSD-3-Clause-LBNL",
    "BSD-3-Clause-Modification",
    "BSD-3-Clause-No-Military-License",
    "BSD-3-Clause-No-Nuclear-License",
    "BSD-3-Clause-No-Nuclear-License-2014",
    "BSD-3-Clause-No-Nuclear-Warranty",
    "BSD-3-Clause-Open-MPI",
    "BSD-4-Clause",
    "BSD-4-Clause-Shortened",
    "BSD-4-Clause-UC",
    "BSD-Protection",
    "BSD-Source-Code",
    "BSL-1.0",
    "BUSL-1.1",
    "Bahyph",
    "Barr",
    "Beerware",
    "BitTorrent-1.0",
    "BitTorrent-1.1",
    "BlueOak-1.0.0",
    "Borceux",
    "C-UDA-1.0",
    "CAL-1.0",
    "CAL-1.0-Combined-Work-Exception",
    "CATOSL-1.1",
    "CC-BY-1.0",
    "CC-BY-2.0",
    "CC-BY-2.5",
    "CC-BY-3.0",
    "CC-BY-3.0-AT",
    "CC-BY-3.0-US",
    "CC-BY-4.0",
    "CC-BY-NC-1.0",
    "CC-BY-NC-2.0",
    "CC-BY-NC-2.5",
    "CC-BY-NC-3.0",
    "CC-BY-NC-4.0",
    "CC-BY-NC-ND-1.0",
    "CC-BY-NC-ND-2.0",
    "CC-BY-NC-ND-2.5",
    "CC-BY-NC-ND-3.0",
    "CC-BY-NC-ND-3.0-IGO",
    "CC-BY-NC-ND-4.0",
    "CC-BY-NC-SA-1.0",
    "CC-BY-NC-SA-2.0",
    "CC-BY-NC-SA-2.5",
    "CC-BY-NC-SA-3.0",
    "CC-BY-NC-SA-4.0",
    "CC-BY-ND-1.0",
    "CC-BY-ND-2.0",
    "CC-BY-ND-2.5",
    "CC-BY-ND-3.0",
    "CC-BY-ND-4.0",
    "CC-BY-SA-1.0",
    "CC-BY-SA-2.0",
    "CC-BY-SA-2.0-UK",
    "CC-BY-SA-2.1-JP",
    "CC-BY-SA-2.5",
    "CC-BY-SA-3.0",
    "CC-BY-SA-3.0-AT",
    "CC-BY-SA-4.0",
    "CC-PDDC",
    "CC0-1.0",
    "CDDL-1.0",
    "CDDL-1.1",
    "CDL-1.0",
    "CDLA-Permissive-1.0",
    "CDLA-Sharing-1.0",
    "CECILL-1.0",
    "CECILL-1.1",
    "CECILL-2.0",
    "CECILL-2.1",
    "CECILL-B",
    "CECILL-C",
    "CERN-OHL-1.1",
    "CERN-OHL-1.2",
    "CERN-OHL-P-2.0",
    "CERN-OHL-S-2.0",
    "CERN-OHL-W-2.0",
    "CNRI-Jython",
    "CNRI-Python",
    "CNRI-Python-GPL-Compatible",
    "CPAL-1.0",
    "CPL-1.0",
    "CPOL-1.02",
    "CUA-OPL-1.0",
    "Caldera",
    "ClArtistic",
    "Condor-1.1",
    "Crossword",
    "CrystalStacker",
    "Cube",
    "D-FSL-1.0",
    "DOC",
    "DRL-1.0",
    "DSDP",
    "Dotseqn",
    "ECL-1.0",
    "ECL-2.0",
    "EFL-1.0",
    "EFL-2.0",
    "EPICS",
    "EPL-1.0",
    "EPL-2.0",
    "EUDatagrid",
    "EUPL-1.0",
    "EUPL-1.1",
    "EUPL-1.2",
    "Entessa",
    "ErlPL-1.1",
    "Eurosym",
    "FSFAP",
    "FSFUL",
    "FSFULLR",
    "FTL",
    "Fair",
    "Frameworx-1.0",
    "FreeBSD-DOC",
    "FreeImage",
    "GD",
    "GFDL-1.1-invariants-only",
    "GFDL-1.1-invariants-or-later",
    "GFDL-1.1-no-invariants-only",
    "GFDL-1.1-no-invariants-or-later",
    "GFDL-1.1-only",
    "GFDL-1.1-or-later",
    "GFDL-1.2-invariants-only",
    "GFDL-1.2-invariants-or-later",
    "GFDL-1.2-no-invariants-only",
    "GFDL-1.2-no-invariants-or-later",
    "GFDL-1.2-only",
    "GFDL-1.2-or-later",
    "GFDL-1.3-invariants-only",
    "GFDL-1.3-invariants-or-later",
    "GFDL-1.3-no-invariants-only",
    "GFDL-1.3-no-invariants-or-later",
    "GFDL-1.3-only",
    "GFDL-1.3-or-later",
    "GL2PS",
    "GLWTPL",
    "GPL-1.0-only",
    "GPL-1.0-or-later",
    "GPL-2.0-only",
    "GPL-2.0-or-later",
    "GPL-3.0-only",
    "GPL-3.0-or-later",
    "Giftware",
    "Glide",
    "Glulxe",
    "HPND",
    "HPND-sell-variant",
    "HTMLTIDY",
    "HaskellReport",
    "Hippocratic-2.1",
    "IBM-pibs",
    "ICU",
    "IJG",
    "IPA",
    "IPL-1.0",
    "ISC",
    "ImageMagick",
    "Imlib2",
    "Info-ZIP",
    "Intel",
    "Intel-ACPI",
    "Interbase-1.0",
    "JPNIC",
    "JSON",
    "JasPer-2.0",
    "LAL-1.2",
    "LAL-1.3",
    "LGPL-2.0-only",
    "LGPL-2.0-or-later",
    "LGPL-2.1-only",
    "LGPL-2.1-or-later",
    "LGPL-3.0-only",
    "LGPL-3.0-or-later",
    "LGPLLR",
    "LPL-1.0",
    "LPL-1.02",
    "LPPL-1.0",
    "LPPL-1.1",
    "LPPL-1.2",
    "LPPL-1.3a",
    "LPPL-1.3c",
    "Latex2e",
    "Leptonica",
    "LiLiQ-P-1.1",
    "LiLiQ-R-1.1",
    "LiLiQ-Rplus-1.1",
    "Libpng",
    "Linux-OpenIB",
    "MIT",
    "MIT-0",
    "MIT-CMU",
    "MIT-Modern-Variant",
    "MIT-advertising",
    "MIT-enna",
    "MIT-feh",
    "MIT-open-group",
    "MITNFA",
    "MPL-1.0",
    "MPL-1.1",
    "MPL-2.0",
    "MPL-2.0-no-copyleft-exception",
    "MS-PL",
    "MS-RL",
    "MTLL",
    "MakeIndex",
    "MirOS",
    "Motosoto",
    "MulanPSL-1.0",
    "MulanPSL-2.0",
    "Multics",
    "Mup",
    "NAIST-2003",
    "NASA-1.3",
    "NBPL-1.0",
    "NCGL-UK-2.0",
    "NCSA",
    "NGPL",
    "NIST-PD",
    "NIST-PD-fallback",
    "NLOD-1.0",
    "NLPL",
    "NOSL",
    "NPL-1.0",
    "NPL-1.1",
    "NPOSL-3.0",
    "NRL",
    "NTP",
    "NTP-0",
    "Naumen",
    "Net-SNMP",
    "NetCDF",
    "Newsletr",
    "Nokia",
    "Noweb",
    "O-UDA-1.0",
    "OCCT-PL",
    "OCLC-2.0",
    "ODC-By-1.0",
    "ODbL-1.0",
    "OFL-1.0",
    "OFL-1.0-RFN",
    "OFL-1.0-no-RFN",
    "OFL-1.1",
    "OFL-1.1-RFN",
    "OFL-1.1-no-RFN",
    "OGC-1.0",
    "OGDL-Taiwan-1.0",
    "OGL-Canada-2.0",
    "OGL-UK-1.0",
    "OGL-UK-2.0",
    "OGL-UK-3.0",
    "OGTSL",
    "OLDAP-1.1",
    "OLDAP-1.2",
    "OLDAP-1.3",
    "OLDAP-1.4",
    "OLDAP-2.0",
    "OLDAP-2.0.1",
    "OLDAP-2.1",
    "OLDAP-2.2",
    "OLDAP-2.2.1",
    "OLDAP-2.2.2",
    "OLDAP-2.3",
    "OLDAP-2.4",
    "OLDAP-2.5",
    "OLDAP-2.6",
    "OLDAP-2.7",
    "OLDAP-2.8",
    "OML",
    "OPL-1.0",
    "OSET-PL-2.1",
    "OSL-1.0",
    "OSL-1.1",
    "OSL-2.0",
    "OSL-2.1",
    "OSL-3.0",
    "OpenSSL",
    "PDDL-1.0",
    "PHP-3.0",
    "PHP-3.01",
    "PSF-2.0",
    "Parity-6.0.0",
    "Parity-7.0.0",
    "Plexus",
    "PolyForm-Noncommercial-1.0.0",
    "PolyForm-Small-Business-1.0.0",
    "PostgreSQL",
    "Python-2.0",
    "QPL-1.0",
    "Qhull",
    "RHeCos-1.1",
    "RPL-1.1",
    "RPL-1.5",
    "RPSL-1.0",
    "RSA-MD",
    "RSCPL",
    "Rdisc",
    "Ruby",
    "SAX-PD",
    "SCEA",
    "SGI-B-1.0",
    "SGI-B-1.1",
    "SGI-B-2.0",
    "SHL-0.5",
    "SHL-0.51",
    "SISSL",
    "SISSL-1.2",
    "SMLNJ",
    "SMPPL",
    "SNIA",
    "SPL-1.0",
    "SSH-OpenSSH",
    "SSH-short",
    "SSPL-1.0",
    "SWL",
    "Saxpath",
    "Sendmail",
    "Sendmail-8.23",
    "SimPL-2.0",
    "Sleepycat",
    "Spencer-86",
    "Spencer-94",
    "Spencer-99",
    "SugarCRM-1.1.3",
    "TAPR-OHL-1.0",
    "TCL",
    "TCP-wrappers",
    "TMate",
    "TORQUE-1.1",
    "TOSL",
    "TU-Berlin-1.0",
    "TU-Berlin-2.0",
    "UCL-1.0",
    "UPL-1.0",
    "Unicode-DFS-2015",
    "Unicode-DFS-2016",
    "Unicode-TOU",
    "Unlicense",
    "VOSTROM",
    "VSL-1.0",
    "Vim",
    "W3C",
    "W3C-19980720",
    "W3C-20150513",
    "WTFPL",
    "Watcom-1.0",
    "Wsuipa",
    "X11",
    "XFree86-1.1",
    "XSkat",
    "Xerox",
    "Xnet",
    "YPL-1.0",
    "YPL-1.1",
    "ZPL-1.1",
    "ZPL-2.0",
    "ZPL-2.1",
    "Zed",
    "Zend-2.0",
    "Zimbra-1.3",
    "Zimbra-1.4",
    "Zlib",
    "blessing",
    "bzip2-1.0.5",
    "bzip2-1.0.6",
    "copyleft-next-0.3.0",
    "copyleft-next-0.3.1",
    "curl",
    "diffmark",
    "dvipdfm",
    "eGenix",
    "etalab-2.0",
    "gSOAP-1.3b",
    "gnuplot",
    "iMatix",
    "libpng-2.0",
    "libselinux-1.0",
    "libtiff",
    "mpich2",
    "psfrag",
    "psutils",
    "xinetd",
    "xpp",
    "zlib-acknowledgement"
  ];
});

// ../../node_modules/.pnpm/spdx-license-ids@3.0.9/node_modules/spdx-license-ids/deprecated.json
var require_deprecated = __commonJS2((exports2, module2) => {
  module2.exports = [
    "AGPL-1.0",
    "AGPL-3.0",
    "BSD-2-Clause-FreeBSD",
    "BSD-2-Clause-NetBSD",
    "GFDL-1.1",
    "GFDL-1.2",
    "GFDL-1.3",
    "GPL-1.0",
    "GPL-2.0",
    "GPL-2.0-with-GCC-exception",
    "GPL-2.0-with-autoconf-exception",
    "GPL-2.0-with-bison-exception",
    "GPL-2.0-with-classpath-exception",
    "GPL-2.0-with-font-exception",
    "GPL-3.0",
    "GPL-3.0-with-GCC-exception",
    "GPL-3.0-with-autoconf-exception",
    "LGPL-2.0",
    "LGPL-2.1",
    "LGPL-3.0",
    "Nunit",
    "StandardML-NJ",
    "eCos-2.0",
    "wxWindows"
  ];
});

// ../../node_modules/.pnpm/spdx-exceptions@2.3.0/node_modules/spdx-exceptions/index.json
var require_spdx_exceptions = __commonJS2((exports2, module2) => {
  module2.exports = [
    "389-exception",
    "Autoconf-exception-2.0",
    "Autoconf-exception-3.0",
    "Bison-exception-2.2",
    "Bootloader-exception",
    "Classpath-exception-2.0",
    "CLISP-exception-2.0",
    "DigiRule-FOSS-exception",
    "eCos-exception-2.0",
    "Fawkes-Runtime-exception",
    "FLTK-exception",
    "Font-exception-2.0",
    "freertos-exception-2.0",
    "GCC-exception-2.0",
    "GCC-exception-3.1",
    "gnu-javamail-exception",
    "GPL-3.0-linking-exception",
    "GPL-3.0-linking-source-exception",
    "GPL-CC-1.0",
    "i2p-gpl-java-exception",
    "Libtool-exception",
    "Linux-syscall-note",
    "LLVM-exception",
    "LZMA-exception",
    "mif-exception",
    "Nokia-Qt-exception-1.1",
    "OCaml-LGPL-linking-exception",
    "OCCT-exception-1.0",
    "OpenJDK-assembly-exception-1.0",
    "openvpn-openssl-exception",
    "PS-or-PDF-font-exception-20170817",
    "Qt-GPL-exception-1.0",
    "Qt-LGPL-exception-1.1",
    "Qwt-exception-1.0",
    "Swift-exception",
    "u-boot-exception-2.0",
    "Universal-FOSS-exception-1.0",
    "WxWindows-exception-3.1"
  ];
});

// ../../node_modules/.pnpm/spdx-expression-parse@3.0.1/node_modules/spdx-expression-parse/scan.js
var require_scan2 = __commonJS2((exports2, module2) => {
  "use strict";
  var licenses = [].concat(require_spdx_license_ids()).concat(require_deprecated());
  var exceptions = require_spdx_exceptions();
  module2.exports = function(source) {
    var index = 0;
    function hasMore() {
      return index < source.length;
    }
    function read(value) {
      if (value instanceof RegExp) {
        var chars = source.slice(index);
        var match = chars.match(value);
        if (match) {
          index += match[0].length;
          return match[0];
        }
      } else {
        if (source.indexOf(value, index) === index) {
          index += value.length;
          return value;
        }
      }
    }
    function skipWhitespace() {
      read(/[ ]*/);
    }
    function operator() {
      var string;
      var possibilities = ["WITH", "AND", "OR", "(", ")", ":", "+"];
      for (var i = 0; i < possibilities.length; i++) {
        string = read(possibilities[i]);
        if (string) {
          break;
        }
      }
      if (string === "+" && index > 1 && source[index - 2] === " ") {
        throw new Error("Space before `+`");
      }
      return string && {
        type: "OPERATOR",
        string
      };
    }
    function idstring() {
      return read(/[A-Za-z0-9-.]+/);
    }
    function expectIdstring() {
      var string = idstring();
      if (!string) {
        throw new Error("Expected idstring at offset " + index);
      }
      return string;
    }
    function documentRef() {
      if (read("DocumentRef-")) {
        var string = expectIdstring();
        return {type: "DOCUMENTREF", string};
      }
    }
    function licenseRef() {
      if (read("LicenseRef-")) {
        var string = expectIdstring();
        return {type: "LICENSEREF", string};
      }
    }
    function identifier() {
      var begin = index;
      var string = idstring();
      if (licenses.indexOf(string) !== -1) {
        return {
          type: "LICENSE",
          string
        };
      } else if (exceptions.indexOf(string) !== -1) {
        return {
          type: "EXCEPTION",
          string
        };
      }
      index = begin;
    }
    function parseToken() {
      return operator() || documentRef() || licenseRef() || identifier();
    }
    var tokens = [];
    while (hasMore()) {
      skipWhitespace();
      if (!hasMore()) {
        break;
      }
      var token = parseToken();
      if (!token) {
        throw new Error("Unexpected `" + source[index] + "` at offset " + index);
      }
      tokens.push(token);
    }
    return tokens;
  };
});

// ../../node_modules/.pnpm/spdx-expression-parse@3.0.1/node_modules/spdx-expression-parse/parse.js
var require_parse6 = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = function(tokens) {
    var index = 0;
    function hasMore() {
      return index < tokens.length;
    }
    function token() {
      return hasMore() ? tokens[index] : null;
    }
    function next() {
      if (!hasMore()) {
        throw new Error();
      }
      index++;
    }
    function parseOperator(operator) {
      var t = token();
      if (t && t.type === "OPERATOR" && operator === t.string) {
        next();
        return t.string;
      }
    }
    function parseWith() {
      if (parseOperator("WITH")) {
        var t = token();
        if (t && t.type === "EXCEPTION") {
          next();
          return t.string;
        }
        throw new Error("Expected exception after `WITH`");
      }
    }
    function parseLicenseRef() {
      var begin = index;
      var string = "";
      var t = token();
      if (t.type === "DOCUMENTREF") {
        next();
        string += "DocumentRef-" + t.string + ":";
        if (!parseOperator(":")) {
          throw new Error("Expected `:` after `DocumentRef-...`");
        }
      }
      t = token();
      if (t.type === "LICENSEREF") {
        next();
        string += "LicenseRef-" + t.string;
        return {license: string};
      }
      index = begin;
    }
    function parseLicense() {
      var t = token();
      if (t && t.type === "LICENSE") {
        next();
        var node2 = {license: t.string};
        if (parseOperator("+")) {
          node2.plus = true;
        }
        var exception = parseWith();
        if (exception) {
          node2.exception = exception;
        }
        return node2;
      }
    }
    function parseParenthesizedExpression() {
      var left = parseOperator("(");
      if (!left) {
        return;
      }
      var expr = parseExpression();
      if (!parseOperator(")")) {
        throw new Error("Expected `)`");
      }
      return expr;
    }
    function parseAtom() {
      return parseParenthesizedExpression() || parseLicenseRef() || parseLicense();
    }
    function makeBinaryOpParser(operator, nextParser) {
      return function parseBinaryOp() {
        var left = nextParser();
        if (!left) {
          return;
        }
        if (!parseOperator(operator)) {
          return left;
        }
        var right = parseBinaryOp();
        if (!right) {
          throw new Error("Expected expression");
        }
        return {
          left,
          conjunction: operator.toLowerCase(),
          right
        };
      };
    }
    var parseAnd = makeBinaryOpParser("AND", parseAtom);
    var parseExpression = makeBinaryOpParser("OR", parseAnd);
    var node = parseExpression();
    if (!node || hasMore()) {
      throw new Error("Syntax error");
    }
    return node;
  };
});

// ../../node_modules/.pnpm/spdx-expression-parse@3.0.1/node_modules/spdx-expression-parse/index.js
var require_spdx_expression_parse = __commonJS2((exports2, module2) => {
  "use strict";
  var scan = require_scan2();
  var parse2 = require_parse6();
  module2.exports = function(source) {
    return parse2(scan(source));
  };
});

// ../../node_modules/.pnpm/spdx-correct@3.1.1/node_modules/spdx-correct/index.js
var require_spdx_correct = __commonJS2((exports2, module2) => {
  var parse2 = require_spdx_expression_parse();
  var spdxLicenseIds = require_spdx_license_ids();
  function valid(string) {
    try {
      parse2(string);
      return true;
    } catch (error) {
      return false;
    }
  }
  var transpositions = [
    ["APGL", "AGPL"],
    ["Gpl", "GPL"],
    ["GLP", "GPL"],
    ["APL", "Apache"],
    ["ISD", "ISC"],
    ["GLP", "GPL"],
    ["IST", "ISC"],
    ["Claude", "Clause"],
    [" or later", "+"],
    [" International", ""],
    ["GNU", "GPL"],
    ["GUN", "GPL"],
    ["+", ""],
    ["GNU GPL", "GPL"],
    ["GNU/GPL", "GPL"],
    ["GNU GLP", "GPL"],
    ["GNU General Public License", "GPL"],
    ["Gnu public license", "GPL"],
    ["GNU Public License", "GPL"],
    ["GNU GENERAL PUBLIC LICENSE", "GPL"],
    ["MTI", "MIT"],
    ["Mozilla Public License", "MPL"],
    ["Universal Permissive License", "UPL"],
    ["WTH", "WTF"],
    ["-License", ""]
  ];
  var TRANSPOSED = 0;
  var CORRECT = 1;
  var transforms = [
    function(argument) {
      return argument.toUpperCase();
    },
    function(argument) {
      return argument.trim();
    },
    function(argument) {
      return argument.replace(/\./g, "");
    },
    function(argument) {
      return argument.replace(/\s+/g, "");
    },
    function(argument) {
      return argument.replace(/\s+/g, "-");
    },
    function(argument) {
      return argument.replace("v", "-");
    },
    function(argument) {
      return argument.replace(/,?\s*(\d)/, "-$1");
    },
    function(argument) {
      return argument.replace(/,?\s*(\d)/, "-$1.0");
    },
    function(argument) {
      return argument.replace(/,?\s*(V\.|v\.|V|v|Version|version)\s*(\d)/, "-$2");
    },
    function(argument) {
      return argument.replace(/,?\s*(V\.|v\.|V|v|Version|version)\s*(\d)/, "-$2.0");
    },
    function(argument) {
      return argument[0].toUpperCase() + argument.slice(1);
    },
    function(argument) {
      return argument.replace("/", "-");
    },
    function(argument) {
      return argument.replace(/\s*V\s*(\d)/, "-$1").replace(/(\d)$/, "$1.0");
    },
    function(argument) {
      if (argument.indexOf("3.0") !== -1) {
        return argument + "-or-later";
      } else {
        return argument + "-only";
      }
    },
    function(argument) {
      return argument + "only";
    },
    function(argument) {
      return argument.replace(/(\d)$/, "-$1.0");
    },
    function(argument) {
      return argument.replace(/(-| )?(\d)$/, "-$2-Clause");
    },
    function(argument) {
      return argument.replace(/(-| )clause(-| )(\d)/, "-$3-Clause");
    },
    function(argument) {
      return argument.replace(/\b(Modified|New|Revised)(-| )?BSD((-| )License)?/i, "BSD-3-Clause");
    },
    function(argument) {
      return argument.replace(/\bSimplified(-| )?BSD((-| )License)?/i, "BSD-2-Clause");
    },
    function(argument) {
      return argument.replace(/\b(Free|Net)(-| )?BSD((-| )License)?/i, "BSD-2-Clause-$1BSD");
    },
    function(argument) {
      return argument.replace(/\bClear(-| )?BSD((-| )License)?/i, "BSD-3-Clause-Clear");
    },
    function(argument) {
      return argument.replace(/\b(Old|Original)(-| )?BSD((-| )License)?/i, "BSD-4-Clause");
    },
    function(argument) {
      return "CC-" + argument;
    },
    function(argument) {
      return "CC-" + argument + "-4.0";
    },
    function(argument) {
      return argument.replace("Attribution", "BY").replace("NonCommercial", "NC").replace("NoDerivatives", "ND").replace(/ (\d)/, "-$1").replace(/ ?International/, "");
    },
    function(argument) {
      return "CC-" + argument.replace("Attribution", "BY").replace("NonCommercial", "NC").replace("NoDerivatives", "ND").replace(/ (\d)/, "-$1").replace(/ ?International/, "") + "-4.0";
    }
  ];
  var licensesWithVersions = spdxLicenseIds.map(function(id) {
    var match = /^(.*)-\d+\.\d+$/.exec(id);
    return match ? [match[0], match[1]] : [id, null];
  }).reduce(function(objectMap, item) {
    var key = item[1];
    objectMap[key] = objectMap[key] || [];
    objectMap[key].push(item[0]);
    return objectMap;
  }, {});
  var licensesWithOneVersion = Object.keys(licensesWithVersions).map(function makeEntries(key) {
    return [key, licensesWithVersions[key]];
  }).filter(function identifySoleVersions(item) {
    return item[1].length === 1 && item[0] !== null && item[0] !== "APL";
  }).map(function createLastResorts(item) {
    return [item[0], item[1][0]];
  });
  licensesWithVersions = void 0;
  var lastResorts = [
    ["UNLI", "Unlicense"],
    ["WTF", "WTFPL"],
    ["2 CLAUSE", "BSD-2-Clause"],
    ["2-CLAUSE", "BSD-2-Clause"],
    ["3 CLAUSE", "BSD-3-Clause"],
    ["3-CLAUSE", "BSD-3-Clause"],
    ["AFFERO", "AGPL-3.0-or-later"],
    ["AGPL", "AGPL-3.0-or-later"],
    ["APACHE", "Apache-2.0"],
    ["ARTISTIC", "Artistic-2.0"],
    ["Affero", "AGPL-3.0-or-later"],
    ["BEER", "Beerware"],
    ["BOOST", "BSL-1.0"],
    ["BSD", "BSD-2-Clause"],
    ["CDDL", "CDDL-1.1"],
    ["ECLIPSE", "EPL-1.0"],
    ["FUCK", "WTFPL"],
    ["GNU", "GPL-3.0-or-later"],
    ["LGPL", "LGPL-3.0-or-later"],
    ["GPLV1", "GPL-1.0-only"],
    ["GPL-1", "GPL-1.0-only"],
    ["GPLV2", "GPL-2.0-only"],
    ["GPL-2", "GPL-2.0-only"],
    ["GPL", "GPL-3.0-or-later"],
    ["MIT +NO-FALSE-ATTRIBS", "MITNFA"],
    ["MIT", "MIT"],
    ["MPL", "MPL-2.0"],
    ["X11", "X11"],
    ["ZLIB", "Zlib"]
  ].concat(licensesWithOneVersion);
  var SUBSTRING = 0;
  var IDENTIFIER = 1;
  var validTransformation = function(identifier) {
    for (var i = 0; i < transforms.length; i++) {
      var transformed = transforms[i](identifier).trim();
      if (transformed !== identifier && valid(transformed)) {
        return transformed;
      }
    }
    return null;
  };
  var validLastResort = function(identifier) {
    var upperCased = identifier.toUpperCase();
    for (var i = 0; i < lastResorts.length; i++) {
      var lastResort = lastResorts[i];
      if (upperCased.indexOf(lastResort[SUBSTRING]) > -1) {
        return lastResort[IDENTIFIER];
      }
    }
    return null;
  };
  var anyCorrection = function(identifier, check2) {
    for (var i = 0; i < transpositions.length; i++) {
      var transposition = transpositions[i];
      var transposed = transposition[TRANSPOSED];
      if (identifier.indexOf(transposed) > -1) {
        var corrected = identifier.replace(transposed, transposition[CORRECT]);
        var checked = check2(corrected);
        if (checked !== null) {
          return checked;
        }
      }
    }
    return null;
  };
  module2.exports = function(identifier, options) {
    options = options || {};
    var upgrade = options.upgrade === void 0 ? true : !!options.upgrade;
    function postprocess(value) {
      return upgrade ? upgradeGPLs(value) : value;
    }
    var validArugment = typeof identifier === "string" && identifier.trim().length !== 0;
    if (!validArugment) {
      throw Error("Invalid argument. Expected non-empty string.");
    }
    identifier = identifier.trim();
    if (valid(identifier)) {
      return postprocess(identifier);
    }
    var noPlus = identifier.replace(/\+$/, "").trim();
    if (valid(noPlus)) {
      return postprocess(noPlus);
    }
    var transformed = validTransformation(identifier);
    if (transformed !== null) {
      return postprocess(transformed);
    }
    transformed = anyCorrection(identifier, function(argument) {
      if (valid(argument)) {
        return argument;
      }
      return validTransformation(argument);
    });
    if (transformed !== null) {
      return postprocess(transformed);
    }
    transformed = validLastResort(identifier);
    if (transformed !== null) {
      return postprocess(transformed);
    }
    transformed = anyCorrection(identifier, validLastResort);
    if (transformed !== null) {
      return postprocess(transformed);
    }
    return null;
  };
  function upgradeGPLs(value) {
    if ([
      "GPL-1.0",
      "LGPL-1.0",
      "AGPL-1.0",
      "GPL-2.0",
      "LGPL-2.0",
      "AGPL-2.0",
      "LGPL-2.1"
    ].indexOf(value) !== -1) {
      return value + "-only";
    } else if ([
      "GPL-1.0+",
      "GPL-2.0+",
      "GPL-3.0+",
      "LGPL-2.0+",
      "LGPL-2.1+",
      "LGPL-3.0+",
      "AGPL-1.0+",
      "AGPL-3.0+"
    ].indexOf(value) !== -1) {
      return value.replace(/\+$/, "-or-later");
    } else if (["GPL-3.0", "LGPL-3.0", "AGPL-3.0"].indexOf(value) !== -1) {
      return value + "-or-later";
    } else {
      return value;
    }
  }
});

// ../../node_modules/.pnpm/validate-npm-package-license@3.0.4/node_modules/validate-npm-package-license/index.js
var require_validate_npm_package_license = __commonJS2((exports2, module2) => {
  var parse2 = require_spdx_expression_parse();
  var correct = require_spdx_correct();
  var genericWarning = 'license should be a valid SPDX license expression (without "LicenseRef"), "UNLICENSED", or "SEE LICENSE IN <filename>"';
  var fileReferenceRE = /^SEE LICEN[CS]E IN (.+)$/;
  function startsWith(prefix, string) {
    return string.slice(0, prefix.length) === prefix;
  }
  function usesLicenseRef(ast) {
    if (ast.hasOwnProperty("license")) {
      var license = ast.license;
      return startsWith("LicenseRef", license) || startsWith("DocumentRef", license);
    } else {
      return usesLicenseRef(ast.left) || usesLicenseRef(ast.right);
    }
  }
  module2.exports = function(argument) {
    var ast;
    try {
      ast = parse2(argument);
    } catch (e) {
      var match;
      if (argument === "UNLICENSED" || argument === "UNLICENCED") {
        return {
          validForOldPackages: true,
          validForNewPackages: true,
          unlicensed: true
        };
      } else if (match = fileReferenceRE.exec(argument)) {
        return {
          validForOldPackages: true,
          validForNewPackages: true,
          inFile: match[1]
        };
      } else {
        var result = {
          validForOldPackages: false,
          validForNewPackages: false,
          warnings: [genericWarning]
        };
        if (argument.trim().length !== 0) {
          var corrected = correct(argument);
          if (corrected) {
            result.warnings.push('license is similar to the valid expression "' + corrected + '"');
          }
        }
        return result;
      }
    }
    if (usesLicenseRef(ast)) {
      return {
        validForNewPackages: false,
        validForOldPackages: false,
        spdx: true,
        warnings: [genericWarning]
      };
    } else {
      return {
        validForNewPackages: true,
        validForOldPackages: true,
        spdx: true
      };
    }
  };
});

// ../../node_modules/.pnpm/hosted-git-info@2.8.9/node_modules/hosted-git-info/git-host-info.js
var require_git_host_info = __commonJS2((exports2, module2) => {
  "use strict";
  var gitHosts = module2.exports = {
    github: {
      protocols: ["git", "http", "git+ssh", "git+https", "ssh", "https"],
      domain: "github.com",
      treepath: "tree",
      filetemplate: "https://{auth@}raw.githubusercontent.com/{user}/{project}/{committish}/{path}",
      bugstemplate: "https://{domain}/{user}/{project}/issues",
      gittemplate: "git://{auth@}{domain}/{user}/{project}.git{#committish}",
      tarballtemplate: "https://codeload.{domain}/{user}/{project}/tar.gz/{committish}"
    },
    bitbucket: {
      protocols: ["git+ssh", "git+https", "ssh", "https"],
      domain: "bitbucket.org",
      treepath: "src",
      tarballtemplate: "https://{domain}/{user}/{project}/get/{committish}.tar.gz"
    },
    gitlab: {
      protocols: ["git+ssh", "git+https", "ssh", "https"],
      domain: "gitlab.com",
      treepath: "tree",
      bugstemplate: "https://{domain}/{user}/{project}/issues",
      httpstemplate: "git+https://{auth@}{domain}/{user}/{projectPath}.git{#committish}",
      tarballtemplate: "https://{domain}/{user}/{project}/repository/archive.tar.gz?ref={committish}",
      pathmatch: /^[/]([^/]+)[/]((?!.*(\/-\/|\/repository\/archive\.tar\.gz\?=.*|\/repository\/[^/]+\/archive.tar.gz$)).*?)(?:[.]git|[/])?$/
    },
    gist: {
      protocols: ["git", "git+ssh", "git+https", "ssh", "https"],
      domain: "gist.github.com",
      pathmatch: /^[/](?:([^/]+)[/])?([a-z0-9]{32,})(?:[.]git)?$/,
      filetemplate: "https://gist.githubusercontent.com/{user}/{project}/raw{/committish}/{path}",
      bugstemplate: "https://{domain}/{project}",
      gittemplate: "git://{domain}/{project}.git{#committish}",
      sshtemplate: "git@{domain}:/{project}.git{#committish}",
      sshurltemplate: "git+ssh://git@{domain}/{project}.git{#committish}",
      browsetemplate: "https://{domain}/{project}{/committish}",
      browsefiletemplate: "https://{domain}/{project}{/committish}{#path}",
      docstemplate: "https://{domain}/{project}{/committish}",
      httpstemplate: "git+https://{domain}/{project}.git{#committish}",
      shortcuttemplate: "{type}:{project}{#committish}",
      pathtemplate: "{project}{#committish}",
      tarballtemplate: "https://codeload.github.com/gist/{project}/tar.gz/{committish}",
      hashformat: function(fragment) {
        return "file-" + formatHashFragment(fragment);
      }
    }
  };
  var gitHostDefaults = {
    sshtemplate: "git@{domain}:{user}/{project}.git{#committish}",
    sshurltemplate: "git+ssh://git@{domain}/{user}/{project}.git{#committish}",
    browsetemplate: "https://{domain}/{user}/{project}{/tree/committish}",
    browsefiletemplate: "https://{domain}/{user}/{project}/{treepath}/{committish}/{path}{#fragment}",
    docstemplate: "https://{domain}/{user}/{project}{/tree/committish}#readme",
    httpstemplate: "git+https://{auth@}{domain}/{user}/{project}.git{#committish}",
    filetemplate: "https://{domain}/{user}/{project}/raw/{committish}/{path}",
    shortcuttemplate: "{type}:{user}/{project}{#committish}",
    pathtemplate: "{user}/{project}{#committish}",
    pathmatch: /^[/]([^/]+)[/]([^/]+?)(?:[.]git|[/])?$/,
    hashformat: formatHashFragment
  };
  Object.keys(gitHosts).forEach(function(name) {
    Object.keys(gitHostDefaults).forEach(function(key) {
      if (gitHosts[name][key])
        return;
      gitHosts[name][key] = gitHostDefaults[key];
    });
    gitHosts[name].protocols_re = RegExp("^(" + gitHosts[name].protocols.map(function(protocol) {
      return protocol.replace(/([\\+*{}()[\]$^|])/g, "\\$1");
    }).join("|") + "):$");
  });
  function formatHashFragment(fragment) {
    return fragment.toLowerCase().replace(/^\W+|\/|\W+$/g, "").replace(/\W+/g, "-");
  }
});

// ../../node_modules/.pnpm/hosted-git-info@2.8.9/node_modules/hosted-git-info/git-host.js
var require_git_host = __commonJS2((exports2, module2) => {
  "use strict";
  var gitHosts = require_git_host_info();
  var extend = Object.assign || function _extend(target, source) {
    if (source === null || typeof source !== "object")
      return target;
    var keys = Object.keys(source);
    var i = keys.length;
    while (i--) {
      target[keys[i]] = source[keys[i]];
    }
    return target;
  };
  module2.exports = GitHost;
  function GitHost(type, user, auth, project, committish, defaultRepresentation, opts) {
    var gitHostInfo = this;
    gitHostInfo.type = type;
    Object.keys(gitHosts[type]).forEach(function(key) {
      gitHostInfo[key] = gitHosts[type][key];
    });
    gitHostInfo.user = user;
    gitHostInfo.auth = auth;
    gitHostInfo.project = project;
    gitHostInfo.committish = committish;
    gitHostInfo.default = defaultRepresentation;
    gitHostInfo.opts = opts || {};
  }
  GitHost.prototype.hash = function() {
    return this.committish ? "#" + this.committish : "";
  };
  GitHost.prototype._fill = function(template, opts) {
    if (!template)
      return;
    var vars = extend({}, opts);
    vars.path = vars.path ? vars.path.replace(/^[/]+/g, "") : "";
    opts = extend(extend({}, this.opts), opts);
    var self2 = this;
    Object.keys(this).forEach(function(key) {
      if (self2[key] != null && vars[key] == null)
        vars[key] = self2[key];
    });
    var rawAuth = vars.auth;
    var rawcommittish = vars.committish;
    var rawFragment = vars.fragment;
    var rawPath = vars.path;
    var rawProject = vars.project;
    Object.keys(vars).forEach(function(key) {
      var value = vars[key];
      if ((key === "path" || key === "project") && typeof value === "string") {
        vars[key] = value.split("/").map(function(pathComponent) {
          return encodeURIComponent(pathComponent);
        }).join("/");
      } else {
        vars[key] = encodeURIComponent(value);
      }
    });
    vars["auth@"] = rawAuth ? rawAuth + "@" : "";
    vars["#fragment"] = rawFragment ? "#" + this.hashformat(rawFragment) : "";
    vars.fragment = vars.fragment ? vars.fragment : "";
    vars["#path"] = rawPath ? "#" + this.hashformat(rawPath) : "";
    vars["/path"] = vars.path ? "/" + vars.path : "";
    vars.projectPath = rawProject.split("/").map(encodeURIComponent).join("/");
    if (opts.noCommittish) {
      vars["#committish"] = "";
      vars["/tree/committish"] = "";
      vars["/committish"] = "";
      vars.committish = "";
    } else {
      vars["#committish"] = rawcommittish ? "#" + rawcommittish : "";
      vars["/tree/committish"] = vars.committish ? "/" + vars.treepath + "/" + vars.committish : "";
      vars["/committish"] = vars.committish ? "/" + vars.committish : "";
      vars.committish = vars.committish || "master";
    }
    var res = template;
    Object.keys(vars).forEach(function(key) {
      res = res.replace(new RegExp("[{]" + key + "[}]", "g"), vars[key]);
    });
    if (opts.noGitPlus) {
      return res.replace(/^git[+]/, "");
    } else {
      return res;
    }
  };
  GitHost.prototype.ssh = function(opts) {
    return this._fill(this.sshtemplate, opts);
  };
  GitHost.prototype.sshurl = function(opts) {
    return this._fill(this.sshurltemplate, opts);
  };
  GitHost.prototype.browse = function(P2, F, opts) {
    if (typeof P2 === "string") {
      if (typeof F !== "string") {
        opts = F;
        F = null;
      }
      return this._fill(this.browsefiletemplate, extend({
        fragment: F,
        path: P2
      }, opts));
    } else {
      return this._fill(this.browsetemplate, P2);
    }
  };
  GitHost.prototype.docs = function(opts) {
    return this._fill(this.docstemplate, opts);
  };
  GitHost.prototype.bugs = function(opts) {
    return this._fill(this.bugstemplate, opts);
  };
  GitHost.prototype.https = function(opts) {
    return this._fill(this.httpstemplate, opts);
  };
  GitHost.prototype.git = function(opts) {
    return this._fill(this.gittemplate, opts);
  };
  GitHost.prototype.shortcut = function(opts) {
    return this._fill(this.shortcuttemplate, opts);
  };
  GitHost.prototype.path = function(opts) {
    return this._fill(this.pathtemplate, opts);
  };
  GitHost.prototype.tarball = function(opts_) {
    var opts = extend({}, opts_, {noCommittish: false});
    return this._fill(this.tarballtemplate, opts);
  };
  GitHost.prototype.file = function(P2, opts) {
    return this._fill(this.filetemplate, extend({path: P2}, opts));
  };
  GitHost.prototype.getDefaultRepresentation = function() {
    return this.default;
  };
  GitHost.prototype.toString = function(opts) {
    if (this.default && typeof this[this.default] === "function")
      return this[this.default](opts);
    return this.sshurl(opts);
  };
});

// ../../node_modules/.pnpm/hosted-git-info@2.8.9/node_modules/hosted-git-info/index.js
var require_hosted_git_info = __commonJS2((exports2, module2) => {
  "use strict";
  var url = require("url");
  var gitHosts = require_git_host_info();
  var GitHost = module2.exports = require_git_host();
  var protocolToRepresentationMap = {
    "git+ssh:": "sshurl",
    "git+https:": "https",
    "ssh:": "sshurl",
    "git:": "git"
  };
  function protocolToRepresentation(protocol) {
    return protocolToRepresentationMap[protocol] || protocol.slice(0, -1);
  }
  var authProtocols = {
    "git:": true,
    "https:": true,
    "git+https:": true,
    "http:": true,
    "git+http:": true
  };
  var cache = {};
  module2.exports.fromUrl = function(giturl, opts) {
    if (typeof giturl !== "string")
      return;
    var key = giturl + JSON.stringify(opts || {});
    if (!(key in cache)) {
      cache[key] = fromUrl(giturl, opts);
    }
    return cache[key];
  };
  function fromUrl(giturl, opts) {
    if (giturl == null || giturl === "")
      return;
    var url2 = fixupUnqualifiedGist(isGitHubShorthand(giturl) ? "github:" + giturl : giturl);
    var parsed = parseGitUrl(url2);
    var shortcutMatch = url2.match(/^([^:]+):(?:[^@]+@)?(?:([^/]*)\/)?([^#]+)/);
    var matches = Object.keys(gitHosts).map(function(gitHostName) {
      try {
        var gitHostInfo = gitHosts[gitHostName];
        var auth = null;
        if (parsed.auth && authProtocols[parsed.protocol]) {
          auth = parsed.auth;
        }
        var committish = parsed.hash ? decodeURIComponent(parsed.hash.substr(1)) : null;
        var user = null;
        var project = null;
        var defaultRepresentation = null;
        if (shortcutMatch && shortcutMatch[1] === gitHostName) {
          user = shortcutMatch[2] && decodeURIComponent(shortcutMatch[2]);
          project = decodeURIComponent(shortcutMatch[3].replace(/\.git$/, ""));
          defaultRepresentation = "shortcut";
        } else {
          if (parsed.host && parsed.host !== gitHostInfo.domain && parsed.host.replace(/^www[.]/, "") !== gitHostInfo.domain)
            return;
          if (!gitHostInfo.protocols_re.test(parsed.protocol))
            return;
          if (!parsed.path)
            return;
          var pathmatch = gitHostInfo.pathmatch;
          var matched = parsed.path.match(pathmatch);
          if (!matched)
            return;
          if (matched[1] !== null && matched[1] !== void 0) {
            user = decodeURIComponent(matched[1].replace(/^:/, ""));
          }
          project = decodeURIComponent(matched[2]);
          defaultRepresentation = protocolToRepresentation(parsed.protocol);
        }
        return new GitHost(gitHostName, user, auth, project, committish, defaultRepresentation, opts);
      } catch (ex) {
        if (ex instanceof URIError) {
        } else
          throw ex;
      }
    }).filter(function(gitHostInfo) {
      return gitHostInfo;
    });
    if (matches.length !== 1)
      return;
    return matches[0];
  }
  function isGitHubShorthand(arg2) {
    return /^[^:@%/\s.-][^:@%/\s]*[/][^:@\s/%]+(?:#.*)?$/.test(arg2);
  }
  function fixupUnqualifiedGist(giturl) {
    var parsed = url.parse(giturl);
    if (parsed.protocol === "gist:" && parsed.host && !parsed.path) {
      return parsed.protocol + "/" + parsed.host;
    } else {
      return giturl;
    }
  }
  function parseGitUrl(giturl) {
    var matched = giturl.match(/^([^@]+)@([^:/]+):[/]?((?:[^/]+[/])?[^/]+?)(?:[.]git)?(#.*)?$/);
    if (!matched) {
      var legacy = url.parse(giturl);
      if (legacy.auth && typeof url.URL === "function") {
        var authmatch = giturl.match(/[^@]+@[^:/]+/);
        if (authmatch) {
          var whatwg = new url.URL(authmatch[0]);
          legacy.auth = whatwg.username || "";
          if (whatwg.password)
            legacy.auth += ":" + whatwg.password;
        }
      }
      return legacy;
    }
    return {
      protocol: "git+ssh:",
      slashes: true,
      auth: matched[1],
      host: matched[2],
      port: null,
      hostname: matched[2],
      hash: matched[4],
      search: null,
      query: null,
      pathname: "/" + matched[3],
      path: "/" + matched[3],
      href: "git+ssh://" + matched[1] + "@" + matched[2] + "/" + matched[3] + (matched[4] || "")
    };
  }
});

// ../../node_modules/.pnpm/resolve@1.20.0/node_modules/resolve/lib/caller.js
var require_caller = __commonJS2((exports2, module2) => {
  module2.exports = function() {
    var origPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = function(_2, stack2) {
      return stack2;
    };
    var stack = new Error().stack;
    Error.prepareStackTrace = origPrepareStackTrace;
    return stack[2].getFileName();
  };
});

// ../../node_modules/.pnpm/path-parse@1.0.7/node_modules/path-parse/index.js
var require_path_parse = __commonJS2((exports2, module2) => {
  "use strict";
  var isWindows = process.platform === "win32";
  var splitWindowsRe = /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/;
  var win32 = {};
  function win32SplitPath(filename) {
    return splitWindowsRe.exec(filename).slice(1);
  }
  win32.parse = function(pathString) {
    if (typeof pathString !== "string") {
      throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
    }
    var allParts = win32SplitPath(pathString);
    if (!allParts || allParts.length !== 5) {
      throw new TypeError("Invalid path '" + pathString + "'");
    }
    return {
      root: allParts[1],
      dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
      base: allParts[2],
      ext: allParts[4],
      name: allParts[3]
    };
  };
  var splitPathRe = /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;
  var posix = {};
  function posixSplitPath(filename) {
    return splitPathRe.exec(filename).slice(1);
  }
  posix.parse = function(pathString) {
    if (typeof pathString !== "string") {
      throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
    }
    var allParts = posixSplitPath(pathString);
    if (!allParts || allParts.length !== 5) {
      throw new TypeError("Invalid path '" + pathString + "'");
    }
    return {
      root: allParts[1],
      dir: allParts[0].slice(0, -1),
      base: allParts[2],
      ext: allParts[4],
      name: allParts[3]
    };
  };
  if (isWindows)
    module2.exports = win32.parse;
  else
    module2.exports = posix.parse;
  module2.exports.posix = posix.parse;
  module2.exports.win32 = win32.parse;
});

// ../../node_modules/.pnpm/resolve@1.20.0/node_modules/resolve/lib/node-modules-paths.js
var require_node_modules_paths = __commonJS2((exports2, module2) => {
  var path4 = require("path");
  var parse2 = path4.parse || require_path_parse();
  var getNodeModulesDirs = function getNodeModulesDirs2(absoluteStart, modules) {
    var prefix = "/";
    if (/^([A-Za-z]:)/.test(absoluteStart)) {
      prefix = "";
    } else if (/^\\\\/.test(absoluteStart)) {
      prefix = "\\\\";
    }
    var paths = [absoluteStart];
    var parsed = parse2(absoluteStart);
    while (parsed.dir !== paths[paths.length - 1]) {
      paths.push(parsed.dir);
      parsed = parse2(parsed.dir);
    }
    return paths.reduce(function(dirs, aPath) {
      return dirs.concat(modules.map(function(moduleDir) {
        return path4.resolve(prefix, aPath, moduleDir);
      }));
    }, []);
  };
  module2.exports = function nodeModulesPaths(start, opts, request) {
    var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ["node_modules"];
    if (opts && typeof opts.paths === "function") {
      return opts.paths(request, start, function() {
        return getNodeModulesDirs(start, modules);
      }, opts);
    }
    var dirs = getNodeModulesDirs(start, modules);
    return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
  };
});

// ../../node_modules/.pnpm/resolve@1.20.0/node_modules/resolve/lib/normalize-options.js
var require_normalize_options = __commonJS2((exports2, module2) => {
  module2.exports = function(x, opts) {
    return opts || {};
  };
});

// ../../node_modules/.pnpm/function-bind@1.1.1/node_modules/function-bind/implementation.js
var require_implementation = __commonJS2((exports2, module2) => {
  "use strict";
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var slice = Array.prototype.slice;
  var toStr = Object.prototype.toString;
  var funcType = "[object Function]";
  module2.exports = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.call(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(this, args.concat(slice.call(arguments)));
        if (Object(result) === result) {
          return result;
        }
        return this;
      } else {
        return target.apply(that, args.concat(slice.call(arguments)));
      }
    };
    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
      boundArgs.push("$" + i);
    }
    bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
});

// ../../node_modules/.pnpm/function-bind@1.1.1/node_modules/function-bind/index.js
var require_function_bind = __commonJS2((exports2, module2) => {
  "use strict";
  var implementation = require_implementation();
  module2.exports = Function.prototype.bind || implementation;
});

// ../../node_modules/.pnpm/has@1.0.3/node_modules/has/src/index.js
var require_src4 = __commonJS2((exports2, module2) => {
  "use strict";
  var bind = require_function_bind();
  module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
});

// ../../node_modules/.pnpm/is-core-module@2.5.0/node_modules/is-core-module/core.json
var require_core3 = __commonJS2((exports2, module2) => {
  module2.exports = {
    assert: true,
    "node:assert": ">= 16",
    "assert/strict": ">= 15",
    "node:assert/strict": ">= 16",
    async_hooks: ">= 8",
    "node:async_hooks": ">= 16",
    buffer_ieee754: "< 0.9.7",
    buffer: true,
    "node:buffer": ">= 16",
    child_process: true,
    "node:child_process": ">= 16",
    cluster: true,
    "node:cluster": ">= 16",
    console: true,
    "node:console": ">= 16",
    constants: true,
    "node:constants": ">= 16",
    crypto: true,
    "node:crypto": ">= 16",
    _debug_agent: ">= 1 && < 8",
    _debugger: "< 8",
    dgram: true,
    "node:dgram": ">= 16",
    diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
    "node:diagnostics_channel": ">= 16",
    dns: true,
    "node:dns": ">= 16",
    "dns/promises": ">= 15",
    "node:dns/promises": ">= 16",
    domain: ">= 0.7.12",
    "node:domain": ">= 16",
    events: true,
    "node:events": ">= 16",
    freelist: "< 6",
    fs: true,
    "node:fs": ">= 16",
    "fs/promises": [">= 10 && < 10.1", ">= 14"],
    "node:fs/promises": ">= 16",
    _http_agent: ">= 0.11.1",
    "node:_http_agent": ">= 16",
    _http_client: ">= 0.11.1",
    "node:_http_client": ">= 16",
    _http_common: ">= 0.11.1",
    "node:_http_common": ">= 16",
    _http_incoming: ">= 0.11.1",
    "node:_http_incoming": ">= 16",
    _http_outgoing: ">= 0.11.1",
    "node:_http_outgoing": ">= 16",
    _http_server: ">= 0.11.1",
    "node:_http_server": ">= 16",
    http: true,
    "node:http": ">= 16",
    http2: ">= 8.8",
    "node:http2": ">= 16",
    https: true,
    "node:https": ">= 16",
    inspector: ">= 8",
    "node:inspector": ">= 16",
    _linklist: "< 8",
    module: true,
    "node:module": ">= 16",
    net: true,
    "node:net": ">= 16",
    "node-inspect/lib/_inspect": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
    os: true,
    "node:os": ">= 16",
    path: true,
    "node:path": ">= 16",
    "path/posix": ">= 15.3",
    "node:path/posix": ">= 16",
    "path/win32": ">= 15.3",
    "node:path/win32": ">= 16",
    perf_hooks: ">= 8.5",
    "node:perf_hooks": ">= 16",
    process: ">= 1",
    "node:process": ">= 16",
    punycode: true,
    "node:punycode": ">= 16",
    querystring: true,
    "node:querystring": ">= 16",
    readline: true,
    "node:readline": ">= 16",
    repl: true,
    "node:repl": ">= 16",
    smalloc: ">= 0.11.5 && < 3",
    _stream_duplex: ">= 0.9.4",
    "node:_stream_duplex": ">= 16",
    _stream_transform: ">= 0.9.4",
    "node:_stream_transform": ">= 16",
    _stream_wrap: ">= 1.4.1",
    "node:_stream_wrap": ">= 16",
    _stream_passthrough: ">= 0.9.4",
    "node:_stream_passthrough": ">= 16",
    _stream_readable: ">= 0.9.4",
    "node:_stream_readable": ">= 16",
    _stream_writable: ">= 0.9.4",
    "node:_stream_writable": ">= 16",
    stream: true,
    "node:stream": ">= 16",
    "stream/promises": ">= 15",
    "node:stream/promises": ">= 16",
    "stream/web": ">= 16.5",
    "node:stream/web": ">= 16.5",
    string_decoder: true,
    "node:string_decoder": ">= 16",
    sys: [">= 0.6 && < 0.7", ">= 0.8"],
    "node:sys": ">= 16",
    timers: true,
    "node:timers": ">= 16",
    "timers/promises": ">= 15",
    "node:timers/promises": ">= 16",
    _tls_common: ">= 0.11.13",
    "node:_tls_common": ">= 16",
    _tls_legacy: ">= 0.11.3 && < 10",
    _tls_wrap: ">= 0.11.3",
    "node:_tls_wrap": ">= 16",
    tls: true,
    "node:tls": ">= 16",
    trace_events: ">= 10",
    "node:trace_events": ">= 16",
    tty: true,
    "node:tty": ">= 16",
    url: true,
    "node:url": ">= 16",
    util: true,
    "node:util": ">= 16",
    "util/types": ">= 15.3",
    "node:util/types": ">= 16",
    "v8/tools/arguments": ">= 10 && < 12",
    "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    v8: ">= 1",
    "node:v8": ">= 16",
    vm: true,
    "node:vm": ">= 16",
    wasi: ">= 13.4 && < 13.5",
    worker_threads: ">= 11.7",
    "node:worker_threads": ">= 16",
    zlib: true,
    "node:zlib": ">= 16"
  };
});

// ../../node_modules/.pnpm/is-core-module@2.5.0/node_modules/is-core-module/index.js
var require_is_core_module = __commonJS2((exports2, module2) => {
  "use strict";
  var has = require_src4();
  function specifierIncluded(current, specifier) {
    var nodeParts = current.split(".");
    var parts = specifier.split(" ");
    var op = parts.length > 1 ? parts[0] : "=";
    var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
    for (var i = 0; i < 3; ++i) {
      var cur = parseInt(nodeParts[i] || 0, 10);
      var ver = parseInt(versionParts[i] || 0, 10);
      if (cur === ver) {
        continue;
      }
      if (op === "<") {
        return cur < ver;
      }
      if (op === ">=") {
        return cur >= ver;
      }
      return false;
    }
    return op === ">=";
  }
  function matchesRange(current, range) {
    var specifiers = range.split(/ ?&& ?/);
    if (specifiers.length === 0) {
      return false;
    }
    for (var i = 0; i < specifiers.length; ++i) {
      if (!specifierIncluded(current, specifiers[i])) {
        return false;
      }
    }
    return true;
  }
  function versionIncluded(nodeVersion, specifierValue) {
    if (typeof specifierValue === "boolean") {
      return specifierValue;
    }
    var current = typeof nodeVersion === "undefined" ? process.versions && process.versions.node && process.versions.node : nodeVersion;
    if (typeof current !== "string") {
      throw new TypeError(typeof nodeVersion === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");
    }
    if (specifierValue && typeof specifierValue === "object") {
      for (var i = 0; i < specifierValue.length; ++i) {
        if (matchesRange(current, specifierValue[i])) {
          return true;
        }
      }
      return false;
    }
    return matchesRange(current, specifierValue);
  }
  var data = require_core3();
  module2.exports = function isCore(x, nodeVersion) {
    return has(data, x) && versionIncluded(nodeVersion, data[x]);
  };
});

// ../../node_modules/.pnpm/resolve@1.20.0/node_modules/resolve/lib/async.js
var require_async6 = __commonJS2((exports2, module2) => {
  var fs2 = require("fs");
  var path4 = require("path");
  var caller = require_caller();
  var nodeModulesPaths = require_node_modules_paths();
  var normalizeOptions = require_normalize_options();
  var isCore = require_is_core_module();
  var realpathFS = fs2.realpath && typeof fs2.realpath.native === "function" ? fs2.realpath.native : fs2.realpath;
  var defaultIsFile = function isFile(file, cb) {
    fs2.stat(file, function(err, stat2) {
      if (!err) {
        return cb(null, stat2.isFile() || stat2.isFIFO());
      }
      if (err.code === "ENOENT" || err.code === "ENOTDIR")
        return cb(null, false);
      return cb(err);
    });
  };
  var defaultIsDir = function isDirectory(dir, cb) {
    fs2.stat(dir, function(err, stat2) {
      if (!err) {
        return cb(null, stat2.isDirectory());
      }
      if (err.code === "ENOENT" || err.code === "ENOTDIR")
        return cb(null, false);
      return cb(err);
    });
  };
  var defaultRealpath = function realpath(x, cb) {
    realpathFS(x, function(realpathErr, realPath) {
      if (realpathErr && realpathErr.code !== "ENOENT")
        cb(realpathErr);
      else
        cb(null, realpathErr ? x : realPath);
    });
  };
  var maybeRealpath = function maybeRealpath2(realpath, x, opts, cb) {
    if (opts && opts.preserveSymlinks === false) {
      realpath(x, cb);
    } else {
      cb(null, x);
    }
  };
  var defaultReadPackage = function defaultReadPackage2(readFile2, pkgfile, cb) {
    readFile2(pkgfile, function(readFileErr, body) {
      if (readFileErr)
        cb(readFileErr);
      else {
        try {
          var pkg2 = JSON.parse(body);
          cb(null, pkg2);
        } catch (jsonErr) {
          cb(null);
        }
      }
    });
  };
  var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0; i < dirs.length; i++) {
      dirs[i] = path4.join(dirs[i], x);
    }
    return dirs;
  };
  module2.exports = function resolve(x, options, callback) {
    var cb = callback;
    var opts = options;
    if (typeof options === "function") {
      cb = opts;
      opts = {};
    }
    if (typeof x !== "string") {
      var err = new TypeError("Path must be a string.");
      return process.nextTick(function() {
        cb(err);
      });
    }
    opts = normalizeOptions(x, opts);
    var isFile = opts.isFile || defaultIsFile;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var readFile2 = opts.readFile || fs2.readFile;
    var realpath = opts.realpath || defaultRealpath;
    var readPackage = opts.readPackage || defaultReadPackage;
    if (opts.readFile && opts.readPackage) {
      var conflictErr = new TypeError("`readFile` and `readPackage` are mutually exclusive.");
      return process.nextTick(function() {
        cb(conflictErr);
      });
    }
    var packageIterator = opts.packageIterator;
    var extensions = opts.extensions || [".js"];
    var includeCoreModules = opts.includeCoreModules !== false;
    var basedir = opts.basedir || path4.dirname(caller());
    var parent = opts.filename || basedir;
    opts.paths = opts.paths || [];
    var absoluteStart = path4.resolve(basedir);
    maybeRealpath(realpath, absoluteStart, opts, function(err2, realStart) {
      if (err2)
        cb(err2);
      else
        init(realStart);
    });
    var res;
    function init(basedir2) {
      if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
        res = path4.resolve(basedir2, x);
        if (x === "." || x === ".." || x.slice(-1) === "/")
          res += "/";
        if (/\/$/.test(x) && res === basedir2) {
          loadAsDirectory(res, opts.package, onfile);
        } else
          loadAsFile(res, opts.package, onfile);
      } else if (includeCoreModules && isCore(x)) {
        return cb(null, x);
      } else
        loadNodeModules(x, basedir2, function(err2, n, pkg2) {
          if (err2)
            cb(err2);
          else if (n) {
            return maybeRealpath(realpath, n, opts, function(err3, realN) {
              if (err3) {
                cb(err3);
              } else {
                cb(null, realN, pkg2);
              }
            });
          } else {
            var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
            moduleError.code = "MODULE_NOT_FOUND";
            cb(moduleError);
          }
        });
    }
    function onfile(err2, m2, pkg2) {
      if (err2)
        cb(err2);
      else if (m2)
        cb(null, m2, pkg2);
      else
        loadAsDirectory(res, function(err3, d2, pkg3) {
          if (err3)
            cb(err3);
          else if (d2) {
            maybeRealpath(realpath, d2, opts, function(err4, realD) {
              if (err4) {
                cb(err4);
              } else {
                cb(null, realD, pkg3);
              }
            });
          } else {
            var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
            moduleError.code = "MODULE_NOT_FOUND";
            cb(moduleError);
          }
        });
    }
    function loadAsFile(x2, thePackage, callback2) {
      var loadAsFilePackage = thePackage;
      var cb2 = callback2;
      if (typeof loadAsFilePackage === "function") {
        cb2 = loadAsFilePackage;
        loadAsFilePackage = void 0;
      }
      var exts = [""].concat(extensions);
      load2(exts, x2, loadAsFilePackage);
      function load2(exts2, x3, loadPackage) {
        if (exts2.length === 0)
          return cb2(null, void 0, loadPackage);
        var file = x3 + exts2[0];
        var pkg2 = loadPackage;
        if (pkg2)
          onpkg(null, pkg2);
        else
          loadpkg(path4.dirname(file), onpkg);
        function onpkg(err2, pkg_, dir) {
          pkg2 = pkg_;
          if (err2)
            return cb2(err2);
          if (dir && pkg2 && opts.pathFilter) {
            var rfile = path4.relative(dir, file);
            var rel = rfile.slice(0, rfile.length - exts2[0].length);
            var r = opts.pathFilter(pkg2, x3, rel);
            if (r)
              return load2([""].concat(extensions.slice()), path4.resolve(dir, r), pkg2);
          }
          isFile(file, onex);
        }
        function onex(err2, ex) {
          if (err2)
            return cb2(err2);
          if (ex)
            return cb2(null, file, pkg2);
          load2(exts2.slice(1), x3, pkg2);
        }
      }
    }
    function loadpkg(dir, cb2) {
      if (dir === "" || dir === "/")
        return cb2(null);
      if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
        return cb2(null);
      }
      if (/[/\\]node_modules[/\\]*$/.test(dir))
        return cb2(null);
      maybeRealpath(realpath, dir, opts, function(unwrapErr, pkgdir) {
        if (unwrapErr)
          return loadpkg(path4.dirname(dir), cb2);
        var pkgfile = path4.join(pkgdir, "package.json");
        isFile(pkgfile, function(err2, ex) {
          if (!ex)
            return loadpkg(path4.dirname(dir), cb2);
          readPackage(readFile2, pkgfile, function(err3, pkgParam) {
            if (err3)
              cb2(err3);
            var pkg2 = pkgParam;
            if (pkg2 && opts.packageFilter) {
              pkg2 = opts.packageFilter(pkg2, pkgfile);
            }
            cb2(null, pkg2, dir);
          });
        });
      });
    }
    function loadAsDirectory(x2, loadAsDirectoryPackage, callback2) {
      var cb2 = callback2;
      var fpkg = loadAsDirectoryPackage;
      if (typeof fpkg === "function") {
        cb2 = fpkg;
        fpkg = opts.package;
      }
      maybeRealpath(realpath, x2, opts, function(unwrapErr, pkgdir) {
        if (unwrapErr)
          return cb2(unwrapErr);
        var pkgfile = path4.join(pkgdir, "package.json");
        isFile(pkgfile, function(err2, ex) {
          if (err2)
            return cb2(err2);
          if (!ex)
            return loadAsFile(path4.join(x2, "index"), fpkg, cb2);
          readPackage(readFile2, pkgfile, function(err3, pkgParam) {
            if (err3)
              return cb2(err3);
            var pkg2 = pkgParam;
            if (pkg2 && opts.packageFilter) {
              pkg2 = opts.packageFilter(pkg2, pkgfile);
            }
            if (pkg2 && pkg2.main) {
              if (typeof pkg2.main !== "string") {
                var mainError = new TypeError("package \u201C" + pkg2.name + "\u201D `main` must be a string");
                mainError.code = "INVALID_PACKAGE_MAIN";
                return cb2(mainError);
              }
              if (pkg2.main === "." || pkg2.main === "./") {
                pkg2.main = "index";
              }
              loadAsFile(path4.resolve(x2, pkg2.main), pkg2, function(err4, m2, pkg3) {
                if (err4)
                  return cb2(err4);
                if (m2)
                  return cb2(null, m2, pkg3);
                if (!pkg3)
                  return loadAsFile(path4.join(x2, "index"), pkg3, cb2);
                var dir = path4.resolve(x2, pkg3.main);
                loadAsDirectory(dir, pkg3, function(err5, n, pkg4) {
                  if (err5)
                    return cb2(err5);
                  if (n)
                    return cb2(null, n, pkg4);
                  loadAsFile(path4.join(x2, "index"), pkg4, cb2);
                });
              });
              return;
            }
            loadAsFile(path4.join(x2, "/index"), pkg2, cb2);
          });
        });
      });
    }
    function processDirs(cb2, dirs) {
      if (dirs.length === 0)
        return cb2(null, void 0);
      var dir = dirs[0];
      isDirectory(path4.dirname(dir), isdir);
      function isdir(err2, isdir2) {
        if (err2)
          return cb2(err2);
        if (!isdir2)
          return processDirs(cb2, dirs.slice(1));
        loadAsFile(dir, opts.package, onfile2);
      }
      function onfile2(err2, m2, pkg2) {
        if (err2)
          return cb2(err2);
        if (m2)
          return cb2(null, m2, pkg2);
        loadAsDirectory(dir, opts.package, ondir);
      }
      function ondir(err2, n, pkg2) {
        if (err2)
          return cb2(err2);
        if (n)
          return cb2(null, n, pkg2);
        processDirs(cb2, dirs.slice(1));
      }
    }
    function loadNodeModules(x2, start, cb2) {
      var thunk = function() {
        return getPackageCandidates(x2, start, opts);
      };
      processDirs(cb2, packageIterator ? packageIterator(x2, start, thunk, opts) : thunk());
    }
  };
});

// ../../node_modules/.pnpm/resolve@1.20.0/node_modules/resolve/lib/core.json
var require_core4 = __commonJS2((exports2, module2) => {
  module2.exports = {
    assert: true,
    "assert/strict": ">= 15",
    async_hooks: ">= 8",
    buffer_ieee754: "< 0.9.7",
    buffer: true,
    child_process: true,
    cluster: true,
    console: true,
    constants: true,
    crypto: true,
    _debug_agent: ">= 1 && < 8",
    _debugger: "< 8",
    dgram: true,
    diagnostics_channel: ">= 15.1",
    dns: true,
    "dns/promises": ">= 15",
    domain: ">= 0.7.12",
    events: true,
    freelist: "< 6",
    fs: true,
    "fs/promises": [">= 10 && < 10.1", ">= 14"],
    _http_agent: ">= 0.11.1",
    _http_client: ">= 0.11.1",
    _http_common: ">= 0.11.1",
    _http_incoming: ">= 0.11.1",
    _http_outgoing: ">= 0.11.1",
    _http_server: ">= 0.11.1",
    http: true,
    http2: ">= 8.8",
    https: true,
    inspector: ">= 8.0.0",
    _linklist: "< 8",
    module: true,
    net: true,
    "node-inspect/lib/_inspect": ">= 7.6.0 && < 12",
    "node-inspect/lib/internal/inspect_client": ">= 7.6.0 && < 12",
    "node-inspect/lib/internal/inspect_repl": ">= 7.6.0 && < 12",
    os: true,
    path: true,
    "path/posix": ">= 15.3",
    "path/win32": ">= 15.3",
    perf_hooks: ">= 8.5",
    process: ">= 1",
    punycode: true,
    querystring: true,
    readline: true,
    repl: true,
    smalloc: ">= 0.11.5 && < 3",
    _stream_duplex: ">= 0.9.4",
    _stream_transform: ">= 0.9.4",
    _stream_wrap: ">= 1.4.1",
    _stream_passthrough: ">= 0.9.4",
    _stream_readable: ">= 0.9.4",
    _stream_writable: ">= 0.9.4",
    stream: true,
    "stream/promises": ">= 15",
    string_decoder: true,
    sys: [">= 0.6 && < 0.7", ">= 0.8"],
    timers: true,
    "timers/promises": ">= 15",
    _tls_common: ">= 0.11.13",
    _tls_legacy: ">= 0.11.3 && < 10",
    _tls_wrap: ">= 0.11.3",
    tls: true,
    trace_events: ">= 10",
    tty: true,
    url: true,
    util: true,
    "util/types": ">= 15.3",
    "v8/tools/arguments": ">= 10 && < 12",
    "v8/tools/codemap": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    "v8/tools/consarray": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    "v8/tools/csvparser": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    "v8/tools/logreader": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    "v8/tools/profile_view": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    "v8/tools/splaytree": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    v8: ">= 1",
    vm: true,
    wasi: ">= 13.4 && < 13.5",
    worker_threads: ">= 11.7",
    zlib: true
  };
});

// ../../node_modules/.pnpm/resolve@1.20.0/node_modules/resolve/lib/core.js
var require_core5 = __commonJS2((exports2, module2) => {
  var current = process.versions && process.versions.node && process.versions.node.split(".") || [];
  function specifierIncluded(specifier) {
    var parts = specifier.split(" ");
    var op = parts.length > 1 ? parts[0] : "=";
    var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
    for (var i = 0; i < 3; ++i) {
      var cur = parseInt(current[i] || 0, 10);
      var ver = parseInt(versionParts[i] || 0, 10);
      if (cur === ver) {
        continue;
      }
      if (op === "<") {
        return cur < ver;
      } else if (op === ">=") {
        return cur >= ver;
      } else {
        return false;
      }
    }
    return op === ">=";
  }
  function matchesRange(range) {
    var specifiers = range.split(/ ?&& ?/);
    if (specifiers.length === 0) {
      return false;
    }
    for (var i = 0; i < specifiers.length; ++i) {
      if (!specifierIncluded(specifiers[i])) {
        return false;
      }
    }
    return true;
  }
  function versionIncluded(specifierValue) {
    if (typeof specifierValue === "boolean") {
      return specifierValue;
    }
    if (specifierValue && typeof specifierValue === "object") {
      for (var i = 0; i < specifierValue.length; ++i) {
        if (matchesRange(specifierValue[i])) {
          return true;
        }
      }
      return false;
    }
    return matchesRange(specifierValue);
  }
  var data = require_core4();
  var core = {};
  for (var mod2 in data) {
    if (Object.prototype.hasOwnProperty.call(data, mod2)) {
      core[mod2] = versionIncluded(data[mod2]);
    }
  }
  module2.exports = core;
});

// ../../node_modules/.pnpm/resolve@1.20.0/node_modules/resolve/lib/is-core.js
var require_is_core = __commonJS2((exports2, module2) => {
  var isCoreModule = require_is_core_module();
  module2.exports = function isCore(x) {
    return isCoreModule(x);
  };
});

// ../../node_modules/.pnpm/resolve@1.20.0/node_modules/resolve/lib/sync.js
var require_sync8 = __commonJS2((exports2, module2) => {
  var isCore = require_is_core_module();
  var fs2 = require("fs");
  var path4 = require("path");
  var caller = require_caller();
  var nodeModulesPaths = require_node_modules_paths();
  var normalizeOptions = require_normalize_options();
  var realpathFS = fs2.realpathSync && typeof fs2.realpathSync.native === "function" ? fs2.realpathSync.native : fs2.realpathSync;
  var defaultIsFile = function isFile(file) {
    try {
      var stat2 = fs2.statSync(file);
    } catch (e) {
      if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
        return false;
      throw e;
    }
    return stat2.isFile() || stat2.isFIFO();
  };
  var defaultIsDir = function isDirectory(dir) {
    try {
      var stat2 = fs2.statSync(dir);
    } catch (e) {
      if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
        return false;
      throw e;
    }
    return stat2.isDirectory();
  };
  var defaultRealpathSync = function realpathSync(x) {
    try {
      return realpathFS(x);
    } catch (realpathErr) {
      if (realpathErr.code !== "ENOENT") {
        throw realpathErr;
      }
    }
    return x;
  };
  var maybeRealpathSync = function maybeRealpathSync2(realpathSync, x, opts) {
    if (opts && opts.preserveSymlinks === false) {
      return realpathSync(x);
    }
    return x;
  };
  var defaultReadPackageSync = function defaultReadPackageSync2(readFileSync, pkgfile) {
    var body = readFileSync(pkgfile);
    try {
      var pkg2 = JSON.parse(body);
      return pkg2;
    } catch (jsonErr) {
    }
  };
  var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0; i < dirs.length; i++) {
      dirs[i] = path4.join(dirs[i], x);
    }
    return dirs;
  };
  module2.exports = function resolveSync(x, options) {
    if (typeof x !== "string") {
      throw new TypeError("Path must be a string.");
    }
    var opts = normalizeOptions(x, options);
    var isFile = opts.isFile || defaultIsFile;
    var readFileSync = opts.readFileSync || fs2.readFileSync;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var realpathSync = opts.realpathSync || defaultRealpathSync;
    var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
    if (opts.readFileSync && opts.readPackageSync) {
      throw new TypeError("`readFileSync` and `readPackageSync` are mutually exclusive.");
    }
    var packageIterator = opts.packageIterator;
    var extensions = opts.extensions || [".js"];
    var includeCoreModules = opts.includeCoreModules !== false;
    var basedir = opts.basedir || path4.dirname(caller());
    var parent = opts.filename || basedir;
    opts.paths = opts.paths || [];
    var absoluteStart = maybeRealpathSync(realpathSync, path4.resolve(basedir), opts);
    if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
      var res = path4.resolve(absoluteStart, x);
      if (x === "." || x === ".." || x.slice(-1) === "/")
        res += "/";
      var m2 = loadAsFileSync(res) || loadAsDirectorySync(res);
      if (m2)
        return maybeRealpathSync(realpathSync, m2, opts);
    } else if (includeCoreModules && isCore(x)) {
      return x;
    } else {
      var n = loadNodeModulesSync(x, absoluteStart);
      if (n)
        return maybeRealpathSync(realpathSync, n, opts);
    }
    var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
    err.code = "MODULE_NOT_FOUND";
    throw err;
    function loadAsFileSync(x2) {
      var pkg2 = loadpkg(path4.dirname(x2));
      if (pkg2 && pkg2.dir && pkg2.pkg && opts.pathFilter) {
        var rfile = path4.relative(pkg2.dir, x2);
        var r = opts.pathFilter(pkg2.pkg, x2, rfile);
        if (r) {
          x2 = path4.resolve(pkg2.dir, r);
        }
      }
      if (isFile(x2)) {
        return x2;
      }
      for (var i = 0; i < extensions.length; i++) {
        var file = x2 + extensions[i];
        if (isFile(file)) {
          return file;
        }
      }
    }
    function loadpkg(dir) {
      if (dir === "" || dir === "/")
        return;
      if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
        return;
      }
      if (/[/\\]node_modules[/\\]*$/.test(dir))
        return;
      var pkgfile = path4.join(maybeRealpathSync(realpathSync, dir, opts), "package.json");
      if (!isFile(pkgfile)) {
        return loadpkg(path4.dirname(dir));
      }
      var pkg2 = readPackageSync(readFileSync, pkgfile);
      if (pkg2 && opts.packageFilter) {
        pkg2 = opts.packageFilter(pkg2, dir);
      }
      return {pkg: pkg2, dir};
    }
    function loadAsDirectorySync(x2) {
      var pkgfile = path4.join(maybeRealpathSync(realpathSync, x2, opts), "/package.json");
      if (isFile(pkgfile)) {
        try {
          var pkg2 = readPackageSync(readFileSync, pkgfile);
        } catch (e) {
        }
        if (pkg2 && opts.packageFilter) {
          pkg2 = opts.packageFilter(pkg2, x2);
        }
        if (pkg2 && pkg2.main) {
          if (typeof pkg2.main !== "string") {
            var mainError = new TypeError("package \u201C" + pkg2.name + "\u201D `main` must be a string");
            mainError.code = "INVALID_PACKAGE_MAIN";
            throw mainError;
          }
          if (pkg2.main === "." || pkg2.main === "./") {
            pkg2.main = "index";
          }
          try {
            var m3 = loadAsFileSync(path4.resolve(x2, pkg2.main));
            if (m3)
              return m3;
            var n2 = loadAsDirectorySync(path4.resolve(x2, pkg2.main));
            if (n2)
              return n2;
          } catch (e) {
          }
        }
      }
      return loadAsFileSync(path4.join(x2, "/index"));
    }
    function loadNodeModulesSync(x2, start) {
      var thunk = function() {
        return getPackageCandidates(x2, start, opts);
      };
      var dirs = packageIterator ? packageIterator(x2, start, thunk, opts) : thunk();
      for (var i = 0; i < dirs.length; i++) {
        var dir = dirs[i];
        if (isDirectory(path4.dirname(dir))) {
          var m3 = loadAsFileSync(dir);
          if (m3)
            return m3;
          var n2 = loadAsDirectorySync(dir);
          if (n2)
            return n2;
        }
      }
    }
  };
});

// ../../node_modules/.pnpm/resolve@1.20.0/node_modules/resolve/index.js
var require_resolve = __commonJS2((exports2, module2) => {
  var async = require_async6();
  async.core = require_core5();
  async.isCore = require_is_core();
  async.sync = require_sync8();
  module2.exports = async;
});

// ../../node_modules/.pnpm/normalize-package-data@2.5.0/node_modules/normalize-package-data/lib/extract_description.js
var require_extract_description = __commonJS2((exports2, module2) => {
  module2.exports = extractDescription;
  function extractDescription(d2) {
    if (!d2)
      return;
    if (d2 === "ERROR: No README data found!")
      return;
    d2 = d2.trim().split("\n");
    for (var s2 = 0; d2[s2] && d2[s2].trim().match(/^(#|$)/); s2++)
      ;
    var l = d2.length;
    for (var e = s2 + 1; e < l && d2[e].trim(); e++)
      ;
    return d2.slice(s2, e).join(" ").trim();
  }
});

// ../../node_modules/.pnpm/normalize-package-data@2.5.0/node_modules/normalize-package-data/lib/typos.json
var require_typos = __commonJS2((exports2, module2) => {
  module2.exports = {
    topLevel: {
      dependancies: "dependencies",
      dependecies: "dependencies",
      depdenencies: "dependencies",
      devEependencies: "devDependencies",
      depends: "dependencies",
      "dev-dependencies": "devDependencies",
      devDependences: "devDependencies",
      devDepenencies: "devDependencies",
      devdependencies: "devDependencies",
      repostitory: "repository",
      repo: "repository",
      prefereGlobal: "preferGlobal",
      hompage: "homepage",
      hampage: "homepage",
      autohr: "author",
      autor: "author",
      contributers: "contributors",
      publicationConfig: "publishConfig",
      script: "scripts"
    },
    bugs: {web: "url", name: "url"},
    script: {server: "start", tests: "test"}
  };
});

// ../../node_modules/.pnpm/normalize-package-data@2.5.0/node_modules/normalize-package-data/lib/fixer.js
var require_fixer = __commonJS2((exports2, module2) => {
  var semver2 = require_semver3();
  var validateLicense = require_validate_npm_package_license();
  var hostedGitInfo = require_hosted_git_info();
  var isBuiltinModule = require_resolve().isCore;
  var depTypes = ["dependencies", "devDependencies", "optionalDependencies"];
  var extractDescription = require_extract_description();
  var url = require("url");
  var typos = require_typos();
  var fixer = module2.exports = {
    warn: function() {
    },
    fixRepositoryField: function(data) {
      if (data.repositories) {
        this.warn("repositories");
        data.repository = data.repositories[0];
      }
      if (!data.repository)
        return this.warn("missingRepository");
      if (typeof data.repository === "string") {
        data.repository = {
          type: "git",
          url: data.repository
        };
      }
      var r = data.repository.url || "";
      if (r) {
        var hosted = hostedGitInfo.fromUrl(r);
        if (hosted) {
          r = data.repository.url = hosted.getDefaultRepresentation() == "shortcut" ? hosted.https() : hosted.toString();
        }
      }
      if (r.match(/github.com\/[^\/]+\/[^\/]+\.git\.git$/)) {
        this.warn("brokenGitUrl", r);
      }
    },
    fixTypos: function(data) {
      Object.keys(typos.topLevel).forEach(function(d2) {
        if (data.hasOwnProperty(d2)) {
          this.warn("typo", d2, typos.topLevel[d2]);
        }
      }, this);
    },
    fixScriptsField: function(data) {
      if (!data.scripts)
        return;
      if (typeof data.scripts !== "object") {
        this.warn("nonObjectScripts");
        delete data.scripts;
        return;
      }
      Object.keys(data.scripts).forEach(function(k) {
        if (typeof data.scripts[k] !== "string") {
          this.warn("nonStringScript");
          delete data.scripts[k];
        } else if (typos.script[k] && !data.scripts[typos.script[k]]) {
          this.warn("typo", k, typos.script[k], "scripts");
        }
      }, this);
    },
    fixFilesField: function(data) {
      var files = data.files;
      if (files && !Array.isArray(files)) {
        this.warn("nonArrayFiles");
        delete data.files;
      } else if (data.files) {
        data.files = data.files.filter(function(file) {
          if (!file || typeof file !== "string") {
            this.warn("invalidFilename", file);
            return false;
          } else {
            return true;
          }
        }, this);
      }
    },
    fixBinField: function(data) {
      if (!data.bin)
        return;
      if (typeof data.bin === "string") {
        var b = {};
        var match;
        if (match = data.name.match(/^@[^/]+[/](.*)$/)) {
          b[match[1]] = data.bin;
        } else {
          b[data.name] = data.bin;
        }
        data.bin = b;
      }
    },
    fixManField: function(data) {
      if (!data.man)
        return;
      if (typeof data.man === "string") {
        data.man = [data.man];
      }
    },
    fixBundleDependenciesField: function(data) {
      var bdd = "bundledDependencies";
      var bd = "bundleDependencies";
      if (data[bdd] && !data[bd]) {
        data[bd] = data[bdd];
        delete data[bdd];
      }
      if (data[bd] && !Array.isArray(data[bd])) {
        this.warn("nonArrayBundleDependencies");
        delete data[bd];
      } else if (data[bd]) {
        data[bd] = data[bd].filter(function(bd2) {
          if (!bd2 || typeof bd2 !== "string") {
            this.warn("nonStringBundleDependency", bd2);
            return false;
          } else {
            if (!data.dependencies) {
              data.dependencies = {};
            }
            if (!data.dependencies.hasOwnProperty(bd2)) {
              this.warn("nonDependencyBundleDependency", bd2);
              data.dependencies[bd2] = "*";
            }
            return true;
          }
        }, this);
      }
    },
    fixDependencies: function(data, strict) {
      var loose = !strict;
      objectifyDeps(data, this.warn);
      addOptionalDepsToDeps(data, this.warn);
      this.fixBundleDependenciesField(data);
      ["dependencies", "devDependencies"].forEach(function(deps) {
        if (!(deps in data))
          return;
        if (!data[deps] || typeof data[deps] !== "object") {
          this.warn("nonObjectDependencies", deps);
          delete data[deps];
          return;
        }
        Object.keys(data[deps]).forEach(function(d2) {
          var r = data[deps][d2];
          if (typeof r !== "string") {
            this.warn("nonStringDependency", d2, JSON.stringify(r));
            delete data[deps][d2];
          }
          var hosted = hostedGitInfo.fromUrl(data[deps][d2]);
          if (hosted)
            data[deps][d2] = hosted.toString();
        }, this);
      }, this);
    },
    fixModulesField: function(data) {
      if (data.modules) {
        this.warn("deprecatedModules");
        delete data.modules;
      }
    },
    fixKeywordsField: function(data) {
      if (typeof data.keywords === "string") {
        data.keywords = data.keywords.split(/,\s+/);
      }
      if (data.keywords && !Array.isArray(data.keywords)) {
        delete data.keywords;
        this.warn("nonArrayKeywords");
      } else if (data.keywords) {
        data.keywords = data.keywords.filter(function(kw) {
          if (typeof kw !== "string" || !kw) {
            this.warn("nonStringKeyword");
            return false;
          } else {
            return true;
          }
        }, this);
      }
    },
    fixVersionField: function(data, strict) {
      var loose = !strict;
      if (!data.version) {
        data.version = "";
        return true;
      }
      if (!semver2.valid(data.version, loose)) {
        throw new Error('Invalid version: "' + data.version + '"');
      }
      data.version = semver2.clean(data.version, loose);
      return true;
    },
    fixPeople: function(data) {
      modifyPeople(data, unParsePerson);
      modifyPeople(data, parsePerson);
    },
    fixNameField: function(data, options) {
      if (typeof options === "boolean")
        options = {strict: options};
      else if (typeof options === "undefined")
        options = {};
      var strict = options.strict;
      if (!data.name && !strict) {
        data.name = "";
        return;
      }
      if (typeof data.name !== "string") {
        throw new Error("name field must be a string.");
      }
      if (!strict)
        data.name = data.name.trim();
      ensureValidName(data.name, strict, options.allowLegacyCase);
      if (isBuiltinModule(data.name))
        this.warn("conflictingName", data.name);
    },
    fixDescriptionField: function(data) {
      if (data.description && typeof data.description !== "string") {
        this.warn("nonStringDescription");
        delete data.description;
      }
      if (data.readme && !data.description)
        data.description = extractDescription(data.readme);
      if (data.description === void 0)
        delete data.description;
      if (!data.description)
        this.warn("missingDescription");
    },
    fixReadmeField: function(data) {
      if (!data.readme) {
        this.warn("missingReadme");
        data.readme = "ERROR: No README data found!";
      }
    },
    fixBugsField: function(data) {
      if (!data.bugs && data.repository && data.repository.url) {
        var hosted = hostedGitInfo.fromUrl(data.repository.url);
        if (hosted && hosted.bugs()) {
          data.bugs = {url: hosted.bugs()};
        }
      } else if (data.bugs) {
        var emailRe = /^.+@.*\..+$/;
        if (typeof data.bugs == "string") {
          if (emailRe.test(data.bugs))
            data.bugs = {email: data.bugs};
          else if (url.parse(data.bugs).protocol)
            data.bugs = {url: data.bugs};
          else
            this.warn("nonEmailUrlBugsString");
        } else {
          bugsTypos(data.bugs, this.warn);
          var oldBugs = data.bugs;
          data.bugs = {};
          if (oldBugs.url) {
            if (typeof oldBugs.url == "string" && url.parse(oldBugs.url).protocol)
              data.bugs.url = oldBugs.url;
            else
              this.warn("nonUrlBugsUrlField");
          }
          if (oldBugs.email) {
            if (typeof oldBugs.email == "string" && emailRe.test(oldBugs.email))
              data.bugs.email = oldBugs.email;
            else
              this.warn("nonEmailBugsEmailField");
          }
        }
        if (!data.bugs.email && !data.bugs.url) {
          delete data.bugs;
          this.warn("emptyNormalizedBugs");
        }
      }
    },
    fixHomepageField: function(data) {
      if (!data.homepage && data.repository && data.repository.url) {
        var hosted = hostedGitInfo.fromUrl(data.repository.url);
        if (hosted && hosted.docs())
          data.homepage = hosted.docs();
      }
      if (!data.homepage)
        return;
      if (typeof data.homepage !== "string") {
        this.warn("nonUrlHomepage");
        return delete data.homepage;
      }
      if (!url.parse(data.homepage).protocol) {
        data.homepage = "http://" + data.homepage;
      }
    },
    fixLicenseField: function(data) {
      if (!data.license) {
        return this.warn("missingLicense");
      } else {
        if (typeof data.license !== "string" || data.license.length < 1 || data.license.trim() === "") {
          this.warn("invalidLicense");
        } else {
          if (!validateLicense(data.license).validForNewPackages)
            this.warn("invalidLicense");
        }
      }
    }
  };
  function isValidScopedPackageName(spec) {
    if (spec.charAt(0) !== "@")
      return false;
    var rest = spec.slice(1).split("/");
    if (rest.length !== 2)
      return false;
    return rest[0] && rest[1] && rest[0] === encodeURIComponent(rest[0]) && rest[1] === encodeURIComponent(rest[1]);
  }
  function isCorrectlyEncodedName(spec) {
    return !spec.match(/[\/@\s\+%:]/) && spec === encodeURIComponent(spec);
  }
  function ensureValidName(name, strict, allowLegacyCase) {
    if (name.charAt(0) === "." || !(isValidScopedPackageName(name) || isCorrectlyEncodedName(name)) || strict && !allowLegacyCase && name !== name.toLowerCase() || name.toLowerCase() === "node_modules" || name.toLowerCase() === "favicon.ico") {
      throw new Error("Invalid name: " + JSON.stringify(name));
    }
  }
  function modifyPeople(data, fn) {
    if (data.author)
      data.author = fn(data.author);
    ["maintainers", "contributors"].forEach(function(set) {
      if (!Array.isArray(data[set]))
        return;
      data[set] = data[set].map(fn);
    });
    return data;
  }
  function unParsePerson(person) {
    if (typeof person === "string")
      return person;
    var name = person.name || "";
    var u = person.url || person.web;
    var url2 = u ? " (" + u + ")" : "";
    var e = person.email || person.mail;
    var email = e ? " <" + e + ">" : "";
    return name + email + url2;
  }
  function parsePerson(person) {
    if (typeof person !== "string")
      return person;
    var name = person.match(/^([^\(<]+)/);
    var url2 = person.match(/\(([^\)]+)\)/);
    var email = person.match(/<([^>]+)>/);
    var obj = {};
    if (name && name[0].trim())
      obj.name = name[0].trim();
    if (email)
      obj.email = email[1];
    if (url2)
      obj.url = url2[1];
    return obj;
  }
  function addOptionalDepsToDeps(data, warn) {
    var o = data.optionalDependencies;
    if (!o)
      return;
    var d2 = data.dependencies || {};
    Object.keys(o).forEach(function(k) {
      d2[k] = o[k];
    });
    data.dependencies = d2;
  }
  function depObjectify(deps, type, warn) {
    if (!deps)
      return {};
    if (typeof deps === "string") {
      deps = deps.trim().split(/[\n\r\s\t ,]+/);
    }
    if (!Array.isArray(deps))
      return deps;
    warn("deprecatedArrayDependencies", type);
    var o = {};
    deps.filter(function(d2) {
      return typeof d2 === "string";
    }).forEach(function(d2) {
      d2 = d2.trim().split(/(:?[@\s><=])/);
      var dn = d2.shift();
      var dv = d2.join("");
      dv = dv.trim();
      dv = dv.replace(/^@/, "");
      o[dn] = dv;
    });
    return o;
  }
  function objectifyDeps(data, warn) {
    depTypes.forEach(function(type) {
      if (!data[type])
        return;
      data[type] = depObjectify(data[type], type, warn);
    });
  }
  function bugsTypos(bugs, warn) {
    if (!bugs)
      return;
    Object.keys(bugs).forEach(function(k) {
      if (typos.bugs[k]) {
        warn("typo", k, typos.bugs[k], "bugs");
        bugs[typos.bugs[k]] = bugs[k];
        delete bugs[k];
      }
    });
  }
});

// ../../node_modules/.pnpm/normalize-package-data@2.5.0/node_modules/normalize-package-data/lib/warning_messages.json
var require_warning_messages = __commonJS2((exports2, module2) => {
  module2.exports = {
    repositories: "'repositories' (plural) Not supported. Please pick one as the 'repository' field",
    missingRepository: "No repository field.",
    brokenGitUrl: "Probably broken git url: %s",
    nonObjectScripts: "scripts must be an object",
    nonStringScript: "script values must be string commands",
    nonArrayFiles: "Invalid 'files' member",
    invalidFilename: "Invalid filename in 'files' list: %s",
    nonArrayBundleDependencies: "Invalid 'bundleDependencies' list. Must be array of package names",
    nonStringBundleDependency: "Invalid bundleDependencies member: %s",
    nonDependencyBundleDependency: "Non-dependency in bundleDependencies: %s",
    nonObjectDependencies: "%s field must be an object",
    nonStringDependency: "Invalid dependency: %s %s",
    deprecatedArrayDependencies: "specifying %s as array is deprecated",
    deprecatedModules: "modules field is deprecated",
    nonArrayKeywords: "keywords should be an array of strings",
    nonStringKeyword: "keywords should be an array of strings",
    conflictingName: "%s is also the name of a node core module.",
    nonStringDescription: "'description' field should be a string",
    missingDescription: "No description",
    missingReadme: "No README data",
    missingLicense: "No license field.",
    nonEmailUrlBugsString: "Bug string field must be url, email, or {email,url}",
    nonUrlBugsUrlField: "bugs.url field must be a string url. Deleted.",
    nonEmailBugsEmailField: "bugs.email field must be a string email. Deleted.",
    emptyNormalizedBugs: "Normalized value of bugs field is an empty object. Deleted.",
    nonUrlHomepage: "homepage field must be a string url. Deleted.",
    invalidLicense: "license should be a valid SPDX license expression",
    typo: "%s should probably be %s."
  };
});

// ../../node_modules/.pnpm/normalize-package-data@2.5.0/node_modules/normalize-package-data/lib/make_warning.js
var require_make_warning = __commonJS2((exports2, module2) => {
  var util2 = require("util");
  var messages = require_warning_messages();
  module2.exports = function() {
    var args = Array.prototype.slice.call(arguments, 0);
    var warningName = args.shift();
    if (warningName == "typo") {
      return makeTypoWarning.apply(null, args);
    } else {
      var msgTemplate = messages[warningName] ? messages[warningName] : warningName + ": '%s'";
      args.unshift(msgTemplate);
      return util2.format.apply(null, args);
    }
  };
  function makeTypoWarning(providedName, probableName, field) {
    if (field) {
      providedName = field + "['" + providedName + "']";
      probableName = field + "['" + probableName + "']";
    }
    return util2.format(messages.typo, providedName, probableName);
  }
});

// ../../node_modules/.pnpm/normalize-package-data@2.5.0/node_modules/normalize-package-data/lib/normalize.js
var require_normalize = __commonJS2((exports2, module2) => {
  module2.exports = normalize;
  var fixer = require_fixer();
  normalize.fixer = fixer;
  var makeWarning = require_make_warning();
  var fieldsToFix = [
    "name",
    "version",
    "description",
    "repository",
    "modules",
    "scripts",
    "files",
    "bin",
    "man",
    "bugs",
    "keywords",
    "readme",
    "homepage",
    "license"
  ];
  var otherThingsToFix = ["dependencies", "people", "typos"];
  var thingsToFix = fieldsToFix.map(function(fieldName) {
    return ucFirst(fieldName) + "Field";
  });
  thingsToFix = thingsToFix.concat(otherThingsToFix);
  function normalize(data, warn, strict) {
    if (warn === true)
      warn = null, strict = true;
    if (!strict)
      strict = false;
    if (!warn || data.private)
      warn = function(msg) {
      };
    if (data.scripts && data.scripts.install === "node-gyp rebuild" && !data.scripts.preinstall) {
      data.gypfile = true;
    }
    fixer.warn = function() {
      warn(makeWarning.apply(null, arguments));
    };
    thingsToFix.forEach(function(thingName) {
      fixer["fix" + ucFirst(thingName)](data, strict);
    });
    data._id = data.name + "@" + data.version;
  }
  function ucFirst(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
  }
});

// ../../node_modules/.pnpm/read-pkg@5.2.0/node_modules/read-pkg/index.js
var require_read_pkg = __commonJS2((exports2, module2) => {
  "use strict";
  var {promisify: promisify2} = require("util");
  var fs2 = require("fs");
  var path4 = require("path");
  var parseJson = require_parse_json();
  var readFileAsync = promisify2(fs2.readFile);
  module2.exports = async (options) => {
    options = {
      cwd: process.cwd(),
      normalize: true,
      ...options
    };
    const filePath = path4.resolve(options.cwd, "package.json");
    const json = parseJson(await readFileAsync(filePath, "utf8"));
    if (options.normalize) {
      require_normalize()(json);
    }
    return json;
  };
  module2.exports.sync = (options) => {
    options = {
      cwd: process.cwd(),
      normalize: true,
      ...options
    };
    const filePath = path4.resolve(options.cwd, "package.json");
    const json = parseJson(fs2.readFileSync(filePath, "utf8"));
    if (options.normalize) {
      require_normalize()(json);
    }
    return json;
  };
});

// ../../node_modules/.pnpm/read-pkg-up@7.0.1/node_modules/read-pkg-up/index.js
var require_read_pkg_up = __commonJS2((exports2, module2) => {
  "use strict";
  var path4 = require("path");
  var findUp = require_find_up2();
  var readPkg = require_read_pkg();
  module2.exports = async (options) => {
    const filePath = await findUp("package.json", options);
    if (!filePath) {
      return;
    }
    return {
      packageJson: await readPkg({...options, cwd: path4.dirname(filePath)}),
      path: filePath
    };
  };
  module2.exports.sync = (options) => {
    const filePath = findUp.sync("package.json", options);
    if (!filePath) {
      return;
    }
    return {
      packageJson: readPkg.sync({...options, cwd: path4.dirname(filePath)}),
      path: filePath
    };
  };
});

// ../sdk/dist/cli/getSchema.js
var require_getSchema = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    getRelativeSchemaPath: () => getRelativeSchemaPath2,
    getSchema: () => getSchema2,
    getSchemaDir: () => getSchemaDir2,
    getSchemaDirSync: () => getSchemaDirSync2,
    getSchemaPath: () => getSchemaPath2,
    getSchemaPathFromPackageJson: () => getSchemaPathFromPackageJson2,
    getSchemaPathFromPackageJsonSync: () => getSchemaPathFromPackageJsonSync2,
    getSchemaPathInternal: () => getSchemaPathInternal,
    getSchemaPathSync: () => getSchemaPathSync2,
    getSchemaPathSyncInternal: () => getSchemaPathSyncInternal,
    getSchemaSync: () => getSchemaSync2
  });
  var import_chalk3 = __toModule3(require_source2());
  var import_execa2 = __toModule3(require_execa2());
  var import_fs2 = __toModule3(require("fs"));
  var import_path4 = __toModule3(require("path"));
  var import_read_pkg_up = __toModule3(require_read_pkg_up());
  var import_util3 = __toModule3(require("util"));
  var exists2 = (0, import_util3.promisify)(import_fs2.default.exists);
  var readFile2 = (0, import_util3.promisify)(import_fs2.default.readFile);
  async function getSchemaPath2(schemaPathFromArgs, opts = {
    cwd: process.cwd()
  }) {
    return getSchemaPathInternal(schemaPathFromArgs, {
      cwd: opts.cwd
    });
  }
  async function getSchemaPathInternal(schemaPathFromArgs, opts = {
    cwd: process.cwd()
  }) {
    var _a, _b;
    if (schemaPathFromArgs) {
      const customSchemaPath = await getAbsoluteSchemaPath(import_path4.default.resolve(schemaPathFromArgs));
      if (!customSchemaPath) {
        throw new Error(`Provided --schema at ${schemaPathFromArgs} doesn't exist.`);
      }
      return customSchemaPath;
    }
    const schemaPath = (_b = (_a = await getSchemaPathFromPackageJson2(opts.cwd)) != null ? _a : await getRelativeSchemaPath2(opts.cwd)) != null ? _b : await resolveYarnSchema(opts.cwd);
    if (schemaPath) {
      return schemaPath;
    }
    return null;
  }
  async function getSchemaPathFromPackageJson2(cwd) {
    var _a, _b;
    const pkgJson = await (0, import_read_pkg_up.default)({cwd});
    const schemaPathFromPkgJson = (_b = (_a = pkgJson == null ? void 0 : pkgJson.packageJson) == null ? void 0 : _a.prisma) == null ? void 0 : _b.schema;
    if (!schemaPathFromPkgJson || !pkgJson) {
      return null;
    }
    if (typeof schemaPathFromPkgJson !== "string") {
      throw new Error(`Provided schema path \`${schemaPathFromPkgJson}\` from \`${import_path4.default.relative(cwd, pkgJson.path)}\` must be of type string`);
    }
    const absoluteSchemaPath = import_path4.default.isAbsolute(schemaPathFromPkgJson) ? schemaPathFromPkgJson : import_path4.default.resolve(import_path4.default.dirname(pkgJson.path), schemaPathFromPkgJson);
    if (await exists2(absoluteSchemaPath) === false) {
      throw new Error(`Provided schema path \`${import_path4.default.relative(cwd, absoluteSchemaPath)}\` from \`${import_path4.default.relative(cwd, pkgJson.path)}\` doesn't exist.`);
    }
    return absoluteSchemaPath;
  }
  async function resolveYarnSchema(cwd) {
    var _a, _b, _c;
    if ((_a = process.env.npm_config_user_agent) == null ? void 0 : _a.includes("yarn")) {
      try {
        const {stdout: version} = await import_execa2.default.command("yarn --version", {
          cwd
        });
        if (version.startsWith("2")) {
          return null;
        }
        const {stdout} = await import_execa2.default.command("yarn workspaces info --json", {
          cwd
        });
        const json = getJson(stdout);
        const workspaces = Object.values(json);
        const workspaceRootDir = await findWorkspaceRoot(cwd);
        if (!workspaceRootDir) {
          return null;
        }
        for (const workspace of workspaces) {
          const workspacePath = import_path4.default.join(workspaceRootDir, workspace.location);
          const workspaceSchemaPath = (_b = getSchemaPathFromPackageJsonSync2(workspacePath)) != null ? _b : getRelativeSchemaPathSync(workspacePath);
          if (workspaceSchemaPath) {
            return workspaceSchemaPath;
          }
        }
        const workspaceSchemaPathFromRoot = (_c = getSchemaPathFromPackageJsonSync2(workspaceRootDir)) != null ? _c : getRelativeSchemaPathSync(workspaceRootDir);
        if (workspaceSchemaPathFromRoot) {
          return workspaceSchemaPathFromRoot;
        }
      } catch (e) {
        return null;
      }
    }
    return null;
  }
  function resolveYarnSchemaSync(cwd) {
    var _a, _b, _c;
    if ((_a = process.env.npm_config_user_agent) == null ? void 0 : _a.includes("yarn")) {
      try {
        const {stdout: version} = import_execa2.default.commandSync("yarn --version", {
          cwd
        });
        if (version.startsWith("2")) {
          return null;
        }
        const {stdout} = import_execa2.default.commandSync("yarn workspaces info --json", {
          cwd
        });
        const json = getJson(stdout);
        const workspaces = Object.values(json);
        const workspaceRootDir = findWorkspaceRootSync(cwd);
        if (!workspaceRootDir) {
          return null;
        }
        for (const workspace of workspaces) {
          const workspacePath = import_path4.default.join(workspaceRootDir, workspace.location);
          const workspaceSchemaPath = (_b = getSchemaPathFromPackageJsonSync2(workspacePath)) != null ? _b : getRelativeSchemaPathSync(workspacePath);
          if (workspaceSchemaPath) {
            return workspaceSchemaPath;
          }
        }
        const workspaceSchemaPathFromRoot = (_c = getSchemaPathFromPackageJsonSync2(workspaceRootDir)) != null ? _c : getRelativeSchemaPathSync(workspaceRootDir);
        if (workspaceSchemaPathFromRoot) {
          return workspaceSchemaPathFromRoot;
        }
      } catch (e) {
        return null;
      }
    }
    return null;
  }
  async function getAbsoluteSchemaPath(schemaPath) {
    if (await exists2(schemaPath)) {
      return schemaPath;
    }
    return null;
  }
  async function getRelativeSchemaPath2(cwd) {
    let schemaPath = import_path4.default.join(cwd, "schema.prisma");
    if (await exists2(schemaPath)) {
      return schemaPath;
    }
    schemaPath = import_path4.default.join(cwd, `prisma/schema.prisma`);
    if (await exists2(schemaPath)) {
      return schemaPath;
    }
    return null;
  }
  async function getSchemaDir2(schemaPathFromArgs) {
    if (schemaPathFromArgs) {
      return import_path4.default.resolve(import_path4.default.dirname(schemaPathFromArgs));
    }
    const schemaPath = await getSchemaPath2(schemaPathFromArgs);
    if (!schemaPath) {
      return null;
    }
    return import_path4.default.dirname(schemaPath);
  }
  async function getSchema2(schemaPathFromArgs) {
    const schemaPath = await getSchemaPath2(schemaPathFromArgs);
    if (!schemaPath) {
      throw new Error(`Could not find a ${import_chalk3.default.bold("schema.prisma")} file that is required for this command.
You can either provide it with ${import_chalk3.default.greenBright("--schema")}, set it as \`prisma.schema\` in your package.json or put it into the default location ${import_chalk3.default.greenBright("./prisma/schema.prisma")} https://pris.ly/d/prisma-schema-location`);
    }
    return readFile2(schemaPath, "utf-8");
  }
  function getSchemaPathSync2(schemaPathFromArgs) {
    return getSchemaPathSyncInternal(schemaPathFromArgs, {
      cwd: process.cwd()
    });
  }
  function getSchemaPathSyncInternal(schemaPathFromArgs, opts = {
    cwd: process.cwd()
  }) {
    var _a, _b;
    if (schemaPathFromArgs) {
      const customSchemaPath = getAbsoluteSchemaPathSync(import_path4.default.resolve(schemaPathFromArgs));
      if (!customSchemaPath) {
        throw new Error(`Provided --schema at ${schemaPathFromArgs} doesn't exist.`);
      }
      return customSchemaPath;
    }
    const schemaPath = (_b = (_a = getSchemaPathFromPackageJsonSync2(opts.cwd)) != null ? _a : getRelativeSchemaPathSync(opts.cwd)) != null ? _b : resolveYarnSchemaSync(opts.cwd);
    if (schemaPath) {
      return schemaPath;
    }
    return null;
  }
  function getSchemaPathFromPackageJsonSync2(cwd) {
    var _a, _b;
    const pkgJson = import_read_pkg_up.default.sync({cwd});
    const schemaPathFromPkgJson = (_b = (_a = pkgJson == null ? void 0 : pkgJson.packageJson) == null ? void 0 : _a.prisma) == null ? void 0 : _b.schema;
    if (!schemaPathFromPkgJson || !pkgJson) {
      return null;
    }
    if (typeof schemaPathFromPkgJson !== "string") {
      throw new Error(`Provided schema path \`${schemaPathFromPkgJson}\` from \`${import_path4.default.relative(cwd, pkgJson.path)}\` must be of type string`);
    }
    const absoluteSchemaPath = import_path4.default.isAbsolute(schemaPathFromPkgJson) ? schemaPathFromPkgJson : import_path4.default.resolve(import_path4.default.dirname(pkgJson.path), schemaPathFromPkgJson);
    if (import_fs2.default.existsSync(absoluteSchemaPath) === false) {
      throw new Error(`Provided schema path \`${import_path4.default.relative(cwd, absoluteSchemaPath)}\` from \`${import_path4.default.relative(cwd, pkgJson.path)}\` doesn't exist.`);
    }
    return absoluteSchemaPath;
  }
  function getAbsoluteSchemaPathSync(schemaPath) {
    if (import_fs2.default.existsSync(schemaPath)) {
      return schemaPath;
    }
    return null;
  }
  function getRelativeSchemaPathSync(cwd) {
    let schemaPath = import_path4.default.join(cwd, "schema.prisma");
    if (import_fs2.default.existsSync(schemaPath)) {
      return schemaPath;
    }
    schemaPath = import_path4.default.join(cwd, `prisma/schema.prisma`);
    if (import_fs2.default.existsSync(schemaPath)) {
      return schemaPath;
    }
    return null;
  }
  function getSchemaDirSync2(schemaPathFromArgs) {
    if (schemaPathFromArgs) {
      return import_path4.default.resolve(import_path4.default.dirname(schemaPathFromArgs));
    }
    const schemaPath = getSchemaPathSync2(schemaPathFromArgs);
    if (schemaPath) {
      return import_path4.default.dirname(schemaPath);
    }
    return null;
  }
  function getSchemaSync2(schemaPathFromArgs) {
    const schemaPath = getSchemaPathSync2(schemaPathFromArgs);
    if (!schemaPath) {
      throw new Error(`Could not find a ${import_chalk3.default.bold("schema.prisma")} file that is required for this command.
You can either provide it with ${import_chalk3.default.greenBright("--schema")}, set it as \`prisma.schema\` in your package.json or put it into the default location ${import_chalk3.default.greenBright("./prisma/schema.prisma")} https://pris.ly/d/prisma-schema-location`);
    }
    return import_fs2.default.readFileSync(schemaPath, "utf-8");
  }
  function getJson(stdout) {
    const firstCurly = stdout.indexOf("{");
    const lastCurly = stdout.lastIndexOf("}");
    const sliced = stdout.slice(firstCurly, lastCurly + 1);
    return JSON.parse(sliced);
  }
  function isPkgJsonWorkspaceRoot(pkgJson) {
    const workspaces = pkgJson.workspaces;
    if (!workspaces) {
      return false;
    }
    return Array.isArray(workspaces) || workspaces.packages !== void 0;
  }
  async function isNearestPkgJsonWorkspaceRoot(cwd) {
    const pkgJson = await (0, import_read_pkg_up.default)({cwd});
    if (!pkgJson) {
      return null;
    }
    return {
      isRoot: isPkgJsonWorkspaceRoot(pkgJson.packageJson),
      path: pkgJson.path
    };
  }
  function isNearestPkgJsonWorkspaceRootSync(cwd) {
    const pkgJson = import_read_pkg_up.default.sync({cwd});
    if (!pkgJson) {
      return null;
    }
    return {
      isRoot: isPkgJsonWorkspaceRoot(pkgJson.packageJson),
      path: pkgJson.path
    };
  }
  async function findWorkspaceRoot(cwd) {
    let pkgJson = await isNearestPkgJsonWorkspaceRoot(cwd);
    if (!pkgJson) {
      return null;
    }
    if (pkgJson.isRoot === true) {
      return import_path4.default.dirname(pkgJson.path);
    }
    const pkgJsonParentDir = import_path4.default.dirname(import_path4.default.dirname(pkgJson.path));
    pkgJson = await isNearestPkgJsonWorkspaceRoot(pkgJsonParentDir);
    if (!pkgJson || pkgJson.isRoot === false) {
      return null;
    }
    return import_path4.default.dirname(pkgJson.path);
  }
  function findWorkspaceRootSync(cwd) {
    let pkgJson = isNearestPkgJsonWorkspaceRootSync(cwd);
    if (!pkgJson) {
      return null;
    }
    if (pkgJson.isRoot === true) {
      return import_path4.default.dirname(pkgJson.path);
    }
    const pkgJsonParentDir = import_path4.default.dirname(import_path4.default.dirname(pkgJson.path));
    pkgJson = isNearestPkgJsonWorkspaceRootSync(pkgJsonParentDir);
    if (!pkgJson || pkgJson.isRoot === false) {
      return null;
    }
    return import_path4.default.dirname(pkgJson.path);
  }
});

// ../../node_modules/.pnpm/min-indent@1.0.1/node_modules/min-indent/index.js
var require_min_indent = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = (string) => {
    const match = string.match(/^[ \t]*(?=\S)/gm);
    if (!match) {
      return 0;
    }
    return match.reduce((r, a) => Math.min(r, a.length), Infinity);
  };
});

// ../../node_modules/.pnpm/strip-indent@3.0.0/node_modules/strip-indent/index.js
var require_strip_indent = __commonJS2((exports2, module2) => {
  "use strict";
  var minIndent = require_min_indent();
  module2.exports = (string) => {
    const indent14 = minIndent(string);
    if (indent14 === 0) {
      return string;
    }
    const regex = new RegExp(`^[ \\t]{${indent14}}`, "gm");
    return string.replace(regex, "");
  };
});

// ../../node_modules/.pnpm/arg@5.0.1/node_modules/arg/index.js
var require_arg = __commonJS2((exports2, module2) => {
  var flagSymbol = Symbol("arg flag");
  var ArgError = class extends Error {
    constructor(msg, code) {
      super(msg);
      this.name = "ArgError";
      this.code = code;
      Object.setPrototypeOf(this, ArgError.prototype);
    }
  };
  function arg2(opts, {
    argv = process.argv.slice(2),
    permissive = false,
    stopAtPositional = false
  } = {}) {
    if (!opts) {
      throw new ArgError("argument specification object is required", "ARG_CONFIG_NO_SPEC");
    }
    const result = {_: []};
    const aliases = {};
    const handlers = {};
    for (const key of Object.keys(opts)) {
      if (!key) {
        throw new ArgError("argument key cannot be an empty string", "ARG_CONFIG_EMPTY_KEY");
      }
      if (key[0] !== "-") {
        throw new ArgError(`argument key must start with '-' but found: '${key}'`, "ARG_CONFIG_NONOPT_KEY");
      }
      if (key.length === 1) {
        throw new ArgError(`argument key must have a name; singular '-' keys are not allowed: ${key}`, "ARG_CONFIG_NONAME_KEY");
      }
      if (typeof opts[key] === "string") {
        aliases[key] = opts[key];
        continue;
      }
      let type = opts[key];
      let isFlag = false;
      if (Array.isArray(type) && type.length === 1 && typeof type[0] === "function") {
        const [fn] = type;
        type = (value, name, prev = []) => {
          prev.push(fn(value, name, prev[prev.length - 1]));
          return prev;
        };
        isFlag = fn === Boolean || fn[flagSymbol] === true;
      } else if (typeof type === "function") {
        isFlag = type === Boolean || type[flagSymbol] === true;
      } else {
        throw new ArgError(`type missing or not a function or valid array type: ${key}`, "ARG_CONFIG_VAD_TYPE");
      }
      if (key[1] !== "-" && key.length > 2) {
        throw new ArgError(`short argument keys (with a single hyphen) must have only one character: ${key}`, "ARG_CONFIG_SHORTOPT_TOOLONG");
      }
      handlers[key] = [type, isFlag];
    }
    for (let i = 0, len = argv.length; i < len; i++) {
      const wholeArg = argv[i];
      if (stopAtPositional && result._.length > 0) {
        result._ = result._.concat(argv.slice(i));
        break;
      }
      if (wholeArg === "--") {
        result._ = result._.concat(argv.slice(i + 1));
        break;
      }
      if (wholeArg.length > 1 && wholeArg[0] === "-") {
        const separatedArguments = wholeArg[1] === "-" || wholeArg.length === 2 ? [wholeArg] : wholeArg.slice(1).split("").map((a) => `-${a}`);
        for (let j = 0; j < separatedArguments.length; j++) {
          const arg3 = separatedArguments[j];
          const [originalArgName, argStr] = arg3[1] === "-" ? arg3.split(/=(.*)/, 2) : [arg3, void 0];
          let argName = originalArgName;
          while (argName in aliases) {
            argName = aliases[argName];
          }
          if (!(argName in handlers)) {
            if (permissive) {
              result._.push(arg3);
              continue;
            } else {
              throw new ArgError(`unknown or unexpected option: ${originalArgName}`, "ARG_UNKNOWN_OPTION");
            }
          }
          const [type, isFlag] = handlers[argName];
          if (!isFlag && j + 1 < separatedArguments.length) {
            throw new ArgError(`option requires argument (but was followed by another short argument): ${originalArgName}`, "ARG_MISSING_REQUIRED_SHORTARG");
          }
          if (isFlag) {
            result[argName] = type(true, argName, result[argName]);
          } else if (argStr === void 0) {
            if (argv.length < i + 2 || argv[i + 1].length > 1 && argv[i + 1][0] === "-" && !(argv[i + 1].match(/^-?\d*(\.(?=\d))?\d*$/) && (type === Number || typeof BigInt !== "undefined" && type === BigInt))) {
              const extended = originalArgName === argName ? "" : ` (alias for ${argName})`;
              throw new ArgError(`option requires argument: ${originalArgName}${extended}`, "ARG_MISSING_REQUIRED_LONGARG");
            }
            result[argName] = type(argv[i + 1], argName, result[argName]);
            ++i;
          } else {
            result[argName] = type(argStr, argName, result[argName]);
          }
        }
      } else {
        result._.push(wholeArg);
      }
    }
    return result;
  }
  arg2.flag = (fn) => {
    fn[flagSymbol] = true;
    return fn;
  };
  arg2.COUNT = arg2.flag((v, name, existingCount) => (existingCount || 0) + 1);
  arg2.ArgError = ArgError;
  module2.exports = arg2;
});

// ../sdk/dist/cli/utils.js
var require_utils5 = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    arg: () => arg2,
    format: () => format2,
    isError: () => isError2
  });
  var import_strip_indent = __toModule3(require_strip_indent());
  var import_arg = __toModule3(require_arg());
  function format2(input = "") {
    return (0, import_strip_indent.default)(input).trimRight() + "\n";
  }
  function arg2(argv, spec, stopAtPositional = true, permissive = false) {
    try {
      return (0, import_arg.default)(spec, {argv, stopAtPositional, permissive});
    } catch (err) {
      return err;
    }
  }
  function isError2(result) {
    return result instanceof Error;
  }
});

// ../sdk/dist/cli/hashes.js
var require_hashes = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    getCLIPathHash: () => getCLIPathHash2,
    getProjectHash: () => getProjectHash2
  });
  var import_getSchema = __toModule3(require_getSchema());
  var import_utils8 = __toModule3(require_utils5());
  var import_crypto = __toModule3(require("crypto"));
  async function getProjectHash2() {
    const args = (0, import_utils8.arg)(process.argv.slice(3), {"--schema": String});
    let projectPath = await (0, import_getSchema.getSchemaPath)(args["--schema"]);
    projectPath = projectPath || process.cwd();
    return import_crypto.default.createHash("sha256").update(projectPath).digest("hex").substring(0, 8);
  }
  function getCLIPathHash2() {
    const cliPath = process.argv[1];
    return import_crypto.default.createHash("sha256").update(cliPath).digest("hex").substring(0, 8);
  }
});

// ../sdk/dist/cli/Help.js
var require_Help = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    HelpError: () => HelpError2,
    unknownCommand: () => unknownCommand2
  });
  var import_chalk3 = __toModule3(require_source2());
  function unknownCommand2(helpTemplate, cmd) {
    return new HelpError2(`
${import_chalk3.default.bold.red(`!`)} Unknown command "${cmd}"
${helpTemplate}`);
  }
  var HelpError2 = class extends Error {
    constructor(msg) {
      super(msg);
      Object.setPrototypeOf(this, HelpError2.prototype);
    }
  };
});

// ../sdk/dist/cli/types.js
var require_types2 = __commonJS2((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  __markAsModule3(exports2);
});

// ../sdk/dist/convertCredentials.js
var require_convertCredentials = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    credentialsToUri: () => credentialsToUri2,
    protocolToConnectorType: () => protocolToConnectorType,
    uriToCredentials: () => uriToCredentials2
  });
  var NodeURL = __toModule3(require("url"));
  var import_path4 = __toModule3(require("path"));
  function credentialsToUri2(credentials) {
    const type = databaseTypeToProtocol(credentials.type);
    if (credentials.type === "mongodb") {
      return credentials.uri;
    }
    const url = new NodeURL.URL(type + "//");
    if (credentials.host) {
      url.hostname = credentials.host;
    }
    if (credentials.type === "postgresql") {
      if (credentials.database) {
        url.pathname = "/" + credentials.database;
      }
      if (credentials.schema) {
        url.searchParams.set("schema", credentials.schema);
      }
      if (credentials.socket) {
        url.host = credentials.socket;
      }
    } else if (credentials.type === "mysql") {
      url.pathname = "/" + (credentials.database || credentials.schema || "");
      if (credentials.socket) {
        url.searchParams.set("socket", credentials.socket);
      }
    }
    if (credentials.ssl) {
      url.searchParams.set("sslmode", "prefer");
    }
    if (credentials.user) {
      url.username = credentials.user;
    }
    if (credentials.password) {
      url.password = credentials.password;
    }
    if (credentials.port) {
      url.port = String(credentials.port);
    }
    url.host = `${url.hostname}${url.port ? `:${url.port}` : ""}`;
    if (credentials.extraFields) {
      for (const [key, value] of Object.entries(credentials.extraFields)) {
        url.searchParams.set(key, value);
      }
    }
    if (url.pathname === "/") {
      url.pathname = "";
    }
    if (credentials.type === "sqlite") {
      return credentials.uri;
    }
    return url.toString();
  }
  function uriToCredentials2(connectionString) {
    let uri;
    try {
      uri = new NodeURL.URL(connectionString);
    } catch (e) {
      throw new Error("Invalid data source URL, see https://www.prisma.io/docs/reference/database-reference/connection-urls");
    }
    const type = protocolToConnectorType(uri.protocol);
    const exists2 = (str) => str && str.length > 0;
    if (type === "mongodb") {
      return {
        type,
        uri: connectionString
      };
    }
    const extraFields = {};
    const schema = uri.searchParams.get("schema");
    const socket = uri.searchParams.get("socket");
    for (const [name, value] of uri.searchParams) {
      if (!["schema", "socket"].includes(name)) {
        extraFields[name] = value;
      }
    }
    let database = void 0;
    let defaultSchema2 = void 0;
    if (type === "sqlite" && uri.pathname) {
      if (uri.pathname.startsWith("file:")) {
        database = uri.pathname.slice(5);
      }
      if (uri.pathname.startsWith("sqlite:")) {
        database = uri.pathname.slice(7);
      } else {
        database = import_path4.default.basename(uri.pathname);
      }
    } else if (uri.pathname.length > 1) {
      database = uri.pathname.slice(1);
      if (type === "postgresql" && !database) {
        database = "postgres";
      }
    }
    if (type === "postgresql" && !schema) {
      defaultSchema2 = "public";
    }
    return {
      type,
      host: exists2(uri.hostname) ? uri.hostname : void 0,
      user: exists2(uri.username) ? uri.username : void 0,
      port: exists2(uri.port) ? Number(uri.port) : void 0,
      password: exists2(uri.password) ? uri.password : void 0,
      database,
      schema: schema || defaultSchema2,
      uri: connectionString,
      ssl: Boolean(uri.searchParams.get("sslmode")),
      socket: socket || void 0,
      extraFields
    };
  }
  function databaseTypeToProtocol(databaseType) {
    switch (databaseType) {
      case "postgresql":
        return "postgresql:";
      case "mysql":
        return "mysql:";
      case "mongodb":
        return "mongodb:";
      case "sqlite":
        return "sqlite:";
      case "sqlserver":
        return "sqlserver:";
    }
  }
  function protocolToConnectorType(protocol) {
    switch (protocol) {
      case "postgresql:":
      case "postgres:":
        return "postgresql";
      case "mongodb:":
        return "mongodb";
      case "mysql:":
        return "mysql";
      case "file:":
      case "sqlite:":
        return "sqlite";
      case "sqlserver:":
      case "jdbc:sqlserver:":
        return "sqlserver";
    }
    throw new Error(`Unknown database type ${protocol}`);
  }
});

// ../../node_modules/.pnpm/is-fullwidth-code-point@3.0.0/node_modules/is-fullwidth-code-point/index.js
var require_is_fullwidth_code_point = __commonJS2((exports2, module2) => {
  "use strict";
  var isFullwidthCodePoint = (codePoint) => {
    if (Number.isNaN(codePoint)) {
      return false;
    }
    if (codePoint >= 4352 && (codePoint <= 4447 || codePoint === 9001 || codePoint === 9002 || 11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || 12880 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65131 || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 262141)) {
      return true;
    }
    return false;
  };
  module2.exports = isFullwidthCodePoint;
  module2.exports.default = isFullwidthCodePoint;
});

// ../../node_modules/.pnpm/astral-regex@2.0.0/node_modules/astral-regex/index.js
var require_astral_regex = __commonJS2((exports2, module2) => {
  "use strict";
  var regex = "[\uD800-\uDBFF][\uDC00-\uDFFF]";
  var astralRegex = (options) => options && options.exact ? new RegExp(`^${regex}$`) : new RegExp(regex, "g");
  module2.exports = astralRegex;
});

// ../../node_modules/.pnpm/slice-ansi@3.0.0/node_modules/slice-ansi/index.js
var require_slice_ansi = __commonJS2((exports2, module2) => {
  "use strict";
  var isFullwidthCodePoint = require_is_fullwidth_code_point();
  var astralRegex = require_astral_regex();
  var ansiStyles = require_ansi_styles2();
  var ESCAPES = [
    "",
    "\x9B"
  ];
  var wrapAnsi = (code) => `${ESCAPES[0]}[${code}m`;
  var checkAnsi = (ansiCodes, isEscapes, endAnsiCode) => {
    let output = [];
    ansiCodes = [...ansiCodes];
    for (let ansiCode of ansiCodes) {
      const ansiCodeOrigin = ansiCode;
      if (ansiCode.match(";")) {
        ansiCode = ansiCode.split(";")[0][0] + "0";
      }
      const item = ansiStyles.codes.get(parseInt(ansiCode, 10));
      if (item) {
        const indexEscape = ansiCodes.indexOf(item.toString());
        if (indexEscape >= 0) {
          ansiCodes.splice(indexEscape, 1);
        } else {
          output.push(wrapAnsi(isEscapes ? item : ansiCodeOrigin));
        }
      } else if (isEscapes) {
        output.push(wrapAnsi(0));
        break;
      } else {
        output.push(wrapAnsi(ansiCodeOrigin));
      }
    }
    if (isEscapes) {
      output = output.filter((element, index) => output.indexOf(element) === index);
      if (endAnsiCode !== void 0) {
        const fistEscapeCode = wrapAnsi(ansiStyles.codes.get(parseInt(endAnsiCode, 10)));
        output = output.reduce((current, next) => next === fistEscapeCode ? [next, ...current] : [...current, next], []);
      }
    }
    return output.join("");
  };
  module2.exports = (string, begin, end) => {
    const characters = [...string.normalize()];
    const ansiCodes = [];
    end = typeof end === "number" ? end : characters.length;
    let isInsideEscape = false;
    let ansiCode;
    let visible = 0;
    let output = "";
    for (const [index, character] of characters.entries()) {
      let leftEscape = false;
      if (ESCAPES.includes(character)) {
        const code = /\d[^m]*/.exec(string.slice(index, index + 18));
        ansiCode = code && code.length > 0 ? code[0] : void 0;
        if (visible < end) {
          isInsideEscape = true;
          if (ansiCode !== void 0) {
            ansiCodes.push(ansiCode);
          }
        }
      } else if (isInsideEscape && character === "m") {
        isInsideEscape = false;
        leftEscape = true;
      }
      if (!isInsideEscape && !leftEscape) {
        ++visible;
      }
      if (!astralRegex({exact: true}).test(character) && isFullwidthCodePoint(character.codePointAt())) {
        ++visible;
      }
      if (visible > begin && visible <= end) {
        output += character;
      } else if (visible === begin && !isInsideEscape && ansiCode !== void 0) {
        output = checkAnsi(ansiCodes);
      } else if (visible >= end) {
        output += checkAnsi(ansiCodes, true, ansiCode);
        break;
      }
    }
    return output;
  };
});

// ../../node_modules/.pnpm/ansi-regex@5.0.0/node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = ({onlyFirst = false} = {}) => {
    const pattern = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(pattern, onlyFirst ? void 0 : "g");
  };
});

// ../../node_modules/.pnpm/strip-ansi@6.0.0/node_modules/strip-ansi/index.js
var require_strip_ansi = __commonJS2((exports2, module2) => {
  "use strict";
  var ansiRegex = require_ansi_regex();
  module2.exports = (string) => typeof string === "string" ? string.replace(ansiRegex(), "") : string;
});

// ../../node_modules/.pnpm/emoji-regex@8.0.0/node_modules/emoji-regex/index.js
var require_emoji_regex = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = function() {
    return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
  };
});

// ../../node_modules/.pnpm/string-width@4.2.2/node_modules/string-width/index.js
var require_string_width = __commonJS2((exports2, module2) => {
  "use strict";
  var stripAnsi = require_strip_ansi();
  var isFullwidthCodePoint = require_is_fullwidth_code_point();
  var emojiRegex = require_emoji_regex();
  var stringWidth = (string) => {
    if (typeof string !== "string" || string.length === 0) {
      return 0;
    }
    string = stripAnsi(string);
    if (string.length === 0) {
      return 0;
    }
    string = string.replace(emojiRegex(), "  ");
    let width = 0;
    for (let i = 0; i < string.length; i++) {
      const code = string.codePointAt(i);
      if (code <= 31 || code >= 127 && code <= 159) {
        continue;
      }
      if (code >= 768 && code <= 879) {
        continue;
      }
      if (code > 65535) {
        i++;
      }
      width += isFullwidthCodePoint(code) ? 2 : 1;
    }
    return width;
  };
  module2.exports = stringWidth;
  module2.exports.default = stringWidth;
});

// ../../node_modules/.pnpm/cli-truncate@2.1.0/node_modules/cli-truncate/index.js
var require_cli_truncate = __commonJS2((exports2, module2) => {
  "use strict";
  var sliceAnsi = require_slice_ansi();
  var stringWidth = require_string_width();
  function getIndexOfNearestSpace(string, index, shouldSearchRight) {
    if (string.charAt(index) === " ") {
      return index;
    }
    for (let i = 1; i <= 3; i++) {
      if (shouldSearchRight) {
        if (string.charAt(index + i) === " ") {
          return index + i;
        }
      } else if (string.charAt(index - i) === " ") {
        return index - i;
      }
    }
    return index;
  }
  module2.exports = (text, columns, options) => {
    options = {
      position: "end",
      preferTruncationOnSpace: false,
      ...options
    };
    const {position, space, preferTruncationOnSpace} = options;
    let ellipsis = "\u2026";
    let ellipsisWidth = 1;
    if (typeof text !== "string") {
      throw new TypeError(`Expected \`input\` to be a string, got ${typeof text}`);
    }
    if (typeof columns !== "number") {
      throw new TypeError(`Expected \`columns\` to be a number, got ${typeof columns}`);
    }
    if (columns < 1) {
      return "";
    }
    if (columns === 1) {
      return ellipsis;
    }
    const length = stringWidth(text);
    if (length <= columns) {
      return text;
    }
    if (position === "start") {
      if (preferTruncationOnSpace) {
        const nearestSpace = getIndexOfNearestSpace(text, length - columns + 1, true);
        return ellipsis + sliceAnsi(text, nearestSpace, length).trim();
      }
      if (space === true) {
        ellipsis += " ";
        ellipsisWidth = 2;
      }
      return ellipsis + sliceAnsi(text, length - columns + ellipsisWidth, length);
    }
    if (position === "middle") {
      if (space === true) {
        ellipsis = " " + ellipsis + " ";
        ellipsisWidth = 3;
      }
      const half = Math.floor(columns / 2);
      if (preferTruncationOnSpace) {
        const spaceNearFirstBreakPoint = getIndexOfNearestSpace(text, half);
        const spaceNearSecondBreakPoint = getIndexOfNearestSpace(text, length - (columns - half) + 1, true);
        return sliceAnsi(text, 0, spaceNearFirstBreakPoint) + ellipsis + sliceAnsi(text, spaceNearSecondBreakPoint, length).trim();
      }
      return sliceAnsi(text, 0, half) + ellipsis + sliceAnsi(text, length - (columns - half) + ellipsisWidth, length);
    }
    if (position === "end") {
      if (preferTruncationOnSpace) {
        const nearestSpace = getIndexOfNearestSpace(text, columns - 1);
        return sliceAnsi(text, 0, nearestSpace) + ellipsis;
      }
      if (space === true) {
        ellipsis = " " + ellipsis;
        ellipsisWidth = 2;
      }
      return sliceAnsi(text, 0, columns - ellipsisWidth) + ellipsis;
    }
    throw new Error(`Expected \`options.position\` to be either \`start\`, \`middle\` or \`end\`, got ${position}`);
  };
});

// ../sdk/dist/drawBox.js
var require_drawBox = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    drawBox: () => drawBox2
  });
  var import_chalk3 = __toModule3(require_source2());
  var import_cli_truncate = __toModule3(require_cli_truncate());
  var import_string_width = __toModule3(require_string_width());
  var chars = {
    topLeft: "\u250C",
    topRight: "\u2510",
    bottomRight: "\u2518",
    bottomLeft: "\u2514",
    vertical: "\u2502",
    horizontal: "\u2500"
  };
  function maxLineLength(str) {
    return str.split("\n").reduce((max2, curr) => Math.max(max2, (0, import_string_width.default)(curr)), 0) + 2;
  }
  function drawBox2({
    title,
    width,
    height,
    str,
    horizontalPadding
  }) {
    horizontalPadding = horizontalPadding || 0;
    width = width || maxLineLength(str) + horizontalPadding * 2;
    const topLine = title ? import_chalk3.default.grey(chars.topLeft + chars.horizontal) + " " + import_chalk3.default.reset.bold(title) + " " + import_chalk3.default.grey(chars.horizontal.repeat(width - title.length - 2 - 3) + chars.topRight) + import_chalk3.default.reset() : import_chalk3.default.grey(chars.topLeft + chars.horizontal) + import_chalk3.default.grey(chars.horizontal.repeat(width - 3) + chars.topRight);
    const bottomLine = chars.bottomLeft + chars.horizontal.repeat(width - 2) + chars.bottomRight;
    const lines = str.split("\n");
    if (lines.length < height) {
      lines.push(...new Array(height - lines.length).fill(""));
    }
    const mappedLines = lines.slice(-height).map((l) => {
      const lineWidth = Math.min((0, import_string_width.default)(l), width);
      const paddingRight = Math.max(width - lineWidth - 2, 0);
      return `${import_chalk3.default.grey(chars.vertical)}${" ".repeat(horizontalPadding)}${import_chalk3.default.reset((0, import_cli_truncate.default)(l, width - 2))}${" ".repeat(paddingRight - horizontalPadding)}${import_chalk3.default.grey(chars.vertical)}`;
    }).join("\n");
    return import_chalk3.default.grey(topLine + "\n" + mappedLines + "\n" + bottomLine);
  }
});

// ../../node_modules/.pnpm/@prisma+debug@2.30.0/node_modules/@prisma/debug/dist/common.js
var require_common8 = __commonJS2((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    setup: () => setup
  });
  function setup(env2) {
    const createDebug = (namespace, logger2) => {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      const debug4 = (...args) => {
        const self2 = debug4;
        const curr = Number(new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format2];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        if (logger2 && typeof logger2 === "function") {
          logger2.apply(self2, args);
        }
        if (debug4.enabled) {
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
      };
      debug4.namespace = namespace;
      debug4.useColors = createDebug.useColors();
      debug4.color = createDebug.selectColor(namespace);
      debug4.extend = extend;
      debug4.destroy = createDebug.destroy;
      Object.defineProperty(debug4, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug4);
      }
      return debug4;
    };
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms3();
    createDebug.destroy = destroy;
    Object.keys(env2).forEach((key) => {
      createDebug[key] = env2[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
});

// ../../node_modules/.pnpm/@prisma+debug@2.30.0/node_modules/@prisma/debug/dist/node.js
var require_node5 = __commonJS2((exports2, module2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    default: () => node_default
  });
  var import_common10 = __toModule3(require_common8());
  var tty = require("tty");
  var util2 = require("util");
  exports2.init = init;
  exports2.log = log3;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load2;
  exports2.useColors = useColors;
  exports2.destroy = util2.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports2.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color2();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports2.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {
  }
  exports2.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_2, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const {namespace: name, useColors: useColors2} = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} [0m`;
      args[0] = prefix + args[0].split("\n").join("\n" + prefix);
      args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports2.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log3(...args) {
    return process.stderr.write(util2.format(...args) + "\n");
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load2() {
    return process.env.DEBUG;
  }
  function init(debug4) {
    debug4.inspectOpts = {};
    const keys = Object.keys(exports2.inspectOpts);
    for (let i = 0; i < keys.length; i++) {
      debug4.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
    }
  }
  var mod2 = (0, import_common10.setup)(exports2);
  module2.exports = mod2;
  var node_default = mod2;
  var {formatters} = mod2;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v, this.inspectOpts);
  };
});

// ../../node_modules/.pnpm/@prisma+debug@2.30.0/node_modules/@prisma/debug/dist/index.js
var require_dist10 = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    Debug: () => Debug2,
    default: () => Debug2,
    getLogs: () => getLogs
  });
  var import_debug3 = __toModule3(require_src3());
  var import_node = __toModule3(require_node5());
  var cache = [];
  var MAX_LOGS = 100;
  function Debug2(namespace) {
    const debug4 = (0, import_node.default)(namespace, (...args) => {
      cache.push(args);
      if (cache.length > MAX_LOGS) {
        cache.shift();
      }
    });
    return debug4;
  }
  Debug2.enable = (namespace) => {
    import_node.default.enable(namespace);
  };
  Debug2.enabled = (namespace) => import_node.default.enabled(namespace);
  function getLogs(numChars = 7500) {
    const output = cache.map((c) => c.map((item) => {
      if (typeof item === "string") {
        return item;
      }
      return JSON.stringify(item);
    }).join("  ")).join("\n");
    if (output.length < numChars) {
      return output;
    }
    return output.slice(-numChars);
  }
});

// ../../node_modules/.pnpm/@prisma+get-platform@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/get-platform/dist/getNodeAPIName.js
var require_getNodeAPIName2 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getNodeAPIName = void 0;
  var NODE_API_QUERY_ENGINE_URL_BASE = "libquery_engine";
  function getNodeAPIName3(platform, type) {
    const isUrl = type === "url";
    if (platform.includes("windows")) {
      return isUrl ? `query_engine.dll.node` : `query_engine-${platform}.dll.node`;
    } else if (platform.includes("linux") || platform.includes("debian") || platform.includes("rhel")) {
      return isUrl ? `${NODE_API_QUERY_ENGINE_URL_BASE}.so.node` : `${NODE_API_QUERY_ENGINE_URL_BASE}-${platform}.so.node`;
    } else if (platform.includes("darwin")) {
      return isUrl ? `${NODE_API_QUERY_ENGINE_URL_BASE}.dylib.node` : `${NODE_API_QUERY_ENGINE_URL_BASE}-${platform}.dylib.node`;
    } else {
      throw new Error(`Node API is currently not supported on your platform: ${platform}`);
    }
  }
  exports2.getNodeAPIName = getNodeAPIName3;
});

// ../../node_modules/.pnpm/@prisma+get-platform@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/get-platform/dist/getPlatform.js
var require_getPlatform2 = __commonJS2((exports2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : {default: mod2};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getPlatform = exports2.getOpenSSLVersion = exports2.parseOpenSSLVersion = exports2.resolveDistro = exports2.parseDistro = exports2.getos = void 0;
  var child_process_1 = require("child_process");
  var fs_12 = __importDefault2(require("fs"));
  var os_1 = __importDefault2(require("os"));
  var util_12 = require("util");
  var readFile2 = util_12.promisify(fs_12.default.readFile);
  var exists2 = util_12.promisify(fs_12.default.exists);
  async function getos() {
    const platform = os_1.default.platform();
    const arch = process.arch;
    if (platform === "freebsd") {
      const version = await gracefulExec(`freebsd-version`);
      if (version && version.trim().length > 0) {
        const regex = /^(\d+)\.?/;
        const match = regex.exec(version);
        if (match) {
          return {
            platform: "freebsd",
            distro: `freebsd${match[1]}`,
            arch
          };
        }
      }
    }
    if (platform !== "linux") {
      return {
        platform,
        arch
      };
    }
    return {
      platform: "linux",
      libssl: await getOpenSSLVersion(),
      distro: await resolveDistro(),
      arch
    };
  }
  exports2.getos = getos;
  function parseDistro(input) {
    const idRegex = /^ID="?([^"\n]*)"?$/im;
    const idLikeRegex = /^ID_LIKE="?([^"\n]*)"?$/im;
    const idMatch = idRegex.exec(input);
    const id = idMatch && idMatch[1] && idMatch[1].toLowerCase() || "";
    const idLikeMatch = idLikeRegex.exec(input);
    const idLike = idLikeMatch && idLikeMatch[1] && idLikeMatch[1].toLowerCase() || "";
    if (id === "raspbian") {
      return "arm";
    }
    if (id === "nixos") {
      return "nixos";
    }
    if (idLike.includes("centos") || idLike.includes("fedora") || idLike.includes("rhel") || id === "fedora") {
      return "rhel";
    }
    if (idLike.includes("debian") || idLike.includes("ubuntu") || id === "debian") {
      return "debian";
    }
    return;
  }
  exports2.parseDistro = parseDistro;
  async function resolveDistro() {
    const osReleaseFile = "/etc/os-release";
    const alpineReleaseFile = "/etc/alpine-release";
    if (await exists2(alpineReleaseFile)) {
      return "musl";
    } else if (await exists2(osReleaseFile)) {
      return parseDistro(await readFile2(osReleaseFile, "utf-8"));
    } else {
      return;
    }
  }
  exports2.resolveDistro = resolveDistro;
  function parseOpenSSLVersion(input) {
    const match = /^OpenSSL\s(\d+\.\d+)\.\d+/.exec(input);
    if (match) {
      return match[1] + ".x";
    }
    return;
  }
  exports2.parseOpenSSLVersion = parseOpenSSLVersion;
  async function getOpenSSLVersion() {
    const [version, ls] = await Promise.all([
      gracefulExec(`openssl version -v`),
      gracefulExec(`
      ls -l /lib64 | grep ssl;
      ls -l /usr/lib64 | grep ssl;
    `)
    ]);
    if (version) {
      const v = parseOpenSSLVersion(version);
      if (v) {
        return v;
      }
    }
    if (ls) {
      const match = /libssl\.so\.(\d+\.\d+)\.\d+/.exec(ls);
      if (match) {
        return match[1] + ".x";
      }
    }
    return void 0;
  }
  exports2.getOpenSSLVersion = getOpenSSLVersion;
  async function gracefulExec(cmd) {
    return new Promise((resolve) => {
      try {
        child_process_1.exec(cmd, (err, stdout) => {
          resolve(String(stdout));
        });
      } catch (e) {
        resolve(void 0);
        return void 0;
      }
    });
  }
  async function getPlatform2() {
    const {platform, libssl, distro, arch} = await getos();
    if (platform === "darwin" && arch === "arm64") {
      return "darwin-arm64";
    }
    if (platform === "darwin") {
      return "darwin";
    }
    if (platform === "win32") {
      return "windows";
    }
    if (platform === "freebsd") {
      return distro;
    }
    if (platform === "openbsd") {
      return "openbsd";
    }
    if (platform === "netbsd") {
      return "netbsd";
    }
    if (platform === "linux" && arch === "arm64") {
      return `linux-arm-openssl-${libssl}`;
    }
    if (platform === "linux" && distro === "nixos") {
      return "linux-nixos";
    }
    if (platform === "linux" && distro === "musl") {
      return "linux-musl";
    }
    if (platform === "linux" && distro && libssl) {
      return distro + "-openssl-" + libssl;
    }
    if (libssl) {
      return "debian-openssl-" + libssl;
    }
    if (distro) {
      return distro + "-openssl-1.1.x";
    }
    return "debian-openssl-1.1.x";
  }
  exports2.getPlatform = getPlatform2;
});

// ../../node_modules/.pnpm/@prisma+get-platform@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/get-platform/dist/isNodeAPISupported.js
var require_isNodeAPISupported2 = __commonJS2((exports2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : {default: mod2};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.isNodeAPISupported = void 0;
  var fs_12 = __importDefault2(require("fs"));
  var _1 = require_dist11();
  async function isNodeAPISupported() {
    const customLibraryPath = process.env.PRISMA_QUERY_ENGINE_LIBRARY;
    const customLibraryExists = customLibraryPath && fs_12.default.existsSync(customLibraryPath);
    const os2 = await _1.getos();
    if (!customLibraryExists && (os2.arch === "x32" || os2.arch === "ia32")) {
      throw new Error(`Node-API is currently not supported for 32bit Node. Please remove \`nApi\` from the "previewFeatures" attribute in the "generator" block of the "schema.prisma", or remove the "PRISMA_FORCE_NAPI" environment variable.`);
    }
  }
  exports2.isNodeAPISupported = isNodeAPISupported;
});

// ../../node_modules/.pnpm/@prisma+get-platform@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/get-platform/dist/platforms.js
var require_platforms2 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.platforms = void 0;
  exports2.platforms = [
    "darwin",
    "darwin-arm64",
    "debian-openssl-1.0.x",
    "debian-openssl-1.1.x",
    "rhel-openssl-1.0.x",
    "rhel-openssl-1.1.x",
    "linux-arm-openssl-1.1.x",
    "linux-arm-openssl-1.0.x",
    "linux-musl",
    "linux-nixos",
    "windows",
    "freebsd11",
    "freebsd12",
    "openbsd",
    "netbsd",
    "arm"
  ];
});

// ../../node_modules/.pnpm/@prisma+get-platform@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/get-platform/dist/index.js
var require_dist11 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.platforms = exports2.isNodeAPISupported = exports2.getPlatform = exports2.getos = exports2.getNodeAPIName = void 0;
  var getNodeAPIName_1 = require_getNodeAPIName2();
  Object.defineProperty(exports2, "getNodeAPIName", {enumerable: true, get: function() {
    return getNodeAPIName_1.getNodeAPIName;
  }});
  var getPlatform_1 = require_getPlatform2();
  Object.defineProperty(exports2, "getos", {enumerable: true, get: function() {
    return getPlatform_1.getos;
  }});
  Object.defineProperty(exports2, "getPlatform", {enumerable: true, get: function() {
    return getPlatform_1.getPlatform;
  }});
  var isNodeAPISupported_1 = require_isNodeAPISupported2();
  Object.defineProperty(exports2, "isNodeAPISupported", {enumerable: true, get: function() {
    return isNodeAPISupported_1.isNodeAPISupported;
  }});
  var platforms_1 = require_platforms2();
  Object.defineProperty(exports2, "platforms", {enumerable: true, get: function() {
    return platforms_1.platforms;
  }});
});

// ../../node_modules/.pnpm/semver@6.3.0/node_modules/semver/semver.js
var require_semver4 = __commonJS2((exports2, module2) => {
  exports2 = module2.exports = SemVer;
  var debug4;
  if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
    debug4 = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift("SEMVER");
      console.log.apply(console, args);
    };
  } else {
    debug4 = function() {
    };
  }
  exports2.SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER2 = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var re = exports2.re = [];
  var src = exports2.src = [];
  var t = exports2.tokens = {};
  var R = 0;
  function tok(n) {
    t[n] = R++;
  }
  tok("NUMERICIDENTIFIER");
  src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
  tok("NUMERICIDENTIFIERLOOSE");
  src[t.NUMERICIDENTIFIERLOOSE] = "[0-9]+";
  tok("NONNUMERICIDENTIFIER");
  src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
  tok("MAINVERSION");
  src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")";
  tok("MAINVERSIONLOOSE");
  src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")";
  tok("PRERELEASEIDENTIFIER");
  src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
  tok("PRERELEASEIDENTIFIERLOOSE");
  src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
  tok("PRERELEASE");
  src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))";
  tok("PRERELEASELOOSE");
  src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))";
  tok("BUILDIDENTIFIER");
  src[t.BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
  tok("BUILD");
  src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))";
  tok("FULL");
  tok("FULLPLAIN");
  src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?";
  src[t.FULL] = "^" + src[t.FULLPLAIN] + "$";
  tok("LOOSEPLAIN");
  src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?";
  tok("LOOSE");
  src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$";
  tok("GTLT");
  src[t.GTLT] = "((?:<|>)?=?)";
  tok("XRANGEIDENTIFIERLOOSE");
  src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
  tok("XRANGEIDENTIFIER");
  src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*";
  tok("XRANGEPLAIN");
  src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?)?)?";
  tok("XRANGEPLAINLOOSE");
  src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?)?)?";
  tok("XRANGE");
  src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$";
  tok("XRANGELOOSE");
  src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$";
  tok("COERCE");
  src[t.COERCE] = "(^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
  tok("COERCERTL");
  re[t.COERCERTL] = new RegExp(src[t.COERCE], "g");
  tok("LONETILDE");
  src[t.LONETILDE] = "(?:~>?)";
  tok("TILDETRIM");
  src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+";
  re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
  var tildeTrimReplace = "$1~";
  tok("TILDE");
  src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$";
  tok("TILDELOOSE");
  src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$";
  tok("LONECARET");
  src[t.LONECARET] = "(?:\\^)";
  tok("CARETTRIM");
  src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+";
  re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
  var caretTrimReplace = "$1^";
  tok("CARET");
  src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$";
  tok("CARETLOOSE");
  src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$";
  tok("COMPARATORLOOSE");
  src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$";
  tok("COMPARATOR");
  src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$";
  tok("COMPARATORTRIM");
  src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")";
  re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
  var comparatorTrimReplace = "$1$2$3";
  tok("HYPHENRANGE");
  src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")\\s+-\\s+(" + src[t.XRANGEPLAIN] + ")\\s*$";
  tok("HYPHENRANGELOOSE");
  src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[t.XRANGEPLAINLOOSE] + ")\\s*$";
  tok("STAR");
  src[t.STAR] = "(<|>)?=?\\s*\\*";
  for (var i = 0; i < R; i++) {
    debug4(i, src[i]);
    if (!re[i]) {
      re[i] = new RegExp(src[i]);
    }
  }
  exports2.parse = parse2;
  function parse2(version, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version !== "string") {
      return null;
    }
    if (version.length > MAX_LENGTH) {
      return null;
    }
    var r = options.loose ? re[t.LOOSE] : re[t.FULL];
    if (!r.test(version)) {
      return null;
    }
    try {
      return new SemVer(version, options);
    } catch (er) {
      return null;
    }
  }
  exports2.valid = valid;
  function valid(version, options) {
    var v = parse2(version, options);
    return v ? v.version : null;
  }
  exports2.clean = clean;
  function clean(version, options) {
    var s2 = parse2(version.trim().replace(/^[=v]+/, ""), options);
    return s2 ? s2.version : null;
  }
  exports2.SemVer = SemVer;
  function SemVer(version, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      if (version.loose === options.loose) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== "string") {
      throw new TypeError("Invalid Version: " + version);
    }
    if (version.length > MAX_LENGTH) {
      throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
    }
    if (!(this instanceof SemVer)) {
      return new SemVer(version, options);
    }
    debug4("SemVer", version, options);
    this.options = options;
    this.loose = !!options.loose;
    var m2 = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
    if (!m2) {
      throw new TypeError("Invalid Version: " + version);
    }
    this.raw = version;
    this.major = +m2[1];
    this.minor = +m2[2];
    this.patch = +m2[3];
    if (this.major > MAX_SAFE_INTEGER2 || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER2 || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER2 || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m2[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m2[4].split(".").map(function(id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER2) {
            return num;
          }
        }
        return id;
      });
    }
    this.build = m2[5] ? m2[5].split(".") : [];
    this.format();
  }
  SemVer.prototype.format = function() {
    this.version = this.major + "." + this.minor + "." + this.patch;
    if (this.prerelease.length) {
      this.version += "-" + this.prerelease.join(".");
    }
    return this.version;
  };
  SemVer.prototype.toString = function() {
    return this.version;
  };
  SemVer.prototype.compare = function(other) {
    debug4("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return this.compareMain(other) || this.comparePre(other);
  };
  SemVer.prototype.compareMain = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  };
  SemVer.prototype.comparePre = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    var i2 = 0;
    do {
      var a = this.prerelease[i2];
      var b = other.prerelease[i2];
      debug4("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  };
  SemVer.prototype.compareBuild = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    var i2 = 0;
    do {
      var a = this.build[i2];
      var b = other.build[i2];
      debug4("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  };
  SemVer.prototype.inc = function(release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier);
        this.inc("pre", identifier);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier);
        }
        this.inc("pre", identifier);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          var i2 = this.prerelease.length;
          while (--i2 >= 0) {
            if (typeof this.prerelease[i2] === "number") {
              this.prerelease[i2]++;
              i2 = -2;
            }
          }
          if (i2 === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error("invalid increment argument: " + release);
    }
    this.format();
    this.raw = this.version;
    return this;
  };
  exports2.inc = inc;
  function inc(version, release, loose, identifier) {
    if (typeof loose === "string") {
      identifier = loose;
      loose = void 0;
    }
    try {
      return new SemVer(version, loose).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  }
  exports2.diff = diff;
  function diff(version1, version2) {
    if (eq(version1, version2)) {
      return null;
    } else {
      var v1 = parse2(version1);
      var v2 = parse2(version2);
      var prefix = "";
      if (v1.prerelease.length || v2.prerelease.length) {
        prefix = "pre";
        var defaultResult = "prerelease";
      }
      for (var key in v1) {
        if (key === "major" || key === "minor" || key === "patch") {
          if (v1[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }
      return defaultResult;
    }
  }
  exports2.compareIdentifiers = compareIdentifiers;
  var numeric = /^[0-9]+$/;
  function compareIdentifiers(a, b) {
    var anum = numeric.test(a);
    var bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  }
  exports2.rcompareIdentifiers = rcompareIdentifiers;
  function rcompareIdentifiers(a, b) {
    return compareIdentifiers(b, a);
  }
  exports2.major = major;
  function major(a, loose) {
    return new SemVer(a, loose).major;
  }
  exports2.minor = minor;
  function minor(a, loose) {
    return new SemVer(a, loose).minor;
  }
  exports2.patch = patch;
  function patch(a, loose) {
    return new SemVer(a, loose).patch;
  }
  exports2.compare = compare;
  function compare(a, b, loose) {
    return new SemVer(a, loose).compare(new SemVer(b, loose));
  }
  exports2.compareLoose = compareLoose;
  function compareLoose(a, b) {
    return compare(a, b, true);
  }
  exports2.compareBuild = compareBuild;
  function compareBuild(a, b, loose) {
    var versionA = new SemVer(a, loose);
    var versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  }
  exports2.rcompare = rcompare;
  function rcompare(a, b, loose) {
    return compare(b, a, loose);
  }
  exports2.sort = sort;
  function sort(list, loose) {
    return list.sort(function(a, b) {
      return exports2.compareBuild(a, b, loose);
    });
  }
  exports2.rsort = rsort;
  function rsort(list, loose) {
    return list.sort(function(a, b) {
      return exports2.compareBuild(b, a, loose);
    });
  }
  exports2.gt = gt;
  function gt(a, b, loose) {
    return compare(a, b, loose) > 0;
  }
  exports2.lt = lt;
  function lt(a, b, loose) {
    return compare(a, b, loose) < 0;
  }
  exports2.eq = eq;
  function eq(a, b, loose) {
    return compare(a, b, loose) === 0;
  }
  exports2.neq = neq;
  function neq(a, b, loose) {
    return compare(a, b, loose) !== 0;
  }
  exports2.gte = gte;
  function gte(a, b, loose) {
    return compare(a, b, loose) >= 0;
  }
  exports2.lte = lte;
  function lte(a, b, loose) {
    return compare(a, b, loose) <= 0;
  }
  exports2.cmp = cmp;
  function cmp(a, op, b, loose) {
    switch (op) {
      case "===":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a === b;
      case "!==":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError("Invalid operator: " + op);
    }
  }
  exports2.Comparator = Comparator;
  function Comparator(comp, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }
    if (!(this instanceof Comparator)) {
      return new Comparator(comp, options);
    }
    debug4("comparator", comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);
    if (this.semver === ANY) {
      this.value = "";
    } else {
      this.value = this.operator + this.semver.version;
    }
    debug4("comp", this);
  }
  var ANY = {};
  Comparator.prototype.parse = function(comp) {
    var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
    var m2 = comp.match(r);
    if (!m2) {
      throw new TypeError("Invalid comparator: " + comp);
    }
    this.operator = m2[1] !== void 0 ? m2[1] : "";
    if (this.operator === "=") {
      this.operator = "";
    }
    if (!m2[2]) {
      this.semver = ANY;
    } else {
      this.semver = new SemVer(m2[2], this.options.loose);
    }
  };
  Comparator.prototype.toString = function() {
    return this.value;
  };
  Comparator.prototype.test = function(version) {
    debug4("Comparator.test", version, this.options.loose);
    if (this.semver === ANY || version === ANY) {
      return true;
    }
    if (typeof version === "string") {
      try {
        version = new SemVer(version, this.options);
      } catch (er) {
        return false;
      }
    }
    return cmp(version, this.operator, this.semver, this.options);
  };
  Comparator.prototype.intersects = function(comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError("a Comparator is required");
    }
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    var rangeTmp;
    if (this.operator === "") {
      if (this.value === "") {
        return true;
      }
      rangeTmp = new Range(comp.value, options);
      return satisfies(this.value, rangeTmp, options);
    } else if (comp.operator === "") {
      if (comp.value === "") {
        return true;
      }
      rangeTmp = new Range(this.value, options);
      return satisfies(comp.semver, rangeTmp, options);
    }
    var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
    var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
    var sameSemVer = this.semver.version === comp.semver.version;
    var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
    var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
    var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  };
  exports2.Range = Range;
  function Range(range, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (range instanceof Range) {
      if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
        return range;
      } else {
        return new Range(range.raw, options);
      }
    }
    if (range instanceof Comparator) {
      return new Range(range.value, options);
    }
    if (!(this instanceof Range)) {
      return new Range(range, options);
    }
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    this.raw = range;
    this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
      return this.parseRange(range2.trim());
    }, this).filter(function(c) {
      return c.length;
    });
    if (!this.set.length) {
      throw new TypeError("Invalid SemVer Range: " + range);
    }
    this.format();
  }
  Range.prototype.format = function() {
    this.range = this.set.map(function(comps) {
      return comps.join(" ").trim();
    }).join("||").trim();
    return this.range;
  };
  Range.prototype.toString = function() {
    return this.range;
  };
  Range.prototype.parseRange = function(range) {
    var loose = this.options.loose;
    range = range.trim();
    var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
    range = range.replace(hr, hyphenReplace);
    debug4("hyphen replace", range);
    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
    debug4("comparator trim", range, re[t.COMPARATORTRIM]);
    range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
    range = range.replace(re[t.CARETTRIM], caretTrimReplace);
    range = range.split(/\s+/).join(" ");
    var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
    var set = range.split(" ").map(function(comp) {
      return parseComparator(comp, this.options);
    }, this).join(" ").split(/\s+/);
    if (this.options.loose) {
      set = set.filter(function(comp) {
        return !!comp.match(compRe);
      });
    }
    set = set.map(function(comp) {
      return new Comparator(comp, this.options);
    }, this);
    return set;
  };
  Range.prototype.intersects = function(range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError("a Range is required");
    }
    return this.set.some(function(thisComparators) {
      return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
        return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
          return rangeComparators.every(function(rangeComparator) {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  };
  function isSatisfiable(comparators, options) {
    var result = true;
    var remainingComparators = comparators.slice();
    var testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every(function(otherComparator) {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  }
  exports2.toComparators = toComparators;
  function toComparators(range, options) {
    return new Range(range, options).set.map(function(comp) {
      return comp.map(function(c) {
        return c.value;
      }).join(" ").trim().split(" ");
    });
  }
  function parseComparator(comp, options) {
    debug4("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug4("caret", comp);
    comp = replaceTildes(comp, options);
    debug4("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug4("xrange", comp);
    comp = replaceStars(comp, options);
    debug4("stars", comp);
    return comp;
  }
  function isX(id) {
    return !id || id.toLowerCase() === "x" || id === "*";
  }
  function replaceTildes(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceTilde(comp2, options);
    }).join(" ");
  }
  function replaceTilde(comp, options) {
    var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, function(_2, M, m2, p, pr) {
      debug4("tilde", comp, _2, M, m2, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m2)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        ret = ">=" + M + "." + m2 + ".0 <" + M + "." + (+m2 + 1) + ".0";
      } else if (pr) {
        debug4("replaceTilde pr", pr);
        ret = ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + M + "." + (+m2 + 1) + ".0";
      } else {
        ret = ">=" + M + "." + m2 + "." + p + " <" + M + "." + (+m2 + 1) + ".0";
      }
      debug4("tilde return", ret);
      return ret;
    });
  }
  function replaceCarets(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceCaret(comp2, options);
    }).join(" ");
  }
  function replaceCaret(comp, options) {
    debug4("caret", comp, options);
    var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
    return comp.replace(r, function(_2, M, m2, p, pr) {
      debug4("caret", comp, _2, M, m2, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m2)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        if (M === "0") {
          ret = ">=" + M + "." + m2 + ".0 <" + M + "." + (+m2 + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m2 + ".0 <" + (+M + 1) + ".0.0";
        }
      } else if (pr) {
        debug4("replaceCaret pr", pr);
        if (M === "0") {
          if (m2 === "0") {
            ret = ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + M + "." + m2 + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + M + "." + (+m2 + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
        }
      } else {
        debug4("no pr");
        if (M === "0") {
          if (m2 === "0") {
            ret = ">=" + M + "." + m2 + "." + p + " <" + M + "." + m2 + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m2 + "." + p + " <" + M + "." + (+m2 + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m2 + "." + p + " <" + (+M + 1) + ".0.0";
        }
      }
      debug4("caret return", ret);
      return ret;
    });
  }
  function replaceXRanges(comp, options) {
    debug4("replaceXRanges", comp, options);
    return comp.split(/\s+/).map(function(comp2) {
      return replaceXRange(comp2, options);
    }).join(" ");
  }
  function replaceXRange(comp, options) {
    comp = comp.trim();
    var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, function(ret, gtlt, M, m2, p, pr) {
      debug4("xRange", comp, ret, gtlt, M, m2, p, pr);
      var xM = isX(M);
      var xm = xM || isX(m2);
      var xp = xm || isX(p);
      var anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m2 = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m2 = 0;
            p = 0;
          } else {
            m2 = +m2 + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m2 = +m2 + 1;
          }
        }
        ret = gtlt + M + "." + m2 + "." + p + pr;
      } else if (xm) {
        ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr;
      } else if (xp) {
        ret = ">=" + M + "." + m2 + ".0" + pr + " <" + M + "." + (+m2 + 1) + ".0" + pr;
      }
      debug4("xRange return", ret);
      return ret;
    });
  }
  function replaceStars(comp, options) {
    debug4("replaceStars", comp, options);
    return comp.trim().replace(re[t.STAR], "");
  }
  function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = ">=" + fM + ".0.0";
    } else if (isX(fp)) {
      from = ">=" + fM + "." + fm + ".0";
    } else {
      from = ">=" + from;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = "<" + (+tM + 1) + ".0.0";
    } else if (isX(tp)) {
      to = "<" + tM + "." + (+tm + 1) + ".0";
    } else if (tpr) {
      to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
    } else {
      to = "<=" + to;
    }
    return (from + " " + to).trim();
  }
  Range.prototype.test = function(version) {
    if (!version) {
      return false;
    }
    if (typeof version === "string") {
      try {
        version = new SemVer(version, this.options);
      } catch (er) {
        return false;
      }
    }
    for (var i2 = 0; i2 < this.set.length; i2++) {
      if (testSet(this.set[i2], version, this.options)) {
        return true;
      }
    }
    return false;
  };
  function testSet(set, version, options) {
    for (var i2 = 0; i2 < set.length; i2++) {
      if (!set[i2].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (i2 = 0; i2 < set.length; i2++) {
        debug4(set[i2].semver);
        if (set[i2].semver === ANY) {
          continue;
        }
        if (set[i2].semver.prerelease.length > 0) {
          var allowed = set[i2].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  }
  exports2.satisfies = satisfies;
  function satisfies(version, range, options) {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version);
  }
  exports2.maxSatisfying = maxSatisfying;
  function maxSatisfying(versions, range, options) {
    var max2 = null;
    var maxSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!max2 || maxSV.compare(v) === -1) {
          max2 = v;
          maxSV = new SemVer(max2, options);
        }
      }
    });
    return max2;
  }
  exports2.minSatisfying = minSatisfying;
  function minSatisfying(versions, range, options) {
    var min2 = null;
    var minSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!min2 || minSV.compare(v) === 1) {
          min2 = v;
          minSV = new SemVer(min2, options);
        }
      }
    });
    return min2;
  }
  exports2.minVersion = minVersion;
  function minVersion(range, loose) {
    range = new Range(range, loose);
    var minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (var i2 = 0; i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      comparators.forEach(function(comparator) {
        var compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!minver || gt(minver, compver)) {
              minver = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + comparator.operator);
        }
      });
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  }
  exports2.validRange = validRange;
  function validRange(range, options) {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  }
  exports2.ltr = ltr;
  function ltr(version, range, options) {
    return outside(version, range, "<", options);
  }
  exports2.gtr = gtr;
  function gtr(version, range, options) {
    return outside(version, range, ">", options);
  }
  exports2.outside = outside;
  function outside(version, range, hilo, options) {
    version = new SemVer(version, options);
    range = new Range(range, options);
    var gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) {
      return false;
    }
    for (var i2 = 0; i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      var high = null;
      var low = null;
      comparators.forEach(function(comparator) {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }
    return true;
  }
  exports2.prerelease = prerelease;
  function prerelease(version, options) {
    var parsed = parse2(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  }
  exports2.intersects = intersects;
  function intersects(r1, r2, options) {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2);
  }
  exports2.coerce = coerce;
  function coerce(version, options) {
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version === "number") {
      version = String(version);
    }
    if (typeof version !== "string") {
      return null;
    }
    options = options || {};
    var match = null;
    if (!options.rtl) {
      match = version.match(re[t.COERCE]);
    } else {
      var next;
      while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
      }
      re[t.COERCERTL].lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    return parse2(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options);
  }
});

// ../../node_modules/.pnpm/make-dir@3.1.0/node_modules/make-dir/index.js
var require_make_dir2 = __commonJS2((exports2, module2) => {
  "use strict";
  var fs2 = require("fs");
  var path4 = require("path");
  var {promisify: promisify2} = require("util");
  var semver2 = require_semver4();
  var useNativeRecursiveOption2 = semver2.satisfies(process.version, ">=10.12.0");
  var checkPath2 = (pth) => {
    if (process.platform === "win32") {
      const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path4.parse(pth).root, ""));
      if (pathHasInvalidWinCharacters) {
        const error = new Error(`Path contains invalid characters: ${pth}`);
        error.code = "EINVAL";
        throw error;
      }
    }
  };
  var processOptions2 = (options) => {
    const defaults = {
      mode: 511,
      fs: fs2
    };
    return {
      ...defaults,
      ...options
    };
  };
  var permissionError2 = (pth) => {
    const error = new Error(`operation not permitted, mkdir '${pth}'`);
    error.code = "EPERM";
    error.errno = -4048;
    error.path = pth;
    error.syscall = "mkdir";
    return error;
  };
  var makeDir2 = async (input, options) => {
    checkPath2(input);
    options = processOptions2(options);
    const mkdir2 = promisify2(options.fs.mkdir);
    const stat2 = promisify2(options.fs.stat);
    if (useNativeRecursiveOption2 && options.fs.mkdir === fs2.mkdir) {
      const pth = path4.resolve(input);
      await mkdir2(pth, {
        mode: options.mode,
        recursive: true
      });
      return pth;
    }
    const make = async (pth) => {
      try {
        await mkdir2(pth, options.mode);
        return pth;
      } catch (error) {
        if (error.code === "EPERM") {
          throw error;
        }
        if (error.code === "ENOENT") {
          if (path4.dirname(pth) === pth) {
            throw permissionError2(pth);
          }
          if (error.message.includes("null bytes")) {
            throw error;
          }
          await make(path4.dirname(pth));
          return make(pth);
        }
        try {
          const stats = await stat2(pth);
          if (!stats.isDirectory()) {
            throw new Error("The path is not a directory");
          }
        } catch (_2) {
          throw error;
        }
        return pth;
      }
    };
    return make(path4.resolve(input));
  };
  module2.exports = makeDir2;
  module2.exports.sync = (input, options) => {
    checkPath2(input);
    options = processOptions2(options);
    if (useNativeRecursiveOption2 && options.fs.mkdirSync === fs2.mkdirSync) {
      const pth = path4.resolve(input);
      fs2.mkdirSync(pth, {
        mode: options.mode,
        recursive: true
      });
      return pth;
    }
    const make = (pth) => {
      try {
        options.fs.mkdirSync(pth, options.mode);
      } catch (error) {
        if (error.code === "EPERM") {
          throw error;
        }
        if (error.code === "ENOENT") {
          if (path4.dirname(pth) === pth) {
            throw permissionError2(pth);
          }
          if (error.message.includes("null bytes")) {
            throw error;
          }
          make(path4.dirname(pth));
          return make(pth);
        }
        try {
          if (!options.fs.statSync(pth).isDirectory()) {
            throw new Error("The path is not a directory");
          }
        } catch (_2) {
          throw error;
        }
      }
      return pth;
    };
    return make(path4.resolve(input));
  };
});

// ../../node_modules/.pnpm/p-map@2.1.0/node_modules/p-map/index.js
var require_p_map2 = __commonJS2((exports2, module2) => {
  "use strict";
  var pMap = (iterable, mapper, options) => new Promise((resolve, reject) => {
    options = Object.assign({
      concurrency: Infinity
    }, options);
    if (typeof mapper !== "function") {
      throw new TypeError("Mapper function is required");
    }
    const {concurrency} = options;
    if (!(typeof concurrency === "number" && concurrency >= 1)) {
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${concurrency}\` (${typeof concurrency})`);
    }
    const ret = [];
    const iterator = iterable[Symbol.iterator]();
    let isRejected = false;
    let isIterableDone = false;
    let resolvingCount = 0;
    let currentIndex = 0;
    const next = () => {
      if (isRejected) {
        return;
      }
      const nextItem = iterator.next();
      const i = currentIndex;
      currentIndex++;
      if (nextItem.done) {
        isIterableDone = true;
        if (resolvingCount === 0) {
          resolve(ret);
        }
        return;
      }
      resolvingCount++;
      Promise.resolve(nextItem.value).then((element) => mapper(element, i)).then((value) => {
        ret[i] = value;
        resolvingCount--;
        next();
      }, (error) => {
        isRejected = true;
        reject(error);
      });
    };
    for (let i = 0; i < concurrency; i++) {
      next();
      if (isIterableDone) {
        break;
      }
    }
  });
  module2.exports = pMap;
  module2.exports.default = pMap;
});

// ../../node_modules/.pnpm/p-filter@2.1.0/node_modules/p-filter/index.js
var require_p_filter2 = __commonJS2((exports2, module2) => {
  "use strict";
  var pMap = require_p_map2();
  var pFilter = async (iterable, filterer, options) => {
    const values = await pMap(iterable, (element, index) => Promise.all([filterer(element, index), element]), options);
    return values.filter((value) => Boolean(value[0])).map((value) => value[1]);
  };
  module2.exports = pFilter;
  module2.exports.default = pFilter;
});

// ../../node_modules/.pnpm/temp-dir@2.0.0/node_modules/temp-dir/index.js
var require_temp_dir2 = __commonJS2((exports2, module2) => {
  "use strict";
  var fs2 = require("fs");
  var os2 = require("os");
  var tempDirectorySymbol = Symbol.for("__RESOLVED_TEMP_DIRECTORY__");
  if (!global[tempDirectorySymbol]) {
    Object.defineProperty(global, tempDirectorySymbol, {
      value: fs2.realpathSync(os2.tmpdir())
    });
  }
  module2.exports = global[tempDirectorySymbol];
});

// ../../node_modules/.pnpm/@prisma+fetch-engine@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/fetch-engine/dist/chmod.js
var require_chmod2 = __commonJS2((exports2) => {
  "use strict";
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, {enumerable: true, get: function() {
      return m2[k];
    }});
  } : function(o, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m2[k];
  });
  var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {enumerable: true, value: v});
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports2 && exports2.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
          __createBinding(result, mod2, k);
    }
    __setModuleDefault(result, mod2);
    return result;
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  var fs2 = __importStar(require("fs"));
  function default_1(file) {
    const s2 = fs2.statSync(file);
    const newMode = s2.mode | 64 | 8 | 1;
    if (s2.mode === newMode)
      return;
    const base8 = newMode.toString(8).slice(-3);
    fs2.chmodSync(file, base8);
  }
  exports2.default = default_1;
});

// ../../node_modules/.pnpm/commondir@1.0.1/node_modules/commondir/index.js
var require_commondir2 = __commonJS2((exports2, module2) => {
  var path4 = require("path");
  module2.exports = function(basedir, relfiles) {
    if (relfiles) {
      var files = relfiles.map(function(r) {
        return path4.resolve(basedir, r);
      });
    } else {
      var files = basedir;
    }
    var res = files.slice(1).reduce(function(ps, file) {
      if (!file.match(/^([A-Za-z]:)?\/|\\/)) {
        throw new Error("relative path without a basedir");
      }
      var xs = file.split(/\/+|\\+/);
      for (var i = 0; ps[i] === xs[i] && i < Math.min(ps.length, xs.length); i++)
        ;
      return ps.slice(0, i);
    }, files[0].split(/\/+|\\+/));
    return res.length > 1 ? res.join("/") : "/";
  };
});

// ../../node_modules/.pnpm/pkg-dir@4.2.0/node_modules/pkg-dir/index.js
var require_pkg_dir2 = __commonJS2((exports2, module2) => {
  "use strict";
  var path4 = require("path");
  var findUp = require_find_up2();
  var pkgDir = async (cwd) => {
    const filePath = await findUp("package.json", {cwd});
    return filePath && path4.dirname(filePath);
  };
  module2.exports = pkgDir;
  module2.exports.default = pkgDir;
  module2.exports.sync = (cwd) => {
    const filePath = findUp.sync("package.json", {cwd});
    return filePath && path4.dirname(filePath);
  };
});

// ../../node_modules/.pnpm/find-cache-dir@3.3.1/node_modules/find-cache-dir/index.js
var require_find_cache_dir2 = __commonJS2((exports2, module2) => {
  "use strict";
  var path4 = require("path");
  var fs2 = require("fs");
  var commonDir = require_commondir2();
  var pkgDir = require_pkg_dir2();
  var makeDir2 = require_make_dir2();
  var {env: env2, cwd} = process;
  var isWritable = (path5) => {
    try {
      fs2.accessSync(path5, fs2.constants.W_OK);
      return true;
    } catch (_2) {
      return false;
    }
  };
  function useDirectory(directory, options) {
    if (options.create) {
      makeDir2.sync(directory);
    }
    if (options.thunk) {
      return (...arguments_) => path4.join(directory, ...arguments_);
    }
    return directory;
  }
  function getNodeModuleDirectory(directory) {
    const nodeModules = path4.join(directory, "node_modules");
    if (!isWritable(nodeModules) && (fs2.existsSync(nodeModules) || !isWritable(path4.join(directory)))) {
      return;
    }
    return nodeModules;
  }
  module2.exports = (options = {}) => {
    if (env2.CACHE_DIR && !["true", "false", "1", "0"].includes(env2.CACHE_DIR)) {
      return useDirectory(path4.join(env2.CACHE_DIR, "find-cache-dir"), options);
    }
    let {cwd: directory = cwd()} = options;
    if (options.files) {
      directory = commonDir(directory, options.files);
    }
    directory = pkgDir.sync(directory);
    if (!directory) {
      return;
    }
    const nodeModules = getNodeModuleDirectory(directory);
    if (!nodeModules) {
      return void 0;
    }
    return useDirectory(path4.join(directory, "node_modules", ".cache", options.name), options);
  };
});

// ../../node_modules/.pnpm/@prisma+fetch-engine@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/fetch-engine/dist/util.js
var require_util4 = __commonJS2((exports2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : {default: mod2};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getDownloadUrl = exports2.getCacheDir = exports2.getRootCacheDir = void 0;
  var debug_12 = __importDefault2(require_dist10());
  var get_platform_12 = require_dist11();
  var find_cache_dir_1 = __importDefault2(require_find_cache_dir2());
  var fs_12 = __importDefault2(require("fs"));
  var make_dir_12 = __importDefault2(require_make_dir2());
  var os_1 = __importDefault2(require("os"));
  var path_12 = __importDefault2(require("path"));
  var download_1 = require_download2();
  var debug4 = debug_12.default("prisma:cache-dir");
  async function getRootCacheDir() {
    if (os_1.default.platform() === "win32") {
      const cacheDir = find_cache_dir_1.default({name: "prisma", create: true});
      if (cacheDir) {
        return cacheDir;
      }
      if (process.env.APPDATA) {
        return path_12.default.join(process.env.APPDATA, "Prisma");
      }
    }
    if (process.env.AWS_LAMBDA_FUNCTION_VERSION) {
      try {
        await make_dir_12.default(`/tmp/prisma-download`);
        return `/tmp/prisma-download`;
      } catch (e) {
        return null;
      }
    }
    return path_12.default.join(os_1.default.homedir(), ".cache/prisma");
  }
  exports2.getRootCacheDir = getRootCacheDir;
  async function getCacheDir(channel2, version, platform) {
    const rootCacheDir = await getRootCacheDir();
    if (!rootCacheDir) {
      return null;
    }
    const cacheDir = path_12.default.join(rootCacheDir, channel2, version, platform);
    try {
      if (!fs_12.default.existsSync(cacheDir)) {
        await make_dir_12.default(cacheDir);
      }
    } catch (e) {
      debug4("The following error is being caught and just there for debugging:");
      debug4(e);
      return null;
    }
    return cacheDir;
  }
  exports2.getCacheDir = getCacheDir;
  function getDownloadUrl(channel2, version, platform, binaryName, extension = ".gz") {
    const baseUrl = process.env.PRISMA_BINARIES_MIRROR || "https://binaries.prisma.sh";
    const finalExtension = platform === "windows" && download_1.BinaryType.libqueryEngine !== binaryName ? `.exe${extension}` : extension;
    if (binaryName === download_1.BinaryType.libqueryEngine) {
      binaryName = get_platform_12.getNodeAPIName(platform, "url");
    }
    return `${baseUrl}/${channel2}/${version}/${platform}/${binaryName}${finalExtension}`;
  }
  exports2.getDownloadUrl = getDownloadUrl;
});

// ../../node_modules/.pnpm/fs.realpath@1.0.0/node_modules/fs.realpath/old.js
var require_old2 = __commonJS2((exports2) => {
  var pathModule = require("path");
  var isWindows = process.platform === "win32";
  var fs2 = require("fs");
  var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
  function rethrow() {
    var callback;
    if (DEBUG) {
      var backtrace = new Error();
      callback = debugCallback;
    } else
      callback = missingCallback;
    return callback;
    function debugCallback(err) {
      if (err) {
        backtrace.message = err.message;
        err = backtrace;
        missingCallback(err);
      }
    }
    function missingCallback(err) {
      if (err) {
        if (process.throwDeprecation)
          throw err;
        else if (!process.noDeprecation) {
          var msg = "fs: missing callback " + (err.stack || err.message);
          if (process.traceDeprecation)
            console.trace(msg);
          else
            console.error(msg);
        }
      }
    }
  }
  function maybeCallback(cb) {
    return typeof cb === "function" ? cb : rethrow();
  }
  var normalize = pathModule.normalize;
  if (isWindows) {
    nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
  } else {
    nextPartRe = /(.*?)(?:[\/]+|$)/g;
  }
  var nextPartRe;
  if (isWindows) {
    splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
  } else {
    splitRootRe = /^[\/]*/;
  }
  var splitRootRe;
  exports2.realpathSync = function realpathSync(p, cache) {
    p = pathModule.resolve(p);
    if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
      return cache[p];
    }
    var original = p, seenLinks = {}, knownHard = {};
    var pos;
    var current;
    var base;
    var previous;
    start();
    function start() {
      var m2 = splitRootRe.exec(p);
      pos = m2[0].length;
      current = m2[0];
      base = m2[0];
      previous = "";
      if (isWindows && !knownHard[base]) {
        fs2.lstatSync(base);
        knownHard[base] = true;
      }
    }
    while (pos < p.length) {
      nextPartRe.lastIndex = pos;
      var result = nextPartRe.exec(p);
      previous = current;
      current += result[0];
      base = previous + result[1];
      pos = nextPartRe.lastIndex;
      if (knownHard[base] || cache && cache[base] === base) {
        continue;
      }
      var resolvedLink;
      if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
        resolvedLink = cache[base];
      } else {
        var stat2 = fs2.lstatSync(base);
        if (!stat2.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache)
            cache[base] = base;
          continue;
        }
        var linkTarget = null;
        if (!isWindows) {
          var id = stat2.dev.toString(32) + ":" + stat2.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            linkTarget = seenLinks[id];
          }
        }
        if (linkTarget === null) {
          fs2.statSync(base);
          linkTarget = fs2.readlinkSync(base);
        }
        resolvedLink = pathModule.resolve(previous, linkTarget);
        if (cache)
          cache[base] = resolvedLink;
        if (!isWindows)
          seenLinks[id] = linkTarget;
      }
      p = pathModule.resolve(resolvedLink, p.slice(pos));
      start();
    }
    if (cache)
      cache[original] = p;
    return p;
  };
  exports2.realpath = function realpath(p, cache, cb) {
    if (typeof cb !== "function") {
      cb = maybeCallback(cache);
      cache = null;
    }
    p = pathModule.resolve(p);
    if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
      return process.nextTick(cb.bind(null, null, cache[p]));
    }
    var original = p, seenLinks = {}, knownHard = {};
    var pos;
    var current;
    var base;
    var previous;
    start();
    function start() {
      var m2 = splitRootRe.exec(p);
      pos = m2[0].length;
      current = m2[0];
      base = m2[0];
      previous = "";
      if (isWindows && !knownHard[base]) {
        fs2.lstat(base, function(err) {
          if (err)
            return cb(err);
          knownHard[base] = true;
          LOOP();
        });
      } else {
        process.nextTick(LOOP);
      }
    }
    function LOOP() {
      if (pos >= p.length) {
        if (cache)
          cache[original] = p;
        return cb(null, p);
      }
      nextPartRe.lastIndex = pos;
      var result = nextPartRe.exec(p);
      previous = current;
      current += result[0];
      base = previous + result[1];
      pos = nextPartRe.lastIndex;
      if (knownHard[base] || cache && cache[base] === base) {
        return process.nextTick(LOOP);
      }
      if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
        return gotResolvedLink(cache[base]);
      }
      return fs2.lstat(base, gotStat);
    }
    function gotStat(err, stat2) {
      if (err)
        return cb(err);
      if (!stat2.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache)
          cache[base] = base;
        return process.nextTick(LOOP);
      }
      if (!isWindows) {
        var id = stat2.dev.toString(32) + ":" + stat2.ino.toString(32);
        if (seenLinks.hasOwnProperty(id)) {
          return gotTarget(null, seenLinks[id], base);
        }
      }
      fs2.stat(base, function(err2) {
        if (err2)
          return cb(err2);
        fs2.readlink(base, function(err3, target) {
          if (!isWindows)
            seenLinks[id] = target;
          gotTarget(err3, target);
        });
      });
    }
    function gotTarget(err, target, base2) {
      if (err)
        return cb(err);
      var resolvedLink = pathModule.resolve(previous, target);
      if (cache)
        cache[base2] = resolvedLink;
      gotResolvedLink(resolvedLink);
    }
    function gotResolvedLink(resolvedLink) {
      p = pathModule.resolve(resolvedLink, p.slice(pos));
      start();
    }
  };
});

// ../../node_modules/.pnpm/fs.realpath@1.0.0/node_modules/fs.realpath/index.js
var require_fs6 = __commonJS2((exports2, module2) => {
  module2.exports = realpath;
  realpath.realpath = realpath;
  realpath.sync = realpathSync;
  realpath.realpathSync = realpathSync;
  realpath.monkeypatch = monkeypatch;
  realpath.unmonkeypatch = unmonkeypatch;
  var fs2 = require("fs");
  var origRealpath = fs2.realpath;
  var origRealpathSync = fs2.realpathSync;
  var version = process.version;
  var ok = /^v[0-5]\./.test(version);
  var old = require_old2();
  function newError(er) {
    return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
  }
  function realpath(p, cache, cb) {
    if (ok) {
      return origRealpath(p, cache, cb);
    }
    if (typeof cache === "function") {
      cb = cache;
      cache = null;
    }
    origRealpath(p, cache, function(er, result) {
      if (newError(er)) {
        old.realpath(p, cache, cb);
      } else {
        cb(er, result);
      }
    });
  }
  function realpathSync(p, cache) {
    if (ok) {
      return origRealpathSync(p, cache);
    }
    try {
      return origRealpathSync(p, cache);
    } catch (er) {
      if (newError(er)) {
        return old.realpathSync(p, cache);
      } else {
        throw er;
      }
    }
  }
  function monkeypatch() {
    fs2.realpath = realpath;
    fs2.realpathSync = realpathSync;
  }
  function unmonkeypatch() {
    fs2.realpath = origRealpath;
    fs2.realpathSync = origRealpathSync;
  }
});

// ../../node_modules/.pnpm/concat-map@0.0.1/node_modules/concat-map/index.js
var require_concat_map2 = __commonJS2((exports2, module2) => {
  module2.exports = function(xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
      var x = fn(xs[i], i);
      if (isArray(x))
        res.push.apply(res, x);
      else
        res.push(x);
    }
    return res;
  };
  var isArray = Array.isArray || function(xs) {
    return Object.prototype.toString.call(xs) === "[object Array]";
  };
});

// ../../node_modules/.pnpm/balanced-match@1.0.0/node_modules/balanced-match/index.js
var require_balanced_match2 = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = balanced;
  function balanced(a, b, str) {
    if (a instanceof RegExp)
      a = maybeMatch(a, str);
    if (b instanceof RegExp)
      b = maybeMatch(b, str);
    var r = range(a, b, str);
    return r && {
      start: r[0],
      end: r[1],
      pre: str.slice(0, r[0]),
      body: str.slice(r[0] + a.length, r[1]),
      post: str.slice(r[1] + b.length)
    };
  }
  function maybeMatch(reg, str) {
    var m2 = str.match(reg);
    return m2 ? m2[0] : null;
  }
  balanced.range = range;
  function range(a, b, str) {
    var begs, beg, left, right, result;
    var ai = str.indexOf(a);
    var bi = str.indexOf(b, ai + 1);
    var i = ai;
    if (ai >= 0 && bi > 0) {
      begs = [];
      left = str.length;
      while (i >= 0 && !result) {
        if (i == ai) {
          begs.push(i);
          ai = str.indexOf(a, i + 1);
        } else if (begs.length == 1) {
          result = [begs.pop(), bi];
        } else {
          beg = begs.pop();
          if (beg < left) {
            left = beg;
            right = bi;
          }
          bi = str.indexOf(b, i + 1);
        }
        i = ai < bi && ai >= 0 ? ai : bi;
      }
      if (begs.length) {
        result = [left, right];
      }
    }
    return result;
  }
});

// ../../node_modules/.pnpm/brace-expansion@1.1.11/node_modules/brace-expansion/index.js
var require_brace_expansion2 = __commonJS2((exports2, module2) => {
  var concatMap = require_concat_map2();
  var balanced = require_balanced_match2();
  module2.exports = expandTop;
  var escSlash = "\0SLASH" + Math.random() + "\0";
  var escOpen = "\0OPEN" + Math.random() + "\0";
  var escClose = "\0CLOSE" + Math.random() + "\0";
  var escComma = "\0COMMA" + Math.random() + "\0";
  var escPeriod = "\0PERIOD" + Math.random() + "\0";
  function numeric(str) {
    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
  }
  function escapeBraces(str) {
    return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  }
  function unescapeBraces(str) {
    return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  }
  function parseCommaParts(str) {
    if (!str)
      return [""];
    var parts = [];
    var m2 = balanced("{", "}", str);
    if (!m2)
      return str.split(",");
    var pre = m2.pre;
    var body = m2.body;
    var post = m2.post;
    var p = pre.split(",");
    p[p.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    if (post.length) {
      p[p.length - 1] += postParts.shift();
      p.push.apply(p, postParts);
    }
    parts.push.apply(parts, p);
    return parts;
  }
  function expandTop(str) {
    if (!str)
      return [];
    if (str.substr(0, 2) === "{}") {
      str = "\\{\\}" + str.substr(2);
    }
    return expand(escapeBraces(str), true).map(unescapeBraces);
  }
  function embrace(str) {
    return "{" + str + "}";
  }
  function isPadded(el) {
    return /^-?0\d/.test(el);
  }
  function lte(i, y2) {
    return i <= y2;
  }
  function gte(i, y2) {
    return i >= y2;
  }
  function expand(str, isTop) {
    var expansions = [];
    var m2 = balanced("{", "}", str);
    if (!m2 || /\$$/.test(m2.pre))
      return [str];
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m2.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m2.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m2.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m2.post.match(/,.*\}/)) {
        str = m2.pre + "{" + m2.body + escClose + m2.post;
        return expand(str);
      }
      return [str];
    }
    var n;
    if (isSequence) {
      n = m2.body.split(/\.\./);
    } else {
      n = parseCommaParts(m2.body);
      if (n.length === 1) {
        n = expand(n[0], false).map(embrace);
        if (n.length === 1) {
          var post = m2.post.length ? expand(m2.post, false) : [""];
          return post.map(function(p) {
            return m2.pre + n[0] + p;
          });
        }
      }
    }
    var pre = m2.pre;
    var post = m2.post.length ? expand(m2.post, false) : [""];
    var N;
    if (isSequence) {
      var x = numeric(n[0]);
      var y2 = numeric(n[1]);
      var width = Math.max(n[0].length, n[1].length);
      var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
      var test = lte;
      var reverse = y2 < x;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      var pad = n.some(isPadded);
      N = [];
      for (var i = x; test(i, y2); i += incr) {
        var c;
        if (isAlphaSequence) {
          c = String.fromCharCode(i);
          if (c === "\\")
            c = "";
        } else {
          c = String(i);
          if (pad) {
            var need = width - c.length;
            if (need > 0) {
              var z = new Array(need + 1).join("0");
              if (i < 0)
                c = "-" + z + c.slice(1);
              else
                c = z + c;
            }
          }
        }
        N.push(c);
      }
    } else {
      N = concatMap(n, function(el) {
        return expand(el, false);
      });
    }
    for (var j = 0; j < N.length; j++) {
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion)
          expansions.push(expansion);
      }
    }
    return expansions;
  }
});

// ../../node_modules/.pnpm/minimatch@3.0.4/node_modules/minimatch/minimatch.js
var require_minimatch2 = __commonJS2((exports2, module2) => {
  module2.exports = minimatch;
  minimatch.Minimatch = Minimatch;
  var path4 = {sep: "/"};
  try {
    path4 = require("path");
  } catch (er) {
  }
  var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
  var expand = require_brace_expansion2();
  var plTypes = {
    "!": {open: "(?:(?!(?:", close: "))[^/]*?)"},
    "?": {open: "(?:", close: ")?"},
    "+": {open: "(?:", close: ")+"},
    "*": {open: "(?:", close: ")*"},
    "@": {open: "(?:", close: ")"}
  };
  var qmark = "[^/]";
  var star = qmark + "*?";
  var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
  var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
  var reSpecials = charSet("().*{}+?[]^$\\!");
  function charSet(s2) {
    return s2.split("").reduce(function(set, c) {
      set[c] = true;
      return set;
    }, {});
  }
  var slashSplit = /\/+/;
  minimatch.filter = filter;
  function filter(pattern, options) {
    options = options || {};
    return function(p, i, list) {
      return minimatch(p, pattern, options);
    };
  }
  function ext(a, b) {
    a = a || {};
    b = b || {};
    var t = {};
    Object.keys(b).forEach(function(k) {
      t[k] = b[k];
    });
    Object.keys(a).forEach(function(k) {
      t[k] = a[k];
    });
    return t;
  }
  minimatch.defaults = function(def) {
    if (!def || !Object.keys(def).length)
      return minimatch;
    var orig = minimatch;
    var m2 = function minimatch2(p, pattern, options) {
      return orig.minimatch(p, pattern, ext(def, options));
    };
    m2.Minimatch = function Minimatch2(pattern, options) {
      return new orig.Minimatch(pattern, ext(def, options));
    };
    return m2;
  };
  Minimatch.defaults = function(def) {
    if (!def || !Object.keys(def).length)
      return Minimatch;
    return minimatch.defaults(def).Minimatch;
  };
  function minimatch(p, pattern, options) {
    if (typeof pattern !== "string") {
      throw new TypeError("glob pattern string required");
    }
    if (!options)
      options = {};
    if (!options.nocomment && pattern.charAt(0) === "#") {
      return false;
    }
    if (pattern.trim() === "")
      return p === "";
    return new Minimatch(pattern, options).match(p);
  }
  function Minimatch(pattern, options) {
    if (!(this instanceof Minimatch)) {
      return new Minimatch(pattern, options);
    }
    if (typeof pattern !== "string") {
      throw new TypeError("glob pattern string required");
    }
    if (!options)
      options = {};
    pattern = pattern.trim();
    if (path4.sep !== "/") {
      pattern = pattern.split(path4.sep).join("/");
    }
    this.options = options;
    this.set = [];
    this.pattern = pattern;
    this.regexp = null;
    this.negate = false;
    this.comment = false;
    this.empty = false;
    this.make();
  }
  Minimatch.prototype.debug = function() {
  };
  Minimatch.prototype.make = make;
  function make() {
    if (this._made)
      return;
    var pattern = this.pattern;
    var options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    var set = this.globSet = this.braceExpand();
    if (options.debug)
      this.debug = console.error;
    this.debug(this.pattern, set);
    set = this.globParts = set.map(function(s2) {
      return s2.split(slashSplit);
    });
    this.debug(this.pattern, set);
    set = set.map(function(s2, si, set2) {
      return s2.map(this.parse, this);
    }, this);
    this.debug(this.pattern, set);
    set = set.filter(function(s2) {
      return s2.indexOf(false) === -1;
    });
    this.debug(this.pattern, set);
    this.set = set;
  }
  Minimatch.prototype.parseNegate = parseNegate;
  function parseNegate() {
    var pattern = this.pattern;
    var negate = false;
    var options = this.options;
    var negateOffset = 0;
    if (options.nonegate)
      return;
    for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.substr(negateOffset);
    this.negate = negate;
  }
  minimatch.braceExpand = function(pattern, options) {
    return braceExpand(pattern, options);
  };
  Minimatch.prototype.braceExpand = braceExpand;
  function braceExpand(pattern, options) {
    if (!options) {
      if (this instanceof Minimatch) {
        options = this.options;
      } else {
        options = {};
      }
    }
    pattern = typeof pattern === "undefined" ? this.pattern : pattern;
    if (typeof pattern === "undefined") {
      throw new TypeError("undefined pattern");
    }
    if (options.nobrace || !pattern.match(/\{.*\}/)) {
      return [pattern];
    }
    return expand(pattern);
  }
  Minimatch.prototype.parse = parse2;
  var SUBPARSE = {};
  function parse2(pattern, isSub) {
    if (pattern.length > 1024 * 64) {
      throw new TypeError("pattern is too long");
    }
    var options = this.options;
    if (!options.noglobstar && pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    var re = "";
    var hasMagic = !!options.nocase;
    var escaping = false;
    var patternListStack = [];
    var negativeLists = [];
    var stateChar;
    var inClass = false;
    var reClassStart = -1;
    var classStart = -1;
    var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
    var self2 = this;
    function clearStateChar() {
      if (stateChar) {
        switch (stateChar) {
          case "*":
            re += star;
            hasMagic = true;
            break;
          case "?":
            re += qmark;
            hasMagic = true;
            break;
          default:
            re += "\\" + stateChar;
            break;
        }
        self2.debug("clearStateChar %j %j", stateChar, re);
        stateChar = false;
      }
    }
    for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
      this.debug("%s	%s %s %j", pattern, i, re, c);
      if (escaping && reSpecials[c]) {
        re += "\\" + c;
        escaping = false;
        continue;
      }
      switch (c) {
        case "/":
          return false;
        case "\\":
          clearStateChar();
          escaping = true;
          continue;
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
          if (inClass) {
            this.debug("  in class");
            if (c === "!" && i === classStart + 1)
              c = "^";
            re += c;
            continue;
          }
          self2.debug("call clearStateChar %j", stateChar);
          clearStateChar();
          stateChar = c;
          if (options.noext)
            clearStateChar();
          continue;
        case "(":
          if (inClass) {
            re += "(";
            continue;
          }
          if (!stateChar) {
            re += "\\(";
            continue;
          }
          patternListStack.push({
            type: stateChar,
            start: i - 1,
            reStart: re.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close
          });
          re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
          this.debug("plType %j %j", stateChar, re);
          stateChar = false;
          continue;
        case ")":
          if (inClass || !patternListStack.length) {
            re += "\\)";
            continue;
          }
          clearStateChar();
          hasMagic = true;
          var pl = patternListStack.pop();
          re += pl.close;
          if (pl.type === "!") {
            negativeLists.push(pl);
          }
          pl.reEnd = re.length;
          continue;
        case "|":
          if (inClass || !patternListStack.length || escaping) {
            re += "\\|";
            escaping = false;
            continue;
          }
          clearStateChar();
          re += "|";
          continue;
        case "[":
          clearStateChar();
          if (inClass) {
            re += "\\" + c;
            continue;
          }
          inClass = true;
          classStart = i;
          reClassStart = re.length;
          re += c;
          continue;
        case "]":
          if (i === classStart + 1 || !inClass) {
            re += "\\" + c;
            escaping = false;
            continue;
          }
          if (inClass) {
            var cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + cs + "]");
            } catch (er) {
              var sp = this.parse(cs, SUBPARSE);
              re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
              hasMagic = hasMagic || sp[1];
              inClass = false;
              continue;
            }
          }
          hasMagic = true;
          inClass = false;
          re += c;
          continue;
        default:
          clearStateChar();
          if (escaping) {
            escaping = false;
          } else if (reSpecials[c] && !(c === "^" && inClass)) {
            re += "\\";
          }
          re += c;
      }
    }
    if (inClass) {
      cs = pattern.substr(classStart + 1);
      sp = this.parse(cs, SUBPARSE);
      re = re.substr(0, reClassStart) + "\\[" + sp[0];
      hasMagic = hasMagic || sp[1];
    }
    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
      var tail = re.slice(pl.reStart + pl.open.length);
      this.debug("setting tail", re, pl);
      tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_2, $1, $2) {
        if (!$2) {
          $2 = "\\";
        }
        return $1 + $1 + $2 + "|";
      });
      this.debug("tail=%j\n   %s", tail, tail, pl, re);
      var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
      hasMagic = true;
      re = re.slice(0, pl.reStart) + t + "\\(" + tail;
    }
    clearStateChar();
    if (escaping) {
      re += "\\\\";
    }
    var addPatternStart = false;
    switch (re.charAt(0)) {
      case ".":
      case "[":
      case "(":
        addPatternStart = true;
    }
    for (var n = negativeLists.length - 1; n > -1; n--) {
      var nl = negativeLists[n];
      var nlBefore = re.slice(0, nl.reStart);
      var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
      var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
      var nlAfter = re.slice(nl.reEnd);
      nlLast += nlAfter;
      var openParensBefore = nlBefore.split("(").length - 1;
      var cleanAfter = nlAfter;
      for (i = 0; i < openParensBefore; i++) {
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
      }
      nlAfter = cleanAfter;
      var dollar = "";
      if (nlAfter === "" && isSub !== SUBPARSE) {
        dollar = "$";
      }
      var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
      re = newRe;
    }
    if (re !== "" && hasMagic) {
      re = "(?=.)" + re;
    }
    if (addPatternStart) {
      re = patternStart + re;
    }
    if (isSub === SUBPARSE) {
      return [re, hasMagic];
    }
    if (!hasMagic) {
      return globUnescape(pattern);
    }
    var flags = options.nocase ? "i" : "";
    try {
      var regExp = new RegExp("^" + re + "$", flags);
    } catch (er) {
      return new RegExp("$.");
    }
    regExp._glob = pattern;
    regExp._src = re;
    return regExp;
  }
  minimatch.makeRe = function(pattern, options) {
    return new Minimatch(pattern, options || {}).makeRe();
  };
  Minimatch.prototype.makeRe = makeRe;
  function makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    var set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    var options = this.options;
    var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
    var flags = options.nocase ? "i" : "";
    var re = set.map(function(pattern) {
      return pattern.map(function(p) {
        return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
      }).join("\\/");
    }).join("|");
    re = "^(?:" + re + ")$";
    if (this.negate)
      re = "^(?!" + re + ").*$";
    try {
      this.regexp = new RegExp(re, flags);
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  minimatch.match = function(list, pattern, options) {
    options = options || {};
    var mm = new Minimatch(pattern, options);
    list = list.filter(function(f) {
      return mm.match(f);
    });
    if (mm.options.nonull && !list.length) {
      list.push(pattern);
    }
    return list;
  };
  Minimatch.prototype.match = match;
  function match(f, partial) {
    this.debug("match", f, this.pattern);
    if (this.comment)
      return false;
    if (this.empty)
      return f === "";
    if (f === "/" && partial)
      return true;
    var options = this.options;
    if (path4.sep !== "/") {
      f = f.split(path4.sep).join("/");
    }
    f = f.split(slashSplit);
    this.debug(this.pattern, "split", f);
    var set = this.set;
    this.debug(this.pattern, "set", set);
    var filename;
    var i;
    for (i = f.length - 1; i >= 0; i--) {
      filename = f[i];
      if (filename)
        break;
    }
    for (i = 0; i < set.length; i++) {
      var pattern = set[i];
      var file = f;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      var hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options.flipNegate)
          return true;
        return !this.negate;
      }
    }
    if (options.flipNegate)
      return false;
    return this.negate;
  }
  Minimatch.prototype.matchOne = function(file, pattern, partial) {
    var options = this.options;
    this.debug("matchOne", {this: this, file, pattern});
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi];
      var f = file[fi];
      this.debug(pattern, p, f);
      if (p === false)
        return false;
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
          if (fr === fl)
            return true;
        }
        return false;
      }
      var hit;
      if (typeof p === "string") {
        if (options.nocase) {
          hit = f.toLowerCase() === p.toLowerCase();
        } else {
          hit = f === p;
        }
        this.debug("string match", p, f, hit);
      } else {
        hit = f.match(p);
        this.debug("pattern match", p, f, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      var emptyFileEnd = fi === fl - 1 && file[fi] === "";
      return emptyFileEnd;
    }
    throw new Error("wtf?");
  };
  function globUnescape(s2) {
    return s2.replace(/\\(.)/g, "$1");
  }
  function regExpEscape(s2) {
    return s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  }
});

// ../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js
var require_inherits_browser2 = __commonJS2((exports2, module2) => {
  if (typeof Object.create === "function") {
    module2.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module2.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});

// ../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js
var require_inherits2 = __commonJS2((exports2, module2) => {
  try {
    util2 = require("util");
    if (typeof util2.inherits !== "function")
      throw "";
    module2.exports = util2.inherits;
  } catch (e) {
    module2.exports = require_inherits_browser2();
  }
  var util2;
});

// ../../node_modules/.pnpm/path-is-absolute@1.0.1/node_modules/path-is-absolute/index.js
var require_path_is_absolute2 = __commonJS2((exports2, module2) => {
  "use strict";
  function posix(path4) {
    return path4.charAt(0) === "/";
  }
  function win32(path4) {
    var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
    var result = splitDeviceRe.exec(path4);
    var device = result[1] || "";
    var isUnc = Boolean(device && device.charAt(1) !== ":");
    return Boolean(result[2] || isUnc);
  }
  module2.exports = process.platform === "win32" ? win32 : posix;
  module2.exports.posix = posix;
  module2.exports.win32 = win32;
});

// ../../node_modules/.pnpm/glob@7.1.7/node_modules/glob/common.js
var require_common9 = __commonJS2((exports2) => {
  exports2.setopts = setopts;
  exports2.ownProp = ownProp;
  exports2.makeAbs = makeAbs;
  exports2.finish = finish;
  exports2.mark = mark;
  exports2.isIgnored = isIgnored;
  exports2.childrenIgnored = childrenIgnored;
  function ownProp(obj, field) {
    return Object.prototype.hasOwnProperty.call(obj, field);
  }
  var path4 = require("path");
  var minimatch = require_minimatch2();
  var isAbsolute = require_path_is_absolute2();
  var Minimatch = minimatch.Minimatch;
  function alphasort(a, b) {
    return a.localeCompare(b, "en");
  }
  function setupIgnores(self2, options) {
    self2.ignore = options.ignore || [];
    if (!Array.isArray(self2.ignore))
      self2.ignore = [self2.ignore];
    if (self2.ignore.length) {
      self2.ignore = self2.ignore.map(ignoreMap);
    }
  }
  function ignoreMap(pattern) {
    var gmatcher = null;
    if (pattern.slice(-3) === "/**") {
      var gpattern = pattern.replace(/(\/\*\*)+$/, "");
      gmatcher = new Minimatch(gpattern, {dot: true});
    }
    return {
      matcher: new Minimatch(pattern, {dot: true}),
      gmatcher
    };
  }
  function setopts(self2, pattern, options) {
    if (!options)
      options = {};
    if (options.matchBase && pattern.indexOf("/") === -1) {
      if (options.noglobstar) {
        throw new Error("base matching requires globstar");
      }
      pattern = "**/" + pattern;
    }
    self2.silent = !!options.silent;
    self2.pattern = pattern;
    self2.strict = options.strict !== false;
    self2.realpath = !!options.realpath;
    self2.realpathCache = options.realpathCache || Object.create(null);
    self2.follow = !!options.follow;
    self2.dot = !!options.dot;
    self2.mark = !!options.mark;
    self2.nodir = !!options.nodir;
    if (self2.nodir)
      self2.mark = true;
    self2.sync = !!options.sync;
    self2.nounique = !!options.nounique;
    self2.nonull = !!options.nonull;
    self2.nosort = !!options.nosort;
    self2.nocase = !!options.nocase;
    self2.stat = !!options.stat;
    self2.noprocess = !!options.noprocess;
    self2.absolute = !!options.absolute;
    self2.maxLength = options.maxLength || Infinity;
    self2.cache = options.cache || Object.create(null);
    self2.statCache = options.statCache || Object.create(null);
    self2.symlinks = options.symlinks || Object.create(null);
    setupIgnores(self2, options);
    self2.changedCwd = false;
    var cwd = process.cwd();
    if (!ownProp(options, "cwd"))
      self2.cwd = cwd;
    else {
      self2.cwd = path4.resolve(options.cwd);
      self2.changedCwd = self2.cwd !== cwd;
    }
    self2.root = options.root || path4.resolve(self2.cwd, "/");
    self2.root = path4.resolve(self2.root);
    if (process.platform === "win32")
      self2.root = self2.root.replace(/\\/g, "/");
    self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
    if (process.platform === "win32")
      self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
    self2.nomount = !!options.nomount;
    options.nonegate = true;
    options.nocomment = true;
    self2.minimatch = new Minimatch(pattern, options);
    self2.options = self2.minimatch.options;
  }
  function finish(self2) {
    var nou = self2.nounique;
    var all = nou ? [] : Object.create(null);
    for (var i = 0, l = self2.matches.length; i < l; i++) {
      var matches = self2.matches[i];
      if (!matches || Object.keys(matches).length === 0) {
        if (self2.nonull) {
          var literal = self2.minimatch.globSet[i];
          if (nou)
            all.push(literal);
          else
            all[literal] = true;
        }
      } else {
        var m2 = Object.keys(matches);
        if (nou)
          all.push.apply(all, m2);
        else
          m2.forEach(function(m3) {
            all[m3] = true;
          });
      }
    }
    if (!nou)
      all = Object.keys(all);
    if (!self2.nosort)
      all = all.sort(alphasort);
    if (self2.mark) {
      for (var i = 0; i < all.length; i++) {
        all[i] = self2._mark(all[i]);
      }
      if (self2.nodir) {
        all = all.filter(function(e) {
          var notDir = !/\/$/.test(e);
          var c = self2.cache[e] || self2.cache[makeAbs(self2, e)];
          if (notDir && c)
            notDir = c !== "DIR" && !Array.isArray(c);
          return notDir;
        });
      }
    }
    if (self2.ignore.length)
      all = all.filter(function(m3) {
        return !isIgnored(self2, m3);
      });
    self2.found = all;
  }
  function mark(self2, p) {
    var abs2 = makeAbs(self2, p);
    var c = self2.cache[abs2];
    var m2 = p;
    if (c) {
      var isDir = c === "DIR" || Array.isArray(c);
      var slash = p.slice(-1) === "/";
      if (isDir && !slash)
        m2 += "/";
      else if (!isDir && slash)
        m2 = m2.slice(0, -1);
      if (m2 !== p) {
        var mabs = makeAbs(self2, m2);
        self2.statCache[mabs] = self2.statCache[abs2];
        self2.cache[mabs] = self2.cache[abs2];
      }
    }
    return m2;
  }
  function makeAbs(self2, f) {
    var abs2 = f;
    if (f.charAt(0) === "/") {
      abs2 = path4.join(self2.root, f);
    } else if (isAbsolute(f) || f === "") {
      abs2 = f;
    } else if (self2.changedCwd) {
      abs2 = path4.resolve(self2.cwd, f);
    } else {
      abs2 = path4.resolve(f);
    }
    if (process.platform === "win32")
      abs2 = abs2.replace(/\\/g, "/");
    return abs2;
  }
  function isIgnored(self2, path5) {
    if (!self2.ignore.length)
      return false;
    return self2.ignore.some(function(item) {
      return item.matcher.match(path5) || !!(item.gmatcher && item.gmatcher.match(path5));
    });
  }
  function childrenIgnored(self2, path5) {
    if (!self2.ignore.length)
      return false;
    return self2.ignore.some(function(item) {
      return !!(item.gmatcher && item.gmatcher.match(path5));
    });
  }
});

// ../../node_modules/.pnpm/glob@7.1.7/node_modules/glob/sync.js
var require_sync9 = __commonJS2((exports2, module2) => {
  module2.exports = globSync;
  globSync.GlobSync = GlobSync;
  var fs2 = require("fs");
  var rp = require_fs6();
  var minimatch = require_minimatch2();
  var Minimatch = minimatch.Minimatch;
  var Glob = require_glob2().Glob;
  var util2 = require("util");
  var path4 = require("path");
  var assert = require("assert");
  var isAbsolute = require_path_is_absolute2();
  var common = require_common9();
  var setopts = common.setopts;
  var ownProp = common.ownProp;
  var childrenIgnored = common.childrenIgnored;
  var isIgnored = common.isIgnored;
  function globSync(pattern, options) {
    if (typeof options === "function" || arguments.length === 3)
      throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
    return new GlobSync(pattern, options).found;
  }
  function GlobSync(pattern, options) {
    if (!pattern)
      throw new Error("must provide pattern");
    if (typeof options === "function" || arguments.length === 3)
      throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
    if (!(this instanceof GlobSync))
      return new GlobSync(pattern, options);
    setopts(this, pattern, options);
    if (this.noprocess)
      return this;
    var n = this.minimatch.set.length;
    this.matches = new Array(n);
    for (var i = 0; i < n; i++) {
      this._process(this.minimatch.set[i], i, false);
    }
    this._finish();
  }
  GlobSync.prototype._finish = function() {
    assert(this instanceof GlobSync);
    if (this.realpath) {
      var self2 = this;
      this.matches.forEach(function(matchset, index) {
        var set = self2.matches[index] = Object.create(null);
        for (var p in matchset) {
          try {
            p = self2._makeAbs(p);
            var real = rp.realpathSync(p, self2.realpathCache);
            set[real] = true;
          } catch (er) {
            if (er.syscall === "stat")
              set[self2._makeAbs(p)] = true;
            else
              throw er;
          }
        }
      });
    }
    common.finish(this);
  };
  GlobSync.prototype._process = function(pattern, index, inGlobStar) {
    assert(this instanceof GlobSync);
    var n = 0;
    while (typeof pattern[n] === "string") {
      n++;
    }
    var prefix;
    switch (n) {
      case pattern.length:
        this._processSimple(pattern.join("/"), index);
        return;
      case 0:
        prefix = null;
        break;
      default:
        prefix = pattern.slice(0, n).join("/");
        break;
    }
    var remain = pattern.slice(n);
    var read;
    if (prefix === null)
      read = ".";
    else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
      if (!prefix || !isAbsolute(prefix))
        prefix = "/" + prefix;
      read = prefix;
    } else
      read = prefix;
    var abs2 = this._makeAbs(read);
    if (childrenIgnored(this, read))
      return;
    var isGlobStar = remain[0] === minimatch.GLOBSTAR;
    if (isGlobStar)
      this._processGlobStar(prefix, read, abs2, remain, index, inGlobStar);
    else
      this._processReaddir(prefix, read, abs2, remain, index, inGlobStar);
  };
  GlobSync.prototype._processReaddir = function(prefix, read, abs2, remain, index, inGlobStar) {
    var entries = this._readdir(abs2, inGlobStar);
    if (!entries)
      return;
    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === ".";
    var matchedEntries = [];
    for (var i = 0; i < entries.length; i++) {
      var e = entries[i];
      if (e.charAt(0) !== "." || dotOk) {
        var m2;
        if (negate && !prefix) {
          m2 = !e.match(pn);
        } else {
          m2 = e.match(pn);
        }
        if (m2)
          matchedEntries.push(e);
      }
    }
    var len = matchedEntries.length;
    if (len === 0)
      return;
    if (remain.length === 1 && !this.mark && !this.stat) {
      if (!this.matches[index])
        this.matches[index] = Object.create(null);
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        if (prefix) {
          if (prefix.slice(-1) !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        if (e.charAt(0) === "/" && !this.nomount) {
          e = path4.join(this.root, e);
        }
        this._emitMatch(index, e);
      }
      return;
    }
    remain.shift();
    for (var i = 0; i < len; i++) {
      var e = matchedEntries[i];
      var newPattern;
      if (prefix)
        newPattern = [prefix, e];
      else
        newPattern = [e];
      this._process(newPattern.concat(remain), index, inGlobStar);
    }
  };
  GlobSync.prototype._emitMatch = function(index, e) {
    if (isIgnored(this, e))
      return;
    var abs2 = this._makeAbs(e);
    if (this.mark)
      e = this._mark(e);
    if (this.absolute) {
      e = abs2;
    }
    if (this.matches[index][e])
      return;
    if (this.nodir) {
      var c = this.cache[abs2];
      if (c === "DIR" || Array.isArray(c))
        return;
    }
    this.matches[index][e] = true;
    if (this.stat)
      this._stat(e);
  };
  GlobSync.prototype._readdirInGlobStar = function(abs2) {
    if (this.follow)
      return this._readdir(abs2, false);
    var entries;
    var lstat;
    var stat2;
    try {
      lstat = fs2.lstatSync(abs2);
    } catch (er) {
      if (er.code === "ENOENT") {
        return null;
      }
    }
    var isSym = lstat && lstat.isSymbolicLink();
    this.symlinks[abs2] = isSym;
    if (!isSym && lstat && !lstat.isDirectory())
      this.cache[abs2] = "FILE";
    else
      entries = this._readdir(abs2, false);
    return entries;
  };
  GlobSync.prototype._readdir = function(abs2, inGlobStar) {
    var entries;
    if (inGlobStar && !ownProp(this.symlinks, abs2))
      return this._readdirInGlobStar(abs2);
    if (ownProp(this.cache, abs2)) {
      var c = this.cache[abs2];
      if (!c || c === "FILE")
        return null;
      if (Array.isArray(c))
        return c;
    }
    try {
      return this._readdirEntries(abs2, fs2.readdirSync(abs2));
    } catch (er) {
      this._readdirError(abs2, er);
      return null;
    }
  };
  GlobSync.prototype._readdirEntries = function(abs2, entries) {
    if (!this.mark && !this.stat) {
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (abs2 === "/")
          e = abs2 + e;
        else
          e = abs2 + "/" + e;
        this.cache[e] = true;
      }
    }
    this.cache[abs2] = entries;
    return entries;
  };
  GlobSync.prototype._readdirError = function(f, er) {
    switch (er.code) {
      case "ENOTSUP":
      case "ENOTDIR":
        var abs2 = this._makeAbs(f);
        this.cache[abs2] = "FILE";
        if (abs2 === this.cwdAbs) {
          var error = new Error(er.code + " invalid cwd " + this.cwd);
          error.path = this.cwd;
          error.code = er.code;
          throw error;
        }
        break;
      case "ENOENT":
      case "ELOOP":
      case "ENAMETOOLONG":
      case "UNKNOWN":
        this.cache[this._makeAbs(f)] = false;
        break;
      default:
        this.cache[this._makeAbs(f)] = false;
        if (this.strict)
          throw er;
        if (!this.silent)
          console.error("glob error", er);
        break;
    }
  };
  GlobSync.prototype._processGlobStar = function(prefix, read, abs2, remain, index, inGlobStar) {
    var entries = this._readdir(abs2, inGlobStar);
    if (!entries)
      return;
    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix ? [prefix] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar);
    this._process(noGlobStar, index, false);
    var len = entries.length;
    var isSym = this.symlinks[abs2];
    if (isSym && inGlobStar)
      return;
    for (var i = 0; i < len; i++) {
      var e = entries[i];
      if (e.charAt(0) === "." && !this.dot)
        continue;
      var instead = gspref.concat(entries[i], remainWithoutGlobStar);
      this._process(instead, index, true);
      var below = gspref.concat(entries[i], remain);
      this._process(below, index, true);
    }
  };
  GlobSync.prototype._processSimple = function(prefix, index) {
    var exists2 = this._stat(prefix);
    if (!this.matches[index])
      this.matches[index] = Object.create(null);
    if (!exists2)
      return;
    if (prefix && isAbsolute(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix);
      if (prefix.charAt(0) === "/") {
        prefix = path4.join(this.root, prefix);
      } else {
        prefix = path4.resolve(this.root, prefix);
        if (trail)
          prefix += "/";
      }
    }
    if (process.platform === "win32")
      prefix = prefix.replace(/\\/g, "/");
    this._emitMatch(index, prefix);
  };
  GlobSync.prototype._stat = function(f) {
    var abs2 = this._makeAbs(f);
    var needDir = f.slice(-1) === "/";
    if (f.length > this.maxLength)
      return false;
    if (!this.stat && ownProp(this.cache, abs2)) {
      var c = this.cache[abs2];
      if (Array.isArray(c))
        c = "DIR";
      if (!needDir || c === "DIR")
        return c;
      if (needDir && c === "FILE")
        return false;
    }
    var exists2;
    var stat2 = this.statCache[abs2];
    if (!stat2) {
      var lstat;
      try {
        lstat = fs2.lstatSync(abs2);
      } catch (er) {
        if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
          this.statCache[abs2] = false;
          return false;
        }
      }
      if (lstat && lstat.isSymbolicLink()) {
        try {
          stat2 = fs2.statSync(abs2);
        } catch (er) {
          stat2 = lstat;
        }
      } else {
        stat2 = lstat;
      }
    }
    this.statCache[abs2] = stat2;
    var c = true;
    if (stat2)
      c = stat2.isDirectory() ? "DIR" : "FILE";
    this.cache[abs2] = this.cache[abs2] || c;
    if (needDir && c === "FILE")
      return false;
    return c;
  };
  GlobSync.prototype._mark = function(p) {
    return common.mark(this, p);
  };
  GlobSync.prototype._makeAbs = function(f) {
    return common.makeAbs(this, f);
  };
});

// ../../node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js
var require_wrappy2 = __commonJS2((exports2, module2) => {
  module2.exports = wrappy;
  function wrappy(fn, cb) {
    if (fn && cb)
      return wrappy(fn)(cb);
    if (typeof fn !== "function")
      throw new TypeError("need wrapper function");
    Object.keys(fn).forEach(function(k) {
      wrapper[k] = fn[k];
    });
    return wrapper;
    function wrapper() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      var ret = fn.apply(this, args);
      var cb2 = args[args.length - 1];
      if (typeof ret === "function" && ret !== cb2) {
        Object.keys(cb2).forEach(function(k) {
          ret[k] = cb2[k];
        });
      }
      return ret;
    }
  }
});

// ../../node_modules/.pnpm/once@1.4.0/node_modules/once/once.js
var require_once2 = __commonJS2((exports2, module2) => {
  var wrappy = require_wrappy2();
  module2.exports = wrappy(once);
  module2.exports.strict = wrappy(onceStrict);
  once.proto = once(function() {
    Object.defineProperty(Function.prototype, "once", {
      value: function() {
        return once(this);
      },
      configurable: true
    });
    Object.defineProperty(Function.prototype, "onceStrict", {
      value: function() {
        return onceStrict(this);
      },
      configurable: true
    });
  });
  function once(fn) {
    var f = function() {
      if (f.called)
        return f.value;
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    f.called = false;
    return f;
  }
  function onceStrict(fn) {
    var f = function() {
      if (f.called)
        throw new Error(f.onceError);
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    var name = fn.name || "Function wrapped with `once`";
    f.onceError = name + " shouldn't be called more than once";
    f.called = false;
    return f;
  }
});

// ../../node_modules/.pnpm/inflight@1.0.6/node_modules/inflight/inflight.js
var require_inflight2 = __commonJS2((exports2, module2) => {
  var wrappy = require_wrappy2();
  var reqs = Object.create(null);
  var once = require_once2();
  module2.exports = wrappy(inflight);
  function inflight(key, cb) {
    if (reqs[key]) {
      reqs[key].push(cb);
      return null;
    } else {
      reqs[key] = [cb];
      return makeres(key);
    }
  }
  function makeres(key) {
    return once(function RES() {
      var cbs = reqs[key];
      var len = cbs.length;
      var args = slice(arguments);
      try {
        for (var i = 0; i < len; i++) {
          cbs[i].apply(null, args);
        }
      } finally {
        if (cbs.length > len) {
          cbs.splice(0, len);
          process.nextTick(function() {
            RES.apply(null, args);
          });
        } else {
          delete reqs[key];
        }
      }
    });
  }
  function slice(args) {
    var length = args.length;
    var array = [];
    for (var i = 0; i < length; i++)
      array[i] = args[i];
    return array;
  }
});

// ../../node_modules/.pnpm/glob@7.1.7/node_modules/glob/glob.js
var require_glob2 = __commonJS2((exports2, module2) => {
  module2.exports = glob;
  var fs2 = require("fs");
  var rp = require_fs6();
  var minimatch = require_minimatch2();
  var Minimatch = minimatch.Minimatch;
  var inherits = require_inherits2();
  var EE = require("events").EventEmitter;
  var path4 = require("path");
  var assert = require("assert");
  var isAbsolute = require_path_is_absolute2();
  var globSync = require_sync9();
  var common = require_common9();
  var setopts = common.setopts;
  var ownProp = common.ownProp;
  var inflight = require_inflight2();
  var util2 = require("util");
  var childrenIgnored = common.childrenIgnored;
  var isIgnored = common.isIgnored;
  var once = require_once2();
  function glob(pattern, options, cb) {
    if (typeof options === "function")
      cb = options, options = {};
    if (!options)
      options = {};
    if (options.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return globSync(pattern, options);
    }
    return new Glob(pattern, options, cb);
  }
  glob.sync = globSync;
  var GlobSync = glob.GlobSync = globSync.GlobSync;
  glob.glob = glob;
  function extend(origin, add2) {
    if (add2 === null || typeof add2 !== "object") {
      return origin;
    }
    var keys = Object.keys(add2);
    var i = keys.length;
    while (i--) {
      origin[keys[i]] = add2[keys[i]];
    }
    return origin;
  }
  glob.hasMagic = function(pattern, options_) {
    var options = extend({}, options_);
    options.noprocess = true;
    var g = new Glob(pattern, options);
    var set = g.minimatch.set;
    if (!pattern)
      return false;
    if (set.length > 1)
      return true;
    for (var j = 0; j < set[0].length; j++) {
      if (typeof set[0][j] !== "string")
        return true;
    }
    return false;
  };
  glob.Glob = Glob;
  inherits(Glob, EE);
  function Glob(pattern, options, cb) {
    if (typeof options === "function") {
      cb = options;
      options = null;
    }
    if (options && options.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return new GlobSync(pattern, options);
    }
    if (!(this instanceof Glob))
      return new Glob(pattern, options, cb);
    setopts(this, pattern, options);
    this._didRealPath = false;
    var n = this.minimatch.set.length;
    this.matches = new Array(n);
    if (typeof cb === "function") {
      cb = once(cb);
      this.on("error", cb);
      this.on("end", function(matches) {
        cb(null, matches);
      });
    }
    var self2 = this;
    this._processing = 0;
    this._emitQueue = [];
    this._processQueue = [];
    this.paused = false;
    if (this.noprocess)
      return this;
    if (n === 0)
      return done();
    var sync2 = true;
    for (var i = 0; i < n; i++) {
      this._process(this.minimatch.set[i], i, false, done);
    }
    sync2 = false;
    function done() {
      --self2._processing;
      if (self2._processing <= 0) {
        if (sync2) {
          process.nextTick(function() {
            self2._finish();
          });
        } else {
          self2._finish();
        }
      }
    }
  }
  Glob.prototype._finish = function() {
    assert(this instanceof Glob);
    if (this.aborted)
      return;
    if (this.realpath && !this._didRealpath)
      return this._realpath();
    common.finish(this);
    this.emit("end", this.found);
  };
  Glob.prototype._realpath = function() {
    if (this._didRealpath)
      return;
    this._didRealpath = true;
    var n = this.matches.length;
    if (n === 0)
      return this._finish();
    var self2 = this;
    for (var i = 0; i < this.matches.length; i++)
      this._realpathSet(i, next);
    function next() {
      if (--n === 0)
        self2._finish();
    }
  };
  Glob.prototype._realpathSet = function(index, cb) {
    var matchset = this.matches[index];
    if (!matchset)
      return cb();
    var found = Object.keys(matchset);
    var self2 = this;
    var n = found.length;
    if (n === 0)
      return cb();
    var set = this.matches[index] = Object.create(null);
    found.forEach(function(p, i) {
      p = self2._makeAbs(p);
      rp.realpath(p, self2.realpathCache, function(er, real) {
        if (!er)
          set[real] = true;
        else if (er.syscall === "stat")
          set[p] = true;
        else
          self2.emit("error", er);
        if (--n === 0) {
          self2.matches[index] = set;
          cb();
        }
      });
    });
  };
  Glob.prototype._mark = function(p) {
    return common.mark(this, p);
  };
  Glob.prototype._makeAbs = function(f) {
    return common.makeAbs(this, f);
  };
  Glob.prototype.abort = function() {
    this.aborted = true;
    this.emit("abort");
  };
  Glob.prototype.pause = function() {
    if (!this.paused) {
      this.paused = true;
      this.emit("pause");
    }
  };
  Glob.prototype.resume = function() {
    if (this.paused) {
      this.emit("resume");
      this.paused = false;
      if (this._emitQueue.length) {
        var eq = this._emitQueue.slice(0);
        this._emitQueue.length = 0;
        for (var i = 0; i < eq.length; i++) {
          var e = eq[i];
          this._emitMatch(e[0], e[1]);
        }
      }
      if (this._processQueue.length) {
        var pq = this._processQueue.slice(0);
        this._processQueue.length = 0;
        for (var i = 0; i < pq.length; i++) {
          var p = pq[i];
          this._processing--;
          this._process(p[0], p[1], p[2], p[3]);
        }
      }
    }
  };
  Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
    assert(this instanceof Glob);
    assert(typeof cb === "function");
    if (this.aborted)
      return;
    this._processing++;
    if (this.paused) {
      this._processQueue.push([pattern, index, inGlobStar, cb]);
      return;
    }
    var n = 0;
    while (typeof pattern[n] === "string") {
      n++;
    }
    var prefix;
    switch (n) {
      case pattern.length:
        this._processSimple(pattern.join("/"), index, cb);
        return;
      case 0:
        prefix = null;
        break;
      default:
        prefix = pattern.slice(0, n).join("/");
        break;
    }
    var remain = pattern.slice(n);
    var read;
    if (prefix === null)
      read = ".";
    else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
      if (!prefix || !isAbsolute(prefix))
        prefix = "/" + prefix;
      read = prefix;
    } else
      read = prefix;
    var abs2 = this._makeAbs(read);
    if (childrenIgnored(this, read))
      return cb();
    var isGlobStar = remain[0] === minimatch.GLOBSTAR;
    if (isGlobStar)
      this._processGlobStar(prefix, read, abs2, remain, index, inGlobStar, cb);
    else
      this._processReaddir(prefix, read, abs2, remain, index, inGlobStar, cb);
  };
  Glob.prototype._processReaddir = function(prefix, read, abs2, remain, index, inGlobStar, cb) {
    var self2 = this;
    this._readdir(abs2, inGlobStar, function(er, entries) {
      return self2._processReaddir2(prefix, read, abs2, remain, index, inGlobStar, entries, cb);
    });
  };
  Glob.prototype._processReaddir2 = function(prefix, read, abs2, remain, index, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === ".";
    var matchedEntries = [];
    for (var i = 0; i < entries.length; i++) {
      var e = entries[i];
      if (e.charAt(0) !== "." || dotOk) {
        var m2;
        if (negate && !prefix) {
          m2 = !e.match(pn);
        } else {
          m2 = e.match(pn);
        }
        if (m2)
          matchedEntries.push(e);
      }
    }
    var len = matchedEntries.length;
    if (len === 0)
      return cb();
    if (remain.length === 1 && !this.mark && !this.stat) {
      if (!this.matches[index])
        this.matches[index] = Object.create(null);
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        if (e.charAt(0) === "/" && !this.nomount) {
          e = path4.join(this.root, e);
        }
        this._emitMatch(index, e);
      }
      return cb();
    }
    remain.shift();
    for (var i = 0; i < len; i++) {
      var e = matchedEntries[i];
      var newPattern;
      if (prefix) {
        if (prefix !== "/")
          e = prefix + "/" + e;
        else
          e = prefix + e;
      }
      this._process([e].concat(remain), index, inGlobStar, cb);
    }
    cb();
  };
  Glob.prototype._emitMatch = function(index, e) {
    if (this.aborted)
      return;
    if (isIgnored(this, e))
      return;
    if (this.paused) {
      this._emitQueue.push([index, e]);
      return;
    }
    var abs2 = isAbsolute(e) ? e : this._makeAbs(e);
    if (this.mark)
      e = this._mark(e);
    if (this.absolute)
      e = abs2;
    if (this.matches[index][e])
      return;
    if (this.nodir) {
      var c = this.cache[abs2];
      if (c === "DIR" || Array.isArray(c))
        return;
    }
    this.matches[index][e] = true;
    var st = this.statCache[abs2];
    if (st)
      this.emit("stat", e, st);
    this.emit("match", e);
  };
  Glob.prototype._readdirInGlobStar = function(abs2, cb) {
    if (this.aborted)
      return;
    if (this.follow)
      return this._readdir(abs2, false, cb);
    var lstatkey = "lstat\0" + abs2;
    var self2 = this;
    var lstatcb = inflight(lstatkey, lstatcb_);
    if (lstatcb)
      fs2.lstat(abs2, lstatcb);
    function lstatcb_(er, lstat) {
      if (er && er.code === "ENOENT")
        return cb();
      var isSym = lstat && lstat.isSymbolicLink();
      self2.symlinks[abs2] = isSym;
      if (!isSym && lstat && !lstat.isDirectory()) {
        self2.cache[abs2] = "FILE";
        cb();
      } else
        self2._readdir(abs2, false, cb);
    }
  };
  Glob.prototype._readdir = function(abs2, inGlobStar, cb) {
    if (this.aborted)
      return;
    cb = inflight("readdir\0" + abs2 + "\0" + inGlobStar, cb);
    if (!cb)
      return;
    if (inGlobStar && !ownProp(this.symlinks, abs2))
      return this._readdirInGlobStar(abs2, cb);
    if (ownProp(this.cache, abs2)) {
      var c = this.cache[abs2];
      if (!c || c === "FILE")
        return cb();
      if (Array.isArray(c))
        return cb(null, c);
    }
    var self2 = this;
    fs2.readdir(abs2, readdirCb(this, abs2, cb));
  };
  function readdirCb(self2, abs2, cb) {
    return function(er, entries) {
      if (er)
        self2._readdirError(abs2, er, cb);
      else
        self2._readdirEntries(abs2, entries, cb);
    };
  }
  Glob.prototype._readdirEntries = function(abs2, entries, cb) {
    if (this.aborted)
      return;
    if (!this.mark && !this.stat) {
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (abs2 === "/")
          e = abs2 + e;
        else
          e = abs2 + "/" + e;
        this.cache[e] = true;
      }
    }
    this.cache[abs2] = entries;
    return cb(null, entries);
  };
  Glob.prototype._readdirError = function(f, er, cb) {
    if (this.aborted)
      return;
    switch (er.code) {
      case "ENOTSUP":
      case "ENOTDIR":
        var abs2 = this._makeAbs(f);
        this.cache[abs2] = "FILE";
        if (abs2 === this.cwdAbs) {
          var error = new Error(er.code + " invalid cwd " + this.cwd);
          error.path = this.cwd;
          error.code = er.code;
          this.emit("error", error);
          this.abort();
        }
        break;
      case "ENOENT":
      case "ELOOP":
      case "ENAMETOOLONG":
      case "UNKNOWN":
        this.cache[this._makeAbs(f)] = false;
        break;
      default:
        this.cache[this._makeAbs(f)] = false;
        if (this.strict) {
          this.emit("error", er);
          this.abort();
        }
        if (!this.silent)
          console.error("glob error", er);
        break;
    }
    return cb();
  };
  Glob.prototype._processGlobStar = function(prefix, read, abs2, remain, index, inGlobStar, cb) {
    var self2 = this;
    this._readdir(abs2, inGlobStar, function(er, entries) {
      self2._processGlobStar2(prefix, read, abs2, remain, index, inGlobStar, entries, cb);
    });
  };
  Glob.prototype._processGlobStar2 = function(prefix, read, abs2, remain, index, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix ? [prefix] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar);
    this._process(noGlobStar, index, false, cb);
    var isSym = this.symlinks[abs2];
    var len = entries.length;
    if (isSym && inGlobStar)
      return cb();
    for (var i = 0; i < len; i++) {
      var e = entries[i];
      if (e.charAt(0) === "." && !this.dot)
        continue;
      var instead = gspref.concat(entries[i], remainWithoutGlobStar);
      this._process(instead, index, true, cb);
      var below = gspref.concat(entries[i], remain);
      this._process(below, index, true, cb);
    }
    cb();
  };
  Glob.prototype._processSimple = function(prefix, index, cb) {
    var self2 = this;
    this._stat(prefix, function(er, exists2) {
      self2._processSimple2(prefix, index, er, exists2, cb);
    });
  };
  Glob.prototype._processSimple2 = function(prefix, index, er, exists2, cb) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null);
    if (!exists2)
      return cb();
    if (prefix && isAbsolute(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix);
      if (prefix.charAt(0) === "/") {
        prefix = path4.join(this.root, prefix);
      } else {
        prefix = path4.resolve(this.root, prefix);
        if (trail)
          prefix += "/";
      }
    }
    if (process.platform === "win32")
      prefix = prefix.replace(/\\/g, "/");
    this._emitMatch(index, prefix);
    cb();
  };
  Glob.prototype._stat = function(f, cb) {
    var abs2 = this._makeAbs(f);
    var needDir = f.slice(-1) === "/";
    if (f.length > this.maxLength)
      return cb();
    if (!this.stat && ownProp(this.cache, abs2)) {
      var c = this.cache[abs2];
      if (Array.isArray(c))
        c = "DIR";
      if (!needDir || c === "DIR")
        return cb(null, c);
      if (needDir && c === "FILE")
        return cb();
    }
    var exists2;
    var stat2 = this.statCache[abs2];
    if (stat2 !== void 0) {
      if (stat2 === false)
        return cb(null, stat2);
      else {
        var type = stat2.isDirectory() ? "DIR" : "FILE";
        if (needDir && type === "FILE")
          return cb();
        else
          return cb(null, type, stat2);
      }
    }
    var self2 = this;
    var statcb = inflight("stat\0" + abs2, lstatcb_);
    if (statcb)
      fs2.lstat(abs2, statcb);
    function lstatcb_(er, lstat) {
      if (lstat && lstat.isSymbolicLink()) {
        return fs2.stat(abs2, function(er2, stat3) {
          if (er2)
            self2._stat2(f, abs2, null, lstat, cb);
          else
            self2._stat2(f, abs2, er2, stat3, cb);
        });
      } else {
        self2._stat2(f, abs2, er, lstat, cb);
      }
    }
  };
  Glob.prototype._stat2 = function(f, abs2, er, stat2, cb) {
    if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
      this.statCache[abs2] = false;
      return cb();
    }
    var needDir = f.slice(-1) === "/";
    this.statCache[abs2] = stat2;
    if (abs2.slice(-1) === "/" && stat2 && !stat2.isDirectory())
      return cb(null, false, stat2);
    var c = true;
    if (stat2)
      c = stat2.isDirectory() ? "DIR" : "FILE";
    this.cache[abs2] = this.cache[abs2] || c;
    if (needDir && c === "FILE")
      return cb();
    return cb(null, c, stat2);
  };
});

// ../../node_modules/.pnpm/rimraf@3.0.2/node_modules/rimraf/rimraf.js
var require_rimraf2 = __commonJS2((exports2, module2) => {
  var assert = require("assert");
  var path4 = require("path");
  var fs2 = require("fs");
  var glob = void 0;
  try {
    glob = require_glob2();
  } catch (_err) {
  }
  var defaultGlobOpts = {
    nosort: true,
    silent: true
  };
  var timeout = 0;
  var isWindows = process.platform === "win32";
  var defaults = (options) => {
    const methods = [
      "unlink",
      "chmod",
      "stat",
      "lstat",
      "rmdir",
      "readdir"
    ];
    methods.forEach((m2) => {
      options[m2] = options[m2] || fs2[m2];
      m2 = m2 + "Sync";
      options[m2] = options[m2] || fs2[m2];
    });
    options.maxBusyTries = options.maxBusyTries || 3;
    options.emfileWait = options.emfileWait || 1e3;
    if (options.glob === false) {
      options.disableGlob = true;
    }
    if (options.disableGlob !== true && glob === void 0) {
      throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");
    }
    options.disableGlob = options.disableGlob || false;
    options.glob = options.glob || defaultGlobOpts;
  };
  var rimraf = (p, options, cb) => {
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    assert(p, "rimraf: missing path");
    assert.equal(typeof p, "string", "rimraf: path should be a string");
    assert.equal(typeof cb, "function", "rimraf: callback function required");
    assert(options, "rimraf: invalid options argument provided");
    assert.equal(typeof options, "object", "rimraf: options should be object");
    defaults(options);
    let busyTries = 0;
    let errState = null;
    let n = 0;
    const next = (er) => {
      errState = errState || er;
      if (--n === 0)
        cb(errState);
    };
    const afterGlob = (er, results) => {
      if (er)
        return cb(er);
      n = results.length;
      if (n === 0)
        return cb();
      results.forEach((p2) => {
        const CB = (er2) => {
          if (er2) {
            if ((er2.code === "EBUSY" || er2.code === "ENOTEMPTY" || er2.code === "EPERM") && busyTries < options.maxBusyTries) {
              busyTries++;
              return setTimeout(() => rimraf_(p2, options, CB), busyTries * 100);
            }
            if (er2.code === "EMFILE" && timeout < options.emfileWait) {
              return setTimeout(() => rimraf_(p2, options, CB), timeout++);
            }
            if (er2.code === "ENOENT")
              er2 = null;
          }
          timeout = 0;
          next(er2);
        };
        rimraf_(p2, options, CB);
      });
    };
    if (options.disableGlob || !glob.hasMagic(p))
      return afterGlob(null, [p]);
    options.lstat(p, (er, stat2) => {
      if (!er)
        return afterGlob(null, [p]);
      glob(p, options.glob, afterGlob);
    });
  };
  var rimraf_ = (p, options, cb) => {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.lstat(p, (er, st) => {
      if (er && er.code === "ENOENT")
        return cb(null);
      if (er && er.code === "EPERM" && isWindows)
        fixWinEPERM(p, options, er, cb);
      if (st && st.isDirectory())
        return rmdir(p, options, er, cb);
      options.unlink(p, (er2) => {
        if (er2) {
          if (er2.code === "ENOENT")
            return cb(null);
          if (er2.code === "EPERM")
            return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
          if (er2.code === "EISDIR")
            return rmdir(p, options, er2, cb);
        }
        return cb(er2);
      });
    });
  };
  var fixWinEPERM = (p, options, er, cb) => {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.chmod(p, 438, (er2) => {
      if (er2)
        cb(er2.code === "ENOENT" ? null : er);
      else
        options.stat(p, (er3, stats) => {
          if (er3)
            cb(er3.code === "ENOENT" ? null : er);
          else if (stats.isDirectory())
            rmdir(p, options, er, cb);
          else
            options.unlink(p, cb);
        });
    });
  };
  var fixWinEPERMSync = (p, options, er) => {
    assert(p);
    assert(options);
    try {
      options.chmodSync(p, 438);
    } catch (er2) {
      if (er2.code === "ENOENT")
        return;
      else
        throw er;
    }
    let stats;
    try {
      stats = options.statSync(p);
    } catch (er3) {
      if (er3.code === "ENOENT")
        return;
      else
        throw er;
    }
    if (stats.isDirectory())
      rmdirSync(p, options, er);
    else
      options.unlinkSync(p);
  };
  var rmdir = (p, options, originalEr, cb) => {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.rmdir(p, (er) => {
      if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
        rmkids(p, options, cb);
      else if (er && er.code === "ENOTDIR")
        cb(originalEr);
      else
        cb(er);
    });
  };
  var rmkids = (p, options, cb) => {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.readdir(p, (er, files) => {
      if (er)
        return cb(er);
      let n = files.length;
      if (n === 0)
        return options.rmdir(p, cb);
      let errState;
      files.forEach((f) => {
        rimraf(path4.join(p, f), options, (er2) => {
          if (errState)
            return;
          if (er2)
            return cb(errState = er2);
          if (--n === 0)
            options.rmdir(p, cb);
        });
      });
    });
  };
  var rimrafSync = (p, options) => {
    options = options || {};
    defaults(options);
    assert(p, "rimraf: missing path");
    assert.equal(typeof p, "string", "rimraf: path should be a string");
    assert(options, "rimraf: missing options");
    assert.equal(typeof options, "object", "rimraf: options should be object");
    let results;
    if (options.disableGlob || !glob.hasMagic(p)) {
      results = [p];
    } else {
      try {
        options.lstatSync(p);
        results = [p];
      } catch (er) {
        results = glob.sync(p, options.glob);
      }
    }
    if (!results.length)
      return;
    for (let i = 0; i < results.length; i++) {
      const p2 = results[i];
      let st;
      try {
        st = options.lstatSync(p2);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "EPERM" && isWindows)
          fixWinEPERMSync(p2, options, er);
      }
      try {
        if (st && st.isDirectory())
          rmdirSync(p2, options, null);
        else
          options.unlinkSync(p2);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "EPERM")
          return isWindows ? fixWinEPERMSync(p2, options, er) : rmdirSync(p2, options, er);
        if (er.code !== "EISDIR")
          throw er;
        rmdirSync(p2, options, er);
      }
    }
  };
  var rmdirSync = (p, options, originalEr) => {
    assert(p);
    assert(options);
    try {
      options.rmdirSync(p);
    } catch (er) {
      if (er.code === "ENOENT")
        return;
      if (er.code === "ENOTDIR")
        throw originalEr;
      if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
        rmkidsSync(p, options);
    }
  };
  var rmkidsSync = (p, options) => {
    assert(p);
    assert(options);
    options.readdirSync(p).forEach((f) => rimrafSync(path4.join(p, f), options));
    const retries = isWindows ? 100 : 1;
    let i = 0;
    do {
      let threw = true;
      try {
        const ret = options.rmdirSync(p, options);
        threw = false;
        return ret;
      } finally {
        if (++i < retries && threw)
          continue;
      }
    } while (true);
  };
  module2.exports = rimraf;
  rimraf.sync = rimrafSync;
});

// ../../node_modules/.pnpm/indent-string@4.0.0/node_modules/indent-string/index.js
var require_indent_string2 = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = (string, count = 1, options) => {
    options = {
      indent: " ",
      includeEmptyLines: false,
      ...options
    };
    if (typeof string !== "string") {
      throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof string}\``);
    }
    if (typeof count !== "number") {
      throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof count}\``);
    }
    if (typeof options.indent !== "string") {
      throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof options.indent}\``);
    }
    if (count === 0) {
      return string;
    }
    const regex = options.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
    return string.replace(regex, options.indent.repeat(count));
  };
});

// ../../node_modules/.pnpm/clean-stack@2.2.0/node_modules/clean-stack/index.js
var require_clean_stack2 = __commonJS2((exports2, module2) => {
  "use strict";
  var os2 = require("os");
  var extractPathRegex = /\s+at.*(?:\(|\s)(.*)\)?/;
  var pathRegex = /^(?:(?:(?:node|(?:internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)\.js:\d+:\d+)|native)/;
  var homeDir = typeof os2.homedir === "undefined" ? "" : os2.homedir();
  module2.exports = (stack, options) => {
    options = Object.assign({pretty: false}, options);
    return stack.replace(/\\/g, "/").split("\n").filter((line) => {
      const pathMatches = line.match(extractPathRegex);
      if (pathMatches === null || !pathMatches[1]) {
        return true;
      }
      const match = pathMatches[1];
      if (match.includes(".app/Contents/Resources/electron.asar") || match.includes(".app/Contents/Resources/default_app.asar")) {
        return false;
      }
      return !pathRegex.test(match);
    }).filter((line) => line.trim() !== "").map((line) => {
      if (options.pretty) {
        return line.replace(extractPathRegex, (m2, p1) => m2.replace(p1, p1.replace(homeDir, "~")));
      }
      return line;
    }).join("\n");
  };
});

// ../../node_modules/.pnpm/aggregate-error@3.1.0/node_modules/aggregate-error/index.js
var require_aggregate_error2 = __commonJS2((exports2, module2) => {
  "use strict";
  var indentString = require_indent_string2();
  var cleanStack = require_clean_stack2();
  var cleanInternalStack = (stack) => stack.replace(/\s+at .*aggregate-error\/index.js:\d+:\d+\)?/g, "");
  var AggregateError = class extends Error {
    constructor(errors) {
      if (!Array.isArray(errors)) {
        throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
      }
      errors = [...errors].map((error) => {
        if (error instanceof Error) {
          return error;
        }
        if (error !== null && typeof error === "object") {
          return Object.assign(new Error(error.message), error);
        }
        return new Error(error);
      });
      let message = errors.map((error) => {
        return typeof error.stack === "string" ? cleanInternalStack(cleanStack(error.stack)) : String(error);
      }).join("\n");
      message = "\n" + indentString(message, 4);
      super(message);
      this.name = "AggregateError";
      Object.defineProperty(this, "_errors", {value: errors});
    }
    *[Symbol.iterator]() {
      for (const error of this._errors) {
        yield error;
      }
    }
  };
  module2.exports = AggregateError;
});

// ../../node_modules/.pnpm/p-map@4.0.0/node_modules/p-map/index.js
var require_p_map3 = __commonJS2((exports2, module2) => {
  "use strict";
  var AggregateError = require_aggregate_error2();
  module2.exports = async (iterable, mapper, {
    concurrency = Infinity,
    stopOnError = true
  } = {}) => {
    return new Promise((resolve, reject) => {
      if (typeof mapper !== "function") {
        throw new TypeError("Mapper function is required");
      }
      if (!((Number.isSafeInteger(concurrency) || concurrency === Infinity) && concurrency >= 1)) {
        throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${concurrency}\` (${typeof concurrency})`);
      }
      const result = [];
      const errors = [];
      const iterator = iterable[Symbol.iterator]();
      let isRejected = false;
      let isIterableDone = false;
      let resolvingCount = 0;
      let currentIndex = 0;
      const next = () => {
        if (isRejected) {
          return;
        }
        const nextItem = iterator.next();
        const index = currentIndex;
        currentIndex++;
        if (nextItem.done) {
          isIterableDone = true;
          if (resolvingCount === 0) {
            if (!stopOnError && errors.length !== 0) {
              reject(new AggregateError(errors));
            } else {
              resolve(result);
            }
          }
          return;
        }
        resolvingCount++;
        (async () => {
          try {
            const element = await nextItem.value;
            result[index] = await mapper(element, index);
            resolvingCount--;
            next();
          } catch (error) {
            if (stopOnError) {
              isRejected = true;
              reject(error);
            } else {
              errors.push(error);
              resolvingCount--;
              next();
            }
          }
        })();
      };
      for (let i = 0; i < concurrency; i++) {
        next();
        if (isIterableDone) {
          break;
        }
      }
    });
  };
});

// ../../node_modules/.pnpm/@prisma+fetch-engine@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/fetch-engine/dist/cleanupCache.js
var require_cleanupCache2 = __commonJS2((exports2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : {default: mod2};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.cleanupCache = void 0;
  var fs_12 = __importDefault2(require("fs"));
  var path_12 = __importDefault2(require("path"));
  var util_12 = require_util4();
  var rimraf_1 = __importDefault2(require_rimraf2());
  var util_22 = require("util");
  var p_map_1 = __importDefault2(require_p_map3());
  var debug_12 = __importDefault2(require_dist10());
  var debug4 = debug_12.default("cleanupCache");
  var del = util_22.promisify(rimraf_1.default);
  var readdir2 = util_22.promisify(fs_12.default.readdir);
  var stat2 = util_22.promisify(fs_12.default.stat);
  async function cleanupCache(n = 5) {
    try {
      const rootCacheDir = await util_12.getRootCacheDir();
      if (!rootCacheDir) {
        debug4("no rootCacheDir found");
        return;
      }
      const channel2 = "master";
      const cacheDir = path_12.default.join(rootCacheDir, channel2);
      const dirs = await readdir2(cacheDir);
      const dirsWithMeta = await Promise.all(dirs.map(async (dirName) => {
        const dir = path_12.default.join(cacheDir, dirName);
        const statResult = await stat2(dir);
        return {
          dir,
          created: statResult.birthtime
        };
      }));
      dirsWithMeta.sort((a, b) => a.created < b.created ? 1 : -1);
      const dirsToRemove = dirsWithMeta.slice(n);
      await p_map_1.default(dirsToRemove, (dir) => del(dir.dir), {concurrency: 20});
    } catch (e) {
    }
  }
  exports2.cleanupCache = cleanupCache;
});

// ../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry_operation.js
var require_retry_operation2 = __commonJS2((exports2, module2) => {
  function RetryOperation(timeouts, options) {
    if (typeof options === "boolean") {
      options = {forever: options};
    }
    this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
    this._timeouts = timeouts;
    this._options = options || {};
    this._maxRetryTime = options && options.maxRetryTime || Infinity;
    this._fn = null;
    this._errors = [];
    this._attempts = 1;
    this._operationTimeout = null;
    this._operationTimeoutCb = null;
    this._timeout = null;
    this._operationStart = null;
    this._timer = null;
    if (this._options.forever) {
      this._cachedTimeouts = this._timeouts.slice(0);
    }
  }
  module2.exports = RetryOperation;
  RetryOperation.prototype.reset = function() {
    this._attempts = 1;
    this._timeouts = this._originalTimeouts.slice(0);
  };
  RetryOperation.prototype.stop = function() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
    if (this._timer) {
      clearTimeout(this._timer);
    }
    this._timeouts = [];
    this._cachedTimeouts = null;
  };
  RetryOperation.prototype.retry = function(err) {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
    if (!err) {
      return false;
    }
    var currentTime = new Date().getTime();
    if (err && currentTime - this._operationStart >= this._maxRetryTime) {
      this._errors.push(err);
      this._errors.unshift(new Error("RetryOperation timeout occurred"));
      return false;
    }
    this._errors.push(err);
    var timeout = this._timeouts.shift();
    if (timeout === void 0) {
      if (this._cachedTimeouts) {
        this._errors.splice(0, this._errors.length - 1);
        timeout = this._cachedTimeouts.slice(-1);
      } else {
        return false;
      }
    }
    var self2 = this;
    this._timer = setTimeout(function() {
      self2._attempts++;
      if (self2._operationTimeoutCb) {
        self2._timeout = setTimeout(function() {
          self2._operationTimeoutCb(self2._attempts);
        }, self2._operationTimeout);
        if (self2._options.unref) {
          self2._timeout.unref();
        }
      }
      self2._fn(self2._attempts);
    }, timeout);
    if (this._options.unref) {
      this._timer.unref();
    }
    return true;
  };
  RetryOperation.prototype.attempt = function(fn, timeoutOps) {
    this._fn = fn;
    if (timeoutOps) {
      if (timeoutOps.timeout) {
        this._operationTimeout = timeoutOps.timeout;
      }
      if (timeoutOps.cb) {
        this._operationTimeoutCb = timeoutOps.cb;
      }
    }
    var self2 = this;
    if (this._operationTimeoutCb) {
      this._timeout = setTimeout(function() {
        self2._operationTimeoutCb();
      }, self2._operationTimeout);
    }
    this._operationStart = new Date().getTime();
    this._fn(this._attempts);
  };
  RetryOperation.prototype.try = function(fn) {
    console.log("Using RetryOperation.try() is deprecated");
    this.attempt(fn);
  };
  RetryOperation.prototype.start = function(fn) {
    console.log("Using RetryOperation.start() is deprecated");
    this.attempt(fn);
  };
  RetryOperation.prototype.start = RetryOperation.prototype.try;
  RetryOperation.prototype.errors = function() {
    return this._errors;
  };
  RetryOperation.prototype.attempts = function() {
    return this._attempts;
  };
  RetryOperation.prototype.mainError = function() {
    if (this._errors.length === 0) {
      return null;
    }
    var counts = {};
    var mainError = null;
    var mainErrorCount = 0;
    for (var i = 0; i < this._errors.length; i++) {
      var error = this._errors[i];
      var message = error.message;
      var count = (counts[message] || 0) + 1;
      counts[message] = count;
      if (count >= mainErrorCount) {
        mainError = error;
        mainErrorCount = count;
      }
    }
    return mainError;
  };
});

// ../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry.js
var require_retry3 = __commonJS2((exports2) => {
  var RetryOperation = require_retry_operation2();
  exports2.operation = function(options) {
    var timeouts = exports2.timeouts(options);
    return new RetryOperation(timeouts, {
      forever: options && (options.forever || options.retries === Infinity),
      unref: options && options.unref,
      maxRetryTime: options && options.maxRetryTime
    });
  };
  exports2.timeouts = function(options) {
    if (options instanceof Array) {
      return [].concat(options);
    }
    var opts = {
      retries: 10,
      factor: 2,
      minTimeout: 1 * 1e3,
      maxTimeout: Infinity,
      randomize: false
    };
    for (var key in options) {
      opts[key] = options[key];
    }
    if (opts.minTimeout > opts.maxTimeout) {
      throw new Error("minTimeout is greater than maxTimeout");
    }
    var timeouts = [];
    for (var i = 0; i < opts.retries; i++) {
      timeouts.push(this.createTimeout(i, opts));
    }
    if (options && options.forever && !timeouts.length) {
      timeouts.push(this.createTimeout(i, opts));
    }
    timeouts.sort(function(a, b) {
      return a - b;
    });
    return timeouts;
  };
  exports2.createTimeout = function(attempt, opts) {
    var random2 = opts.randomize ? Math.random() + 1 : 1;
    var timeout = Math.round(random2 * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
    timeout = Math.min(timeout, opts.maxTimeout);
    return timeout;
  };
  exports2.wrap = function(obj, options, methods) {
    if (options instanceof Array) {
      methods = options;
      options = null;
    }
    if (!methods) {
      methods = [];
      for (var key in obj) {
        if (typeof obj[key] === "function") {
          methods.push(key);
        }
      }
    }
    for (var i = 0; i < methods.length; i++) {
      var method = methods[i];
      var original = obj[method];
      obj[method] = function retryWrapper(original2) {
        var op = exports2.operation(options);
        var args = Array.prototype.slice.call(arguments, 1);
        var callback = args.pop();
        args.push(function(err) {
          if (op.retry(err)) {
            return;
          }
          if (err) {
            arguments[0] = op.mainError();
          }
          callback.apply(this, arguments);
        });
        op.attempt(function() {
          original2.apply(obj, args);
        });
      }.bind(obj, original);
      obj[method].options = options;
    }
  };
});

// ../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/index.js
var require_retry4 = __commonJS2((exports2, module2) => {
  module2.exports = require_retry3();
});

// ../../node_modules/.pnpm/p-retry@4.6.1/node_modules/p-retry/index.js
var require_p_retry2 = __commonJS2((exports2, module2) => {
  "use strict";
  var retry = require_retry4();
  var networkErrorMsgs = [
    "Failed to fetch",
    "NetworkError when attempting to fetch resource.",
    "The Internet connection appears to be offline.",
    "Network request failed"
  ];
  var AbortError = class extends Error {
    constructor(message) {
      super();
      if (message instanceof Error) {
        this.originalError = message;
        ({message} = message);
      } else {
        this.originalError = new Error(message);
        this.originalError.stack = this.stack;
      }
      this.name = "AbortError";
      this.message = message;
    }
  };
  var decorateErrorWithCounts = (error, attemptNumber, options) => {
    const retriesLeft = options.retries - (attemptNumber - 1);
    error.attemptNumber = attemptNumber;
    error.retriesLeft = retriesLeft;
    return error;
  };
  var isNetworkError = (errorMessage) => networkErrorMsgs.includes(errorMessage);
  var pRetry = (input, options) => new Promise((resolve, reject) => {
    options = {
      onFailedAttempt: () => {
      },
      retries: 10,
      ...options
    };
    const operation = retry.operation(options);
    operation.attempt(async (attemptNumber) => {
      try {
        resolve(await input(attemptNumber));
      } catch (error) {
        if (!(error instanceof Error)) {
          reject(new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`));
          return;
        }
        if (error instanceof AbortError) {
          operation.stop();
          reject(error.originalError);
        } else if (error instanceof TypeError && !isNetworkError(error.message)) {
          operation.stop();
          reject(error);
        } else {
          decorateErrorWithCounts(error, attemptNumber, options);
          try {
            await options.onFailedAttempt(error);
          } catch (error2) {
            reject(error2);
            return;
          }
          if (!operation.retry(error)) {
            reject(operation.mainError());
          }
        }
      }
    });
  });
  module2.exports = pRetry;
  module2.exports.default = pRetry;
  module2.exports.AbortError = AbortError;
});

// ../../node_modules/.pnpm/node-fetch@2.6.1/node_modules/node-fetch/lib/index.mjs
var require_lib5 = __commonJS2((exports2) => {
  __markAsModule2(exports2);
  __export2(exports2, {
    FetchError: () => FetchError,
    Headers: () => Headers,
    Request: () => Request,
    Response: () => Response,
    default: () => lib_default
  });
  var import_stream = __toModule2(require("stream"));
  var import_http = __toModule2(require("http"));
  var import_url2 = __toModule2(require("url"));
  var import_https = __toModule2(require("https"));
  var import_zlib = __toModule2(require("zlib"));
  var Readable = import_stream.default.Readable;
  var BUFFER = Symbol("buffer");
  var TYPE = Symbol("type");
  var Blob = class {
    constructor() {
      this[TYPE] = "";
      const blobParts = arguments[0];
      const options = arguments[1];
      const buffers = [];
      let size = 0;
      if (blobParts) {
        const a = blobParts;
        const length = Number(a.length);
        for (let i = 0; i < length; i++) {
          const element = a[i];
          let buffer;
          if (element instanceof Buffer) {
            buffer = element;
          } else if (ArrayBuffer.isView(element)) {
            buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
          } else if (element instanceof ArrayBuffer) {
            buffer = Buffer.from(element);
          } else if (element instanceof Blob) {
            buffer = element[BUFFER];
          } else {
            buffer = Buffer.from(typeof element === "string" ? element : String(element));
          }
          size += buffer.length;
          buffers.push(buffer);
        }
      }
      this[BUFFER] = Buffer.concat(buffers);
      let type = options && options.type !== void 0 && String(options.type).toLowerCase();
      if (type && !/[^\u0020-\u007E]/.test(type)) {
        this[TYPE] = type;
      }
    }
    get size() {
      return this[BUFFER].length;
    }
    get type() {
      return this[TYPE];
    }
    text() {
      return Promise.resolve(this[BUFFER].toString());
    }
    arrayBuffer() {
      const buf = this[BUFFER];
      const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
      return Promise.resolve(ab);
    }
    stream() {
      const readable = new Readable();
      readable._read = function() {
      };
      readable.push(this[BUFFER]);
      readable.push(null);
      return readable;
    }
    toString() {
      return "[object Blob]";
    }
    slice() {
      const size = this.size;
      const start = arguments[0];
      const end = arguments[1];
      let relativeStart, relativeEnd;
      if (start === void 0) {
        relativeStart = 0;
      } else if (start < 0) {
        relativeStart = Math.max(size + start, 0);
      } else {
        relativeStart = Math.min(start, size);
      }
      if (end === void 0) {
        relativeEnd = size;
      } else if (end < 0) {
        relativeEnd = Math.max(size + end, 0);
      } else {
        relativeEnd = Math.min(end, size);
      }
      const span = Math.max(relativeEnd - relativeStart, 0);
      const buffer = this[BUFFER];
      const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
      const blob = new Blob([], {type: arguments[2]});
      blob[BUFFER] = slicedBuffer;
      return blob;
    }
  };
  Object.defineProperties(Blob.prototype, {
    size: {enumerable: true},
    type: {enumerable: true},
    slice: {enumerable: true}
  });
  Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
    value: "Blob",
    writable: false,
    enumerable: false,
    configurable: true
  });
  function FetchError(message, type, systemError) {
    Error.call(this, message);
    this.message = message;
    this.type = type;
    if (systemError) {
      this.code = this.errno = systemError.code;
    }
    Error.captureStackTrace(this, this.constructor);
  }
  FetchError.prototype = Object.create(Error.prototype);
  FetchError.prototype.constructor = FetchError;
  FetchError.prototype.name = "FetchError";
  var convert;
  try {
    convert = require("encoding").convert;
  } catch (e) {
  }
  var INTERNALS = Symbol("Body internals");
  var PassThrough = import_stream.default.PassThrough;
  function Body(body) {
    var _this = this;
    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
    let size = _ref$size === void 0 ? 0 : _ref$size;
    var _ref$timeout = _ref.timeout;
    let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
    if (body == null) {
      body = null;
    } else if (isURLSearchParams(body)) {
      body = Buffer.from(body.toString());
    } else if (isBlob(body))
      ;
    else if (Buffer.isBuffer(body))
      ;
    else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      body = Buffer.from(body);
    } else if (ArrayBuffer.isView(body)) {
      body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
    } else if (body instanceof import_stream.default)
      ;
    else {
      body = Buffer.from(String(body));
    }
    this[INTERNALS] = {
      body,
      disturbed: false,
      error: null
    };
    this.size = size;
    this.timeout = timeout;
    if (body instanceof import_stream.default) {
      body.on("error", function(err) {
        const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
        _this[INTERNALS].error = error;
      });
    }
  }
  Body.prototype = {
    get body() {
      return this[INTERNALS].body;
    },
    get bodyUsed() {
      return this[INTERNALS].disturbed;
    },
    arrayBuffer() {
      return consumeBody.call(this).then(function(buf) {
        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
      });
    },
    blob() {
      let ct = this.headers && this.headers.get("content-type") || "";
      return consumeBody.call(this).then(function(buf) {
        return Object.assign(new Blob([], {
          type: ct.toLowerCase()
        }), {
          [BUFFER]: buf
        });
      });
    },
    json() {
      var _this2 = this;
      return consumeBody.call(this).then(function(buffer) {
        try {
          return JSON.parse(buffer.toString());
        } catch (err) {
          return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
        }
      });
    },
    text() {
      return consumeBody.call(this).then(function(buffer) {
        return buffer.toString();
      });
    },
    buffer() {
      return consumeBody.call(this);
    },
    textConverted() {
      var _this3 = this;
      return consumeBody.call(this).then(function(buffer) {
        return convertBody(buffer, _this3.headers);
      });
    }
  };
  Object.defineProperties(Body.prototype, {
    body: {enumerable: true},
    bodyUsed: {enumerable: true},
    arrayBuffer: {enumerable: true},
    blob: {enumerable: true},
    json: {enumerable: true},
    text: {enumerable: true}
  });
  Body.mixIn = function(proto) {
    for (const name of Object.getOwnPropertyNames(Body.prototype)) {
      if (!(name in proto)) {
        const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
        Object.defineProperty(proto, name, desc);
      }
    }
  };
  function consumeBody() {
    var _this4 = this;
    if (this[INTERNALS].disturbed) {
      return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
    }
    this[INTERNALS].disturbed = true;
    if (this[INTERNALS].error) {
      return Body.Promise.reject(this[INTERNALS].error);
    }
    let body = this.body;
    if (body === null) {
      return Body.Promise.resolve(Buffer.alloc(0));
    }
    if (isBlob(body)) {
      body = body.stream();
    }
    if (Buffer.isBuffer(body)) {
      return Body.Promise.resolve(body);
    }
    if (!(body instanceof import_stream.default)) {
      return Body.Promise.resolve(Buffer.alloc(0));
    }
    let accum = [];
    let accumBytes = 0;
    let abort = false;
    return new Body.Promise(function(resolve, reject) {
      let resTimeout;
      if (_this4.timeout) {
        resTimeout = setTimeout(function() {
          abort = true;
          reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
        }, _this4.timeout);
      }
      body.on("error", function(err) {
        if (err.name === "AbortError") {
          abort = true;
          reject(err);
        } else {
          reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
        }
      });
      body.on("data", function(chunk) {
        if (abort || chunk === null) {
          return;
        }
        if (_this4.size && accumBytes + chunk.length > _this4.size) {
          abort = true;
          reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
          return;
        }
        accumBytes += chunk.length;
        accum.push(chunk);
      });
      body.on("end", function() {
        if (abort) {
          return;
        }
        clearTimeout(resTimeout);
        try {
          resolve(Buffer.concat(accum, accumBytes));
        } catch (err) {
          reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
        }
      });
    });
  }
  function convertBody(buffer, headers) {
    if (typeof convert !== "function") {
      throw new Error("The package `encoding` must be installed to use the textConverted() function");
    }
    const ct = headers.get("content-type");
    let charset = "utf-8";
    let res, str;
    if (ct) {
      res = /charset=([^;]*)/i.exec(ct);
    }
    str = buffer.slice(0, 1024).toString();
    if (!res && str) {
      res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
    }
    if (!res && str) {
      res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
      if (!res) {
        res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
        if (res) {
          res.pop();
        }
      }
      if (res) {
        res = /charset=(.*)/i.exec(res.pop());
      }
    }
    if (!res && str) {
      res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
    }
    if (res) {
      charset = res.pop();
      if (charset === "gb2312" || charset === "gbk") {
        charset = "gb18030";
      }
    }
    return convert(buffer, "UTF-8", charset).toString();
  }
  function isURLSearchParams(obj) {
    if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
      return false;
    }
    return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
  }
  function isBlob(obj) {
    return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
  }
  function clone2(instance) {
    let p1, p2;
    let body = instance.body;
    if (instance.bodyUsed) {
      throw new Error("cannot clone body after it is used");
    }
    if (body instanceof import_stream.default && typeof body.getBoundary !== "function") {
      p1 = new PassThrough();
      p2 = new PassThrough();
      body.pipe(p1);
      body.pipe(p2);
      instance[INTERNALS].body = p1;
      body = p2;
    }
    return body;
  }
  function extractContentType(body) {
    if (body === null) {
      return null;
    } else if (typeof body === "string") {
      return "text/plain;charset=UTF-8";
    } else if (isURLSearchParams(body)) {
      return "application/x-www-form-urlencoded;charset=UTF-8";
    } else if (isBlob(body)) {
      return body.type || null;
    } else if (Buffer.isBuffer(body)) {
      return null;
    } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      return null;
    } else if (ArrayBuffer.isView(body)) {
      return null;
    } else if (typeof body.getBoundary === "function") {
      return `multipart/form-data;boundary=${body.getBoundary()}`;
    } else if (body instanceof import_stream.default) {
      return null;
    } else {
      return "text/plain;charset=UTF-8";
    }
  }
  function getTotalBytes(instance) {
    const body = instance.body;
    if (body === null) {
      return 0;
    } else if (isBlob(body)) {
      return body.size;
    } else if (Buffer.isBuffer(body)) {
      return body.length;
    } else if (body && typeof body.getLengthSync === "function") {
      if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || body.hasKnownLength && body.hasKnownLength()) {
        return body.getLengthSync();
      }
      return null;
    } else {
      return null;
    }
  }
  function writeToStream(dest, instance) {
    const body = instance.body;
    if (body === null) {
      dest.end();
    } else if (isBlob(body)) {
      body.stream().pipe(dest);
    } else if (Buffer.isBuffer(body)) {
      dest.write(body);
      dest.end();
    } else {
      body.pipe(dest);
    }
  }
  Body.Promise = global.Promise;
  var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
  var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
  function validateName(name) {
    name = `${name}`;
    if (invalidTokenRegex.test(name) || name === "") {
      throw new TypeError(`${name} is not a legal HTTP header name`);
    }
  }
  function validateValue(value) {
    value = `${value}`;
    if (invalidHeaderCharRegex.test(value)) {
      throw new TypeError(`${value} is not a legal HTTP header value`);
    }
  }
  function find(map, name) {
    name = name.toLowerCase();
    for (const key in map) {
      if (key.toLowerCase() === name) {
        return key;
      }
    }
    return void 0;
  }
  var MAP = Symbol("map");
  var Headers = class {
    constructor() {
      let init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
      this[MAP] = Object.create(null);
      if (init instanceof Headers) {
        const rawHeaders = init.raw();
        const headerNames = Object.keys(rawHeaders);
        for (const headerName of headerNames) {
          for (const value of rawHeaders[headerName]) {
            this.append(headerName, value);
          }
        }
        return;
      }
      if (init == null)
        ;
      else if (typeof init === "object") {
        const method = init[Symbol.iterator];
        if (method != null) {
          if (typeof method !== "function") {
            throw new TypeError("Header pairs must be iterable");
          }
          const pairs = [];
          for (const pair of init) {
            if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
              throw new TypeError("Each header pair must be iterable");
            }
            pairs.push(Array.from(pair));
          }
          for (const pair of pairs) {
            if (pair.length !== 2) {
              throw new TypeError("Each header pair must be a name/value tuple");
            }
            this.append(pair[0], pair[1]);
          }
        } else {
          for (const key of Object.keys(init)) {
            const value = init[key];
            this.append(key, value);
          }
        }
      } else {
        throw new TypeError("Provided initializer must be an object");
      }
    }
    get(name) {
      name = `${name}`;
      validateName(name);
      const key = find(this[MAP], name);
      if (key === void 0) {
        return null;
      }
      return this[MAP][key].join(", ");
    }
    forEach(callback) {
      let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
      let pairs = getHeaders(this);
      let i = 0;
      while (i < pairs.length) {
        var _pairs$i = pairs[i];
        const name = _pairs$i[0], value = _pairs$i[1];
        callback.call(thisArg, value, name, this);
        pairs = getHeaders(this);
        i++;
      }
    }
    set(name, value) {
      name = `${name}`;
      value = `${value}`;
      validateName(name);
      validateValue(value);
      const key = find(this[MAP], name);
      this[MAP][key !== void 0 ? key : name] = [value];
    }
    append(name, value) {
      name = `${name}`;
      value = `${value}`;
      validateName(name);
      validateValue(value);
      const key = find(this[MAP], name);
      if (key !== void 0) {
        this[MAP][key].push(value);
      } else {
        this[MAP][name] = [value];
      }
    }
    has(name) {
      name = `${name}`;
      validateName(name);
      return find(this[MAP], name) !== void 0;
    }
    delete(name) {
      name = `${name}`;
      validateName(name);
      const key = find(this[MAP], name);
      if (key !== void 0) {
        delete this[MAP][key];
      }
    }
    raw() {
      return this[MAP];
    }
    keys() {
      return createHeadersIterator(this, "key");
    }
    values() {
      return createHeadersIterator(this, "value");
    }
    [Symbol.iterator]() {
      return createHeadersIterator(this, "key+value");
    }
  };
  Headers.prototype.entries = Headers.prototype[Symbol.iterator];
  Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
    value: "Headers",
    writable: false,
    enumerable: false,
    configurable: true
  });
  Object.defineProperties(Headers.prototype, {
    get: {enumerable: true},
    forEach: {enumerable: true},
    set: {enumerable: true},
    append: {enumerable: true},
    has: {enumerable: true},
    delete: {enumerable: true},
    keys: {enumerable: true},
    values: {enumerable: true},
    entries: {enumerable: true}
  });
  function getHeaders(headers) {
    let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
    const keys = Object.keys(headers[MAP]).sort();
    return keys.map(kind === "key" ? function(k) {
      return k.toLowerCase();
    } : kind === "value" ? function(k) {
      return headers[MAP][k].join(", ");
    } : function(k) {
      return [k.toLowerCase(), headers[MAP][k].join(", ")];
    });
  }
  var INTERNAL = Symbol("internal");
  function createHeadersIterator(target, kind) {
    const iterator = Object.create(HeadersIteratorPrototype);
    iterator[INTERNAL] = {
      target,
      kind,
      index: 0
    };
    return iterator;
  }
  var HeadersIteratorPrototype = Object.setPrototypeOf({
    next() {
      if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
        throw new TypeError("Value of `this` is not a HeadersIterator");
      }
      var _INTERNAL = this[INTERNAL];
      const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
      const values = getHeaders(target, kind);
      const len = values.length;
      if (index >= len) {
        return {
          value: void 0,
          done: true
        };
      }
      this[INTERNAL].index = index + 1;
      return {
        value: values[index],
        done: false
      };
    }
  }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
  Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
    value: "HeadersIterator",
    writable: false,
    enumerable: false,
    configurable: true
  });
  function exportNodeCompatibleHeaders(headers) {
    const obj = Object.assign({__proto__: null}, headers[MAP]);
    const hostHeaderKey = find(headers[MAP], "Host");
    if (hostHeaderKey !== void 0) {
      obj[hostHeaderKey] = obj[hostHeaderKey][0];
    }
    return obj;
  }
  function createHeadersLenient(obj) {
    const headers = new Headers();
    for (const name of Object.keys(obj)) {
      if (invalidTokenRegex.test(name)) {
        continue;
      }
      if (Array.isArray(obj[name])) {
        for (const val of obj[name]) {
          if (invalidHeaderCharRegex.test(val)) {
            continue;
          }
          if (headers[MAP][name] === void 0) {
            headers[MAP][name] = [val];
          } else {
            headers[MAP][name].push(val);
          }
        }
      } else if (!invalidHeaderCharRegex.test(obj[name])) {
        headers[MAP][name] = [obj[name]];
      }
    }
    return headers;
  }
  var INTERNALS$1 = Symbol("Response internals");
  var STATUS_CODES = import_http.default.STATUS_CODES;
  var Response = class {
    constructor() {
      let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      Body.call(this, body, opts);
      const status = opts.status || 200;
      const headers = new Headers(opts.headers);
      if (body != null && !headers.has("Content-Type")) {
        const contentType = extractContentType(body);
        if (contentType) {
          headers.append("Content-Type", contentType);
        }
      }
      this[INTERNALS$1] = {
        url: opts.url,
        status,
        statusText: opts.statusText || STATUS_CODES[status],
        headers,
        counter: opts.counter
      };
    }
    get url() {
      return this[INTERNALS$1].url || "";
    }
    get status() {
      return this[INTERNALS$1].status;
    }
    get ok() {
      return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
    }
    get redirected() {
      return this[INTERNALS$1].counter > 0;
    }
    get statusText() {
      return this[INTERNALS$1].statusText;
    }
    get headers() {
      return this[INTERNALS$1].headers;
    }
    clone() {
      return new Response(clone2(this), {
        url: this.url,
        status: this.status,
        statusText: this.statusText,
        headers: this.headers,
        ok: this.ok,
        redirected: this.redirected
      });
    }
  };
  Body.mixIn(Response.prototype);
  Object.defineProperties(Response.prototype, {
    url: {enumerable: true},
    status: {enumerable: true},
    ok: {enumerable: true},
    redirected: {enumerable: true},
    statusText: {enumerable: true},
    headers: {enumerable: true},
    clone: {enumerable: true}
  });
  Object.defineProperty(Response.prototype, Symbol.toStringTag, {
    value: "Response",
    writable: false,
    enumerable: false,
    configurable: true
  });
  var INTERNALS$2 = Symbol("Request internals");
  var parse_url = import_url2.default.parse;
  var format_url = import_url2.default.format;
  var streamDestructionSupported = "destroy" in import_stream.default.Readable.prototype;
  function isRequest(input) {
    return typeof input === "object" && typeof input[INTERNALS$2] === "object";
  }
  function isAbortSignal(signal) {
    const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
    return !!(proto && proto.constructor.name === "AbortSignal");
  }
  var Request = class {
    constructor(input) {
      let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      let parsedURL;
      if (!isRequest(input)) {
        if (input && input.href) {
          parsedURL = parse_url(input.href);
        } else {
          parsedURL = parse_url(`${input}`);
        }
        input = {};
      } else {
        parsedURL = parse_url(input.url);
      }
      let method = init.method || input.method || "GET";
      method = method.toUpperCase();
      if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
        throw new TypeError("Request with GET/HEAD method cannot have body");
      }
      let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone2(input) : null;
      Body.call(this, inputBody, {
        timeout: init.timeout || input.timeout || 0,
        size: init.size || input.size || 0
      });
      const headers = new Headers(init.headers || input.headers || {});
      if (inputBody != null && !headers.has("Content-Type")) {
        const contentType = extractContentType(inputBody);
        if (contentType) {
          headers.append("Content-Type", contentType);
        }
      }
      let signal = isRequest(input) ? input.signal : null;
      if ("signal" in init)
        signal = init.signal;
      if (signal != null && !isAbortSignal(signal)) {
        throw new TypeError("Expected signal to be an instanceof AbortSignal");
      }
      this[INTERNALS$2] = {
        method,
        redirect: init.redirect || input.redirect || "follow",
        headers,
        parsedURL,
        signal
      };
      this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20;
      this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : true;
      this.counter = init.counter || input.counter || 0;
      this.agent = init.agent || input.agent;
    }
    get method() {
      return this[INTERNALS$2].method;
    }
    get url() {
      return format_url(this[INTERNALS$2].parsedURL);
    }
    get headers() {
      return this[INTERNALS$2].headers;
    }
    get redirect() {
      return this[INTERNALS$2].redirect;
    }
    get signal() {
      return this[INTERNALS$2].signal;
    }
    clone() {
      return new Request(this);
    }
  };
  Body.mixIn(Request.prototype);
  Object.defineProperty(Request.prototype, Symbol.toStringTag, {
    value: "Request",
    writable: false,
    enumerable: false,
    configurable: true
  });
  Object.defineProperties(Request.prototype, {
    method: {enumerable: true},
    url: {enumerable: true},
    headers: {enumerable: true},
    redirect: {enumerable: true},
    clone: {enumerable: true},
    signal: {enumerable: true}
  });
  function getNodeRequestOptions(request) {
    const parsedURL = request[INTERNALS$2].parsedURL;
    const headers = new Headers(request[INTERNALS$2].headers);
    if (!headers.has("Accept")) {
      headers.set("Accept", "*/*");
    }
    if (!parsedURL.protocol || !parsedURL.hostname) {
      throw new TypeError("Only absolute URLs are supported");
    }
    if (!/^https?:$/.test(parsedURL.protocol)) {
      throw new TypeError("Only HTTP(S) protocols are supported");
    }
    if (request.signal && request.body instanceof import_stream.default.Readable && !streamDestructionSupported) {
      throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
    }
    let contentLengthValue = null;
    if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
      contentLengthValue = "0";
    }
    if (request.body != null) {
      const totalBytes = getTotalBytes(request);
      if (typeof totalBytes === "number") {
        contentLengthValue = String(totalBytes);
      }
    }
    if (contentLengthValue) {
      headers.set("Content-Length", contentLengthValue);
    }
    if (!headers.has("User-Agent")) {
      headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
    }
    if (request.compress && !headers.has("Accept-Encoding")) {
      headers.set("Accept-Encoding", "gzip,deflate");
    }
    let agent = request.agent;
    if (typeof agent === "function") {
      agent = agent(parsedURL);
    }
    if (!headers.has("Connection") && !agent) {
      headers.set("Connection", "close");
    }
    return Object.assign({}, parsedURL, {
      method: request.method,
      headers: exportNodeCompatibleHeaders(headers),
      agent
    });
  }
  function AbortError(message) {
    Error.call(this, message);
    this.type = "aborted";
    this.message = message;
    Error.captureStackTrace(this, this.constructor);
  }
  AbortError.prototype = Object.create(Error.prototype);
  AbortError.prototype.constructor = AbortError;
  AbortError.prototype.name = "AbortError";
  var PassThrough$1 = import_stream.default.PassThrough;
  var resolve_url = import_url2.default.resolve;
  function fetch(url, opts) {
    if (!fetch.Promise) {
      throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
    }
    Body.Promise = fetch.Promise;
    return new fetch.Promise(function(resolve, reject) {
      const request = new Request(url, opts);
      const options = getNodeRequestOptions(request);
      const send = (options.protocol === "https:" ? import_https.default : import_http.default).request;
      const signal = request.signal;
      let response = null;
      const abort = function abort2() {
        let error = new AbortError("The user aborted a request.");
        reject(error);
        if (request.body && request.body instanceof import_stream.default.Readable) {
          request.body.destroy(error);
        }
        if (!response || !response.body)
          return;
        response.body.emit("error", error);
      };
      if (signal && signal.aborted) {
        abort();
        return;
      }
      const abortAndFinalize = function abortAndFinalize2() {
        abort();
        finalize();
      };
      const req = send(options);
      let reqTimeout;
      if (signal) {
        signal.addEventListener("abort", abortAndFinalize);
      }
      function finalize() {
        req.abort();
        if (signal)
          signal.removeEventListener("abort", abortAndFinalize);
        clearTimeout(reqTimeout);
      }
      if (request.timeout) {
        req.once("socket", function(socket) {
          reqTimeout = setTimeout(function() {
            reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
            finalize();
          }, request.timeout);
        });
      }
      req.on("error", function(err) {
        reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
        finalize();
      });
      req.on("response", function(res) {
        clearTimeout(reqTimeout);
        const headers = createHeadersLenient(res.headers);
        if (fetch.isRedirect(res.statusCode)) {
          const location = headers.get("Location");
          const locationURL = location === null ? null : resolve_url(request.url, location);
          switch (request.redirect) {
            case "error":
              reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
              finalize();
              return;
            case "manual":
              if (locationURL !== null) {
                try {
                  headers.set("Location", locationURL);
                } catch (err) {
                  reject(err);
                }
              }
              break;
            case "follow":
              if (locationURL === null) {
                break;
              }
              if (request.counter >= request.follow) {
                reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                finalize();
                return;
              }
              const requestOpts = {
                headers: new Headers(request.headers),
                follow: request.follow,
                counter: request.counter + 1,
                agent: request.agent,
                compress: request.compress,
                method: request.method,
                body: request.body,
                signal: request.signal,
                timeout: request.timeout,
                size: request.size
              };
              if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                finalize();
                return;
              }
              if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                requestOpts.method = "GET";
                requestOpts.body = void 0;
                requestOpts.headers.delete("content-length");
              }
              resolve(fetch(new Request(locationURL, requestOpts)));
              finalize();
              return;
          }
        }
        res.once("end", function() {
          if (signal)
            signal.removeEventListener("abort", abortAndFinalize);
        });
        let body = res.pipe(new PassThrough$1());
        const response_options = {
          url: request.url,
          status: res.statusCode,
          statusText: res.statusMessage,
          headers,
          size: request.size,
          timeout: request.timeout,
          counter: request.counter
        };
        const codings = headers.get("Content-Encoding");
        if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
          response = new Response(body, response_options);
          resolve(response);
          return;
        }
        const zlibOptions = {
          flush: import_zlib.default.Z_SYNC_FLUSH,
          finishFlush: import_zlib.default.Z_SYNC_FLUSH
        };
        if (codings == "gzip" || codings == "x-gzip") {
          body = body.pipe(import_zlib.default.createGunzip(zlibOptions));
          response = new Response(body, response_options);
          resolve(response);
          return;
        }
        if (codings == "deflate" || codings == "x-deflate") {
          const raw = res.pipe(new PassThrough$1());
          raw.once("data", function(chunk) {
            if ((chunk[0] & 15) === 8) {
              body = body.pipe(import_zlib.default.createInflate());
            } else {
              body = body.pipe(import_zlib.default.createInflateRaw());
            }
            response = new Response(body, response_options);
            resolve(response);
          });
          return;
        }
        if (codings == "br" && typeof import_zlib.default.createBrotliDecompress === "function") {
          body = body.pipe(import_zlib.default.createBrotliDecompress());
          response = new Response(body, response_options);
          resolve(response);
          return;
        }
        response = new Response(body, response_options);
        resolve(response);
      });
      writeToStream(req, request);
    });
  }
  fetch.isRedirect = function(code) {
    return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
  };
  fetch.Promise = global.Promise;
  var lib_default = fetch;
});

// ../../node_modules/.pnpm/agent-base@6.0.2/node_modules/agent-base/dist/src/promisify.js
var require_promisify2 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  function promisify2(fn) {
    return function(req, opts) {
      return new Promise((resolve, reject) => {
        fn.call(this, req, opts, (err, rtn) => {
          if (err) {
            reject(err);
          } else {
            resolve(rtn);
          }
        });
      });
    };
  }
  exports2.default = promisify2;
});

// ../../node_modules/.pnpm/agent-base@6.0.2/node_modules/agent-base/dist/src/index.js
var require_src5 = __commonJS2((exports2, module2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : {default: mod2};
  };
  var events_1 = require("events");
  var debug_12 = __importDefault2(require_src3());
  var promisify_1 = __importDefault2(require_promisify2());
  var debug4 = debug_12.default("agent-base");
  function isAgent(v) {
    return Boolean(v) && typeof v.addRequest === "function";
  }
  function isSecureEndpoint() {
    const {stack} = new Error();
    if (typeof stack !== "string")
      return false;
    return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
  }
  function createAgent(callback, opts) {
    return new createAgent.Agent(callback, opts);
  }
  (function(createAgent2) {
    class Agent extends events_1.EventEmitter {
      constructor(callback, _opts) {
        super();
        let opts = _opts;
        if (typeof callback === "function") {
          this.callback = callback;
        } else if (callback) {
          opts = callback;
        }
        this.timeout = null;
        if (opts && typeof opts.timeout === "number") {
          this.timeout = opts.timeout;
        }
        this.maxFreeSockets = 1;
        this.maxSockets = 1;
        this.maxTotalSockets = Infinity;
        this.sockets = {};
        this.freeSockets = {};
        this.requests = {};
        this.options = {};
      }
      get defaultPort() {
        if (typeof this.explicitDefaultPort === "number") {
          return this.explicitDefaultPort;
        }
        return isSecureEndpoint() ? 443 : 80;
      }
      set defaultPort(v) {
        this.explicitDefaultPort = v;
      }
      get protocol() {
        if (typeof this.explicitProtocol === "string") {
          return this.explicitProtocol;
        }
        return isSecureEndpoint() ? "https:" : "http:";
      }
      set protocol(v) {
        this.explicitProtocol = v;
      }
      callback(req, opts, fn) {
        throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
      }
      addRequest(req, _opts) {
        const opts = Object.assign({}, _opts);
        if (typeof opts.secureEndpoint !== "boolean") {
          opts.secureEndpoint = isSecureEndpoint();
        }
        if (opts.host == null) {
          opts.host = "localhost";
        }
        if (opts.port == null) {
          opts.port = opts.secureEndpoint ? 443 : 80;
        }
        if (opts.protocol == null) {
          opts.protocol = opts.secureEndpoint ? "https:" : "http:";
        }
        if (opts.host && opts.path) {
          delete opts.path;
        }
        delete opts.agent;
        delete opts.hostname;
        delete opts._defaultAgent;
        delete opts.defaultPort;
        delete opts.createConnection;
        req._last = true;
        req.shouldKeepAlive = false;
        let timedOut = false;
        let timeoutId = null;
        const timeoutMs = opts.timeout || this.timeout;
        const onerror = (err) => {
          if (req._hadError)
            return;
          req.emit("error", err);
          req._hadError = true;
        };
        const ontimeout = () => {
          timeoutId = null;
          timedOut = true;
          const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
          err.code = "ETIMEOUT";
          onerror(err);
        };
        const callbackError = (err) => {
          if (timedOut)
            return;
          if (timeoutId !== null) {
            clearTimeout(timeoutId);
            timeoutId = null;
          }
          onerror(err);
        };
        const onsocket = (socket) => {
          if (timedOut)
            return;
          if (timeoutId != null) {
            clearTimeout(timeoutId);
            timeoutId = null;
          }
          if (isAgent(socket)) {
            debug4("Callback returned another Agent instance %o", socket.constructor.name);
            socket.addRequest(req, opts);
            return;
          }
          if (socket) {
            socket.once("free", () => {
              this.freeSocket(socket, opts);
            });
            req.onSocket(socket);
            return;
          }
          const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
          onerror(err);
        };
        if (typeof this.callback !== "function") {
          onerror(new Error("`callback` is not defined"));
          return;
        }
        if (!this.promisifiedCallback) {
          if (this.callback.length >= 3) {
            debug4("Converting legacy callback function to promise");
            this.promisifiedCallback = promisify_1.default(this.callback);
          } else {
            this.promisifiedCallback = this.callback;
          }
        }
        if (typeof timeoutMs === "number" && timeoutMs > 0) {
          timeoutId = setTimeout(ontimeout, timeoutMs);
        }
        if ("port" in opts && typeof opts.port !== "number") {
          opts.port = Number(opts.port);
        }
        try {
          debug4("Resolving socket for %o request: %o", opts.protocol, `${req.method} ${req.path}`);
          Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
        } catch (err) {
          Promise.reject(err).catch(callbackError);
        }
      }
      freeSocket(socket, opts) {
        debug4("Freeing socket %o %o", socket.constructor.name, opts);
        socket.destroy();
      }
      destroy() {
        debug4("Destroying agent %o", this.constructor.name);
      }
    }
    createAgent2.Agent = Agent;
    createAgent2.prototype = createAgent2.Agent.prototype;
  })(createAgent || (createAgent = {}));
  module2.exports = createAgent;
});

// ../../node_modules/.pnpm/https-proxy-agent@5.0.0/node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response2 = __commonJS2((exports2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : {default: mod2};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  var debug_12 = __importDefault2(require_src3());
  var debug4 = debug_12.default("https-proxy-agent:parse-proxy-response");
  function parseProxyResponse(socket) {
    return new Promise((resolve, reject) => {
      let buffersLength = 0;
      const buffers = [];
      function read() {
        const b = socket.read();
        if (b)
          ondata(b);
        else
          socket.once("readable", read);
      }
      function cleanup2() {
        socket.removeListener("end", onend);
        socket.removeListener("error", onerror);
        socket.removeListener("close", onclose);
        socket.removeListener("readable", read);
      }
      function onclose(err) {
        debug4("onclose had error %o", err);
      }
      function onend() {
        debug4("onend");
      }
      function onerror(err) {
        cleanup2();
        debug4("onerror %o", err);
        reject(err);
      }
      function ondata(b) {
        buffers.push(b);
        buffersLength += b.length;
        const buffered = Buffer.concat(buffers, buffersLength);
        const endOfHeaders = buffered.indexOf("\r\n\r\n");
        if (endOfHeaders === -1) {
          debug4("have not received end of HTTP headers yet...");
          read();
          return;
        }
        const firstLine = buffered.toString("ascii", 0, buffered.indexOf("\r\n"));
        const statusCode = +firstLine.split(" ")[1];
        debug4("got proxy server response: %o", firstLine);
        resolve({
          statusCode,
          buffered
        });
      }
      socket.on("error", onerror);
      socket.on("close", onclose);
      socket.on("end", onend);
      read();
    });
  }
  exports2.default = parseProxyResponse;
});

// ../../node_modules/.pnpm/https-proxy-agent@5.0.0/node_modules/https-proxy-agent/dist/agent.js
var require_agent3 = __commonJS2((exports2) => {
  "use strict";
  var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : {default: mod2};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  var net_1 = __importDefault2(require("net"));
  var tls_1 = __importDefault2(require("tls"));
  var url_1 = __importDefault2(require("url"));
  var assert_1 = __importDefault2(require("assert"));
  var debug_12 = __importDefault2(require_src3());
  var agent_base_1 = require_src5();
  var parse_proxy_response_1 = __importDefault2(require_parse_proxy_response2());
  var debug4 = debug_12.default("https-proxy-agent:agent");
  var HttpsProxyAgent = class extends agent_base_1.Agent {
    constructor(_opts) {
      let opts;
      if (typeof _opts === "string") {
        opts = url_1.default.parse(_opts);
      } else {
        opts = _opts;
      }
      if (!opts) {
        throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
      }
      debug4("creating new HttpsProxyAgent instance: %o", opts);
      super(opts);
      const proxy = Object.assign({}, opts);
      this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
      proxy.host = proxy.hostname || proxy.host;
      if (typeof proxy.port === "string") {
        proxy.port = parseInt(proxy.port, 10);
      }
      if (!proxy.port && proxy.host) {
        proxy.port = this.secureProxy ? 443 : 80;
      }
      if (this.secureProxy && !("ALPNProtocols" in proxy)) {
        proxy.ALPNProtocols = ["http 1.1"];
      }
      if (proxy.host && proxy.path) {
        delete proxy.path;
        delete proxy.pathname;
      }
      this.proxy = proxy;
    }
    callback(req, opts) {
      return __awaiter(this, void 0, void 0, function* () {
        const {proxy, secureProxy} = this;
        let socket;
        if (secureProxy) {
          debug4("Creating `tls.Socket`: %o", proxy);
          socket = tls_1.default.connect(proxy);
        } else {
          debug4("Creating `net.Socket`: %o", proxy);
          socket = net_1.default.connect(proxy);
        }
        const headers = Object.assign({}, proxy.headers);
        const hostname = `${opts.host}:${opts.port}`;
        let payload = `CONNECT ${hostname} HTTP/1.1\r
`;
        if (proxy.auth) {
          headers["Proxy-Authorization"] = `Basic ${Buffer.from(proxy.auth).toString("base64")}`;
        }
        let {host, port, secureEndpoint} = opts;
        if (!isDefaultPort(port, secureEndpoint)) {
          host += `:${port}`;
        }
        headers.Host = host;
        headers.Connection = "close";
        for (const name of Object.keys(headers)) {
          payload += `${name}: ${headers[name]}\r
`;
        }
        const proxyResponsePromise = parse_proxy_response_1.default(socket);
        socket.write(`${payload}\r
`);
        const {statusCode, buffered} = yield proxyResponsePromise;
        if (statusCode === 200) {
          req.once("socket", resume);
          if (opts.secureEndpoint) {
            const servername = opts.servername || opts.host;
            if (!servername) {
              throw new Error('Could not determine "servername"');
            }
            debug4("Upgrading socket connection to TLS");
            return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, "host", "hostname", "path", "port")), {
              socket,
              servername
            }));
          }
          return socket;
        }
        socket.destroy();
        const fakeSocket = new net_1.default.Socket();
        fakeSocket.readable = true;
        req.once("socket", (s2) => {
          debug4("replaying proxy buffer for failed request");
          assert_1.default(s2.listenerCount("data") > 0);
          s2.push(buffered);
          s2.push(null);
        });
        return fakeSocket;
      });
    }
  };
  exports2.default = HttpsProxyAgent;
  function resume(socket) {
    socket.resume();
  }
  function isDefaultPort(port, secure) {
    return Boolean(!secure && port === 80 || secure && port === 443);
  }
  function isHTTPS(protocol) {
    return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
  }
  function omit(obj, ...keys) {
    const ret = {};
    let key;
    for (key in obj) {
      if (!keys.includes(key)) {
        ret[key] = obj[key];
      }
    }
    return ret;
  }
});

// ../../node_modules/.pnpm/https-proxy-agent@5.0.0/node_modules/https-proxy-agent/dist/index.js
var require_dist12 = __commonJS2((exports2, module2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : {default: mod2};
  };
  var agent_1 = __importDefault2(require_agent3());
  function createHttpsProxyAgent(opts) {
    return new agent_1.default(opts);
  }
  (function(createHttpsProxyAgent2) {
    createHttpsProxyAgent2.HttpsProxyAgent = agent_1.default;
    createHttpsProxyAgent2.prototype = agent_1.default.prototype;
  })(createHttpsProxyAgent || (createHttpsProxyAgent = {}));
  module2.exports = createHttpsProxyAgent;
});

// ../../node_modules/.pnpm/@tootallnate+once@1.1.2/node_modules/@tootallnate/once/dist/index.js
var require_dist13 = __commonJS2((exports2, module2) => {
  "use strict";
  function noop() {
  }
  function once(emitter, name) {
    const o = once.spread(emitter, name);
    const r = o.then((args) => args[0]);
    r.cancel = o.cancel;
    return r;
  }
  (function(once2) {
    function spread(emitter, name) {
      let c = null;
      const p = new Promise((resolve, reject) => {
        function cancel() {
          emitter.removeListener(name, onEvent);
          emitter.removeListener("error", onError);
          p.cancel = noop;
        }
        function onEvent(...args) {
          cancel();
          resolve(args);
        }
        function onError(err) {
          cancel();
          reject(err);
        }
        c = cancel;
        emitter.on(name, onEvent);
        emitter.on("error", onError);
      });
      if (!c) {
        throw new TypeError("Could not get `cancel()` function");
      }
      p.cancel = c;
      return p;
    }
    once2.spread = spread;
  })(once || (once = {}));
  module2.exports = once;
});

// ../../node_modules/.pnpm/http-proxy-agent@4.0.1/node_modules/http-proxy-agent/dist/agent.js
var require_agent4 = __commonJS2((exports2) => {
  "use strict";
  var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : {default: mod2};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  var net_1 = __importDefault2(require("net"));
  var tls_1 = __importDefault2(require("tls"));
  var url_1 = __importDefault2(require("url"));
  var debug_12 = __importDefault2(require_src3());
  var once_1 = __importDefault2(require_dist13());
  var agent_base_1 = require_src5();
  var debug4 = debug_12.default("http-proxy-agent");
  function isHTTPS(protocol) {
    return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
  }
  var HttpProxyAgent = class extends agent_base_1.Agent {
    constructor(_opts) {
      let opts;
      if (typeof _opts === "string") {
        opts = url_1.default.parse(_opts);
      } else {
        opts = _opts;
      }
      if (!opts) {
        throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
      }
      debug4("Creating new HttpProxyAgent instance: %o", opts);
      super(opts);
      const proxy = Object.assign({}, opts);
      this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
      proxy.host = proxy.hostname || proxy.host;
      if (typeof proxy.port === "string") {
        proxy.port = parseInt(proxy.port, 10);
      }
      if (!proxy.port && proxy.host) {
        proxy.port = this.secureProxy ? 443 : 80;
      }
      if (proxy.host && proxy.path) {
        delete proxy.path;
        delete proxy.pathname;
      }
      this.proxy = proxy;
    }
    callback(req, opts) {
      return __awaiter(this, void 0, void 0, function* () {
        const {proxy, secureProxy} = this;
        const parsed = url_1.default.parse(req.path);
        if (!parsed.protocol) {
          parsed.protocol = "http:";
        }
        if (!parsed.hostname) {
          parsed.hostname = opts.hostname || opts.host || null;
        }
        if (parsed.port == null && typeof opts.port) {
          parsed.port = String(opts.port);
        }
        if (parsed.port === "80") {
          delete parsed.port;
        }
        req.path = url_1.default.format(parsed);
        if (proxy.auth) {
          req.setHeader("Proxy-Authorization", `Basic ${Buffer.from(proxy.auth).toString("base64")}`);
        }
        let socket;
        if (secureProxy) {
          debug4("Creating `tls.Socket`: %o", proxy);
          socket = tls_1.default.connect(proxy);
        } else {
          debug4("Creating `net.Socket`: %o", proxy);
          socket = net_1.default.connect(proxy);
        }
        if (req._header) {
          let first;
          let endOfHeaders;
          debug4("Regenerating stored HTTP header string for request");
          req._header = null;
          req._implicitHeader();
          if (req.output && req.output.length > 0) {
            debug4("Patching connection write() output buffer with updated header");
            first = req.output[0];
            endOfHeaders = first.indexOf("\r\n\r\n") + 4;
            req.output[0] = req._header + first.substring(endOfHeaders);
            debug4("Output buffer: %o", req.output);
          } else if (req.outputData && req.outputData.length > 0) {
            debug4("Patching connection write() output buffer with updated header");
            first = req.outputData[0].data;
            endOfHeaders = first.indexOf("\r\n\r\n") + 4;
            req.outputData[0].data = req._header + first.substring(endOfHeaders);
            debug4("Output buffer: %o", req.outputData[0].data);
          }
        }
        yield once_1.default(socket, "connect");
        return socket;
      });
    }
  };
  exports2.default = HttpProxyAgent;
});

// ../../node_modules/.pnpm/http-proxy-agent@4.0.1/node_modules/http-proxy-agent/dist/index.js
var require_dist14 = __commonJS2((exports2, module2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : {default: mod2};
  };
  var agent_1 = __importDefault2(require_agent4());
  function createHttpProxyAgent(opts) {
    return new agent_1.default(opts);
  }
  (function(createHttpProxyAgent2) {
    createHttpProxyAgent2.HttpProxyAgent = agent_1.default;
    createHttpProxyAgent2.prototype = agent_1.default.prototype;
  })(createHttpProxyAgent || (createHttpProxyAgent = {}));
  module2.exports = createHttpProxyAgent;
});

// ../../node_modules/.pnpm/@prisma+fetch-engine@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/fetch-engine/dist/getProxyAgent.js
var require_getProxyAgent2 = __commonJS2((exports2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : {default: mod2};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getProxyAgent = void 0;
  var https_proxy_agent_1 = __importDefault2(require_dist12());
  var http_proxy_agent_1 = __importDefault2(require_dist14());
  var url_1 = __importDefault2(require("url"));
  function formatHostname(hostname) {
    return hostname.replace(/^\.*/, ".").toLowerCase();
  }
  function parseNoProxyZone(zone) {
    zone = zone.trim().toLowerCase();
    const zoneParts = zone.split(":", 2);
    const zoneHost = formatHostname(zoneParts[0]);
    const zonePort = zoneParts[1];
    const hasPort = zone.includes(":");
    return {hostname: zoneHost, port: zonePort, hasPort};
  }
  function uriInNoProxy(uri, noProxy) {
    const port = uri.port || (uri.protocol === "https:" ? "443" : "80");
    const hostname = formatHostname(uri.hostname);
    const noProxyList = noProxy.split(",");
    return noProxyList.map(parseNoProxyZone).some(function(noProxyZone) {
      const isMatchedAt = hostname.indexOf(noProxyZone.hostname);
      const hostnameMatched = isMatchedAt > -1 && isMatchedAt === hostname.length - noProxyZone.hostname.length;
      if (noProxyZone.hasPort) {
        return port === noProxyZone.port && hostnameMatched;
      }
      return hostnameMatched;
    });
  }
  function getProxyFromURI(uri) {
    const noProxy = process.env.NO_PROXY || process.env.no_proxy || "";
    if (noProxy === "*") {
      return null;
    }
    if (noProxy !== "" && uriInNoProxy(uri, noProxy)) {
      return null;
    }
    if (uri.protocol === "http:") {
      return process.env.HTTP_PROXY || process.env.http_proxy || null;
    }
    if (uri.protocol === "https:") {
      return process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy || null;
    }
    return null;
  }
  function getProxyAgent(url) {
    const uri = url_1.default.parse(url);
    const proxy = getProxyFromURI(uri);
    if (!proxy) {
      return void 0;
    }
    if (uri.protocol === "http:") {
      return http_proxy_agent_1.default(proxy);
    }
    if (uri.protocol === "https:") {
      return https_proxy_agent_1.default(proxy);
    }
    return void 0;
  }
  exports2.getProxyAgent = getProxyAgent;
});

// ../../node_modules/.pnpm/crypto-random-string@2.0.0/node_modules/crypto-random-string/index.js
var require_crypto_random_string2 = __commonJS2((exports2, module2) => {
  "use strict";
  var crypto2 = require("crypto");
  module2.exports = (length) => {
    if (!Number.isFinite(length)) {
      throw new TypeError("Expected a finite number");
    }
    return crypto2.randomBytes(Math.ceil(length / 2)).toString("hex").slice(0, length);
  };
});

// ../../node_modules/.pnpm/unique-string@2.0.0/node_modules/unique-string/index.js
var require_unique_string2 = __commonJS2((exports2, module2) => {
  "use strict";
  var cryptoRandomString = require_crypto_random_string2();
  module2.exports = () => cryptoRandomString(32);
});

// ../../node_modules/.pnpm/array-union@2.1.0/node_modules/array-union/index.js
var require_array_union2 = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = (...arguments_) => {
    return [...new Set([].concat(...arguments_))];
  };
});

// ../../node_modules/.pnpm/merge2@1.4.1/node_modules/merge2/index.js
var require_merge22 = __commonJS2((exports2, module2) => {
  "use strict";
  var Stream = require("stream");
  var PassThrough = Stream.PassThrough;
  var slice = Array.prototype.slice;
  module2.exports = merge2;
  function merge2() {
    const streamsQueue = [];
    const args = slice.call(arguments);
    let merging = false;
    let options = args[args.length - 1];
    if (options && !Array.isArray(options) && options.pipe == null) {
      args.pop();
    } else {
      options = {};
    }
    const doEnd = options.end !== false;
    const doPipeError = options.pipeError === true;
    if (options.objectMode == null) {
      options.objectMode = true;
    }
    if (options.highWaterMark == null) {
      options.highWaterMark = 64 * 1024;
    }
    const mergedStream = PassThrough(options);
    function addStream() {
      for (let i = 0, len = arguments.length; i < len; i++) {
        streamsQueue.push(pauseStreams(arguments[i], options));
      }
      mergeStream();
      return this;
    }
    function mergeStream() {
      if (merging) {
        return;
      }
      merging = true;
      let streams = streamsQueue.shift();
      if (!streams) {
        process.nextTick(endStream);
        return;
      }
      if (!Array.isArray(streams)) {
        streams = [streams];
      }
      let pipesCount = streams.length + 1;
      function next() {
        if (--pipesCount > 0) {
          return;
        }
        merging = false;
        mergeStream();
      }
      function pipe(stream) {
        function onend() {
          stream.removeListener("merge2UnpipeEnd", onend);
          stream.removeListener("end", onend);
          if (doPipeError) {
            stream.removeListener("error", onerror);
          }
          next();
        }
        function onerror(err) {
          mergedStream.emit("error", err);
        }
        if (stream._readableState.endEmitted) {
          return next();
        }
        stream.on("merge2UnpipeEnd", onend);
        stream.on("end", onend);
        if (doPipeError) {
          stream.on("error", onerror);
        }
        stream.pipe(mergedStream, {end: false});
        stream.resume();
      }
      for (let i = 0; i < streams.length; i++) {
        pipe(streams[i]);
      }
      next();
    }
    function endStream() {
      merging = false;
      mergedStream.emit("queueDrain");
      if (doEnd) {
        mergedStream.end();
      }
    }
    mergedStream.setMaxListeners(0);
    mergedStream.add = addStream;
    mergedStream.on("unpipe", function(stream) {
      stream.emit("merge2UnpipeEnd");
    });
    if (args.length) {
      addStream.apply(null, args);
    }
    return mergedStream;
  }
  function pauseStreams(streams, options) {
    if (!Array.isArray(streams)) {
      if (!streams._readableState && streams.pipe) {
        streams = streams.pipe(PassThrough(options));
      }
      if (!streams._readableState || !streams.pause || !streams.pipe) {
        throw new Error("Only readable stream can be merged.");
      }
      streams.pause();
    } else {
      for (let i = 0, len = streams.length; i < len; i++) {
        streams[i] = pauseStreams(streams[i], options);
      }
    }
    return streams;
  }
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/utils/array.js
var require_array2 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.splitWhen = exports2.flatten = void 0;
  function flatten(items) {
    return items.reduce((collection, item) => [].concat(collection, item), []);
  }
  exports2.flatten = flatten;
  function splitWhen(items, predicate) {
    const result = [[]];
    let groupIndex = 0;
    for (const item of items) {
      if (predicate(item)) {
        groupIndex++;
        result[groupIndex] = [];
      } else {
        result[groupIndex].push(item);
      }
    }
    return result;
  }
  exports2.splitWhen = splitWhen;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/utils/errno.js
var require_errno2 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.isEnoentCodeError = void 0;
  function isEnoentCodeError(error) {
    return error.code === "ENOENT";
  }
  exports2.isEnoentCodeError = isEnoentCodeError;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/utils/fs.js
var require_fs7 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.createDirentFromStats = void 0;
  var DirentFromStats = class {
    constructor(name, stats) {
      this.name = name;
      this.isBlockDevice = stats.isBlockDevice.bind(stats);
      this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
      this.isDirectory = stats.isDirectory.bind(stats);
      this.isFIFO = stats.isFIFO.bind(stats);
      this.isFile = stats.isFile.bind(stats);
      this.isSocket = stats.isSocket.bind(stats);
      this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
    }
  };
  function createDirentFromStats(name, stats) {
    return new DirentFromStats(name, stats);
  }
  exports2.createDirentFromStats = createDirentFromStats;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/utils/path.js
var require_path2 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.removeLeadingDotSegment = exports2.escape = exports2.makeAbsolute = exports2.unixify = void 0;
  var path4 = require("path");
  var LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;
  var UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g;
  function unixify(filepath) {
    return filepath.replace(/\\/g, "/");
  }
  exports2.unixify = unixify;
  function makeAbsolute(cwd, filepath) {
    return path4.resolve(cwd, filepath);
  }
  exports2.makeAbsolute = makeAbsolute;
  function escape(pattern) {
    return pattern.replace(UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
  }
  exports2.escape = escape;
  function removeLeadingDotSegment(entry) {
    if (entry.charAt(0) === ".") {
      const secondCharactery = entry.charAt(1);
      if (secondCharactery === "/" || secondCharactery === "\\") {
        return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
      }
    }
    return entry;
  }
  exports2.removeLeadingDotSegment = removeLeadingDotSegment;
});

// ../../node_modules/.pnpm/is-extglob@2.1.1/node_modules/is-extglob/index.js
var require_is_extglob2 = __commonJS2((exports2, module2) => {
  /*!
   * is-extglob <https://github.com/jonschlinkert/is-extglob>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  module2.exports = function isExtglob(str) {
    if (typeof str !== "string" || str === "") {
      return false;
    }
    var match;
    while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
      if (match[2])
        return true;
      str = str.slice(match.index + match[0].length);
    }
    return false;
  };
});

// ../../node_modules/.pnpm/is-glob@4.0.1/node_modules/is-glob/index.js
var require_is_glob2 = __commonJS2((exports2, module2) => {
  /*!
   * is-glob <https://github.com/jonschlinkert/is-glob>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  var isExtglob = require_is_extglob2();
  var chars = {"{": "}", "(": ")", "[": "]"};
  var strictRegex = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
  var relaxedRegex = /\\(.)|(^!|[*?{}()[\]]|\(\?)/;
  module2.exports = function isGlob(str, options) {
    if (typeof str !== "string" || str === "") {
      return false;
    }
    if (isExtglob(str)) {
      return true;
    }
    var regex = strictRegex;
    var match;
    if (options && options.strict === false) {
      regex = relaxedRegex;
    }
    while (match = regex.exec(str)) {
      if (match[2])
        return true;
      var idx = match.index + match[0].length;
      var open2 = match[1];
      var close2 = open2 ? chars[open2] : null;
      if (open2 && close2) {
        var n = str.indexOf(close2, idx);
        if (n !== -1) {
          idx = n + 1;
        }
      }
      str = str.slice(idx);
    }
    return false;
  };
});

// ../../node_modules/.pnpm/glob-parent@5.1.2/node_modules/glob-parent/index.js
var require_glob_parent2 = __commonJS2((exports2, module2) => {
  "use strict";
  var isGlob = require_is_glob2();
  var pathPosixDirname = require("path").posix.dirname;
  var isWin32 = require("os").platform() === "win32";
  var slash = "/";
  var backslash = /\\/g;
  var enclosure = /[\{\[].*[\}\]]$/;
  var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
  var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
  module2.exports = function globParent(str, opts) {
    var options = Object.assign({flipBackslashes: true}, opts);
    if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
      str = str.replace(backslash, slash);
    }
    if (enclosure.test(str)) {
      str += slash;
    }
    str += "a";
    do {
      str = pathPosixDirname(str);
    } while (isGlob(str) || globby.test(str));
    return str.replace(escaped, "$1");
  };
});

// ../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/utils.js
var require_utils6 = __commonJS2((exports2) => {
  "use strict";
  exports2.isInteger = (num) => {
    if (typeof num === "number") {
      return Number.isInteger(num);
    }
    if (typeof num === "string" && num.trim() !== "") {
      return Number.isInteger(Number(num));
    }
    return false;
  };
  exports2.find = (node, type) => node.nodes.find((node2) => node2.type === type);
  exports2.exceedsLimit = (min2, max2, step = 1, limit) => {
    if (limit === false)
      return false;
    if (!exports2.isInteger(min2) || !exports2.isInteger(max2))
      return false;
    return (Number(max2) - Number(min2)) / Number(step) >= limit;
  };
  exports2.escapeNode = (block, n = 0, type) => {
    let node = block.nodes[n];
    if (!node)
      return;
    if (type && node.type === type || node.type === "open" || node.type === "close") {
      if (node.escaped !== true) {
        node.value = "\\" + node.value;
        node.escaped = true;
      }
    }
  };
  exports2.encloseBrace = (node) => {
    if (node.type !== "brace")
      return false;
    if (node.commas >> 0 + node.ranges >> 0 === 0) {
      node.invalid = true;
      return true;
    }
    return false;
  };
  exports2.isInvalidBrace = (block) => {
    if (block.type !== "brace")
      return false;
    if (block.invalid === true || block.dollar)
      return true;
    if (block.commas >> 0 + block.ranges >> 0 === 0) {
      block.invalid = true;
      return true;
    }
    if (block.open !== true || block.close !== true) {
      block.invalid = true;
      return true;
    }
    return false;
  };
  exports2.isOpenOrClose = (node) => {
    if (node.type === "open" || node.type === "close") {
      return true;
    }
    return node.open === true || node.close === true;
  };
  exports2.reduce = (nodes) => nodes.reduce((acc, node) => {
    if (node.type === "text")
      acc.push(node.value);
    if (node.type === "range")
      node.type = "text";
    return acc;
  }, []);
  exports2.flatten = (...args) => {
    const result = [];
    const flat = (arr) => {
      for (let i = 0; i < arr.length; i++) {
        let ele = arr[i];
        Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
      }
      return result;
    };
    flat(args);
    return result;
  };
});

// ../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/stringify.js
var require_stringify2 = __commonJS2((exports2, module2) => {
  "use strict";
  var utils = require_utils6();
  module2.exports = (ast, options = {}) => {
    let stringify2 = (node, parent = {}) => {
      let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
      let invalidNode = node.invalid === true && options.escapeInvalid === true;
      let output = "";
      if (node.value) {
        if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
          return "\\" + node.value;
        }
        return node.value;
      }
      if (node.value) {
        return node.value;
      }
      if (node.nodes) {
        for (let child of node.nodes) {
          output += stringify2(child);
        }
      }
      return output;
    };
    return stringify2(ast);
  };
});

// ../../node_modules/.pnpm/is-number@7.0.0/node_modules/is-number/index.js
var require_is_number2 = __commonJS2((exports2, module2) => {
  /*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  module2.exports = function(num) {
    if (typeof num === "number") {
      return num - num === 0;
    }
    if (typeof num === "string" && num.trim() !== "") {
      return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
    }
    return false;
  };
});

// ../../node_modules/.pnpm/to-regex-range@5.0.1/node_modules/to-regex-range/index.js
var require_to_regex_range2 = __commonJS2((exports2, module2) => {
  /*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  var isNumber = require_is_number2();
  var toRegexRange = (min2, max2, options) => {
    if (isNumber(min2) === false) {
      throw new TypeError("toRegexRange: expected the first argument to be a number");
    }
    if (max2 === void 0 || min2 === max2) {
      return String(min2);
    }
    if (isNumber(max2) === false) {
      throw new TypeError("toRegexRange: expected the second argument to be a number.");
    }
    let opts = {relaxZeros: true, ...options};
    if (typeof opts.strictZeros === "boolean") {
      opts.relaxZeros = opts.strictZeros === false;
    }
    let relax = String(opts.relaxZeros);
    let shorthand = String(opts.shorthand);
    let capture = String(opts.capture);
    let wrap = String(opts.wrap);
    let cacheKey = min2 + ":" + max2 + "=" + relax + shorthand + capture + wrap;
    if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
      return toRegexRange.cache[cacheKey].result;
    }
    let a = Math.min(min2, max2);
    let b = Math.max(min2, max2);
    if (Math.abs(a - b) === 1) {
      let result = min2 + "|" + max2;
      if (opts.capture) {
        return `(${result})`;
      }
      if (opts.wrap === false) {
        return result;
      }
      return `(?:${result})`;
    }
    let isPadded = hasPadding(min2) || hasPadding(max2);
    let state = {min: min2, max: max2, a, b};
    let positives = [];
    let negatives = [];
    if (isPadded) {
      state.isPadded = isPadded;
      state.maxLen = String(state.max).length;
    }
    if (a < 0) {
      let newMin = b < 0 ? Math.abs(b) : 1;
      negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
      a = state.a = 0;
    }
    if (b >= 0) {
      positives = splitToPatterns(a, b, state, opts);
    }
    state.negatives = negatives;
    state.positives = positives;
    state.result = collatePatterns(negatives, positives, opts);
    if (opts.capture === true) {
      state.result = `(${state.result})`;
    } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
      state.result = `(?:${state.result})`;
    }
    toRegexRange.cache[cacheKey] = state;
    return state.result;
  };
  function collatePatterns(neg, pos, options) {
    let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
    let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
    let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
    let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
    return subpatterns.join("|");
  }
  function splitToRanges(min2, max2) {
    let nines = 1;
    let zeros = 1;
    let stop = countNines(min2, nines);
    let stops = new Set([max2]);
    while (min2 <= stop && stop <= max2) {
      stops.add(stop);
      nines += 1;
      stop = countNines(min2, nines);
    }
    stop = countZeros(max2 + 1, zeros) - 1;
    while (min2 < stop && stop <= max2) {
      stops.add(stop);
      zeros += 1;
      stop = countZeros(max2 + 1, zeros) - 1;
    }
    stops = [...stops];
    stops.sort(compare);
    return stops;
  }
  function rangeToPattern(start, stop, options) {
    if (start === stop) {
      return {pattern: start, count: [], digits: 0};
    }
    let zipped = zip(start, stop);
    let digits = zipped.length;
    let pattern = "";
    let count = 0;
    for (let i = 0; i < digits; i++) {
      let [startDigit, stopDigit] = zipped[i];
      if (startDigit === stopDigit) {
        pattern += startDigit;
      } else if (startDigit !== "0" || stopDigit !== "9") {
        pattern += toCharacterClass(startDigit, stopDigit, options);
      } else {
        count++;
      }
    }
    if (count) {
      pattern += options.shorthand === true ? "\\d" : "[0-9]";
    }
    return {pattern, count: [count], digits};
  }
  function splitToPatterns(min2, max2, tok, options) {
    let ranges = splitToRanges(min2, max2);
    let tokens = [];
    let start = min2;
    let prev;
    for (let i = 0; i < ranges.length; i++) {
      let max3 = ranges[i];
      let obj = rangeToPattern(String(start), String(max3), options);
      let zeros = "";
      if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
        if (prev.count.length > 1) {
          prev.count.pop();
        }
        prev.count.push(obj.count[0]);
        prev.string = prev.pattern + toQuantifier(prev.count);
        start = max3 + 1;
        continue;
      }
      if (tok.isPadded) {
        zeros = padZeros(max3, tok, options);
      }
      obj.string = zeros + obj.pattern + toQuantifier(obj.count);
      tokens.push(obj);
      start = max3 + 1;
      prev = obj;
    }
    return tokens;
  }
  function filterPatterns(arr, comparison, prefix, intersection, options) {
    let result = [];
    for (let ele of arr) {
      let {string} = ele;
      if (!intersection && !contains(comparison, "string", string)) {
        result.push(prefix + string);
      }
      if (intersection && contains(comparison, "string", string)) {
        result.push(prefix + string);
      }
    }
    return result;
  }
  function zip(a, b) {
    let arr = [];
    for (let i = 0; i < a.length; i++)
      arr.push([a[i], b[i]]);
    return arr;
  }
  function compare(a, b) {
    return a > b ? 1 : b > a ? -1 : 0;
  }
  function contains(arr, key, val) {
    return arr.some((ele) => ele[key] === val);
  }
  function countNines(min2, len) {
    return Number(String(min2).slice(0, -len) + "9".repeat(len));
  }
  function countZeros(integer, zeros) {
    return integer - integer % Math.pow(10, zeros);
  }
  function toQuantifier(digits) {
    let [start = 0, stop = ""] = digits;
    if (stop || start > 1) {
      return `{${start + (stop ? "," + stop : "")}}`;
    }
    return "";
  }
  function toCharacterClass(a, b, options) {
    return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
  }
  function hasPadding(str) {
    return /^-?(0+)\d/.test(str);
  }
  function padZeros(value, tok, options) {
    if (!tok.isPadded) {
      return value;
    }
    let diff = Math.abs(tok.maxLen - String(value).length);
    let relax = options.relaxZeros !== false;
    switch (diff) {
      case 0:
        return "";
      case 1:
        return relax ? "0?" : "0";
      case 2:
        return relax ? "0{0,2}" : "00";
      default: {
        return relax ? `0{0,${diff}}` : `0{${diff}}`;
      }
    }
  }
  toRegexRange.cache = {};
  toRegexRange.clearCache = () => toRegexRange.cache = {};
  module2.exports = toRegexRange;
});

// ../../node_modules/.pnpm/fill-range@7.0.1/node_modules/fill-range/index.js
var require_fill_range2 = __commonJS2((exports2, module2) => {
  /*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  "use strict";
  var util2 = require("util");
  var toRegexRange = require_to_regex_range2();
  var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
  var transform = (toNumber) => {
    return (value) => toNumber === true ? Number(value) : String(value);
  };
  var isValidValue = (value) => {
    return typeof value === "number" || typeof value === "string" && value !== "";
  };
  var isNumber = (num) => Number.isInteger(+num);
  var zeros = (input) => {
    let value = `${input}`;
    let index = -1;
    if (value[0] === "-")
      value = value.slice(1);
    if (value === "0")
      return false;
    while (value[++index] === "0")
      ;
    return index > 0;
  };
  var stringify2 = (start, end, options) => {
    if (typeof start === "string" || typeof end === "string") {
      return true;
    }
    return options.stringify === true;
  };
  var pad = (input, maxLength, toNumber) => {
    if (maxLength > 0) {
      let dash = input[0] === "-" ? "-" : "";
      if (dash)
        input = input.slice(1);
      input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
    }
    if (toNumber === false) {
      return String(input);
    }
    return input;
  };
  var toMaxLen = (input, maxLength) => {
    let negative = input[0] === "-" ? "-" : "";
    if (negative) {
      input = input.slice(1);
      maxLength--;
    }
    while (input.length < maxLength)
      input = "0" + input;
    return negative ? "-" + input : input;
  };
  var toSequence = (parts, options) => {
    parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
    parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
    let prefix = options.capture ? "" : "?:";
    let positives = "";
    let negatives = "";
    let result;
    if (parts.positives.length) {
      positives = parts.positives.join("|");
    }
    if (parts.negatives.length) {
      negatives = `-(${prefix}${parts.negatives.join("|")})`;
    }
    if (positives && negatives) {
      result = `${positives}|${negatives}`;
    } else {
      result = positives || negatives;
    }
    if (options.wrap) {
      return `(${prefix}${result})`;
    }
    return result;
  };
  var toRange = (a, b, isNumbers, options) => {
    if (isNumbers) {
      return toRegexRange(a, b, {wrap: false, ...options});
    }
    let start = String.fromCharCode(a);
    if (a === b)
      return start;
    let stop = String.fromCharCode(b);
    return `[${start}-${stop}]`;
  };
  var toRegex = (start, end, options) => {
    if (Array.isArray(start)) {
      let wrap = options.wrap === true;
      let prefix = options.capture ? "" : "?:";
      return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
    }
    return toRegexRange(start, end, options);
  };
  var rangeError = (...args) => {
    return new RangeError("Invalid range arguments: " + util2.inspect(...args));
  };
  var invalidRange = (start, end, options) => {
    if (options.strictRanges === true)
      throw rangeError([start, end]);
    return [];
  };
  var invalidStep = (step, options) => {
    if (options.strictRanges === true) {
      throw new TypeError(`Expected step "${step}" to be a number`);
    }
    return [];
  };
  var fillNumbers = (start, end, step = 1, options = {}) => {
    let a = Number(start);
    let b = Number(end);
    if (!Number.isInteger(a) || !Number.isInteger(b)) {
      if (options.strictRanges === true)
        throw rangeError([start, end]);
      return [];
    }
    if (a === 0)
      a = 0;
    if (b === 0)
      b = 0;
    let descending = a > b;
    let startString = String(start);
    let endString = String(end);
    let stepString = String(step);
    step = Math.max(Math.abs(step), 1);
    let padded = zeros(startString) || zeros(endString) || zeros(stepString);
    let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
    let toNumber = padded === false && stringify2(start, end, options) === false;
    let format2 = options.transform || transform(toNumber);
    if (options.toRegex && step === 1) {
      return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
    }
    let parts = {negatives: [], positives: []};
    let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
    let range = [];
    let index = 0;
    while (descending ? a >= b : a <= b) {
      if (options.toRegex === true && step > 1) {
        push(a);
      } else {
        range.push(pad(format2(a, index), maxLen, toNumber));
      }
      a = descending ? a - step : a + step;
      index++;
    }
    if (options.toRegex === true) {
      return step > 1 ? toSequence(parts, options) : toRegex(range, null, {wrap: false, ...options});
    }
    return range;
  };
  var fillLetters = (start, end, step = 1, options = {}) => {
    if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
      return invalidRange(start, end, options);
    }
    let format2 = options.transform || ((val) => String.fromCharCode(val));
    let a = `${start}`.charCodeAt(0);
    let b = `${end}`.charCodeAt(0);
    let descending = a > b;
    let min2 = Math.min(a, b);
    let max2 = Math.max(a, b);
    if (options.toRegex && step === 1) {
      return toRange(min2, max2, false, options);
    }
    let range = [];
    let index = 0;
    while (descending ? a >= b : a <= b) {
      range.push(format2(a, index));
      a = descending ? a - step : a + step;
      index++;
    }
    if (options.toRegex === true) {
      return toRegex(range, null, {wrap: false, options});
    }
    return range;
  };
  var fill = (start, end, step, options = {}) => {
    if (end == null && isValidValue(start)) {
      return [start];
    }
    if (!isValidValue(start) || !isValidValue(end)) {
      return invalidRange(start, end, options);
    }
    if (typeof step === "function") {
      return fill(start, end, 1, {transform: step});
    }
    if (isObject(step)) {
      return fill(start, end, 0, step);
    }
    let opts = {...options};
    if (opts.capture === true)
      opts.wrap = true;
    step = step || opts.step || 1;
    if (!isNumber(step)) {
      if (step != null && !isObject(step))
        return invalidStep(step, opts);
      return fill(start, end, 1, step);
    }
    if (isNumber(start) && isNumber(end)) {
      return fillNumbers(start, end, step, opts);
    }
    return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
  };
  module2.exports = fill;
});

// ../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/compile.js
var require_compile2 = __commonJS2((exports2, module2) => {
  "use strict";
  var fill = require_fill_range2();
  var utils = require_utils6();
  var compile = (ast, options = {}) => {
    let walk = (node, parent = {}) => {
      let invalidBlock = utils.isInvalidBrace(parent);
      let invalidNode = node.invalid === true && options.escapeInvalid === true;
      let invalid = invalidBlock === true || invalidNode === true;
      let prefix = options.escapeInvalid === true ? "\\" : "";
      let output = "";
      if (node.isOpen === true) {
        return prefix + node.value;
      }
      if (node.isClose === true) {
        return prefix + node.value;
      }
      if (node.type === "open") {
        return invalid ? prefix + node.value : "(";
      }
      if (node.type === "close") {
        return invalid ? prefix + node.value : ")";
      }
      if (node.type === "comma") {
        return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
      }
      if (node.value) {
        return node.value;
      }
      if (node.nodes && node.ranges > 0) {
        let args = utils.reduce(node.nodes);
        let range = fill(...args, {...options, wrap: false, toRegex: true});
        if (range.length !== 0) {
          return args.length > 1 && range.length > 1 ? `(${range})` : range;
        }
      }
      if (node.nodes) {
        for (let child of node.nodes) {
          output += walk(child, node);
        }
      }
      return output;
    };
    return walk(ast);
  };
  module2.exports = compile;
});

// ../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/expand.js
var require_expand2 = __commonJS2((exports2, module2) => {
  "use strict";
  var fill = require_fill_range2();
  var stringify2 = require_stringify2();
  var utils = require_utils6();
  var append = (queue = "", stash = "", enclose = false) => {
    let result = [];
    queue = [].concat(queue);
    stash = [].concat(stash);
    if (!stash.length)
      return queue;
    if (!queue.length) {
      return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
    }
    for (let item of queue) {
      if (Array.isArray(item)) {
        for (let value of item) {
          result.push(append(value, stash, enclose));
        }
      } else {
        for (let ele of stash) {
          if (enclose === true && typeof ele === "string")
            ele = `{${ele}}`;
          result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
        }
      }
    }
    return utils.flatten(result);
  };
  var expand = (ast, options = {}) => {
    let rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
    let walk = (node, parent = {}) => {
      node.queue = [];
      let p = parent;
      let q = parent.queue;
      while (p.type !== "brace" && p.type !== "root" && p.parent) {
        p = p.parent;
        q = p.queue;
      }
      if (node.invalid || node.dollar) {
        q.push(append(q.pop(), stringify2(node, options)));
        return;
      }
      if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
        q.push(append(q.pop(), ["{}"]));
        return;
      }
      if (node.nodes && node.ranges > 0) {
        let args = utils.reduce(node.nodes);
        if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
          throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
        }
        let range = fill(...args, options);
        if (range.length === 0) {
          range = stringify2(node, options);
        }
        q.push(append(q.pop(), range));
        node.nodes = [];
        return;
      }
      let enclose = utils.encloseBrace(node);
      let queue = node.queue;
      let block = node;
      while (block.type !== "brace" && block.type !== "root" && block.parent) {
        block = block.parent;
        queue = block.queue;
      }
      for (let i = 0; i < node.nodes.length; i++) {
        let child = node.nodes[i];
        if (child.type === "comma" && node.type === "brace") {
          if (i === 1)
            queue.push("");
          queue.push("");
          continue;
        }
        if (child.type === "close") {
          q.push(append(q.pop(), queue, enclose));
          continue;
        }
        if (child.value && child.type !== "open") {
          queue.push(append(queue.pop(), child.value));
          continue;
        }
        if (child.nodes) {
          walk(child, node);
        }
      }
      return queue;
    };
    return utils.flatten(walk(ast));
  };
  module2.exports = expand;
});

// ../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/constants.js
var require_constants5 = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = {
    MAX_LENGTH: 1024 * 64,
    CHAR_0: "0",
    CHAR_9: "9",
    CHAR_UPPERCASE_A: "A",
    CHAR_LOWERCASE_A: "a",
    CHAR_UPPERCASE_Z: "Z",
    CHAR_LOWERCASE_Z: "z",
    CHAR_LEFT_PARENTHESES: "(",
    CHAR_RIGHT_PARENTHESES: ")",
    CHAR_ASTERISK: "*",
    CHAR_AMPERSAND: "&",
    CHAR_AT: "@",
    CHAR_BACKSLASH: "\\",
    CHAR_BACKTICK: "`",
    CHAR_CARRIAGE_RETURN: "\r",
    CHAR_CIRCUMFLEX_ACCENT: "^",
    CHAR_COLON: ":",
    CHAR_COMMA: ",",
    CHAR_DOLLAR: "$",
    CHAR_DOT: ".",
    CHAR_DOUBLE_QUOTE: '"',
    CHAR_EQUAL: "=",
    CHAR_EXCLAMATION_MARK: "!",
    CHAR_FORM_FEED: "\f",
    CHAR_FORWARD_SLASH: "/",
    CHAR_HASH: "#",
    CHAR_HYPHEN_MINUS: "-",
    CHAR_LEFT_ANGLE_BRACKET: "<",
    CHAR_LEFT_CURLY_BRACE: "{",
    CHAR_LEFT_SQUARE_BRACKET: "[",
    CHAR_LINE_FEED: "\n",
    CHAR_NO_BREAK_SPACE: "\xA0",
    CHAR_PERCENT: "%",
    CHAR_PLUS: "+",
    CHAR_QUESTION_MARK: "?",
    CHAR_RIGHT_ANGLE_BRACKET: ">",
    CHAR_RIGHT_CURLY_BRACE: "}",
    CHAR_RIGHT_SQUARE_BRACKET: "]",
    CHAR_SEMICOLON: ";",
    CHAR_SINGLE_QUOTE: "'",
    CHAR_SPACE: " ",
    CHAR_TAB: "	",
    CHAR_UNDERSCORE: "_",
    CHAR_VERTICAL_LINE: "|",
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
  };
});

// ../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/parse.js
var require_parse7 = __commonJS2((exports2, module2) => {
  "use strict";
  var stringify2 = require_stringify2();
  var {
    MAX_LENGTH,
    CHAR_BACKSLASH,
    CHAR_BACKTICK,
    CHAR_COMMA,
    CHAR_DOT,
    CHAR_LEFT_PARENTHESES,
    CHAR_RIGHT_PARENTHESES,
    CHAR_LEFT_CURLY_BRACE,
    CHAR_RIGHT_CURLY_BRACE,
    CHAR_LEFT_SQUARE_BRACKET,
    CHAR_RIGHT_SQUARE_BRACKET,
    CHAR_DOUBLE_QUOTE,
    CHAR_SINGLE_QUOTE,
    CHAR_NO_BREAK_SPACE,
    CHAR_ZERO_WIDTH_NOBREAK_SPACE
  } = require_constants5();
  var parse2 = (input, options = {}) => {
    if (typeof input !== "string") {
      throw new TypeError("Expected a string");
    }
    let opts = options || {};
    let max2 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    if (input.length > max2) {
      throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max2})`);
    }
    let ast = {type: "root", input, nodes: []};
    let stack = [ast];
    let block = ast;
    let prev = ast;
    let brackets = 0;
    let length = input.length;
    let index = 0;
    let depth = 0;
    let value;
    let memo = {};
    const advance = () => input[index++];
    const push = (node) => {
      if (node.type === "text" && prev.type === "dot") {
        prev.type = "text";
      }
      if (prev && prev.type === "text" && node.type === "text") {
        prev.value += node.value;
        return;
      }
      block.nodes.push(node);
      node.parent = block;
      node.prev = prev;
      prev = node;
      return node;
    };
    push({type: "bos"});
    while (index < length) {
      block = stack[stack.length - 1];
      value = advance();
      if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
        continue;
      }
      if (value === CHAR_BACKSLASH) {
        push({type: "text", value: (options.keepEscaping ? value : "") + advance()});
        continue;
      }
      if (value === CHAR_RIGHT_SQUARE_BRACKET) {
        push({type: "text", value: "\\" + value});
        continue;
      }
      if (value === CHAR_LEFT_SQUARE_BRACKET) {
        brackets++;
        let closed = true;
        let next;
        while (index < length && (next = advance())) {
          value += next;
          if (next === CHAR_LEFT_SQUARE_BRACKET) {
            brackets++;
            continue;
          }
          if (next === CHAR_BACKSLASH) {
            value += advance();
            continue;
          }
          if (next === CHAR_RIGHT_SQUARE_BRACKET) {
            brackets--;
            if (brackets === 0) {
              break;
            }
          }
        }
        push({type: "text", value});
        continue;
      }
      if (value === CHAR_LEFT_PARENTHESES) {
        block = push({type: "paren", nodes: []});
        stack.push(block);
        push({type: "text", value});
        continue;
      }
      if (value === CHAR_RIGHT_PARENTHESES) {
        if (block.type !== "paren") {
          push({type: "text", value});
          continue;
        }
        block = stack.pop();
        push({type: "text", value});
        block = stack[stack.length - 1];
        continue;
      }
      if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
        let open2 = value;
        let next;
        if (options.keepQuotes !== true) {
          value = "";
        }
        while (index < length && (next = advance())) {
          if (next === CHAR_BACKSLASH) {
            value += next + advance();
            continue;
          }
          if (next === open2) {
            if (options.keepQuotes === true)
              value += next;
            break;
          }
          value += next;
        }
        push({type: "text", value});
        continue;
      }
      if (value === CHAR_LEFT_CURLY_BRACE) {
        depth++;
        let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
        let brace = {
          type: "brace",
          open: true,
          close: false,
          dollar,
          depth,
          commas: 0,
          ranges: 0,
          nodes: []
        };
        block = push(brace);
        stack.push(block);
        push({type: "open", value});
        continue;
      }
      if (value === CHAR_RIGHT_CURLY_BRACE) {
        if (block.type !== "brace") {
          push({type: "text", value});
          continue;
        }
        let type = "close";
        block = stack.pop();
        block.close = true;
        push({type, value});
        depth--;
        block = stack[stack.length - 1];
        continue;
      }
      if (value === CHAR_COMMA && depth > 0) {
        if (block.ranges > 0) {
          block.ranges = 0;
          let open2 = block.nodes.shift();
          block.nodes = [open2, {type: "text", value: stringify2(block)}];
        }
        push({type: "comma", value});
        block.commas++;
        continue;
      }
      if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
        let siblings = block.nodes;
        if (depth === 0 || siblings.length === 0) {
          push({type: "text", value});
          continue;
        }
        if (prev.type === "dot") {
          block.range = [];
          prev.value += value;
          prev.type = "range";
          if (block.nodes.length !== 3 && block.nodes.length !== 5) {
            block.invalid = true;
            block.ranges = 0;
            prev.type = "text";
            continue;
          }
          block.ranges++;
          block.args = [];
          continue;
        }
        if (prev.type === "range") {
          siblings.pop();
          let before = siblings[siblings.length - 1];
          before.value += prev.value + value;
          prev = before;
          block.ranges--;
          continue;
        }
        push({type: "dot", value});
        continue;
      }
      push({type: "text", value});
    }
    do {
      block = stack.pop();
      if (block.type !== "root") {
        block.nodes.forEach((node) => {
          if (!node.nodes) {
            if (node.type === "open")
              node.isOpen = true;
            if (node.type === "close")
              node.isClose = true;
            if (!node.nodes)
              node.type = "text";
            node.invalid = true;
          }
        });
        let parent = stack[stack.length - 1];
        let index2 = parent.nodes.indexOf(block);
        parent.nodes.splice(index2, 1, ...block.nodes);
      }
    } while (stack.length > 0);
    push({type: "eos"});
    return ast;
  };
  module2.exports = parse2;
});

// ../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/index.js
var require_braces2 = __commonJS2((exports2, module2) => {
  "use strict";
  var stringify2 = require_stringify2();
  var compile = require_compile2();
  var expand = require_expand2();
  var parse2 = require_parse7();
  var braces = (input, options = {}) => {
    let output = [];
    if (Array.isArray(input)) {
      for (let pattern of input) {
        let result = braces.create(pattern, options);
        if (Array.isArray(result)) {
          output.push(...result);
        } else {
          output.push(result);
        }
      }
    } else {
      output = [].concat(braces.create(input, options));
    }
    if (options && options.expand === true && options.nodupes === true) {
      output = [...new Set(output)];
    }
    return output;
  };
  braces.parse = (input, options = {}) => parse2(input, options);
  braces.stringify = (input, options = {}) => {
    if (typeof input === "string") {
      return stringify2(braces.parse(input, options), options);
    }
    return stringify2(input, options);
  };
  braces.compile = (input, options = {}) => {
    if (typeof input === "string") {
      input = braces.parse(input, options);
    }
    return compile(input, options);
  };
  braces.expand = (input, options = {}) => {
    if (typeof input === "string") {
      input = braces.parse(input, options);
    }
    let result = expand(input, options);
    if (options.noempty === true) {
      result = result.filter(Boolean);
    }
    if (options.nodupes === true) {
      result = [...new Set(result)];
    }
    return result;
  };
  braces.create = (input, options = {}) => {
    if (input === "" || input.length < 3) {
      return [input];
    }
    return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
  };
  module2.exports = braces;
});

// ../../node_modules/.pnpm/picomatch@2.3.0/node_modules/picomatch/lib/constants.js
var require_constants6 = __commonJS2((exports2, module2) => {
  "use strict";
  var path4 = require("path");
  var WIN_SLASH = "\\\\/";
  var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
  var DOT_LITERAL = "\\.";
  var PLUS_LITERAL = "\\+";
  var QMARK_LITERAL = "\\?";
  var SLASH_LITERAL = "\\/";
  var ONE_CHAR = "(?=.)";
  var QMARK = "[^/]";
  var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
  var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
  var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
  var NO_DOT = `(?!${DOT_LITERAL})`;
  var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
  var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
  var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
  var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
  var STAR = `${QMARK}*?`;
  var POSIX_CHARS = {
    DOT_LITERAL,
    PLUS_LITERAL,
    QMARK_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    QMARK,
    END_ANCHOR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOTS,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR
  };
  var WINDOWS_CHARS = {
    ...POSIX_CHARS,
    SLASH_LITERAL: `[${WIN_SLASH}]`,
    QMARK: WIN_NO_SLASH,
    STAR: `${WIN_NO_SLASH}*?`,
    DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
    NO_DOT: `(?!${DOT_LITERAL})`,
    NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
    NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
    NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
    QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
    START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
    END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
  };
  var POSIX_REGEX_SOURCE = {
    alnum: "a-zA-Z0-9",
    alpha: "a-zA-Z",
    ascii: "\\x00-\\x7F",
    blank: " \\t",
    cntrl: "\\x00-\\x1F\\x7F",
    digit: "0-9",
    graph: "\\x21-\\x7E",
    lower: "a-z",
    print: "\\x20-\\x7E ",
    punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
    space: " \\t\\r\\n\\v\\f",
    upper: "A-Z",
    word: "A-Za-z0-9_",
    xdigit: "A-Fa-f0-9"
  };
  module2.exports = {
    MAX_LENGTH: 1024 * 64,
    POSIX_REGEX_SOURCE,
    REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
    REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
    REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
    REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
    REPLACEMENTS: {
      "***": "*",
      "**/**": "**",
      "**/**/**": "**"
    },
    CHAR_0: 48,
    CHAR_9: 57,
    CHAR_UPPERCASE_A: 65,
    CHAR_LOWERCASE_A: 97,
    CHAR_UPPERCASE_Z: 90,
    CHAR_LOWERCASE_Z: 122,
    CHAR_LEFT_PARENTHESES: 40,
    CHAR_RIGHT_PARENTHESES: 41,
    CHAR_ASTERISK: 42,
    CHAR_AMPERSAND: 38,
    CHAR_AT: 64,
    CHAR_BACKWARD_SLASH: 92,
    CHAR_CARRIAGE_RETURN: 13,
    CHAR_CIRCUMFLEX_ACCENT: 94,
    CHAR_COLON: 58,
    CHAR_COMMA: 44,
    CHAR_DOT: 46,
    CHAR_DOUBLE_QUOTE: 34,
    CHAR_EQUAL: 61,
    CHAR_EXCLAMATION_MARK: 33,
    CHAR_FORM_FEED: 12,
    CHAR_FORWARD_SLASH: 47,
    CHAR_GRAVE_ACCENT: 96,
    CHAR_HASH: 35,
    CHAR_HYPHEN_MINUS: 45,
    CHAR_LEFT_ANGLE_BRACKET: 60,
    CHAR_LEFT_CURLY_BRACE: 123,
    CHAR_LEFT_SQUARE_BRACKET: 91,
    CHAR_LINE_FEED: 10,
    CHAR_NO_BREAK_SPACE: 160,
    CHAR_PERCENT: 37,
    CHAR_PLUS: 43,
    CHAR_QUESTION_MARK: 63,
    CHAR_RIGHT_ANGLE_BRACKET: 62,
    CHAR_RIGHT_CURLY_BRACE: 125,
    CHAR_RIGHT_SQUARE_BRACKET: 93,
    CHAR_SEMICOLON: 59,
    CHAR_SINGLE_QUOTE: 39,
    CHAR_SPACE: 32,
    CHAR_TAB: 9,
    CHAR_UNDERSCORE: 95,
    CHAR_VERTICAL_LINE: 124,
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
    SEP: path4.sep,
    extglobChars(chars) {
      return {
        "!": {type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})`},
        "?": {type: "qmark", open: "(?:", close: ")?"},
        "+": {type: "plus", open: "(?:", close: ")+"},
        "*": {type: "star", open: "(?:", close: ")*"},
        "@": {type: "at", open: "(?:", close: ")"}
      };
    },
    globChars(win32) {
      return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
    }
  };
});

// ../../node_modules/.pnpm/picomatch@2.3.0/node_modules/picomatch/lib/utils.js
var require_utils7 = __commonJS2((exports2) => {
  "use strict";
  var path4 = require("path");
  var win32 = process.platform === "win32";
  var {
    REGEX_BACKSLASH,
    REGEX_REMOVE_BACKSLASH,
    REGEX_SPECIAL_CHARS,
    REGEX_SPECIAL_CHARS_GLOBAL
  } = require_constants6();
  exports2.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
  exports2.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
  exports2.isRegexChar = (str) => str.length === 1 && exports2.hasRegexChars(str);
  exports2.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
  exports2.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
  exports2.removeBackslashes = (str) => {
    return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
      return match === "\\" ? "" : match;
    });
  };
  exports2.supportsLookbehinds = () => {
    const segs = process.version.slice(1).split(".").map(Number);
    if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
      return true;
    }
    return false;
  };
  exports2.isWindows = (options) => {
    if (options && typeof options.windows === "boolean") {
      return options.windows;
    }
    return win32 === true || path4.sep === "\\";
  };
  exports2.escapeLast = (input, char, lastIdx) => {
    const idx = input.lastIndexOf(char, lastIdx);
    if (idx === -1)
      return input;
    if (input[idx - 1] === "\\")
      return exports2.escapeLast(input, char, idx - 1);
    return `${input.slice(0, idx)}\\${input.slice(idx)}`;
  };
  exports2.removePrefix = (input, state = {}) => {
    let output = input;
    if (output.startsWith("./")) {
      output = output.slice(2);
      state.prefix = "./";
    }
    return output;
  };
  exports2.wrapOutput = (input, state = {}, options = {}) => {
    const prepend = options.contains ? "" : "^";
    const append = options.contains ? "" : "$";
    let output = `${prepend}(?:${input})${append}`;
    if (state.negated === true) {
      output = `(?:^(?!${output}).*$)`;
    }
    return output;
  };
});

// ../../node_modules/.pnpm/picomatch@2.3.0/node_modules/picomatch/lib/scan.js
var require_scan3 = __commonJS2((exports2, module2) => {
  "use strict";
  var utils = require_utils7();
  var {
    CHAR_ASTERISK,
    CHAR_AT,
    CHAR_BACKWARD_SLASH,
    CHAR_COMMA,
    CHAR_DOT,
    CHAR_EXCLAMATION_MARK,
    CHAR_FORWARD_SLASH,
    CHAR_LEFT_CURLY_BRACE,
    CHAR_LEFT_PARENTHESES,
    CHAR_LEFT_SQUARE_BRACKET,
    CHAR_PLUS,
    CHAR_QUESTION_MARK,
    CHAR_RIGHT_CURLY_BRACE,
    CHAR_RIGHT_PARENTHESES,
    CHAR_RIGHT_SQUARE_BRACKET
  } = require_constants6();
  var isPathSeparator = (code) => {
    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
  };
  var depth = (token) => {
    if (token.isPrefix !== true) {
      token.depth = token.isGlobstar ? Infinity : 1;
    }
  };
  var scan = (input, options) => {
    const opts = options || {};
    const length = input.length - 1;
    const scanToEnd = opts.parts === true || opts.scanToEnd === true;
    const slashes = [];
    const tokens = [];
    const parts = [];
    let str = input;
    let index = -1;
    let start = 0;
    let lastIndex = 0;
    let isBrace = false;
    let isBracket = false;
    let isGlob = false;
    let isExtglob = false;
    let isGlobstar = false;
    let braceEscaped = false;
    let backslashes = false;
    let negated = false;
    let negatedExtglob = false;
    let finished = false;
    let braces = 0;
    let prev;
    let code;
    let token = {value: "", depth: 0, isGlob: false};
    const eos = () => index >= length;
    const peek = () => str.charCodeAt(index + 1);
    const advance = () => {
      prev = code;
      return str.charCodeAt(++index);
    };
    while (index < length) {
      code = advance();
      let next;
      if (code === CHAR_BACKWARD_SLASH) {
        backslashes = token.backslashes = true;
        code = advance();
        if (code === CHAR_LEFT_CURLY_BRACE) {
          braceEscaped = true;
        }
        continue;
      }
      if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
        braces++;
        while (eos() !== true && (code = advance())) {
          if (code === CHAR_BACKWARD_SLASH) {
            backslashes = token.backslashes = true;
            advance();
            continue;
          }
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braces++;
            continue;
          }
          if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
            isBrace = token.isBrace = true;
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (braceEscaped !== true && code === CHAR_COMMA) {
            isBrace = token.isBrace = true;
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (code === CHAR_RIGHT_CURLY_BRACE) {
            braces--;
            if (braces === 0) {
              braceEscaped = false;
              isBrace = token.isBrace = true;
              finished = true;
              break;
            }
          }
        }
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
      if (code === CHAR_FORWARD_SLASH) {
        slashes.push(index);
        tokens.push(token);
        token = {value: "", depth: 0, isGlob: false};
        if (finished === true)
          continue;
        if (prev === CHAR_DOT && index === start + 1) {
          start += 2;
          continue;
        }
        lastIndex = index + 1;
        continue;
      }
      if (opts.noext !== true) {
        const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
        if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          isExtglob = token.isExtglob = true;
          finished = true;
          if (code === CHAR_EXCLAMATION_MARK && index === start) {
            negatedExtglob = true;
          }
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_BACKWARD_SLASH) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                isGlob = token.isGlob = true;
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
      }
      if (code === CHAR_ASTERISK) {
        if (prev === CHAR_ASTERISK)
          isGlobstar = token.isGlobstar = true;
        isGlob = token.isGlob = true;
        finished = true;
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
      if (code === CHAR_QUESTION_MARK) {
        isGlob = token.isGlob = true;
        finished = true;
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
      if (code === CHAR_LEFT_SQUARE_BRACKET) {
        while (eos() !== true && (next = advance())) {
          if (next === CHAR_BACKWARD_SLASH) {
            backslashes = token.backslashes = true;
            advance();
            continue;
          }
          if (next === CHAR_RIGHT_SQUARE_BRACKET) {
            isBracket = token.isBracket = true;
            isGlob = token.isGlob = true;
            finished = true;
            break;
          }
        }
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
      if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
        negated = token.negated = true;
        start++;
        continue;
      }
      if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
        isGlob = token.isGlob = true;
        if (scanToEnd === true) {
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_LEFT_PARENTHESES) {
              backslashes = token.backslashes = true;
              code = advance();
              continue;
            }
            if (code === CHAR_RIGHT_PARENTHESES) {
              finished = true;
              break;
            }
          }
          continue;
        }
        break;
      }
      if (isGlob === true) {
        finished = true;
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
    }
    if (opts.noext === true) {
      isExtglob = false;
      isGlob = false;
    }
    let base = str;
    let prefix = "";
    let glob = "";
    if (start > 0) {
      prefix = str.slice(0, start);
      str = str.slice(start);
      lastIndex -= start;
    }
    if (base && isGlob === true && lastIndex > 0) {
      base = str.slice(0, lastIndex);
      glob = str.slice(lastIndex);
    } else if (isGlob === true) {
      base = "";
      glob = str;
    } else {
      base = str;
    }
    if (base && base !== "" && base !== "/" && base !== str) {
      if (isPathSeparator(base.charCodeAt(base.length - 1))) {
        base = base.slice(0, -1);
      }
    }
    if (opts.unescape === true) {
      if (glob)
        glob = utils.removeBackslashes(glob);
      if (base && backslashes === true) {
        base = utils.removeBackslashes(base);
      }
    }
    const state = {
      prefix,
      input,
      start,
      base,
      glob,
      isBrace,
      isBracket,
      isGlob,
      isExtglob,
      isGlobstar,
      negated,
      negatedExtglob
    };
    if (opts.tokens === true) {
      state.maxDepth = 0;
      if (!isPathSeparator(code)) {
        tokens.push(token);
      }
      state.tokens = tokens;
    }
    if (opts.parts === true || opts.tokens === true) {
      let prevIndex;
      for (let idx = 0; idx < slashes.length; idx++) {
        const n = prevIndex ? prevIndex + 1 : start;
        const i = slashes[idx];
        const value = input.slice(n, i);
        if (opts.tokens) {
          if (idx === 0 && start !== 0) {
            tokens[idx].isPrefix = true;
            tokens[idx].value = prefix;
          } else {
            tokens[idx].value = value;
          }
          depth(tokens[idx]);
          state.maxDepth += tokens[idx].depth;
        }
        if (idx !== 0 || value !== "") {
          parts.push(value);
        }
        prevIndex = i;
      }
      if (prevIndex && prevIndex + 1 < input.length) {
        const value = input.slice(prevIndex + 1);
        parts.push(value);
        if (opts.tokens) {
          tokens[tokens.length - 1].value = value;
          depth(tokens[tokens.length - 1]);
          state.maxDepth += tokens[tokens.length - 1].depth;
        }
      }
      state.slashes = slashes;
      state.parts = parts;
    }
    return state;
  };
  module2.exports = scan;
});

// ../../node_modules/.pnpm/picomatch@2.3.0/node_modules/picomatch/lib/parse.js
var require_parse8 = __commonJS2((exports2, module2) => {
  "use strict";
  var constants = require_constants6();
  var utils = require_utils7();
  var {
    MAX_LENGTH,
    POSIX_REGEX_SOURCE,
    REGEX_NON_SPECIAL_CHARS,
    REGEX_SPECIAL_CHARS_BACKREF,
    REPLACEMENTS
  } = constants;
  var expandRange = (args, options) => {
    if (typeof options.expandRange === "function") {
      return options.expandRange(...args, options);
    }
    args.sort();
    const value = `[${args.join("-")}]`;
    try {
      new RegExp(value);
    } catch (ex) {
      return args.map((v) => utils.escapeRegex(v)).join("..");
    }
    return value;
  };
  var syntaxError = (type, char) => {
    return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
  };
  var parse2 = (input, options) => {
    if (typeof input !== "string") {
      throw new TypeError("Expected a string");
    }
    input = REPLACEMENTS[input] || input;
    const opts = {...options};
    const max2 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    let len = input.length;
    if (len > max2) {
      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max2}`);
    }
    const bos = {type: "bos", value: "", output: opts.prepend || ""};
    const tokens = [bos];
    const capture = opts.capture ? "" : "?:";
    const win32 = utils.isWindows(options);
    const PLATFORM_CHARS = constants.globChars(win32);
    const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
    const {
      DOT_LITERAL,
      PLUS_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    } = PLATFORM_CHARS;
    const globstar = (opts2) => {
      return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };
    const nodot = opts.dot ? "" : NO_DOT;
    const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
    let star = opts.bash === true ? globstar(opts) : STAR;
    if (opts.capture) {
      star = `(${star})`;
    }
    if (typeof opts.noext === "boolean") {
      opts.noextglob = opts.noext;
    }
    const state = {
      input,
      index: -1,
      start: 0,
      dot: opts.dot === true,
      consumed: "",
      output: "",
      prefix: "",
      backtrack: false,
      negated: false,
      brackets: 0,
      braces: 0,
      parens: 0,
      quotes: 0,
      globstar: false,
      tokens
    };
    input = utils.removePrefix(input, state);
    len = input.length;
    const extglobs = [];
    const braces = [];
    const stack = [];
    let prev = bos;
    let value;
    const eos = () => state.index === len - 1;
    const peek = state.peek = (n = 1) => input[state.index + n];
    const advance = state.advance = () => input[++state.index] || "";
    const remaining = () => input.slice(state.index + 1);
    const consume = (value2 = "", num = 0) => {
      state.consumed += value2;
      state.index += num;
    };
    const append = (token) => {
      state.output += token.output != null ? token.output : token.value;
      consume(token.value);
    };
    const negate = () => {
      let count = 1;
      while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
        advance();
        state.start++;
        count++;
      }
      if (count % 2 === 0) {
        return false;
      }
      state.negated = true;
      state.start++;
      return true;
    };
    const increment = (type) => {
      state[type]++;
      stack.push(type);
    };
    const decrement = (type) => {
      state[type]--;
      stack.pop();
    };
    const push = (tok) => {
      if (prev.type === "globstar") {
        const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
        const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
        if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "star";
          prev.value = "*";
          prev.output = star;
          state.output += prev.output;
        }
      }
      if (extglobs.length && tok.type !== "paren") {
        extglobs[extglobs.length - 1].inner += tok.value;
      }
      if (tok.value || tok.output)
        append(tok);
      if (prev && prev.type === "text" && tok.type === "text") {
        prev.value += tok.value;
        prev.output = (prev.output || "") + tok.value;
        return;
      }
      tok.prev = prev;
      tokens.push(tok);
      prev = tok;
    };
    const extglobOpen = (type, value2) => {
      const token = {...EXTGLOB_CHARS[value2], conditions: 1, inner: ""};
      token.prev = prev;
      token.parens = state.parens;
      token.output = state.output;
      const output = (opts.capture ? "(" : "") + token.open;
      increment("parens");
      push({type, value: value2, output: state.output ? "" : ONE_CHAR});
      push({type: "paren", extglob: true, value: advance(), output});
      extglobs.push(token);
    };
    const extglobClose = (token) => {
      let output = token.close + (opts.capture ? ")" : "");
      let rest;
      if (token.type === "negate") {
        let extglobStar = star;
        if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
          extglobStar = globstar(opts);
        }
        if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
          output = token.close = `)$))${extglobStar}`;
        }
        if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
          output = token.close = `)${rest})${extglobStar})`;
        }
        if (token.prev.type === "bos") {
          state.negatedExtglob = true;
        }
      }
      push({type: "paren", extglob: true, value, output});
      decrement("parens");
    };
    if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
      let backslashes = false;
      let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m2, esc, chars, first, rest, index) => {
        if (first === "\\") {
          backslashes = true;
          return m2;
        }
        if (first === "?") {
          if (esc) {
            return esc + first + (rest ? QMARK.repeat(rest.length) : "");
          }
          if (index === 0) {
            return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
          }
          return QMARK.repeat(chars.length);
        }
        if (first === ".") {
          return DOT_LITERAL.repeat(chars.length);
        }
        if (first === "*") {
          if (esc) {
            return esc + first + (rest ? star : "");
          }
          return star;
        }
        return esc ? m2 : `\\${m2}`;
      });
      if (backslashes === true) {
        if (opts.unescape === true) {
          output = output.replace(/\\/g, "");
        } else {
          output = output.replace(/\\+/g, (m2) => {
            return m2.length % 2 === 0 ? "\\\\" : m2 ? "\\" : "";
          });
        }
      }
      if (output === input && opts.contains === true) {
        state.output = input;
        return state;
      }
      state.output = utils.wrapOutput(output, state, options);
      return state;
    }
    while (!eos()) {
      value = advance();
      if (value === "\0") {
        continue;
      }
      if (value === "\\") {
        const next = peek();
        if (next === "/" && opts.bash !== true) {
          continue;
        }
        if (next === "." || next === ";") {
          continue;
        }
        if (!next) {
          value += "\\";
          push({type: "text", value});
          continue;
        }
        const match = /^\\+/.exec(remaining());
        let slashes = 0;
        if (match && match[0].length > 2) {
          slashes = match[0].length;
          state.index += slashes;
          if (slashes % 2 !== 0) {
            value += "\\";
          }
        }
        if (opts.unescape === true) {
          value = advance();
        } else {
          value += advance();
        }
        if (state.brackets === 0) {
          push({type: "text", value});
          continue;
        }
      }
      if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
        if (opts.posix !== false && value === ":") {
          const inner = prev.value.slice(1);
          if (inner.includes("[")) {
            prev.posix = true;
            if (inner.includes(":")) {
              const idx = prev.value.lastIndexOf("[");
              const pre = prev.value.slice(0, idx);
              const rest2 = prev.value.slice(idx + 2);
              const posix = POSIX_REGEX_SOURCE[rest2];
              if (posix) {
                prev.value = pre + posix;
                state.backtrack = true;
                advance();
                if (!bos.output && tokens.indexOf(prev) === 1) {
                  bos.output = ONE_CHAR;
                }
                continue;
              }
            }
          }
        }
        if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
          value = `\\${value}`;
        }
        if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
          value = `\\${value}`;
        }
        if (opts.posix === true && value === "!" && prev.value === "[") {
          value = "^";
        }
        prev.value += value;
        append({value});
        continue;
      }
      if (state.quotes === 1 && value !== '"') {
        value = utils.escapeRegex(value);
        prev.value += value;
        append({value});
        continue;
      }
      if (value === '"') {
        state.quotes = state.quotes === 1 ? 0 : 1;
        if (opts.keepQuotes === true) {
          push({type: "text", value});
        }
        continue;
      }
      if (value === "(") {
        increment("parens");
        push({type: "paren", value});
        continue;
      }
      if (value === ")") {
        if (state.parens === 0 && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError("opening", "("));
        }
        const extglob = extglobs[extglobs.length - 1];
        if (extglob && state.parens === extglob.parens + 1) {
          extglobClose(extglobs.pop());
          continue;
        }
        push({type: "paren", value, output: state.parens ? ")" : "\\)"});
        decrement("parens");
        continue;
      }
      if (value === "[") {
        if (opts.nobracket === true || !remaining().includes("]")) {
          if (opts.nobracket !== true && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("closing", "]"));
          }
          value = `\\${value}`;
        } else {
          increment("brackets");
        }
        push({type: "bracket", value});
        continue;
      }
      if (value === "]") {
        if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
          push({type: "text", value, output: `\\${value}`});
          continue;
        }
        if (state.brackets === 0) {
          if (opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "["));
          }
          push({type: "text", value, output: `\\${value}`});
          continue;
        }
        decrement("brackets");
        const prevValue = prev.value.slice(1);
        if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
          value = `/${value}`;
        }
        prev.value += value;
        append({value});
        if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
          continue;
        }
        const escaped = utils.escapeRegex(prev.value);
        state.output = state.output.slice(0, -prev.value.length);
        if (opts.literalBrackets === true) {
          state.output += escaped;
          prev.value = escaped;
          continue;
        }
        prev.value = `(${capture}${escaped}|${prev.value})`;
        state.output += prev.value;
        continue;
      }
      if (value === "{" && opts.nobrace !== true) {
        increment("braces");
        const open2 = {
          type: "brace",
          value,
          output: "(",
          outputIndex: state.output.length,
          tokensIndex: state.tokens.length
        };
        braces.push(open2);
        push(open2);
        continue;
      }
      if (value === "}") {
        const brace = braces[braces.length - 1];
        if (opts.nobrace === true || !brace) {
          push({type: "text", value, output: value});
          continue;
        }
        let output = ")";
        if (brace.dots === true) {
          const arr = tokens.slice();
          const range = [];
          for (let i = arr.length - 1; i >= 0; i--) {
            tokens.pop();
            if (arr[i].type === "brace") {
              break;
            }
            if (arr[i].type !== "dots") {
              range.unshift(arr[i].value);
            }
          }
          output = expandRange(range, opts);
          state.backtrack = true;
        }
        if (brace.comma !== true && brace.dots !== true) {
          const out = state.output.slice(0, brace.outputIndex);
          const toks = state.tokens.slice(brace.tokensIndex);
          brace.value = brace.output = "\\{";
          value = output = "\\}";
          state.output = out;
          for (const t of toks) {
            state.output += t.output || t.value;
          }
        }
        push({type: "brace", value, output});
        decrement("braces");
        braces.pop();
        continue;
      }
      if (value === "|") {
        if (extglobs.length > 0) {
          extglobs[extglobs.length - 1].conditions++;
        }
        push({type: "text", value});
        continue;
      }
      if (value === ",") {
        let output = value;
        const brace = braces[braces.length - 1];
        if (brace && stack[stack.length - 1] === "braces") {
          brace.comma = true;
          output = "|";
        }
        push({type: "comma", value, output});
        continue;
      }
      if (value === "/") {
        if (prev.type === "dot" && state.index === state.start + 1) {
          state.start = state.index + 1;
          state.consumed = "";
          state.output = "";
          tokens.pop();
          prev = bos;
          continue;
        }
        push({type: "slash", value, output: SLASH_LITERAL});
        continue;
      }
      if (value === ".") {
        if (state.braces > 0 && prev.type === "dot") {
          if (prev.value === ".")
            prev.output = DOT_LITERAL;
          const brace = braces[braces.length - 1];
          prev.type = "dots";
          prev.output += value;
          prev.value += value;
          brace.dots = true;
          continue;
        }
        if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
          push({type: "text", value, output: DOT_LITERAL});
          continue;
        }
        push({type: "dot", value, output: DOT_LITERAL});
        continue;
      }
      if (value === "?") {
        const isGroup = prev && prev.value === "(";
        if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
          extglobOpen("qmark", value);
          continue;
        }
        if (prev && prev.type === "paren") {
          const next = peek();
          let output = value;
          if (next === "<" && !utils.supportsLookbehinds()) {
            throw new Error("Node.js v10 or higher is required for regex lookbehinds");
          }
          if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
            output = `\\${value}`;
          }
          push({type: "text", value, output});
          continue;
        }
        if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
          push({type: "qmark", value, output: QMARK_NO_DOT});
          continue;
        }
        push({type: "qmark", value, output: QMARK});
        continue;
      }
      if (value === "!") {
        if (opts.noextglob !== true && peek() === "(") {
          if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
            extglobOpen("negate", value);
            continue;
          }
        }
        if (opts.nonegate !== true && state.index === 0) {
          negate();
          continue;
        }
      }
      if (value === "+") {
        if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
          extglobOpen("plus", value);
          continue;
        }
        if (prev && prev.value === "(" || opts.regex === false) {
          push({type: "plus", value, output: PLUS_LITERAL});
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
          push({type: "plus", value});
          continue;
        }
        push({type: "plus", value: PLUS_LITERAL});
        continue;
      }
      if (value === "@") {
        if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
          push({type: "at", extglob: true, value, output: ""});
          continue;
        }
        push({type: "text", value});
        continue;
      }
      if (value !== "*") {
        if (value === "$" || value === "^") {
          value = `\\${value}`;
        }
        const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
        if (match) {
          value += match[0];
          state.index += match[0].length;
        }
        push({type: "text", value});
        continue;
      }
      if (prev && (prev.type === "globstar" || prev.star === true)) {
        prev.type = "star";
        prev.star = true;
        prev.value += value;
        prev.output = star;
        state.backtrack = true;
        state.globstar = true;
        consume(value);
        continue;
      }
      let rest = remaining();
      if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
        extglobOpen("star", value);
        continue;
      }
      if (prev.type === "star") {
        if (opts.noglobstar === true) {
          consume(value);
          continue;
        }
        const prior = prev.prev;
        const before = prior.prev;
        const isStart = prior.type === "slash" || prior.type === "bos";
        const afterStar = before && (before.type === "star" || before.type === "globstar");
        if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
          push({type: "star", value, output: ""});
          continue;
        }
        const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
        const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
        if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
          push({type: "star", value, output: ""});
          continue;
        }
        while (rest.slice(0, 3) === "/**") {
          const after = input[state.index + 4];
          if (after && after !== "/") {
            break;
          }
          rest = rest.slice(3);
          consume("/**", 3);
        }
        if (prior.type === "bos" && eos()) {
          prev.type = "globstar";
          prev.value += value;
          prev.output = globstar(opts);
          state.output = prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
          state.output = state.output.slice(0, -(prior.output + prev.output).length);
          prior.output = `(?:${prior.output}`;
          prev.type = "globstar";
          prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
          prev.value += value;
          state.globstar = true;
          state.output += prior.output + prev.output;
          consume(value);
          continue;
        }
        if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
          const end = rest[1] !== void 0 ? "|$" : "";
          state.output = state.output.slice(0, -(prior.output + prev.output).length);
          prior.output = `(?:${prior.output}`;
          prev.type = "globstar";
          prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
          prev.value += value;
          state.output += prior.output + prev.output;
          state.globstar = true;
          consume(value + advance());
          push({type: "slash", value: "/", output: ""});
          continue;
        }
        if (prior.type === "bos" && rest[0] === "/") {
          prev.type = "globstar";
          prev.value += value;
          prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
          state.output = prev.output;
          state.globstar = true;
          consume(value + advance());
          push({type: "slash", value: "/", output: ""});
          continue;
        }
        state.output = state.output.slice(0, -prev.output.length);
        prev.type = "globstar";
        prev.output = globstar(opts);
        prev.value += value;
        state.output += prev.output;
        state.globstar = true;
        consume(value);
        continue;
      }
      const token = {type: "star", value, output: star};
      if (opts.bash === true) {
        token.output = ".*?";
        if (prev.type === "bos" || prev.type === "slash") {
          token.output = nodot + token.output;
        }
        push(token);
        continue;
      }
      if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
        token.output = value;
        push(token);
        continue;
      }
      if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
        if (prev.type === "dot") {
          state.output += NO_DOT_SLASH;
          prev.output += NO_DOT_SLASH;
        } else if (opts.dot === true) {
          state.output += NO_DOTS_SLASH;
          prev.output += NO_DOTS_SLASH;
        } else {
          state.output += nodot;
          prev.output += nodot;
        }
        if (peek() !== "*") {
          state.output += ONE_CHAR;
          prev.output += ONE_CHAR;
        }
      }
      push(token);
    }
    while (state.brackets > 0) {
      if (opts.strictBrackets === true)
        throw new SyntaxError(syntaxError("closing", "]"));
      state.output = utils.escapeLast(state.output, "[");
      decrement("brackets");
    }
    while (state.parens > 0) {
      if (opts.strictBrackets === true)
        throw new SyntaxError(syntaxError("closing", ")"));
      state.output = utils.escapeLast(state.output, "(");
      decrement("parens");
    }
    while (state.braces > 0) {
      if (opts.strictBrackets === true)
        throw new SyntaxError(syntaxError("closing", "}"));
      state.output = utils.escapeLast(state.output, "{");
      decrement("braces");
    }
    if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
      push({type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?`});
    }
    if (state.backtrack === true) {
      state.output = "";
      for (const token of state.tokens) {
        state.output += token.output != null ? token.output : token.value;
        if (token.suffix) {
          state.output += token.suffix;
        }
      }
    }
    return state;
  };
  parse2.fastpaths = (input, options) => {
    const opts = {...options};
    const max2 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    const len = input.length;
    if (len > max2) {
      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max2}`);
    }
    input = REPLACEMENTS[input] || input;
    const win32 = utils.isWindows(options);
    const {
      DOT_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOTS_SLASH,
      STAR,
      START_ANCHOR
    } = constants.globChars(win32);
    const nodot = opts.dot ? NO_DOTS : NO_DOT;
    const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
    const capture = opts.capture ? "" : "?:";
    const state = {negated: false, prefix: ""};
    let star = opts.bash === true ? ".*?" : STAR;
    if (opts.capture) {
      star = `(${star})`;
    }
    const globstar = (opts2) => {
      if (opts2.noglobstar === true)
        return star;
      return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };
    const create = (str) => {
      switch (str) {
        case "*":
          return `${nodot}${ONE_CHAR}${star}`;
        case ".*":
          return `${DOT_LITERAL}${ONE_CHAR}${star}`;
        case "*.*":
          return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
        case "*/*":
          return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
        case "**":
          return nodot + globstar(opts);
        case "**/*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
        case "**/*.*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
        case "**/.*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
        default: {
          const match = /^(.*?)\.(\w+)$/.exec(str);
          if (!match)
            return;
          const source2 = create(match[1]);
          if (!source2)
            return;
          return source2 + DOT_LITERAL + match[2];
        }
      }
    };
    const output = utils.removePrefix(input, state);
    let source = create(output);
    if (source && opts.strictSlashes !== true) {
      source += `${SLASH_LITERAL}?`;
    }
    return source;
  };
  module2.exports = parse2;
});

// ../../node_modules/.pnpm/picomatch@2.3.0/node_modules/picomatch/lib/picomatch.js
var require_picomatch3 = __commonJS2((exports2, module2) => {
  "use strict";
  var path4 = require("path");
  var scan = require_scan3();
  var parse2 = require_parse8();
  var utils = require_utils7();
  var constants = require_constants6();
  var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
  var picomatch = (glob, options, returnState = false) => {
    if (Array.isArray(glob)) {
      const fns = glob.map((input) => picomatch(input, options, returnState));
      const arrayMatcher = (str) => {
        for (const isMatch of fns) {
          const state2 = isMatch(str);
          if (state2)
            return state2;
        }
        return false;
      };
      return arrayMatcher;
    }
    const isState = isObject(glob) && glob.tokens && glob.input;
    if (glob === "" || typeof glob !== "string" && !isState) {
      throw new TypeError("Expected pattern to be a non-empty string");
    }
    const opts = options || {};
    const posix = utils.isWindows(options);
    const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
    const state = regex.state;
    delete regex.state;
    let isIgnored = () => false;
    if (opts.ignore) {
      const ignoreOpts = {...options, ignore: null, onMatch: null, onResult: null};
      isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
    }
    const matcher = (input, returnObject = false) => {
      const {isMatch, match, output} = picomatch.test(input, regex, options, {glob, posix});
      const result = {glob, state, regex, posix, input, output, match, isMatch};
      if (typeof opts.onResult === "function") {
        opts.onResult(result);
      }
      if (isMatch === false) {
        result.isMatch = false;
        return returnObject ? result : false;
      }
      if (isIgnored(input)) {
        if (typeof opts.onIgnore === "function") {
          opts.onIgnore(result);
        }
        result.isMatch = false;
        return returnObject ? result : false;
      }
      if (typeof opts.onMatch === "function") {
        opts.onMatch(result);
      }
      return returnObject ? result : true;
    };
    if (returnState) {
      matcher.state = state;
    }
    return matcher;
  };
  picomatch.test = (input, regex, options, {glob, posix} = {}) => {
    if (typeof input !== "string") {
      throw new TypeError("Expected input to be a string");
    }
    if (input === "") {
      return {isMatch: false, output: ""};
    }
    const opts = options || {};
    const format2 = opts.format || (posix ? utils.toPosixSlashes : null);
    let match = input === glob;
    let output = match && format2 ? format2(input) : input;
    if (match === false) {
      output = format2 ? format2(input) : input;
      match = output === glob;
    }
    if (match === false || opts.capture === true) {
      if (opts.matchBase === true || opts.basename === true) {
        match = picomatch.matchBase(input, regex, options, posix);
      } else {
        match = regex.exec(output);
      }
    }
    return {isMatch: Boolean(match), match, output};
  };
  picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
    const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
    return regex.test(path4.basename(input));
  };
  picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
  picomatch.parse = (pattern, options) => {
    if (Array.isArray(pattern))
      return pattern.map((p) => picomatch.parse(p, options));
    return parse2(pattern, {...options, fastpaths: false});
  };
  picomatch.scan = (input, options) => scan(input, options);
  picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
    if (returnOutput === true) {
      return state.output;
    }
    const opts = options || {};
    const prepend = opts.contains ? "" : "^";
    const append = opts.contains ? "" : "$";
    let source = `${prepend}(?:${state.output})${append}`;
    if (state && state.negated === true) {
      source = `^(?!${source}).*$`;
    }
    const regex = picomatch.toRegex(source, options);
    if (returnState === true) {
      regex.state = state;
    }
    return regex;
  };
  picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
    if (!input || typeof input !== "string") {
      throw new TypeError("Expected a non-empty string");
    }
    let parsed = {negated: false, fastpaths: true};
    if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
      parsed.output = parse2.fastpaths(input, options);
    }
    if (!parsed.output) {
      parsed = parse2(input, options);
    }
    return picomatch.compileRe(parsed, options, returnOutput, returnState);
  };
  picomatch.toRegex = (source, options) => {
    try {
      const opts = options || {};
      return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
    } catch (err) {
      if (options && options.debug === true)
        throw err;
      return /$^/;
    }
  };
  picomatch.constants = constants;
  module2.exports = picomatch;
});

// ../../node_modules/.pnpm/picomatch@2.3.0/node_modules/picomatch/index.js
var require_picomatch4 = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = require_picomatch3();
});

// ../../node_modules/.pnpm/micromatch@4.0.4/node_modules/micromatch/index.js
var require_micromatch2 = __commonJS2((exports2, module2) => {
  "use strict";
  var util2 = require("util");
  var braces = require_braces2();
  var picomatch = require_picomatch4();
  var utils = require_utils7();
  var isEmptyString = (val) => val === "" || val === "./";
  var micromatch = (list, patterns, options) => {
    patterns = [].concat(patterns);
    list = [].concat(list);
    let omit = new Set();
    let keep = new Set();
    let items = new Set();
    let negatives = 0;
    let onResult = (state) => {
      items.add(state.output);
      if (options && options.onResult) {
        options.onResult(state);
      }
    };
    for (let i = 0; i < patterns.length; i++) {
      let isMatch = picomatch(String(patterns[i]), {...options, onResult}, true);
      let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
      if (negated)
        negatives++;
      for (let item of list) {
        let matched = isMatch(item, true);
        let match = negated ? !matched.isMatch : matched.isMatch;
        if (!match)
          continue;
        if (negated) {
          omit.add(matched.output);
        } else {
          omit.delete(matched.output);
          keep.add(matched.output);
        }
      }
    }
    let result = negatives === patterns.length ? [...items] : [...keep];
    let matches = result.filter((item) => !omit.has(item));
    if (options && matches.length === 0) {
      if (options.failglob === true) {
        throw new Error(`No matches found for "${patterns.join(", ")}"`);
      }
      if (options.nonull === true || options.nullglob === true) {
        return options.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
      }
    }
    return matches;
  };
  micromatch.match = micromatch;
  micromatch.matcher = (pattern, options) => picomatch(pattern, options);
  micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
  micromatch.any = micromatch.isMatch;
  micromatch.not = (list, patterns, options = {}) => {
    patterns = [].concat(patterns).map(String);
    let result = new Set();
    let items = [];
    let onResult = (state) => {
      if (options.onResult)
        options.onResult(state);
      items.push(state.output);
    };
    let matches = micromatch(list, patterns, {...options, onResult});
    for (let item of items) {
      if (!matches.includes(item)) {
        result.add(item);
      }
    }
    return [...result];
  };
  micromatch.contains = (str, pattern, options) => {
    if (typeof str !== "string") {
      throw new TypeError(`Expected a string: "${util2.inspect(str)}"`);
    }
    if (Array.isArray(pattern)) {
      return pattern.some((p) => micromatch.contains(str, p, options));
    }
    if (typeof pattern === "string") {
      if (isEmptyString(str) || isEmptyString(pattern)) {
        return false;
      }
      if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern)) {
        return true;
      }
    }
    return micromatch.isMatch(str, pattern, {...options, contains: true});
  };
  micromatch.matchKeys = (obj, patterns, options) => {
    if (!utils.isObject(obj)) {
      throw new TypeError("Expected the first argument to be an object");
    }
    let keys = micromatch(Object.keys(obj), patterns, options);
    let res = {};
    for (let key of keys)
      res[key] = obj[key];
    return res;
  };
  micromatch.some = (list, patterns, options) => {
    let items = [].concat(list);
    for (let pattern of [].concat(patterns)) {
      let isMatch = picomatch(String(pattern), options);
      if (items.some((item) => isMatch(item))) {
        return true;
      }
    }
    return false;
  };
  micromatch.every = (list, patterns, options) => {
    let items = [].concat(list);
    for (let pattern of [].concat(patterns)) {
      let isMatch = picomatch(String(pattern), options);
      if (!items.every((item) => isMatch(item))) {
        return false;
      }
    }
    return true;
  };
  micromatch.all = (str, patterns, options) => {
    if (typeof str !== "string") {
      throw new TypeError(`Expected a string: "${util2.inspect(str)}"`);
    }
    return [].concat(patterns).every((p) => picomatch(p, options)(str));
  };
  micromatch.capture = (glob, input, options) => {
    let posix = utils.isWindows(options);
    let regex = picomatch.makeRe(String(glob), {...options, capture: true});
    let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);
    if (match) {
      return match.slice(1).map((v) => v === void 0 ? "" : v);
    }
  };
  micromatch.makeRe = (...args) => picomatch.makeRe(...args);
  micromatch.scan = (...args) => picomatch.scan(...args);
  micromatch.parse = (patterns, options) => {
    let res = [];
    for (let pattern of [].concat(patterns || [])) {
      for (let str of braces(String(pattern), options)) {
        res.push(picomatch.parse(str, options));
      }
    }
    return res;
  };
  micromatch.braces = (pattern, options) => {
    if (typeof pattern !== "string")
      throw new TypeError("Expected a string");
    if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
      return [pattern];
    }
    return braces(pattern, options);
  };
  micromatch.braceExpand = (pattern, options) => {
    if (typeof pattern !== "string")
      throw new TypeError("Expected a string");
    return micromatch.braces(pattern, {...options, expand: true});
  };
  module2.exports = micromatch;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/utils/pattern.js
var require_pattern2 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.matchAny = exports2.convertPatternsToRe = exports2.makeRe = exports2.getPatternParts = exports2.expandBraceExpansion = exports2.expandPatternsWithBraceExpansion = exports2.isAffectDepthOfReadingPattern = exports2.endsWithSlashGlobStar = exports2.hasGlobStar = exports2.getBaseDirectory = exports2.getPositivePatterns = exports2.getNegativePatterns = exports2.isPositivePattern = exports2.isNegativePattern = exports2.convertToNegativePattern = exports2.convertToPositivePattern = exports2.isDynamicPattern = exports2.isStaticPattern = void 0;
  var path4 = require("path");
  var globParent = require_glob_parent2();
  var micromatch = require_micromatch2();
  var picomatch = require_picomatch4();
  var GLOBSTAR = "**";
  var ESCAPE_SYMBOL = "\\";
  var COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
  var REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[.*]/;
  var REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\(.*\|.*\)/;
  var GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\(.*\)/;
  var BRACE_EXPANSIONS_SYMBOLS_RE = /{.*(?:,|\.\.).*}/;
  function isStaticPattern(pattern, options = {}) {
    return !isDynamicPattern(pattern, options);
  }
  exports2.isStaticPattern = isStaticPattern;
  function isDynamicPattern(pattern, options = {}) {
    if (pattern === "") {
      return false;
    }
    if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
      return true;
    }
    if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
      return true;
    }
    if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
      return true;
    }
    if (options.braceExpansion !== false && BRACE_EXPANSIONS_SYMBOLS_RE.test(pattern)) {
      return true;
    }
    return false;
  }
  exports2.isDynamicPattern = isDynamicPattern;
  function convertToPositivePattern(pattern) {
    return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
  }
  exports2.convertToPositivePattern = convertToPositivePattern;
  function convertToNegativePattern(pattern) {
    return "!" + pattern;
  }
  exports2.convertToNegativePattern = convertToNegativePattern;
  function isNegativePattern(pattern) {
    return pattern.startsWith("!") && pattern[1] !== "(";
  }
  exports2.isNegativePattern = isNegativePattern;
  function isPositivePattern(pattern) {
    return !isNegativePattern(pattern);
  }
  exports2.isPositivePattern = isPositivePattern;
  function getNegativePatterns(patterns) {
    return patterns.filter(isNegativePattern);
  }
  exports2.getNegativePatterns = getNegativePatterns;
  function getPositivePatterns(patterns) {
    return patterns.filter(isPositivePattern);
  }
  exports2.getPositivePatterns = getPositivePatterns;
  function getBaseDirectory(pattern) {
    return globParent(pattern, {flipBackslashes: false});
  }
  exports2.getBaseDirectory = getBaseDirectory;
  function hasGlobStar(pattern) {
    return pattern.includes(GLOBSTAR);
  }
  exports2.hasGlobStar = hasGlobStar;
  function endsWithSlashGlobStar(pattern) {
    return pattern.endsWith("/" + GLOBSTAR);
  }
  exports2.endsWithSlashGlobStar = endsWithSlashGlobStar;
  function isAffectDepthOfReadingPattern(pattern) {
    const basename = path4.basename(pattern);
    return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
  }
  exports2.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
  function expandPatternsWithBraceExpansion(patterns) {
    return patterns.reduce((collection, pattern) => {
      return collection.concat(expandBraceExpansion(pattern));
    }, []);
  }
  exports2.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
  function expandBraceExpansion(pattern) {
    return micromatch.braces(pattern, {
      expand: true,
      nodupes: true
    });
  }
  exports2.expandBraceExpansion = expandBraceExpansion;
  function getPatternParts(pattern, options) {
    let {parts} = picomatch.scan(pattern, Object.assign(Object.assign({}, options), {parts: true}));
    if (parts.length === 0) {
      parts = [pattern];
    }
    if (parts[0].startsWith("/")) {
      parts[0] = parts[0].slice(1);
      parts.unshift("");
    }
    return parts;
  }
  exports2.getPatternParts = getPatternParts;
  function makeRe(pattern, options) {
    return micromatch.makeRe(pattern, options);
  }
  exports2.makeRe = makeRe;
  function convertPatternsToRe(patterns, options) {
    return patterns.map((pattern) => makeRe(pattern, options));
  }
  exports2.convertPatternsToRe = convertPatternsToRe;
  function matchAny(entry, patternsRe) {
    return patternsRe.some((patternRe) => patternRe.test(entry));
  }
  exports2.matchAny = matchAny;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/utils/stream.js
var require_stream7 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.merge = void 0;
  var merge2 = require_merge22();
  function merge(streams) {
    const mergedStream = merge2(streams);
    streams.forEach((stream) => {
      stream.once("error", (error) => mergedStream.emit("error", error));
    });
    mergedStream.once("close", () => propagateCloseEventToSources(streams));
    mergedStream.once("end", () => propagateCloseEventToSources(streams));
    return mergedStream;
  }
  exports2.merge = merge;
  function propagateCloseEventToSources(streams) {
    streams.forEach((stream) => stream.emit("close"));
  }
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/utils/string.js
var require_string2 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.isEmpty = exports2.isString = void 0;
  function isString(input) {
    return typeof input === "string";
  }
  exports2.isString = isString;
  function isEmpty(input) {
    return input === "";
  }
  exports2.isEmpty = isEmpty;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/utils/index.js
var require_utils8 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.string = exports2.stream = exports2.pattern = exports2.path = exports2.fs = exports2.errno = exports2.array = void 0;
  var array = require_array2();
  exports2.array = array;
  var errno = require_errno2();
  exports2.errno = errno;
  var fs2 = require_fs7();
  exports2.fs = fs2;
  var path4 = require_path2();
  exports2.path = path4;
  var pattern = require_pattern2();
  exports2.pattern = pattern;
  var stream = require_stream7();
  exports2.stream = stream;
  var string = require_string2();
  exports2.string = string;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/managers/tasks.js
var require_tasks2 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.convertPatternGroupToTask = exports2.convertPatternGroupsToTasks = exports2.groupPatternsByBaseDirectory = exports2.getNegativePatternsAsPositive = exports2.getPositivePatterns = exports2.convertPatternsToTasks = exports2.generate = void 0;
  var utils = require_utils8();
  function generate(patterns, settings) {
    const positivePatterns = getPositivePatterns(patterns);
    const negativePatterns = getNegativePatternsAsPositive(patterns, settings.ignore);
    const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));
    const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));
    const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, false);
    const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, true);
    return staticTasks.concat(dynamicTasks);
  }
  exports2.generate = generate;
  function convertPatternsToTasks(positive, negative, dynamic) {
    const positivePatternsGroup = groupPatternsByBaseDirectory(positive);
    if ("." in positivePatternsGroup) {
      const task = convertPatternGroupToTask(".", positive, negative, dynamic);
      return [task];
    }
    return convertPatternGroupsToTasks(positivePatternsGroup, negative, dynamic);
  }
  exports2.convertPatternsToTasks = convertPatternsToTasks;
  function getPositivePatterns(patterns) {
    return utils.pattern.getPositivePatterns(patterns);
  }
  exports2.getPositivePatterns = getPositivePatterns;
  function getNegativePatternsAsPositive(patterns, ignore) {
    const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);
    const positive = negative.map(utils.pattern.convertToPositivePattern);
    return positive;
  }
  exports2.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
  function groupPatternsByBaseDirectory(patterns) {
    const group = {};
    return patterns.reduce((collection, pattern) => {
      const base = utils.pattern.getBaseDirectory(pattern);
      if (base in collection) {
        collection[base].push(pattern);
      } else {
        collection[base] = [pattern];
      }
      return collection;
    }, group);
  }
  exports2.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
  function convertPatternGroupsToTasks(positive, negative, dynamic) {
    return Object.keys(positive).map((base) => {
      return convertPatternGroupToTask(base, positive[base], negative, dynamic);
    });
  }
  exports2.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
  function convertPatternGroupToTask(base, positive, negative, dynamic) {
    return {
      dynamic,
      positive,
      negative,
      base,
      patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))
    };
  }
  exports2.convertPatternGroupToTask = convertPatternGroupToTask;
});

// ../../node_modules/.pnpm/@nodelib+fs.stat@2.0.4/node_modules/@nodelib/fs.stat/out/providers/async.js
var require_async7 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.read = void 0;
  function read(path4, settings, callback) {
    settings.fs.lstat(path4, (lstatError, lstat) => {
      if (lstatError !== null) {
        return callFailureCallback(callback, lstatError);
      }
      if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
        return callSuccessCallback(callback, lstat);
      }
      settings.fs.stat(path4, (statError, stat2) => {
        if (statError !== null) {
          if (settings.throwErrorOnBrokenSymbolicLink) {
            return callFailureCallback(callback, statError);
          }
          return callSuccessCallback(callback, lstat);
        }
        if (settings.markSymbolicLink) {
          stat2.isSymbolicLink = () => true;
        }
        callSuccessCallback(callback, stat2);
      });
    });
  }
  exports2.read = read;
  function callFailureCallback(callback, error) {
    callback(error);
  }
  function callSuccessCallback(callback, result) {
    callback(null, result);
  }
});

// ../../node_modules/.pnpm/@nodelib+fs.stat@2.0.4/node_modules/@nodelib/fs.stat/out/providers/sync.js
var require_sync10 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.read = void 0;
  function read(path4, settings) {
    const lstat = settings.fs.lstatSync(path4);
    if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
      return lstat;
    }
    try {
      const stat2 = settings.fs.statSync(path4);
      if (settings.markSymbolicLink) {
        stat2.isSymbolicLink = () => true;
      }
      return stat2;
    } catch (error) {
      if (!settings.throwErrorOnBrokenSymbolicLink) {
        return lstat;
      }
      throw error;
    }
  }
  exports2.read = read;
});

// ../../node_modules/.pnpm/@nodelib+fs.stat@2.0.4/node_modules/@nodelib/fs.stat/out/adapters/fs.js
var require_fs8 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
  var fs2 = require("fs");
  exports2.FILE_SYSTEM_ADAPTER = {
    lstat: fs2.lstat,
    stat: fs2.stat,
    lstatSync: fs2.lstatSync,
    statSync: fs2.statSync
  };
  function createFileSystemAdapter(fsMethods) {
    if (fsMethods === void 0) {
      return exports2.FILE_SYSTEM_ADAPTER;
    }
    return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
  }
  exports2.createFileSystemAdapter = createFileSystemAdapter;
});

// ../../node_modules/.pnpm/@nodelib+fs.stat@2.0.4/node_modules/@nodelib/fs.stat/out/settings.js
var require_settings5 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var fs2 = require_fs8();
  var Settings = class {
    constructor(_options = {}) {
      this._options = _options;
      this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
      this.fs = fs2.createFileSystemAdapter(this._options.fs);
      this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
      this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
    }
    _getValue(option, value) {
      return option !== null && option !== void 0 ? option : value;
    }
  };
  exports2.default = Settings;
});

// ../../node_modules/.pnpm/@nodelib+fs.stat@2.0.4/node_modules/@nodelib/fs.stat/out/index.js
var require_out5 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.statSync = exports2.stat = exports2.Settings = void 0;
  var async = require_async7();
  var sync2 = require_sync10();
  var settings_1 = require_settings5();
  exports2.Settings = settings_1.default;
  function stat2(path4, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === "function") {
      return async.read(path4, getSettings(), optionsOrSettingsOrCallback);
    }
    async.read(path4, getSettings(optionsOrSettingsOrCallback), callback);
  }
  exports2.stat = stat2;
  function statSync(path4, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    return sync2.read(path4, settings);
  }
  exports2.statSync = statSync;
  function getSettings(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1.default) {
      return settingsOrOptions;
    }
    return new settings_1.default(settingsOrOptions);
  }
});

// ../../node_modules/.pnpm/queue-microtask@1.2.2/node_modules/queue-microtask/index.js
var require_queue_microtask2 = __commonJS2((exports2, module2) => {
  /*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var promise;
  module2.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(globalThis) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
    throw err;
  }, 0));
});

// ../../node_modules/.pnpm/run-parallel@1.2.0/node_modules/run-parallel/index.js
var require_run_parallel2 = __commonJS2((exports2, module2) => {
  /*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  module2.exports = runParallel;
  var queueMicrotask2 = require_queue_microtask2();
  function runParallel(tasks, cb) {
    let results, pending, keys;
    let isSync = true;
    if (Array.isArray(tasks)) {
      results = [];
      pending = tasks.length;
    } else {
      keys = Object.keys(tasks);
      results = {};
      pending = keys.length;
    }
    function done(err) {
      function end() {
        if (cb)
          cb(err, results);
        cb = null;
      }
      if (isSync)
        queueMicrotask2(end);
      else
        end();
    }
    function each(i, err, result) {
      results[i] = result;
      if (--pending === 0 || err) {
        done(err);
      }
    }
    if (!pending) {
      done(null);
    } else if (keys) {
      keys.forEach(function(key) {
        tasks[key](function(err, result) {
          each(key, err, result);
        });
      });
    } else {
      tasks.forEach(function(task, i) {
        task(function(err, result) {
          each(i, err, result);
        });
      });
    }
    isSync = false;
  }
});

// ../../node_modules/.pnpm/@nodelib+fs.scandir@2.1.4/node_modules/@nodelib/fs.scandir/out/constants.js
var require_constants7 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
  var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
  var MAJOR_VERSION = parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
  var MINOR_VERSION = parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
  var SUPPORTED_MAJOR_VERSION = 10;
  var SUPPORTED_MINOR_VERSION = 10;
  var IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
  var IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
  exports2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
});

// ../../node_modules/.pnpm/@nodelib+fs.scandir@2.1.4/node_modules/@nodelib/fs.scandir/out/utils/fs.js
var require_fs9 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.createDirentFromStats = void 0;
  var DirentFromStats = class {
    constructor(name, stats) {
      this.name = name;
      this.isBlockDevice = stats.isBlockDevice.bind(stats);
      this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
      this.isDirectory = stats.isDirectory.bind(stats);
      this.isFIFO = stats.isFIFO.bind(stats);
      this.isFile = stats.isFile.bind(stats);
      this.isSocket = stats.isSocket.bind(stats);
      this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
    }
  };
  function createDirentFromStats(name, stats) {
    return new DirentFromStats(name, stats);
  }
  exports2.createDirentFromStats = createDirentFromStats;
});

// ../../node_modules/.pnpm/@nodelib+fs.scandir@2.1.4/node_modules/@nodelib/fs.scandir/out/utils/index.js
var require_utils9 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.fs = void 0;
  var fs2 = require_fs9();
  exports2.fs = fs2;
});

// ../../node_modules/.pnpm/@nodelib+fs.scandir@2.1.4/node_modules/@nodelib/fs.scandir/out/providers/common.js
var require_common10 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.joinPathSegments = void 0;
  function joinPathSegments(a, b, separator) {
    if (a.endsWith(separator)) {
      return a + b;
    }
    return a + separator + b;
  }
  exports2.joinPathSegments = joinPathSegments;
});

// ../../node_modules/.pnpm/@nodelib+fs.scandir@2.1.4/node_modules/@nodelib/fs.scandir/out/providers/async.js
var require_async8 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.readdir = exports2.readdirWithFileTypes = exports2.read = void 0;
  var fsStat = require_out5();
  var rpl = require_run_parallel2();
  var constants_1 = require_constants7();
  var utils = require_utils9();
  var common = require_common10();
  function read(directory, settings, callback) {
    if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
      return readdirWithFileTypes(directory, settings, callback);
    }
    return readdir2(directory, settings, callback);
  }
  exports2.read = read;
  function readdirWithFileTypes(directory, settings, callback) {
    settings.fs.readdir(directory, {withFileTypes: true}, (readdirError, dirents) => {
      if (readdirError !== null) {
        return callFailureCallback(callback, readdirError);
      }
      const entries = dirents.map((dirent) => ({
        dirent,
        name: dirent.name,
        path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
      }));
      if (!settings.followSymbolicLinks) {
        return callSuccessCallback(callback, entries);
      }
      const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));
      rpl(tasks, (rplError, rplEntries) => {
        if (rplError !== null) {
          return callFailureCallback(callback, rplError);
        }
        callSuccessCallback(callback, rplEntries);
      });
    });
  }
  exports2.readdirWithFileTypes = readdirWithFileTypes;
  function makeRplTaskEntry(entry, settings) {
    return (done) => {
      if (!entry.dirent.isSymbolicLink()) {
        return done(null, entry);
      }
      settings.fs.stat(entry.path, (statError, stats) => {
        if (statError !== null) {
          if (settings.throwErrorOnBrokenSymbolicLink) {
            return done(statError);
          }
          return done(null, entry);
        }
        entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
        return done(null, entry);
      });
    };
  }
  function readdir2(directory, settings, callback) {
    settings.fs.readdir(directory, (readdirError, names) => {
      if (readdirError !== null) {
        return callFailureCallback(callback, readdirError);
      }
      const filepaths = names.map((name) => common.joinPathSegments(directory, name, settings.pathSegmentSeparator));
      const tasks = filepaths.map((filepath) => {
        return (done) => fsStat.stat(filepath, settings.fsStatSettings, done);
      });
      rpl(tasks, (rplError, results) => {
        if (rplError !== null) {
          return callFailureCallback(callback, rplError);
        }
        const entries = [];
        names.forEach((name, index) => {
          const stats = results[index];
          const entry = {
            name,
            path: filepaths[index],
            dirent: utils.fs.createDirentFromStats(name, stats)
          };
          if (settings.stats) {
            entry.stats = stats;
          }
          entries.push(entry);
        });
        callSuccessCallback(callback, entries);
      });
    });
  }
  exports2.readdir = readdir2;
  function callFailureCallback(callback, error) {
    callback(error);
  }
  function callSuccessCallback(callback, result) {
    callback(null, result);
  }
});

// ../../node_modules/.pnpm/@nodelib+fs.scandir@2.1.4/node_modules/@nodelib/fs.scandir/out/providers/sync.js
var require_sync11 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.readdir = exports2.readdirWithFileTypes = exports2.read = void 0;
  var fsStat = require_out5();
  var constants_1 = require_constants7();
  var utils = require_utils9();
  var common = require_common10();
  function read(directory, settings) {
    if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
      return readdirWithFileTypes(directory, settings);
    }
    return readdir2(directory, settings);
  }
  exports2.read = read;
  function readdirWithFileTypes(directory, settings) {
    const dirents = settings.fs.readdirSync(directory, {withFileTypes: true});
    return dirents.map((dirent) => {
      const entry = {
        dirent,
        name: dirent.name,
        path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
      };
      if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
        try {
          const stats = settings.fs.statSync(entry.path);
          entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
        } catch (error) {
          if (settings.throwErrorOnBrokenSymbolicLink) {
            throw error;
          }
        }
      }
      return entry;
    });
  }
  exports2.readdirWithFileTypes = readdirWithFileTypes;
  function readdir2(directory, settings) {
    const names = settings.fs.readdirSync(directory);
    return names.map((name) => {
      const entryPath = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
      const stats = fsStat.statSync(entryPath, settings.fsStatSettings);
      const entry = {
        name,
        path: entryPath,
        dirent: utils.fs.createDirentFromStats(name, stats)
      };
      if (settings.stats) {
        entry.stats = stats;
      }
      return entry;
    });
  }
  exports2.readdir = readdir2;
});

// ../../node_modules/.pnpm/@nodelib+fs.scandir@2.1.4/node_modules/@nodelib/fs.scandir/out/adapters/fs.js
var require_fs10 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
  var fs2 = require("fs");
  exports2.FILE_SYSTEM_ADAPTER = {
    lstat: fs2.lstat,
    stat: fs2.stat,
    lstatSync: fs2.lstatSync,
    statSync: fs2.statSync,
    readdir: fs2.readdir,
    readdirSync: fs2.readdirSync
  };
  function createFileSystemAdapter(fsMethods) {
    if (fsMethods === void 0) {
      return exports2.FILE_SYSTEM_ADAPTER;
    }
    return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
  }
  exports2.createFileSystemAdapter = createFileSystemAdapter;
});

// ../../node_modules/.pnpm/@nodelib+fs.scandir@2.1.4/node_modules/@nodelib/fs.scandir/out/settings.js
var require_settings6 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var path4 = require("path");
  var fsStat = require_out5();
  var fs2 = require_fs10();
  var Settings = class {
    constructor(_options = {}) {
      this._options = _options;
      this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
      this.fs = fs2.createFileSystemAdapter(this._options.fs);
      this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path4.sep);
      this.stats = this._getValue(this._options.stats, false);
      this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
      this.fsStatSettings = new fsStat.Settings({
        followSymbolicLink: this.followSymbolicLinks,
        fs: this.fs,
        throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
      });
    }
    _getValue(option, value) {
      return option !== null && option !== void 0 ? option : value;
    }
  };
  exports2.default = Settings;
});

// ../../node_modules/.pnpm/@nodelib+fs.scandir@2.1.4/node_modules/@nodelib/fs.scandir/out/index.js
var require_out6 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Settings = exports2.scandirSync = exports2.scandir = void 0;
  var async = require_async8();
  var sync2 = require_sync11();
  var settings_1 = require_settings6();
  exports2.Settings = settings_1.default;
  function scandir(path4, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === "function") {
      return async.read(path4, getSettings(), optionsOrSettingsOrCallback);
    }
    async.read(path4, getSettings(optionsOrSettingsOrCallback), callback);
  }
  exports2.scandir = scandir;
  function scandirSync(path4, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    return sync2.read(path4, settings);
  }
  exports2.scandirSync = scandirSync;
  function getSettings(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1.default) {
      return settingsOrOptions;
    }
    return new settings_1.default(settingsOrOptions);
  }
});

// ../../node_modules/.pnpm/reusify@1.0.4/node_modules/reusify/reusify.js
var require_reusify2 = __commonJS2((exports2, module2) => {
  "use strict";
  function reusify(Constructor) {
    var head = new Constructor();
    var tail = head;
    function get() {
      var current = head;
      if (current.next) {
        head = current.next;
      } else {
        head = new Constructor();
        tail = head;
      }
      current.next = null;
      return current;
    }
    function release(obj) {
      tail.next = obj;
      tail = obj;
    }
    return {
      get,
      release
    };
  }
  module2.exports = reusify;
});

// ../../node_modules/.pnpm/fastq@1.11.0/node_modules/fastq/queue.js
var require_queue2 = __commonJS2((exports2, module2) => {
  "use strict";
  var reusify = require_reusify2();
  function fastqueue(context, worker, concurrency) {
    if (typeof context === "function") {
      concurrency = worker;
      worker = context;
      context = null;
    }
    if (concurrency < 1) {
      throw new Error("fastqueue concurrency must be greater than 1");
    }
    var cache = reusify(Task);
    var queueHead = null;
    var queueTail = null;
    var _running = 0;
    var errorHandler = null;
    var self2 = {
      push,
      drain: noop,
      saturated: noop,
      pause,
      paused: false,
      concurrency,
      running,
      resume,
      idle,
      length,
      getQueue,
      unshift,
      empty: noop,
      kill,
      killAndDrain,
      error
    };
    return self2;
    function running() {
      return _running;
    }
    function pause() {
      self2.paused = true;
    }
    function length() {
      var current = queueHead;
      var counter2 = 0;
      while (current) {
        current = current.next;
        counter2++;
      }
      return counter2;
    }
    function getQueue() {
      var current = queueHead;
      var tasks = [];
      while (current) {
        tasks.push(current.value);
        current = current.next;
      }
      return tasks;
    }
    function resume() {
      if (!self2.paused)
        return;
      self2.paused = false;
      for (var i = 0; i < self2.concurrency; i++) {
        _running++;
        release();
      }
    }
    function idle() {
      return _running === 0 && self2.length() === 0;
    }
    function push(value, done) {
      var current = cache.get();
      current.context = context;
      current.release = release;
      current.value = value;
      current.callback = done || noop;
      current.errorHandler = errorHandler;
      if (_running === self2.concurrency || self2.paused) {
        if (queueTail) {
          queueTail.next = current;
          queueTail = current;
        } else {
          queueHead = current;
          queueTail = current;
          self2.saturated();
        }
      } else {
        _running++;
        worker.call(context, current.value, current.worked);
      }
    }
    function unshift(value, done) {
      var current = cache.get();
      current.context = context;
      current.release = release;
      current.value = value;
      current.callback = done || noop;
      if (_running === self2.concurrency || self2.paused) {
        if (queueHead) {
          current.next = queueHead;
          queueHead = current;
        } else {
          queueHead = current;
          queueTail = current;
          self2.saturated();
        }
      } else {
        _running++;
        worker.call(context, current.value, current.worked);
      }
    }
    function release(holder) {
      if (holder) {
        cache.release(holder);
      }
      var next = queueHead;
      if (next) {
        if (!self2.paused) {
          if (queueTail === queueHead) {
            queueTail = null;
          }
          queueHead = next.next;
          next.next = null;
          worker.call(context, next.value, next.worked);
          if (queueTail === null) {
            self2.empty();
          }
        } else {
          _running--;
        }
      } else if (--_running === 0) {
        self2.drain();
      }
    }
    function kill() {
      queueHead = null;
      queueTail = null;
      self2.drain = noop;
    }
    function killAndDrain() {
      queueHead = null;
      queueTail = null;
      self2.drain();
      self2.drain = noop;
    }
    function error(handler) {
      errorHandler = handler;
    }
  }
  function noop() {
  }
  function Task() {
    this.value = null;
    this.callback = noop;
    this.next = null;
    this.release = noop;
    this.context = null;
    this.errorHandler = null;
    var self2 = this;
    this.worked = function worked(err, result) {
      var callback = self2.callback;
      var errorHandler = self2.errorHandler;
      var val = self2.value;
      self2.value = null;
      self2.callback = noop;
      if (self2.errorHandler) {
        errorHandler(err, val);
      }
      callback.call(self2.context, err, result);
      self2.release(self2);
    };
  }
  function queueAsPromised(context, worker, concurrency) {
    if (typeof context === "function") {
      concurrency = worker;
      worker = context;
      context = null;
    }
    function asyncWrapper(arg2, cb) {
      worker.call(this, arg2).then(function(res) {
        cb(null, res);
      }, cb);
    }
    var queue = fastqueue(context, asyncWrapper, concurrency);
    var pushCb = queue.push;
    var unshiftCb = queue.unshift;
    queue.push = push;
    queue.unshift = unshift;
    return queue;
    function push(value) {
      return new Promise(function(resolve, reject) {
        pushCb(value, function(err, result) {
          if (err) {
            reject(err);
            return;
          }
          resolve(result);
        });
      });
    }
    function unshift(value) {
      return new Promise(function(resolve, reject) {
        unshiftCb(value, function(err, result) {
          if (err) {
            reject(err);
            return;
          }
          resolve(result);
        });
      });
    }
  }
  module2.exports = fastqueue;
  module2.exports.promise = queueAsPromised;
});

// ../../node_modules/.pnpm/@nodelib+fs.walk@1.2.6/node_modules/@nodelib/fs.walk/out/readers/common.js
var require_common11 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.joinPathSegments = exports2.replacePathSegmentSeparator = exports2.isAppliedFilter = exports2.isFatalError = void 0;
  function isFatalError(settings, error) {
    if (settings.errorFilter === null) {
      return true;
    }
    return !settings.errorFilter(error);
  }
  exports2.isFatalError = isFatalError;
  function isAppliedFilter(filter, value) {
    return filter === null || filter(value);
  }
  exports2.isAppliedFilter = isAppliedFilter;
  function replacePathSegmentSeparator(filepath, separator) {
    return filepath.split(/[/\\]/).join(separator);
  }
  exports2.replacePathSegmentSeparator = replacePathSegmentSeparator;
  function joinPathSegments(a, b, separator) {
    if (a === "") {
      return b;
    }
    if (a.endsWith(separator)) {
      return a + b;
    }
    return a + separator + b;
  }
  exports2.joinPathSegments = joinPathSegments;
});

// ../../node_modules/.pnpm/@nodelib+fs.walk@1.2.6/node_modules/@nodelib/fs.walk/out/readers/reader.js
var require_reader3 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var common = require_common11();
  var Reader = class {
    constructor(_root, _settings) {
      this._root = _root;
      this._settings = _settings;
      this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
    }
  };
  exports2.default = Reader;
});

// ../../node_modules/.pnpm/@nodelib+fs.walk@1.2.6/node_modules/@nodelib/fs.walk/out/readers/async.js
var require_async9 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var events_1 = require("events");
  var fsScandir = require_out6();
  var fastq = require_queue2();
  var common = require_common11();
  var reader_1 = require_reader3();
  var AsyncReader = class extends reader_1.default {
    constructor(_root, _settings) {
      super(_root, _settings);
      this._settings = _settings;
      this._scandir = fsScandir.scandir;
      this._emitter = new events_1.EventEmitter();
      this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
      this._isFatalError = false;
      this._isDestroyed = false;
      this._queue.drain = () => {
        if (!this._isFatalError) {
          this._emitter.emit("end");
        }
      };
    }
    read() {
      this._isFatalError = false;
      this._isDestroyed = false;
      setImmediate(() => {
        this._pushToQueue(this._root, this._settings.basePath);
      });
      return this._emitter;
    }
    get isDestroyed() {
      return this._isDestroyed;
    }
    destroy() {
      if (this._isDestroyed) {
        throw new Error("The reader is already destroyed");
      }
      this._isDestroyed = true;
      this._queue.killAndDrain();
    }
    onEntry(callback) {
      this._emitter.on("entry", callback);
    }
    onError(callback) {
      this._emitter.once("error", callback);
    }
    onEnd(callback) {
      this._emitter.once("end", callback);
    }
    _pushToQueue(directory, base) {
      const queueItem = {directory, base};
      this._queue.push(queueItem, (error) => {
        if (error !== null) {
          this._handleError(error);
        }
      });
    }
    _worker(item, done) {
      this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {
        if (error !== null) {
          return done(error, void 0);
        }
        for (const entry of entries) {
          this._handleEntry(entry, item.base);
        }
        done(null, void 0);
      });
    }
    _handleError(error) {
      if (this._isDestroyed || !common.isFatalError(this._settings, error)) {
        return;
      }
      this._isFatalError = true;
      this._isDestroyed = true;
      this._emitter.emit("error", error);
    }
    _handleEntry(entry, base) {
      if (this._isDestroyed || this._isFatalError) {
        return;
      }
      const fullpath = entry.path;
      if (base !== void 0) {
        entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
      }
      if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
        this._emitEntry(entry);
      }
      if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
        this._pushToQueue(fullpath, entry.path);
      }
    }
    _emitEntry(entry) {
      this._emitter.emit("entry", entry);
    }
  };
  exports2.default = AsyncReader;
});

// ../../node_modules/.pnpm/@nodelib+fs.walk@1.2.6/node_modules/@nodelib/fs.walk/out/providers/async.js
var require_async10 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var async_1 = require_async9();
  var AsyncProvider = class {
    constructor(_root, _settings) {
      this._root = _root;
      this._settings = _settings;
      this._reader = new async_1.default(this._root, this._settings);
      this._storage = new Set();
    }
    read(callback) {
      this._reader.onError((error) => {
        callFailureCallback(callback, error);
      });
      this._reader.onEntry((entry) => {
        this._storage.add(entry);
      });
      this._reader.onEnd(() => {
        callSuccessCallback(callback, [...this._storage]);
      });
      this._reader.read();
    }
  };
  exports2.default = AsyncProvider;
  function callFailureCallback(callback, error) {
    callback(error);
  }
  function callSuccessCallback(callback, entries) {
    callback(null, entries);
  }
});

// ../../node_modules/.pnpm/@nodelib+fs.walk@1.2.6/node_modules/@nodelib/fs.walk/out/providers/stream.js
var require_stream8 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var stream_1 = require("stream");
  var async_1 = require_async9();
  var StreamProvider = class {
    constructor(_root, _settings) {
      this._root = _root;
      this._settings = _settings;
      this._reader = new async_1.default(this._root, this._settings);
      this._stream = new stream_1.Readable({
        objectMode: true,
        read: () => {
        },
        destroy: () => {
          if (!this._reader.isDestroyed) {
            this._reader.destroy();
          }
        }
      });
    }
    read() {
      this._reader.onError((error) => {
        this._stream.emit("error", error);
      });
      this._reader.onEntry((entry) => {
        this._stream.push(entry);
      });
      this._reader.onEnd(() => {
        this._stream.push(null);
      });
      this._reader.read();
      return this._stream;
    }
  };
  exports2.default = StreamProvider;
});

// ../../node_modules/.pnpm/@nodelib+fs.walk@1.2.6/node_modules/@nodelib/fs.walk/out/readers/sync.js
var require_sync12 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var fsScandir = require_out6();
  var common = require_common11();
  var reader_1 = require_reader3();
  var SyncReader = class extends reader_1.default {
    constructor() {
      super(...arguments);
      this._scandir = fsScandir.scandirSync;
      this._storage = new Set();
      this._queue = new Set();
    }
    read() {
      this._pushToQueue(this._root, this._settings.basePath);
      this._handleQueue();
      return [...this._storage];
    }
    _pushToQueue(directory, base) {
      this._queue.add({directory, base});
    }
    _handleQueue() {
      for (const item of this._queue.values()) {
        this._handleDirectory(item.directory, item.base);
      }
    }
    _handleDirectory(directory, base) {
      try {
        const entries = this._scandir(directory, this._settings.fsScandirSettings);
        for (const entry of entries) {
          this._handleEntry(entry, base);
        }
      } catch (error) {
        this._handleError(error);
      }
    }
    _handleError(error) {
      if (!common.isFatalError(this._settings, error)) {
        return;
      }
      throw error;
    }
    _handleEntry(entry, base) {
      const fullpath = entry.path;
      if (base !== void 0) {
        entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
      }
      if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
        this._pushToStorage(entry);
      }
      if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
        this._pushToQueue(fullpath, entry.path);
      }
    }
    _pushToStorage(entry) {
      this._storage.add(entry);
    }
  };
  exports2.default = SyncReader;
});

// ../../node_modules/.pnpm/@nodelib+fs.walk@1.2.6/node_modules/@nodelib/fs.walk/out/providers/sync.js
var require_sync13 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var sync_1 = require_sync12();
  var SyncProvider = class {
    constructor(_root, _settings) {
      this._root = _root;
      this._settings = _settings;
      this._reader = new sync_1.default(this._root, this._settings);
    }
    read() {
      return this._reader.read();
    }
  };
  exports2.default = SyncProvider;
});

// ../../node_modules/.pnpm/@nodelib+fs.walk@1.2.6/node_modules/@nodelib/fs.walk/out/settings.js
var require_settings7 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var path4 = require("path");
  var fsScandir = require_out6();
  var Settings = class {
    constructor(_options = {}) {
      this._options = _options;
      this.basePath = this._getValue(this._options.basePath, void 0);
      this.concurrency = this._getValue(this._options.concurrency, Infinity);
      this.deepFilter = this._getValue(this._options.deepFilter, null);
      this.entryFilter = this._getValue(this._options.entryFilter, null);
      this.errorFilter = this._getValue(this._options.errorFilter, null);
      this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path4.sep);
      this.fsScandirSettings = new fsScandir.Settings({
        followSymbolicLinks: this._options.followSymbolicLinks,
        fs: this._options.fs,
        pathSegmentSeparator: this._options.pathSegmentSeparator,
        stats: this._options.stats,
        throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
      });
    }
    _getValue(option, value) {
      return option !== null && option !== void 0 ? option : value;
    }
  };
  exports2.default = Settings;
});

// ../../node_modules/.pnpm/@nodelib+fs.walk@1.2.6/node_modules/@nodelib/fs.walk/out/index.js
var require_out7 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Settings = exports2.walkStream = exports2.walkSync = exports2.walk = void 0;
  var async_1 = require_async10();
  var stream_1 = require_stream8();
  var sync_1 = require_sync13();
  var settings_1 = require_settings7();
  exports2.Settings = settings_1.default;
  function walk(directory, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === "function") {
      return new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
    }
    new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
  }
  exports2.walk = walk;
  function walkSync(directory, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    const provider = new sync_1.default(directory, settings);
    return provider.read();
  }
  exports2.walkSync = walkSync;
  function walkStream(directory, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    const provider = new stream_1.default(directory, settings);
    return provider.read();
  }
  exports2.walkStream = walkStream;
  function getSettings(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1.default) {
      return settingsOrOptions;
    }
    return new settings_1.default(settingsOrOptions);
  }
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/readers/reader.js
var require_reader4 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var path4 = require("path");
  var fsStat = require_out5();
  var utils = require_utils8();
  var Reader = class {
    constructor(_settings) {
      this._settings = _settings;
      this._fsStatSettings = new fsStat.Settings({
        followSymbolicLink: this._settings.followSymbolicLinks,
        fs: this._settings.fs,
        throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
      });
    }
    _getFullEntryPath(filepath) {
      return path4.resolve(this._settings.cwd, filepath);
    }
    _makeEntry(stats, pattern) {
      const entry = {
        name: pattern,
        path: pattern,
        dirent: utils.fs.createDirentFromStats(pattern, stats)
      };
      if (this._settings.stats) {
        entry.stats = stats;
      }
      return entry;
    }
    _isFatalError(error) {
      return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
    }
  };
  exports2.default = Reader;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/readers/stream.js
var require_stream9 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var stream_1 = require("stream");
  var fsStat = require_out5();
  var fsWalk = require_out7();
  var reader_1 = require_reader4();
  var ReaderStream = class extends reader_1.default {
    constructor() {
      super(...arguments);
      this._walkStream = fsWalk.walkStream;
      this._stat = fsStat.stat;
    }
    dynamic(root, options) {
      return this._walkStream(root, options);
    }
    static(patterns, options) {
      const filepaths = patterns.map(this._getFullEntryPath, this);
      const stream = new stream_1.PassThrough({objectMode: true});
      stream._write = (index, _enc, done) => {
        return this._getEntry(filepaths[index], patterns[index], options).then((entry) => {
          if (entry !== null && options.entryFilter(entry)) {
            stream.push(entry);
          }
          if (index === filepaths.length - 1) {
            stream.end();
          }
          done();
        }).catch(done);
      };
      for (let i = 0; i < filepaths.length; i++) {
        stream.write(i);
      }
      return stream;
    }
    _getEntry(filepath, pattern, options) {
      return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern)).catch((error) => {
        if (options.errorFilter(error)) {
          return null;
        }
        throw error;
      });
    }
    _getStat(filepath) {
      return new Promise((resolve, reject) => {
        this._stat(filepath, this._fsStatSettings, (error, stats) => {
          return error === null ? resolve(stats) : reject(error);
        });
      });
    }
  };
  exports2.default = ReaderStream;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/providers/matchers/matcher.js
var require_matcher2 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var utils = require_utils8();
  var Matcher = class {
    constructor(_patterns, _settings, _micromatchOptions) {
      this._patterns = _patterns;
      this._settings = _settings;
      this._micromatchOptions = _micromatchOptions;
      this._storage = [];
      this._fillStorage();
    }
    _fillStorage() {
      const patterns = utils.pattern.expandPatternsWithBraceExpansion(this._patterns);
      for (const pattern of patterns) {
        const segments = this._getPatternSegments(pattern);
        const sections = this._splitSegmentsIntoSections(segments);
        this._storage.push({
          complete: sections.length <= 1,
          pattern,
          segments,
          sections
        });
      }
    }
    _getPatternSegments(pattern) {
      const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);
      return parts.map((part) => {
        const dynamic = utils.pattern.isDynamicPattern(part, this._settings);
        if (!dynamic) {
          return {
            dynamic: false,
            pattern: part
          };
        }
        return {
          dynamic: true,
          pattern: part,
          patternRe: utils.pattern.makeRe(part, this._micromatchOptions)
        };
      });
    }
    _splitSegmentsIntoSections(segments) {
      return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));
    }
  };
  exports2.default = Matcher;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/providers/matchers/partial.js
var require_partial2 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var matcher_1 = require_matcher2();
  var PartialMatcher = class extends matcher_1.default {
    match(filepath) {
      const parts = filepath.split("/");
      const levels = parts.length;
      const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);
      for (const pattern of patterns) {
        const section = pattern.sections[0];
        if (!pattern.complete && levels > section.length) {
          return true;
        }
        const match = parts.every((part, index) => {
          const segment = pattern.segments[index];
          if (segment.dynamic && segment.patternRe.test(part)) {
            return true;
          }
          if (!segment.dynamic && segment.pattern === part) {
            return true;
          }
          return false;
        });
        if (match) {
          return true;
        }
      }
      return false;
    }
  };
  exports2.default = PartialMatcher;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/providers/filters/deep.js
var require_deep2 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var utils = require_utils8();
  var partial_1 = require_partial2();
  var DeepFilter = class {
    constructor(_settings, _micromatchOptions) {
      this._settings = _settings;
      this._micromatchOptions = _micromatchOptions;
    }
    getFilter(basePath, positive, negative) {
      const matcher = this._getMatcher(positive);
      const negativeRe = this._getNegativePatternsRe(negative);
      return (entry) => this._filter(basePath, entry, matcher, negativeRe);
    }
    _getMatcher(patterns) {
      return new partial_1.default(patterns, this._settings, this._micromatchOptions);
    }
    _getNegativePatternsRe(patterns) {
      const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);
      return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
    }
    _filter(basePath, entry, matcher, negativeRe) {
      if (this._isSkippedByDeep(basePath, entry.path)) {
        return false;
      }
      if (this._isSkippedSymbolicLink(entry)) {
        return false;
      }
      const filepath = utils.path.removeLeadingDotSegment(entry.path);
      if (this._isSkippedByPositivePatterns(filepath, matcher)) {
        return false;
      }
      return this._isSkippedByNegativePatterns(filepath, negativeRe);
    }
    _isSkippedByDeep(basePath, entryPath) {
      if (this._settings.deep === Infinity) {
        return false;
      }
      return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
    }
    _getEntryLevel(basePath, entryPath) {
      const entryPathDepth = entryPath.split("/").length;
      if (basePath === "") {
        return entryPathDepth;
      }
      const basePathDepth = basePath.split("/").length;
      return entryPathDepth - basePathDepth;
    }
    _isSkippedSymbolicLink(entry) {
      return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
    }
    _isSkippedByPositivePatterns(entryPath, matcher) {
      return !this._settings.baseNameMatch && !matcher.match(entryPath);
    }
    _isSkippedByNegativePatterns(entryPath, patternsRe) {
      return !utils.pattern.matchAny(entryPath, patternsRe);
    }
  };
  exports2.default = DeepFilter;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/providers/filters/entry.js
var require_entry3 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var utils = require_utils8();
  var EntryFilter = class {
    constructor(_settings, _micromatchOptions) {
      this._settings = _settings;
      this._micromatchOptions = _micromatchOptions;
      this.index = new Map();
    }
    getFilter(positive, negative) {
      const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);
      const negativeRe = utils.pattern.convertPatternsToRe(negative, this._micromatchOptions);
      return (entry) => this._filter(entry, positiveRe, negativeRe);
    }
    _filter(entry, positiveRe, negativeRe) {
      if (this._settings.unique && this._isDuplicateEntry(entry)) {
        return false;
      }
      if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
        return false;
      }
      if (this._isSkippedByAbsoluteNegativePatterns(entry.path, negativeRe)) {
        return false;
      }
      const filepath = this._settings.baseNameMatch ? entry.name : entry.path;
      const isMatched = this._isMatchToPatterns(filepath, positiveRe) && !this._isMatchToPatterns(entry.path, negativeRe);
      if (this._settings.unique && isMatched) {
        this._createIndexRecord(entry);
      }
      return isMatched;
    }
    _isDuplicateEntry(entry) {
      return this.index.has(entry.path);
    }
    _createIndexRecord(entry) {
      this.index.set(entry.path, void 0);
    }
    _onlyFileFilter(entry) {
      return this._settings.onlyFiles && !entry.dirent.isFile();
    }
    _onlyDirectoryFilter(entry) {
      return this._settings.onlyDirectories && !entry.dirent.isDirectory();
    }
    _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
      if (!this._settings.absolute) {
        return false;
      }
      const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);
      return utils.pattern.matchAny(fullpath, patternsRe);
    }
    _isMatchToPatterns(entryPath, patternsRe) {
      const filepath = utils.path.removeLeadingDotSegment(entryPath);
      return utils.pattern.matchAny(filepath, patternsRe);
    }
  };
  exports2.default = EntryFilter;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/providers/filters/error.js
var require_error4 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var utils = require_utils8();
  var ErrorFilter = class {
    constructor(_settings) {
      this._settings = _settings;
    }
    getFilter() {
      return (error) => this._isNonFatalError(error);
    }
    _isNonFatalError(error) {
      return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
    }
  };
  exports2.default = ErrorFilter;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/providers/transformers/entry.js
var require_entry4 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var utils = require_utils8();
  var EntryTransformer = class {
    constructor(_settings) {
      this._settings = _settings;
    }
    getTransformer() {
      return (entry) => this._transform(entry);
    }
    _transform(entry) {
      let filepath = entry.path;
      if (this._settings.absolute) {
        filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);
        filepath = utils.path.unixify(filepath);
      }
      if (this._settings.markDirectories && entry.dirent.isDirectory()) {
        filepath += "/";
      }
      if (!this._settings.objectMode) {
        return filepath;
      }
      return Object.assign(Object.assign({}, entry), {path: filepath});
    }
  };
  exports2.default = EntryTransformer;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/providers/provider.js
var require_provider2 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var path4 = require("path");
  var deep_1 = require_deep2();
  var entry_1 = require_entry3();
  var error_1 = require_error4();
  var entry_2 = require_entry4();
  var Provider = class {
    constructor(_settings) {
      this._settings = _settings;
      this.errorFilter = new error_1.default(this._settings);
      this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
      this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
      this.entryTransformer = new entry_2.default(this._settings);
    }
    _getRootDirectory(task) {
      return path4.resolve(this._settings.cwd, task.base);
    }
    _getReaderOptions(task) {
      const basePath = task.base === "." ? "" : task.base;
      return {
        basePath,
        pathSegmentSeparator: "/",
        concurrency: this._settings.concurrency,
        deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
        entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
        errorFilter: this.errorFilter.getFilter(),
        followSymbolicLinks: this._settings.followSymbolicLinks,
        fs: this._settings.fs,
        stats: this._settings.stats,
        throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
        transform: this.entryTransformer.getTransformer()
      };
    }
    _getMicromatchOptions() {
      return {
        dot: this._settings.dot,
        matchBase: this._settings.baseNameMatch,
        nobrace: !this._settings.braceExpansion,
        nocase: !this._settings.caseSensitiveMatch,
        noext: !this._settings.extglob,
        noglobstar: !this._settings.globstar,
        posix: true,
        strictSlashes: false
      };
    }
  };
  exports2.default = Provider;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/providers/async.js
var require_async11 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var stream_1 = require_stream9();
  var provider_1 = require_provider2();
  var ProviderAsync = class extends provider_1.default {
    constructor() {
      super(...arguments);
      this._reader = new stream_1.default(this._settings);
    }
    read(task) {
      const root = this._getRootDirectory(task);
      const options = this._getReaderOptions(task);
      const entries = [];
      return new Promise((resolve, reject) => {
        const stream = this.api(root, task, options);
        stream.once("error", reject);
        stream.on("data", (entry) => entries.push(options.transform(entry)));
        stream.once("end", () => resolve(entries));
      });
    }
    api(root, task, options) {
      if (task.dynamic) {
        return this._reader.dynamic(root, options);
      }
      return this._reader.static(task.patterns, options);
    }
  };
  exports2.default = ProviderAsync;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/providers/stream.js
var require_stream10 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var stream_1 = require("stream");
  var stream_2 = require_stream9();
  var provider_1 = require_provider2();
  var ProviderStream = class extends provider_1.default {
    constructor() {
      super(...arguments);
      this._reader = new stream_2.default(this._settings);
    }
    read(task) {
      const root = this._getRootDirectory(task);
      const options = this._getReaderOptions(task);
      const source = this.api(root, task, options);
      const destination = new stream_1.Readable({objectMode: true, read: () => {
      }});
      source.once("error", (error) => destination.emit("error", error)).on("data", (entry) => destination.emit("data", options.transform(entry))).once("end", () => destination.emit("end"));
      destination.once("close", () => source.destroy());
      return destination;
    }
    api(root, task, options) {
      if (task.dynamic) {
        return this._reader.dynamic(root, options);
      }
      return this._reader.static(task.patterns, options);
    }
  };
  exports2.default = ProviderStream;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/readers/sync.js
var require_sync14 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var fsStat = require_out5();
  var fsWalk = require_out7();
  var reader_1 = require_reader4();
  var ReaderSync = class extends reader_1.default {
    constructor() {
      super(...arguments);
      this._walkSync = fsWalk.walkSync;
      this._statSync = fsStat.statSync;
    }
    dynamic(root, options) {
      return this._walkSync(root, options);
    }
    static(patterns, options) {
      const entries = [];
      for (const pattern of patterns) {
        const filepath = this._getFullEntryPath(pattern);
        const entry = this._getEntry(filepath, pattern, options);
        if (entry === null || !options.entryFilter(entry)) {
          continue;
        }
        entries.push(entry);
      }
      return entries;
    }
    _getEntry(filepath, pattern, options) {
      try {
        const stats = this._getStat(filepath);
        return this._makeEntry(stats, pattern);
      } catch (error) {
        if (options.errorFilter(error)) {
          return null;
        }
        throw error;
      }
    }
    _getStat(filepath) {
      return this._statSync(filepath, this._fsStatSettings);
    }
  };
  exports2.default = ReaderSync;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/providers/sync.js
var require_sync15 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var sync_1 = require_sync14();
  var provider_1 = require_provider2();
  var ProviderSync = class extends provider_1.default {
    constructor() {
      super(...arguments);
      this._reader = new sync_1.default(this._settings);
    }
    read(task) {
      const root = this._getRootDirectory(task);
      const options = this._getReaderOptions(task);
      const entries = this.api(root, task, options);
      return entries.map(options.transform);
    }
    api(root, task, options) {
      if (task.dynamic) {
        return this._reader.dynamic(root, options);
      }
      return this._reader.static(task.patterns, options);
    }
  };
  exports2.default = ProviderSync;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/settings.js
var require_settings8 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
  var fs2 = require("fs");
  var os2 = require("os");
  var CPU_COUNT = Math.max(os2.cpus().length, 1);
  exports2.DEFAULT_FILE_SYSTEM_ADAPTER = {
    lstat: fs2.lstat,
    lstatSync: fs2.lstatSync,
    stat: fs2.stat,
    statSync: fs2.statSync,
    readdir: fs2.readdir,
    readdirSync: fs2.readdirSync
  };
  var Settings = class {
    constructor(_options = {}) {
      this._options = _options;
      this.absolute = this._getValue(this._options.absolute, false);
      this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
      this.braceExpansion = this._getValue(this._options.braceExpansion, true);
      this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
      this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
      this.cwd = this._getValue(this._options.cwd, process.cwd());
      this.deep = this._getValue(this._options.deep, Infinity);
      this.dot = this._getValue(this._options.dot, false);
      this.extglob = this._getValue(this._options.extglob, true);
      this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
      this.fs = this._getFileSystemMethods(this._options.fs);
      this.globstar = this._getValue(this._options.globstar, true);
      this.ignore = this._getValue(this._options.ignore, []);
      this.markDirectories = this._getValue(this._options.markDirectories, false);
      this.objectMode = this._getValue(this._options.objectMode, false);
      this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
      this.onlyFiles = this._getValue(this._options.onlyFiles, true);
      this.stats = this._getValue(this._options.stats, false);
      this.suppressErrors = this._getValue(this._options.suppressErrors, false);
      this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
      this.unique = this._getValue(this._options.unique, true);
      if (this.onlyDirectories) {
        this.onlyFiles = false;
      }
      if (this.stats) {
        this.objectMode = true;
      }
    }
    _getValue(option, value) {
      return option === void 0 ? value : option;
    }
    _getFileSystemMethods(methods = {}) {
      return Object.assign(Object.assign({}, exports2.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
    }
  };
  exports2.default = Settings;
});

// ../../node_modules/.pnpm/fast-glob@3.2.5/node_modules/fast-glob/out/index.js
var require_out8 = __commonJS2((exports2, module2) => {
  "use strict";
  var taskManager = require_tasks2();
  var async_1 = require_async11();
  var stream_1 = require_stream10();
  var sync_1 = require_sync15();
  var settings_1 = require_settings8();
  var utils = require_utils8();
  async function FastGlob(source, options) {
    assertPatternsInput(source);
    const works = getWorks(source, async_1.default, options);
    const result = await Promise.all(works);
    return utils.array.flatten(result);
  }
  (function(FastGlob2) {
    function sync2(source, options) {
      assertPatternsInput(source);
      const works = getWorks(source, sync_1.default, options);
      return utils.array.flatten(works);
    }
    FastGlob2.sync = sync2;
    function stream(source, options) {
      assertPatternsInput(source);
      const works = getWorks(source, stream_1.default, options);
      return utils.stream.merge(works);
    }
    FastGlob2.stream = stream;
    function generateTasks(source, options) {
      assertPatternsInput(source);
      const patterns = [].concat(source);
      const settings = new settings_1.default(options);
      return taskManager.generate(patterns, settings);
    }
    FastGlob2.generateTasks = generateTasks;
    function isDynamicPattern(source, options) {
      assertPatternsInput(source);
      const settings = new settings_1.default(options);
      return utils.pattern.isDynamicPattern(source, settings);
    }
    FastGlob2.isDynamicPattern = isDynamicPattern;
    function escapePath(source) {
      assertPatternsInput(source);
      return utils.path.escape(source);
    }
    FastGlob2.escapePath = escapePath;
  })(FastGlob || (FastGlob = {}));
  function getWorks(source, _Provider, options) {
    const patterns = [].concat(source);
    const settings = new settings_1.default(options);
    const tasks = taskManager.generate(patterns, settings);
    const provider = new _Provider(settings);
    return tasks.map(provider.read, provider);
  }
  function assertPatternsInput(input) {
    const source = [].concat(input);
    const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));
    if (!isValidSource) {
      throw new TypeError("Patterns must be a string (non empty) or an array of strings");
    }
  }
  module2.exports = FastGlob;
});

// ../../node_modules/.pnpm/path-type@4.0.0/node_modules/path-type/index.js
var require_path_type2 = __commonJS2((exports2) => {
  "use strict";
  var {promisify: promisify2} = require("util");
  var fs2 = require("fs");
  async function isType(fsStatType, statsMethodName, filePath) {
    if (typeof filePath !== "string") {
      throw new TypeError(`Expected a string, got ${typeof filePath}`);
    }
    try {
      const stats = await promisify2(fs2[fsStatType])(filePath);
      return stats[statsMethodName]();
    } catch (error) {
      if (error.code === "ENOENT") {
        return false;
      }
      throw error;
    }
  }
  function isTypeSync(fsStatType, statsMethodName, filePath) {
    if (typeof filePath !== "string") {
      throw new TypeError(`Expected a string, got ${typeof filePath}`);
    }
    try {
      return fs2[fsStatType](filePath)[statsMethodName]();
    } catch (error) {
      if (error.code === "ENOENT") {
        return false;
      }
      throw error;
    }
  }
  exports2.isFile = isType.bind(null, "stat", "isFile");
  exports2.isDirectory = isType.bind(null, "stat", "isDirectory");
  exports2.isSymlink = isType.bind(null, "lstat", "isSymbolicLink");
  exports2.isFileSync = isTypeSync.bind(null, "statSync", "isFile");
  exports2.isDirectorySync = isTypeSync.bind(null, "statSync", "isDirectory");
  exports2.isSymlinkSync = isTypeSync.bind(null, "lstatSync", "isSymbolicLink");
});

// ../../node_modules/.pnpm/dir-glob@3.0.1/node_modules/dir-glob/index.js
var require_dir_glob2 = __commonJS2((exports2, module2) => {
  "use strict";
  var path4 = require("path");
  var pathType = require_path_type2();
  var getExtensions = (extensions) => extensions.length > 1 ? `{${extensions.join(",")}}` : extensions[0];
  var getPath = (filepath, cwd) => {
    const pth = filepath[0] === "!" ? filepath.slice(1) : filepath;
    return path4.isAbsolute(pth) ? pth : path4.join(cwd, pth);
  };
  var addExtensions = (file, extensions) => {
    if (path4.extname(file)) {
      return `**/${file}`;
    }
    return `**/${file}.${getExtensions(extensions)}`;
  };
  var getGlob = (directory, options) => {
    if (options.files && !Array.isArray(options.files)) {
      throw new TypeError(`Expected \`files\` to be of type \`Array\` but received type \`${typeof options.files}\``);
    }
    if (options.extensions && !Array.isArray(options.extensions)) {
      throw new TypeError(`Expected \`extensions\` to be of type \`Array\` but received type \`${typeof options.extensions}\``);
    }
    if (options.files && options.extensions) {
      return options.files.map((x) => path4.posix.join(directory, addExtensions(x, options.extensions)));
    }
    if (options.files) {
      return options.files.map((x) => path4.posix.join(directory, `**/${x}`));
    }
    if (options.extensions) {
      return [path4.posix.join(directory, `**/*.${getExtensions(options.extensions)}`)];
    }
    return [path4.posix.join(directory, "**")];
  };
  module2.exports = async (input, options) => {
    options = {
      cwd: process.cwd(),
      ...options
    };
    if (typeof options.cwd !== "string") {
      throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
    }
    const globs = await Promise.all([].concat(input).map(async (x) => {
      const isDirectory = await pathType.isDirectory(getPath(x, options.cwd));
      return isDirectory ? getGlob(x, options) : x;
    }));
    return [].concat.apply([], globs);
  };
  module2.exports.sync = (input, options) => {
    options = {
      cwd: process.cwd(),
      ...options
    };
    if (typeof options.cwd !== "string") {
      throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
    }
    const globs = [].concat(input).map((x) => pathType.isDirectorySync(getPath(x, options.cwd)) ? getGlob(x, options) : x);
    return [].concat.apply([], globs);
  };
});

// ../../node_modules/.pnpm/ignore@5.1.8/node_modules/ignore/index.js
var require_ignore2 = __commonJS2((exports2, module2) => {
  function makeArray(subject) {
    return Array.isArray(subject) ? subject : [subject];
  }
  var EMPTY = "";
  var SPACE = " ";
  var ESCAPE = "\\";
  var REGEX_TEST_BLANK_LINE = /^\s+$/;
  var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
  var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
  var REGEX_SPLITALL_CRLF = /\r?\n/g;
  var REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
  var SLASH = "/";
  var KEY_IGNORE = typeof Symbol !== "undefined" ? Symbol.for("node-ignore") : "node-ignore";
  var define2 = (object, key, value) => Object.defineProperty(object, key, {value});
  var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
  var sanitizeRange = (range) => range.replace(REGEX_REGEXP_RANGE, (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY);
  var cleanRangeBackSlash = (slashes) => {
    const {length} = slashes;
    return slashes.slice(0, length - length % 2);
  };
  var REPLACERS = [
    [
      /\\?\s+$/,
      (match) => match.indexOf("\\") === 0 ? SPACE : EMPTY
    ],
    [
      /\\\s/g,
      () => SPACE
    ],
    [
      /[\\$.|*+(){^]/g,
      (match) => `\\${match}`
    ],
    [
      /(?!\\)\?/g,
      () => "[^/]"
    ],
    [
      /^\//,
      () => "^"
    ],
    [
      /\//g,
      () => "\\/"
    ],
    [
      /^\^*\\\*\\\*\\\//,
      () => "^(?:.*\\/)?"
    ],
    [
      /^(?=[^^])/,
      function startingReplacer() {
        return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
      }
    ],
    [
      /\\\/\\\*\\\*(?=\\\/|$)/g,
      (_2, index, str) => index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
    ],
    [
      /(^|[^\\]+)\\\*(?=.+)/g,
      (_2, p1) => `${p1}[^\\/]*`
    ],
    [
      /\\\\\\(?=[$.|*+(){^])/g,
      () => ESCAPE
    ],
    [
      /\\\\/g,
      () => ESCAPE
    ],
    [
      /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
      (match, leadEscape, range, endEscape, close2) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close2}` : close2 === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"
    ],
    [
      /(?:[^*])$/,
      (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
    ],
    [
      /(\^|\\\/)?\\\*$/,
      (_2, p1) => {
        const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
        return `${prefix}(?=$|\\/$)`;
      }
    ]
  ];
  var regexCache = Object.create(null);
  var makeRegex = (pattern, negative, ignorecase) => {
    const r = regexCache[pattern];
    if (r) {
      return r;
    }
    const source = REPLACERS.reduce((prev, current) => prev.replace(current[0], current[1].bind(pattern)), pattern);
    return regexCache[pattern] = ignorecase ? new RegExp(source, "i") : new RegExp(source);
  };
  var isString = (subject) => typeof subject === "string";
  var checkPattern = (pattern) => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && pattern.indexOf("#") !== 0;
  var splitPattern = (pattern) => pattern.split(REGEX_SPLITALL_CRLF);
  var IgnoreRule = class {
    constructor(origin, pattern, negative, regex) {
      this.origin = origin;
      this.pattern = pattern;
      this.negative = negative;
      this.regex = regex;
    }
  };
  var createRule = (pattern, ignorecase) => {
    const origin = pattern;
    let negative = false;
    if (pattern.indexOf("!") === 0) {
      negative = true;
      pattern = pattern.substr(1);
    }
    pattern = pattern.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
    const regex = makeRegex(pattern, negative, ignorecase);
    return new IgnoreRule(origin, pattern, negative, regex);
  };
  var throwError = (message, Ctor) => {
    throw new Ctor(message);
  };
  var checkPath2 = (path4, originalPath, doThrow) => {
    if (!isString(path4)) {
      return doThrow(`path must be a string, but got \`${originalPath}\``, TypeError);
    }
    if (!path4) {
      return doThrow(`path must not be empty`, TypeError);
    }
    if (checkPath2.isNotRelative(path4)) {
      const r = "`path.relative()`d";
      return doThrow(`path should be a ${r} string, but got "${originalPath}"`, RangeError);
    }
    return true;
  };
  var isNotRelative = (path4) => REGEX_TEST_INVALID_PATH.test(path4);
  checkPath2.isNotRelative = isNotRelative;
  checkPath2.convert = (p) => p;
  var Ignore = class {
    constructor({
      ignorecase = true
    } = {}) {
      this._rules = [];
      this._ignorecase = ignorecase;
      define2(this, KEY_IGNORE, true);
      this._initCache();
    }
    _initCache() {
      this._ignoreCache = Object.create(null);
      this._testCache = Object.create(null);
    }
    _addPattern(pattern) {
      if (pattern && pattern[KEY_IGNORE]) {
        this._rules = this._rules.concat(pattern._rules);
        this._added = true;
        return;
      }
      if (checkPattern(pattern)) {
        const rule = createRule(pattern, this._ignorecase);
        this._added = true;
        this._rules.push(rule);
      }
    }
    add(pattern) {
      this._added = false;
      makeArray(isString(pattern) ? splitPattern(pattern) : pattern).forEach(this._addPattern, this);
      if (this._added) {
        this._initCache();
      }
      return this;
    }
    addPattern(pattern) {
      return this.add(pattern);
    }
    _testOne(path4, checkUnignored) {
      let ignored = false;
      let unignored = false;
      this._rules.forEach((rule) => {
        const {negative} = rule;
        if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
          return;
        }
        const matched = rule.regex.test(path4);
        if (matched) {
          ignored = !negative;
          unignored = negative;
        }
      });
      return {
        ignored,
        unignored
      };
    }
    _test(originalPath, cache, checkUnignored, slices) {
      const path4 = originalPath && checkPath2.convert(originalPath);
      checkPath2(path4, originalPath, throwError);
      return this._t(path4, cache, checkUnignored, slices);
    }
    _t(path4, cache, checkUnignored, slices) {
      if (path4 in cache) {
        return cache[path4];
      }
      if (!slices) {
        slices = path4.split(SLASH);
      }
      slices.pop();
      if (!slices.length) {
        return cache[path4] = this._testOne(path4, checkUnignored);
      }
      const parent = this._t(slices.join(SLASH) + SLASH, cache, checkUnignored, slices);
      return cache[path4] = parent.ignored ? parent : this._testOne(path4, checkUnignored);
    }
    ignores(path4) {
      return this._test(path4, this._ignoreCache, false).ignored;
    }
    createFilter() {
      return (path4) => !this.ignores(path4);
    }
    filter(paths) {
      return makeArray(paths).filter(this.createFilter());
    }
    test(path4) {
      return this._test(path4, this._testCache, true);
    }
  };
  var factory = (options) => new Ignore(options);
  var returnFalse = () => false;
  var isPathValid = (path4) => checkPath2(path4 && checkPath2.convert(path4), path4, returnFalse);
  factory.isPathValid = isPathValid;
  factory.default = factory;
  module2.exports = factory;
  if (typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")) {
    const makePosix = (str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/");
    checkPath2.convert = makePosix;
    const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
    checkPath2.isNotRelative = (path4) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path4) || isNotRelative(path4);
  }
});

// ../../node_modules/.pnpm/slash@3.0.0/node_modules/slash/index.js
var require_slash2 = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = (path4) => {
    const isExtendedLengthPath = /^\\\\\?\\/.test(path4);
    const hasNonAscii = /[^\u0000-\u0080]+/.test(path4);
    if (isExtendedLengthPath || hasNonAscii) {
      return path4;
    }
    return path4.replace(/\\/g, "/");
  };
});

// ../../node_modules/.pnpm/globby@11.0.4/node_modules/globby/gitignore.js
var require_gitignore2 = __commonJS2((exports2, module2) => {
  "use strict";
  var {promisify: promisify2} = require("util");
  var fs2 = require("fs");
  var path4 = require("path");
  var fastGlob = require_out8();
  var gitIgnore = require_ignore2();
  var slash = require_slash2();
  var DEFAULT_IGNORE = [
    "**/node_modules/**",
    "**/flow-typed/**",
    "**/coverage/**",
    "**/.git"
  ];
  var readFileP = promisify2(fs2.readFile);
  var mapGitIgnorePatternTo = (base) => (ignore) => {
    if (ignore.startsWith("!")) {
      return "!" + path4.posix.join(base, ignore.slice(1));
    }
    return path4.posix.join(base, ignore);
  };
  var parseGitIgnore = (content, options) => {
    const base = slash(path4.relative(options.cwd, path4.dirname(options.fileName)));
    return content.split(/\r?\n/).filter(Boolean).filter((line) => !line.startsWith("#")).map(mapGitIgnorePatternTo(base));
  };
  var reduceIgnore = (files) => {
    const ignores = gitIgnore();
    for (const file of files) {
      ignores.add(parseGitIgnore(file.content, {
        cwd: file.cwd,
        fileName: file.filePath
      }));
    }
    return ignores;
  };
  var ensureAbsolutePathForCwd = (cwd, p) => {
    cwd = slash(cwd);
    if (path4.isAbsolute(p)) {
      if (slash(p).startsWith(cwd)) {
        return p;
      }
      throw new Error(`Path ${p} is not in cwd ${cwd}`);
    }
    return path4.join(cwd, p);
  };
  var getIsIgnoredPredecate = (ignores, cwd) => {
    return (p) => ignores.ignores(slash(path4.relative(cwd, ensureAbsolutePathForCwd(cwd, p.path || p))));
  };
  var getFile = async (file, cwd) => {
    const filePath = path4.join(cwd, file);
    const content = await readFileP(filePath, "utf8");
    return {
      cwd,
      filePath,
      content
    };
  };
  var getFileSync = (file, cwd) => {
    const filePath = path4.join(cwd, file);
    const content = fs2.readFileSync(filePath, "utf8");
    return {
      cwd,
      filePath,
      content
    };
  };
  var normalizeOptions = ({
    ignore = [],
    cwd = slash(process.cwd())
  } = {}) => {
    return {ignore, cwd};
  };
  module2.exports = async (options) => {
    options = normalizeOptions(options);
    const paths = await fastGlob("**/.gitignore", {
      ignore: DEFAULT_IGNORE.concat(options.ignore),
      cwd: options.cwd
    });
    const files = await Promise.all(paths.map((file) => getFile(file, options.cwd)));
    const ignores = reduceIgnore(files);
    return getIsIgnoredPredecate(ignores, options.cwd);
  };
  module2.exports.sync = (options) => {
    options = normalizeOptions(options);
    const paths = fastGlob.sync("**/.gitignore", {
      ignore: DEFAULT_IGNORE.concat(options.ignore),
      cwd: options.cwd
    });
    const files = paths.map((file) => getFileSync(file, options.cwd));
    const ignores = reduceIgnore(files);
    return getIsIgnoredPredecate(ignores, options.cwd);
  };
});

// ../../node_modules/.pnpm/globby@11.0.4/node_modules/globby/stream-utils.js
var require_stream_utils2 = __commonJS2((exports2, module2) => {
  "use strict";
  var {Transform} = require("stream");
  var ObjectTransform = class extends Transform {
    constructor() {
      super({
        objectMode: true
      });
    }
  };
  var FilterStream = class extends ObjectTransform {
    constructor(filter) {
      super();
      this._filter = filter;
    }
    _transform(data, encoding, callback) {
      if (this._filter(data)) {
        this.push(data);
      }
      callback();
    }
  };
  var UniqueStream = class extends ObjectTransform {
    constructor() {
      super();
      this._pushed = new Set();
    }
    _transform(data, encoding, callback) {
      if (!this._pushed.has(data)) {
        this.push(data);
        this._pushed.add(data);
      }
      callback();
    }
  };
  module2.exports = {
    FilterStream,
    UniqueStream
  };
});

// ../../node_modules/.pnpm/globby@11.0.4/node_modules/globby/index.js
var require_globby2 = __commonJS2((exports2, module2) => {
  "use strict";
  var fs2 = require("fs");
  var arrayUnion = require_array_union2();
  var merge2 = require_merge22();
  var fastGlob = require_out8();
  var dirGlob = require_dir_glob2();
  var gitignore = require_gitignore2();
  var {FilterStream, UniqueStream} = require_stream_utils2();
  var DEFAULT_FILTER = () => false;
  var isNegative = (pattern) => pattern[0] === "!";
  var assertPatternsInput = (patterns) => {
    if (!patterns.every((pattern) => typeof pattern === "string")) {
      throw new TypeError("Patterns must be a string or an array of strings");
    }
  };
  var checkCwdOption = (options = {}) => {
    if (!options.cwd) {
      return;
    }
    let stat2;
    try {
      stat2 = fs2.statSync(options.cwd);
    } catch (e) {
      return;
    }
    if (!stat2.isDirectory()) {
      throw new Error("The `cwd` option must be a path to a directory");
    }
  };
  var getPathString = (p) => p.stats instanceof fs2.Stats ? p.path : p;
  var generateGlobTasks = (patterns, taskOptions) => {
    patterns = arrayUnion([].concat(patterns));
    assertPatternsInput(patterns);
    checkCwdOption(taskOptions);
    const globTasks = [];
    taskOptions = {
      ignore: [],
      expandDirectories: true,
      ...taskOptions
    };
    for (const [index, pattern] of patterns.entries()) {
      if (isNegative(pattern)) {
        continue;
      }
      const ignore = patterns.slice(index).filter((pattern2) => isNegative(pattern2)).map((pattern2) => pattern2.slice(1));
      const options = {
        ...taskOptions,
        ignore: taskOptions.ignore.concat(ignore)
      };
      globTasks.push({pattern, options});
    }
    return globTasks;
  };
  var globDirs = (task, fn) => {
    let options = {};
    if (task.options.cwd) {
      options.cwd = task.options.cwd;
    }
    if (Array.isArray(task.options.expandDirectories)) {
      options = {
        ...options,
        files: task.options.expandDirectories
      };
    } else if (typeof task.options.expandDirectories === "object") {
      options = {
        ...options,
        ...task.options.expandDirectories
      };
    }
    return fn(task.pattern, options);
  };
  var getPattern = (task, fn) => task.options.expandDirectories ? globDirs(task, fn) : [task.pattern];
  var getFilterSync = (options) => {
    return options && options.gitignore ? gitignore.sync({cwd: options.cwd, ignore: options.ignore}) : DEFAULT_FILTER;
  };
  var globToTask = (task) => (glob) => {
    const {options} = task;
    if (options.ignore && Array.isArray(options.ignore) && options.expandDirectories) {
      options.ignore = dirGlob.sync(options.ignore);
    }
    return {
      pattern: glob,
      options
    };
  };
  module2.exports = async (patterns, options) => {
    const globTasks = generateGlobTasks(patterns, options);
    const getFilter = async () => {
      return options && options.gitignore ? gitignore({cwd: options.cwd, ignore: options.ignore}) : DEFAULT_FILTER;
    };
    const getTasks = async () => {
      const tasks2 = await Promise.all(globTasks.map(async (task) => {
        const globs = await getPattern(task, dirGlob);
        return Promise.all(globs.map(globToTask(task)));
      }));
      return arrayUnion(...tasks2);
    };
    const [filter, tasks] = await Promise.all([getFilter(), getTasks()]);
    const paths = await Promise.all(tasks.map((task) => fastGlob(task.pattern, task.options)));
    return arrayUnion(...paths).filter((path_) => !filter(getPathString(path_)));
  };
  module2.exports.sync = (patterns, options) => {
    const globTasks = generateGlobTasks(patterns, options);
    const tasks = [];
    for (const task of globTasks) {
      const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));
      tasks.push(...newTask);
    }
    const filter = getFilterSync(options);
    let matches = [];
    for (const task of tasks) {
      matches = arrayUnion(matches, fastGlob.sync(task.pattern, task.options));
    }
    return matches.filter((path_) => !filter(path_));
  };
  module2.exports.stream = (patterns, options) => {
    const globTasks = generateGlobTasks(patterns, options);
    const tasks = [];
    for (const task of globTasks) {
      const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));
      tasks.push(...newTask);
    }
    const filter = getFilterSync(options);
    const filterStream = new FilterStream((p) => !filter(p));
    const uniqueStream = new UniqueStream();
    return merge2(tasks.map((task) => fastGlob.stream(task.pattern, task.options))).pipe(filterStream).pipe(uniqueStream);
  };
  module2.exports.generateGlobTasks = generateGlobTasks;
  module2.exports.hasMagic = (patterns, options) => [].concat(patterns).some((pattern) => fastGlob.isDynamicPattern(pattern, options));
  module2.exports.gitignore = gitignore;
});

// ../../node_modules/.pnpm/graceful-fs@4.2.6/node_modules/graceful-fs/polyfills.js
var require_polyfills2 = __commonJS2((exports2, module2) => {
  var constants = require("constants");
  var origCwd = process.cwd;
  var cwd = null;
  var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
  process.cwd = function() {
    if (!cwd)
      cwd = origCwd.call(process);
    return cwd;
  };
  try {
    process.cwd();
  } catch (er) {
  }
  if (typeof process.chdir === "function") {
    chdir = process.chdir;
    process.chdir = function(d2) {
      cwd = null;
      chdir.call(process, d2);
    };
    if (Object.setPrototypeOf)
      Object.setPrototypeOf(process.chdir, chdir);
  }
  var chdir;
  module2.exports = patch;
  function patch(fs2) {
    if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
      patchLchmod(fs2);
    }
    if (!fs2.lutimes) {
      patchLutimes(fs2);
    }
    fs2.chown = chownFix(fs2.chown);
    fs2.fchown = chownFix(fs2.fchown);
    fs2.lchown = chownFix(fs2.lchown);
    fs2.chmod = chmodFix(fs2.chmod);
    fs2.fchmod = chmodFix(fs2.fchmod);
    fs2.lchmod = chmodFix(fs2.lchmod);
    fs2.chownSync = chownFixSync(fs2.chownSync);
    fs2.fchownSync = chownFixSync(fs2.fchownSync);
    fs2.lchownSync = chownFixSync(fs2.lchownSync);
    fs2.chmodSync = chmodFixSync(fs2.chmodSync);
    fs2.fchmodSync = chmodFixSync(fs2.fchmodSync);
    fs2.lchmodSync = chmodFixSync(fs2.lchmodSync);
    fs2.stat = statFix(fs2.stat);
    fs2.fstat = statFix(fs2.fstat);
    fs2.lstat = statFix(fs2.lstat);
    fs2.statSync = statFixSync(fs2.statSync);
    fs2.fstatSync = statFixSync(fs2.fstatSync);
    fs2.lstatSync = statFixSync(fs2.lstatSync);
    if (!fs2.lchmod) {
      fs2.lchmod = function(path4, mode, cb) {
        if (cb)
          process.nextTick(cb);
      };
      fs2.lchmodSync = function() {
      };
    }
    if (!fs2.lchown) {
      fs2.lchown = function(path4, uid, gid, cb) {
        if (cb)
          process.nextTick(cb);
      };
      fs2.lchownSync = function() {
      };
    }
    if (platform === "win32") {
      fs2.rename = function(fs$rename) {
        return function(from, to, cb) {
          var start = Date.now();
          var backoff = 0;
          fs$rename(from, to, function CB(er) {
            if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
              setTimeout(function() {
                fs2.stat(to, function(stater, st) {
                  if (stater && stater.code === "ENOENT")
                    fs$rename(from, to, CB);
                  else
                    cb(er);
                });
              }, backoff);
              if (backoff < 100)
                backoff += 10;
              return;
            }
            if (cb)
              cb(er);
          });
        };
      }(fs2.rename);
    }
    fs2.read = function(fs$read) {
      function read(fd, buffer, offset, length, position, callback_) {
        var callback;
        if (callback_ && typeof callback_ === "function") {
          var eagCounter = 0;
          callback = function(er, _2, __) {
            if (er && er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
            }
            callback_.apply(this, arguments);
          };
        }
        return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
      }
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(read, fs$read);
      return read;
    }(fs2.read);
    fs2.readSync = function(fs$readSync) {
      return function(fd, buffer, offset, length, position) {
        var eagCounter = 0;
        while (true) {
          try {
            return fs$readSync.call(fs2, fd, buffer, offset, length, position);
          } catch (er) {
            if (er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              continue;
            }
            throw er;
          }
        }
      };
    }(fs2.readSync);
    function patchLchmod(fs3) {
      fs3.lchmod = function(path4, mode, callback) {
        fs3.open(path4, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
          if (err) {
            if (callback)
              callback(err);
            return;
          }
          fs3.fchmod(fd, mode, function(err2) {
            fs3.close(fd, function(err22) {
              if (callback)
                callback(err2 || err22);
            });
          });
        });
      };
      fs3.lchmodSync = function(path4, mode) {
        var fd = fs3.openSync(path4, constants.O_WRONLY | constants.O_SYMLINK, mode);
        var threw = true;
        var ret;
        try {
          ret = fs3.fchmodSync(fd, mode);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs3.closeSync(fd);
            } catch (er) {
            }
          } else {
            fs3.closeSync(fd);
          }
        }
        return ret;
      };
    }
    function patchLutimes(fs3) {
      if (constants.hasOwnProperty("O_SYMLINK")) {
        fs3.lutimes = function(path4, at, mt, cb) {
          fs3.open(path4, constants.O_SYMLINK, function(er, fd) {
            if (er) {
              if (cb)
                cb(er);
              return;
            }
            fs3.futimes(fd, at, mt, function(er2) {
              fs3.close(fd, function(er22) {
                if (cb)
                  cb(er2 || er22);
              });
            });
          });
        };
        fs3.lutimesSync = function(path4, at, mt) {
          var fd = fs3.openSync(path4, constants.O_SYMLINK);
          var ret;
          var threw = true;
          try {
            ret = fs3.futimesSync(fd, at, mt);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs3.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs3.closeSync(fd);
            }
          }
          return ret;
        };
      } else {
        fs3.lutimes = function(_a, _b, _c, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs3.lutimesSync = function() {
        };
      }
    }
    function chmodFix(orig) {
      if (!orig)
        return orig;
      return function(target, mode, cb) {
        return orig.call(fs2, target, mode, function(er) {
          if (chownErOk(er))
            er = null;
          if (cb)
            cb.apply(this, arguments);
        });
      };
    }
    function chmodFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, mode) {
        try {
          return orig.call(fs2, target, mode);
        } catch (er) {
          if (!chownErOk(er))
            throw er;
        }
      };
    }
    function chownFix(orig) {
      if (!orig)
        return orig;
      return function(target, uid, gid, cb) {
        return orig.call(fs2, target, uid, gid, function(er) {
          if (chownErOk(er))
            er = null;
          if (cb)
            cb.apply(this, arguments);
        });
      };
    }
    function chownFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, uid, gid) {
        try {
          return orig.call(fs2, target, uid, gid);
        } catch (er) {
          if (!chownErOk(er))
            throw er;
        }
      };
    }
    function statFix(orig) {
      if (!orig)
        return orig;
      return function(target, options, cb) {
        if (typeof options === "function") {
          cb = options;
          options = null;
        }
        function callback(er, stats) {
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          if (cb)
            cb.apply(this, arguments);
        }
        return options ? orig.call(fs2, target, options, callback) : orig.call(fs2, target, callback);
      };
    }
    function statFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, options) {
        var stats = options ? orig.call(fs2, target, options) : orig.call(fs2, target);
        if (stats.uid < 0)
          stats.uid += 4294967296;
        if (stats.gid < 0)
          stats.gid += 4294967296;
        return stats;
      };
    }
    function chownErOk(er) {
      if (!er)
        return true;
      if (er.code === "ENOSYS")
        return true;
      var nonroot = !process.getuid || process.getuid() !== 0;
      if (nonroot) {
        if (er.code === "EINVAL" || er.code === "EPERM")
          return true;
      }
      return false;
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.6/node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams2 = __commonJS2((exports2, module2) => {
  var Stream = require("stream").Stream;
  module2.exports = legacy;
  function legacy(fs2) {
    return {
      ReadStream,
      WriteStream
    };
    function ReadStream(path4, options) {
      if (!(this instanceof ReadStream))
        return new ReadStream(path4, options);
      Stream.call(this);
      var self2 = this;
      this.path = path4;
      this.fd = null;
      this.readable = true;
      this.paused = false;
      this.flags = "r";
      this.mode = 438;
      this.bufferSize = 64 * 1024;
      options = options || {};
      var keys = Object.keys(options);
      for (var index = 0, length = keys.length; index < length; index++) {
        var key = keys[index];
        this[key] = options[key];
      }
      if (this.encoding)
        this.setEncoding(this.encoding);
      if (this.start !== void 0) {
        if (typeof this.start !== "number") {
          throw TypeError("start must be a Number");
        }
        if (this.end === void 0) {
          this.end = Infinity;
        } else if (typeof this.end !== "number") {
          throw TypeError("end must be a Number");
        }
        if (this.start > this.end) {
          throw new Error("start must be <= end");
        }
        this.pos = this.start;
      }
      if (this.fd !== null) {
        process.nextTick(function() {
          self2._read();
        });
        return;
      }
      fs2.open(this.path, this.flags, this.mode, function(err, fd) {
        if (err) {
          self2.emit("error", err);
          self2.readable = false;
          return;
        }
        self2.fd = fd;
        self2.emit("open", fd);
        self2._read();
      });
    }
    function WriteStream(path4, options) {
      if (!(this instanceof WriteStream))
        return new WriteStream(path4, options);
      Stream.call(this);
      this.path = path4;
      this.fd = null;
      this.writable = true;
      this.flags = "w";
      this.encoding = "binary";
      this.mode = 438;
      this.bytesWritten = 0;
      options = options || {};
      var keys = Object.keys(options);
      for (var index = 0, length = keys.length; index < length; index++) {
        var key = keys[index];
        this[key] = options[key];
      }
      if (this.start !== void 0) {
        if (typeof this.start !== "number") {
          throw TypeError("start must be a Number");
        }
        if (this.start < 0) {
          throw new Error("start must be >= zero");
        }
        this.pos = this.start;
      }
      this.busy = false;
      this._queue = [];
      if (this.fd === null) {
        this._open = fs2.open;
        this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
        this.flush();
      }
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.6/node_modules/graceful-fs/clone.js
var require_clone2 = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = clone2;
  var getPrototypeOf = Object.getPrototypeOf || function(obj) {
    return obj.__proto__;
  };
  function clone2(obj) {
    if (obj === null || typeof obj !== "object")
      return obj;
    if (obj instanceof Object)
      var copy2 = {__proto__: getPrototypeOf(obj)};
    else
      var copy2 = Object.create(null);
    Object.getOwnPropertyNames(obj).forEach(function(key) {
      Object.defineProperty(copy2, key, Object.getOwnPropertyDescriptor(obj, key));
    });
    return copy2;
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.6/node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs2 = __commonJS2((exports2, module2) => {
  var fs2 = require("fs");
  var polyfills = require_polyfills2();
  var legacy = require_legacy_streams2();
  var clone2 = require_clone2();
  var util2 = require("util");
  var gracefulQueue;
  var previousSymbol;
  if (typeof Symbol === "function" && typeof Symbol.for === "function") {
    gracefulQueue = Symbol.for("graceful-fs.queue");
    previousSymbol = Symbol.for("graceful-fs.previous");
  } else {
    gracefulQueue = "___graceful-fs.queue";
    previousSymbol = "___graceful-fs.previous";
  }
  function noop() {
  }
  function publishQueue(context, queue2) {
    Object.defineProperty(context, gracefulQueue, {
      get: function() {
        return queue2;
      }
    });
  }
  var debug4 = noop;
  if (util2.debuglog)
    debug4 = util2.debuglog("gfs4");
  else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
    debug4 = function() {
      var m2 = util2.format.apply(util2, arguments);
      m2 = "GFS4: " + m2.split(/\n/).join("\nGFS4: ");
      console.error(m2);
    };
  if (!fs2[gracefulQueue]) {
    queue = global[gracefulQueue] || [];
    publishQueue(fs2, queue);
    fs2.close = function(fs$close) {
      function close2(fd, cb) {
        return fs$close.call(fs2, fd, function(err) {
          if (!err) {
            retry();
          }
          if (typeof cb === "function")
            cb.apply(this, arguments);
        });
      }
      Object.defineProperty(close2, previousSymbol, {
        value: fs$close
      });
      return close2;
    }(fs2.close);
    fs2.closeSync = function(fs$closeSync) {
      function closeSync(fd) {
        fs$closeSync.apply(fs2, arguments);
        retry();
      }
      Object.defineProperty(closeSync, previousSymbol, {
        value: fs$closeSync
      });
      return closeSync;
    }(fs2.closeSync);
    if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
      process.on("exit", function() {
        debug4(fs2[gracefulQueue]);
        require("assert").equal(fs2[gracefulQueue].length, 0);
      });
    }
  }
  var queue;
  if (!global[gracefulQueue]) {
    publishQueue(global, fs2[gracefulQueue]);
  }
  module2.exports = patch(clone2(fs2));
  if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs2.__patched) {
    module2.exports = patch(fs2);
    fs2.__patched = true;
  }
  function patch(fs3) {
    polyfills(fs3);
    fs3.gracefulify = patch;
    fs3.createReadStream = createReadStream;
    fs3.createWriteStream = createWriteStream;
    var fs$readFile = fs3.readFile;
    fs3.readFile = readFile2;
    function readFile2(path4, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$readFile(path4, options, cb);
      function go$readFile(path5, options2, cb2) {
        return fs$readFile(path5, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$readFile, [path5, options2, cb2]]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
            retry();
          }
        });
      }
    }
    var fs$writeFile = fs3.writeFile;
    fs3.writeFile = writeFile2;
    function writeFile2(path4, data, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$writeFile(path4, data, options, cb);
      function go$writeFile(path5, data2, options2, cb2) {
        return fs$writeFile(path5, data2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$writeFile, [path5, data2, options2, cb2]]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
            retry();
          }
        });
      }
    }
    var fs$appendFile = fs3.appendFile;
    if (fs$appendFile)
      fs3.appendFile = appendFile;
    function appendFile(path4, data, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$appendFile(path4, data, options, cb);
      function go$appendFile(path5, data2, options2, cb2) {
        return fs$appendFile(path5, data2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$appendFile, [path5, data2, options2, cb2]]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
            retry();
          }
        });
      }
    }
    var fs$copyFile = fs3.copyFile;
    if (fs$copyFile)
      fs3.copyFile = copyFile2;
    function copyFile2(src, dest, flags, cb) {
      if (typeof flags === "function") {
        cb = flags;
        flags = 0;
      }
      return fs$copyFile(src, dest, flags, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([fs$copyFile, [src, dest, flags, cb]]);
        else {
          if (typeof cb === "function")
            cb.apply(this, arguments);
          retry();
        }
      });
    }
    var fs$readdir = fs3.readdir;
    fs3.readdir = readdir2;
    function readdir2(path4, options, cb) {
      var args = [path4];
      if (typeof options !== "function") {
        args.push(options);
      } else {
        cb = options;
      }
      args.push(go$readdir$cb);
      return go$readdir(args);
      function go$readdir$cb(err, files) {
        if (files && files.sort)
          files.sort();
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$readdir, [args]]);
        else {
          if (typeof cb === "function")
            cb.apply(this, arguments);
          retry();
        }
      }
    }
    function go$readdir(args) {
      return fs$readdir.apply(fs3, args);
    }
    if (process.version.substr(0, 4) === "v0.8") {
      var legStreams = legacy(fs3);
      ReadStream = legStreams.ReadStream;
      WriteStream = legStreams.WriteStream;
    }
    var fs$ReadStream = fs3.ReadStream;
    if (fs$ReadStream) {
      ReadStream.prototype = Object.create(fs$ReadStream.prototype);
      ReadStream.prototype.open = ReadStream$open;
    }
    var fs$WriteStream = fs3.WriteStream;
    if (fs$WriteStream) {
      WriteStream.prototype = Object.create(fs$WriteStream.prototype);
      WriteStream.prototype.open = WriteStream$open;
    }
    Object.defineProperty(fs3, "ReadStream", {
      get: function() {
        return ReadStream;
      },
      set: function(val) {
        ReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(fs3, "WriteStream", {
      get: function() {
        return WriteStream;
      },
      set: function(val) {
        WriteStream = val;
      },
      enumerable: true,
      configurable: true
    });
    var FileReadStream = ReadStream;
    Object.defineProperty(fs3, "FileReadStream", {
      get: function() {
        return FileReadStream;
      },
      set: function(val) {
        FileReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    var FileWriteStream = WriteStream;
    Object.defineProperty(fs3, "FileWriteStream", {
      get: function() {
        return FileWriteStream;
      },
      set: function(val) {
        FileWriteStream = val;
      },
      enumerable: true,
      configurable: true
    });
    function ReadStream(path4, options) {
      if (this instanceof ReadStream)
        return fs$ReadStream.apply(this, arguments), this;
      else
        return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
    }
    function ReadStream$open() {
      var that = this;
      open2(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          if (that.autoClose)
            that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
          that.read();
        }
      });
    }
    function WriteStream(path4, options) {
      if (this instanceof WriteStream)
        return fs$WriteStream.apply(this, arguments), this;
      else
        return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
    }
    function WriteStream$open() {
      var that = this;
      open2(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
        }
      });
    }
    function createReadStream(path4, options) {
      return new fs3.ReadStream(path4, options);
    }
    function createWriteStream(path4, options) {
      return new fs3.WriteStream(path4, options);
    }
    var fs$open = fs3.open;
    fs3.open = open2;
    function open2(path4, flags, mode, cb) {
      if (typeof mode === "function")
        cb = mode, mode = null;
      return go$open(path4, flags, mode, cb);
      function go$open(path5, flags2, mode2, cb2) {
        return fs$open(path5, flags2, mode2, function(err, fd) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$open, [path5, flags2, mode2, cb2]]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
            retry();
          }
        });
      }
    }
    return fs3;
  }
  function enqueue(elem) {
    debug4("ENQUEUE", elem[0].name, elem[1]);
    fs2[gracefulQueue].push(elem);
  }
  function retry() {
    var elem = fs2[gracefulQueue].shift();
    if (elem) {
      debug4("RETRY", elem[0].name, elem[1]);
      elem[0].apply(null, elem[1]);
    }
  }
});

// ../../node_modules/.pnpm/is-path-cwd@2.2.0/node_modules/is-path-cwd/index.js
var require_is_path_cwd2 = __commonJS2((exports2, module2) => {
  "use strict";
  var path4 = require("path");
  module2.exports = (path_) => {
    let cwd = process.cwd();
    path_ = path4.resolve(path_);
    if (process.platform === "win32") {
      cwd = cwd.toLowerCase();
      path_ = path_.toLowerCase();
    }
    return path_ === cwd;
  };
});

// ../../node_modules/.pnpm/is-path-inside@3.0.3/node_modules/is-path-inside/index.js
var require_is_path_inside2 = __commonJS2((exports2, module2) => {
  "use strict";
  var path4 = require("path");
  module2.exports = (childPath2, parentPath) => {
    const relation = path4.relative(parentPath, childPath2);
    return Boolean(relation && relation !== ".." && !relation.startsWith(`..${path4.sep}`) && relation !== path4.resolve(childPath2));
  };
});

// ../../node_modules/.pnpm/del@6.0.0/node_modules/del/index.js
var require_del2 = __commonJS2((exports2, module2) => {
  "use strict";
  var {promisify: promisify2} = require("util");
  var path4 = require("path");
  var globby = require_globby2();
  var isGlob = require_is_glob2();
  var slash = require_slash2();
  var gracefulFs = require_graceful_fs2();
  var isPathCwd = require_is_path_cwd2();
  var isPathInside = require_is_path_inside2();
  var rimraf = require_rimraf2();
  var pMap = require_p_map3();
  var rimrafP = promisify2(rimraf);
  var rimrafOptions = {
    glob: false,
    unlink: gracefulFs.unlink,
    unlinkSync: gracefulFs.unlinkSync,
    chmod: gracefulFs.chmod,
    chmodSync: gracefulFs.chmodSync,
    stat: gracefulFs.stat,
    statSync: gracefulFs.statSync,
    lstat: gracefulFs.lstat,
    lstatSync: gracefulFs.lstatSync,
    rmdir: gracefulFs.rmdir,
    rmdirSync: gracefulFs.rmdirSync,
    readdir: gracefulFs.readdir,
    readdirSync: gracefulFs.readdirSync
  };
  function safeCheck(file, cwd) {
    if (isPathCwd(file)) {
      throw new Error("Cannot delete the current working directory. Can be overridden with the `force` option.");
    }
    if (!isPathInside(file, cwd)) {
      throw new Error("Cannot delete files/directories outside the current working directory. Can be overridden with the `force` option.");
    }
  }
  function normalizePatterns(patterns) {
    patterns = Array.isArray(patterns) ? patterns : [patterns];
    patterns = patterns.map((pattern) => {
      if (process.platform === "win32" && isGlob(pattern) === false) {
        return slash(pattern);
      }
      return pattern;
    });
    return patterns;
  }
  module2.exports = async (patterns, {force, dryRun, cwd = process.cwd(), ...options} = {}) => {
    options = {
      expandDirectories: false,
      onlyFiles: false,
      followSymbolicLinks: false,
      cwd,
      ...options
    };
    patterns = normalizePatterns(patterns);
    const files = (await globby(patterns, options)).sort((a, b) => b.localeCompare(a));
    const mapper = async (file) => {
      file = path4.resolve(cwd, file);
      if (!force) {
        safeCheck(file, cwd);
      }
      if (!dryRun) {
        await rimrafP(file, rimrafOptions);
      }
      return file;
    };
    const removedFiles = await pMap(files, mapper, options);
    removedFiles.sort((a, b) => a.localeCompare(b));
    return removedFiles;
  };
  module2.exports.sync = (patterns, {force, dryRun, cwd = process.cwd(), ...options} = {}) => {
    options = {
      expandDirectories: false,
      onlyFiles: false,
      followSymbolicLinks: false,
      cwd,
      ...options
    };
    patterns = normalizePatterns(patterns);
    const files = globby.sync(patterns, options).sort((a, b) => b.localeCompare(a));
    const removedFiles = files.map((file) => {
      file = path4.resolve(cwd, file);
      if (!force) {
        safeCheck(file, cwd);
      }
      if (!dryRun) {
        rimraf.sync(file, rimrafOptions);
      }
      return file;
    });
    removedFiles.sort((a, b) => a.localeCompare(b));
    return removedFiles;
  };
});

// ../../node_modules/.pnpm/tempy@1.0.1/node_modules/tempy/index.js
var require_tempy2 = __commonJS2((exports2, module2) => {
  "use strict";
  var fs2 = require("fs");
  var path4 = require("path");
  var uniqueString = require_unique_string2();
  var tempDir = require_temp_dir2();
  var isStream = require_is_stream2();
  var del = require_del2();
  var stream = require("stream");
  var {promisify: promisify2} = require("util");
  var pipeline = promisify2(stream.pipeline);
  var {writeFile: writeFile2} = fs2.promises;
  var getPath = (prefix = "") => path4.join(tempDir, prefix + uniqueString());
  var writeStream = async (filePath, data) => pipeline(data, fs2.createWriteStream(filePath));
  var createTask = (tempyFunction, {extraArguments = 0} = {}) => async (...arguments_) => {
    const [callback, options] = arguments_.slice(extraArguments);
    const result = await tempyFunction(...arguments_.slice(0, extraArguments), options);
    try {
      return await callback(result);
    } finally {
      await del(result, {force: true});
    }
  };
  module2.exports.file = (options) => {
    options = {
      ...options
    };
    if (options.name) {
      if (options.extension !== void 0 && options.extension !== null) {
        throw new Error("The `name` and `extension` options are mutually exclusive");
      }
      return path4.join(module2.exports.directory(), options.name);
    }
    return getPath() + (options.extension === void 0 || options.extension === null ? "" : "." + options.extension.replace(/^\./, ""));
  };
  module2.exports.file.task = createTask(module2.exports.file);
  module2.exports.directory = ({prefix = ""} = {}) => {
    const directory = getPath(prefix);
    fs2.mkdirSync(directory);
    return directory;
  };
  module2.exports.directory.task = createTask(module2.exports.directory);
  module2.exports.write = async (data, options) => {
    const filename = module2.exports.file(options);
    const write2 = isStream(data) ? writeStream : writeFile2;
    await write2(filename, data);
    return filename;
  };
  module2.exports.write.task = createTask(module2.exports.write, {extraArguments: 1});
  module2.exports.writeSync = (data, options) => {
    const filename = module2.exports.file(options);
    fs2.writeFileSync(filename, data);
    return filename;
  };
  Object.defineProperty(module2.exports, "root", {
    get() {
      return tempDir;
    }
  });
});

// ../../node_modules/.pnpm/hasha@5.2.2/node_modules/hasha/index.js
var require_hasha2 = __commonJS2((exports2, module2) => {
  "use strict";
  var fs2 = require("fs");
  var path4 = require("path");
  var crypto2 = require("crypto");
  var isStream = require_is_stream2();
  var {Worker} = (() => {
    try {
      return require("worker_threads");
    } catch (_2) {
      return {};
    }
  })();
  var worker;
  var taskIdCounter = 0;
  var tasks = new Map();
  var recreateWorkerError = (sourceError) => {
    const error = new Error(sourceError.message);
    for (const [key, value] of Object.entries(sourceError)) {
      if (key !== "message") {
        error[key] = value;
      }
    }
    return error;
  };
  var createWorker = () => {
    worker = new Worker(path4.join(__dirname, "thread.js"));
    worker.on("message", (message) => {
      const task = tasks.get(message.id);
      tasks.delete(message.id);
      if (tasks.size === 0) {
        worker.unref();
      }
      if (message.error === void 0) {
        task.resolve(message.value);
      } else {
        task.reject(recreateWorkerError(message.error));
      }
    });
    worker.on("error", (error) => {
      throw error;
    });
  };
  var taskWorker = (method, args, transferList) => new Promise((resolve, reject) => {
    const id = taskIdCounter++;
    tasks.set(id, {resolve, reject});
    if (worker === void 0) {
      createWorker();
    }
    worker.ref();
    worker.postMessage({id, method, args}, transferList);
  });
  var hasha = (input, options = {}) => {
    let outputEncoding = options.encoding || "hex";
    if (outputEncoding === "buffer") {
      outputEncoding = void 0;
    }
    const hash = crypto2.createHash(options.algorithm || "sha512");
    const update = (buffer) => {
      const inputEncoding = typeof buffer === "string" ? "utf8" : void 0;
      hash.update(buffer, inputEncoding);
    };
    if (Array.isArray(input)) {
      input.forEach(update);
    } else {
      update(input);
    }
    return hash.digest(outputEncoding);
  };
  hasha.stream = (options = {}) => {
    let outputEncoding = options.encoding || "hex";
    if (outputEncoding === "buffer") {
      outputEncoding = void 0;
    }
    const stream = crypto2.createHash(options.algorithm || "sha512");
    stream.setEncoding(outputEncoding);
    return stream;
  };
  hasha.fromStream = async (stream, options = {}) => {
    if (!isStream(stream)) {
      throw new TypeError("Expected a stream");
    }
    return new Promise((resolve, reject) => {
      stream.on("error", reject).pipe(hasha.stream(options)).on("error", reject).on("finish", function() {
        resolve(this.read());
      });
    });
  };
  if (Worker === void 0) {
    hasha.fromFile = async (filePath, options) => hasha.fromStream(fs2.createReadStream(filePath), options);
    hasha.async = async (input, options) => hasha(input, options);
  } else {
    hasha.fromFile = async (filePath, {algorithm = "sha512", encoding = "hex"} = {}) => {
      const hash = await taskWorker("hashFile", [algorithm, filePath]);
      if (encoding === "buffer") {
        return Buffer.from(hash);
      }
      return Buffer.from(hash).toString(encoding);
    };
    hasha.async = async (input, {algorithm = "sha512", encoding = "hex"} = {}) => {
      if (encoding === "buffer") {
        encoding = void 0;
      }
      const hash = await taskWorker("hash", [algorithm, input]);
      if (encoding === void 0) {
        return Buffer.from(hash);
      }
      return Buffer.from(hash).toString(encoding);
    };
  }
  hasha.fromFileSync = (filePath, options) => hasha(fs2.readFileSync(filePath), options);
  module2.exports = hasha;
});

// ../../node_modules/.pnpm/@prisma+fetch-engine@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/fetch-engine/dist/downloadZip.js
var require_downloadZip2 = __commonJS2((exports2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : {default: mod2};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.downloadZip = void 0;
  var zlib_1 = __importDefault2(require("zlib"));
  var p_retry_1 = __importDefault2(require_p_retry2());
  var node_fetch_1 = __importDefault2(require_lib5());
  var fs_12 = __importDefault2(require("fs"));
  var getProxyAgent_1 = require_getProxyAgent2();
  var tempy_1 = __importDefault2(require_tempy2());
  var path_12 = __importDefault2(require("path"));
  var debug_12 = __importDefault2(require_dist10());
  var hasha_1 = __importDefault2(require_hasha2());
  var util_12 = require("util");
  var rimraf_1 = __importDefault2(require_rimraf2());
  var debug4 = debug_12.default("prisma:downloadZip");
  var del = util_12.promisify(rimraf_1.default);
  async function fetchSha256(url) {
    const [zippedSha256, sha256] = [
      (await node_fetch_1.default(`${url}.sha256`, {
        agent: getProxyAgent_1.getProxyAgent(url)
      }).then((res) => res.text())).split(/\s+/)[0],
      (await node_fetch_1.default(`${url.slice(0, url.length - 3)}.sha256`, {
        agent: getProxyAgent_1.getProxyAgent(url.slice(0, url.length - 3))
      }).then((res) => res.text())).split(/\s+/)[0]
    ];
    return {sha256, zippedSha256};
  }
  async function downloadZip(url, target, progressCb) {
    const tmpDir = tempy_1.default.directory();
    const partial = path_12.default.join(tmpDir, "partial");
    const {sha256, zippedSha256} = await fetchSha256(url);
    const result = await p_retry_1.default(async () => {
      try {
        const resp = await node_fetch_1.default(url, {
          compress: false,
          agent: getProxyAgent_1.getProxyAgent(url)
        });
        if (resp.status !== 200) {
          throw new Error(resp.statusText + " " + url);
        }
        const lastModified = resp.headers.get("last-modified");
        const size = parseFloat(resp.headers.get("content-length"));
        const ws = fs_12.default.createWriteStream(partial);
        return await new Promise(async (resolve, reject) => {
          let bytesRead = 0;
          resp.body.on("error", reject).on("data", (chunk) => {
            bytesRead += chunk.length;
            if (size && progressCb) {
              progressCb(bytesRead / size);
            }
          });
          const gunzip = zlib_1.default.createGunzip();
          gunzip.on("error", reject);
          const zipStream = resp.body.pipe(gunzip);
          const zippedHashPromise = hasha_1.default.fromStream(resp.body, {
            algorithm: "sha256"
          });
          const hashPromise = hasha_1.default.fromStream(zipStream, {
            algorithm: "sha256"
          });
          zipStream.pipe(ws);
          ws.on("error", reject).on("close", () => {
            resolve({lastModified, sha256, zippedSha256});
          });
          const hash = await hashPromise;
          const zippedHash = await zippedHashPromise;
          if (zippedHash !== zippedSha256) {
            throw new Error(`sha256 of ${url} (zipped) should be ${zippedSha256} but is ${zippedHash}`);
          }
          if (hash !== sha256) {
            throw new Error(`sha256 of ${url} (uzipped) should be ${sha256} but is ${hash}`);
          }
        });
      } finally {
      }
    }, {
      retries: 2,
      onFailedAttempt: (err) => debug4(err)
    });
    fs_12.default.copyFileSync(partial, target);
    try {
      await del(partial);
      await del(tmpDir);
    } catch (e) {
      debug4(e);
    }
    return result;
  }
  exports2.downloadZip = downloadZip;
});

// ../../node_modules/.pnpm/@prisma+fetch-engine@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/fetch-engine/dist/flatMap.js
var require_flatMap2 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.flatMap = void 0;
  function flatten(array) {
    return Array.prototype.concat.apply([], array);
  }
  function flatMap(array, callbackFn, thisArg) {
    return flatten(array.map(callbackFn, thisArg));
  }
  exports2.flatMap = flatMap;
});

// ../../node_modules/.pnpm/@prisma+fetch-engine@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/fetch-engine/dist/getHash.js
var require_getHash2 = __commonJS2((exports2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : {default: mod2};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getHash = void 0;
  var crypto_1 = __importDefault2(require("crypto"));
  var fs_12 = __importDefault2(require("fs"));
  function getHash(filePath) {
    const hash = crypto_1.default.createHash("sha256");
    const input = fs_12.default.createReadStream(filePath);
    return new Promise((resolve) => {
      input.on("readable", () => {
        const data = input.read();
        if (data) {
          hash.update(data);
        } else {
          resolve(hash.digest("hex"));
        }
      });
    });
  }
  exports2.getHash = getHash;
});

// ../../node_modules/.pnpm/@prisma+fetch-engine@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/fetch-engine/dist/getLatestTag.js
var require_getLatestTag2 = __commonJS2((exports2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : {default: mod2};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.urlExists = exports2.getAllUrls = exports2.getLatestTag = void 0;
  var get_platform_12 = require_dist11();
  var chalk_12 = __importDefault2(require_source2());
  var execa_12 = __importDefault2(require_execa2());
  var node_fetch_1 = __importDefault2(require_lib5());
  var p_map_1 = __importDefault2(require_p_map3());
  var getProxyAgent_1 = require_getProxyAgent2();
  var util_12 = require_util4();
  async function getLatestTag() {
    let branch = await getBranch();
    if (branch !== "master" && !isPatchBranch(branch) && !branch.startsWith("integration/")) {
      branch = "master";
    }
    branch = branch.replace(/^integration\//, "");
    let commits = await getCommits(branch);
    if ((!commits || !Array.isArray(commits)) && branch !== "master" && !isPatchBranch(branch)) {
      console.log(`Overwriting branch "${branch}" with "master" as it's not a branch we have binaries for`);
      branch = "master";
      commits = await getCommits(branch);
    }
    if (!Array.isArray(commits)) {
      console.error(commits);
      throw new Error(`Could not fetch commits from github: ${JSON.stringify(commits, null, 2)}`);
    }
    return getFirstFinishedCommit(branch, commits);
  }
  exports2.getLatestTag = getLatestTag;
  function getAllUrls(branch, commit) {
    const urls = [];
    const excludedPlatforms = [
      "freebsd",
      "arm",
      "linux-nixos",
      "openbsd",
      "netbsd",
      "freebsd11",
      "freebsd12"
    ];
    const relevantPlatforms = get_platform_12.platforms.filter((p) => !excludedPlatforms.includes(p));
    for (const platform of relevantPlatforms) {
      for (const engine of [
        "query-engine",
        "introspection-engine",
        "migration-engine",
        "prisma-fmt"
      ]) {
        for (const extension of [
          ".gz",
          ".gz.sha256",
          ".gz.sig",
          ".sig",
          ".sha256"
        ]) {
          const downloadUrl = util_12.getDownloadUrl(branch, commit, platform, engine, extension);
          urls.push(downloadUrl);
        }
      }
    }
    return urls;
  }
  exports2.getAllUrls = getAllUrls;
  async function getFirstFinishedCommit(branch, commits) {
    for (const commit of commits) {
      const urls = getAllUrls(branch, commit);
      const exist = await p_map_1.default(urls, urlExists, {concurrency: 10});
      const hasMissing = exist.some((e) => !e);
      if (!hasMissing) {
        return commit;
      } else {
        const missing = urls.filter((_2, i) => !exist[i]);
        if (missing.length !== urls.length) {
          console.log(`${chalk_12.default.blueBright("info")} The engine commit ${commit} is not yet done. We're skipping it as we're in dev. Missing urls: ${missing.length}`);
        }
      }
    }
  }
  async function urlExists(url) {
    try {
      const res = await node_fetch_1.default(url, {
        method: "HEAD",
        agent: getProxyAgent_1.getProxyAgent(url)
      });
      const headers = fromEntries(res.headers.entries());
      if (res.status > 200) {
      }
      if (parseInt(headers["content-length"]) > 0) {
        return res.status < 300;
      }
    } catch (e) {
    }
    return false;
  }
  exports2.urlExists = urlExists;
  function fromEntries(entries) {
    const result = {};
    for (const [key, value] of entries) {
      result[key] = value;
    }
    return result;
  }
  async function getBranch() {
    if (process.env.NODE_ENV !== "test") {
      if (process.env.PATCH_BRANCH) {
        return process.env.PATCH_BRANCH;
      }
      if (process.env.BUILDKITE_BRANCH) {
        return process.env.BUILDKITE_BRANCH;
      }
      if (process.env.GITHUB_CONTEXT) {
        const context = JSON.parse(process.env.GITHUB_CONTEXT);
        return context.head_ref;
      }
    }
    try {
      const result = await execa_12.default.command("git rev-parse --abbrev-ref HEAD", {
        shell: true,
        stdio: "pipe"
      });
      return result.stdout;
    } catch (e) {
      console.error(e);
    }
    return;
  }
  function isPatchBranch(version) {
    return /^2\.(\d+)\.x/.test(version);
  }
  async function getCommits(branch) {
    const url = `https://github-cache.prisma.workers.dev/repos/prisma/prisma-engines/commits?sha=${branch}`;
    const result = await node_fetch_1.default(url, {
      agent: getProxyAgent_1.getProxyAgent(url),
      headers: {
        Authorization: process.env.GITHUB_TOKEN ? `token ${process.env.GITHUB_TOKEN}` : void 0
      }
    }).then((res) => res.json());
    if (!Array.isArray(result)) {
      return result;
    }
    const commits = result.map((r) => r.sha);
    return commits;
  }
});

// ../../node_modules/.pnpm/progress@2.0.3/node_modules/progress/lib/node-progress.js
var require_node_progress2 = __commonJS2((exports2, module2) => {
  /*!
   * node-progress
   * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>
   * MIT Licensed
   */
  exports2 = module2.exports = ProgressBar;
  function ProgressBar(fmt, options) {
    this.stream = options.stream || process.stderr;
    if (typeof options == "number") {
      var total = options;
      options = {};
      options.total = total;
    } else {
      options = options || {};
      if (typeof fmt != "string")
        throw new Error("format required");
      if (typeof options.total != "number")
        throw new Error("total required");
    }
    this.fmt = fmt;
    this.curr = options.curr || 0;
    this.total = options.total;
    this.width = options.width || this.total;
    this.clear = options.clear;
    this.chars = {
      complete: options.complete || "=",
      incomplete: options.incomplete || "-",
      head: options.head || (options.complete || "=")
    };
    this.renderThrottle = options.renderThrottle !== 0 ? options.renderThrottle || 16 : 0;
    this.lastRender = -Infinity;
    this.callback = options.callback || function() {
    };
    this.tokens = {};
    this.lastDraw = "";
  }
  ProgressBar.prototype.tick = function(len, tokens) {
    if (len !== 0)
      len = len || 1;
    if (typeof len == "object")
      tokens = len, len = 1;
    if (tokens)
      this.tokens = tokens;
    if (this.curr == 0)
      this.start = new Date();
    this.curr += len;
    this.render();
    if (this.curr >= this.total) {
      this.render(void 0, true);
      this.complete = true;
      this.terminate();
      this.callback(this);
      return;
    }
  };
  ProgressBar.prototype.render = function(tokens, force) {
    force = force !== void 0 ? force : false;
    if (tokens)
      this.tokens = tokens;
    if (!this.stream.isTTY)
      return;
    var now = Date.now();
    var delta = now - this.lastRender;
    if (!force && delta < this.renderThrottle) {
      return;
    } else {
      this.lastRender = now;
    }
    var ratio = this.curr / this.total;
    ratio = Math.min(Math.max(ratio, 0), 1);
    var percent = Math.floor(ratio * 100);
    var incomplete, complete, completeLength;
    var elapsed = new Date() - this.start;
    var eta = percent == 100 ? 0 : elapsed * (this.total / this.curr - 1);
    var rate = this.curr / (elapsed / 1e3);
    var str = this.fmt.replace(":current", this.curr).replace(":total", this.total).replace(":elapsed", isNaN(elapsed) ? "0.0" : (elapsed / 1e3).toFixed(1)).replace(":eta", isNaN(eta) || !isFinite(eta) ? "0.0" : (eta / 1e3).toFixed(1)).replace(":percent", percent.toFixed(0) + "%").replace(":rate", Math.round(rate));
    var availableSpace = Math.max(0, this.stream.columns - str.replace(":bar", "").length);
    if (availableSpace && process.platform === "win32") {
      availableSpace = availableSpace - 1;
    }
    var width = Math.min(this.width, availableSpace);
    completeLength = Math.round(width * ratio);
    complete = Array(Math.max(0, completeLength + 1)).join(this.chars.complete);
    incomplete = Array(Math.max(0, width - completeLength + 1)).join(this.chars.incomplete);
    if (completeLength > 0)
      complete = complete.slice(0, -1) + this.chars.head;
    str = str.replace(":bar", complete + incomplete);
    if (this.tokens)
      for (var key in this.tokens)
        str = str.replace(":" + key, this.tokens[key]);
    if (this.lastDraw !== str) {
      this.stream.cursorTo(0);
      this.stream.write(str);
      this.stream.clearLine(1);
      this.lastDraw = str;
    }
  };
  ProgressBar.prototype.update = function(ratio, tokens) {
    var goal = Math.floor(ratio * this.total);
    var delta = goal - this.curr;
    this.tick(delta, tokens);
  };
  ProgressBar.prototype.interrupt = function(message) {
    this.stream.clearLine();
    this.stream.cursorTo(0);
    this.stream.write(message);
    this.stream.write("\n");
    this.stream.write(this.lastDraw);
  };
  ProgressBar.prototype.terminate = function() {
    if (this.clear) {
      if (this.stream.clearLine) {
        this.stream.clearLine();
        this.stream.cursorTo(0);
      }
    } else {
      this.stream.write("\n");
    }
  };
});

// ../../node_modules/.pnpm/progress@2.0.3/node_modules/progress/index.js
var require_progress2 = __commonJS2((exports2, module2) => {
  module2.exports = require_node_progress2();
});

// ../../node_modules/.pnpm/@prisma+fetch-engine@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/fetch-engine/dist/log.js
var require_log2 = __commonJS2((exports2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : {default: mod2};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getBar = void 0;
  var progress_1 = __importDefault2(require_progress2());
  function getBar(text) {
    return new progress_1.default(`> ${text} [:bar] :percent`, {
      stream: process.stdout,
      width: 20,
      complete: "=",
      incomplete: " ",
      total: 100,
      head: "",
      clear: true
    });
  }
  exports2.getBar = getBar;
});

// ../../node_modules/.pnpm/@prisma+fetch-engine@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/fetch-engine/dist/download.js
var require_download2 = __commonJS2((exports, module) => {
  "use strict";
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : {default: mod2};
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.plusX = exports.maybeCopyToTmp = exports.getBinaryEnvVarPath = exports.getBinaryName = exports.checkVersionCommand = exports.getVersion = exports.download = exports.BinaryType = void 0;
  var debug_1 = __importDefault(require_dist10());
  var get_platform_1 = require_dist11();
  var chalk_1 = __importDefault(require_source2());
  var execa_1 = __importDefault(require_execa2());
  var fs_1 = __importDefault(require("fs"));
  var make_dir_1 = __importDefault(require_make_dir2());
  var p_filter_1 = __importDefault(require_p_filter2());
  var path_1 = __importDefault(require("path"));
  var temp_dir_1 = __importDefault(require_temp_dir2());
  var util_1 = require("util");
  var chmod_1 = __importDefault(require_chmod2());
  var cleanupCache_1 = require_cleanupCache2();
  var downloadZip_1 = require_downloadZip2();
  var flatMap_1 = require_flatMap2();
  var getHash_1 = require_getHash2();
  var getLatestTag_1 = require_getLatestTag2();
  var log_1 = require_log2();
  var util_2 = require_util4();
  var debug = debug_1.default("prisma:download");
  var writeFile = util_1.promisify(fs_1.default.writeFile);
  var exists = util_1.promisify(fs_1.default.exists);
  var readFile = util_1.promisify(fs_1.default.readFile);
  var copyFile = util_1.promisify(fs_1.default.copyFile);
  var utimes = util_1.promisify(fs_1.default.utimes);
  var channel = "master";
  var BinaryType;
  (function(BinaryType2) {
    BinaryType2["queryEngine"] = "query-engine";
    BinaryType2["libqueryEngine"] = "libquery-engine";
    BinaryType2["migrationEngine"] = "migration-engine";
    BinaryType2["introspectionEngine"] = "introspection-engine";
    BinaryType2["prismaFmt"] = "prisma-fmt";
  })(BinaryType = exports.BinaryType || (exports.BinaryType = {}));
  var BINARY_TO_ENV_VAR = {
    [BinaryType.migrationEngine]: "PRISMA_MIGRATION_ENGINE_BINARY",
    [BinaryType.queryEngine]: "PRISMA_QUERY_ENGINE_BINARY",
    [BinaryType.libqueryEngine]: "PRISMA_QUERY_ENGINE_LIBRARY",
    [BinaryType.introspectionEngine]: "PRISMA_INTROSPECTION_ENGINE_BINARY",
    [BinaryType.prismaFmt]: "PRISMA_FMT_BINARY"
  };
  async function download(options) {
    var _a, _b;
    const platform = await get_platform_1.getPlatform();
    const os = await get_platform_1.getos();
    if (os.distro && ["nixos"].includes(os.distro)) {
      console.error(`${chalk_1.default.yellow("Warning")} Precompiled binaries are not available for ${os.distro}.`);
    } else if (["freebsd11", "freebsd12", "openbsd", "netbsd"].includes(platform)) {
      console.error(`${chalk_1.default.yellow("Warning")} Precompiled binaries are not available for ${platform}. Read more about building your own binaries at https://pris.ly/d/build-binaries`);
    } else if (BinaryType.libqueryEngine in options.binaries) {
      await get_platform_1.isNodeAPISupported();
    }
    if (!options.binaries || Object.values(options.binaries).length === 0) {
      return {};
    }
    const opts = {
      ...options,
      binaryTargets: (_a = options.binaryTargets) !== null && _a !== void 0 ? _a : [platform],
      version: (_b = options.version) !== null && _b !== void 0 ? _b : "latest",
      binaries: mapKeys(options.binaries, (key) => engineTypeToBinaryType(key, platform))
    };
    const binaryJobs = flatMap_1.flatMap(Object.entries(opts.binaries), ([binaryName, targetFolder]) => opts.binaryTargets.map((binaryTarget) => {
      const fileName = binaryName === BinaryType.libqueryEngine ? get_platform_1.getNodeAPIName(binaryTarget, "fs") : getBinaryName(binaryName, binaryTarget);
      const targetFilePath = path_1.default.join(targetFolder, fileName);
      return {
        binaryName,
        targetFolder,
        binaryTarget,
        fileName,
        targetFilePath,
        envVarPath: getBinaryEnvVarPath(binaryName)
      };
    }));
    if (process.env.BINARY_DOWNLOAD_VERSION) {
      opts.version = process.env.BINARY_DOWNLOAD_VERSION;
    }
    if (opts.version === "latest") {
      opts.version = await getLatestTag_1.getLatestTag();
    }
    if (opts.printVersion) {
      console.log(`version: ${opts.version}`);
    }
    const binariesToDownload = await p_filter_1.default(binaryJobs, async (job) => {
      const needsToBeDownloaded = await binaryNeedsToBeDownloaded(job, platform, opts.version, opts.failSilent);
      const isSupported = get_platform_1.platforms.includes(job.binaryTarget);
      const shouldDownload = isSupported && !job.envVarPath && (opts.ignoreCache || needsToBeDownloaded);
      if (needsToBeDownloaded && !isSupported) {
        throw new Error(`Unknown binaryTarget ${job.binaryTarget} and no custom binaries were provided`);
      }
      return shouldDownload;
    });
    if (binariesToDownload.length > 0) {
      const cleanupPromise = cleanupCache_1.cleanupCache();
      let finishBar;
      let setProgress;
      if (opts.showProgress) {
        const collectiveBar = getCollectiveBar(opts);
        finishBar = collectiveBar.finishBar;
        setProgress = collectiveBar.setProgress;
      }
      await Promise.all(binariesToDownload.map((job) => downloadBinary({
        ...job,
        version: opts.version,
        failSilent: opts.failSilent,
        progressCb: setProgress ? setProgress(job.targetFilePath) : void 0
      })));
      await cleanupPromise;
      if (finishBar) {
        finishBar();
      }
    }
    const binaryPaths = binaryJobsToBinaryPaths(binaryJobs);
    const dir = eval("__dirname");
    if (dir.startsWith("/snapshot/")) {
      for (const engineType in binaryPaths) {
        const binaryTargets = binaryPaths[engineType];
        for (const binaryTarget in binaryTargets) {
          const binaryPath = binaryTargets[binaryTarget];
          binaryTargets[binaryTarget] = await maybeCopyToTmp(binaryPath);
        }
      }
    }
    return binaryPaths;
  }
  exports.download = download;
  function getCollectiveBar(options) {
    var _a, _b;
    const hasNodeAPI = "libquery-engine" in options.binaries;
    const bar = log_1.getBar(`Downloading Prisma engines${hasNodeAPI ? " for Node-API" : ""} for ${(_a = options.binaryTargets) === null || _a === void 0 ? void 0 : _a.map((p) => chalk_1.default.bold(p)).join(" and ")}`);
    const progressMap = {};
    const numDownloads = Object.values(options.binaries).length * Object.values((_b = options === null || options === void 0 ? void 0 : options.binaryTargets) !== null && _b !== void 0 ? _b : []).length;
    const setProgress = (sourcePath) => (progress) => {
      progressMap[sourcePath] = progress;
      const progressValues = Object.values(progressMap);
      const totalProgress = progressValues.reduce((acc, curr) => {
        return acc + curr;
      }, 0) / numDownloads;
      if (options.progressCb) {
        options.progressCb(totalProgress);
      }
      if (bar) {
        bar.update(totalProgress);
      }
    };
    return {
      setProgress,
      finishBar: () => {
        bar.update(1);
        bar.terminate();
      }
    };
  }
  function binaryJobsToBinaryPaths(jobs) {
    return jobs.reduce((acc, job) => {
      if (!acc[job.binaryName]) {
        acc[job.binaryName] = {};
      }
      acc[job.binaryName][job.binaryTarget] = job.envVarPath || job.targetFilePath;
      return acc;
    }, {});
  }
  async function binaryNeedsToBeDownloaded(job, nativePlatform, version, failSilent) {
    if (job.envVarPath && fs_1.default.existsSync(job.envVarPath)) {
      return false;
    }
    const targetExists = await exists(job.targetFilePath);
    const cachedFile = await getCachedBinaryPath({
      ...job,
      version,
      failSilent
    });
    if (cachedFile) {
      const sha256FilePath = cachedFile + ".sha256";
      if (await exists(sha256FilePath)) {
        const sha256File = await readFile(sha256FilePath, "utf-8");
        const sha256Cache = await getHash_1.getHash(cachedFile);
        if (sha256File === sha256Cache) {
          if (!targetExists) {
            debug(`copying ${cachedFile} to ${job.targetFilePath}`);
            await utimes(cachedFile, new Date(), new Date());
            await copyFile(cachedFile, job.targetFilePath);
          }
          const targetSha256 = await getHash_1.getHash(job.targetFilePath);
          if (sha256File !== targetSha256) {
            debug(`overwriting ${job.targetFilePath} with ${cachedFile} as hashes do not match`);
            await copyFile(cachedFile, job.targetFilePath);
          }
          return false;
        } else {
          return true;
        }
      } else {
        return true;
      }
    }
    if (!targetExists) {
      debug(`file ${job.targetFilePath} does not exist and must be downloaded`);
      return true;
    }
    if (job.binaryTarget === nativePlatform && job.binaryName !== BinaryType.libqueryEngine) {
      const works = await checkVersionCommand(job.targetFilePath);
      return !works;
    }
    return false;
  }
  async function getVersion(enginePath) {
    const result = await execa_1.default(enginePath, ["--version"]);
    return result.stdout;
  }
  exports.getVersion = getVersion;
  async function checkVersionCommand(enginePath) {
    try {
      const version = await getVersion(enginePath);
      return version.length > 0;
    } catch (e) {
      return false;
    }
  }
  exports.checkVersionCommand = checkVersionCommand;
  function getBinaryName(binaryName, platform) {
    if (binaryName === BinaryType.libqueryEngine) {
      return `${get_platform_1.getNodeAPIName(platform, "url")}`;
    }
    const extension = platform === "windows" ? ".exe" : "";
    return `${binaryName}-${platform}${extension}`;
  }
  exports.getBinaryName = getBinaryName;
  async function getCachedBinaryPath({version, binaryTarget, binaryName}) {
    const cacheDir = await util_2.getCacheDir(channel, version, binaryTarget);
    if (!cacheDir) {
      return null;
    }
    const cachedTargetPath = path_1.default.join(cacheDir, binaryName);
    if (!fs_1.default.existsSync(cachedTargetPath)) {
      return null;
    }
    if (version !== "latest") {
      return cachedTargetPath;
    }
    if (await exists(cachedTargetPath)) {
      return cachedTargetPath;
    }
    return null;
  }
  function getBinaryEnvVarPath(binaryName) {
    const envVar = BINARY_TO_ENV_VAR[binaryName];
    if (envVar && process.env[envVar]) {
      const envVarPath = path_1.default.resolve(process.cwd(), process.env[envVar]);
      if (!fs_1.default.existsSync(envVarPath)) {
        throw new Error(`Env var ${chalk_1.default.bold(envVar)} is provided but provided path ${chalk_1.default.underline(process.env[envVar])} can't be resolved.`);
      }
      debug(`Using env var ${chalk_1.default.bold(envVar)} for binary ${chalk_1.default.bold(binaryName)}, which points to ${chalk_1.default.underline(process.env[envVar])}`);
      return envVarPath;
    }
    return null;
  }
  exports.getBinaryEnvVarPath = getBinaryEnvVarPath;
  async function downloadBinary(options) {
    const {version, progressCb, targetFilePath, binaryTarget, binaryName} = options;
    const downloadUrl = util_2.getDownloadUrl("all_commits", version, binaryTarget, binaryName);
    const targetDir = path_1.default.dirname(targetFilePath);
    try {
      fs_1.default.accessSync(targetDir, fs_1.default.constants.W_OK);
      await make_dir_1.default(targetDir);
    } catch (e) {
      if (options.failSilent || e.code !== "EACCES") {
        return;
      } else {
        throw new Error(`Can't write to ${targetDir} please make sure you install "prisma" with the right permissions.`);
      }
    }
    debug(`Downloading ${downloadUrl} to ${targetFilePath}`);
    if (progressCb) {
      progressCb(0);
    }
    const {sha256, zippedSha256} = await downloadZip_1.downloadZip(downloadUrl, targetFilePath, progressCb);
    if (progressCb) {
      progressCb(1);
    }
    if (process.platform !== "win32") {
      chmod_1.default(targetFilePath);
    }
    await saveFileToCache(options, version, sha256, zippedSha256);
  }
  async function saveFileToCache(job, version, sha256, zippedSha256) {
    const cacheDir = await util_2.getCacheDir(channel, version, job.binaryTarget);
    if (!cacheDir) {
      return;
    }
    const cachedTargetPath = path_1.default.join(cacheDir, job.binaryName);
    const cachedSha256Path = path_1.default.join(cacheDir, job.binaryName + ".sha256");
    const cachedSha256ZippedPath = path_1.default.join(cacheDir, job.binaryName + ".gz.sha256");
    try {
      await copyFile(job.targetFilePath, cachedTargetPath);
      await writeFile(cachedSha256Path, sha256);
      await writeFile(cachedSha256ZippedPath, zippedSha256);
    } catch (e) {
      debug(e);
    }
  }
  function engineTypeToBinaryType(engineType, binaryTarget) {
    if (BinaryType[engineType]) {
      return BinaryType[engineType];
    }
    if (engineType === "native") {
      return binaryTarget;
    }
    return engineType;
  }
  function mapKeys(obj, mapper) {
    return Object.entries(obj).reduce((acc, [key, value]) => {
      acc[mapper(key)] = value;
      return acc;
    }, {});
  }
  async function maybeCopyToTmp(file) {
    const dir = eval("__dirname");
    if (dir.startsWith("/snapshot/")) {
      const targetDir = path_1.default.join(temp_dir_1.default, "prisma-binaries");
      await make_dir_1.default(targetDir);
      const target = path_1.default.join(targetDir, path_1.default.basename(file));
      const data = await readFile(file);
      await writeFile(target, data);
      plusX(target);
      return target;
    }
    return file;
  }
  exports.maybeCopyToTmp = maybeCopyToTmp;
  function plusX(file) {
    const s2 = fs_1.default.statSync(file);
    const newMode = s2.mode | 64 | 8 | 1;
    if (s2.mode === newMode) {
      return;
    }
    const base8 = newMode.toString(8).slice(-3);
    fs_1.default.chmodSync(file, base8);
  }
  exports.plusX = plusX;
});

// ../../node_modules/.pnpm/@prisma+fetch-engine@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/fetch-engine/dist/index.js
var require_dist15 = __commonJS2((exports2) => {
  "use strict";
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, {enumerable: true, get: function() {
      return m2[k];
    }});
  } : function(o, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m2[k];
  });
  var __exportStar3 = exports2 && exports2.__exportStar || function(m2, exports3) {
    for (var p in m2)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m2, p);
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getProxyAgent = exports2.urlExists = exports2.getLatestTag = exports2.getAllUrls = void 0;
  __exportStar3(require_download2(), exports2);
  var getLatestTag_12 = require_getLatestTag2();
  Object.defineProperty(exports2, "getAllUrls", {enumerable: true, get: function() {
    return getLatestTag_12.getAllUrls;
  }});
  Object.defineProperty(exports2, "getLatestTag", {enumerable: true, get: function() {
    return getLatestTag_12.getLatestTag;
  }});
  Object.defineProperty(exports2, "urlExists", {enumerable: true, get: function() {
    return getLatestTag_12.urlExists;
  }});
  var getProxyAgent_1 = require_getProxyAgent2();
  Object.defineProperty(exports2, "getProxyAgent", {enumerable: true, get: function() {
    return getProxyAgent_1.getProxyAgent;
  }});
});

// ../engine-core/dist/common/errors/PrismaClientInitializationError.js
var require_PrismaClientInitializationError = __commonJS2((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    PrismaClientInitializationError: () => PrismaClientInitializationError2
  });
  var PrismaClientInitializationError2 = class extends Error {
    constructor(message, clientVersion2, errorCode) {
      super(message);
      this.clientVersion = clientVersion2;
      this.errorCode = errorCode;
      Error.captureStackTrace(PrismaClientInitializationError2);
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientInitializationError";
    }
  };
});

// ../engine-core/dist/common/errors/PrismaClientKnownRequestError.js
var require_PrismaClientKnownRequestError = __commonJS2((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    PrismaClientKnownRequestError: () => PrismaClientKnownRequestError2
  });
  var PrismaClientKnownRequestError2 = class extends Error {
    constructor(message, code, clientVersion2, meta) {
      super(message);
      this.code = code;
      this.clientVersion = clientVersion2;
      this.meta = meta;
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientKnownRequestError";
    }
  };
});

// ../engine-core/dist/common/errors/PrismaClientRustPanicError.js
var require_PrismaClientRustPanicError = __commonJS2((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    PrismaClientRustPanicError: () => PrismaClientRustPanicError2
  });
  var PrismaClientRustPanicError2 = class extends Error {
    constructor(message, clientVersion2) {
      super(message);
      this.clientVersion = clientVersion2;
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientRustPanicError";
    }
  };
});

// ../engine-core/dist/common/errors/PrismaClientUnknownRequestError.js
var require_PrismaClientUnknownRequestError = __commonJS2((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    PrismaClientUnknownRequestError: () => PrismaClientUnknownRequestError2
  });
  var PrismaClientUnknownRequestError2 = class extends Error {
    constructor(message, clientVersion2) {
      super(message);
      this.clientVersion = clientVersion2;
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientUnknownRequestError";
    }
  };
});

// ../engine-core/dist/common/Engine.js
var require_Engine = __commonJS2((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    Engine: () => Engine2
  });
  var Engine2 = class {
  };
});

// ../../node_modules/.pnpm/@prisma+engines@2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20/node_modules/@prisma/engines/dist/index.js
var require_dist16 = __commonJS2((exports, module) => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
  var __commonJS = (callback, module2) => () => {
    if (!module2) {
      module2 = {exports: {}};
      callback(module2.exports, module2);
    }
    return module2.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, {get: all[name], enumerable: true});
  };
  var __exportStar = (target, module2, desc) => {
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
      for (let key of __getOwnPropNames(module2))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule = (module2) => {
    if (module2 && module2.__esModule)
      return module2;
    return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", {value: module2, enumerable: true})), module2);
  };
  var require_ms = __commonJS((exports2, module2) => {
    var s2 = 1e3;
    var m2 = s2 * 60;
    var h2 = m2 * 60;
    var d2 = h2 * 24;
    var w2 = d2 * 7;
    var y2 = d2 * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong2(val) : fmtShort2(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y2;
        case "weeks":
        case "week":
        case "w":
          return n * w2;
        case "days":
        case "day":
        case "d":
          return n * d2;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h2;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m2;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort2(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d2) {
        return Math.round(ms2 / d2) + "d";
      }
      if (msAbs >= h2) {
        return Math.round(ms2 / h2) + "h";
      }
      if (msAbs >= m2) {
        return Math.round(ms2 / m2) + "m";
      }
      if (msAbs >= s2) {
        return Math.round(ms2 / s2) + "s";
      }
      return ms2 + "ms";
    }
    function fmtLong2(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d2) {
        return plural2(ms2, msAbs, d2, "day");
      }
      if (msAbs >= h2) {
        return plural2(ms2, msAbs, h2, "hour");
      }
      if (msAbs >= m2) {
        return plural2(ms2, msAbs, m2, "minute");
      }
      if (msAbs >= s2) {
        return plural2(ms2, msAbs, s2, "second");
      }
      return ms2 + " ms";
    }
    function plural2(ms2, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
    }
  });
  var require_common = __commonJS((exports2, module2) => {
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key) => {
        createDebug[key] = env2[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug32(...args) {
          if (!debug32.enabled) {
            return;
          }
          const self2 = debug32;
          const curr = Number(new Date());
          const ms2 = curr - (prevTime || curr);
          self2.diff = ms2;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format2];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug32.namespace = namespace;
        debug32.useColors = createDebug.useColors();
        debug32.color = createDebug.selectColor(namespace);
        debug32.extend = extend;
        debug32.destroy = createDebug.destroy;
        Object.defineProperty(debug32, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug32);
        }
        return debug32;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  });
  var require_browser = __commonJS((exports2, module2) => {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load2;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load2() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var {formatters} = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  });
  var require_has_flag = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  });
  var require_supports_color = __commonJS((exports2, module2) => {
    "use strict";
    var os2 = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var {env: env2} = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env2) {
      if (env2.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env2.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env2.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env2.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min2 = forceColor || 0;
      if (env2.TERM === "dumb") {
        return min2;
      }
      if (process.platform === "win32") {
        const osRelease = os2.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env2) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign2) => sign2 in env2) || env2.CI_NAME === "codeship") {
          return 1;
        }
        return min2;
      }
      if ("TEAMCITY_VERSION" in env2) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env2.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env2) {
        const version = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env2.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env2.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env2) {
        return 1;
      }
      return min2;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  });
  var require_node = __commonJS((exports2, module2) => {
    var tty = require("tty");
    var util2 = require("util");
    exports2.init = init;
    exports2.log = log3;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load2;
    exports2.useColors = useColors;
    exports2.destroy = util2.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_2, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const {namespace: name, useColors: useColors2} = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} [0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log3(...args) {
      return process.stderr.write(util2.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load2() {
      return process.env.DEBUG;
    }
    function init(debug32) {
      debug32.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug32.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports2);
    var {formatters} = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  });
  var require_src = __commonJS((exports2, module2) => {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  });
  var require_common2 = __commonJS((exports2) => {
    var __defProp22 = Object.defineProperty;
    var __markAsModule22 = (target) => __defProp22(target, "__esModule", {value: true});
    var __export22 = (target, all) => {
      __markAsModule22(target);
      for (var name in all)
        __defProp22(target, name, {get: all[name], enumerable: true});
    };
    __export22(exports2, {
      setup: () => setup
    });
    function setup(env2) {
      const createDebug = (namespace, logger2) => {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        const debug32 = (...args) => {
          const self2 = debug32;
          const curr = Number(new Date());
          const ms2 = curr - (prevTime || curr);
          self2.diff = ms2;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format2];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          if (logger2 && typeof logger2 === "function") {
            logger2.apply(self2, args);
          }
          if (debug32.enabled) {
            const logFn = self2.log || createDebug.log;
            logFn.apply(self2, args);
          }
        };
        debug32.namespace = namespace;
        debug32.useColors = createDebug.useColors();
        debug32.color = createDebug.selectColor(namespace);
        debug32.extend = extend;
        debug32.destroy = createDebug.destroy;
        Object.defineProperty(debug32, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug32);
        }
        return debug32;
      };
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key) => {
        createDebug[key] = env2[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
  });
  var require_node2 = __commonJS((exports2, module2) => {
    var __create22 = Object.create;
    var __defProp22 = Object.defineProperty;
    var __getOwnPropDesc22 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames22 = Object.getOwnPropertyNames;
    var __getProtoOf22 = Object.getPrototypeOf;
    var __hasOwnProp22 = Object.prototype.hasOwnProperty;
    var __markAsModule22 = (target) => __defProp22(target, "__esModule", {value: true});
    var __export22 = (target, all) => {
      __markAsModule22(target);
      for (var name in all)
        __defProp22(target, name, {get: all[name], enumerable: true});
    };
    var __reExport2 = (target, module22, desc) => {
      if (module22 && typeof module22 === "object" || typeof module22 === "function") {
        for (let key of __getOwnPropNames22(module22))
          if (!__hasOwnProp22.call(target, key) && key !== "default")
            __defProp22(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc22(module22, key)) || desc.enumerable});
      }
      return target;
    };
    var __toModule22 = (module22) => {
      return __reExport2(__markAsModule22(__defProp22(module22 != null ? __create22(__getProtoOf22(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
    };
    __export22(exports2, {
      default: () => node_default
    });
    var import_common10 = __toModule22(require_common2());
    var tty = require("tty");
    var util2 = require("util");
    exports2.init = init;
    exports2.log = log3;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load2;
    exports2.useColors = useColors;
    exports2.destroy = util2.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_2, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const {namespace: name, useColors: useColors2} = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} [0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log3(...args) {
      return process.stderr.write(util2.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load2() {
      return process.env.DEBUG;
    }
    function init(debug32) {
      debug32.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug32.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    var mod2 = (0, import_common10.setup)(exports2);
    module2.exports = mod2;
    var node_default = mod2;
    var {formatters} = mod2;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  });
  var require_dist = __commonJS((exports2) => {
    var __create22 = Object.create;
    var __defProp22 = Object.defineProperty;
    var __getOwnPropDesc22 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames22 = Object.getOwnPropertyNames;
    var __getProtoOf22 = Object.getPrototypeOf;
    var __hasOwnProp22 = Object.prototype.hasOwnProperty;
    var __markAsModule22 = (target) => __defProp22(target, "__esModule", {value: true});
    var __export22 = (target, all) => {
      __markAsModule22(target);
      for (var name in all)
        __defProp22(target, name, {get: all[name], enumerable: true});
    };
    var __reExport2 = (target, module22, desc) => {
      if (module22 && typeof module22 === "object" || typeof module22 === "function") {
        for (let key of __getOwnPropNames22(module22))
          if (!__hasOwnProp22.call(target, key) && key !== "default")
            __defProp22(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc22(module22, key)) || desc.enumerable});
      }
      return target;
    };
    var __toModule22 = (module22) => {
      return __reExport2(__markAsModule22(__defProp22(module22 != null ? __create22(__getProtoOf22(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
    };
    __export22(exports2, {
      Debug: () => Debug2,
      default: () => Debug2,
      getLogs: () => getLogs
    });
    var import_debug22 = __toModule22(require_src());
    var import_node = __toModule22(require_node2());
    var cache = [];
    var MAX_LOGS = 100;
    function Debug2(namespace) {
      const debug32 = (0, import_node.default)(namespace, (...args) => {
        cache.push(args);
        if (cache.length > MAX_LOGS) {
          cache.shift();
        }
      });
      return debug32;
    }
    Debug2.enable = (namespace) => {
      import_node.default.enable(namespace);
    };
    Debug2.enabled = (namespace) => import_node.default.enabled(namespace);
    function getLogs(numChars = 7500) {
      const output = cache.map((c) => c.map((item) => {
        if (typeof item === "string") {
          return item;
        }
        return JSON.stringify(item);
      }).join("  ")).join("\n");
      if (output.length < numChars) {
        return output;
      }
      return output.slice(-numChars);
    }
  });
  var require_package = __commonJS((exports2, module2) => {
    module2.exports = {
      name: "@prisma/engines-version",
      version: "2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20",
      main: "index.js",
      types: "index.d.ts",
      license: "Apache-2.0",
      author: "Tim Suchanek <suchanek@prisma.io>",
      prisma: {
        enginesVersion: "b8c35d44de987a9691890b3ddf3e2e7effb9bf20"
      },
      devDependencies: {
        "@types/node": "14.17.11",
        typescript: "4.3.5"
      },
      scripts: {
        build: "tsc -d",
        prepublishOnly: "tsc -d",
        publish: "echo $GITHUB_CONTEXT"
      },
      files: [
        "index.js",
        "index.d.ts"
      ]
    };
  });
  var require_engines_version = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.enginesVersion = void 0;
    exports2.enginesVersion = require_package().prisma.enginesVersion;
  });
  var require_getNodeAPIName = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.getNodeAPIName = void 0;
    var NODE_API_QUERY_ENGINE_URL_BASE = "libquery_engine";
    function getNodeAPIName3(platform, type) {
      const isUrl = type === "url";
      if (platform.includes("windows")) {
        return isUrl ? `query_engine.dll.node` : `query_engine-${platform}.dll.node`;
      } else if (platform.includes("linux") || platform.includes("debian") || platform.includes("rhel")) {
        return isUrl ? `${NODE_API_QUERY_ENGINE_URL_BASE}.so.node` : `${NODE_API_QUERY_ENGINE_URL_BASE}-${platform}.so.node`;
      } else if (platform.includes("darwin")) {
        return isUrl ? `${NODE_API_QUERY_ENGINE_URL_BASE}.dylib.node` : `${NODE_API_QUERY_ENGINE_URL_BASE}-${platform}.dylib.node`;
      } else {
        throw new Error(`Node API is currently not supported on your platform: ${platform}`);
      }
    }
    exports2.getNodeAPIName = getNodeAPIName3;
  });
  var require_getPlatform = __commonJS((exports2) => {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : {default: mod2};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.getPlatform = exports2.getOpenSSLVersion = exports2.parseOpenSSLVersion = exports2.resolveDistro = exports2.parseDistro = exports2.getos = void 0;
    var child_process_1 = require("child_process");
    var fs_12 = __importDefault2(require("fs"));
    var os_1 = __importDefault2(require("os"));
    var util_12 = require("util");
    var readFile2 = util_12.promisify(fs_12.default.readFile);
    var exists2 = util_12.promisify(fs_12.default.exists);
    async function getos() {
      const platform = os_1.default.platform();
      const arch = process.arch;
      if (platform === "freebsd") {
        const version = await gracefulExec(`freebsd-version`);
        if (version && version.trim().length > 0) {
          const regex = /^(\d+)\.?/;
          const match = regex.exec(version);
          if (match) {
            return {
              platform: "freebsd",
              distro: `freebsd${match[1]}`,
              arch
            };
          }
        }
      }
      if (platform !== "linux") {
        return {
          platform,
          arch
        };
      }
      return {
        platform: "linux",
        libssl: await getOpenSSLVersion(),
        distro: await resolveDistro(),
        arch
      };
    }
    exports2.getos = getos;
    function parseDistro(input) {
      const idRegex = /^ID="?([^"\n]*)"?$/im;
      const idLikeRegex = /^ID_LIKE="?([^"\n]*)"?$/im;
      const idMatch = idRegex.exec(input);
      const id = idMatch && idMatch[1] && idMatch[1].toLowerCase() || "";
      const idLikeMatch = idLikeRegex.exec(input);
      const idLike = idLikeMatch && idLikeMatch[1] && idLikeMatch[1].toLowerCase() || "";
      if (id === "raspbian") {
        return "arm";
      }
      if (id === "nixos") {
        return "nixos";
      }
      if (idLike.includes("centos") || idLike.includes("fedora") || idLike.includes("rhel") || id === "fedora") {
        return "rhel";
      }
      if (idLike.includes("debian") || idLike.includes("ubuntu") || id === "debian") {
        return "debian";
      }
      return;
    }
    exports2.parseDistro = parseDistro;
    async function resolveDistro() {
      const osReleaseFile = "/etc/os-release";
      const alpineReleaseFile = "/etc/alpine-release";
      if (await exists2(alpineReleaseFile)) {
        return "musl";
      } else if (await exists2(osReleaseFile)) {
        return parseDistro(await readFile2(osReleaseFile, "utf-8"));
      } else {
        return;
      }
    }
    exports2.resolveDistro = resolveDistro;
    function parseOpenSSLVersion(input) {
      const match = /^OpenSSL\s(\d+\.\d+)\.\d+/.exec(input);
      if (match) {
        return match[1] + ".x";
      }
      return;
    }
    exports2.parseOpenSSLVersion = parseOpenSSLVersion;
    async function getOpenSSLVersion() {
      const [version, ls] = await Promise.all([
        gracefulExec(`openssl version -v`),
        gracefulExec(`
      ls -l /lib64 | grep ssl;
      ls -l /usr/lib64 | grep ssl;
    `)
      ]);
      if (version) {
        const v = parseOpenSSLVersion(version);
        if (v) {
          return v;
        }
      }
      if (ls) {
        const match = /libssl\.so\.(\d+\.\d+)\.\d+/.exec(ls);
        if (match) {
          return match[1] + ".x";
        }
      }
      return void 0;
    }
    exports2.getOpenSSLVersion = getOpenSSLVersion;
    async function gracefulExec(cmd) {
      return new Promise((resolve) => {
        try {
          child_process_1.exec(cmd, (err, stdout) => {
            resolve(String(stdout));
          });
        } catch (e) {
          resolve(void 0);
          return void 0;
        }
      });
    }
    async function getPlatform2() {
      const {platform, libssl, distro, arch} = await getos();
      if (platform === "darwin" && arch === "arm64") {
        return "darwin-arm64";
      }
      if (platform === "darwin") {
        return "darwin";
      }
      if (platform === "win32") {
        return "windows";
      }
      if (platform === "freebsd") {
        return distro;
      }
      if (platform === "openbsd") {
        return "openbsd";
      }
      if (platform === "netbsd") {
        return "netbsd";
      }
      if (platform === "linux" && arch === "arm64") {
        return `linux-arm-openssl-${libssl}`;
      }
      if (platform === "linux" && distro === "nixos") {
        return "linux-nixos";
      }
      if (platform === "linux" && distro === "musl") {
        return "linux-musl";
      }
      if (platform === "linux" && distro && libssl) {
        return distro + "-openssl-" + libssl;
      }
      if (libssl) {
        return "debian-openssl-" + libssl;
      }
      if (distro) {
        return distro + "-openssl-1.1.x";
      }
      return "debian-openssl-1.1.x";
    }
    exports2.getPlatform = getPlatform2;
  });
  var require_isNodeAPISupported = __commonJS((exports2) => {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : {default: mod2};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.isNodeAPISupported = void 0;
    var fs_12 = __importDefault2(require("fs"));
    var _1 = require_dist2();
    async function isNodeAPISupported() {
      const customLibraryPath = process.env.PRISMA_QUERY_ENGINE_LIBRARY;
      const customLibraryExists = customLibraryPath && fs_12.default.existsSync(customLibraryPath);
      const os2 = await _1.getos();
      if (!customLibraryExists && (os2.arch === "x32" || os2.arch === "ia32")) {
        throw new Error(`Node-API is currently not supported for 32bit Node. Please remove \`nApi\` from the "previewFeatures" attribute in the "generator" block of the "schema.prisma", or remove the "PRISMA_FORCE_NAPI" environment variable.`);
      }
    }
    exports2.isNodeAPISupported = isNodeAPISupported;
  });
  var require_platforms = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.platforms = void 0;
    exports2.platforms = [
      "darwin",
      "darwin-arm64",
      "debian-openssl-1.0.x",
      "debian-openssl-1.1.x",
      "rhel-openssl-1.0.x",
      "rhel-openssl-1.1.x",
      "linux-arm-openssl-1.1.x",
      "linux-arm-openssl-1.0.x",
      "linux-musl",
      "linux-nixos",
      "windows",
      "freebsd11",
      "freebsd12",
      "openbsd",
      "netbsd",
      "arm"
    ];
  });
  var require_dist2 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.platforms = exports2.isNodeAPISupported = exports2.getPlatform = exports2.getos = exports2.getNodeAPIName = void 0;
    var getNodeAPIName_1 = require_getNodeAPIName();
    Object.defineProperty(exports2, "getNodeAPIName", {enumerable: true, get: function() {
      return getNodeAPIName_1.getNodeAPIName;
    }});
    var getPlatform_1 = require_getPlatform();
    Object.defineProperty(exports2, "getos", {enumerable: true, get: function() {
      return getPlatform_1.getos;
    }});
    Object.defineProperty(exports2, "getPlatform", {enumerable: true, get: function() {
      return getPlatform_1.getPlatform;
    }});
    var isNodeAPISupported_1 = require_isNodeAPISupported();
    Object.defineProperty(exports2, "isNodeAPISupported", {enumerable: true, get: function() {
      return isNodeAPISupported_1.isNodeAPISupported;
    }});
    var platforms_1 = require_platforms();
    Object.defineProperty(exports2, "platforms", {enumerable: true, get: function() {
      return platforms_1.platforms;
    }});
  });
  var require_color_name = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 134, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 250, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 221],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [112, 128, 144],
      slategrey: [112, 128, 144],
      snow: [255, 250, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 50]
    };
  });
  var require_conversions = __commonJS((exports2, module2) => {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: {channels: 3, labels: "rgb"},
      hsl: {channels: 3, labels: "hsl"},
      hsv: {channels: 3, labels: "hsv"},
      hwb: {channels: 3, labels: "hwb"},
      cmyk: {channels: 4, labels: "cmyk"},
      xyz: {channels: 3, labels: "xyz"},
      lab: {channels: 3, labels: "lab"},
      lch: {channels: 3, labels: "lch"},
      hex: {channels: 1, labels: ["hex"]},
      keyword: {channels: 1, labels: ["keyword"]},
      ansi16: {channels: 1, labels: ["ansi16"]},
      ansi256: {channels: 1, labels: ["ansi256"]},
      hcg: {channels: 3, labels: ["h", "c", "g"]},
      apple: {channels: 3, labels: ["r16", "g16", "b16"]},
      gray: {channels: 1, labels: ["gray"]}
    };
    module2.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const {channels, labels} = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", {value: channels});
      Object.defineProperty(convert[model], "labels", {value: labels});
    }
    convert.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min2 = Math.min(r, g, b);
      const max2 = Math.max(r, g, b);
      const delta = max2 - min2;
      let h2;
      let s2;
      if (max2 === min2) {
        h2 = 0;
      } else if (r === max2) {
        h2 = (g - b) / delta;
      } else if (g === max2) {
        h2 = 2 + (b - r) / delta;
      } else if (b === max2) {
        h2 = 4 + (r - g) / delta;
      }
      h2 = Math.min(h2 * 60, 360);
      if (h2 < 0) {
        h2 += 360;
      }
      const l = (min2 + max2) / 2;
      if (max2 === min2) {
        s2 = 0;
      } else if (l <= 0.5) {
        s2 = delta / (max2 + min2);
      } else {
        s2 = delta / (2 - max2 - min2);
      }
      return [h2, s2 * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h2;
      let s2;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff = v - Math.min(r, g, b);
      const diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h2 = 0;
        s2 = 0;
      } else {
        s2 = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h2 = bdif - gdif;
        } else if (g === v) {
          h2 = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h2 = 2 / 3 + gdif - rdif;
        }
        if (h2 < 0) {
          h2 += 1;
        } else if (h2 > 1) {
          h2 -= 1;
        }
      }
      return [
        h2 * 360,
        s2 * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h2 = convert.rgb.hsl(rgb)[0];
      const w2 = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h2, w2 * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m2 = (1 - g - k) / (1 - k) || 0;
      const y2 = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m2 * 100, y2 * 100, k * 100];
    };
    function comparativeDistance(x, y2) {
      return (x[0] - y2[0]) ** 2 + (x[1] - y2[1]) ** 2 + (x[2] - y2[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y2 = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y2 * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x = xyz[0];
      let y2 = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y2 /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y2 = y2 > 8856e-6 ? y2 ** (1 / 3) : 7.787 * y2 + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y2 - 16;
      const a = 500 * (x - y2);
      const b = 200 * (y2 - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      const h2 = hsl[0] / 360;
      const s2 = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s2 === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s2);
      } else {
        t2 = l + s2 - l * s2;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h2 + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h2 = hsl[0];
      let s2 = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s2;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s2 *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s2) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s2 / (l + s2);
      return [h2, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h2 = hsv[0] / 60;
      const s2 = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h2) % 6;
      const f = h2 - Math.floor(h2);
      const p = 255 * v * (1 - s2);
      const q = 255 * v * (1 - s2 * f);
      const t = 255 * v * (1 - s2 * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h2 = hsv[0];
      const s2 = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s2) * v;
      const lmin = (2 - s2) * vmin;
      sl = s2 * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h2, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h2 = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h2);
      const v = 1 - bl;
      f = 6 * h2 - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m2 = cmyk[1] / 100;
      const y2 = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m2 * (1 - k) + k);
      const b = 1 - Math.min(1, y2 * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y2 = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y2 * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y2 * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y2 * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y2 = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y2 /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y2 = y2 > 8856e-6 ? y2 ** (1 / 3) : 7.787 * y2 + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y2 - 16;
      const a = 500 * (x - y2);
      const b = 200 * (y2 - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y2;
      let z;
      y2 = (l + 16) / 116;
      x = a / 500 + y2;
      z = y2 - b / 200;
      const y22 = y2 ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y2 = y22 > 8856e-6 ? y22 : (y2 - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y2 *= 100;
      z *= 108.883;
      return [x, y2, z];
    };
    convert.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h2;
      const hr = Math.atan2(b, a);
      h2 = hr * 360 / 2 / Math.PI;
      if (h2 < 0) {
        h2 += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h2];
    };
    convert.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h2 = lch[2];
      const hr = h2 / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max2 = Math.max(Math.max(r, g), b);
      const min2 = Math.min(Math.min(r, g), b);
      const chroma = max2 - min2;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min2 / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max2 === r) {
        hue = (g - b) / chroma % 6;
      } else if (max2 === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s2 = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s2 * l : 2 * s2 * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s2 = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s2 * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h2 = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h2 % 1 * 6;
      const v = hi % 1;
      const w2 = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w2;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w2;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w2;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s2 = 0;
      if (l > 0 && l < 0.5) {
        s2 = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s2 = c / (2 * (1 - l));
      }
      return [hcg[0], s2 * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w2 = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w2;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  });
  var require_route = __commonJS((exports2, module2) => {
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link2(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path22 = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path22.unshift(graph[cur].parent);
        fn = link2(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path22;
      return fn;
    }
    module2.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i = 0; i < len; i++) {
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  });
  var require_color_convert = __commonJS((exports2, module2) => {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", {value: conversions[fromModel].channels});
      Object.defineProperty(convert[fromModel], "labels", {value: conversions[fromModel].labels});
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  });
  var require_ansi_styles = __commonJS((exports2, module2) => {
    "use strict";
    var wrapAnsi16 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    var ansi2ansi = (n) => n;
    var rgb2rgb = (r, g, b) => [r, g, b];
    var setLazyProperty = (object, property, get) => {
      Object.defineProperty(object, property, {
        get: () => {
          const value = get();
          Object.defineProperty(object, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    var colorConvert;
    var makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert();
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name] = wrap(identity, offset);
        } else if (typeof suite === "object") {
          styles[name] = wrap(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes = new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `[${style[0]}m`,
            close: `[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "[39m";
      styles.bgColor.close = "[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  });
  var require_util = __commonJS((exports2, module2) => {
    "use strict";
    var stringReplaceAll = (string, substring, replacer) => {
      let index = string.indexOf(substring);
      if (index === -1) {
        return string;
      }
      const substringLength = substring.length;
      let endIndex = 0;
      let returnValue = "";
      do {
        returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
        endIndex = index + substringLength;
        index = string.indexOf(substring, endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    var stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
      let endIndex = 0;
      let returnValue = "";
      do {
        const gotCR = string[index - 1] === "\r";
        returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
        endIndex = index + 1;
        index = string.indexOf("\n", endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    module2.exports = {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    };
  });
  var require_templates = __commonJS((exports2, module2) => {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", ""],
      ["a", "\x07"]
    ]);
    function unescape(c) {
      const u = c[0] === "u";
      const bracket = c[1] === "{";
      if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      if (u && bracket) {
        return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name, arguments_) {
      const results = [];
      const chunks = arguments_.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        const number = Number(chunk);
        if (!Number.isNaN(number)) {
          results.push(number);
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m2, escape, character) => escape ? unescape(escape) : character));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk3, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk3;
      for (const [styleName, styles2] of Object.entries(enabled)) {
        if (!Array.isArray(styles2)) {
          continue;
        }
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
      }
      return current;
    }
    module2.exports = (chalk3, temporary) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      temporary.replace(TEMPLATE_REGEX, (m2, escapeCharacter, inverse, style, close2, character) => {
        if (escapeCharacter) {
          chunk.push(unescape(escapeCharacter));
        } else if (style) {
          const string = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? string : buildStyle(chalk3, styles)(string));
          styles.push({inverse, styles: parseStyle(style)});
        } else if (close2) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk3, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(character);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMessage);
      }
      return chunks.join("");
    };
  });
  var require_source = __commonJS((exports2, module2) => {
    "use strict";
    var ansiStyles = require_ansi_styles();
    var {stdout: stdoutColor, stderr: stderrColor} = require_supports_color();
    var {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    } = require_util();
    var {isArray} = Array;
    var levelMapping = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    var styles = Object.create(null);
    var applyOptions = (object, options = {}) => {
      if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      const colorLevel = stdoutColor ? stdoutColor.level : 0;
      object.level = options.level === void 0 ? colorLevel : options.level;
    };
    var ChalkClass = class {
      constructor(options) {
        return chalkFactory(options);
      }
    };
    var chalkFactory = (options) => {
      const chalk22 = {};
      applyOptions(chalk22, options);
      chalk22.template = (...arguments_) => chalkTag(chalk22.template, ...arguments_);
      Object.setPrototypeOf(chalk22, Chalk.prototype);
      Object.setPrototypeOf(chalk22.template, chalk22);
      chalk22.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      };
      chalk22.template.Instance = ChalkClass;
      return chalk22.template;
    };
    function Chalk(options) {
      return chalkFactory(options);
    }
    for (const [styleName, style] of Object.entries(ansiStyles)) {
      styles[styleName] = {
        get() {
          const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
          Object.defineProperty(this, styleName, {value: builder});
          return builder;
        }
      };
    }
    styles.visible = {
      get() {
        const builder = createBuilder(this, this._styler, true);
        Object.defineProperty(this, "visible", {value: builder});
        return builder;
      }
    };
    var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
    for (const model of usedModels) {
      styles[model] = {
        get() {
          const {level} = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    for (const model of usedModels) {
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const {level} = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, {
      ...styles,
      level: {
        enumerable: true,
        get() {
          return this._generator.level;
        },
        set(level) {
          this._generator.level = level;
        }
      }
    });
    var createStyler = (open2, close2, parent) => {
      let openAll;
      let closeAll;
      if (parent === void 0) {
        openAll = open2;
        closeAll = close2;
      } else {
        openAll = parent.openAll + open2;
        closeAll = close2 + parent.closeAll;
      }
      return {
        open: open2,
        close: close2,
        openAll,
        closeAll,
        parent
      };
    };
    var createBuilder = (self2, _styler, _isEmpty) => {
      const builder = (...arguments_) => {
        if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
          return applyStyle(builder, chalkTag(builder, ...arguments_));
        }
        return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      };
      Object.setPrototypeOf(builder, proto);
      builder._generator = self2;
      builder._styler = _styler;
      builder._isEmpty = _isEmpty;
      return builder;
    };
    var applyStyle = (self2, string) => {
      if (self2.level <= 0 || !string) {
        return self2._isEmpty ? "" : string;
      }
      let styler = self2._styler;
      if (styler === void 0) {
        return string;
      }
      const {openAll, closeAll} = styler;
      if (string.indexOf("") !== -1) {
        while (styler !== void 0) {
          string = stringReplaceAll(string, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      const lfIndex = string.indexOf("\n");
      if (lfIndex !== -1) {
        string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
      }
      return openAll + string + closeAll;
    };
    var template;
    var chalkTag = (chalk22, ...strings) => {
      const [firstString] = strings;
      if (!isArray(firstString) || !isArray(firstString.raw)) {
        return strings.join(" ");
      }
      const arguments_ = strings.slice(1);
      const parts = [firstString.raw[0]];
      for (let i = 1; i < firstString.length; i++) {
        parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i]));
      }
      if (template === void 0) {
        template = require_templates();
      }
      return template(chalk22, parts.join(""));
    };
    Object.defineProperties(Chalk.prototype, styles);
    var chalk3 = Chalk();
    chalk3.supportsColor = stdoutColor;
    chalk3.stderr = Chalk({level: stderrColor ? stderrColor.level : 0});
    chalk3.stderr.supportsColor = stderrColor;
    module2.exports = chalk3;
  });
  var require_windows = __commonJS((exports2, module2) => {
    module2.exports = isexe;
    isexe.sync = sync2;
    var fs2 = require("fs");
    function checkPathExt(path22, options) {
      var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
      if (!pathext) {
        return true;
      }
      pathext = pathext.split(";");
      if (pathext.indexOf("") !== -1) {
        return true;
      }
      for (var i = 0; i < pathext.length; i++) {
        var p = pathext[i].toLowerCase();
        if (p && path22.substr(-p.length).toLowerCase() === p) {
          return true;
        }
      }
      return false;
    }
    function checkStat(stat2, path22, options) {
      if (!stat2.isSymbolicLink() && !stat2.isFile()) {
        return false;
      }
      return checkPathExt(path22, options);
    }
    function isexe(path22, options, cb) {
      fs2.stat(path22, function(er, stat2) {
        cb(er, er ? false : checkStat(stat2, path22, options));
      });
    }
    function sync2(path22, options) {
      return checkStat(fs2.statSync(path22), path22, options);
    }
  });
  var require_mode = __commonJS((exports2, module2) => {
    module2.exports = isexe;
    isexe.sync = sync2;
    var fs2 = require("fs");
    function isexe(path22, options, cb) {
      fs2.stat(path22, function(er, stat2) {
        cb(er, er ? false : checkStat(stat2, options));
      });
    }
    function sync2(path22, options) {
      return checkStat(fs2.statSync(path22), options);
    }
    function checkStat(stat2, options) {
      return stat2.isFile() && checkMode(stat2, options);
    }
    function checkMode(stat2, options) {
      var mod2 = stat2.mode;
      var uid = stat2.uid;
      var gid = stat2.gid;
      var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
      var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
      var u = parseInt("100", 8);
      var g = parseInt("010", 8);
      var o = parseInt("001", 8);
      var ug = u | g;
      var ret = mod2 & o || mod2 & g && gid === myGid || mod2 & u && uid === myUid || mod2 & ug && myUid === 0;
      return ret;
    }
  });
  var require_isexe = __commonJS((exports2, module2) => {
    var fs2 = require("fs");
    var core;
    if (process.platform === "win32" || global.TESTING_WINDOWS) {
      core = require_windows();
    } else {
      core = require_mode();
    }
    module2.exports = isexe;
    isexe.sync = sync2;
    function isexe(path22, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (!cb) {
        if (typeof Promise !== "function") {
          throw new TypeError("callback not provided");
        }
        return new Promise(function(resolve, reject) {
          isexe(path22, options || {}, function(er, is) {
            if (er) {
              reject(er);
            } else {
              resolve(is);
            }
          });
        });
      }
      core(path22, options || {}, function(er, is) {
        if (er) {
          if (er.code === "EACCES" || options && options.ignoreErrors) {
            er = null;
            is = false;
          }
        }
        cb(er, is);
      });
    }
    function sync2(path22, options) {
      try {
        return core.sync(path22, options || {});
      } catch (er) {
        if (options && options.ignoreErrors || er.code === "EACCES") {
          return false;
        } else {
          throw er;
        }
      }
    }
  });
  var require_which = __commonJS((exports2, module2) => {
    var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
    var path22 = require("path");
    var COLON = isWindows ? ";" : ":";
    var isexe = require_isexe();
    var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), {code: "ENOENT"});
    var getPathInfo = (cmd, opt) => {
      const colon = opt.colon || COLON;
      const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
        ...isWindows ? [process.cwd()] : [],
        ...(opt.path || process.env.PATH || "").split(colon)
      ];
      const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
      const pathExt = isWindows ? pathExtExe.split(colon) : [""];
      if (isWindows) {
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
          pathExt.unshift("");
      }
      return {
        pathEnv,
        pathExt,
        pathExtExe
      };
    };
    var which = (cmd, opt, cb) => {
      if (typeof opt === "function") {
        cb = opt;
        opt = {};
      }
      if (!opt)
        opt = {};
      const {pathEnv, pathExt, pathExtExe} = getPathInfo(cmd, opt);
      const found = [];
      const step = (i) => new Promise((resolve, reject) => {
        if (i === pathEnv.length)
          return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path22.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        resolve(subStep(p, i, 0));
      });
      const subStep = (p, i, ii) => new Promise((resolve, reject) => {
        if (ii === pathExt.length)
          return resolve(step(i + 1));
        const ext = pathExt[ii];
        isexe(p + ext, {pathExt: pathExtExe}, (er, is) => {
          if (!er && is) {
            if (opt.all)
              found.push(p + ext);
            else
              return resolve(p + ext);
          }
          return resolve(subStep(p, i, ii + 1));
        });
      });
      return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
    };
    var whichSync = (cmd, opt) => {
      opt = opt || {};
      const {pathEnv, pathExt, pathExtExe} = getPathInfo(cmd, opt);
      const found = [];
      for (let i = 0; i < pathEnv.length; i++) {
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path22.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for (let j = 0; j < pathExt.length; j++) {
          const cur = p + pathExt[j];
          try {
            const is = isexe.sync(cur, {pathExt: pathExtExe});
            if (is) {
              if (opt.all)
                found.push(cur);
              else
                return cur;
            }
          } catch (ex) {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    };
    module2.exports = which;
    which.sync = whichSync;
  });
  var require_path_key = __commonJS((exports2, module2) => {
    "use strict";
    var pathKey = (options = {}) => {
      const environment = options.env || process.env;
      const platform = options.platform || process.platform;
      if (platform !== "win32") {
        return "PATH";
      }
      return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
    };
    module2.exports = pathKey;
    module2.exports.default = pathKey;
  });
  var require_resolveCommand = __commonJS((exports2, module2) => {
    "use strict";
    var path22 = require("path");
    var which = require_which();
    var getPathKey = require_path_key();
    function resolveCommandAttempt(parsed, withoutPathExt) {
      const env2 = parsed.options.env || process.env;
      const cwd = process.cwd();
      const hasCustomCwd = parsed.options.cwd != null;
      const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
      if (shouldSwitchCwd) {
        try {
          process.chdir(parsed.options.cwd);
        } catch (err) {
        }
      }
      let resolved;
      try {
        resolved = which.sync(parsed.command, {
          path: env2[getPathKey({env: env2})],
          pathExt: withoutPathExt ? path22.delimiter : void 0
        });
      } catch (e) {
      } finally {
        if (shouldSwitchCwd) {
          process.chdir(cwd);
        }
      }
      if (resolved) {
        resolved = path22.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
      }
      return resolved;
    }
    function resolveCommand(parsed) {
      return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
    }
    module2.exports = resolveCommand;
  });
  var require_escape = __commonJS((exports2, module2) => {
    "use strict";
    var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
    function escapeCommand(arg2) {
      arg2 = arg2.replace(metaCharsRegExp, "^$1");
      return arg2;
    }
    function escapeArgument(arg2, doubleEscapeMetaChars) {
      arg2 = `${arg2}`;
      arg2 = arg2.replace(/(\\*)"/g, '$1$1\\"');
      arg2 = arg2.replace(/(\\*)$/, "$1$1");
      arg2 = `"${arg2}"`;
      arg2 = arg2.replace(metaCharsRegExp, "^$1");
      if (doubleEscapeMetaChars) {
        arg2 = arg2.replace(metaCharsRegExp, "^$1");
      }
      return arg2;
    }
    module2.exports.command = escapeCommand;
    module2.exports.argument = escapeArgument;
  });
  var require_shebang_regex = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = /^#!(.*)/;
  });
  var require_shebang_command = __commonJS((exports2, module2) => {
    "use strict";
    var shebangRegex = require_shebang_regex();
    module2.exports = (string = "") => {
      const match = string.match(shebangRegex);
      if (!match) {
        return null;
      }
      const [path22, argument] = match[0].replace(/#! ?/, "").split(" ");
      const binary = path22.split("/").pop();
      if (binary === "env") {
        return argument;
      }
      return argument ? `${binary} ${argument}` : binary;
    };
  });
  var require_readShebang = __commonJS((exports2, module2) => {
    "use strict";
    var fs2 = require("fs");
    var shebangCommand = require_shebang_command();
    function readShebang(command) {
      const size = 150;
      const buffer = Buffer.alloc(size);
      let fd;
      try {
        fd = fs2.openSync(command, "r");
        fs2.readSync(fd, buffer, 0, size, 0);
        fs2.closeSync(fd);
      } catch (e) {
      }
      return shebangCommand(buffer.toString());
    }
    module2.exports = readShebang;
  });
  var require_parse = __commonJS((exports2, module2) => {
    "use strict";
    var path22 = require("path");
    var resolveCommand = require_resolveCommand();
    var escape = require_escape();
    var readShebang = require_readShebang();
    var isWin = process.platform === "win32";
    var isExecutableRegExp = /\.(?:com|exe)$/i;
    var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
    function detectShebang(parsed) {
      parsed.file = resolveCommand(parsed);
      const shebang = parsed.file && readShebang(parsed.file);
      if (shebang) {
        parsed.args.unshift(parsed.file);
        parsed.command = shebang;
        return resolveCommand(parsed);
      }
      return parsed.file;
    }
    function parseNonShell(parsed) {
      if (!isWin) {
        return parsed;
      }
      const commandFile = detectShebang(parsed);
      const needsShell = !isExecutableRegExp.test(commandFile);
      if (parsed.options.forceShell || needsShell) {
        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
        parsed.command = path22.normalize(parsed.command);
        parsed.command = escape.command(parsed.command);
        parsed.args = parsed.args.map((arg2) => escape.argument(arg2, needsDoubleEscapeMetaChars));
        const shellCommand = [parsed.command].concat(parsed.args).join(" ");
        parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
        parsed.command = process.env.comspec || "cmd.exe";
        parsed.options.windowsVerbatimArguments = true;
      }
      return parsed;
    }
    function parse2(command, args, options) {
      if (args && !Array.isArray(args)) {
        options = args;
        args = null;
      }
      args = args ? args.slice(0) : [];
      options = Object.assign({}, options);
      const parsed = {
        command,
        args,
        options,
        file: void 0,
        original: {
          command,
          args
        }
      };
      return options.shell ? parsed : parseNonShell(parsed);
    }
    module2.exports = parse2;
  });
  var require_enoent = __commonJS((exports2, module2) => {
    "use strict";
    var isWin = process.platform === "win32";
    function notFoundError(original, syscall) {
      return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
        code: "ENOENT",
        errno: "ENOENT",
        syscall: `${syscall} ${original.command}`,
        path: original.command,
        spawnargs: original.args
      });
    }
    function hookChildProcess(cp, parsed) {
      if (!isWin) {
        return;
      }
      const originalEmit = cp.emit;
      cp.emit = function(name, arg1) {
        if (name === "exit") {
          const err = verifyENOENT(arg1, parsed, "spawn");
          if (err) {
            return originalEmit.call(cp, "error", err);
          }
        }
        return originalEmit.apply(cp, arguments);
      };
    }
    function verifyENOENT(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawn");
      }
      return null;
    }
    function verifyENOENTSync(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawnSync");
      }
      return null;
    }
    module2.exports = {
      hookChildProcess,
      verifyENOENT,
      verifyENOENTSync,
      notFoundError
    };
  });
  var require_cross_spawn = __commonJS((exports2, module2) => {
    "use strict";
    var cp = require("child_process");
    var parse2 = require_parse();
    var enoent = require_enoent();
    function spawn2(command, args, options) {
      const parsed = parse2(command, args, options);
      const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
      enoent.hookChildProcess(spawned, parsed);
      return spawned;
    }
    function spawnSync(command, args, options) {
      const parsed = parse2(command, args, options);
      const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
      result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
      return result;
    }
    module2.exports = spawn2;
    module2.exports.spawn = spawn2;
    module2.exports.sync = spawnSync;
    module2.exports._parse = parse2;
    module2.exports._enoent = enoent;
  });
  var require_strip_final_newline = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = (input) => {
      const LF = typeof input === "string" ? "\n" : "\n".charCodeAt();
      const CR = typeof input === "string" ? "\r" : "\r".charCodeAt();
      if (input[input.length - 1] === LF) {
        input = input.slice(0, input.length - 1);
      }
      if (input[input.length - 1] === CR) {
        input = input.slice(0, input.length - 1);
      }
      return input;
    };
  });
  var require_npm_run_path = __commonJS((exports2, module2) => {
    "use strict";
    var path22 = require("path");
    var pathKey = require_path_key();
    var npmRunPath = (options) => {
      options = {
        cwd: process.cwd(),
        path: process.env[pathKey()],
        execPath: process.execPath,
        ...options
      };
      let previous;
      let cwdPath = path22.resolve(options.cwd);
      const result = [];
      while (previous !== cwdPath) {
        result.push(path22.join(cwdPath, "node_modules/.bin"));
        previous = cwdPath;
        cwdPath = path22.resolve(cwdPath, "..");
      }
      const execPathDir = path22.resolve(options.cwd, options.execPath, "..");
      result.push(execPathDir);
      return result.concat(options.path).join(path22.delimiter);
    };
    module2.exports = npmRunPath;
    module2.exports.default = npmRunPath;
    module2.exports.env = (options) => {
      options = {
        env: process.env,
        ...options
      };
      const env2 = {...options.env};
      const path32 = pathKey({env: env2});
      options.path = env2[path32];
      env2[path32] = module2.exports(options);
      return env2;
    };
  });
  var require_mimic_fn = __commonJS((exports2, module2) => {
    "use strict";
    var mimicFn = (to, from) => {
      for (const prop of Reflect.ownKeys(from)) {
        Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
      }
      return to;
    };
    module2.exports = mimicFn;
    module2.exports.default = mimicFn;
  });
  var require_onetime = __commonJS((exports2, module2) => {
    "use strict";
    var mimicFn = require_mimic_fn();
    var calledFunctions = new WeakMap();
    var onetime = (function_, options = {}) => {
      if (typeof function_ !== "function") {
        throw new TypeError("Expected a function");
      }
      let returnValue;
      let callCount = 0;
      const functionName = function_.displayName || function_.name || "<anonymous>";
      const onetime2 = function(...arguments_) {
        calledFunctions.set(onetime2, ++callCount);
        if (callCount === 1) {
          returnValue = function_.apply(this, arguments_);
          function_ = null;
        } else if (options.throw === true) {
          throw new Error(`Function \`${functionName}\` can only be called once`);
        }
        return returnValue;
      };
      mimicFn(onetime2, function_);
      calledFunctions.set(onetime2, callCount);
      return onetime2;
    };
    module2.exports = onetime;
    module2.exports.default = onetime;
    module2.exports.callCount = (function_) => {
      if (!calledFunctions.has(function_)) {
        throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
      }
      return calledFunctions.get(function_);
    };
  });
  var require_core = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.SIGNALS = void 0;
    var SIGNALS = [
      {
        name: "SIGHUP",
        number: 1,
        action: "terminate",
        description: "Terminal closed",
        standard: "posix"
      },
      {
        name: "SIGINT",
        number: 2,
        action: "terminate",
        description: "User interruption with CTRL-C",
        standard: "ansi"
      },
      {
        name: "SIGQUIT",
        number: 3,
        action: "core",
        description: "User interruption with CTRL-\\",
        standard: "posix"
      },
      {
        name: "SIGILL",
        number: 4,
        action: "core",
        description: "Invalid machine instruction",
        standard: "ansi"
      },
      {
        name: "SIGTRAP",
        number: 5,
        action: "core",
        description: "Debugger breakpoint",
        standard: "posix"
      },
      {
        name: "SIGABRT",
        number: 6,
        action: "core",
        description: "Aborted",
        standard: "ansi"
      },
      {
        name: "SIGIOT",
        number: 6,
        action: "core",
        description: "Aborted",
        standard: "bsd"
      },
      {
        name: "SIGBUS",
        number: 7,
        action: "core",
        description: "Bus error due to misaligned, non-existing address or paging error",
        standard: "bsd"
      },
      {
        name: "SIGEMT",
        number: 7,
        action: "terminate",
        description: "Command should be emulated but is not implemented",
        standard: "other"
      },
      {
        name: "SIGFPE",
        number: 8,
        action: "core",
        description: "Floating point arithmetic error",
        standard: "ansi"
      },
      {
        name: "SIGKILL",
        number: 9,
        action: "terminate",
        description: "Forced termination",
        standard: "posix",
        forced: true
      },
      {
        name: "SIGUSR1",
        number: 10,
        action: "terminate",
        description: "Application-specific signal",
        standard: "posix"
      },
      {
        name: "SIGSEGV",
        number: 11,
        action: "core",
        description: "Segmentation fault",
        standard: "ansi"
      },
      {
        name: "SIGUSR2",
        number: 12,
        action: "terminate",
        description: "Application-specific signal",
        standard: "posix"
      },
      {
        name: "SIGPIPE",
        number: 13,
        action: "terminate",
        description: "Broken pipe or socket",
        standard: "posix"
      },
      {
        name: "SIGALRM",
        number: 14,
        action: "terminate",
        description: "Timeout or timer",
        standard: "posix"
      },
      {
        name: "SIGTERM",
        number: 15,
        action: "terminate",
        description: "Termination",
        standard: "ansi"
      },
      {
        name: "SIGSTKFLT",
        number: 16,
        action: "terminate",
        description: "Stack is empty or overflowed",
        standard: "other"
      },
      {
        name: "SIGCHLD",
        number: 17,
        action: "ignore",
        description: "Child process terminated, paused or unpaused",
        standard: "posix"
      },
      {
        name: "SIGCLD",
        number: 17,
        action: "ignore",
        description: "Child process terminated, paused or unpaused",
        standard: "other"
      },
      {
        name: "SIGCONT",
        number: 18,
        action: "unpause",
        description: "Unpaused",
        standard: "posix",
        forced: true
      },
      {
        name: "SIGSTOP",
        number: 19,
        action: "pause",
        description: "Paused",
        standard: "posix",
        forced: true
      },
      {
        name: "SIGTSTP",
        number: 20,
        action: "pause",
        description: 'Paused using CTRL-Z or "suspend"',
        standard: "posix"
      },
      {
        name: "SIGTTIN",
        number: 21,
        action: "pause",
        description: "Background process cannot read terminal input",
        standard: "posix"
      },
      {
        name: "SIGBREAK",
        number: 21,
        action: "terminate",
        description: "User interruption with CTRL-BREAK",
        standard: "other"
      },
      {
        name: "SIGTTOU",
        number: 22,
        action: "pause",
        description: "Background process cannot write to terminal output",
        standard: "posix"
      },
      {
        name: "SIGURG",
        number: 23,
        action: "ignore",
        description: "Socket received out-of-band data",
        standard: "bsd"
      },
      {
        name: "SIGXCPU",
        number: 24,
        action: "core",
        description: "Process timed out",
        standard: "bsd"
      },
      {
        name: "SIGXFSZ",
        number: 25,
        action: "core",
        description: "File too big",
        standard: "bsd"
      },
      {
        name: "SIGVTALRM",
        number: 26,
        action: "terminate",
        description: "Timeout or timer",
        standard: "bsd"
      },
      {
        name: "SIGPROF",
        number: 27,
        action: "terminate",
        description: "Timeout or timer",
        standard: "bsd"
      },
      {
        name: "SIGWINCH",
        number: 28,
        action: "ignore",
        description: "Terminal window size changed",
        standard: "bsd"
      },
      {
        name: "SIGIO",
        number: 29,
        action: "terminate",
        description: "I/O is available",
        standard: "other"
      },
      {
        name: "SIGPOLL",
        number: 29,
        action: "terminate",
        description: "Watched event",
        standard: "other"
      },
      {
        name: "SIGINFO",
        number: 29,
        action: "ignore",
        description: "Request for process information",
        standard: "other"
      },
      {
        name: "SIGPWR",
        number: 30,
        action: "terminate",
        description: "Device running out of power",
        standard: "systemv"
      },
      {
        name: "SIGSYS",
        number: 31,
        action: "core",
        description: "Invalid system call",
        standard: "other"
      },
      {
        name: "SIGUNUSED",
        number: 31,
        action: "terminate",
        description: "Invalid system call",
        standard: "other"
      }
    ];
    exports2.SIGNALS = SIGNALS;
  });
  var require_realtime = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.SIGRTMAX = exports2.getRealtimeSignals = void 0;
    var getRealtimeSignals = function() {
      const length = SIGRTMAX - SIGRTMIN + 1;
      return Array.from({length}, getRealtimeSignal);
    };
    exports2.getRealtimeSignals = getRealtimeSignals;
    var getRealtimeSignal = function(value, index) {
      return {
        name: `SIGRT${index + 1}`,
        number: SIGRTMIN + index,
        action: "terminate",
        description: "Application-specific signal (realtime)",
        standard: "posix"
      };
    };
    var SIGRTMIN = 34;
    var SIGRTMAX = 64;
    exports2.SIGRTMAX = SIGRTMAX;
  });
  var require_signals = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.getSignals = void 0;
    var _os = require("os");
    var _core = require_core();
    var _realtime = require_realtime();
    var getSignals = function() {
      const realtimeSignals = (0, _realtime.getRealtimeSignals)();
      const signals = [..._core.SIGNALS, ...realtimeSignals].map(normalizeSignal);
      return signals;
    };
    exports2.getSignals = getSignals;
    var normalizeSignal = function({
      name,
      number: defaultNumber,
      description,
      action,
      forced = false,
      standard
    }) {
      const {
        signals: {[name]: constantSignal}
      } = _os.constants;
      const supported = constantSignal !== void 0;
      const number = supported ? constantSignal : defaultNumber;
      return {name, number, description, supported, action, forced, standard};
    };
  });
  var require_main = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.signalsByNumber = exports2.signalsByName = void 0;
    var _os = require("os");
    var _signals = require_signals();
    var _realtime = require_realtime();
    var getSignalsByName = function() {
      const signals = (0, _signals.getSignals)();
      return signals.reduce(getSignalByName, {});
    };
    var getSignalByName = function(signalByNameMemo, {name, number, description, supported, action, forced, standard}) {
      return {
        ...signalByNameMemo,
        [name]: {name, number, description, supported, action, forced, standard}
      };
    };
    var signalsByName = getSignalsByName();
    exports2.signalsByName = signalsByName;
    var getSignalsByNumber = function() {
      const signals = (0, _signals.getSignals)();
      const length = _realtime.SIGRTMAX + 1;
      const signalsA = Array.from({length}, (value, number) => getSignalByNumber(number, signals));
      return Object.assign({}, ...signalsA);
    };
    var getSignalByNumber = function(number, signals) {
      const signal = findSignalByNumber(number, signals);
      if (signal === void 0) {
        return {};
      }
      const {name, description, supported, action, forced, standard} = signal;
      return {
        [number]: {
          name,
          number,
          description,
          supported,
          action,
          forced,
          standard
        }
      };
    };
    var findSignalByNumber = function(number, signals) {
      const signal = signals.find(({name}) => _os.constants.signals[name] === number);
      if (signal !== void 0) {
        return signal;
      }
      return signals.find((signalA) => signalA.number === number);
    };
    var signalsByNumber = getSignalsByNumber();
    exports2.signalsByNumber = signalsByNumber;
  });
  var require_error = __commonJS((exports2, module2) => {
    "use strict";
    var {signalsByName} = require_main();
    var getErrorPrefix = ({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled}) => {
      if (timedOut) {
        return `timed out after ${timeout} milliseconds`;
      }
      if (isCanceled) {
        return "was canceled";
      }
      if (errorCode !== void 0) {
        return `failed with ${errorCode}`;
      }
      if (signal !== void 0) {
        return `was killed with ${signal} (${signalDescription})`;
      }
      if (exitCode !== void 0) {
        return `failed with exit code ${exitCode}`;
      }
      return "failed";
    };
    var makeError = ({
      stdout,
      stderr,
      all,
      error,
      signal,
      exitCode,
      command,
      escapedCommand,
      timedOut,
      isCanceled,
      killed,
      parsed: {options: {timeout}}
    }) => {
      exitCode = exitCode === null ? void 0 : exitCode;
      signal = signal === null ? void 0 : signal;
      const signalDescription = signal === void 0 ? void 0 : signalsByName[signal].description;
      const errorCode = error && error.code;
      const prefix = getErrorPrefix({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled});
      const execaMessage = `Command ${prefix}: ${command}`;
      const isError2 = Object.prototype.toString.call(error) === "[object Error]";
      const shortMessage = isError2 ? `${execaMessage}
${error.message}` : execaMessage;
      const message = [shortMessage, stderr, stdout].filter(Boolean).join("\n");
      if (isError2) {
        error.originalMessage = error.message;
        error.message = message;
      } else {
        error = new Error(message);
      }
      error.shortMessage = shortMessage;
      error.command = command;
      error.escapedCommand = escapedCommand;
      error.exitCode = exitCode;
      error.signal = signal;
      error.signalDescription = signalDescription;
      error.stdout = stdout;
      error.stderr = stderr;
      if (all !== void 0) {
        error.all = all;
      }
      if ("bufferedData" in error) {
        delete error.bufferedData;
      }
      error.failed = true;
      error.timedOut = Boolean(timedOut);
      error.isCanceled = isCanceled;
      error.killed = killed && !timedOut;
      return error;
    };
    module2.exports = makeError;
  });
  var require_stdio = __commonJS((exports2, module2) => {
    "use strict";
    var aliases = ["stdin", "stdout", "stderr"];
    var hasAlias = (options) => aliases.some((alias) => options[alias] !== void 0);
    var normalizeStdio = (options) => {
      if (!options) {
        return;
      }
      const {stdio} = options;
      if (stdio === void 0) {
        return aliases.map((alias) => options[alias]);
      }
      if (hasAlias(options)) {
        throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${aliases.map((alias) => `\`${alias}\``).join(", ")}`);
      }
      if (typeof stdio === "string") {
        return stdio;
      }
      if (!Array.isArray(stdio)) {
        throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
      }
      const length = Math.max(stdio.length, aliases.length);
      return Array.from({length}, (value, index) => stdio[index]);
    };
    module2.exports = normalizeStdio;
    module2.exports.node = (options) => {
      const stdio = normalizeStdio(options);
      if (stdio === "ipc") {
        return "ipc";
      }
      if (stdio === void 0 || typeof stdio === "string") {
        return [stdio, stdio, stdio, "ipc"];
      }
      if (stdio.includes("ipc")) {
        return stdio;
      }
      return [...stdio, "ipc"];
    };
  });
  var require_signals2 = __commonJS((exports2, module2) => {
    module2.exports = [
      "SIGABRT",
      "SIGALRM",
      "SIGHUP",
      "SIGINT",
      "SIGTERM"
    ];
    if (process.platform !== "win32") {
      module2.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
    }
    if (process.platform === "linux") {
      module2.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");
    }
  });
  var require_signal_exit = __commonJS((exports2, module2) => {
    var assert = require("assert");
    var signals = require_signals2();
    var isWin = /^win/i.test(process.platform);
    var EE = require("events");
    if (typeof EE !== "function") {
      EE = EE.EventEmitter;
    }
    var emitter;
    if (process.__signal_exit_emitter__) {
      emitter = process.__signal_exit_emitter__;
    } else {
      emitter = process.__signal_exit_emitter__ = new EE();
      emitter.count = 0;
      emitter.emitted = {};
    }
    if (!emitter.infinite) {
      emitter.setMaxListeners(Infinity);
      emitter.infinite = true;
    }
    module2.exports = function(cb, opts) {
      assert.equal(typeof cb, "function", "a callback must be provided for exit handler");
      if (loaded === false) {
        load2();
      }
      var ev = "exit";
      if (opts && opts.alwaysLast) {
        ev = "afterexit";
      }
      var remove2 = function() {
        emitter.removeListener(ev, cb);
        if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
          unload();
        }
      };
      emitter.on(ev, cb);
      return remove2;
    };
    module2.exports.unload = unload;
    function unload() {
      if (!loaded) {
        return;
      }
      loaded = false;
      signals.forEach(function(sig) {
        try {
          process.removeListener(sig, sigListeners[sig]);
        } catch (er) {
        }
      });
      process.emit = originalProcessEmit;
      process.reallyExit = originalProcessReallyExit;
      emitter.count -= 1;
    }
    function emit(event, code, signal) {
      if (emitter.emitted[event]) {
        return;
      }
      emitter.emitted[event] = true;
      emitter.emit(event, code, signal);
    }
    var sigListeners = {};
    signals.forEach(function(sig) {
      sigListeners[sig] = function listener() {
        var listeners = process.listeners(sig);
        if (listeners.length === emitter.count) {
          unload();
          emit("exit", null, sig);
          emit("afterexit", null, sig);
          if (isWin && sig === "SIGHUP") {
            sig = "SIGINT";
          }
          process.kill(process.pid, sig);
        }
      };
    });
    module2.exports.signals = function() {
      return signals;
    };
    module2.exports.load = load2;
    var loaded = false;
    function load2() {
      if (loaded) {
        return;
      }
      loaded = true;
      emitter.count += 1;
      signals = signals.filter(function(sig) {
        try {
          process.on(sig, sigListeners[sig]);
          return true;
        } catch (er) {
          return false;
        }
      });
      process.emit = processEmit;
      process.reallyExit = processReallyExit;
    }
    var originalProcessReallyExit = process.reallyExit;
    function processReallyExit(code) {
      process.exitCode = code || 0;
      emit("exit", process.exitCode, null);
      emit("afterexit", process.exitCode, null);
      originalProcessReallyExit.call(process, process.exitCode);
    }
    var originalProcessEmit = process.emit;
    function processEmit(ev, arg2) {
      if (ev === "exit") {
        if (arg2 !== void 0) {
          process.exitCode = arg2;
        }
        var ret = originalProcessEmit.apply(this, arguments);
        emit("exit", process.exitCode, null);
        emit("afterexit", process.exitCode, null);
        return ret;
      } else {
        return originalProcessEmit.apply(this, arguments);
      }
    }
  });
  var require_kill = __commonJS((exports2, module2) => {
    "use strict";
    var os2 = require("os");
    var onExit = require_signal_exit();
    var DEFAULT_FORCE_KILL_TIMEOUT = 1e3 * 5;
    var spawnedKill = (kill, signal = "SIGTERM", options = {}) => {
      const killResult = kill(signal);
      setKillTimeout(kill, signal, options, killResult);
      return killResult;
    };
    var setKillTimeout = (kill, signal, options, killResult) => {
      if (!shouldForceKill(signal, options, killResult)) {
        return;
      }
      const timeout = getForceKillAfterTimeout(options);
      const t = setTimeout(() => {
        kill("SIGKILL");
      }, timeout);
      if (t.unref) {
        t.unref();
      }
    };
    var shouldForceKill = (signal, {forceKillAfterTimeout}, killResult) => {
      return isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
    };
    var isSigterm = (signal) => {
      return signal === os2.constants.signals.SIGTERM || typeof signal === "string" && signal.toUpperCase() === "SIGTERM";
    };
    var getForceKillAfterTimeout = ({forceKillAfterTimeout = true}) => {
      if (forceKillAfterTimeout === true) {
        return DEFAULT_FORCE_KILL_TIMEOUT;
      }
      if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {
        throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
      }
      return forceKillAfterTimeout;
    };
    var spawnedCancel = (spawned, context) => {
      const killResult = spawned.kill();
      if (killResult) {
        context.isCanceled = true;
      }
    };
    var timeoutKill = (spawned, signal, reject) => {
      spawned.kill(signal);
      reject(Object.assign(new Error("Timed out"), {timedOut: true, signal}));
    };
    var setupTimeout = (spawned, {timeout, killSignal = "SIGTERM"}, spawnedPromise) => {
      if (timeout === 0 || timeout === void 0) {
        return spawnedPromise;
      }
      let timeoutId;
      const timeoutPromise = new Promise((resolve, reject) => {
        timeoutId = setTimeout(() => {
          timeoutKill(spawned, killSignal, reject);
        }, timeout);
      });
      const safeSpawnedPromise = spawnedPromise.finally(() => {
        clearTimeout(timeoutId);
      });
      return Promise.race([timeoutPromise, safeSpawnedPromise]);
    };
    var validateTimeout = ({timeout}) => {
      if (timeout !== void 0 && (!Number.isFinite(timeout) || timeout < 0)) {
        throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
      }
    };
    var setExitHandler = async (spawned, {cleanup: cleanup2, detached}, timedPromise) => {
      if (!cleanup2 || detached) {
        return timedPromise;
      }
      const removeExitHandler = onExit(() => {
        spawned.kill();
      });
      return timedPromise.finally(() => {
        removeExitHandler();
      });
    };
    module2.exports = {
      spawnedKill,
      spawnedCancel,
      setupTimeout,
      validateTimeout,
      setExitHandler
    };
  });
  var require_is_stream = __commonJS((exports2, module2) => {
    "use strict";
    var isStream = (stream) => stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
    isStream.writable = (stream) => isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
    isStream.readable = (stream) => isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
    isStream.duplex = (stream) => isStream.writable(stream) && isStream.readable(stream);
    isStream.transform = (stream) => isStream.duplex(stream) && typeof stream._transform === "function" && typeof stream._transformState === "object";
    module2.exports = isStream;
  });
  var require_buffer_stream = __commonJS((exports2, module2) => {
    "use strict";
    var {PassThrough: PassThroughStream} = require("stream");
    module2.exports = (options) => {
      options = {...options};
      const {array} = options;
      let {encoding} = options;
      const isBuffer = encoding === "buffer";
      let objectMode = false;
      if (array) {
        objectMode = !(encoding || isBuffer);
      } else {
        encoding = encoding || "utf8";
      }
      if (isBuffer) {
        encoding = null;
      }
      const stream = new PassThroughStream({objectMode});
      if (encoding) {
        stream.setEncoding(encoding);
      }
      let length = 0;
      const chunks = [];
      stream.on("data", (chunk) => {
        chunks.push(chunk);
        if (objectMode) {
          length = chunks.length;
        } else {
          length += chunk.length;
        }
      });
      stream.getBufferedValue = () => {
        if (array) {
          return chunks;
        }
        return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
      };
      stream.getBufferedLength = () => length;
      return stream;
    };
  });
  var require_get_stream = __commonJS((exports2, module2) => {
    "use strict";
    var {constants: BufferConstants} = require("buffer");
    var stream = require("stream");
    var {promisify: promisify2} = require("util");
    var bufferStream = require_buffer_stream();
    var streamPipelinePromisified = promisify2(stream.pipeline);
    var MaxBufferError = class extends Error {
      constructor() {
        super("maxBuffer exceeded");
        this.name = "MaxBufferError";
      }
    };
    async function getStream(inputStream, options) {
      if (!inputStream) {
        throw new Error("Expected a stream");
      }
      options = {
        maxBuffer: Infinity,
        ...options
      };
      const {maxBuffer} = options;
      const stream2 = bufferStream(options);
      await new Promise((resolve, reject) => {
        const rejectPromise = (error) => {
          if (error && stream2.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
            error.bufferedData = stream2.getBufferedValue();
          }
          reject(error);
        };
        (async () => {
          try {
            await streamPipelinePromisified(inputStream, stream2);
            resolve();
          } catch (error) {
            rejectPromise(error);
          }
        })();
        stream2.on("data", () => {
          if (stream2.getBufferedLength() > maxBuffer) {
            rejectPromise(new MaxBufferError());
          }
        });
      });
      return stream2.getBufferedValue();
    }
    module2.exports = getStream;
    module2.exports.buffer = (stream2, options) => getStream(stream2, {...options, encoding: "buffer"});
    module2.exports.array = (stream2, options) => getStream(stream2, {...options, array: true});
    module2.exports.MaxBufferError = MaxBufferError;
  });
  var require_merge_stream = __commonJS((exports2, module2) => {
    "use strict";
    var {PassThrough} = require("stream");
    module2.exports = function() {
      var sources = [];
      var output = new PassThrough({objectMode: true});
      output.setMaxListeners(0);
      output.add = add2;
      output.isEmpty = isEmpty;
      output.on("unpipe", remove2);
      Array.prototype.slice.call(arguments).forEach(add2);
      return output;
      function add2(source) {
        if (Array.isArray(source)) {
          source.forEach(add2);
          return this;
        }
        sources.push(source);
        source.once("end", remove2.bind(null, source));
        source.once("error", output.emit.bind(output, "error"));
        source.pipe(output, {end: false});
        return this;
      }
      function isEmpty() {
        return sources.length == 0;
      }
      function remove2(source) {
        sources = sources.filter(function(it) {
          return it !== source;
        });
        if (!sources.length && output.readable) {
          output.end();
        }
      }
    };
  });
  var require_stream = __commonJS((exports2, module2) => {
    "use strict";
    var isStream = require_is_stream();
    var getStream = require_get_stream();
    var mergeStream = require_merge_stream();
    var handleInput = (spawned, input) => {
      if (input === void 0 || spawned.stdin === void 0) {
        return;
      }
      if (isStream(input)) {
        input.pipe(spawned.stdin);
      } else {
        spawned.stdin.end(input);
      }
    };
    var makeAllStream = (spawned, {all}) => {
      if (!all || !spawned.stdout && !spawned.stderr) {
        return;
      }
      const mixed = mergeStream();
      if (spawned.stdout) {
        mixed.add(spawned.stdout);
      }
      if (spawned.stderr) {
        mixed.add(spawned.stderr);
      }
      return mixed;
    };
    var getBufferedData = async (stream, streamPromise) => {
      if (!stream) {
        return;
      }
      stream.destroy();
      try {
        return await streamPromise;
      } catch (error) {
        return error.bufferedData;
      }
    };
    var getStreamPromise = (stream, {encoding, buffer, maxBuffer}) => {
      if (!stream || !buffer) {
        return;
      }
      if (encoding) {
        return getStream(stream, {encoding, maxBuffer});
      }
      return getStream.buffer(stream, {maxBuffer});
    };
    var getSpawnedResult = async ({stdout, stderr, all}, {encoding, buffer, maxBuffer}, processDone) => {
      const stdoutPromise = getStreamPromise(stdout, {encoding, buffer, maxBuffer});
      const stderrPromise = getStreamPromise(stderr, {encoding, buffer, maxBuffer});
      const allPromise = getStreamPromise(all, {encoding, buffer, maxBuffer: maxBuffer * 2});
      try {
        return await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);
      } catch (error) {
        return Promise.all([
          {error, signal: error.signal, timedOut: error.timedOut},
          getBufferedData(stdout, stdoutPromise),
          getBufferedData(stderr, stderrPromise),
          getBufferedData(all, allPromise)
        ]);
      }
    };
    var validateInputSync = ({input}) => {
      if (isStream(input)) {
        throw new TypeError("The `input` option cannot be a stream in sync mode");
      }
    };
    module2.exports = {
      handleInput,
      makeAllStream,
      getSpawnedResult,
      validateInputSync
    };
  });
  var require_promise = __commonJS((exports2, module2) => {
    "use strict";
    var nativePromisePrototype = (async () => {
    })().constructor.prototype;
    var descriptors = ["then", "catch", "finally"].map((property) => [
      property,
      Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
    ]);
    var mergePromise = (spawned, promise) => {
      for (const [property, descriptor] of descriptors) {
        const value = typeof promise === "function" ? (...args) => Reflect.apply(descriptor.value, promise(), args) : descriptor.value.bind(promise);
        Reflect.defineProperty(spawned, property, {...descriptor, value});
      }
      return spawned;
    };
    var getSpawnedPromise = (spawned) => {
      return new Promise((resolve, reject) => {
        spawned.on("exit", (exitCode, signal) => {
          resolve({exitCode, signal});
        });
        spawned.on("error", (error) => {
          reject(error);
        });
        if (spawned.stdin) {
          spawned.stdin.on("error", (error) => {
            reject(error);
          });
        }
      });
    };
    module2.exports = {
      mergePromise,
      getSpawnedPromise
    };
  });
  var require_command = __commonJS((exports2, module2) => {
    "use strict";
    var normalizeArgs = (file, args = []) => {
      if (!Array.isArray(args)) {
        return [file];
      }
      return [file, ...args];
    };
    var NO_ESCAPE_REGEXP = /^[\w.-]+$/;
    var DOUBLE_QUOTES_REGEXP = /"/g;
    var escapeArg = (arg2) => {
      if (typeof arg2 !== "string" || NO_ESCAPE_REGEXP.test(arg2)) {
        return arg2;
      }
      return `"${arg2.replace(DOUBLE_QUOTES_REGEXP, '\\"')}"`;
    };
    var joinCommand = (file, args) => {
      return normalizeArgs(file, args).join(" ");
    };
    var getEscapedCommand = (file, args) => {
      return normalizeArgs(file, args).map((arg2) => escapeArg(arg2)).join(" ");
    };
    var SPACES_REGEXP = / +/g;
    var parseCommand = (command) => {
      const tokens = [];
      for (const token of command.trim().split(SPACES_REGEXP)) {
        const previousToken = tokens[tokens.length - 1];
        if (previousToken && previousToken.endsWith("\\")) {
          tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
        } else {
          tokens.push(token);
        }
      }
      return tokens;
    };
    module2.exports = {
      joinCommand,
      getEscapedCommand,
      parseCommand
    };
  });
  var require_execa = __commonJS((exports2, module2) => {
    "use strict";
    var path22 = require("path");
    var childProcess = require("child_process");
    var crossSpawn = require_cross_spawn();
    var stripFinalNewline = require_strip_final_newline();
    var npmRunPath = require_npm_run_path();
    var onetime = require_onetime();
    var makeError = require_error();
    var normalizeStdio = require_stdio();
    var {spawnedKill, spawnedCancel, setupTimeout, validateTimeout, setExitHandler} = require_kill();
    var {handleInput, getSpawnedResult, makeAllStream, validateInputSync} = require_stream();
    var {mergePromise, getSpawnedPromise} = require_promise();
    var {joinCommand, parseCommand, getEscapedCommand} = require_command();
    var DEFAULT_MAX_BUFFER = 1e3 * 1e3 * 100;
    var getEnv = ({env: envOption, extendEnv, preferLocal, localDir, execPath}) => {
      const env2 = extendEnv ? {...process.env, ...envOption} : envOption;
      if (preferLocal) {
        return npmRunPath.env({env: env2, cwd: localDir, execPath});
      }
      return env2;
    };
    var handleArguments = (file, args, options = {}) => {
      const parsed = crossSpawn._parse(file, args, options);
      file = parsed.command;
      args = parsed.args;
      options = parsed.options;
      options = {
        maxBuffer: DEFAULT_MAX_BUFFER,
        buffer: true,
        stripFinalNewline: true,
        extendEnv: true,
        preferLocal: false,
        localDir: options.cwd || process.cwd(),
        execPath: process.execPath,
        encoding: "utf8",
        reject: true,
        cleanup: true,
        all: false,
        windowsHide: true,
        ...options
      };
      options.env = getEnv(options);
      options.stdio = normalizeStdio(options);
      if (process.platform === "win32" && path22.basename(file, ".exe") === "cmd") {
        args.unshift("/q");
      }
      return {file, args, options, parsed};
    };
    var handleOutput = (options, value, error) => {
      if (typeof value !== "string" && !Buffer.isBuffer(value)) {
        return error === void 0 ? void 0 : "";
      }
      if (options.stripFinalNewline) {
        return stripFinalNewline(value);
      }
      return value;
    };
    var execa = (file, args, options) => {
      const parsed = handleArguments(file, args, options);
      const command = joinCommand(file, args);
      const escapedCommand = getEscapedCommand(file, args);
      validateTimeout(parsed.options);
      let spawned;
      try {
        spawned = childProcess.spawn(parsed.file, parsed.args, parsed.options);
      } catch (error) {
        const dummySpawned = new childProcess.ChildProcess();
        const errorPromise = Promise.reject(makeError({
          error,
          stdout: "",
          stderr: "",
          all: "",
          command,
          escapedCommand,
          parsed,
          timedOut: false,
          isCanceled: false,
          killed: false
        }));
        return mergePromise(dummySpawned, errorPromise);
      }
      const spawnedPromise = getSpawnedPromise(spawned);
      const timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);
      const processDone = setExitHandler(spawned, parsed.options, timedPromise);
      const context = {isCanceled: false};
      spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));
      spawned.cancel = spawnedCancel.bind(null, spawned, context);
      const handlePromise = async () => {
        const [{error, exitCode, signal, timedOut}, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone);
        const stdout = handleOutput(parsed.options, stdoutResult);
        const stderr = handleOutput(parsed.options, stderrResult);
        const all = handleOutput(parsed.options, allResult);
        if (error || exitCode !== 0 || signal !== null) {
          const returnedError = makeError({
            error,
            exitCode,
            signal,
            stdout,
            stderr,
            all,
            command,
            escapedCommand,
            parsed,
            timedOut,
            isCanceled: context.isCanceled,
            killed: spawned.killed
          });
          if (!parsed.options.reject) {
            return returnedError;
          }
          throw returnedError;
        }
        return {
          command,
          escapedCommand,
          exitCode: 0,
          stdout,
          stderr,
          all,
          failed: false,
          timedOut: false,
          isCanceled: false,
          killed: false
        };
      };
      const handlePromiseOnce = onetime(handlePromise);
      handleInput(spawned, parsed.options.input);
      spawned.all = makeAllStream(spawned, parsed.options);
      return mergePromise(spawned, handlePromiseOnce);
    };
    module2.exports = execa;
    module2.exports.sync = (file, args, options) => {
      const parsed = handleArguments(file, args, options);
      const command = joinCommand(file, args);
      const escapedCommand = getEscapedCommand(file, args);
      validateInputSync(parsed.options);
      let result;
      try {
        result = childProcess.spawnSync(parsed.file, parsed.args, parsed.options);
      } catch (error) {
        throw makeError({
          error,
          stdout: "",
          stderr: "",
          all: "",
          command,
          escapedCommand,
          parsed,
          timedOut: false,
          isCanceled: false,
          killed: false
        });
      }
      const stdout = handleOutput(parsed.options, result.stdout, result.error);
      const stderr = handleOutput(parsed.options, result.stderr, result.error);
      if (result.error || result.status !== 0 || result.signal !== null) {
        const error = makeError({
          stdout,
          stderr,
          error: result.error,
          signal: result.signal,
          exitCode: result.status,
          command,
          escapedCommand,
          parsed,
          timedOut: result.error && result.error.code === "ETIMEDOUT",
          isCanceled: false,
          killed: result.signal !== null
        });
        if (!parsed.options.reject) {
          return error;
        }
        throw error;
      }
      return {
        command,
        escapedCommand,
        exitCode: 0,
        stdout,
        stderr,
        failed: false,
        timedOut: false,
        isCanceled: false,
        killed: false
      };
    };
    module2.exports.command = (command, options) => {
      const [file, ...args] = parseCommand(command);
      return execa(file, args, options);
    };
    module2.exports.commandSync = (command, options) => {
      const [file, ...args] = parseCommand(command);
      return execa.sync(file, args, options);
    };
    module2.exports.node = (scriptPath, args, options = {}) => {
      if (args && !Array.isArray(args) && typeof args === "object") {
        options = args;
        args = [];
      }
      const stdio = normalizeStdio.node(options);
      const defaultExecArgv = process.execArgv.filter((arg2) => !arg2.startsWith("--inspect"));
      const {
        nodePath = process.execPath,
        nodeOptions = defaultExecArgv
      } = options;
      return execa(nodePath, [
        ...nodeOptions,
        scriptPath,
        ...Array.isArray(args) ? args : []
      ], {
        ...options,
        stdin: void 0,
        stdout: void 0,
        stderr: void 0,
        stdio,
        shell: false
      });
    };
  });
  var require_constants = __commonJS((exports2, module2) => {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER2 = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    module2.exports = {
      SEMVER_SPEC_VERSION,
      MAX_LENGTH,
      MAX_SAFE_INTEGER: MAX_SAFE_INTEGER2,
      MAX_SAFE_COMPONENT_LENGTH
    };
  });
  var require_debug = __commonJS((exports2, module2) => {
    var debug32 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug32;
  });
  var require_re = __commonJS((exports2, module2) => {
    var {MAX_SAFE_COMPONENT_LENGTH} = require_constants();
    var debug32 = require_debug();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var src = exports2.src = [];
    var t = exports2.t = {};
    var R = 0;
    var createToken = (name, value, isGlobal) => {
      const index = R++;
      debug32(index, value);
      t[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
    createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0.0.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
  });
  var require_parse_options = __commonJS((exports2, module2) => {
    var opts = ["includePrerelease", "loose", "rtl"];
    var parseOptions = (options) => !options ? {} : typeof options !== "object" ? {loose: true} : opts.filter((k) => options[k]).reduce((options2, k) => {
      options2[k] = true;
      return options2;
    }, {});
    module2.exports = parseOptions;
  });
  var require_identifiers = __commonJS((exports2, module2) => {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  });
  var require_semver = __commonJS((exports2, module2) => {
    var debug32 = require_debug();
    var {MAX_LENGTH, MAX_SAFE_INTEGER: MAX_SAFE_INTEGER2} = require_constants();
    var {re, t} = require_re();
    var parseOptions = require_parse_options();
    var {compareIdentifiers} = require_identifiers();
    var SemVer = class {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
        }
        debug32("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m2 = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m2) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m2[1];
        this.minor = +m2[2];
        this.patch = +m2[3];
        if (this.major > MAX_SAFE_INTEGER2 || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER2 || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER2 || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m2[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m2[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER2) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m2[5] ? m2[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug32("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug32("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug32("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      inc(release, identifier) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier);
            this.inc("pre", identifier);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier);
            }
            this.inc("pre", identifier);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre":
            if (this.prerelease.length === 0) {
              this.prerelease = [0];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                this.prerelease.push(0);
              }
            }
            if (identifier) {
              if (this.prerelease[0] === identifier) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = [identifier, 0];
                }
              } else {
                this.prerelease = [identifier, 0];
              }
            }
            break;
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.format();
        this.raw = this.version;
        return this;
      }
    };
    module2.exports = SemVer;
  });
  var require_parse2 = __commonJS((exports2, module2) => {
    var {MAX_LENGTH} = require_constants();
    var {re, t} = require_re();
    var SemVer = require_semver();
    var parseOptions = require_parse_options();
    var parse2 = (version, options) => {
      options = parseOptions(options);
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      if (version.length > MAX_LENGTH) {
        return null;
      }
      const r = options.loose ? re[t.LOOSE] : re[t.FULL];
      if (!r.test(version)) {
        return null;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        return null;
      }
    };
    module2.exports = parse2;
  });
  var require_valid = __commonJS((exports2, module2) => {
    var parse2 = require_parse2();
    var valid = (version, options) => {
      const v = parse2(version, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  });
  var require_clean = __commonJS((exports2, module2) => {
    var parse2 = require_parse2();
    var clean = (version, options) => {
      const s2 = parse2(version.trim().replace(/^[=v]+/, ""), options);
      return s2 ? s2.version : null;
    };
    module2.exports = clean;
  });
  var require_inc = __commonJS((exports2, module2) => {
    var SemVer = require_semver();
    var inc = (version, release, options, identifier) => {
      if (typeof options === "string") {
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(version, options).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  });
  var require_compare = __commonJS((exports2, module2) => {
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  });
  var require_eq = __commonJS((exports2, module2) => {
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  });
  var require_diff = __commonJS((exports2, module2) => {
    var parse2 = require_parse2();
    var eq = require_eq();
    var diff = (version1, version2) => {
      if (eq(version1, version2)) {
        return null;
      } else {
        const v1 = parse2(version1);
        const v2 = parse2(version2);
        const hasPre = v1.prerelease.length || v2.prerelease.length;
        const prefix = hasPre ? "pre" : "";
        const defaultResult = hasPre ? "prerelease" : "";
        for (const key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    };
    module2.exports = diff;
  });
  var require_major = __commonJS((exports2, module2) => {
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  });
  var require_minor = __commonJS((exports2, module2) => {
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  });
  var require_patch = __commonJS((exports2, module2) => {
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  });
  var require_prerelease = __commonJS((exports2, module2) => {
    var parse2 = require_parse2();
    var prerelease = (version, options) => {
      const parsed = parse2(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  });
  var require_rcompare = __commonJS((exports2, module2) => {
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  });
  var require_compare_loose = __commonJS((exports2, module2) => {
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  });
  var require_compare_build = __commonJS((exports2, module2) => {
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  });
  var require_sort = __commonJS((exports2, module2) => {
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  });
  var require_rsort = __commonJS((exports2, module2) => {
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  });
  var require_gt = __commonJS((exports2, module2) => {
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  });
  var require_lt = __commonJS((exports2, module2) => {
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  });
  var require_neq = __commonJS((exports2, module2) => {
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  });
  var require_gte = __commonJS((exports2, module2) => {
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  });
  var require_lte = __commonJS((exports2, module2) => {
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  });
  var require_cmp = __commonJS((exports2, module2) => {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  });
  var require_coerce = __commonJS((exports2, module2) => {
    var SemVer = require_semver();
    var parse2 = require_parse2();
    var {re, t} = require_re();
    var coerce = (version, options) => {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version.match(re[t.COERCE]);
      } else {
        let next;
        while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        re[t.COERCERTL].lastIndex = -1;
      }
      if (match === null)
        return null;
      return parse2(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
    };
    module2.exports = coerce;
  });
  var require_iterator = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  });
  var require_yallist = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  });
  var require_lru_cache = __commonJS((exports2, module2) => {
    "use strict";
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options) {
        if (typeof options === "number")
          options = {max: options};
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max2 = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h2) => h2);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key))
          return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get(this, key, true);
      }
      peek(key) {
        return get(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get(this, key, false));
      }
    };
    var get = (self2, key, doUse) => {
      const node = self2[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    };
    var trim = (self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    };
    var del = (self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self2, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self2);
    };
    module2.exports = LRUCache;
  });
  var require_range = __commonJS((exports2, module2) => {
    var Range = class {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.format();
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range;
        this.set = range.split(/\s*\|\|\s*/).map((range2) => this.parseRange(range2.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${range}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0)
            this.set = [first];
          else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => {
          return comps.join(" ").trim();
        }).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        range = range.trim();
        const memoOpts = Object.keys(this.options).join(",");
        const memoKey = `parseRange:${memoOpts}:${range}`;
        const cached = cache.get(memoKey);
        if (cached)
          return cached;
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug32("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug32("comparator trim", range, re[t.COMPARATORTRIM]);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        range = range.split(/\s+/).join(" ");
        const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options)).filter(this.options.loose ? (comp) => !!comp.match(compRe) : () => true).map((comp) => new Comparator(comp, this.options));
        const l = rangeList.length;
        const rangeMap = new Map();
        for (const comp of rangeList) {
          if (isNullSet(comp))
            return [comp];
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has(""))
          rangeMap.delete("");
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lru_cache();
    var cache = new LRU({max: 1e3});
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug32 = require_debug();
    var SemVer = require_semver();
    var {
      re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug32("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug32("caret", comp);
      comp = replaceTildes(comp, options);
      debug32("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug32("xrange", comp);
      comp = replaceStars(comp, options);
      debug32("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
      return replaceTilde(comp2, options);
    }).join(" ");
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_2, M, m2, p, pr) => {
        debug32("tilde", comp, _2, M, m2, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m2)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m2}.0 <${M}.${+m2 + 1}.0-0`;
        } else if (pr) {
          debug32("replaceTilde pr", pr);
          ret = `>=${M}.${m2}.${p}-${pr} <${M}.${+m2 + 1}.0-0`;
        } else {
          ret = `>=${M}.${m2}.${p} <${M}.${+m2 + 1}.0-0`;
        }
        debug32("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
      return replaceCaret(comp2, options);
    }).join(" ");
    var replaceCaret = (comp, options) => {
      debug32("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_2, M, m2, p, pr) => {
        debug32("caret", comp, _2, M, m2, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m2)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m2}.0${z} <${M}.${+m2 + 1}.0-0`;
          } else {
            ret = `>=${M}.${m2}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug32("replaceCaret pr", pr);
          if (M === "0") {
            if (m2 === "0") {
              ret = `>=${M}.${m2}.${p}-${pr} <${M}.${m2}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m2}.${p}-${pr} <${M}.${+m2 + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m2}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug32("no pr");
          if (M === "0") {
            if (m2 === "0") {
              ret = `>=${M}.${m2}.${p}${z} <${M}.${m2}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m2}.${p}${z} <${M}.${+m2 + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m2}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug32("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug32("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((comp2) => {
        return replaceXRange(comp2, options);
      }).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m2, p, pr) => {
        debug32("xRange", comp, ret, gtlt, M, m2, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m2);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m2 = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m2 = 0;
              p = 0;
            } else {
              m2 = +m2 + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m2 = +m2 + 1;
            }
          }
          if (gtlt === "<")
            pr = "-0";
          ret = `${gtlt + M}.${m2}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m2}.0${pr} <${M}.${+m2 + 1}.0-0`;
        }
        debug32("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug32("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug32("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug32(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  });
  var require_comparator = __commonJS((exports2, module2) => {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        debug32("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug32("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m2 = comp.match(r);
        if (!m2) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m2[1] !== void 0 ? m2[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m2[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m2[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug32("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (!options || typeof options !== "object") {
          options = {
            loose: !!options,
            includePrerelease: false
          };
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        const sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
        const sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
        const sameSemVer = this.semver.version === comp.semver.version;
        const differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
        const oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
        const oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
        return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var {re, t} = require_re();
    var cmp = require_cmp();
    var debug32 = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  });
  var require_satisfies = __commonJS((exports2, module2) => {
    var Range = require_range();
    var satisfies = (version, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module2.exports = satisfies;
  });
  var require_to_comparators = __commonJS((exports2, module2) => {
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  });
  var require_max_satisfying = __commonJS((exports2, module2) => {
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max2 = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max2 || maxSV.compare(v) === -1) {
            max2 = v;
            maxSV = new SemVer(max2, options);
          }
        }
      });
      return max2;
    };
    module2.exports = maxSatisfying;
  });
  var require_min_satisfying = __commonJS((exports2, module2) => {
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min2 = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min2 || minSV.compare(v) === 1) {
            min2 = v;
            minSV = new SemVer(min2, options);
          }
        }
      });
      return min2;
    };
    module2.exports = minSatisfying;
  });
  var require_min_version = __commonJS((exports2, module2) => {
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin)))
          minver = setMin;
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  });
  var require_valid2 = __commonJS((exports2, module2) => {
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  });
  var require_outside = __commonJS((exports2, module2) => {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var {ANY} = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version, range, hilo, options) => {
      version = new SemVer(version, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  });
  var require_gtr = __commonJS((exports2, module2) => {
    var outside = require_outside();
    var gtr = (version, range, options) => outside(version, range, ">", options);
    module2.exports = gtr;
  });
  var require_ltr = __commonJS((exports2, module2) => {
    var outside = require_outside();
    var ltr = (version, range, options) => outside(version, range, "<", options);
    module2.exports = ltr;
  });
  var require_intersects = __commonJS((exports2, module2) => {
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    };
    module2.exports = intersects;
  });
  var require_simplify = __commonJS((exports2, module2) => {
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options) => {
      const set = [];
      let min2 = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version of v) {
        const included = satisfies(version, range, options);
        if (included) {
          prev = version;
          if (!min2)
            min2 = version;
        } else {
          if (prev) {
            set.push([min2, prev]);
          }
          prev = null;
          min2 = null;
        }
      }
      if (min2)
        set.push([min2, null]);
      const ranges = [];
      for (const [min22, max2] of set) {
        if (min22 === max2)
          ranges.push(min22);
        else if (!max2 && min22 === v[0])
          ranges.push("*");
        else if (!max2)
          ranges.push(`>=${min22}`);
        else if (min22 === v[0])
          ranges.push(`<=${max2}`);
        else
          ranges.push(`${min22} - ${max2}`);
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  });
  var require_subset = __commonJS((exports2, module2) => {
    var Range = require_range();
    var Comparator = require_comparator();
    var {ANY} = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub2, dom, options = {}) => {
      if (sub2 === dom)
        return true;
      sub2 = new Range(sub2, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER:
        for (const simpleSub of sub2.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub)
              continue OUTER;
          }
          if (sawNonNull)
            return false;
        }
      return true;
    };
    var simpleSubset = (sub2, dom, options) => {
      if (sub2 === dom)
        return true;
      if (sub2.length === 1 && sub2[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY)
          return true;
        else if (options.includePrerelease)
          sub2 = [new Comparator(">=0.0.0-0")];
        else
          sub2 = [new Comparator(">=0.0.0")];
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease)
          return true;
        else
          dom = [new Comparator(">=0.0.0")];
      }
      const eqSet = new Set();
      let gt, lt;
      for (const c of sub2) {
        if (c.operator === ">" || c.operator === ">=")
          gt = higherGT(gt, c, options);
        else if (c.operator === "<" || c.operator === "<=")
          lt = lowerLT(lt, c, options);
        else
          eqSet.add(c.semver);
      }
      if (eqSet.size > 1)
        return null;
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0)
          return null;
        else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<="))
          return null;
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options))
          return null;
        if (lt && !satisfies(eq, String(lt), options))
          return null;
        for (const c of dom) {
          if (!satisfies(eq, String(c), options))
            return false;
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt)
              return false;
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options))
            return false;
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt)
              return false;
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options))
            return false;
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0)
          return false;
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0)
        return false;
      if (lt && hasDomGT && !gt && gtltComp !== 0)
        return false;
      if (needDomGTPre || needDomLTPre)
        return false;
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a)
        return b;
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a)
        return b;
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  });
  var require_semver2 = __commonJS((exports2, module2) => {
    var internalRe = require_re();
    module2.exports = {
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: require_constants().SEMVER_SPEC_VERSION,
      SemVer: require_semver(),
      compareIdentifiers: require_identifiers().compareIdentifiers,
      rcompareIdentifiers: require_identifiers().rcompareIdentifiers,
      parse: require_parse2(),
      valid: require_valid(),
      clean: require_clean(),
      inc: require_inc(),
      diff: require_diff(),
      major: require_major(),
      minor: require_minor(),
      patch: require_patch(),
      prerelease: require_prerelease(),
      compare: require_compare(),
      rcompare: require_rcompare(),
      compareLoose: require_compare_loose(),
      compareBuild: require_compare_build(),
      sort: require_sort(),
      rsort: require_rsort(),
      gt: require_gt(),
      lt: require_lt(),
      eq: require_eq(),
      neq: require_neq(),
      gte: require_gte(),
      lte: require_lte(),
      cmp: require_cmp(),
      coerce: require_coerce(),
      Comparator: require_comparator(),
      Range: require_range(),
      satisfies: require_satisfies(),
      toComparators: require_to_comparators(),
      maxSatisfying: require_max_satisfying(),
      minSatisfying: require_min_satisfying(),
      minVersion: require_min_version(),
      validRange: require_valid2(),
      outside: require_outside(),
      gtr: require_gtr(),
      ltr: require_ltr(),
      intersects: require_intersects(),
      simplifyRange: require_simplify(),
      subset: require_subset()
    };
  });
  var require_make_dir = __commonJS((exports2, module2) => {
    "use strict";
    var fs2 = require("fs");
    var path22 = require("path");
    var {promisify: promisify2} = require("util");
    var semver2 = require_semver2();
    var useNativeRecursiveOption2 = semver2.satisfies(process.version, ">=10.12.0");
    var checkPath2 = (pth) => {
      if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path22.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
          const error = new Error(`Path contains invalid characters: ${pth}`);
          error.code = "EINVAL";
          throw error;
        }
      }
    };
    var processOptions2 = (options) => {
      const defaults = {
        mode: 511,
        fs: fs2
      };
      return {
        ...defaults,
        ...options
      };
    };
    var permissionError2 = (pth) => {
      const error = new Error(`operation not permitted, mkdir '${pth}'`);
      error.code = "EPERM";
      error.errno = -4048;
      error.path = pth;
      error.syscall = "mkdir";
      return error;
    };
    var makeDir2 = async (input, options) => {
      checkPath2(input);
      options = processOptions2(options);
      const mkdir2 = promisify2(options.fs.mkdir);
      const stat2 = promisify2(options.fs.stat);
      if (useNativeRecursiveOption2 && options.fs.mkdir === fs2.mkdir) {
        const pth = path22.resolve(input);
        await mkdir2(pth, {
          mode: options.mode,
          recursive: true
        });
        return pth;
      }
      const make = async (pth) => {
        try {
          await mkdir2(pth, options.mode);
          return pth;
        } catch (error) {
          if (error.code === "EPERM") {
            throw error;
          }
          if (error.code === "ENOENT") {
            if (path22.dirname(pth) === pth) {
              throw permissionError2(pth);
            }
            if (error.message.includes("null bytes")) {
              throw error;
            }
            await make(path22.dirname(pth));
            return make(pth);
          }
          try {
            const stats = await stat2(pth);
            if (!stats.isDirectory()) {
              throw new Error("The path is not a directory");
            }
          } catch (_2) {
            throw error;
          }
          return pth;
        }
      };
      return make(path22.resolve(input));
    };
    module2.exports = makeDir2;
    module2.exports.sync = (input, options) => {
      checkPath2(input);
      options = processOptions2(options);
      if (useNativeRecursiveOption2 && options.fs.mkdirSync === fs2.mkdirSync) {
        const pth = path22.resolve(input);
        fs2.mkdirSync(pth, {
          mode: options.mode,
          recursive: true
        });
        return pth;
      }
      const make = (pth) => {
        try {
          options.fs.mkdirSync(pth, options.mode);
        } catch (error) {
          if (error.code === "EPERM") {
            throw error;
          }
          if (error.code === "ENOENT") {
            if (path22.dirname(pth) === pth) {
              throw permissionError2(pth);
            }
            if (error.message.includes("null bytes")) {
              throw error;
            }
            make(path22.dirname(pth));
            return make(pth);
          }
          try {
            if (!options.fs.statSync(pth).isDirectory()) {
              throw new Error("The path is not a directory");
            }
          } catch (_2) {
            throw error;
          }
        }
        return pth;
      };
      return make(path22.resolve(input));
    };
  });
  var require_indent_string = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = (string, count = 1, options) => {
      options = {
        indent: " ",
        includeEmptyLines: false,
        ...options
      };
      if (typeof string !== "string") {
        throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof string}\``);
      }
      if (typeof count !== "number") {
        throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof count}\``);
      }
      if (typeof options.indent !== "string") {
        throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof options.indent}\``);
      }
      if (count === 0) {
        return string;
      }
      const regex = options.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
      return string.replace(regex, options.indent.repeat(count));
    };
  });
  var require_clean_stack = __commonJS((exports2, module2) => {
    "use strict";
    var os2 = require("os");
    var extractPathRegex = /\s+at.*(?:\(|\s)(.*)\)?/;
    var pathRegex = /^(?:(?:(?:node|(?:internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)\.js:\d+:\d+)|native)/;
    var homeDir = typeof os2.homedir === "undefined" ? "" : os2.homedir();
    module2.exports = (stack, options) => {
      options = Object.assign({pretty: false}, options);
      return stack.replace(/\\/g, "/").split("\n").filter((line) => {
        const pathMatches = line.match(extractPathRegex);
        if (pathMatches === null || !pathMatches[1]) {
          return true;
        }
        const match = pathMatches[1];
        if (match.includes(".app/Contents/Resources/electron.asar") || match.includes(".app/Contents/Resources/default_app.asar")) {
          return false;
        }
        return !pathRegex.test(match);
      }).filter((line) => line.trim() !== "").map((line) => {
        if (options.pretty) {
          return line.replace(extractPathRegex, (m2, p1) => m2.replace(p1, p1.replace(homeDir, "~")));
        }
        return line;
      }).join("\n");
    };
  });
  var require_aggregate_error = __commonJS((exports2, module2) => {
    "use strict";
    var indentString = require_indent_string();
    var cleanStack = require_clean_stack();
    var cleanInternalStack = (stack) => stack.replace(/\s+at .*aggregate-error\/index.js:\d+:\d+\)?/g, "");
    var AggregateError = class extends Error {
      constructor(errors) {
        if (!Array.isArray(errors)) {
          throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
        }
        errors = [...errors].map((error) => {
          if (error instanceof Error) {
            return error;
          }
          if (error !== null && typeof error === "object") {
            return Object.assign(new Error(error.message), error);
          }
          return new Error(error);
        });
        let message = errors.map((error) => {
          return typeof error.stack === "string" ? cleanInternalStack(cleanStack(error.stack)) : String(error);
        }).join("\n");
        message = "\n" + indentString(message, 4);
        super(message);
        this.name = "AggregateError";
        Object.defineProperty(this, "_errors", {value: errors});
      }
      *[Symbol.iterator]() {
        for (const error of this._errors) {
          yield error;
        }
      }
    };
    module2.exports = AggregateError;
  });
  var require_p_map = __commonJS((exports2, module2) => {
    "use strict";
    var AggregateError = require_aggregate_error();
    module2.exports = async (iterable, mapper, {
      concurrency = Infinity,
      stopOnError = true
    } = {}) => {
      return new Promise((resolve, reject) => {
        if (typeof mapper !== "function") {
          throw new TypeError("Mapper function is required");
        }
        if (!((Number.isSafeInteger(concurrency) || concurrency === Infinity) && concurrency >= 1)) {
          throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${concurrency}\` (${typeof concurrency})`);
        }
        const result = [];
        const errors = [];
        const iterator = iterable[Symbol.iterator]();
        let isRejected = false;
        let isIterableDone = false;
        let resolvingCount = 0;
        let currentIndex = 0;
        const next = () => {
          if (isRejected) {
            return;
          }
          const nextItem = iterator.next();
          const index = currentIndex;
          currentIndex++;
          if (nextItem.done) {
            isIterableDone = true;
            if (resolvingCount === 0) {
              if (!stopOnError && errors.length !== 0) {
                reject(new AggregateError(errors));
              } else {
                resolve(result);
              }
            }
            return;
          }
          resolvingCount++;
          (async () => {
            try {
              const element = await nextItem.value;
              result[index] = await mapper(element, index);
              resolvingCount--;
              next();
            } catch (error) {
              if (stopOnError) {
                isRejected = true;
                reject(error);
              } else {
                errors.push(error);
                resolvingCount--;
                next();
              }
            }
          })();
        };
        for (let i = 0; i < concurrency; i++) {
          next();
          if (isIterableDone) {
            break;
          }
        }
      });
    };
  });
  var require_p_filter = __commonJS((exports2, module2) => {
    "use strict";
    var pMap = require_p_map();
    var pFilter = async (iterable, filterer, options) => {
      const values = await pMap(iterable, (element, index) => Promise.all([filterer(element, index), element]), options);
      return values.filter((value) => Boolean(value[0])).map((value) => value[1]);
    };
    module2.exports = pFilter;
    module2.exports.default = pFilter;
  });
  var require_temp_dir = __commonJS((exports2, module2) => {
    "use strict";
    var fs2 = require("fs");
    var os2 = require("os");
    var tempDirectorySymbol = Symbol.for("__RESOLVED_TEMP_DIRECTORY__");
    if (!global[tempDirectorySymbol]) {
      Object.defineProperty(global, tempDirectorySymbol, {
        value: fs2.realpathSync(os2.tmpdir())
      });
    }
    module2.exports = global[tempDirectorySymbol];
  });
  var require_chmod = __commonJS((exports2) => {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m2[k];
      }});
    } : function(o, m2, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m2[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    var fs2 = __importStar(require("fs"));
    function default_1(file) {
      const s2 = fs2.statSync(file);
      const newMode = s2.mode | 64 | 8 | 1;
      if (s2.mode === newMode)
        return;
      const base8 = newMode.toString(8).slice(-3);
      fs2.chmodSync(file, base8);
    }
    exports2.default = default_1;
  });
  var require_commondir = __commonJS((exports2, module2) => {
    var path22 = require("path");
    module2.exports = function(basedir, relfiles) {
      if (relfiles) {
        var files = relfiles.map(function(r) {
          return path22.resolve(basedir, r);
        });
      } else {
        var files = basedir;
      }
      var res = files.slice(1).reduce(function(ps, file) {
        if (!file.match(/^([A-Za-z]:)?\/|\\/)) {
          throw new Error("relative path without a basedir");
        }
        var xs = file.split(/\/+|\\+/);
        for (var i = 0; ps[i] === xs[i] && i < Math.min(ps.length, xs.length); i++)
          ;
        return ps.slice(0, i);
      }, files[0].split(/\/+|\\+/));
      return res.length > 1 ? res.join("/") : "/";
    };
  });
  var require_p_try = __commonJS((exports2, module2) => {
    "use strict";
    var pTry = (fn, ...arguments_) => new Promise((resolve) => {
      resolve(fn(...arguments_));
    });
    module2.exports = pTry;
    module2.exports.default = pTry;
  });
  var require_p_limit = __commonJS((exports2, module2) => {
    "use strict";
    var pTry = require_p_try();
    var pLimit = (concurrency) => {
      if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
        return Promise.reject(new TypeError("Expected `concurrency` to be a number from 1 and up"));
      }
      const queue = [];
      let activeCount = 0;
      const next = () => {
        activeCount--;
        if (queue.length > 0) {
          queue.shift()();
        }
      };
      const run = (fn, resolve, ...args) => {
        activeCount++;
        const result = pTry(fn, ...args);
        resolve(result);
        result.then(next, next);
      };
      const enqueue = (fn, resolve, ...args) => {
        if (activeCount < concurrency) {
          run(fn, resolve, ...args);
        } else {
          queue.push(run.bind(null, fn, resolve, ...args));
        }
      };
      const generator = (fn, ...args) => new Promise((resolve) => enqueue(fn, resolve, ...args));
      Object.defineProperties(generator, {
        activeCount: {
          get: () => activeCount
        },
        pendingCount: {
          get: () => queue.length
        },
        clearQueue: {
          value: () => {
            queue.length = 0;
          }
        }
      });
      return generator;
    };
    module2.exports = pLimit;
    module2.exports.default = pLimit;
  });
  var require_p_locate = __commonJS((exports2, module2) => {
    "use strict";
    var pLimit = require_p_limit();
    var EndError = class extends Error {
      constructor(value) {
        super();
        this.value = value;
      }
    };
    var testElement = async (element, tester) => tester(await element);
    var finder = async (element) => {
      const values = await Promise.all(element);
      if (values[1] === true) {
        throw new EndError(values[0]);
      }
      return false;
    };
    var pLocate = async (iterable, tester, options) => {
      options = {
        concurrency: Infinity,
        preserveOrder: true,
        ...options
      };
      const limit = pLimit(options.concurrency);
      const items = [...iterable].map((element) => [element, limit(testElement, element, tester)]);
      const checkLimit = pLimit(options.preserveOrder ? 1 : Infinity);
      try {
        await Promise.all(items.map((element) => checkLimit(finder, element)));
      } catch (error) {
        if (error instanceof EndError) {
          return error.value;
        }
        throw error;
      }
    };
    module2.exports = pLocate;
    module2.exports.default = pLocate;
  });
  var require_locate_path = __commonJS((exports2, module2) => {
    "use strict";
    var path22 = require("path");
    var fs2 = require("fs");
    var {promisify: promisify2} = require("util");
    var pLocate = require_p_locate();
    var fsStat = promisify2(fs2.stat);
    var fsLStat = promisify2(fs2.lstat);
    var typeMappings = {
      directory: "isDirectory",
      file: "isFile"
    };
    function checkType({type}) {
      if (type in typeMappings) {
        return;
      }
      throw new Error(`Invalid type specified: ${type}`);
    }
    var matchType = (type, stat2) => type === void 0 || stat2[typeMappings[type]]();
    module2.exports = async (paths, options) => {
      options = {
        cwd: process.cwd(),
        type: "file",
        allowSymlinks: true,
        ...options
      };
      checkType(options);
      const statFn = options.allowSymlinks ? fsStat : fsLStat;
      return pLocate(paths, async (path_) => {
        try {
          const stat2 = await statFn(path22.resolve(options.cwd, path_));
          return matchType(options.type, stat2);
        } catch (_2) {
          return false;
        }
      }, options);
    };
    module2.exports.sync = (paths, options) => {
      options = {
        cwd: process.cwd(),
        allowSymlinks: true,
        type: "file",
        ...options
      };
      checkType(options);
      const statFn = options.allowSymlinks ? fs2.statSync : fs2.lstatSync;
      for (const path_ of paths) {
        try {
          const stat2 = statFn(path22.resolve(options.cwd, path_));
          if (matchType(options.type, stat2)) {
            return path_;
          }
        } catch (_2) {
        }
      }
    };
  });
  var require_path_exists = __commonJS((exports2, module2) => {
    "use strict";
    var fs2 = require("fs");
    var {promisify: promisify2} = require("util");
    var pAccess = promisify2(fs2.access);
    module2.exports = async (path22) => {
      try {
        await pAccess(path22);
        return true;
      } catch (_2) {
        return false;
      }
    };
    module2.exports.sync = (path22) => {
      try {
        fs2.accessSync(path22);
        return true;
      } catch (_2) {
        return false;
      }
    };
  });
  var require_find_up = __commonJS((exports2, module2) => {
    "use strict";
    var path22 = require("path");
    var locatePath = require_locate_path();
    var pathExists = require_path_exists();
    var stop = Symbol("findUp.stop");
    module2.exports = async (name, options = {}) => {
      let directory = path22.resolve(options.cwd || "");
      const {root} = path22.parse(directory);
      const paths = [].concat(name);
      const runMatcher = async (locateOptions) => {
        if (typeof name !== "function") {
          return locatePath(paths, locateOptions);
        }
        const foundPath = await name(locateOptions.cwd);
        if (typeof foundPath === "string") {
          return locatePath([foundPath], locateOptions);
        }
        return foundPath;
      };
      while (true) {
        const foundPath = await runMatcher({...options, cwd: directory});
        if (foundPath === stop) {
          return;
        }
        if (foundPath) {
          return path22.resolve(directory, foundPath);
        }
        if (directory === root) {
          return;
        }
        directory = path22.dirname(directory);
      }
    };
    module2.exports.sync = (name, options = {}) => {
      let directory = path22.resolve(options.cwd || "");
      const {root} = path22.parse(directory);
      const paths = [].concat(name);
      const runMatcher = (locateOptions) => {
        if (typeof name !== "function") {
          return locatePath.sync(paths, locateOptions);
        }
        const foundPath = name(locateOptions.cwd);
        if (typeof foundPath === "string") {
          return locatePath.sync([foundPath], locateOptions);
        }
        return foundPath;
      };
      while (true) {
        const foundPath = runMatcher({...options, cwd: directory});
        if (foundPath === stop) {
          return;
        }
        if (foundPath) {
          return path22.resolve(directory, foundPath);
        }
        if (directory === root) {
          return;
        }
        directory = path22.dirname(directory);
      }
    };
    module2.exports.exists = pathExists;
    module2.exports.sync.exists = pathExists.sync;
    module2.exports.stop = stop;
  });
  var require_pkg_dir = __commonJS((exports2, module2) => {
    "use strict";
    var path22 = require("path");
    var findUp = require_find_up();
    var pkgDir = async (cwd) => {
      const filePath = await findUp("package.json", {cwd});
      return filePath && path22.dirname(filePath);
    };
    module2.exports = pkgDir;
    module2.exports.default = pkgDir;
    module2.exports.sync = (cwd) => {
      const filePath = findUp.sync("package.json", {cwd});
      return filePath && path22.dirname(filePath);
    };
  });
  var require_find_cache_dir = __commonJS((exports2, module2) => {
    "use strict";
    var path22 = require("path");
    var fs2 = require("fs");
    var commonDir = require_commondir();
    var pkgDir = require_pkg_dir();
    var makeDir2 = require_make_dir();
    var {env: env2, cwd} = process;
    var isWritable = (path32) => {
      try {
        fs2.accessSync(path32, fs2.constants.W_OK);
        return true;
      } catch (_2) {
        return false;
      }
    };
    function useDirectory(directory, options) {
      if (options.create) {
        makeDir2.sync(directory);
      }
      if (options.thunk) {
        return (...arguments_) => path22.join(directory, ...arguments_);
      }
      return directory;
    }
    function getNodeModuleDirectory(directory) {
      const nodeModules = path22.join(directory, "node_modules");
      if (!isWritable(nodeModules) && (fs2.existsSync(nodeModules) || !isWritable(path22.join(directory)))) {
        return;
      }
      return nodeModules;
    }
    module2.exports = (options = {}) => {
      if (env2.CACHE_DIR && !["true", "false", "1", "0"].includes(env2.CACHE_DIR)) {
        return useDirectory(path22.join(env2.CACHE_DIR, "find-cache-dir"), options);
      }
      let {cwd: directory = cwd()} = options;
      if (options.files) {
        directory = commonDir(directory, options.files);
      }
      directory = pkgDir.sync(directory);
      if (!directory) {
        return;
      }
      const nodeModules = getNodeModuleDirectory(directory);
      if (!nodeModules) {
        return void 0;
      }
      return useDirectory(path22.join(directory, "node_modules", ".cache", options.name), options);
    };
  });
  var require_util2 = __commonJS((exports2) => {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : {default: mod2};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.getDownloadUrl = exports2.getCacheDir = exports2.getRootCacheDir = void 0;
    var debug_12 = __importDefault2(require_dist());
    var get_platform_12 = require_dist2();
    var find_cache_dir_1 = __importDefault2(require_find_cache_dir());
    var fs_12 = __importDefault2(require("fs"));
    var make_dir_12 = __importDefault2(require_make_dir());
    var os_1 = __importDefault2(require("os"));
    var path_12 = __importDefault2(require("path"));
    var download_1 = require_download();
    var debug32 = debug_12.default("prisma:cache-dir");
    async function getRootCacheDir() {
      if (os_1.default.platform() === "win32") {
        const cacheDir = find_cache_dir_1.default({name: "prisma", create: true});
        if (cacheDir) {
          return cacheDir;
        }
        if (process.env.APPDATA) {
          return path_12.default.join(process.env.APPDATA, "Prisma");
        }
      }
      if (process.env.AWS_LAMBDA_FUNCTION_VERSION) {
        try {
          await make_dir_12.default(`/tmp/prisma-download`);
          return `/tmp/prisma-download`;
        } catch (e) {
          return null;
        }
      }
      return path_12.default.join(os_1.default.homedir(), ".cache/prisma");
    }
    exports2.getRootCacheDir = getRootCacheDir;
    async function getCacheDir(channel2, version, platform) {
      const rootCacheDir = await getRootCacheDir();
      if (!rootCacheDir) {
        return null;
      }
      const cacheDir = path_12.default.join(rootCacheDir, channel2, version, platform);
      try {
        if (!fs_12.default.existsSync(cacheDir)) {
          await make_dir_12.default(cacheDir);
        }
      } catch (e) {
        debug32("The following error is being caught and just there for debugging:");
        debug32(e);
        return null;
      }
      return cacheDir;
    }
    exports2.getCacheDir = getCacheDir;
    function getDownloadUrl(channel2, version, platform, binaryName, extension = ".gz") {
      const baseUrl = process.env.PRISMA_BINARIES_MIRROR || "https://binaries.prisma.sh";
      const finalExtension = platform === "windows" && download_1.BinaryType.libqueryEngine !== binaryName ? `.exe${extension}` : extension;
      if (binaryName === download_1.BinaryType.libqueryEngine) {
        binaryName = get_platform_12.getNodeAPIName(platform, "url");
      }
      return `${baseUrl}/${channel2}/${version}/${platform}/${binaryName}${finalExtension}`;
    }
    exports2.getDownloadUrl = getDownloadUrl;
  });
  var require_old = __commonJS((exports2) => {
    var pathModule = require("path");
    var isWindows = process.platform === "win32";
    var fs2 = require("fs");
    var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
    function rethrow() {
      var callback;
      if (DEBUG) {
        var backtrace = new Error();
        callback = debugCallback;
      } else
        callback = missingCallback;
      return callback;
      function debugCallback(err) {
        if (err) {
          backtrace.message = err.message;
          err = backtrace;
          missingCallback(err);
        }
      }
      function missingCallback(err) {
        if (err) {
          if (process.throwDeprecation)
            throw err;
          else if (!process.noDeprecation) {
            var msg = "fs: missing callback " + (err.stack || err.message);
            if (process.traceDeprecation)
              console.trace(msg);
            else
              console.error(msg);
          }
        }
      }
    }
    function maybeCallback(cb) {
      return typeof cb === "function" ? cb : rethrow();
    }
    var normalize = pathModule.normalize;
    if (isWindows) {
      nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
    } else {
      nextPartRe = /(.*?)(?:[\/]+|$)/g;
    }
    var nextPartRe;
    if (isWindows) {
      splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
    } else {
      splitRootRe = /^[\/]*/;
    }
    var splitRootRe;
    exports2.realpathSync = function realpathSync(p, cache) {
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return cache[p];
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m2 = splitRootRe.exec(p);
        pos = m2[0].length;
        current = m2[0];
        base = m2[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs2.lstatSync(base);
          knownHard[base] = true;
        }
      }
      while (pos < p.length) {
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          continue;
        }
        var resolvedLink;
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          resolvedLink = cache[base];
        } else {
          var stat2 = fs2.lstatSync(base);
          if (!stat2.isSymbolicLink()) {
            knownHard[base] = true;
            if (cache)
              cache[base] = base;
            continue;
          }
          var linkTarget = null;
          if (!isWindows) {
            var id = stat2.dev.toString(32) + ":" + stat2.ino.toString(32);
            if (seenLinks.hasOwnProperty(id)) {
              linkTarget = seenLinks[id];
            }
          }
          if (linkTarget === null) {
            fs2.statSync(base);
            linkTarget = fs2.readlinkSync(base);
          }
          resolvedLink = pathModule.resolve(previous, linkTarget);
          if (cache)
            cache[base] = resolvedLink;
          if (!isWindows)
            seenLinks[id] = linkTarget;
        }
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
      if (cache)
        cache[original] = p;
      return p;
    };
    exports2.realpath = function realpath(p, cache, cb) {
      if (typeof cb !== "function") {
        cb = maybeCallback(cache);
        cache = null;
      }
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return process.nextTick(cb.bind(null, null, cache[p]));
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m2 = splitRootRe.exec(p);
        pos = m2[0].length;
        current = m2[0];
        base = m2[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs2.lstat(base, function(err) {
            if (err)
              return cb(err);
            knownHard[base] = true;
            LOOP();
          });
        } else {
          process.nextTick(LOOP);
        }
      }
      function LOOP() {
        if (pos >= p.length) {
          if (cache)
            cache[original] = p;
          return cb(null, p);
        }
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          return process.nextTick(LOOP);
        }
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          return gotResolvedLink(cache[base]);
        }
        return fs2.lstat(base, gotStat);
      }
      function gotStat(err, stat2) {
        if (err)
          return cb(err);
        if (!stat2.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache)
            cache[base] = base;
          return process.nextTick(LOOP);
        }
        if (!isWindows) {
          var id = stat2.dev.toString(32) + ":" + stat2.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            return gotTarget(null, seenLinks[id], base);
          }
        }
        fs2.stat(base, function(err2) {
          if (err2)
            return cb(err2);
          fs2.readlink(base, function(err3, target) {
            if (!isWindows)
              seenLinks[id] = target;
            gotTarget(err3, target);
          });
        });
      }
      function gotTarget(err, target, base2) {
        if (err)
          return cb(err);
        var resolvedLink = pathModule.resolve(previous, target);
        if (cache)
          cache[base2] = resolvedLink;
        gotResolvedLink(resolvedLink);
      }
      function gotResolvedLink(resolvedLink) {
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
    };
  });
  var require_fs = __commonJS((exports2, module2) => {
    module2.exports = realpath;
    realpath.realpath = realpath;
    realpath.sync = realpathSync;
    realpath.realpathSync = realpathSync;
    realpath.monkeypatch = monkeypatch;
    realpath.unmonkeypatch = unmonkeypatch;
    var fs2 = require("fs");
    var origRealpath = fs2.realpath;
    var origRealpathSync = fs2.realpathSync;
    var version = process.version;
    var ok = /^v[0-5]\./.test(version);
    var old = require_old();
    function newError(er) {
      return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
    }
    function realpath(p, cache, cb) {
      if (ok) {
        return origRealpath(p, cache, cb);
      }
      if (typeof cache === "function") {
        cb = cache;
        cache = null;
      }
      origRealpath(p, cache, function(er, result) {
        if (newError(er)) {
          old.realpath(p, cache, cb);
        } else {
          cb(er, result);
        }
      });
    }
    function realpathSync(p, cache) {
      if (ok) {
        return origRealpathSync(p, cache);
      }
      try {
        return origRealpathSync(p, cache);
      } catch (er) {
        if (newError(er)) {
          return old.realpathSync(p, cache);
        } else {
          throw er;
        }
      }
    }
    function monkeypatch() {
      fs2.realpath = realpath;
      fs2.realpathSync = realpathSync;
    }
    function unmonkeypatch() {
      fs2.realpath = origRealpath;
      fs2.realpathSync = origRealpathSync;
    }
  });
  var require_concat_map = __commonJS((exports2, module2) => {
    module2.exports = function(xs, fn) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x))
          res.push.apply(res, x);
        else
          res.push(x);
      }
      return res;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  });
  var require_balanced_match = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m2 = str.match(reg);
      return m2 ? m2[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  });
  var require_brace_expansion = __commonJS((exports2, module2) => {
    var concatMap = require_concat_map();
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m2 = balanced("{", "}", str);
      if (!m2)
        return str.split(",");
      var pre = m2.pre;
      var body = m2.body;
      var post = m2.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y2) {
      return i <= y2;
    }
    function gte(i, y2) {
      return i >= y2;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m2 = balanced("{", "}", str);
      if (!m2 || /\$$/.test(m2.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m2.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m2.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m2.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m2.post.match(/,.*\}/)) {
          str = m2.pre + "{" + m2.body + escClose + m2.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m2.body.split(/\.\./);
      } else {
        n = parseCommaParts(m2.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m2.post.length ? expand(m2.post, false) : [""];
            return post.map(function(p) {
              return m2.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m2.pre;
      var post = m2.post.length ? expand(m2.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y2 = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y2 < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y2); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  });
  var require_minimatch = __commonJS((exports2, module2) => {
    module2.exports = minimatch;
    minimatch.Minimatch = Minimatch;
    var path22 = {sep: "/"};
    try {
      path22 = require("path");
    } catch (er) {
    }
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand = require_brace_expansion();
    var plTypes = {
      "!": {open: "(?:(?!(?:", close: "))[^/]*?)"},
      "?": {open: "(?:", close: ")?"},
      "+": {open: "(?:", close: ")+"},
      "*": {open: "(?:", close: ")*"},
      "@": {open: "(?:", close: ")"}
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s2) {
      return s2.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter;
    function filter(pattern, options) {
      options = options || {};
      return function(p, i, list) {
        return minimatch(p, pattern, options);
      };
    }
    function ext(a, b) {
      a = a || {};
      b = b || {};
      var t = {};
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      return t;
    }
    minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return minimatch;
      var orig = minimatch;
      var m2 = function minimatch2(p, pattern, options) {
        return orig.minimatch(p, pattern, ext(def, options));
      };
      m2.Minimatch = function Minimatch2(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      return m2;
    };
    Minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return Minimatch;
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options)
        options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      if (pattern.trim() === "")
        return p === "";
      return new Minimatch(pattern, options).match(p);
    }
    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
      }
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options)
        options = {};
      pattern = pattern.trim();
      if (path22.sep !== "/") {
        pattern = pattern.split(path22.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      if (this._made)
        return;
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = console.error;
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s2) {
        return s2.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s2, si, set2) {
        return s2.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s2) {
        return s2.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate)
        return;
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch.braceExpand = function(pattern, options) {
      return braceExpand(pattern, options);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      if (typeof pattern === "undefined") {
        throw new TypeError("undefined pattern");
      }
      if (options.nobrace || !pattern.match(/\{.*\}/)) {
        return [pattern];
      }
      return expand(pattern);
    }
    Minimatch.prototype.parse = parse2;
    var SUBPARSE = {};
    function parse2(pattern, isSub) {
      if (pattern.length > 1024 * 64) {
        throw new TypeError("pattern is too long");
      }
      var options = this.options;
      if (!options.noglobstar && pattern === "**")
        return GLOBSTAR;
      if (pattern === "")
        return "";
      var re = "";
      var hasMagic = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self2 = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self2.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/":
            return false;
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            self2.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            if (inClass) {
              var cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + cs + "]");
              } catch (er) {
                var sp = this.parse(cs, SUBPARSE);
                re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                hasMagic = hasMagic || sp[1];
                inClass = false;
                continue;
              }
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_2, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case ".":
        case "[":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      var flags = options.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch.match = function(list, pattern, options) {
      options = options || {};
      var mm = new Minimatch(pattern, options);
      list = list.filter(function(f) {
        return mm.match(f);
      });
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch.prototype.match = match;
    function match(f, partial) {
      this.debug("match", f, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      var options = this.options;
      if (path22.sep !== "/") {
        f = f.split(path22.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename)
          break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    }
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options = this.options;
      this.debug("matchOne", {this: this, file, pattern});
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          if (options.nocase) {
            hit = f.toLowerCase() === p.toLowerCase();
          } else {
            hit = f === p;
          }
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        var emptyFileEnd = fi === fl - 1 && file[fi] === "";
        return emptyFileEnd;
      }
      throw new Error("wtf?");
    };
    function globUnescape(s2) {
      return s2.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s2) {
      return s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  });
  var require_inherits_browser = __commonJS((exports2, module2) => {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  });
  var require_inherits = __commonJS((exports2, module2) => {
    try {
      util2 = require("util");
      if (typeof util2.inherits !== "function")
        throw "";
      module2.exports = util2.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util2;
  });
  var require_path_is_absolute = __commonJS((exports2, module2) => {
    "use strict";
    function posix(path22) {
      return path22.charAt(0) === "/";
    }
    function win32(path22) {
      var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
      var result = splitDeviceRe.exec(path22);
      var device = result[1] || "";
      var isUnc = Boolean(device && device.charAt(1) !== ":");
      return Boolean(result[2] || isUnc);
    }
    module2.exports = process.platform === "win32" ? win32 : posix;
    module2.exports.posix = posix;
    module2.exports.win32 = win32;
  });
  var require_common3 = __commonJS((exports2) => {
    exports2.alphasort = alphasort;
    exports2.alphasorti = alphasorti;
    exports2.setopts = setopts;
    exports2.ownProp = ownProp;
    exports2.makeAbs = makeAbs;
    exports2.finish = finish;
    exports2.mark = mark;
    exports2.isIgnored = isIgnored;
    exports2.childrenIgnored = childrenIgnored;
    function ownProp(obj, field) {
      return Object.prototype.hasOwnProperty.call(obj, field);
    }
    var path22 = require("path");
    var minimatch = require_minimatch();
    var isAbsolute = require_path_is_absolute();
    var Minimatch = minimatch.Minimatch;
    function alphasorti(a, b) {
      return a.toLowerCase().localeCompare(b.toLowerCase());
    }
    function alphasort(a, b) {
      return a.localeCompare(b);
    }
    function setupIgnores(self2, options) {
      self2.ignore = options.ignore || [];
      if (!Array.isArray(self2.ignore))
        self2.ignore = [self2.ignore];
      if (self2.ignore.length) {
        self2.ignore = self2.ignore.map(ignoreMap);
      }
    }
    function ignoreMap(pattern) {
      var gmatcher = null;
      if (pattern.slice(-3) === "/**") {
        var gpattern = pattern.replace(/(\/\*\*)+$/, "");
        gmatcher = new Minimatch(gpattern, {dot: true});
      }
      return {
        matcher: new Minimatch(pattern, {dot: true}),
        gmatcher
      };
    }
    function setopts(self2, pattern, options) {
      if (!options)
        options = {};
      if (options.matchBase && pattern.indexOf("/") === -1) {
        if (options.noglobstar) {
          throw new Error("base matching requires globstar");
        }
        pattern = "**/" + pattern;
      }
      self2.silent = !!options.silent;
      self2.pattern = pattern;
      self2.strict = options.strict !== false;
      self2.realpath = !!options.realpath;
      self2.realpathCache = options.realpathCache || Object.create(null);
      self2.follow = !!options.follow;
      self2.dot = !!options.dot;
      self2.mark = !!options.mark;
      self2.nodir = !!options.nodir;
      if (self2.nodir)
        self2.mark = true;
      self2.sync = !!options.sync;
      self2.nounique = !!options.nounique;
      self2.nonull = !!options.nonull;
      self2.nosort = !!options.nosort;
      self2.nocase = !!options.nocase;
      self2.stat = !!options.stat;
      self2.noprocess = !!options.noprocess;
      self2.absolute = !!options.absolute;
      self2.maxLength = options.maxLength || Infinity;
      self2.cache = options.cache || Object.create(null);
      self2.statCache = options.statCache || Object.create(null);
      self2.symlinks = options.symlinks || Object.create(null);
      setupIgnores(self2, options);
      self2.changedCwd = false;
      var cwd = process.cwd();
      if (!ownProp(options, "cwd"))
        self2.cwd = cwd;
      else {
        self2.cwd = path22.resolve(options.cwd);
        self2.changedCwd = self2.cwd !== cwd;
      }
      self2.root = options.root || path22.resolve(self2.cwd, "/");
      self2.root = path22.resolve(self2.root);
      if (process.platform === "win32")
        self2.root = self2.root.replace(/\\/g, "/");
      self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
      if (process.platform === "win32")
        self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
      self2.nomount = !!options.nomount;
      options.nonegate = true;
      options.nocomment = true;
      self2.minimatch = new Minimatch(pattern, options);
      self2.options = self2.minimatch.options;
    }
    function finish(self2) {
      var nou = self2.nounique;
      var all = nou ? [] : Object.create(null);
      for (var i = 0, l = self2.matches.length; i < l; i++) {
        var matches = self2.matches[i];
        if (!matches || Object.keys(matches).length === 0) {
          if (self2.nonull) {
            var literal = self2.minimatch.globSet[i];
            if (nou)
              all.push(literal);
            else
              all[literal] = true;
          }
        } else {
          var m2 = Object.keys(matches);
          if (nou)
            all.push.apply(all, m2);
          else
            m2.forEach(function(m22) {
              all[m22] = true;
            });
        }
      }
      if (!nou)
        all = Object.keys(all);
      if (!self2.nosort)
        all = all.sort(self2.nocase ? alphasorti : alphasort);
      if (self2.mark) {
        for (var i = 0; i < all.length; i++) {
          all[i] = self2._mark(all[i]);
        }
        if (self2.nodir) {
          all = all.filter(function(e) {
            var notDir = !/\/$/.test(e);
            var c = self2.cache[e] || self2.cache[makeAbs(self2, e)];
            if (notDir && c)
              notDir = c !== "DIR" && !Array.isArray(c);
            return notDir;
          });
        }
      }
      if (self2.ignore.length)
        all = all.filter(function(m22) {
          return !isIgnored(self2, m22);
        });
      self2.found = all;
    }
    function mark(self2, p) {
      var abs2 = makeAbs(self2, p);
      var c = self2.cache[abs2];
      var m2 = p;
      if (c) {
        var isDir = c === "DIR" || Array.isArray(c);
        var slash = p.slice(-1) === "/";
        if (isDir && !slash)
          m2 += "/";
        else if (!isDir && slash)
          m2 = m2.slice(0, -1);
        if (m2 !== p) {
          var mabs = makeAbs(self2, m2);
          self2.statCache[mabs] = self2.statCache[abs2];
          self2.cache[mabs] = self2.cache[abs2];
        }
      }
      return m2;
    }
    function makeAbs(self2, f) {
      var abs2 = f;
      if (f.charAt(0) === "/") {
        abs2 = path22.join(self2.root, f);
      } else if (isAbsolute(f) || f === "") {
        abs2 = f;
      } else if (self2.changedCwd) {
        abs2 = path22.resolve(self2.cwd, f);
      } else {
        abs2 = path22.resolve(f);
      }
      if (process.platform === "win32")
        abs2 = abs2.replace(/\\/g, "/");
      return abs2;
    }
    function isIgnored(self2, path32) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return item.matcher.match(path32) || !!(item.gmatcher && item.gmatcher.match(path32));
      });
    }
    function childrenIgnored(self2, path32) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path32));
      });
    }
  });
  var require_sync = __commonJS((exports2, module2) => {
    module2.exports = globSync;
    globSync.GlobSync = GlobSync;
    var fs2 = require("fs");
    var rp = require_fs();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var Glob = require_glob().Glob;
    var util2 = require("util");
    var path22 = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var common = require_common3();
    var alphasort = common.alphasort;
    var alphasorti = common.alphasorti;
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    function globSync(pattern, options) {
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      return new GlobSync(pattern, options).found;
    }
    function GlobSync(pattern, options) {
      if (!pattern)
        throw new Error("must provide pattern");
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      if (!(this instanceof GlobSync))
        return new GlobSync(pattern, options);
      setopts(this, pattern, options);
      if (this.noprocess)
        return this;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false);
      }
      this._finish();
    }
    GlobSync.prototype._finish = function() {
      assert(this instanceof GlobSync);
      if (this.realpath) {
        var self2 = this;
        this.matches.forEach(function(matchset, index) {
          var set = self2.matches[index] = Object.create(null);
          for (var p in matchset) {
            try {
              p = self2._makeAbs(p);
              var real = rp.realpathSync(p, self2.realpathCache);
              set[real] = true;
            } catch (er) {
              if (er.syscall === "stat")
                set[self2._makeAbs(p)] = true;
              else
                throw er;
            }
          }
        });
      }
      common.finish(this);
    };
    GlobSync.prototype._process = function(pattern, index, inGlobStar) {
      assert(this instanceof GlobSync);
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs2 = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return;
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs2, remain, index, inGlobStar);
      else
        this._processReaddir(prefix, read, abs2, remain, index, inGlobStar);
    };
    GlobSync.prototype._processReaddir = function(prefix, read, abs2, remain, index, inGlobStar) {
      var entries = this._readdir(abs2, inGlobStar);
      if (!entries)
        return;
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m2;
          if (negate && !prefix) {
            m2 = !e.match(pn);
          } else {
            m2 = e.match(pn);
          }
          if (m2)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return;
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix.slice(-1) !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path22.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return;
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix)
          newPattern = [prefix, e];
        else
          newPattern = [e];
        this._process(newPattern.concat(remain), index, inGlobStar);
      }
    };
    GlobSync.prototype._emitMatch = function(index, e) {
      if (isIgnored(this, e))
        return;
      var abs2 = this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute) {
        e = abs2;
      }
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs2];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      if (this.stat)
        this._stat(e);
    };
    GlobSync.prototype._readdirInGlobStar = function(abs2) {
      if (this.follow)
        return this._readdir(abs2, false);
      var entries;
      var lstat;
      var stat2;
      try {
        lstat = fs2.lstatSync(abs2);
      } catch (er) {
        if (er.code === "ENOENT") {
          return null;
        }
      }
      var isSym = lstat && lstat.isSymbolicLink();
      this.symlinks[abs2] = isSym;
      if (!isSym && lstat && !lstat.isDirectory())
        this.cache[abs2] = "FILE";
      else
        entries = this._readdir(abs2, false);
      return entries;
    };
    GlobSync.prototype._readdir = function(abs2, inGlobStar) {
      var entries;
      if (inGlobStar && !ownProp(this.symlinks, abs2))
        return this._readdirInGlobStar(abs2);
      if (ownProp(this.cache, abs2)) {
        var c = this.cache[abs2];
        if (!c || c === "FILE")
          return null;
        if (Array.isArray(c))
          return c;
      }
      try {
        return this._readdirEntries(abs2, fs2.readdirSync(abs2));
      } catch (er) {
        this._readdirError(abs2, er);
        return null;
      }
    };
    GlobSync.prototype._readdirEntries = function(abs2, entries) {
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs2 === "/")
            e = abs2 + e;
          else
            e = abs2 + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs2] = entries;
      return entries;
    };
    GlobSync.prototype._readdirError = function(f, er) {
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs2 = this._makeAbs(f);
          this.cache[abs2] = "FILE";
          if (abs2 === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            throw error;
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict)
            throw er;
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
    };
    GlobSync.prototype._processGlobStar = function(prefix, read, abs2, remain, index, inGlobStar) {
      var entries = this._readdir(abs2, inGlobStar);
      if (!entries)
        return;
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false);
      var len = entries.length;
      var isSym = this.symlinks[abs2];
      if (isSym && inGlobStar)
        return;
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true);
      }
    };
    GlobSync.prototype._processSimple = function(prefix, index) {
      var exists2 = this._stat(prefix);
      if (!this.matches[index])
        this.matches[index] = Object.create(null);
      if (!exists2)
        return;
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path22.join(this.root, prefix);
        } else {
          prefix = path22.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
    };
    GlobSync.prototype._stat = function(f) {
      var abs2 = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return false;
      if (!this.stat && ownProp(this.cache, abs2)) {
        var c = this.cache[abs2];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return c;
        if (needDir && c === "FILE")
          return false;
      }
      var exists2;
      var stat2 = this.statCache[abs2];
      if (!stat2) {
        var lstat;
        try {
          lstat = fs2.lstatSync(abs2);
        } catch (er) {
          if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
            this.statCache[abs2] = false;
            return false;
          }
        }
        if (lstat && lstat.isSymbolicLink()) {
          try {
            stat2 = fs2.statSync(abs2);
          } catch (er) {
            stat2 = lstat;
          }
        } else {
          stat2 = lstat;
        }
      }
      this.statCache[abs2] = stat2;
      var c = true;
      if (stat2)
        c = stat2.isDirectory() ? "DIR" : "FILE";
      this.cache[abs2] = this.cache[abs2] || c;
      if (needDir && c === "FILE")
        return false;
      return c;
    };
    GlobSync.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    GlobSync.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
  });
  var require_wrappy = __commonJS((exports2, module2) => {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  });
  var require_once = __commonJS((exports2, module2) => {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once);
    module2.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  });
  var require_inflight = __commonJS((exports2, module2) => {
    var wrappy = require_wrappy();
    var reqs = Object.create(null);
    var once = require_once();
    module2.exports = wrappy(inflight);
    function inflight(key, cb) {
      if (reqs[key]) {
        reqs[key].push(cb);
        return null;
      } else {
        reqs[key] = [cb];
        return makeres(key);
      }
    }
    function makeres(key) {
      return once(function RES() {
        var cbs = reqs[key];
        var len = cbs.length;
        var args = slice(arguments);
        try {
          for (var i = 0; i < len; i++) {
            cbs[i].apply(null, args);
          }
        } finally {
          if (cbs.length > len) {
            cbs.splice(0, len);
            process.nextTick(function() {
              RES.apply(null, args);
            });
          } else {
            delete reqs[key];
          }
        }
      });
    }
    function slice(args) {
      var length = args.length;
      var array = [];
      for (var i = 0; i < length; i++)
        array[i] = args[i];
      return array;
    }
  });
  var require_glob = __commonJS((exports2, module2) => {
    module2.exports = glob;
    var fs2 = require("fs");
    var rp = require_fs();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var inherits = require_inherits();
    var EE = require("events").EventEmitter;
    var path22 = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var globSync = require_sync();
    var common = require_common3();
    var alphasort = common.alphasort;
    var alphasorti = common.alphasorti;
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var inflight = require_inflight();
    var util2 = require("util");
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    var once = require_once();
    function glob(pattern, options, cb) {
      if (typeof options === "function")
        cb = options, options = {};
      if (!options)
        options = {};
      if (options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return globSync(pattern, options);
      }
      return new Glob(pattern, options, cb);
    }
    glob.sync = globSync;
    var GlobSync = glob.GlobSync = globSync.GlobSync;
    glob.glob = glob;
    function extend(origin, add2) {
      if (add2 === null || typeof add2 !== "object") {
        return origin;
      }
      var keys = Object.keys(add2);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add2[keys[i]];
      }
      return origin;
    }
    glob.hasMagic = function(pattern, options_) {
      var options = extend({}, options_);
      options.noprocess = true;
      var g = new Glob(pattern, options);
      var set = g.minimatch.set;
      if (!pattern)
        return false;
      if (set.length > 1)
        return true;
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== "string")
          return true;
      }
      return false;
    };
    glob.Glob = Glob;
    inherits(Glob, EE);
    function Glob(pattern, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      if (options && options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return new GlobSync(pattern, options);
      }
      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb);
      setopts(this, pattern, options);
      this._didRealPath = false;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      if (typeof cb === "function") {
        cb = once(cb);
        this.on("error", cb);
        this.on("end", function(matches) {
          cb(null, matches);
        });
      }
      var self2 = this;
      this._processing = 0;
      this._emitQueue = [];
      this._processQueue = [];
      this.paused = false;
      if (this.noprocess)
        return this;
      if (n === 0)
        return done();
      var sync2 = true;
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false, done);
      }
      sync2 = false;
      function done() {
        --self2._processing;
        if (self2._processing <= 0) {
          if (sync2) {
            process.nextTick(function() {
              self2._finish();
            });
          } else {
            self2._finish();
          }
        }
      }
    }
    Glob.prototype._finish = function() {
      assert(this instanceof Glob);
      if (this.aborted)
        return;
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common.finish(this);
      this.emit("end", this.found);
    };
    Glob.prototype._realpath = function() {
      if (this._didRealpath)
        return;
      this._didRealpath = true;
      var n = this.matches.length;
      if (n === 0)
        return this._finish();
      var self2 = this;
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next);
      function next() {
        if (--n === 0)
          self2._finish();
      }
    };
    Glob.prototype._realpathSet = function(index, cb) {
      var matchset = this.matches[index];
      if (!matchset)
        return cb();
      var found = Object.keys(matchset);
      var self2 = this;
      var n = found.length;
      if (n === 0)
        return cb();
      var set = this.matches[index] = Object.create(null);
      found.forEach(function(p, i) {
        p = self2._makeAbs(p);
        rp.realpath(p, self2.realpathCache, function(er, real) {
          if (!er)
            set[real] = true;
          else if (er.syscall === "stat")
            set[p] = true;
          else
            self2.emit("error", er);
          if (--n === 0) {
            self2.matches[index] = set;
            cb();
          }
        });
      });
    };
    Glob.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    Glob.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
    Glob.prototype.abort = function() {
      this.aborted = true;
      this.emit("abort");
    };
    Glob.prototype.pause = function() {
      if (!this.paused) {
        this.paused = true;
        this.emit("pause");
      }
    };
    Glob.prototype.resume = function() {
      if (this.paused) {
        this.emit("resume");
        this.paused = false;
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0);
          this._emitQueue.length = 0;
          for (var i = 0; i < eq.length; i++) {
            var e = eq[i];
            this._emitMatch(e[0], e[1]);
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0);
          this._processQueue.length = 0;
          for (var i = 0; i < pq.length; i++) {
            var p = pq[i];
            this._processing--;
            this._process(p[0], p[1], p[2], p[3]);
          }
        }
      }
    };
    Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
      assert(this instanceof Glob);
      assert(typeof cb === "function");
      if (this.aborted)
        return;
      this._processing++;
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb]);
        return;
      }
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index, cb);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs2 = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return cb();
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs2, remain, index, inGlobStar, cb);
      else
        this._processReaddir(prefix, read, abs2, remain, index, inGlobStar, cb);
    };
    Glob.prototype._processReaddir = function(prefix, read, abs2, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs2, inGlobStar, function(er, entries) {
        return self2._processReaddir2(prefix, read, abs2, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processReaddir2 = function(prefix, read, abs2, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m2;
          if (negate && !prefix) {
            m2 = !e.match(pn);
          } else {
            m2 = e.match(pn);
          }
          if (m2)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return cb();
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path22.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return cb();
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        this._process([e].concat(remain), index, inGlobStar, cb);
      }
      cb();
    };
    Glob.prototype._emitMatch = function(index, e) {
      if (this.aborted)
        return;
      if (isIgnored(this, e))
        return;
      if (this.paused) {
        this._emitQueue.push([index, e]);
        return;
      }
      var abs2 = isAbsolute(e) ? e : this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute)
        e = abs2;
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs2];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      var st = this.statCache[abs2];
      if (st)
        this.emit("stat", e, st);
      this.emit("match", e);
    };
    Glob.prototype._readdirInGlobStar = function(abs2, cb) {
      if (this.aborted)
        return;
      if (this.follow)
        return this._readdir(abs2, false, cb);
      var lstatkey = "lstat\0" + abs2;
      var self2 = this;
      var lstatcb = inflight(lstatkey, lstatcb_);
      if (lstatcb)
        fs2.lstat(abs2, lstatcb);
      function lstatcb_(er, lstat) {
        if (er && er.code === "ENOENT")
          return cb();
        var isSym = lstat && lstat.isSymbolicLink();
        self2.symlinks[abs2] = isSym;
        if (!isSym && lstat && !lstat.isDirectory()) {
          self2.cache[abs2] = "FILE";
          cb();
        } else
          self2._readdir(abs2, false, cb);
      }
    };
    Glob.prototype._readdir = function(abs2, inGlobStar, cb) {
      if (this.aborted)
        return;
      cb = inflight("readdir\0" + abs2 + "\0" + inGlobStar, cb);
      if (!cb)
        return;
      if (inGlobStar && !ownProp(this.symlinks, abs2))
        return this._readdirInGlobStar(abs2, cb);
      if (ownProp(this.cache, abs2)) {
        var c = this.cache[abs2];
        if (!c || c === "FILE")
          return cb();
        if (Array.isArray(c))
          return cb(null, c);
      }
      var self2 = this;
      fs2.readdir(abs2, readdirCb(this, abs2, cb));
    };
    function readdirCb(self2, abs2, cb) {
      return function(er, entries) {
        if (er)
          self2._readdirError(abs2, er, cb);
        else
          self2._readdirEntries(abs2, entries, cb);
      };
    }
    Glob.prototype._readdirEntries = function(abs2, entries, cb) {
      if (this.aborted)
        return;
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs2 === "/")
            e = abs2 + e;
          else
            e = abs2 + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs2] = entries;
      return cb(null, entries);
    };
    Glob.prototype._readdirError = function(f, er, cb) {
      if (this.aborted)
        return;
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs2 = this._makeAbs(f);
          this.cache[abs2] = "FILE";
          if (abs2 === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            this.emit("error", error);
            this.abort();
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict) {
            this.emit("error", er);
            this.abort();
          }
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
      return cb();
    };
    Glob.prototype._processGlobStar = function(prefix, read, abs2, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs2, inGlobStar, function(er, entries) {
        self2._processGlobStar2(prefix, read, abs2, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processGlobStar2 = function(prefix, read, abs2, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false, cb);
      var isSym = this.symlinks[abs2];
      var len = entries.length;
      if (isSym && inGlobStar)
        return cb();
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true, cb);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true, cb);
      }
      cb();
    };
    Glob.prototype._processSimple = function(prefix, index, cb) {
      var self2 = this;
      this._stat(prefix, function(er, exists2) {
        self2._processSimple2(prefix, index, er, exists2, cb);
      });
    };
    Glob.prototype._processSimple2 = function(prefix, index, er, exists2, cb) {
      if (!this.matches[index])
        this.matches[index] = Object.create(null);
      if (!exists2)
        return cb();
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path22.join(this.root, prefix);
        } else {
          prefix = path22.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
      cb();
    };
    Glob.prototype._stat = function(f, cb) {
      var abs2 = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return cb();
      if (!this.stat && ownProp(this.cache, abs2)) {
        var c = this.cache[abs2];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return cb(null, c);
        if (needDir && c === "FILE")
          return cb();
      }
      var exists2;
      var stat2 = this.statCache[abs2];
      if (stat2 !== void 0) {
        if (stat2 === false)
          return cb(null, stat2);
        else {
          var type = stat2.isDirectory() ? "DIR" : "FILE";
          if (needDir && type === "FILE")
            return cb();
          else
            return cb(null, type, stat2);
        }
      }
      var self2 = this;
      var statcb = inflight("stat\0" + abs2, lstatcb_);
      if (statcb)
        fs2.lstat(abs2, statcb);
      function lstatcb_(er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          return fs2.stat(abs2, function(er2, stat22) {
            if (er2)
              self2._stat2(f, abs2, null, lstat, cb);
            else
              self2._stat2(f, abs2, er2, stat22, cb);
          });
        } else {
          self2._stat2(f, abs2, er, lstat, cb);
        }
      }
    };
    Glob.prototype._stat2 = function(f, abs2, er, stat2, cb) {
      if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
        this.statCache[abs2] = false;
        return cb();
      }
      var needDir = f.slice(-1) === "/";
      this.statCache[abs2] = stat2;
      if (abs2.slice(-1) === "/" && stat2 && !stat2.isDirectory())
        return cb(null, false, stat2);
      var c = true;
      if (stat2)
        c = stat2.isDirectory() ? "DIR" : "FILE";
      this.cache[abs2] = this.cache[abs2] || c;
      if (needDir && c === "FILE")
        return cb();
      return cb(null, c, stat2);
    };
  });
  var require_rimraf = __commonJS((exports2, module2) => {
    var assert = require("assert");
    var path22 = require("path");
    var fs2 = require("fs");
    var glob = void 0;
    try {
      glob = require_glob();
    } catch (_err) {
    }
    var defaultGlobOpts = {
      nosort: true,
      silent: true
    };
    var timeout = 0;
    var isWindows = process.platform === "win32";
    var defaults = (options) => {
      const methods = [
        "unlink",
        "chmod",
        "stat",
        "lstat",
        "rmdir",
        "readdir"
      ];
      methods.forEach((m2) => {
        options[m2] = options[m2] || fs2[m2];
        m2 = m2 + "Sync";
        options[m2] = options[m2] || fs2[m2];
      });
      options.maxBusyTries = options.maxBusyTries || 3;
      options.emfileWait = options.emfileWait || 1e3;
      if (options.glob === false) {
        options.disableGlob = true;
      }
      if (options.disableGlob !== true && glob === void 0) {
        throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");
      }
      options.disableGlob = options.disableGlob || false;
      options.glob = options.glob || defaultGlobOpts;
    };
    var rimraf = (p, options, cb) => {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      assert(p, "rimraf: missing path");
      assert.equal(typeof p, "string", "rimraf: path should be a string");
      assert.equal(typeof cb, "function", "rimraf: callback function required");
      assert(options, "rimraf: invalid options argument provided");
      assert.equal(typeof options, "object", "rimraf: options should be object");
      defaults(options);
      let busyTries = 0;
      let errState = null;
      let n = 0;
      const next = (er) => {
        errState = errState || er;
        if (--n === 0)
          cb(errState);
      };
      const afterGlob = (er, results) => {
        if (er)
          return cb(er);
        n = results.length;
        if (n === 0)
          return cb();
        results.forEach((p2) => {
          const CB = (er2) => {
            if (er2) {
              if ((er2.code === "EBUSY" || er2.code === "ENOTEMPTY" || er2.code === "EPERM") && busyTries < options.maxBusyTries) {
                busyTries++;
                return setTimeout(() => rimraf_(p2, options, CB), busyTries * 100);
              }
              if (er2.code === "EMFILE" && timeout < options.emfileWait) {
                return setTimeout(() => rimraf_(p2, options, CB), timeout++);
              }
              if (er2.code === "ENOENT")
                er2 = null;
            }
            timeout = 0;
            next(er2);
          };
          rimraf_(p2, options, CB);
        });
      };
      if (options.disableGlob || !glob.hasMagic(p))
        return afterGlob(null, [p]);
      options.lstat(p, (er, stat2) => {
        if (!er)
          return afterGlob(null, [p]);
        glob(p, options.glob, afterGlob);
      });
    };
    var rimraf_ = (p, options, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.lstat(p, (er, st) => {
        if (er && er.code === "ENOENT")
          return cb(null);
        if (er && er.code === "EPERM" && isWindows)
          fixWinEPERM(p, options, er, cb);
        if (st && st.isDirectory())
          return rmdir(p, options, er, cb);
        options.unlink(p, (er2) => {
          if (er2) {
            if (er2.code === "ENOENT")
              return cb(null);
            if (er2.code === "EPERM")
              return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
            if (er2.code === "EISDIR")
              return rmdir(p, options, er2, cb);
          }
          return cb(er2);
        });
      });
    };
    var fixWinEPERM = (p, options, er, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.chmod(p, 438, (er2) => {
        if (er2)
          cb(er2.code === "ENOENT" ? null : er);
        else
          options.stat(p, (er3, stats) => {
            if (er3)
              cb(er3.code === "ENOENT" ? null : er);
            else if (stats.isDirectory())
              rmdir(p, options, er, cb);
            else
              options.unlink(p, cb);
          });
      });
    };
    var fixWinEPERMSync = (p, options, er) => {
      assert(p);
      assert(options);
      try {
        options.chmodSync(p, 438);
      } catch (er2) {
        if (er2.code === "ENOENT")
          return;
        else
          throw er;
      }
      let stats;
      try {
        stats = options.statSync(p);
      } catch (er3) {
        if (er3.code === "ENOENT")
          return;
        else
          throw er;
      }
      if (stats.isDirectory())
        rmdirSync(p, options, er);
      else
        options.unlinkSync(p);
    };
    var rmdir = (p, options, originalEr, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.rmdir(p, (er) => {
        if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
          rmkids(p, options, cb);
        else if (er && er.code === "ENOTDIR")
          cb(originalEr);
        else
          cb(er);
      });
    };
    var rmkids = (p, options, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.readdir(p, (er, files) => {
        if (er)
          return cb(er);
        let n = files.length;
        if (n === 0)
          return options.rmdir(p, cb);
        let errState;
        files.forEach((f) => {
          rimraf(path22.join(p, f), options, (er2) => {
            if (errState)
              return;
            if (er2)
              return cb(errState = er2);
            if (--n === 0)
              options.rmdir(p, cb);
          });
        });
      });
    };
    var rimrafSync = (p, options) => {
      options = options || {};
      defaults(options);
      assert(p, "rimraf: missing path");
      assert.equal(typeof p, "string", "rimraf: path should be a string");
      assert(options, "rimraf: missing options");
      assert.equal(typeof options, "object", "rimraf: options should be object");
      let results;
      if (options.disableGlob || !glob.hasMagic(p)) {
        results = [p];
      } else {
        try {
          options.lstatSync(p);
          results = [p];
        } catch (er) {
          results = glob.sync(p, options.glob);
        }
      }
      if (!results.length)
        return;
      for (let i = 0; i < results.length; i++) {
        const p2 = results[i];
        let st;
        try {
          st = options.lstatSync(p2);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "EPERM" && isWindows)
            fixWinEPERMSync(p2, options, er);
        }
        try {
          if (st && st.isDirectory())
            rmdirSync(p2, options, null);
          else
            options.unlinkSync(p2);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "EPERM")
            return isWindows ? fixWinEPERMSync(p2, options, er) : rmdirSync(p2, options, er);
          if (er.code !== "EISDIR")
            throw er;
          rmdirSync(p2, options, er);
        }
      }
    };
    var rmdirSync = (p, options, originalEr) => {
      assert(p);
      assert(options);
      try {
        options.rmdirSync(p);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "ENOTDIR")
          throw originalEr;
        if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
          rmkidsSync(p, options);
      }
    };
    var rmkidsSync = (p, options) => {
      assert(p);
      assert(options);
      options.readdirSync(p).forEach((f) => rimrafSync(path22.join(p, f), options));
      const retries = isWindows ? 100 : 1;
      let i = 0;
      do {
        let threw = true;
        try {
          const ret = options.rmdirSync(p, options);
          threw = false;
          return ret;
        } finally {
          if (++i < retries && threw)
            continue;
        }
      } while (true);
    };
    module2.exports = rimraf;
    rimraf.sync = rimrafSync;
  });
  var require_cleanupCache = __commonJS((exports2) => {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : {default: mod2};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.cleanupCache = void 0;
    var fs_12 = __importDefault2(require("fs"));
    var path_12 = __importDefault2(require("path"));
    var util_12 = require_util2();
    var rimraf_1 = __importDefault2(require_rimraf());
    var util_22 = require("util");
    var p_map_1 = __importDefault2(require_p_map());
    var debug_12 = __importDefault2(require_dist());
    var debug32 = debug_12.default("cleanupCache");
    var del = util_22.promisify(rimraf_1.default);
    var readdir2 = util_22.promisify(fs_12.default.readdir);
    var stat2 = util_22.promisify(fs_12.default.stat);
    async function cleanupCache(n = 5) {
      try {
        const rootCacheDir = await util_12.getRootCacheDir();
        if (!rootCacheDir) {
          debug32("no rootCacheDir found");
          return;
        }
        const channel2 = "master";
        const cacheDir = path_12.default.join(rootCacheDir, channel2);
        const dirs = await readdir2(cacheDir);
        const dirsWithMeta = await Promise.all(dirs.map(async (dirName) => {
          const dir = path_12.default.join(cacheDir, dirName);
          const statResult = await stat2(dir);
          return {
            dir,
            created: statResult.birthtime
          };
        }));
        dirsWithMeta.sort((a, b) => a.created < b.created ? 1 : -1);
        const dirsToRemove = dirsWithMeta.slice(n);
        await p_map_1.default(dirsToRemove, (dir) => del(dir.dir), {concurrency: 20});
      } catch (e) {
      }
    }
    exports2.cleanupCache = cleanupCache;
  });
  var require_retry_operation = __commonJS((exports2, module2) => {
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = {forever: options};
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    module2.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts;
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = new Date().getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(this._errors.length - 1, this._errors.length);
          this._timeouts = this._cachedTimeouts.slice(0);
          timeout = this._timeouts.shift();
        } else {
          return false;
        }
      }
      var self2 = this;
      var timer = setTimeout(function() {
        self2._attempts++;
        if (self2._operationTimeoutCb) {
          self2._timeout = setTimeout(function() {
            self2._operationTimeoutCb(self2._attempts);
          }, self2._operationTimeout);
          if (self2._options.unref) {
            self2._timeout.unref();
          }
        }
        self2._fn(self2._attempts);
      }, timeout);
      if (this._options.unref) {
        timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self2 = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self2._operationTimeoutCb();
        }, self2._operationTimeout);
      }
      this._operationStart = new Date().getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i = 0; i < this._errors.length; i++) {
        var error = this._errors[i];
        var message = error.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  });
  var require_retry = __commonJS((exports2) => {
    var RetryOperation = require_retry_operation();
    exports2.operation = function(options) {
      var timeouts = exports2.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && options.forever,
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports2.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports2.createTimeout = function(attempt, opts) {
      var random2 = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random2 * opts.minTimeout * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports2.wrap = function(obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        var original = obj[method];
        obj[method] = function retryWrapper(original2) {
          var op = exports2.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }.bind(obj, original);
        obj[method].options = options;
      }
    };
  });
  var require_retry2 = __commonJS((exports2, module2) => {
    module2.exports = require_retry();
  });
  var require_p_retry = __commonJS((exports2, module2) => {
    "use strict";
    var retry = require_retry2();
    var networkErrorMsgs = [
      "Failed to fetch",
      "NetworkError when attempting to fetch resource",
      "The Internet connection appears to be offline"
    ];
    var AbortError = class extends Error {
      constructor(message) {
        super();
        if (message instanceof Error) {
          this.originalError = message;
          ({message} = message);
        } else {
          this.originalError = new Error(message);
          this.originalError.stack = this.stack;
        }
        this.name = "AbortError";
        this.message = message;
      }
    };
    var decorateErrorWithCounts = (error, attemptNumber, options) => {
      const retriesLeft = options.retries - (attemptNumber - 1);
      error.attemptNumber = attemptNumber;
      error.retriesLeft = retriesLeft;
      return error;
    };
    var isNetworkError = (errorMessage) => networkErrorMsgs.includes(errorMessage);
    var pRetry = (input, options) => new Promise((resolve, reject) => {
      options = {
        onFailedAttempt: () => {
        },
        retries: 10,
        ...options
      };
      const operation = retry.operation(options);
      operation.attempt(async (attemptNumber) => {
        try {
          resolve(await input(attemptNumber));
        } catch (error) {
          if (!(error instanceof Error)) {
            reject(new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`));
            return;
          }
          if (error instanceof AbortError) {
            operation.stop();
            reject(error.originalError);
          } else if (error instanceof TypeError && !isNetworkError(error.message)) {
            operation.stop();
            reject(error);
          } else {
            decorateErrorWithCounts(error, attemptNumber, options);
            try {
              await options.onFailedAttempt(error);
            } catch (error2) {
              reject(error2);
              return;
            }
            if (!operation.retry(error)) {
              reject(operation.mainError());
            }
          }
        }
      });
    });
    module2.exports = pRetry;
    module2.exports.default = pRetry;
    module2.exports.AbortError = AbortError;
  });
  var require_lib = __commonJS((exports2) => {
    __markAsModule(exports2);
    __export(exports2, {
      FetchError: () => FetchError,
      Headers: () => Headers,
      Request: () => Request,
      Response: () => Response,
      default: () => lib_default
    });
    var import_stream = __toModule(require("stream"));
    var import_http = __toModule(require("http"));
    var import_url2 = __toModule(require("url"));
    var import_https = __toModule(require("https"));
    var import_zlib = __toModule(require("zlib"));
    var Readable = import_stream.default.Readable;
    var BUFFER = Symbol("buffer");
    var TYPE = Symbol("type");
    var Blob = class {
      constructor() {
        this[TYPE] = "";
        const blobParts = arguments[0];
        const options = arguments[1];
        const buffers = [];
        let size = 0;
        if (blobParts) {
          const a = blobParts;
          const length = Number(a.length);
          for (let i = 0; i < length; i++) {
            const element = a[i];
            let buffer;
            if (element instanceof Buffer) {
              buffer = element;
            } else if (ArrayBuffer.isView(element)) {
              buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
            } else if (element instanceof ArrayBuffer) {
              buffer = Buffer.from(element);
            } else if (element instanceof Blob) {
              buffer = element[BUFFER];
            } else {
              buffer = Buffer.from(typeof element === "string" ? element : String(element));
            }
            size += buffer.length;
            buffers.push(buffer);
          }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type = options && options.type !== void 0 && String(options.type).toLowerCase();
        if (type && !/[^\u0020-\u007E]/.test(type)) {
          this[TYPE] = type;
        }
      }
      get size() {
        return this[BUFFER].length;
      }
      get type() {
        return this[TYPE];
      }
      text() {
        return Promise.resolve(this[BUFFER].toString());
      }
      arrayBuffer() {
        const buf = this[BUFFER];
        const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        return Promise.resolve(ab);
      }
      stream() {
        const readable = new Readable();
        readable._read = function() {
        };
        readable.push(this[BUFFER]);
        readable.push(null);
        return readable;
      }
      toString() {
        return "[object Blob]";
      }
      slice() {
        const size = this.size;
        const start = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start === void 0) {
          relativeStart = 0;
        } else if (start < 0) {
          relativeStart = Math.max(size + start, 0);
        } else {
          relativeStart = Math.min(start, size);
        }
        if (end === void 0) {
          relativeEnd = size;
        } else if (end < 0) {
          relativeEnd = Math.max(size + end, 0);
        } else {
          relativeEnd = Math.min(end, size);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer = this[BUFFER];
        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
        const blob = new Blob([], {type: arguments[2]});
        blob[BUFFER] = slicedBuffer;
        return blob;
      }
    };
    Object.defineProperties(Blob.prototype, {
      size: {enumerable: true},
      type: {enumerable: true},
      slice: {enumerable: true}
    });
    Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
      value: "Blob",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function FetchError(message, type, systemError) {
      Error.call(this, message);
      this.message = message;
      this.type = type;
      if (systemError) {
        this.code = this.errno = systemError.code;
      }
      Error.captureStackTrace(this, this.constructor);
    }
    FetchError.prototype = Object.create(Error.prototype);
    FetchError.prototype.constructor = FetchError;
    FetchError.prototype.name = "FetchError";
    var convert;
    try {
      convert = require("encoding").convert;
    } catch (e) {
    }
    var INTERNALS = Symbol("Body internals");
    var PassThrough = import_stream.default.PassThrough;
    function Body(body) {
      var _this = this;
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
      let size = _ref$size === void 0 ? 0 : _ref$size;
      var _ref$timeout = _ref.timeout;
      let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
      if (body == null) {
        body = null;
      } else if (isURLSearchParams(body)) {
        body = Buffer.from(body.toString());
      } else if (isBlob(body))
        ;
      else if (Buffer.isBuffer(body))
        ;
      else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        body = Buffer.from(body);
      } else if (ArrayBuffer.isView(body)) {
        body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
      } else if (body instanceof import_stream.default)
        ;
      else {
        body = Buffer.from(String(body));
      }
      this[INTERNALS] = {
        body,
        disturbed: false,
        error: null
      };
      this.size = size;
      this.timeout = timeout;
      if (body instanceof import_stream.default) {
        body.on("error", function(err) {
          const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
          _this[INTERNALS].error = error;
        });
      }
    }
    Body.prototype = {
      get body() {
        return this[INTERNALS].body;
      },
      get bodyUsed() {
        return this[INTERNALS].disturbed;
      },
      arrayBuffer() {
        return consumeBody.call(this).then(function(buf) {
          return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        });
      },
      blob() {
        let ct = this.headers && this.headers.get("content-type") || "";
        return consumeBody.call(this).then(function(buf) {
          return Object.assign(new Blob([], {
            type: ct.toLowerCase()
          }), {
            [BUFFER]: buf
          });
        });
      },
      json() {
        var _this2 = this;
        return consumeBody.call(this).then(function(buffer) {
          try {
            return JSON.parse(buffer.toString());
          } catch (err) {
            return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
          }
        });
      },
      text() {
        return consumeBody.call(this).then(function(buffer) {
          return buffer.toString();
        });
      },
      buffer() {
        return consumeBody.call(this);
      },
      textConverted() {
        var _this3 = this;
        return consumeBody.call(this).then(function(buffer) {
          return convertBody(buffer, _this3.headers);
        });
      }
    };
    Object.defineProperties(Body.prototype, {
      body: {enumerable: true},
      bodyUsed: {enumerable: true},
      arrayBuffer: {enumerable: true},
      blob: {enumerable: true},
      json: {enumerable: true},
      text: {enumerable: true}
    });
    Body.mixIn = function(proto) {
      for (const name of Object.getOwnPropertyNames(Body.prototype)) {
        if (!(name in proto)) {
          const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
          Object.defineProperty(proto, name, desc);
        }
      }
    };
    function consumeBody() {
      var _this4 = this;
      if (this[INTERNALS].disturbed) {
        return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
      }
      this[INTERNALS].disturbed = true;
      if (this[INTERNALS].error) {
        return Body.Promise.reject(this[INTERNALS].error);
      }
      let body = this.body;
      if (body === null) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      if (isBlob(body)) {
        body = body.stream();
      }
      if (Buffer.isBuffer(body)) {
        return Body.Promise.resolve(body);
      }
      if (!(body instanceof import_stream.default)) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      let accum = [];
      let accumBytes = 0;
      let abort = false;
      return new Body.Promise(function(resolve, reject) {
        let resTimeout;
        if (_this4.timeout) {
          resTimeout = setTimeout(function() {
            abort = true;
            reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
          }, _this4.timeout);
        }
        body.on("error", function(err) {
          if (err.name === "AbortError") {
            abort = true;
            reject(err);
          } else {
            reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
          }
        });
        body.on("data", function(chunk) {
          if (abort || chunk === null) {
            return;
          }
          if (_this4.size && accumBytes + chunk.length > _this4.size) {
            abort = true;
            reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
            return;
          }
          accumBytes += chunk.length;
          accum.push(chunk);
        });
        body.on("end", function() {
          if (abort) {
            return;
          }
          clearTimeout(resTimeout);
          try {
            resolve(Buffer.concat(accum, accumBytes));
          } catch (err) {
            reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
          }
        });
      });
    }
    function convertBody(buffer, headers) {
      if (typeof convert !== "function") {
        throw new Error("The package `encoding` must be installed to use the textConverted() function");
      }
      const ct = headers.get("content-type");
      let charset = "utf-8";
      let res, str;
      if (ct) {
        res = /charset=([^;]*)/i.exec(ct);
      }
      str = buffer.slice(0, 1024).toString();
      if (!res && str) {
        res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
      }
      if (!res && str) {
        res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
        if (!res) {
          res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
          if (res) {
            res.pop();
          }
        }
        if (res) {
          res = /charset=(.*)/i.exec(res.pop());
        }
      }
      if (!res && str) {
        res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
      }
      if (res) {
        charset = res.pop();
        if (charset === "gb2312" || charset === "gbk") {
          charset = "gb18030";
        }
      }
      return convert(buffer, "UTF-8", charset).toString();
    }
    function isURLSearchParams(obj) {
      if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
        return false;
      }
      return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
    }
    function isBlob(obj) {
      return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
    }
    function clone2(instance) {
      let p1, p2;
      let body = instance.body;
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof import_stream.default && typeof body.getBoundary !== "function") {
        p1 = new PassThrough();
        p2 = new PassThrough();
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS].body = p1;
        body = p2;
      }
      return body;
    }
    function extractContentType(body) {
      if (body === null) {
        return null;
      } else if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      } else if (isURLSearchParams(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isBlob(body)) {
        return body.type || null;
      } else if (Buffer.isBuffer(body)) {
        return null;
      } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        return null;
      } else if (ArrayBuffer.isView(body)) {
        return null;
      } else if (typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      } else if (body instanceof import_stream.default) {
        return null;
      } else {
        return "text/plain;charset=UTF-8";
      }
    }
    function getTotalBytes(instance) {
      const body = instance.body;
      if (body === null) {
        return 0;
      } else if (isBlob(body)) {
        return body.size;
      } else if (Buffer.isBuffer(body)) {
        return body.length;
      } else if (body && typeof body.getLengthSync === "function") {
        if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || body.hasKnownLength && body.hasKnownLength()) {
          return body.getLengthSync();
        }
        return null;
      } else {
        return null;
      }
    }
    function writeToStream(dest, instance) {
      const body = instance.body;
      if (body === null) {
        dest.end();
      } else if (isBlob(body)) {
        body.stream().pipe(dest);
      } else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else {
        body.pipe(dest);
      }
    }
    Body.Promise = global.Promise;
    var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
    var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    function validateName(name) {
      name = `${name}`;
      if (invalidTokenRegex.test(name) || name === "") {
        throw new TypeError(`${name} is not a legal HTTP header name`);
      }
    }
    function validateValue(value) {
      value = `${value}`;
      if (invalidHeaderCharRegex.test(value)) {
        throw new TypeError(`${value} is not a legal HTTP header value`);
      }
    }
    function find(map, name) {
      name = name.toLowerCase();
      for (const key in map) {
        if (key.toLowerCase() === name) {
          return key;
        }
      }
      return void 0;
    }
    var MAP = Symbol("map");
    var Headers = class {
      constructor() {
        let init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        this[MAP] = Object.create(null);
        if (init instanceof Headers) {
          const rawHeaders = init.raw();
          const headerNames = Object.keys(rawHeaders);
          for (const headerName of headerNames) {
            for (const value of rawHeaders[headerName]) {
              this.append(headerName, value);
            }
          }
          return;
        }
        if (init == null)
          ;
        else if (typeof init === "object") {
          const method = init[Symbol.iterator];
          if (method != null) {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            const pairs = [];
            for (const pair of init) {
              if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                throw new TypeError("Each header pair must be iterable");
              }
              pairs.push(Array.from(pair));
            }
            for (const pair of pairs) {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              this.append(pair[0], pair[1]);
            }
          } else {
            for (const key of Object.keys(init)) {
              const value = init[key];
              this.append(key, value);
            }
          }
        } else {
          throw new TypeError("Provided initializer must be an object");
        }
      }
      get(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key === void 0) {
          return null;
        }
        return this[MAP][key].join(", ");
      }
      forEach(callback) {
        let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
        let pairs = getHeaders(this);
        let i = 0;
        while (i < pairs.length) {
          var _pairs$i = pairs[i];
          const name = _pairs$i[0], value = _pairs$i[1];
          callback.call(thisArg, value, name, this);
          pairs = getHeaders(this);
          i++;
        }
      }
      set(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        this[MAP][key !== void 0 ? key : name] = [value];
      }
      append(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          this[MAP][key].push(value);
        } else {
          this[MAP][name] = [value];
        }
      }
      has(name) {
        name = `${name}`;
        validateName(name);
        return find(this[MAP], name) !== void 0;
      }
      delete(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          delete this[MAP][key];
        }
      }
      raw() {
        return this[MAP];
      }
      keys() {
        return createHeadersIterator(this, "key");
      }
      values() {
        return createHeadersIterator(this, "value");
      }
      [Symbol.iterator]() {
        return createHeadersIterator(this, "key+value");
      }
    };
    Headers.prototype.entries = Headers.prototype[Symbol.iterator];
    Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
      value: "Headers",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Headers.prototype, {
      get: {enumerable: true},
      forEach: {enumerable: true},
      set: {enumerable: true},
      append: {enumerable: true},
      has: {enumerable: true},
      delete: {enumerable: true},
      keys: {enumerable: true},
      values: {enumerable: true},
      entries: {enumerable: true}
    });
    function getHeaders(headers) {
      let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
      const keys = Object.keys(headers[MAP]).sort();
      return keys.map(kind === "key" ? function(k) {
        return k.toLowerCase();
      } : kind === "value" ? function(k) {
        return headers[MAP][k].join(", ");
      } : function(k) {
        return [k.toLowerCase(), headers[MAP][k].join(", ")];
      });
    }
    var INTERNAL = Symbol("internal");
    function createHeadersIterator(target, kind) {
      const iterator = Object.create(HeadersIteratorPrototype);
      iterator[INTERNAL] = {
        target,
        kind,
        index: 0
      };
      return iterator;
    }
    var HeadersIteratorPrototype = Object.setPrototypeOf({
      next() {
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
          throw new TypeError("Value of `this` is not a HeadersIterator");
        }
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
        const values = getHeaders(target, kind);
        const len = values.length;
        if (index >= len) {
          return {
            value: void 0,
            done: true
          };
        }
        this[INTERNAL].index = index + 1;
        return {
          value: values[index],
          done: false
        };
      }
    }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
    Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
      value: "HeadersIterator",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function exportNodeCompatibleHeaders(headers) {
      const obj = Object.assign({__proto__: null}, headers[MAP]);
      const hostHeaderKey = find(headers[MAP], "Host");
      if (hostHeaderKey !== void 0) {
        obj[hostHeaderKey] = obj[hostHeaderKey][0];
      }
      return obj;
    }
    function createHeadersLenient(obj) {
      const headers = new Headers();
      for (const name of Object.keys(obj)) {
        if (invalidTokenRegex.test(name)) {
          continue;
        }
        if (Array.isArray(obj[name])) {
          for (const val of obj[name]) {
            if (invalidHeaderCharRegex.test(val)) {
              continue;
            }
            if (headers[MAP][name] === void 0) {
              headers[MAP][name] = [val];
            } else {
              headers[MAP][name].push(val);
            }
          }
        } else if (!invalidHeaderCharRegex.test(obj[name])) {
          headers[MAP][name] = [obj[name]];
        }
      }
      return headers;
    }
    var INTERNALS$1 = Symbol("Response internals");
    var STATUS_CODES = import_http.default.STATUS_CODES;
    var Response = class {
      constructor() {
        let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        Body.call(this, body, opts);
        const status = opts.status || 200;
        const headers = new Headers(opts.headers);
        if (body != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          url: opts.url,
          status,
          statusText: opts.statusText || STATUS_CODES[status],
          headers,
          counter: opts.counter
        };
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      clone() {
        return new Response(clone2(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected
        });
      }
    };
    Body.mixIn(Response.prototype);
    Object.defineProperties(Response.prototype, {
      url: {enumerable: true},
      status: {enumerable: true},
      ok: {enumerable: true},
      redirected: {enumerable: true},
      statusText: {enumerable: true},
      headers: {enumerable: true},
      clone: {enumerable: true}
    });
    Object.defineProperty(Response.prototype, Symbol.toStringTag, {
      value: "Response",
      writable: false,
      enumerable: false,
      configurable: true
    });
    var INTERNALS$2 = Symbol("Request internals");
    var parse_url = import_url2.default.parse;
    var format_url = import_url2.default.format;
    var streamDestructionSupported = "destroy" in import_stream.default.Readable.prototype;
    function isRequest(input) {
      return typeof input === "object" && typeof input[INTERNALS$2] === "object";
    }
    function isAbortSignal(signal) {
      const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
      return !!(proto && proto.constructor.name === "AbortSignal");
    }
    var Request = class {
      constructor(input) {
        let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let parsedURL;
        if (!isRequest(input)) {
          if (input && input.href) {
            parsedURL = parse_url(input.href);
          } else {
            parsedURL = parse_url(`${input}`);
          }
          input = {};
        } else {
          parsedURL = parse_url(input.url);
        }
        let method = init.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone2(input) : null;
        Body.call(this, inputBody, {
          timeout: init.timeout || input.timeout || 0,
          size: init.size || input.size || 0
        });
        const headers = new Headers(init.headers || input.headers || {});
        if (inputBody != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init)
          signal = init.signal;
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS$2] = {
          method,
          redirect: init.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20;
        this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : true;
        this.counter = init.counter || input.counter || 0;
        this.agent = init.agent || input.agent;
      }
      get method() {
        return this[INTERNALS$2].method;
      }
      get url() {
        return format_url(this[INTERNALS$2].parsedURL);
      }
      get headers() {
        return this[INTERNALS$2].headers;
      }
      get redirect() {
        return this[INTERNALS$2].redirect;
      }
      get signal() {
        return this[INTERNALS$2].signal;
      }
      clone() {
        return new Request(this);
      }
    };
    Body.mixIn(Request.prototype);
    Object.defineProperty(Request.prototype, Symbol.toStringTag, {
      value: "Request",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Request.prototype, {
      method: {enumerable: true},
      url: {enumerable: true},
      headers: {enumerable: true},
      redirect: {enumerable: true},
      clone: {enumerable: true},
      signal: {enumerable: true}
    });
    function getNodeRequestOptions(request) {
      const parsedURL = request[INTERNALS$2].parsedURL;
      const headers = new Headers(request[INTERNALS$2].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      if (!parsedURL.protocol || !parsedURL.hostname) {
        throw new TypeError("Only absolute URLs are supported");
      }
      if (!/^https?:$/.test(parsedURL.protocol)) {
        throw new TypeError("Only HTTP(S) protocols are supported");
      }
      if (request.signal && request.body instanceof import_stream.default.Readable && !streamDestructionSupported) {
        throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
      }
      let contentLengthValue = null;
      if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body != null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number") {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate");
      }
      let agent = request.agent;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      if (!headers.has("Connection") && !agent) {
        headers.set("Connection", "close");
      }
      return Object.assign({}, parsedURL, {
        method: request.method,
        headers: exportNodeCompatibleHeaders(headers),
        agent
      });
    }
    function AbortError(message) {
      Error.call(this, message);
      this.type = "aborted";
      this.message = message;
      Error.captureStackTrace(this, this.constructor);
    }
    AbortError.prototype = Object.create(Error.prototype);
    AbortError.prototype.constructor = AbortError;
    AbortError.prototype.name = "AbortError";
    var PassThrough$1 = import_stream.default.PassThrough;
    var resolve_url = import_url2.default.resolve;
    function fetch(url, opts) {
      if (!fetch.Promise) {
        throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
      }
      Body.Promise = fetch.Promise;
      return new fetch.Promise(function(resolve, reject) {
        const request = new Request(url, opts);
        const options = getNodeRequestOptions(request);
        const send = (options.protocol === "https:" ? import_https.default : import_http.default).request;
        const signal = request.signal;
        let response = null;
        const abort = function abort2() {
          let error = new AbortError("The user aborted a request.");
          reject(error);
          if (request.body && request.body instanceof import_stream.default.Readable) {
            request.body.destroy(error);
          }
          if (!response || !response.body)
            return;
          response.body.emit("error", error);
        };
        if (signal && signal.aborted) {
          abort();
          return;
        }
        const abortAndFinalize = function abortAndFinalize2() {
          abort();
          finalize();
        };
        const req = send(options);
        let reqTimeout;
        if (signal) {
          signal.addEventListener("abort", abortAndFinalize);
        }
        function finalize() {
          req.abort();
          if (signal)
            signal.removeEventListener("abort", abortAndFinalize);
          clearTimeout(reqTimeout);
        }
        if (request.timeout) {
          req.once("socket", function(socket) {
            reqTimeout = setTimeout(function() {
              reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
              finalize();
            }, request.timeout);
          });
        }
        req.on("error", function(err) {
          reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
          finalize();
        });
        req.on("response", function(res) {
          clearTimeout(reqTimeout);
          const headers = createHeadersLenient(res.headers);
          if (fetch.isRedirect(res.statusCode)) {
            const location = headers.get("Location");
            const locationURL = location === null ? null : resolve_url(request.url, location);
            switch (request.redirect) {
              case "error":
                reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
                finalize();
                return;
              case "manual":
                if (locationURL !== null) {
                  try {
                    headers.set("Location", locationURL);
                  } catch (err) {
                    reject(err);
                  }
                }
                break;
              case "follow":
                if (locationURL === null) {
                  break;
                }
                if (request.counter >= request.follow) {
                  reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                  finalize();
                  return;
                }
                const requestOpts = {
                  headers: new Headers(request.headers),
                  follow: request.follow,
                  counter: request.counter + 1,
                  agent: request.agent,
                  compress: request.compress,
                  method: request.method,
                  body: request.body,
                  signal: request.signal,
                  timeout: request.timeout,
                  size: request.size
                };
                if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                  reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                  finalize();
                  return;
                }
                if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                  requestOpts.method = "GET";
                  requestOpts.body = void 0;
                  requestOpts.headers.delete("content-length");
                }
                resolve(fetch(new Request(locationURL, requestOpts)));
                finalize();
                return;
            }
          }
          res.once("end", function() {
            if (signal)
              signal.removeEventListener("abort", abortAndFinalize);
          });
          let body = res.pipe(new PassThrough$1());
          const response_options = {
            url: request.url,
            status: res.statusCode,
            statusText: res.statusMessage,
            headers,
            size: request.size,
            timeout: request.timeout,
            counter: request.counter
          };
          const codings = headers.get("Content-Encoding");
          if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
            response = new Response(body, response_options);
            resolve(response);
            return;
          }
          const zlibOptions = {
            flush: import_zlib.default.Z_SYNC_FLUSH,
            finishFlush: import_zlib.default.Z_SYNC_FLUSH
          };
          if (codings == "gzip" || codings == "x-gzip") {
            body = body.pipe(import_zlib.default.createGunzip(zlibOptions));
            response = new Response(body, response_options);
            resolve(response);
            return;
          }
          if (codings == "deflate" || codings == "x-deflate") {
            const raw = res.pipe(new PassThrough$1());
            raw.once("data", function(chunk) {
              if ((chunk[0] & 15) === 8) {
                body = body.pipe(import_zlib.default.createInflate());
              } else {
                body = body.pipe(import_zlib.default.createInflateRaw());
              }
              response = new Response(body, response_options);
              resolve(response);
            });
            return;
          }
          if (codings == "br" && typeof import_zlib.default.createBrotliDecompress === "function") {
            body = body.pipe(import_zlib.default.createBrotliDecompress());
            response = new Response(body, response_options);
            resolve(response);
            return;
          }
          response = new Response(body, response_options);
          resolve(response);
        });
        writeToStream(req, request);
      });
    }
    fetch.isRedirect = function(code) {
      return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
    };
    fetch.Promise = global.Promise;
    var lib_default = fetch;
  });
  var require_promisify = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    function promisify2(fn) {
      return function(req, opts) {
        return new Promise((resolve, reject) => {
          fn.call(this, req, opts, (err, rtn) => {
            if (err) {
              reject(err);
            } else {
              resolve(rtn);
            }
          });
        });
      };
    }
    exports2.default = promisify2;
  });
  var require_src2 = __commonJS((exports2, module2) => {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : {default: mod2};
    };
    var events_1 = require("events");
    var debug_12 = __importDefault2(require_src());
    var promisify_1 = __importDefault2(require_promisify());
    var debug32 = debug_12.default("agent-base");
    function isAgent(v) {
      return Boolean(v) && typeof v.addRequest === "function";
    }
    function isSecureEndpoint() {
      const {stack} = new Error();
      if (typeof stack !== "string")
        return false;
      return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
    }
    function createAgent(callback, opts) {
      return new createAgent.Agent(callback, opts);
    }
    (function(createAgent2) {
      class Agent extends events_1.EventEmitter {
        constructor(callback, _opts) {
          super();
          let opts = _opts;
          if (typeof callback === "function") {
            this.callback = callback;
          } else if (callback) {
            opts = callback;
          }
          this.timeout = null;
          if (opts && typeof opts.timeout === "number") {
            this.timeout = opts.timeout;
          }
          this.maxFreeSockets = 1;
          this.maxSockets = 1;
          this.maxTotalSockets = Infinity;
          this.sockets = {};
          this.freeSockets = {};
          this.requests = {};
          this.options = {};
        }
        get defaultPort() {
          if (typeof this.explicitDefaultPort === "number") {
            return this.explicitDefaultPort;
          }
          return isSecureEndpoint() ? 443 : 80;
        }
        set defaultPort(v) {
          this.explicitDefaultPort = v;
        }
        get protocol() {
          if (typeof this.explicitProtocol === "string") {
            return this.explicitProtocol;
          }
          return isSecureEndpoint() ? "https:" : "http:";
        }
        set protocol(v) {
          this.explicitProtocol = v;
        }
        callback(req, opts, fn) {
          throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
        }
        addRequest(req, _opts) {
          const opts = Object.assign({}, _opts);
          if (typeof opts.secureEndpoint !== "boolean") {
            opts.secureEndpoint = isSecureEndpoint();
          }
          if (opts.host == null) {
            opts.host = "localhost";
          }
          if (opts.port == null) {
            opts.port = opts.secureEndpoint ? 443 : 80;
          }
          if (opts.protocol == null) {
            opts.protocol = opts.secureEndpoint ? "https:" : "http:";
          }
          if (opts.host && opts.path) {
            delete opts.path;
          }
          delete opts.agent;
          delete opts.hostname;
          delete opts._defaultAgent;
          delete opts.defaultPort;
          delete opts.createConnection;
          req._last = true;
          req.shouldKeepAlive = false;
          let timedOut = false;
          let timeoutId = null;
          const timeoutMs = opts.timeout || this.timeout;
          const onerror = (err) => {
            if (req._hadError)
              return;
            req.emit("error", err);
            req._hadError = true;
          };
          const ontimeout = () => {
            timeoutId = null;
            timedOut = true;
            const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
            err.code = "ETIMEOUT";
            onerror(err);
          };
          const callbackError = (err) => {
            if (timedOut)
              return;
            if (timeoutId !== null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            onerror(err);
          };
          const onsocket = (socket) => {
            if (timedOut)
              return;
            if (timeoutId != null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            if (isAgent(socket)) {
              debug32("Callback returned another Agent instance %o", socket.constructor.name);
              socket.addRequest(req, opts);
              return;
            }
            if (socket) {
              socket.once("free", () => {
                this.freeSocket(socket, opts);
              });
              req.onSocket(socket);
              return;
            }
            const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
            onerror(err);
          };
          if (typeof this.callback !== "function") {
            onerror(new Error("`callback` is not defined"));
            return;
          }
          if (!this.promisifiedCallback) {
            if (this.callback.length >= 3) {
              debug32("Converting legacy callback function to promise");
              this.promisifiedCallback = promisify_1.default(this.callback);
            } else {
              this.promisifiedCallback = this.callback;
            }
          }
          if (typeof timeoutMs === "number" && timeoutMs > 0) {
            timeoutId = setTimeout(ontimeout, timeoutMs);
          }
          if ("port" in opts && typeof opts.port !== "number") {
            opts.port = Number(opts.port);
          }
          try {
            debug32("Resolving socket for %o request: %o", opts.protocol, `${req.method} ${req.path}`);
            Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
          } catch (err) {
            Promise.reject(err).catch(callbackError);
          }
        }
        freeSocket(socket, opts) {
          debug32("Freeing socket %o %o", socket.constructor.name, opts);
          socket.destroy();
        }
        destroy() {
          debug32("Destroying agent %o", this.constructor.name);
        }
      }
      createAgent2.Agent = Agent;
      createAgent2.prototype = createAgent2.Agent.prototype;
    })(createAgent || (createAgent = {}));
    module2.exports = createAgent;
  });
  var require_parse_proxy_response = __commonJS((exports2) => {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : {default: mod2};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    var debug_12 = __importDefault2(require_src());
    var debug32 = debug_12.default("https-proxy-agent:parse-proxy-response");
    function parseProxyResponse(socket) {
      return new Promise((resolve, reject) => {
        let buffersLength = 0;
        const buffers = [];
        function read() {
          const b = socket.read();
          if (b)
            ondata(b);
          else
            socket.once("readable", read);
        }
        function cleanup2() {
          socket.removeListener("end", onend);
          socket.removeListener("error", onerror);
          socket.removeListener("close", onclose);
          socket.removeListener("readable", read);
        }
        function onclose(err) {
          debug32("onclose had error %o", err);
        }
        function onend() {
          debug32("onend");
        }
        function onerror(err) {
          cleanup2();
          debug32("onerror %o", err);
          reject(err);
        }
        function ondata(b) {
          buffers.push(b);
          buffersLength += b.length;
          const buffered = Buffer.concat(buffers, buffersLength);
          const endOfHeaders = buffered.indexOf("\r\n\r\n");
          if (endOfHeaders === -1) {
            debug32("have not received end of HTTP headers yet...");
            read();
            return;
          }
          const firstLine = buffered.toString("ascii", 0, buffered.indexOf("\r\n"));
          const statusCode = +firstLine.split(" ")[1];
          debug32("got proxy server response: %o", firstLine);
          resolve({
            statusCode,
            buffered
          });
        }
        socket.on("error", onerror);
        socket.on("close", onclose);
        socket.on("end", onend);
        read();
      });
    }
    exports2.default = parseProxyResponse;
  });
  var require_agent = __commonJS((exports2) => {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : {default: mod2};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    var net_1 = __importDefault2(require("net"));
    var tls_1 = __importDefault2(require("tls"));
    var url_1 = __importDefault2(require("url"));
    var assert_1 = __importDefault2(require("assert"));
    var debug_12 = __importDefault2(require_src());
    var agent_base_1 = require_src2();
    var parse_proxy_response_1 = __importDefault2(require_parse_proxy_response());
    var debug32 = debug_12.default("https-proxy-agent:agent");
    var HttpsProxyAgent = class extends agent_base_1.Agent {
      constructor(_opts) {
        let opts;
        if (typeof _opts === "string") {
          opts = url_1.default.parse(_opts);
        } else {
          opts = _opts;
        }
        if (!opts) {
          throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
        }
        debug32("creating new HttpsProxyAgent instance: %o", opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === "string") {
          proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
          proxy.port = this.secureProxy ? 443 : 80;
        }
        if (this.secureProxy && !("ALPNProtocols" in proxy)) {
          proxy.ALPNProtocols = ["http 1.1"];
        }
        if (proxy.host && proxy.path) {
          delete proxy.path;
          delete proxy.pathname;
        }
        this.proxy = proxy;
      }
      callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const {proxy, secureProxy} = this;
          let socket;
          if (secureProxy) {
            debug32("Creating `tls.Socket`: %o", proxy);
            socket = tls_1.default.connect(proxy);
          } else {
            debug32("Creating `net.Socket`: %o", proxy);
            socket = net_1.default.connect(proxy);
          }
          const headers = Object.assign({}, proxy.headers);
          const hostname = `${opts.host}:${opts.port}`;
          let payload = `CONNECT ${hostname} HTTP/1.1\r
`;
          if (proxy.auth) {
            headers["Proxy-Authorization"] = `Basic ${Buffer.from(proxy.auth).toString("base64")}`;
          }
          let {host, port, secureEndpoint} = opts;
          if (!isDefaultPort(port, secureEndpoint)) {
            host += `:${port}`;
          }
          headers.Host = host;
          headers.Connection = "close";
          for (const name of Object.keys(headers)) {
            payload += `${name}: ${headers[name]}\r
`;
          }
          const proxyResponsePromise = parse_proxy_response_1.default(socket);
          socket.write(`${payload}\r
`);
          const {statusCode, buffered} = yield proxyResponsePromise;
          if (statusCode === 200) {
            req.once("socket", resume);
            if (opts.secureEndpoint) {
              const servername = opts.servername || opts.host;
              if (!servername) {
                throw new Error('Could not determine "servername"');
              }
              debug32("Upgrading socket connection to TLS");
              return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, "host", "hostname", "path", "port")), {
                socket,
                servername
              }));
            }
            return socket;
          }
          socket.destroy();
          const fakeSocket = new net_1.default.Socket();
          fakeSocket.readable = true;
          req.once("socket", (s2) => {
            debug32("replaying proxy buffer for failed request");
            assert_1.default(s2.listenerCount("data") > 0);
            s2.push(buffered);
            s2.push(null);
          });
          return fakeSocket;
        });
      }
    };
    exports2.default = HttpsProxyAgent;
    function resume(socket) {
      socket.resume();
    }
    function isDefaultPort(port, secure) {
      return Boolean(!secure && port === 80 || secure && port === 443);
    }
    function isHTTPS(protocol) {
      return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
    }
    function omit(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  });
  var require_dist3 = __commonJS((exports2, module2) => {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : {default: mod2};
    };
    var agent_1 = __importDefault2(require_agent());
    function createHttpsProxyAgent(opts) {
      return new agent_1.default(opts);
    }
    (function(createHttpsProxyAgent2) {
      createHttpsProxyAgent2.HttpsProxyAgent = agent_1.default;
      createHttpsProxyAgent2.prototype = agent_1.default.prototype;
    })(createHttpsProxyAgent || (createHttpsProxyAgent = {}));
    module2.exports = createHttpsProxyAgent;
  });
  var require_dist4 = __commonJS((exports2, module2) => {
    "use strict";
    function noop() {
    }
    function once(emitter, name) {
      const o = once.spread(emitter, name);
      const r = o.then((args) => args[0]);
      r.cancel = o.cancel;
      return r;
    }
    (function(once2) {
      function spread(emitter, name) {
        let c = null;
        const p = new Promise((resolve, reject) => {
          function cancel() {
            emitter.removeListener(name, onEvent);
            emitter.removeListener("error", onError);
            p.cancel = noop;
          }
          function onEvent(...args) {
            cancel();
            resolve(args);
          }
          function onError(err) {
            cancel();
            reject(err);
          }
          c = cancel;
          emitter.on(name, onEvent);
          emitter.on("error", onError);
        });
        if (!c) {
          throw new TypeError("Could not get `cancel()` function");
        }
        p.cancel = c;
        return p;
      }
      once2.spread = spread;
    })(once || (once = {}));
    module2.exports = once;
  });
  var require_agent2 = __commonJS((exports2) => {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : {default: mod2};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    var net_1 = __importDefault2(require("net"));
    var tls_1 = __importDefault2(require("tls"));
    var url_1 = __importDefault2(require("url"));
    var debug_12 = __importDefault2(require_src());
    var once_1 = __importDefault2(require_dist4());
    var agent_base_1 = require_src2();
    var debug32 = debug_12.default("http-proxy-agent");
    function isHTTPS(protocol) {
      return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
    }
    var HttpProxyAgent = class extends agent_base_1.Agent {
      constructor(_opts) {
        let opts;
        if (typeof _opts === "string") {
          opts = url_1.default.parse(_opts);
        } else {
          opts = _opts;
        }
        if (!opts) {
          throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
        }
        debug32("Creating new HttpProxyAgent instance: %o", opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === "string") {
          proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
          proxy.port = this.secureProxy ? 443 : 80;
        }
        if (proxy.host && proxy.path) {
          delete proxy.path;
          delete proxy.pathname;
        }
        this.proxy = proxy;
      }
      callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const {proxy, secureProxy} = this;
          const parsed = url_1.default.parse(req.path);
          if (!parsed.protocol) {
            parsed.protocol = "http:";
          }
          if (!parsed.hostname) {
            parsed.hostname = opts.hostname || opts.host || null;
          }
          if (parsed.port == null && typeof opts.port) {
            parsed.port = String(opts.port);
          }
          if (parsed.port === "80") {
            delete parsed.port;
          }
          req.path = url_1.default.format(parsed);
          if (proxy.auth) {
            req.setHeader("Proxy-Authorization", `Basic ${Buffer.from(proxy.auth).toString("base64")}`);
          }
          let socket;
          if (secureProxy) {
            debug32("Creating `tls.Socket`: %o", proxy);
            socket = tls_1.default.connect(proxy);
          } else {
            debug32("Creating `net.Socket`: %o", proxy);
            socket = net_1.default.connect(proxy);
          }
          if (req._header) {
            let first;
            let endOfHeaders;
            debug32("Regenerating stored HTTP header string for request");
            req._header = null;
            req._implicitHeader();
            if (req.output && req.output.length > 0) {
              debug32("Patching connection write() output buffer with updated header");
              first = req.output[0];
              endOfHeaders = first.indexOf("\r\n\r\n") + 4;
              req.output[0] = req._header + first.substring(endOfHeaders);
              debug32("Output buffer: %o", req.output);
            } else if (req.outputData && req.outputData.length > 0) {
              debug32("Patching connection write() output buffer with updated header");
              first = req.outputData[0].data;
              endOfHeaders = first.indexOf("\r\n\r\n") + 4;
              req.outputData[0].data = req._header + first.substring(endOfHeaders);
              debug32("Output buffer: %o", req.outputData[0].data);
            }
          }
          yield once_1.default(socket, "connect");
          return socket;
        });
      }
    };
    exports2.default = HttpProxyAgent;
  });
  var require_dist5 = __commonJS((exports2, module2) => {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : {default: mod2};
    };
    var agent_1 = __importDefault2(require_agent2());
    function createHttpProxyAgent(opts) {
      return new agent_1.default(opts);
    }
    (function(createHttpProxyAgent2) {
      createHttpProxyAgent2.HttpProxyAgent = agent_1.default;
      createHttpProxyAgent2.prototype = agent_1.default.prototype;
    })(createHttpProxyAgent || (createHttpProxyAgent = {}));
    module2.exports = createHttpProxyAgent;
  });
  var require_getProxyAgent = __commonJS((exports2) => {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : {default: mod2};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.getProxyAgent = void 0;
    var https_proxy_agent_1 = __importDefault2(require_dist3());
    var http_proxy_agent_1 = __importDefault2(require_dist5());
    var url_1 = __importDefault2(require("url"));
    function formatHostname(hostname) {
      return hostname.replace(/^\.*/, ".").toLowerCase();
    }
    function parseNoProxyZone(zone) {
      zone = zone.trim().toLowerCase();
      const zoneParts = zone.split(":", 2);
      const zoneHost = formatHostname(zoneParts[0]);
      const zonePort = zoneParts[1];
      const hasPort = zone.includes(":");
      return {hostname: zoneHost, port: zonePort, hasPort};
    }
    function uriInNoProxy(uri, noProxy) {
      const port = uri.port || (uri.protocol === "https:" ? "443" : "80");
      const hostname = formatHostname(uri.hostname);
      const noProxyList = noProxy.split(",");
      return noProxyList.map(parseNoProxyZone).some(function(noProxyZone) {
        const isMatchedAt = hostname.indexOf(noProxyZone.hostname);
        const hostnameMatched = isMatchedAt > -1 && isMatchedAt === hostname.length - noProxyZone.hostname.length;
        if (noProxyZone.hasPort) {
          return port === noProxyZone.port && hostnameMatched;
        }
        return hostnameMatched;
      });
    }
    function getProxyFromURI(uri) {
      const noProxy = process.env.NO_PROXY || process.env.no_proxy || "";
      if (noProxy === "*") {
        return null;
      }
      if (noProxy !== "" && uriInNoProxy(uri, noProxy)) {
        return null;
      }
      if (uri.protocol === "http:") {
        return process.env.HTTP_PROXY || process.env.http_proxy || null;
      }
      if (uri.protocol === "https:") {
        return process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy || null;
      }
      return null;
    }
    function getProxyAgent(url) {
      const uri = url_1.default.parse(url);
      const proxy = getProxyFromURI(uri);
      if (!proxy) {
        return void 0;
      }
      if (uri.protocol === "http:") {
        return http_proxy_agent_1.default(proxy);
      }
      if (uri.protocol === "https:") {
        return https_proxy_agent_1.default(proxy);
      }
      return void 0;
    }
    exports2.getProxyAgent = getProxyAgent;
  });
  var require_crypto_random_string = __commonJS((exports2, module2) => {
    "use strict";
    var crypto2 = require("crypto");
    module2.exports = (length) => {
      if (!Number.isFinite(length)) {
        throw new TypeError("Expected a finite number");
      }
      return crypto2.randomBytes(Math.ceil(length / 2)).toString("hex").slice(0, length);
    };
  });
  var require_unique_string = __commonJS((exports2, module2) => {
    "use strict";
    var cryptoRandomString = require_crypto_random_string();
    module2.exports = () => cryptoRandomString(32);
  });
  var require_array_union = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = (...arguments_) => {
      return [...new Set([].concat(...arguments_))];
    };
  });
  var require_merge2 = __commonJS((exports2, module2) => {
    "use strict";
    var Stream = require("stream");
    var PassThrough = Stream.PassThrough;
    var slice = Array.prototype.slice;
    module2.exports = merge2;
    function merge2() {
      const streamsQueue = [];
      const args = slice.call(arguments);
      let merging = false;
      let options = args[args.length - 1];
      if (options && !Array.isArray(options) && options.pipe == null) {
        args.pop();
      } else {
        options = {};
      }
      const doEnd = options.end !== false;
      const doPipeError = options.pipeError === true;
      if (options.objectMode == null) {
        options.objectMode = true;
      }
      if (options.highWaterMark == null) {
        options.highWaterMark = 64 * 1024;
      }
      const mergedStream = PassThrough(options);
      function addStream() {
        for (let i = 0, len = arguments.length; i < len; i++) {
          streamsQueue.push(pauseStreams(arguments[i], options));
        }
        mergeStream();
        return this;
      }
      function mergeStream() {
        if (merging) {
          return;
        }
        merging = true;
        let streams = streamsQueue.shift();
        if (!streams) {
          process.nextTick(endStream);
          return;
        }
        if (!Array.isArray(streams)) {
          streams = [streams];
        }
        let pipesCount = streams.length + 1;
        function next() {
          if (--pipesCount > 0) {
            return;
          }
          merging = false;
          mergeStream();
        }
        function pipe(stream) {
          function onend() {
            stream.removeListener("merge2UnpipeEnd", onend);
            stream.removeListener("end", onend);
            if (doPipeError) {
              stream.removeListener("error", onerror);
            }
            next();
          }
          function onerror(err) {
            mergedStream.emit("error", err);
          }
          if (stream._readableState.endEmitted) {
            return next();
          }
          stream.on("merge2UnpipeEnd", onend);
          stream.on("end", onend);
          if (doPipeError) {
            stream.on("error", onerror);
          }
          stream.pipe(mergedStream, {end: false});
          stream.resume();
        }
        for (let i = 0; i < streams.length; i++) {
          pipe(streams[i]);
        }
        next();
      }
      function endStream() {
        merging = false;
        mergedStream.emit("queueDrain");
        if (doEnd) {
          mergedStream.end();
        }
      }
      mergedStream.setMaxListeners(0);
      mergedStream.add = addStream;
      mergedStream.on("unpipe", function(stream) {
        stream.emit("merge2UnpipeEnd");
      });
      if (args.length) {
        addStream.apply(null, args);
      }
      return mergedStream;
    }
    function pauseStreams(streams, options) {
      if (!Array.isArray(streams)) {
        if (!streams._readableState && streams.pipe) {
          streams = streams.pipe(PassThrough(options));
        }
        if (!streams._readableState || !streams.pause || !streams.pipe) {
          throw new Error("Only readable stream can be merged.");
        }
        streams.pause();
      } else {
        for (let i = 0, len = streams.length; i < len; i++) {
          streams[i] = pauseStreams(streams[i], options);
        }
      }
      return streams;
    }
  });
  var require_array = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.splitWhen = exports2.flatten = void 0;
    function flatten(items) {
      return items.reduce((collection, item) => [].concat(collection, item), []);
    }
    exports2.flatten = flatten;
    function splitWhen(items, predicate) {
      const result = [[]];
      let groupIndex = 0;
      for (const item of items) {
        if (predicate(item)) {
          groupIndex++;
          result[groupIndex] = [];
        } else {
          result[groupIndex].push(item);
        }
      }
      return result;
    }
    exports2.splitWhen = splitWhen;
  });
  var require_errno = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.isEnoentCodeError = void 0;
    function isEnoentCodeError(error) {
      return error.code === "ENOENT";
    }
    exports2.isEnoentCodeError = isEnoentCodeError;
  });
  var require_fs2 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports2.createDirentFromStats = createDirentFromStats;
  });
  var require_path = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.removeLeadingDotSegment = exports2.escape = exports2.makeAbsolute = exports2.unixify = void 0;
    var path22 = require("path");
    var LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;
    var UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g;
    function unixify(filepath) {
      return filepath.replace(/\\/g, "/");
    }
    exports2.unixify = unixify;
    function makeAbsolute(cwd, filepath) {
      return path22.resolve(cwd, filepath);
    }
    exports2.makeAbsolute = makeAbsolute;
    function escape(pattern) {
      return pattern.replace(UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
    }
    exports2.escape = escape;
    function removeLeadingDotSegment(entry) {
      if (entry.charAt(0) === ".") {
        const secondCharactery = entry.charAt(1);
        if (secondCharactery === "/" || secondCharactery === "\\") {
          return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
        }
      }
      return entry;
    }
    exports2.removeLeadingDotSegment = removeLeadingDotSegment;
  });
  var require_is_extglob = __commonJS((exports2, module2) => {
    /*!
     * is-extglob <https://github.com/jonschlinkert/is-extglob>
     *
     * Copyright (c) 2014-2016, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    module2.exports = function isExtglob(str) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      var match;
      while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
        if (match[2])
          return true;
        str = str.slice(match.index + match[0].length);
      }
      return false;
    };
  });
  var require_is_glob = __commonJS((exports2, module2) => {
    /*!
     * is-glob <https://github.com/jonschlinkert/is-glob>
     *
     * Copyright (c) 2014-2017, Jon Schlinkert.
     * Released under the MIT License.
     */
    var isExtglob = require_is_extglob();
    var chars = {"{": "}", "(": ")", "[": "]"};
    var strictRegex = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
    var relaxedRegex = /\\(.)|(^!|[*?{}()[\]]|\(\?)/;
    module2.exports = function isGlob(str, options) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      if (isExtglob(str)) {
        return true;
      }
      var regex = strictRegex;
      var match;
      if (options && options.strict === false) {
        regex = relaxedRegex;
      }
      while (match = regex.exec(str)) {
        if (match[2])
          return true;
        var idx = match.index + match[0].length;
        var open2 = match[1];
        var close2 = open2 ? chars[open2] : null;
        if (open2 && close2) {
          var n = str.indexOf(close2, idx);
          if (n !== -1) {
            idx = n + 1;
          }
        }
        str = str.slice(idx);
      }
      return false;
    };
  });
  var require_glob_parent = __commonJS((exports2, module2) => {
    "use strict";
    var isGlob = require_is_glob();
    var pathPosixDirname = require("path").posix.dirname;
    var isWin32 = require("os").platform() === "win32";
    var slash = "/";
    var backslash = /\\/g;
    var enclosure = /[\{\[].*[\}\]]$/;
    var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
    var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
    module2.exports = function globParent(str, opts) {
      var options = Object.assign({flipBackslashes: true}, opts);
      if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
        str = str.replace(backslash, slash);
      }
      if (enclosure.test(str)) {
        str += slash;
      }
      str += "a";
      do {
        str = pathPosixDirname(str);
      } while (isGlob(str) || globby.test(str));
      return str.replace(escaped, "$1");
    };
  });
  var require_utils = __commonJS((exports2) => {
    "use strict";
    exports2.isInteger = (num) => {
      if (typeof num === "number") {
        return Number.isInteger(num);
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isInteger(Number(num));
      }
      return false;
    };
    exports2.find = (node, type) => node.nodes.find((node2) => node2.type === type);
    exports2.exceedsLimit = (min2, max2, step = 1, limit) => {
      if (limit === false)
        return false;
      if (!exports2.isInteger(min2) || !exports2.isInteger(max2))
        return false;
      return (Number(max2) - Number(min2)) / Number(step) >= limit;
    };
    exports2.escapeNode = (block, n = 0, type) => {
      let node = block.nodes[n];
      if (!node)
        return;
      if (type && node.type === type || node.type === "open" || node.type === "close") {
        if (node.escaped !== true) {
          node.value = "\\" + node.value;
          node.escaped = true;
        }
      }
    };
    exports2.encloseBrace = (node) => {
      if (node.type !== "brace")
        return false;
      if (node.commas >> 0 + node.ranges >> 0 === 0) {
        node.invalid = true;
        return true;
      }
      return false;
    };
    exports2.isInvalidBrace = (block) => {
      if (block.type !== "brace")
        return false;
      if (block.invalid === true || block.dollar)
        return true;
      if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
      }
      if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
      }
      return false;
    };
    exports2.isOpenOrClose = (node) => {
      if (node.type === "open" || node.type === "close") {
        return true;
      }
      return node.open === true || node.close === true;
    };
    exports2.reduce = (nodes) => nodes.reduce((acc, node) => {
      if (node.type === "text")
        acc.push(node.value);
      if (node.type === "range")
        node.type = "text";
      return acc;
    }, []);
    exports2.flatten = (...args) => {
      const result = [];
      const flat = (arr) => {
        for (let i = 0; i < arr.length; i++) {
          let ele = arr[i];
          Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
        }
        return result;
      };
      flat(args);
      return result;
    };
  });
  var require_stringify = __commonJS((exports2, module2) => {
    "use strict";
    var utils = require_utils();
    module2.exports = (ast, options = {}) => {
      let stringify2 = (node, parent = {}) => {
        let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let output = "";
        if (node.value) {
          if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
            return "\\" + node.value;
          }
          return node.value;
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += stringify2(child);
          }
        }
        return output;
      };
      return stringify2(ast);
    };
  });
  var require_is_number = __commonJS((exports2, module2) => {
    /*!
     * is-number <https://github.com/jonschlinkert/is-number>
     *
     * Copyright (c) 2014-present, Jon Schlinkert.
     * Released under the MIT License.
     */
    "use strict";
    module2.exports = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
  });
  var require_to_regex_range = __commonJS((exports2, module2) => {
    /*!
     * to-regex-range <https://github.com/micromatch/to-regex-range>
     *
     * Copyright (c) 2015-present, Jon Schlinkert.
     * Released under the MIT License.
     */
    "use strict";
    var isNumber = require_is_number();
    var toRegexRange = (min2, max2, options) => {
      if (isNumber(min2) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max2 === void 0 || min2 === max2) {
        return String(min2);
      }
      if (isNumber(max2) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = {relaxZeros: true, ...options};
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap = String(opts.wrap);
      let cacheKey = min2 + ":" + max2 + "=" + relax + shorthand + capture + wrap;
      if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange.cache[cacheKey].result;
      }
      let a = Math.min(min2, max2);
      let b = Math.max(min2, max2);
      if (Math.abs(a - b) === 1) {
        let result = min2 + "|" + max2;
        if (opts.capture) {
          return `(${result})`;
        }
        if (opts.wrap === false) {
          return result;
        }
        return `(?:${result})`;
      }
      let isPadded = hasPadding(min2) || hasPadding(max2);
      let state = {min: min2, max: max2, a, b};
      let positives = [];
      let negatives = [];
      if (isPadded) {
        state.isPadded = isPadded;
        state.maxLen = String(state.max).length;
      }
      if (a < 0) {
        let newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
        a = state.a = 0;
      }
      if (b >= 0) {
        positives = splitToPatterns(a, b, state, opts);
      }
      state.negatives = negatives;
      state.positives = positives;
      state.result = collatePatterns(negatives, positives, opts);
      if (opts.capture === true) {
        state.result = `(${state.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
      }
      toRegexRange.cache[cacheKey] = state;
      return state.result;
    };
    function collatePatterns(neg, pos, options) {
      let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
      let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
      let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min2, max2) {
      let nines = 1;
      let zeros = 1;
      let stop = countNines(min2, nines);
      let stops = new Set([max2]);
      while (min2 <= stop && stop <= max2) {
        stops.add(stop);
        nines += 1;
        stop = countNines(min2, nines);
      }
      stop = countZeros(max2 + 1, zeros) - 1;
      while (min2 < stop && stop <= max2) {
        stops.add(stop);
        zeros += 1;
        stop = countZeros(max2 + 1, zeros) - 1;
      }
      stops = [...stops];
      stops.sort(compare);
      return stops;
    }
    function rangeToPattern(start, stop, options) {
      if (start === stop) {
        return {pattern: start, count: [], digits: 0};
      }
      let zipped = zip(start, stop);
      let digits = zipped.length;
      let pattern = "";
      let count = 0;
      for (let i = 0; i < digits; i++) {
        let [startDigit, stopDigit] = zipped[i];
        if (startDigit === stopDigit) {
          pattern += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern += toCharacterClass(startDigit, stopDigit, options);
        } else {
          count++;
        }
      }
      if (count) {
        pattern += options.shorthand === true ? "\\d" : "[0-9]";
      }
      return {pattern, count: [count], digits};
    }
    function splitToPatterns(min2, max2, tok, options) {
      let ranges = splitToRanges(min2, max2);
      let tokens = [];
      let start = min2;
      let prev;
      for (let i = 0; i < ranges.length; i++) {
        let max22 = ranges[i];
        let obj = rangeToPattern(String(start), String(max22), options);
        let zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.count.length > 1) {
            prev.count.pop();
          }
          prev.count.push(obj.count[0]);
          prev.string = prev.pattern + toQuantifier(prev.count);
          start = max22 + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros = padZeros(max22, tok, options);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.count);
        tokens.push(obj);
        start = max22 + 1;
        prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix, intersection, options) {
      let result = [];
      for (let ele of arr) {
        let {string} = ele;
        if (!intersection && !contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
        if (intersection && contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
      }
      return result;
    }
    function zip(a, b) {
      let arr = [];
      for (let i = 0; i < a.length; i++)
        arr.push([a[i], b[i]]);
      return arr;
    }
    function compare(a, b) {
      return a > b ? 1 : b > a ? -1 : 0;
    }
    function contains(arr, key, val) {
      return arr.some((ele) => ele[key] === val);
    }
    function countNines(min2, len) {
      return Number(String(min2).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      let [start = 0, stop = ""] = digits;
      if (stop || start > 1) {
        return `{${start + (stop ? "," + stop : "")}}`;
      }
      return "";
    }
    function toCharacterClass(a, b, options) {
      return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
    }
    function hasPadding(str) {
      return /^-?(0+)\d/.test(str);
    }
    function padZeros(value, tok, options) {
      if (!tok.isPadded) {
        return value;
      }
      let diff = Math.abs(tok.maxLen - String(value).length);
      let relax = options.relaxZeros !== false;
      switch (diff) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default: {
          return relax ? `0{0,${diff}}` : `0{${diff}}`;
        }
      }
    }
    toRegexRange.cache = {};
    toRegexRange.clearCache = () => toRegexRange.cache = {};
    module2.exports = toRegexRange;
  });
  var require_fill_range = __commonJS((exports2, module2) => {
    /*!
     * fill-range <https://github.com/jonschlinkert/fill-range>
     *
     * Copyright (c) 2014-present, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    "use strict";
    var util2 = require("util");
    var toRegexRange = require_to_regex_range();
    var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var transform = (toNumber) => {
      return (value) => toNumber === true ? Number(value) : String(value);
    };
    var isValidValue = (value) => {
      return typeof value === "number" || typeof value === "string" && value !== "";
    };
    var isNumber = (num) => Number.isInteger(+num);
    var zeros = (input) => {
      let value = `${input}`;
      let index = -1;
      if (value[0] === "-")
        value = value.slice(1);
      if (value === "0")
        return false;
      while (value[++index] === "0")
        ;
      return index > 0;
    };
    var stringify2 = (start, end, options) => {
      if (typeof start === "string" || typeof end === "string") {
        return true;
      }
      return options.stringify === true;
    };
    var pad = (input, maxLength, toNumber) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash)
          input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber === false) {
        return String(input);
      }
      return input;
    };
    var toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength)
        input = "0" + input;
      return negative ? "-" + input : input;
    };
    var toSequence = (parts, options) => {
      parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      let prefix = options.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result;
      if (parts.positives.length) {
        positives = parts.positives.join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix}${parts.negatives.join("|")})`;
      }
      if (positives && negatives) {
        result = `${positives}|${negatives}`;
      } else {
        result = positives || negatives;
      }
      if (options.wrap) {
        return `(${prefix}${result})`;
      }
      return result;
    };
    var toRange = (a, b, isNumbers, options) => {
      if (isNumbers) {
        return toRegexRange(a, b, {wrap: false, ...options});
      }
      let start = String.fromCharCode(a);
      if (a === b)
        return start;
      let stop = String.fromCharCode(b);
      return `[${start}-${stop}]`;
    };
    var toRegex = (start, end, options) => {
      if (Array.isArray(start)) {
        let wrap = options.wrap === true;
        let prefix = options.capture ? "" : "?:";
        return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
      }
      return toRegexRange(start, end, options);
    };
    var rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util2.inspect(...args));
    };
    var invalidRange = (start, end, options) => {
      if (options.strictRanges === true)
        throw rangeError([start, end]);
      return [];
    };
    var invalidStep = (step, options) => {
      if (options.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
      }
      return [];
    };
    var fillNumbers = (start, end, step = 1, options = {}) => {
      let a = Number(start);
      let b = Number(end);
      if (!Number.isInteger(a) || !Number.isInteger(b)) {
        if (options.strictRanges === true)
          throw rangeError([start, end]);
        return [];
      }
      if (a === 0)
        a = 0;
      if (b === 0)
        b = 0;
      let descending = a > b;
      let startString = String(start);
      let endString = String(end);
      let stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber = padded === false && stringify2(start, end, options) === false;
      let format2 = options.transform || transform(toNumber);
      if (options.toRegex && step === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
      }
      let parts = {negatives: [], positives: []};
      let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        if (options.toRegex === true && step > 1) {
          push(a);
        } else {
          range.push(pad(format2(a, index), maxLen, toNumber));
        }
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return step > 1 ? toSequence(parts, options) : toRegex(range, null, {wrap: false, ...options});
      }
      return range;
    };
    var fillLetters = (start, end, step = 1, options = {}) => {
      if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
        return invalidRange(start, end, options);
      }
      let format2 = options.transform || ((val) => String.fromCharCode(val));
      let a = `${start}`.charCodeAt(0);
      let b = `${end}`.charCodeAt(0);
      let descending = a > b;
      let min2 = Math.min(a, b);
      let max2 = Math.max(a, b);
      if (options.toRegex && step === 1) {
        return toRange(min2, max2, false, options);
      }
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        range.push(format2(a, index));
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return toRegex(range, null, {wrap: false, options});
      }
      return range;
    };
    var fill = (start, end, step, options = {}) => {
      if (end == null && isValidValue(start)) {
        return [start];
      }
      if (!isValidValue(start) || !isValidValue(end)) {
        return invalidRange(start, end, options);
      }
      if (typeof step === "function") {
        return fill(start, end, 1, {transform: step});
      }
      if (isObject(step)) {
        return fill(start, end, 0, step);
      }
      let opts = {...options};
      if (opts.capture === true)
        opts.wrap = true;
      step = step || opts.step || 1;
      if (!isNumber(step)) {
        if (step != null && !isObject(step))
          return invalidStep(step, opts);
        return fill(start, end, 1, step);
      }
      if (isNumber(start) && isNumber(end)) {
        return fillNumbers(start, end, step, opts);
      }
      return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
    };
    module2.exports = fill;
  });
  var require_compile = __commonJS((exports2, module2) => {
    "use strict";
    var fill = require_fill_range();
    var utils = require_utils();
    var compile = (ast, options = {}) => {
      let walk = (node, parent = {}) => {
        let invalidBlock = utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let invalid = invalidBlock === true || invalidNode === true;
        let prefix = options.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node.isOpen === true) {
          return prefix + node.value;
        }
        if (node.isClose === true) {
          return prefix + node.value;
        }
        if (node.type === "open") {
          return invalid ? prefix + node.value : "(";
        }
        if (node.type === "close") {
          return invalid ? prefix + node.value : ")";
        }
        if (node.type === "comma") {
          return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          let range = fill(...args, {...options, wrap: false, toRegex: true});
          if (range.length !== 0) {
            return args.length > 1 && range.length > 1 ? `(${range})` : range;
          }
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += walk(child, node);
          }
        }
        return output;
      };
      return walk(ast);
    };
    module2.exports = compile;
  });
  var require_expand = __commonJS((exports2, module2) => {
    "use strict";
    var fill = require_fill_range();
    var stringify2 = require_stringify();
    var utils = require_utils();
    var append = (queue = "", stash = "", enclose = false) => {
      let result = [];
      queue = [].concat(queue);
      stash = [].concat(stash);
      if (!stash.length)
        return queue;
      if (!queue.length) {
        return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (let item of queue) {
        if (Array.isArray(item)) {
          for (let value of item) {
            result.push(append(value, stash, enclose));
          }
        } else {
          for (let ele of stash) {
            if (enclose === true && typeof ele === "string")
              ele = `{${ele}}`;
            result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
          }
        }
      }
      return utils.flatten(result);
    };
    var expand = (ast, options = {}) => {
      let rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
      let walk = (node, parent = {}) => {
        node.queue = [];
        let p = parent;
        let q = parent.queue;
        while (p.type !== "brace" && p.type !== "root" && p.parent) {
          p = p.parent;
          q = p.queue;
        }
        if (node.invalid || node.dollar) {
          q.push(append(q.pop(), stringify2(node, options)));
          return;
        }
        if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
          q.push(append(q.pop(), ["{}"]));
          return;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range = fill(...args, options);
          if (range.length === 0) {
            range = stringify2(node, options);
          }
          q.push(append(q.pop(), range));
          node.nodes = [];
          return;
        }
        let enclose = utils.encloseBrace(node);
        let queue = node.queue;
        let block = node;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue = block.queue;
        }
        for (let i = 0; i < node.nodes.length; i++) {
          let child = node.nodes[i];
          if (child.type === "comma" && node.type === "brace") {
            if (i === 1)
              queue.push("");
            queue.push("");
            continue;
          }
          if (child.type === "close") {
            q.push(append(q.pop(), queue, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue.push(append(queue.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk(child, node);
          }
        }
        return queue;
      };
      return utils.flatten(walk(ast));
    };
    module2.exports = expand;
  });
  var require_constants2 = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      CHAR_0: "0",
      CHAR_9: "9",
      CHAR_UPPERCASE_A: "A",
      CHAR_LOWERCASE_A: "a",
      CHAR_UPPERCASE_Z: "Z",
      CHAR_LOWERCASE_Z: "z",
      CHAR_LEFT_PARENTHESES: "(",
      CHAR_RIGHT_PARENTHESES: ")",
      CHAR_ASTERISK: "*",
      CHAR_AMPERSAND: "&",
      CHAR_AT: "@",
      CHAR_BACKSLASH: "\\",
      CHAR_BACKTICK: "`",
      CHAR_CARRIAGE_RETURN: "\r",
      CHAR_CIRCUMFLEX_ACCENT: "^",
      CHAR_COLON: ":",
      CHAR_COMMA: ",",
      CHAR_DOLLAR: "$",
      CHAR_DOT: ".",
      CHAR_DOUBLE_QUOTE: '"',
      CHAR_EQUAL: "=",
      CHAR_EXCLAMATION_MARK: "!",
      CHAR_FORM_FEED: "\f",
      CHAR_FORWARD_SLASH: "/",
      CHAR_HASH: "#",
      CHAR_HYPHEN_MINUS: "-",
      CHAR_LEFT_ANGLE_BRACKET: "<",
      CHAR_LEFT_CURLY_BRACE: "{",
      CHAR_LEFT_SQUARE_BRACKET: "[",
      CHAR_LINE_FEED: "\n",
      CHAR_NO_BREAK_SPACE: "\xA0",
      CHAR_PERCENT: "%",
      CHAR_PLUS: "+",
      CHAR_QUESTION_MARK: "?",
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      CHAR_RIGHT_CURLY_BRACE: "}",
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      CHAR_SEMICOLON: ";",
      CHAR_SINGLE_QUOTE: "'",
      CHAR_SPACE: " ",
      CHAR_TAB: "	",
      CHAR_UNDERSCORE: "_",
      CHAR_VERTICAL_LINE: "|",
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
    };
  });
  var require_parse3 = __commonJS((exports2, module2) => {
    "use strict";
    var stringify2 = require_stringify();
    var {
      MAX_LENGTH,
      CHAR_BACKSLASH,
      CHAR_BACKTICK,
      CHAR_COMMA,
      CHAR_DOT,
      CHAR_LEFT_PARENTHESES,
      CHAR_RIGHT_PARENTHESES,
      CHAR_LEFT_CURLY_BRACE,
      CHAR_RIGHT_CURLY_BRACE,
      CHAR_LEFT_SQUARE_BRACKET,
      CHAR_RIGHT_SQUARE_BRACKET,
      CHAR_DOUBLE_QUOTE,
      CHAR_SINGLE_QUOTE,
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = require_constants2();
    var parse2 = (input, options = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      let opts = options || {};
      let max2 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max2) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max2})`);
      }
      let ast = {type: "root", input, nodes: []};
      let stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets = 0;
      let length = input.length;
      let index = 0;
      let depth = 0;
      let value;
      let memo = {};
      const advance = () => input[index++];
      const push = (node) => {
        if (node.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node.type === "text") {
          prev.value += node.value;
          return;
        }
        block.nodes.push(node);
        node.parent = block;
        node.prev = prev;
        prev = node;
        return node;
      };
      push({type: "bos"});
      while (index < length) {
        block = stack[stack.length - 1];
        value = advance();
        if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value === CHAR_BACKSLASH) {
          push({type: "text", value: (options.keepEscaping ? value : "") + advance()});
          continue;
        }
        if (value === CHAR_RIGHT_SQUARE_BRACKET) {
          push({type: "text", value: "\\" + value});
          continue;
        }
        if (value === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          let closed = true;
          let next;
          while (index < length && (next = advance())) {
            value += next;
            if (next === CHAR_LEFT_SQUARE_BRACKET) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value += advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              brackets--;
              if (brackets === 0) {
                break;
              }
            }
          }
          push({type: "text", value});
          continue;
        }
        if (value === CHAR_LEFT_PARENTHESES) {
          block = push({type: "paren", nodes: []});
          stack.push(block);
          push({type: "text", value});
          continue;
        }
        if (value === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push({type: "text", value});
            continue;
          }
          block = stack.pop();
          push({type: "text", value});
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
          let open2 = value;
          let next;
          if (options.keepQuotes !== true) {
            value = "";
          }
          while (index < length && (next = advance())) {
            if (next === CHAR_BACKSLASH) {
              value += next + advance();
              continue;
            }
            if (next === open2) {
              if (options.keepQuotes === true)
                value += next;
              break;
            }
            value += next;
          }
          push({type: "text", value});
          continue;
        }
        if (value === CHAR_LEFT_CURLY_BRACE) {
          depth++;
          let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          let brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push(brace);
          stack.push(block);
          push({type: "open", value});
          continue;
        }
        if (value === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push({type: "text", value});
            continue;
          }
          let type = "close";
          block = stack.pop();
          block.close = true;
          push({type, value});
          depth--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_COMMA && depth > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            let open2 = block.nodes.shift();
            block.nodes = [open2, {type: "text", value: stringify2(block)}];
          }
          push({type: "comma", value});
          block.commas++;
          continue;
        }
        if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
          let siblings = block.nodes;
          if (depth === 0 || siblings.length === 0) {
            push({type: "text", value});
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            let before = siblings[siblings.length - 1];
            before.value += prev.value + value;
            prev = before;
            block.ranges--;
            continue;
          }
          push({type: "dot", value});
          continue;
        }
        push({type: "text", value});
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node) => {
            if (!node.nodes) {
              if (node.type === "open")
                node.isOpen = true;
              if (node.type === "close")
                node.isClose = true;
              if (!node.nodes)
                node.type = "text";
              node.invalid = true;
            }
          });
          let parent = stack[stack.length - 1];
          let index2 = parent.nodes.indexOf(block);
          parent.nodes.splice(index2, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push({type: "eos"});
      return ast;
    };
    module2.exports = parse2;
  });
  var require_braces = __commonJS((exports2, module2) => {
    "use strict";
    var stringify2 = require_stringify();
    var compile = require_compile();
    var expand = require_expand();
    var parse2 = require_parse3();
    var braces = (input, options = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (let pattern of input) {
          let result = braces.create(pattern, options);
          if (Array.isArray(result)) {
            output.push(...result);
          } else {
            output.push(result);
          }
        }
      } else {
        output = [].concat(braces.create(input, options));
      }
      if (options && options.expand === true && options.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces.parse = (input, options = {}) => parse2(input, options);
    braces.stringify = (input, options = {}) => {
      if (typeof input === "string") {
        return stringify2(braces.parse(input, options), options);
      }
      return stringify2(input, options);
    };
    braces.compile = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      return compile(input, options);
    };
    braces.expand = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      let result = expand(input, options);
      if (options.noempty === true) {
        result = result.filter(Boolean);
      }
      if (options.nodupes === true) {
        result = [...new Set(result)];
      }
      return result;
    };
    braces.create = (input, options = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
    };
    module2.exports = braces;
  });
  var require_constants3 = __commonJS((exports2, module2) => {
    "use strict";
    var path22 = require("path");
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      CHAR_0: 48,
      CHAR_9: 57,
      CHAR_UPPERCASE_A: 65,
      CHAR_LOWERCASE_A: 97,
      CHAR_UPPERCASE_Z: 90,
      CHAR_LOWERCASE_Z: 122,
      CHAR_LEFT_PARENTHESES: 40,
      CHAR_RIGHT_PARENTHESES: 41,
      CHAR_ASTERISK: 42,
      CHAR_AMPERSAND: 38,
      CHAR_AT: 64,
      CHAR_BACKWARD_SLASH: 92,
      CHAR_CARRIAGE_RETURN: 13,
      CHAR_CIRCUMFLEX_ACCENT: 94,
      CHAR_COLON: 58,
      CHAR_COMMA: 44,
      CHAR_DOT: 46,
      CHAR_DOUBLE_QUOTE: 34,
      CHAR_EQUAL: 61,
      CHAR_EXCLAMATION_MARK: 33,
      CHAR_FORM_FEED: 12,
      CHAR_FORWARD_SLASH: 47,
      CHAR_GRAVE_ACCENT: 96,
      CHAR_HASH: 35,
      CHAR_HYPHEN_MINUS: 45,
      CHAR_LEFT_ANGLE_BRACKET: 60,
      CHAR_LEFT_CURLY_BRACE: 123,
      CHAR_LEFT_SQUARE_BRACKET: 91,
      CHAR_LINE_FEED: 10,
      CHAR_NO_BREAK_SPACE: 160,
      CHAR_PERCENT: 37,
      CHAR_PLUS: 43,
      CHAR_QUESTION_MARK: 63,
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      CHAR_RIGHT_CURLY_BRACE: 125,
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      CHAR_SEMICOLON: 59,
      CHAR_SINGLE_QUOTE: 39,
      CHAR_SPACE: 32,
      CHAR_TAB: 9,
      CHAR_UNDERSCORE: 95,
      CHAR_VERTICAL_LINE: 124,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      SEP: path22.sep,
      extglobChars(chars) {
        return {
          "!": {type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})`},
          "?": {type: "qmark", open: "(?:", close: ")?"},
          "+": {type: "plus", open: "(?:", close: ")+"},
          "*": {type: "star", open: "(?:", close: ")*"},
          "@": {type: "at", open: "(?:", close: ")"}
        };
      },
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  });
  var require_utils2 = __commonJS((exports2) => {
    "use strict";
    var path22 = require("path");
    var win32 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants3();
    exports2.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports2.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports2.isRegexChar = (str) => str.length === 1 && exports2.hasRegexChars(str);
    exports2.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports2.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports2.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
        return match === "\\" ? "" : match;
      });
    };
    exports2.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports2.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win32 === true || path22.sep === "\\";
    };
    exports2.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1)
        return input;
      if (input[idx - 1] === "\\")
        return exports2.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports2.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports2.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
  });
  var require_scan = __commonJS((exports2, module2) => {
    "use strict";
    var utils = require_utils2();
    var {
      CHAR_ASTERISK,
      CHAR_AT,
      CHAR_BACKWARD_SLASH,
      CHAR_COMMA,
      CHAR_DOT,
      CHAR_EXCLAMATION_MARK,
      CHAR_FORWARD_SLASH,
      CHAR_LEFT_CURLY_BRACE,
      CHAR_LEFT_PARENTHESES,
      CHAR_LEFT_SQUARE_BRACKET,
      CHAR_PLUS,
      CHAR_QUESTION_MARK,
      CHAR_RIGHT_CURLY_BRACE,
      CHAR_RIGHT_PARENTHESES,
      CHAR_RIGHT_SQUARE_BRACKET
    } = require_constants3();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = {value: "", depth: 0, isGlob: false};
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = {value: "", depth: 0, isGlob: false};
          if (finished === true)
            continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK)
            isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix = "";
      let glob = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob)
          glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx];
          const value = input.slice(n, i);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module2.exports = scan;
  });
  var require_parse4 = __commonJS((exports2, module2) => {
    "use strict";
    var constants = require_constants3();
    var utils = require_utils2();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse2 = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = {...options};
      const max2 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max2) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max2}`);
      }
      const bos = {type: "bos", value: "", output: opts.prepend || ""};
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win32 = utils.isWindows(options);
      const PLATFORM_CHARS = constants.globChars(win32);
      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n = 1) => input[state.index + n];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = {...EXTGLOB_CHARS[value2], conditions: 1, inner: ""};
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({type, value: value2, output: state.output ? "" : ONE_CHAR});
        push({type: "paren", extglob: true, value: advance(), output});
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            output = token.close = `)${rest})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({type: "paren", extglob: true, value, output});
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m2, esc, chars, first, rest, index) => {
          if (first === "\\") {
            backslashes = true;
            return m2;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star : "");
            }
            return star;
          }
          return esc ? m2 : `\\${m2}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m2) => {
              return m2.length % 2 === 0 ? "\\\\" : m2 ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({type: "text", value});
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push({type: "text", value});
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix = POSIX_REGEX_SOURCE[rest2];
                if (posix) {
                  prev.value = pre + posix;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append({value});
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append({value});
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({type: "text", value});
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({type: "paren", value});
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({type: "paren", value, output: state.parens ? ")" : "\\)"});
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({type: "bracket", value});
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({type: "text", value, output: `\\${value}`});
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({type: "text", value, output: `\\${value}`});
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append({value});
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open2 = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open2);
          push(open2);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({type: "text", value, output: value});
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range.unshift(arr[i].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push({type: "brace", value, output});
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({type: "text", value});
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({type: "comma", value, output});
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({type: "slash", value, output: SLASH_LITERAL});
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({type: "text", value, output: DOT_LITERAL});
            continue;
          }
          push({type: "dot", value, output: DOT_LITERAL});
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (next === "<" && !utils.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({type: "text", value, output});
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({type: "qmark", value, output: QMARK_NO_DOT});
            continue;
          }
          push({type: "qmark", value, output: QMARK});
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({type: "plus", value, output: PLUS_LITERAL});
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({type: "plus", value});
            continue;
          }
          push({type: "plus", value: PLUS_LITERAL});
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({type: "at", extglob: true, value, output: ""});
            continue;
          }
          push({type: "text", value});
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match) {
            value += match[0];
            state.index += match[0].length;
          }
          push({type: "text", value});
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({type: "star", value, output: ""});
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({type: "star", value, output: ""});
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push({type: "slash", value: "/", output: ""});
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push({type: "slash", value: "/", output: ""});
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = {type: "star", value, output: star};
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?`});
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse2.fastpaths = (input, options) => {
      const opts = {...options};
      const max2 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max2) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max2}`);
      }
      input = REPLACEMENTS[input] || input;
      const win32 = utils.isWindows(options);
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(win32);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = {negated: false, prefix: ""};
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match)
              return;
            const source2 = create(match[1]);
            if (!source2)
              return;
            return source2 + DOT_LITERAL + match[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module2.exports = parse2;
  });
  var require_picomatch = __commonJS((exports2, module2) => {
    "use strict";
    var path22 = require("path");
    var scan = require_scan();
    var parse2 = require_parse4();
    var utils = require_utils2();
    var constants = require_constants3();
    var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2)
              return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix = utils.isWindows(options);
      const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = {...options, ignore: null, onMatch: null, onResult: null};
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const {isMatch, match, output} = picomatch.test(input, regex, options, {glob, posix});
        const result = {glob, state, regex, posix, input, output, match, isMatch};
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input, regex, options, {glob, posix} = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return {isMatch: false, output: ""};
      }
      const opts = options || {};
      const format2 = opts.format || (posix ? utils.toPosixSlashes : null);
      let match = input === glob;
      let output = match && format2 ? format2(input) : input;
      if (match === false) {
        output = format2 ? format2(input) : input;
        match = output === glob;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch.matchBase(input, regex, options, posix);
        } else {
          match = regex.exec(output);
        }
      }
      return {isMatch: Boolean(match), match, output};
    };
    picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
      return regex.test(path22.basename(input));
    };
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern))
        return pattern.map((p) => picomatch.parse(p, options));
      return parse2(pattern, {...options, fastpaths: false});
    };
    picomatch.scan = (input, options) => scan(input, options);
    picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = {negated: false, fastpaths: true};
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse2.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse2(input, options);
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true)
          throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants;
    module2.exports = picomatch;
  });
  var require_picomatch2 = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = require_picomatch();
  });
  var require_micromatch = __commonJS((exports2, module2) => {
    "use strict";
    var util2 = require("util");
    var braces = require_braces();
    var picomatch = require_picomatch2();
    var utils = require_utils2();
    var isEmptyString = (val) => val === "" || val === "./";
    var micromatch = (list, patterns, options) => {
      patterns = [].concat(patterns);
      list = [].concat(list);
      let omit = new Set();
      let keep = new Set();
      let items = new Set();
      let negatives = 0;
      let onResult = (state) => {
        items.add(state.output);
        if (options && options.onResult) {
          options.onResult(state);
        }
      };
      for (let i = 0; i < patterns.length; i++) {
        let isMatch = picomatch(String(patterns[i]), {...options, onResult}, true);
        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
        if (negated)
          negatives++;
        for (let item of list) {
          let matched = isMatch(item, true);
          let match = negated ? !matched.isMatch : matched.isMatch;
          if (!match)
            continue;
          if (negated) {
            omit.add(matched.output);
          } else {
            omit.delete(matched.output);
            keep.add(matched.output);
          }
        }
      }
      let result = negatives === patterns.length ? [...items] : [...keep];
      let matches = result.filter((item) => !omit.has(item));
      if (options && matches.length === 0) {
        if (options.failglob === true) {
          throw new Error(`No matches found for "${patterns.join(", ")}"`);
        }
        if (options.nonull === true || options.nullglob === true) {
          return options.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
        }
      }
      return matches;
    };
    micromatch.match = micromatch;
    micromatch.matcher = (pattern, options) => picomatch(pattern, options);
    micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    micromatch.any = micromatch.isMatch;
    micromatch.not = (list, patterns, options = {}) => {
      patterns = [].concat(patterns).map(String);
      let result = new Set();
      let items = [];
      let onResult = (state) => {
        if (options.onResult)
          options.onResult(state);
        items.push(state.output);
      };
      let matches = micromatch(list, patterns, {...options, onResult});
      for (let item of items) {
        if (!matches.includes(item)) {
          result.add(item);
        }
      }
      return [...result];
    };
    micromatch.contains = (str, pattern, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util2.inspect(str)}"`);
      }
      if (Array.isArray(pattern)) {
        return pattern.some((p) => micromatch.contains(str, p, options));
      }
      if (typeof pattern === "string") {
        if (isEmptyString(str) || isEmptyString(pattern)) {
          return false;
        }
        if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern)) {
          return true;
        }
      }
      return micromatch.isMatch(str, pattern, {...options, contains: true});
    };
    micromatch.matchKeys = (obj, patterns, options) => {
      if (!utils.isObject(obj)) {
        throw new TypeError("Expected the first argument to be an object");
      }
      let keys = micromatch(Object.keys(obj), patterns, options);
      let res = {};
      for (let key of keys)
        res[key] = obj[key];
      return res;
    };
    micromatch.some = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (items.some((item) => isMatch(item))) {
          return true;
        }
      }
      return false;
    };
    micromatch.every = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (!items.every((item) => isMatch(item))) {
          return false;
        }
      }
      return true;
    };
    micromatch.all = (str, patterns, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util2.inspect(str)}"`);
      }
      return [].concat(patterns).every((p) => picomatch(p, options)(str));
    };
    micromatch.capture = (glob, input, options) => {
      let posix = utils.isWindows(options);
      let regex = picomatch.makeRe(String(glob), {...options, capture: true});
      let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);
      if (match) {
        return match.slice(1).map((v) => v === void 0 ? "" : v);
      }
    };
    micromatch.makeRe = (...args) => picomatch.makeRe(...args);
    micromatch.scan = (...args) => picomatch.scan(...args);
    micromatch.parse = (patterns, options) => {
      let res = [];
      for (let pattern of [].concat(patterns || [])) {
        for (let str of braces(String(pattern), options)) {
          res.push(picomatch.parse(str, options));
        }
      }
      return res;
    };
    micromatch.braces = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
        return [pattern];
      }
      return braces(pattern, options);
    };
    micromatch.braceExpand = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      return micromatch.braces(pattern, {...options, expand: true});
    };
    module2.exports = micromatch;
  });
  var require_pattern = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.matchAny = exports2.convertPatternsToRe = exports2.makeRe = exports2.getPatternParts = exports2.expandBraceExpansion = exports2.expandPatternsWithBraceExpansion = exports2.isAffectDepthOfReadingPattern = exports2.endsWithSlashGlobStar = exports2.hasGlobStar = exports2.getBaseDirectory = exports2.getPositivePatterns = exports2.getNegativePatterns = exports2.isPositivePattern = exports2.isNegativePattern = exports2.convertToNegativePattern = exports2.convertToPositivePattern = exports2.isDynamicPattern = exports2.isStaticPattern = void 0;
    var path22 = require("path");
    var globParent = require_glob_parent();
    var micromatch = require_micromatch();
    var picomatch = require_picomatch2();
    var GLOBSTAR = "**";
    var ESCAPE_SYMBOL = "\\";
    var COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
    var REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[.*]/;
    var REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\(.*\|.*\)/;
    var GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\(.*\)/;
    var BRACE_EXPANSIONS_SYMBOLS_RE = /{.*(?:,|\.\.).*}/;
    function isStaticPattern(pattern, options = {}) {
      return !isDynamicPattern(pattern, options);
    }
    exports2.isStaticPattern = isStaticPattern;
    function isDynamicPattern(pattern, options = {}) {
      if (pattern === "") {
        return false;
      }
      if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
        return true;
      }
      if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options.braceExpansion !== false && BRACE_EXPANSIONS_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      return false;
    }
    exports2.isDynamicPattern = isDynamicPattern;
    function convertToPositivePattern(pattern) {
      return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
    }
    exports2.convertToPositivePattern = convertToPositivePattern;
    function convertToNegativePattern(pattern) {
      return "!" + pattern;
    }
    exports2.convertToNegativePattern = convertToNegativePattern;
    function isNegativePattern(pattern) {
      return pattern.startsWith("!") && pattern[1] !== "(";
    }
    exports2.isNegativePattern = isNegativePattern;
    function isPositivePattern(pattern) {
      return !isNegativePattern(pattern);
    }
    exports2.isPositivePattern = isPositivePattern;
    function getNegativePatterns(patterns) {
      return patterns.filter(isNegativePattern);
    }
    exports2.getNegativePatterns = getNegativePatterns;
    function getPositivePatterns(patterns) {
      return patterns.filter(isPositivePattern);
    }
    exports2.getPositivePatterns = getPositivePatterns;
    function getBaseDirectory(pattern) {
      return globParent(pattern, {flipBackslashes: false});
    }
    exports2.getBaseDirectory = getBaseDirectory;
    function hasGlobStar(pattern) {
      return pattern.includes(GLOBSTAR);
    }
    exports2.hasGlobStar = hasGlobStar;
    function endsWithSlashGlobStar(pattern) {
      return pattern.endsWith("/" + GLOBSTAR);
    }
    exports2.endsWithSlashGlobStar = endsWithSlashGlobStar;
    function isAffectDepthOfReadingPattern(pattern) {
      const basename = path22.basename(pattern);
      return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
    }
    exports2.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
    function expandPatternsWithBraceExpansion(patterns) {
      return patterns.reduce((collection, pattern) => {
        return collection.concat(expandBraceExpansion(pattern));
      }, []);
    }
    exports2.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
    function expandBraceExpansion(pattern) {
      return micromatch.braces(pattern, {
        expand: true,
        nodupes: true
      });
    }
    exports2.expandBraceExpansion = expandBraceExpansion;
    function getPatternParts(pattern, options) {
      let {parts} = picomatch.scan(pattern, Object.assign(Object.assign({}, options), {parts: true}));
      if (parts.length === 0) {
        parts = [pattern];
      }
      if (parts[0].startsWith("/")) {
        parts[0] = parts[0].slice(1);
        parts.unshift("");
      }
      return parts;
    }
    exports2.getPatternParts = getPatternParts;
    function makeRe(pattern, options) {
      return micromatch.makeRe(pattern, options);
    }
    exports2.makeRe = makeRe;
    function convertPatternsToRe(patterns, options) {
      return patterns.map((pattern) => makeRe(pattern, options));
    }
    exports2.convertPatternsToRe = convertPatternsToRe;
    function matchAny(entry, patternsRe) {
      return patternsRe.some((patternRe) => patternRe.test(entry));
    }
    exports2.matchAny = matchAny;
  });
  var require_stream2 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.merge = void 0;
    var merge2 = require_merge2();
    function merge(streams) {
      const mergedStream = merge2(streams);
      streams.forEach((stream) => {
        stream.once("error", (error) => mergedStream.emit("error", error));
      });
      mergedStream.once("close", () => propagateCloseEventToSources(streams));
      mergedStream.once("end", () => propagateCloseEventToSources(streams));
      return mergedStream;
    }
    exports2.merge = merge;
    function propagateCloseEventToSources(streams) {
      streams.forEach((stream) => stream.emit("close"));
    }
  });
  var require_string = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.isEmpty = exports2.isString = void 0;
    function isString(input) {
      return typeof input === "string";
    }
    exports2.isString = isString;
    function isEmpty(input) {
      return input === "";
    }
    exports2.isEmpty = isEmpty;
  });
  var require_utils3 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.string = exports2.stream = exports2.pattern = exports2.path = exports2.fs = exports2.errno = exports2.array = void 0;
    var array = require_array();
    exports2.array = array;
    var errno = require_errno();
    exports2.errno = errno;
    var fs2 = require_fs2();
    exports2.fs = fs2;
    var path22 = require_path();
    exports2.path = path22;
    var pattern = require_pattern();
    exports2.pattern = pattern;
    var stream = require_stream2();
    exports2.stream = stream;
    var string = require_string();
    exports2.string = string;
  });
  var require_tasks = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.convertPatternGroupToTask = exports2.convertPatternGroupsToTasks = exports2.groupPatternsByBaseDirectory = exports2.getNegativePatternsAsPositive = exports2.getPositivePatterns = exports2.convertPatternsToTasks = exports2.generate = void 0;
    var utils = require_utils3();
    function generate(patterns, settings) {
      const positivePatterns = getPositivePatterns(patterns);
      const negativePatterns = getNegativePatternsAsPositive(patterns, settings.ignore);
      const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));
      const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));
      const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, false);
      const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, true);
      return staticTasks.concat(dynamicTasks);
    }
    exports2.generate = generate;
    function convertPatternsToTasks(positive, negative, dynamic) {
      const positivePatternsGroup = groupPatternsByBaseDirectory(positive);
      if ("." in positivePatternsGroup) {
        const task = convertPatternGroupToTask(".", positive, negative, dynamic);
        return [task];
      }
      return convertPatternGroupsToTasks(positivePatternsGroup, negative, dynamic);
    }
    exports2.convertPatternsToTasks = convertPatternsToTasks;
    function getPositivePatterns(patterns) {
      return utils.pattern.getPositivePatterns(patterns);
    }
    exports2.getPositivePatterns = getPositivePatterns;
    function getNegativePatternsAsPositive(patterns, ignore) {
      const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);
      const positive = negative.map(utils.pattern.convertToPositivePattern);
      return positive;
    }
    exports2.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
    function groupPatternsByBaseDirectory(patterns) {
      const group = {};
      return patterns.reduce((collection, pattern) => {
        const base = utils.pattern.getBaseDirectory(pattern);
        if (base in collection) {
          collection[base].push(pattern);
        } else {
          collection[base] = [pattern];
        }
        return collection;
      }, group);
    }
    exports2.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
    function convertPatternGroupsToTasks(positive, negative, dynamic) {
      return Object.keys(positive).map((base) => {
        return convertPatternGroupToTask(base, positive[base], negative, dynamic);
      });
    }
    exports2.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
    function convertPatternGroupToTask(base, positive, negative, dynamic) {
      return {
        dynamic,
        positive,
        negative,
        base,
        patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))
      };
    }
    exports2.convertPatternGroupToTask = convertPatternGroupToTask;
  });
  var require_async = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.read = void 0;
    function read(path22, settings, callback) {
      settings.fs.lstat(path22, (lstatError, lstat) => {
        if (lstatError !== null) {
          return callFailureCallback(callback, lstatError);
        }
        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
          return callSuccessCallback(callback, lstat);
        }
        settings.fs.stat(path22, (statError, stat2) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              return callFailureCallback(callback, statError);
            }
            return callSuccessCallback(callback, lstat);
          }
          if (settings.markSymbolicLink) {
            stat2.isSymbolicLink = () => true;
          }
          callSuccessCallback(callback, stat2);
        });
      });
    }
    exports2.read = read;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  });
  var require_sync2 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.read = void 0;
    function read(path22, settings) {
      const lstat = settings.fs.lstatSync(path22);
      if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
        return lstat;
      }
      try {
        const stat2 = settings.fs.statSync(path22);
        if (settings.markSymbolicLink) {
          stat2.isSymbolicLink = () => true;
        }
        return stat2;
      } catch (error) {
        if (!settings.throwErrorOnBrokenSymbolicLink) {
          return lstat;
        }
        throw error;
      }
    }
    exports2.read = read;
  });
  var require_fs3 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
    var fs2 = require("fs");
    exports2.FILE_SYSTEM_ADAPTER = {
      lstat: fs2.lstat,
      stat: fs2.stat,
      lstatSync: fs2.lstatSync,
      statSync: fs2.statSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports2.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports2.createFileSystemAdapter = createFileSystemAdapter;
  });
  var require_settings = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var fs2 = require_fs3();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
        this.fs = fs2.createFileSystemAdapter(this._options.fs);
        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports2.default = Settings;
  });
  var require_out = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.statSync = exports2.stat = exports2.Settings = void 0;
    var async = require_async();
    var sync2 = require_sync2();
    var settings_1 = require_settings();
    exports2.Settings = settings_1.default;
    function stat2(path22, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        return async.read(path22, getSettings(), optionsOrSettingsOrCallback);
      }
      async.read(path22, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports2.stat = stat2;
    function statSync(path22, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync2.read(path22, settings);
    }
    exports2.statSync = statSync;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  });
  var require_queue_microtask = __commonJS((exports2, module2) => {
    /*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
    var promise;
    module2.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
      throw err;
    }, 0));
  });
  var require_run_parallel = __commonJS((exports2, module2) => {
    /*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
    module2.exports = runParallel;
    var queueMicrotask2 = require_queue_microtask();
    function runParallel(tasks, cb) {
      let results, pending, keys;
      let isSync = true;
      if (Array.isArray(tasks)) {
        results = [];
        pending = tasks.length;
      } else {
        keys = Object.keys(tasks);
        results = {};
        pending = keys.length;
      }
      function done(err) {
        function end() {
          if (cb)
            cb(err, results);
          cb = null;
        }
        if (isSync)
          queueMicrotask2(end);
        else
          end();
      }
      function each(i, err, result) {
        results[i] = result;
        if (--pending === 0 || err) {
          done(err);
        }
      }
      if (!pending) {
        done(null);
      } else if (keys) {
        keys.forEach(function(key) {
          tasks[key](function(err, result) {
            each(key, err, result);
          });
        });
      } else {
        tasks.forEach(function(task, i) {
          task(function(err, result) {
            each(i, err, result);
          });
        });
      }
      isSync = false;
    }
  });
  var require_constants4 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
    var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
    var MAJOR_VERSION = parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
    var MINOR_VERSION = parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
    var SUPPORTED_MAJOR_VERSION = 10;
    var SUPPORTED_MINOR_VERSION = 10;
    var IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
    var IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
    exports2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
  });
  var require_fs4 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports2.createDirentFromStats = createDirentFromStats;
  });
  var require_utils4 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.fs = void 0;
    var fs2 = require_fs4();
    exports2.fs = fs2;
  });
  var require_common4 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.joinPathSegments = void 0;
    function joinPathSegments(a, b, separator) {
      if (a.endsWith(separator)) {
        return a + b;
      }
      return a + separator + b;
    }
    exports2.joinPathSegments = joinPathSegments;
  });
  var require_async2 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.readdir = exports2.readdirWithFileTypes = exports2.read = void 0;
    var fsStat = require_out();
    var rpl = require_run_parallel();
    var constants_1 = require_constants4();
    var utils = require_utils4();
    var common = require_common4();
    function read(directory, settings, callback) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings, callback);
      }
      return readdir2(directory, settings, callback);
    }
    exports2.read = read;
    function readdirWithFileTypes(directory, settings, callback) {
      settings.fs.readdir(directory, {withFileTypes: true}, (readdirError, dirents) => {
        if (readdirError !== null) {
          return callFailureCallback(callback, readdirError);
        }
        const entries = dirents.map((dirent) => ({
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        }));
        if (!settings.followSymbolicLinks) {
          return callSuccessCallback(callback, entries);
        }
        const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));
        rpl(tasks, (rplError, rplEntries) => {
          if (rplError !== null) {
            return callFailureCallback(callback, rplError);
          }
          callSuccessCallback(callback, rplEntries);
        });
      });
    }
    exports2.readdirWithFileTypes = readdirWithFileTypes;
    function makeRplTaskEntry(entry, settings) {
      return (done) => {
        if (!entry.dirent.isSymbolicLink()) {
          return done(null, entry);
        }
        settings.fs.stat(entry.path, (statError, stats) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              return done(statError);
            }
            return done(null, entry);
          }
          entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          return done(null, entry);
        });
      };
    }
    function readdir2(directory, settings, callback) {
      settings.fs.readdir(directory, (readdirError, names) => {
        if (readdirError !== null) {
          return callFailureCallback(callback, readdirError);
        }
        const filepaths = names.map((name) => common.joinPathSegments(directory, name, settings.pathSegmentSeparator));
        const tasks = filepaths.map((filepath) => {
          return (done) => fsStat.stat(filepath, settings.fsStatSettings, done);
        });
        rpl(tasks, (rplError, results) => {
          if (rplError !== null) {
            return callFailureCallback(callback, rplError);
          }
          const entries = [];
          names.forEach((name, index) => {
            const stats = results[index];
            const entry = {
              name,
              path: filepaths[index],
              dirent: utils.fs.createDirentFromStats(name, stats)
            };
            if (settings.stats) {
              entry.stats = stats;
            }
            entries.push(entry);
          });
          callSuccessCallback(callback, entries);
        });
      });
    }
    exports2.readdir = readdir2;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  });
  var require_sync3 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.readdir = exports2.readdirWithFileTypes = exports2.read = void 0;
    var fsStat = require_out();
    var constants_1 = require_constants4();
    var utils = require_utils4();
    var common = require_common4();
    function read(directory, settings) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings);
      }
      return readdir2(directory, settings);
    }
    exports2.read = read;
    function readdirWithFileTypes(directory, settings) {
      const dirents = settings.fs.readdirSync(directory, {withFileTypes: true});
      return dirents.map((dirent) => {
        const entry = {
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        };
        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
          try {
            const stats = settings.fs.statSync(entry.path);
            entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          } catch (error) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              throw error;
            }
          }
        }
        return entry;
      });
    }
    exports2.readdirWithFileTypes = readdirWithFileTypes;
    function readdir2(directory, settings) {
      const names = settings.fs.readdirSync(directory);
      return names.map((name) => {
        const entryPath = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
        const stats = fsStat.statSync(entryPath, settings.fsStatSettings);
        const entry = {
          name,
          path: entryPath,
          dirent: utils.fs.createDirentFromStats(name, stats)
        };
        if (settings.stats) {
          entry.stats = stats;
        }
        return entry;
      });
    }
    exports2.readdir = readdir2;
  });
  var require_fs5 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
    var fs2 = require("fs");
    exports2.FILE_SYSTEM_ADAPTER = {
      lstat: fs2.lstat,
      stat: fs2.stat,
      lstatSync: fs2.lstatSync,
      statSync: fs2.statSync,
      readdir: fs2.readdir,
      readdirSync: fs2.readdirSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports2.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports2.createFileSystemAdapter = createFileSystemAdapter;
  });
  var require_settings2 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var path22 = require("path");
    var fsStat = require_out();
    var fs2 = require_fs5();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
        this.fs = fs2.createFileSystemAdapter(this._options.fs);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path22.sep);
        this.stats = this._getValue(this._options.stats, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        this.fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this.followSymbolicLinks,
          fs: this.fs,
          throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports2.default = Settings;
  });
  var require_out2 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.Settings = exports2.scandirSync = exports2.scandir = void 0;
    var async = require_async2();
    var sync2 = require_sync3();
    var settings_1 = require_settings2();
    exports2.Settings = settings_1.default;
    function scandir(path22, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        return async.read(path22, getSettings(), optionsOrSettingsOrCallback);
      }
      async.read(path22, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports2.scandir = scandir;
    function scandirSync(path22, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync2.read(path22, settings);
    }
    exports2.scandirSync = scandirSync;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  });
  var require_reusify = __commonJS((exports2, module2) => {
    "use strict";
    function reusify(Constructor) {
      var head = new Constructor();
      var tail = head;
      function get() {
        var current = head;
        if (current.next) {
          head = current.next;
        } else {
          head = new Constructor();
          tail = head;
        }
        current.next = null;
        return current;
      }
      function release(obj) {
        tail.next = obj;
        tail = obj;
      }
      return {
        get,
        release
      };
    }
    module2.exports = reusify;
  });
  var require_queue = __commonJS((exports2, module2) => {
    "use strict";
    var reusify = require_reusify();
    function fastqueue(context, worker, concurrency) {
      if (typeof context === "function") {
        concurrency = worker;
        worker = context;
        context = null;
      }
      if (concurrency < 1) {
        throw new Error("fastqueue concurrency must be greater than 1");
      }
      var cache = reusify(Task);
      var queueHead = null;
      var queueTail = null;
      var _running = 0;
      var errorHandler = null;
      var self2 = {
        push,
        drain: noop,
        saturated: noop,
        pause,
        paused: false,
        concurrency,
        running,
        resume,
        idle,
        length,
        getQueue,
        unshift,
        empty: noop,
        kill,
        killAndDrain,
        error
      };
      return self2;
      function running() {
        return _running;
      }
      function pause() {
        self2.paused = true;
      }
      function length() {
        var current = queueHead;
        var counter2 = 0;
        while (current) {
          current = current.next;
          counter2++;
        }
        return counter2;
      }
      function getQueue() {
        var current = queueHead;
        var tasks = [];
        while (current) {
          tasks.push(current.value);
          current = current.next;
        }
        return tasks;
      }
      function resume() {
        if (!self2.paused)
          return;
        self2.paused = false;
        for (var i = 0; i < self2.concurrency; i++) {
          _running++;
          release();
        }
      }
      function idle() {
        return _running === 0 && self2.length() === 0;
      }
      function push(value, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value;
        current.callback = done || noop;
        current.errorHandler = errorHandler;
        if (_running === self2.concurrency || self2.paused) {
          if (queueTail) {
            queueTail.next = current;
            queueTail = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function unshift(value, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value;
        current.callback = done || noop;
        if (_running === self2.concurrency || self2.paused) {
          if (queueHead) {
            current.next = queueHead;
            queueHead = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function release(holder) {
        if (holder) {
          cache.release(holder);
        }
        var next = queueHead;
        if (next) {
          if (!self2.paused) {
            if (queueTail === queueHead) {
              queueTail = null;
            }
            queueHead = next.next;
            next.next = null;
            worker.call(context, next.value, next.worked);
            if (queueTail === null) {
              self2.empty();
            }
          } else {
            _running--;
          }
        } else if (--_running === 0) {
          self2.drain();
        }
      }
      function kill() {
        queueHead = null;
        queueTail = null;
        self2.drain = noop;
      }
      function killAndDrain() {
        queueHead = null;
        queueTail = null;
        self2.drain();
        self2.drain = noop;
      }
      function error(handler) {
        errorHandler = handler;
      }
    }
    function noop() {
    }
    function Task() {
      this.value = null;
      this.callback = noop;
      this.next = null;
      this.release = noop;
      this.context = null;
      this.errorHandler = null;
      var self2 = this;
      this.worked = function worked(err, result) {
        var callback = self2.callback;
        var errorHandler = self2.errorHandler;
        var val = self2.value;
        self2.value = null;
        self2.callback = noop;
        if (self2.errorHandler) {
          errorHandler(err, val);
        }
        callback.call(self2.context, err, result);
        self2.release(self2);
      };
    }
    function queueAsPromised(context, worker, concurrency) {
      if (typeof context === "function") {
        concurrency = worker;
        worker = context;
        context = null;
      }
      function asyncWrapper(arg2, cb) {
        worker.call(this, arg2).then(function(res) {
          cb(null, res);
        }, cb);
      }
      var queue = fastqueue(context, asyncWrapper, concurrency);
      var pushCb = queue.push;
      var unshiftCb = queue.unshift;
      queue.push = push;
      queue.unshift = unshift;
      return queue;
      function push(value) {
        return new Promise(function(resolve, reject) {
          pushCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve(result);
          });
        });
      }
      function unshift(value) {
        return new Promise(function(resolve, reject) {
          unshiftCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve(result);
          });
        });
      }
    }
    module2.exports = fastqueue;
    module2.exports.promise = queueAsPromised;
  });
  var require_common5 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.joinPathSegments = exports2.replacePathSegmentSeparator = exports2.isAppliedFilter = exports2.isFatalError = void 0;
    function isFatalError(settings, error) {
      if (settings.errorFilter === null) {
        return true;
      }
      return !settings.errorFilter(error);
    }
    exports2.isFatalError = isFatalError;
    function isAppliedFilter(filter, value) {
      return filter === null || filter(value);
    }
    exports2.isAppliedFilter = isAppliedFilter;
    function replacePathSegmentSeparator(filepath, separator) {
      return filepath.split(/[/\\]/).join(separator);
    }
    exports2.replacePathSegmentSeparator = replacePathSegmentSeparator;
    function joinPathSegments(a, b, separator) {
      if (a === "") {
        return b;
      }
      if (a.endsWith(separator)) {
        return a + b;
      }
      return a + separator + b;
    }
    exports2.joinPathSegments = joinPathSegments;
  });
  var require_reader = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var common = require_common5();
    var Reader = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
      }
    };
    exports2.default = Reader;
  });
  var require_async3 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var events_1 = require("events");
    var fsScandir = require_out2();
    var fastq = require_queue();
    var common = require_common5();
    var reader_1 = require_reader();
    var AsyncReader = class extends reader_1.default {
      constructor(_root, _settings) {
        super(_root, _settings);
        this._settings = _settings;
        this._scandir = fsScandir.scandir;
        this._emitter = new events_1.EventEmitter();
        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
        this._isFatalError = false;
        this._isDestroyed = false;
        this._queue.drain = () => {
          if (!this._isFatalError) {
            this._emitter.emit("end");
          }
        };
      }
      read() {
        this._isFatalError = false;
        this._isDestroyed = false;
        setImmediate(() => {
          this._pushToQueue(this._root, this._settings.basePath);
        });
        return this._emitter;
      }
      get isDestroyed() {
        return this._isDestroyed;
      }
      destroy() {
        if (this._isDestroyed) {
          throw new Error("The reader is already destroyed");
        }
        this._isDestroyed = true;
        this._queue.killAndDrain();
      }
      onEntry(callback) {
        this._emitter.on("entry", callback);
      }
      onError(callback) {
        this._emitter.once("error", callback);
      }
      onEnd(callback) {
        this._emitter.once("end", callback);
      }
      _pushToQueue(directory, base) {
        const queueItem = {directory, base};
        this._queue.push(queueItem, (error) => {
          if (error !== null) {
            this._handleError(error);
          }
        });
      }
      _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {
          if (error !== null) {
            return done(error, void 0);
          }
          for (const entry of entries) {
            this._handleEntry(entry, item.base);
          }
          done(null, void 0);
        });
      }
      _handleError(error) {
        if (this._isDestroyed || !common.isFatalError(this._settings, error)) {
          return;
        }
        this._isFatalError = true;
        this._isDestroyed = true;
        this._emitter.emit("error", error);
      }
      _handleEntry(entry, base) {
        if (this._isDestroyed || this._isFatalError) {
          return;
        }
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._emitEntry(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, entry.path);
        }
      }
      _emitEntry(entry) {
        this._emitter.emit("entry", entry);
      }
    };
    exports2.default = AsyncReader;
  });
  var require_async4 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var async_1 = require_async3();
    var AsyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._storage = new Set();
      }
      read(callback) {
        this._reader.onError((error) => {
          callFailureCallback(callback, error);
        });
        this._reader.onEntry((entry) => {
          this._storage.add(entry);
        });
        this._reader.onEnd(() => {
          callSuccessCallback(callback, [...this._storage]);
        });
        this._reader.read();
      }
    };
    exports2.default = AsyncProvider;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, entries) {
      callback(null, entries);
    }
  });
  var require_stream3 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var stream_1 = require("stream");
    var async_1 = require_async3();
    var StreamProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._stream = new stream_1.Readable({
          objectMode: true,
          read: () => {
          },
          destroy: () => {
            if (!this._reader.isDestroyed) {
              this._reader.destroy();
            }
          }
        });
      }
      read() {
        this._reader.onError((error) => {
          this._stream.emit("error", error);
        });
        this._reader.onEntry((entry) => {
          this._stream.push(entry);
        });
        this._reader.onEnd(() => {
          this._stream.push(null);
        });
        this._reader.read();
        return this._stream;
      }
    };
    exports2.default = StreamProvider;
  });
  var require_sync4 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var fsScandir = require_out2();
    var common = require_common5();
    var reader_1 = require_reader();
    var SyncReader = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._scandir = fsScandir.scandirSync;
        this._storage = new Set();
        this._queue = new Set();
      }
      read() {
        this._pushToQueue(this._root, this._settings.basePath);
        this._handleQueue();
        return [...this._storage];
      }
      _pushToQueue(directory, base) {
        this._queue.add({directory, base});
      }
      _handleQueue() {
        for (const item of this._queue.values()) {
          this._handleDirectory(item.directory, item.base);
        }
      }
      _handleDirectory(directory, base) {
        try {
          const entries = this._scandir(directory, this._settings.fsScandirSettings);
          for (const entry of entries) {
            this._handleEntry(entry, base);
          }
        } catch (error) {
          this._handleError(error);
        }
      }
      _handleError(error) {
        if (!common.isFatalError(this._settings, error)) {
          return;
        }
        throw error;
      }
      _handleEntry(entry, base) {
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._pushToStorage(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, entry.path);
        }
      }
      _pushToStorage(entry) {
        this._storage.add(entry);
      }
    };
    exports2.default = SyncReader;
  });
  var require_sync5 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var sync_1 = require_sync4();
    var SyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new sync_1.default(this._root, this._settings);
      }
      read() {
        return this._reader.read();
      }
    };
    exports2.default = SyncProvider;
  });
  var require_settings3 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var path22 = require("path");
    var fsScandir = require_out2();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.basePath = this._getValue(this._options.basePath, void 0);
        this.concurrency = this._getValue(this._options.concurrency, Infinity);
        this.deepFilter = this._getValue(this._options.deepFilter, null);
        this.entryFilter = this._getValue(this._options.entryFilter, null);
        this.errorFilter = this._getValue(this._options.errorFilter, null);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path22.sep);
        this.fsScandirSettings = new fsScandir.Settings({
          followSymbolicLinks: this._options.followSymbolicLinks,
          fs: this._options.fs,
          pathSegmentSeparator: this._options.pathSegmentSeparator,
          stats: this._options.stats,
          throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports2.default = Settings;
  });
  var require_out3 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.Settings = exports2.walkStream = exports2.walkSync = exports2.walk = void 0;
    var async_1 = require_async4();
    var stream_1 = require_stream3();
    var sync_1 = require_sync5();
    var settings_1 = require_settings3();
    exports2.Settings = settings_1.default;
    function walk(directory, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        return new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
      }
      new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
    }
    exports2.walk = walk;
    function walkSync(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new sync_1.default(directory, settings);
      return provider.read();
    }
    exports2.walkSync = walkSync;
    function walkStream(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new stream_1.default(directory, settings);
      return provider.read();
    }
    exports2.walkStream = walkStream;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  });
  var require_reader2 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var path22 = require("path");
    var fsStat = require_out();
    var utils = require_utils3();
    var Reader = class {
      constructor(_settings) {
        this._settings = _settings;
        this._fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
      }
      _getFullEntryPath(filepath) {
        return path22.resolve(this._settings.cwd, filepath);
      }
      _makeEntry(stats, pattern) {
        const entry = {
          name: pattern,
          path: pattern,
          dirent: utils.fs.createDirentFromStats(pattern, stats)
        };
        if (this._settings.stats) {
          entry.stats = stats;
        }
        return entry;
      }
      _isFatalError(error) {
        return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
      }
    };
    exports2.default = Reader;
  });
  var require_stream4 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var stream_1 = require("stream");
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderStream = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkStream = fsWalk.walkStream;
        this._stat = fsStat.stat;
      }
      dynamic(root, options) {
        return this._walkStream(root, options);
      }
      static(patterns, options) {
        const filepaths = patterns.map(this._getFullEntryPath, this);
        const stream = new stream_1.PassThrough({objectMode: true});
        stream._write = (index, _enc, done) => {
          return this._getEntry(filepaths[index], patterns[index], options).then((entry) => {
            if (entry !== null && options.entryFilter(entry)) {
              stream.push(entry);
            }
            if (index === filepaths.length - 1) {
              stream.end();
            }
            done();
          }).catch(done);
        };
        for (let i = 0; i < filepaths.length; i++) {
          stream.write(i);
        }
        return stream;
      }
      _getEntry(filepath, pattern, options) {
        return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern)).catch((error) => {
          if (options.errorFilter(error)) {
            return null;
          }
          throw error;
        });
      }
      _getStat(filepath) {
        return new Promise((resolve, reject) => {
          this._stat(filepath, this._fsStatSettings, (error, stats) => {
            return error === null ? resolve(stats) : reject(error);
          });
        });
      }
    };
    exports2.default = ReaderStream;
  });
  var require_matcher = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var utils = require_utils3();
    var Matcher = class {
      constructor(_patterns, _settings, _micromatchOptions) {
        this._patterns = _patterns;
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this._storage = [];
        this._fillStorage();
      }
      _fillStorage() {
        const patterns = utils.pattern.expandPatternsWithBraceExpansion(this._patterns);
        for (const pattern of patterns) {
          const segments = this._getPatternSegments(pattern);
          const sections = this._splitSegmentsIntoSections(segments);
          this._storage.push({
            complete: sections.length <= 1,
            pattern,
            segments,
            sections
          });
        }
      }
      _getPatternSegments(pattern) {
        const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);
        return parts.map((part) => {
          const dynamic = utils.pattern.isDynamicPattern(part, this._settings);
          if (!dynamic) {
            return {
              dynamic: false,
              pattern: part
            };
          }
          return {
            dynamic: true,
            pattern: part,
            patternRe: utils.pattern.makeRe(part, this._micromatchOptions)
          };
        });
      }
      _splitSegmentsIntoSections(segments) {
        return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));
      }
    };
    exports2.default = Matcher;
  });
  var require_partial = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var matcher_1 = require_matcher();
    var PartialMatcher = class extends matcher_1.default {
      match(filepath) {
        const parts = filepath.split("/");
        const levels = parts.length;
        const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);
        for (const pattern of patterns) {
          const section = pattern.sections[0];
          if (!pattern.complete && levels > section.length) {
            return true;
          }
          const match = parts.every((part, index) => {
            const segment = pattern.segments[index];
            if (segment.dynamic && segment.patternRe.test(part)) {
              return true;
            }
            if (!segment.dynamic && segment.pattern === part) {
              return true;
            }
            return false;
          });
          if (match) {
            return true;
          }
        }
        return false;
      }
    };
    exports2.default = PartialMatcher;
  });
  var require_deep = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var utils = require_utils3();
    var partial_1 = require_partial();
    var DeepFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
      }
      getFilter(basePath, positive, negative) {
        const matcher = this._getMatcher(positive);
        const negativeRe = this._getNegativePatternsRe(negative);
        return (entry) => this._filter(basePath, entry, matcher, negativeRe);
      }
      _getMatcher(patterns) {
        return new partial_1.default(patterns, this._settings, this._micromatchOptions);
      }
      _getNegativePatternsRe(patterns) {
        const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);
        return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
      }
      _filter(basePath, entry, matcher, negativeRe) {
        if (this._isSkippedByDeep(basePath, entry.path)) {
          return false;
        }
        if (this._isSkippedSymbolicLink(entry)) {
          return false;
        }
        const filepath = utils.path.removeLeadingDotSegment(entry.path);
        if (this._isSkippedByPositivePatterns(filepath, matcher)) {
          return false;
        }
        return this._isSkippedByNegativePatterns(filepath, negativeRe);
      }
      _isSkippedByDeep(basePath, entryPath) {
        if (this._settings.deep === Infinity) {
          return false;
        }
        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
      }
      _getEntryLevel(basePath, entryPath) {
        const entryPathDepth = entryPath.split("/").length;
        if (basePath === "") {
          return entryPathDepth;
        }
        const basePathDepth = basePath.split("/").length;
        return entryPathDepth - basePathDepth;
      }
      _isSkippedSymbolicLink(entry) {
        return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
      }
      _isSkippedByPositivePatterns(entryPath, matcher) {
        return !this._settings.baseNameMatch && !matcher.match(entryPath);
      }
      _isSkippedByNegativePatterns(entryPath, patternsRe) {
        return !utils.pattern.matchAny(entryPath, patternsRe);
      }
    };
    exports2.default = DeepFilter;
  });
  var require_entry = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var utils = require_utils3();
    var EntryFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this.index = new Map();
      }
      getFilter(positive, negative) {
        const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);
        const negativeRe = utils.pattern.convertPatternsToRe(negative, this._micromatchOptions);
        return (entry) => this._filter(entry, positiveRe, negativeRe);
      }
      _filter(entry, positiveRe, negativeRe) {
        if (this._settings.unique && this._isDuplicateEntry(entry)) {
          return false;
        }
        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
          return false;
        }
        if (this._isSkippedByAbsoluteNegativePatterns(entry.path, negativeRe)) {
          return false;
        }
        const filepath = this._settings.baseNameMatch ? entry.name : entry.path;
        const isMatched = this._isMatchToPatterns(filepath, positiveRe) && !this._isMatchToPatterns(entry.path, negativeRe);
        if (this._settings.unique && isMatched) {
          this._createIndexRecord(entry);
        }
        return isMatched;
      }
      _isDuplicateEntry(entry) {
        return this.index.has(entry.path);
      }
      _createIndexRecord(entry) {
        this.index.set(entry.path, void 0);
      }
      _onlyFileFilter(entry) {
        return this._settings.onlyFiles && !entry.dirent.isFile();
      }
      _onlyDirectoryFilter(entry) {
        return this._settings.onlyDirectories && !entry.dirent.isDirectory();
      }
      _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
        if (!this._settings.absolute) {
          return false;
        }
        const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);
        return utils.pattern.matchAny(fullpath, patternsRe);
      }
      _isMatchToPatterns(entryPath, patternsRe) {
        const filepath = utils.path.removeLeadingDotSegment(entryPath);
        return utils.pattern.matchAny(filepath, patternsRe);
      }
    };
    exports2.default = EntryFilter;
  });
  var require_error2 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var utils = require_utils3();
    var ErrorFilter = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getFilter() {
        return (error) => this._isNonFatalError(error);
      }
      _isNonFatalError(error) {
        return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
      }
    };
    exports2.default = ErrorFilter;
  });
  var require_entry2 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var utils = require_utils3();
    var EntryTransformer = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getTransformer() {
        return (entry) => this._transform(entry);
      }
      _transform(entry) {
        let filepath = entry.path;
        if (this._settings.absolute) {
          filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);
          filepath = utils.path.unixify(filepath);
        }
        if (this._settings.markDirectories && entry.dirent.isDirectory()) {
          filepath += "/";
        }
        if (!this._settings.objectMode) {
          return filepath;
        }
        return Object.assign(Object.assign({}, entry), {path: filepath});
      }
    };
    exports2.default = EntryTransformer;
  });
  var require_provider = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var path22 = require("path");
    var deep_1 = require_deep();
    var entry_1 = require_entry();
    var error_1 = require_error2();
    var entry_2 = require_entry2();
    var Provider = class {
      constructor(_settings) {
        this._settings = _settings;
        this.errorFilter = new error_1.default(this._settings);
        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
        this.entryTransformer = new entry_2.default(this._settings);
      }
      _getRootDirectory(task) {
        return path22.resolve(this._settings.cwd, task.base);
      }
      _getReaderOptions(task) {
        const basePath = task.base === "." ? "" : task.base;
        return {
          basePath,
          pathSegmentSeparator: "/",
          concurrency: this._settings.concurrency,
          deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
          entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
          errorFilter: this.errorFilter.getFilter(),
          followSymbolicLinks: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          stats: this._settings.stats,
          throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
          transform: this.entryTransformer.getTransformer()
        };
      }
      _getMicromatchOptions() {
        return {
          dot: this._settings.dot,
          matchBase: this._settings.baseNameMatch,
          nobrace: !this._settings.braceExpansion,
          nocase: !this._settings.caseSensitiveMatch,
          noext: !this._settings.extglob,
          noglobstar: !this._settings.globstar,
          posix: true,
          strictSlashes: false
        };
      }
    };
    exports2.default = Provider;
  });
  var require_async5 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var stream_1 = require_stream4();
    var provider_1 = require_provider();
    var ProviderAsync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new stream_1.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = [];
        return new Promise((resolve, reject) => {
          const stream = this.api(root, task, options);
          stream.once("error", reject);
          stream.on("data", (entry) => entries.push(options.transform(entry)));
          stream.once("end", () => resolve(entries));
        });
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderAsync;
  });
  var require_stream5 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var stream_1 = require("stream");
    var stream_2 = require_stream4();
    var provider_1 = require_provider();
    var ProviderStream = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new stream_2.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const source = this.api(root, task, options);
        const destination = new stream_1.Readable({objectMode: true, read: () => {
        }});
        source.once("error", (error) => destination.emit("error", error)).on("data", (entry) => destination.emit("data", options.transform(entry))).once("end", () => destination.emit("end"));
        destination.once("close", () => source.destroy());
        return destination;
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderStream;
  });
  var require_sync6 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderSync = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkSync = fsWalk.walkSync;
        this._statSync = fsStat.statSync;
      }
      dynamic(root, options) {
        return this._walkSync(root, options);
      }
      static(patterns, options) {
        const entries = [];
        for (const pattern of patterns) {
          const filepath = this._getFullEntryPath(pattern);
          const entry = this._getEntry(filepath, pattern, options);
          if (entry === null || !options.entryFilter(entry)) {
            continue;
          }
          entries.push(entry);
        }
        return entries;
      }
      _getEntry(filepath, pattern, options) {
        try {
          const stats = this._getStat(filepath);
          return this._makeEntry(stats, pattern);
        } catch (error) {
          if (options.errorFilter(error)) {
            return null;
          }
          throw error;
        }
      }
      _getStat(filepath) {
        return this._statSync(filepath, this._fsStatSettings);
      }
    };
    exports2.default = ReaderSync;
  });
  var require_sync7 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var sync_1 = require_sync6();
    var provider_1 = require_provider();
    var ProviderSync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new sync_1.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = this.api(root, task, options);
        return entries.map(options.transform);
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderSync;
  });
  var require_settings4 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
    var fs2 = require("fs");
    var os2 = require("os");
    var CPU_COUNT = Math.max(os2.cpus().length, 1);
    exports2.DEFAULT_FILE_SYSTEM_ADAPTER = {
      lstat: fs2.lstat,
      lstatSync: fs2.lstatSync,
      stat: fs2.stat,
      statSync: fs2.statSync,
      readdir: fs2.readdir,
      readdirSync: fs2.readdirSync
    };
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.absolute = this._getValue(this._options.absolute, false);
        this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
        this.braceExpansion = this._getValue(this._options.braceExpansion, true);
        this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
        this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
        this.cwd = this._getValue(this._options.cwd, process.cwd());
        this.deep = this._getValue(this._options.deep, Infinity);
        this.dot = this._getValue(this._options.dot, false);
        this.extglob = this._getValue(this._options.extglob, true);
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
        this.fs = this._getFileSystemMethods(this._options.fs);
        this.globstar = this._getValue(this._options.globstar, true);
        this.ignore = this._getValue(this._options.ignore, []);
        this.markDirectories = this._getValue(this._options.markDirectories, false);
        this.objectMode = this._getValue(this._options.objectMode, false);
        this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
        this.onlyFiles = this._getValue(this._options.onlyFiles, true);
        this.stats = this._getValue(this._options.stats, false);
        this.suppressErrors = this._getValue(this._options.suppressErrors, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
        this.unique = this._getValue(this._options.unique, true);
        if (this.onlyDirectories) {
          this.onlyFiles = false;
        }
        if (this.stats) {
          this.objectMode = true;
        }
      }
      _getValue(option, value) {
        return option === void 0 ? value : option;
      }
      _getFileSystemMethods(methods = {}) {
        return Object.assign(Object.assign({}, exports2.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
      }
    };
    exports2.default = Settings;
  });
  var require_out4 = __commonJS((exports2, module2) => {
    "use strict";
    var taskManager = require_tasks();
    var async_1 = require_async5();
    var stream_1 = require_stream5();
    var sync_1 = require_sync7();
    var settings_1 = require_settings4();
    var utils = require_utils3();
    async function FastGlob(source, options) {
      assertPatternsInput(source);
      const works = getWorks(source, async_1.default, options);
      const result = await Promise.all(works);
      return utils.array.flatten(result);
    }
    (function(FastGlob2) {
      function sync2(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, sync_1.default, options);
        return utils.array.flatten(works);
      }
      FastGlob2.sync = sync2;
      function stream(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, stream_1.default, options);
        return utils.stream.merge(works);
      }
      FastGlob2.stream = stream;
      function generateTasks(source, options) {
        assertPatternsInput(source);
        const patterns = [].concat(source);
        const settings = new settings_1.default(options);
        return taskManager.generate(patterns, settings);
      }
      FastGlob2.generateTasks = generateTasks;
      function isDynamicPattern(source, options) {
        assertPatternsInput(source);
        const settings = new settings_1.default(options);
        return utils.pattern.isDynamicPattern(source, settings);
      }
      FastGlob2.isDynamicPattern = isDynamicPattern;
      function escapePath(source) {
        assertPatternsInput(source);
        return utils.path.escape(source);
      }
      FastGlob2.escapePath = escapePath;
    })(FastGlob || (FastGlob = {}));
    function getWorks(source, _Provider, options) {
      const patterns = [].concat(source);
      const settings = new settings_1.default(options);
      const tasks = taskManager.generate(patterns, settings);
      const provider = new _Provider(settings);
      return tasks.map(provider.read, provider);
    }
    function assertPatternsInput(input) {
      const source = [].concat(input);
      const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));
      if (!isValidSource) {
        throw new TypeError("Patterns must be a string (non empty) or an array of strings");
      }
    }
    module2.exports = FastGlob;
  });
  var require_path_type = __commonJS((exports2) => {
    "use strict";
    var {promisify: promisify2} = require("util");
    var fs2 = require("fs");
    async function isType(fsStatType, statsMethodName, filePath) {
      if (typeof filePath !== "string") {
        throw new TypeError(`Expected a string, got ${typeof filePath}`);
      }
      try {
        const stats = await promisify2(fs2[fsStatType])(filePath);
        return stats[statsMethodName]();
      } catch (error) {
        if (error.code === "ENOENT") {
          return false;
        }
        throw error;
      }
    }
    function isTypeSync(fsStatType, statsMethodName, filePath) {
      if (typeof filePath !== "string") {
        throw new TypeError(`Expected a string, got ${typeof filePath}`);
      }
      try {
        return fs2[fsStatType](filePath)[statsMethodName]();
      } catch (error) {
        if (error.code === "ENOENT") {
          return false;
        }
        throw error;
      }
    }
    exports2.isFile = isType.bind(null, "stat", "isFile");
    exports2.isDirectory = isType.bind(null, "stat", "isDirectory");
    exports2.isSymlink = isType.bind(null, "lstat", "isSymbolicLink");
    exports2.isFileSync = isTypeSync.bind(null, "statSync", "isFile");
    exports2.isDirectorySync = isTypeSync.bind(null, "statSync", "isDirectory");
    exports2.isSymlinkSync = isTypeSync.bind(null, "lstatSync", "isSymbolicLink");
  });
  var require_dir_glob = __commonJS((exports2, module2) => {
    "use strict";
    var path22 = require("path");
    var pathType = require_path_type();
    var getExtensions = (extensions) => extensions.length > 1 ? `{${extensions.join(",")}}` : extensions[0];
    var getPath = (filepath, cwd) => {
      const pth = filepath[0] === "!" ? filepath.slice(1) : filepath;
      return path22.isAbsolute(pth) ? pth : path22.join(cwd, pth);
    };
    var addExtensions = (file, extensions) => {
      if (path22.extname(file)) {
        return `**/${file}`;
      }
      return `**/${file}.${getExtensions(extensions)}`;
    };
    var getGlob = (directory, options) => {
      if (options.files && !Array.isArray(options.files)) {
        throw new TypeError(`Expected \`files\` to be of type \`Array\` but received type \`${typeof options.files}\``);
      }
      if (options.extensions && !Array.isArray(options.extensions)) {
        throw new TypeError(`Expected \`extensions\` to be of type \`Array\` but received type \`${typeof options.extensions}\``);
      }
      if (options.files && options.extensions) {
        return options.files.map((x) => path22.posix.join(directory, addExtensions(x, options.extensions)));
      }
      if (options.files) {
        return options.files.map((x) => path22.posix.join(directory, `**/${x}`));
      }
      if (options.extensions) {
        return [path22.posix.join(directory, `**/*.${getExtensions(options.extensions)}`)];
      }
      return [path22.posix.join(directory, "**")];
    };
    module2.exports = async (input, options) => {
      options = {
        cwd: process.cwd(),
        ...options
      };
      if (typeof options.cwd !== "string") {
        throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
      }
      const globs = await Promise.all([].concat(input).map(async (x) => {
        const isDirectory = await pathType.isDirectory(getPath(x, options.cwd));
        return isDirectory ? getGlob(x, options) : x;
      }));
      return [].concat.apply([], globs);
    };
    module2.exports.sync = (input, options) => {
      options = {
        cwd: process.cwd(),
        ...options
      };
      if (typeof options.cwd !== "string") {
        throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
      }
      const globs = [].concat(input).map((x) => pathType.isDirectorySync(getPath(x, options.cwd)) ? getGlob(x, options) : x);
      return [].concat.apply([], globs);
    };
  });
  var require_ignore = __commonJS((exports2, module2) => {
    function makeArray(subject) {
      return Array.isArray(subject) ? subject : [subject];
    }
    var EMPTY = "";
    var SPACE = " ";
    var ESCAPE = "\\";
    var REGEX_TEST_BLANK_LINE = /^\s+$/;
    var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
    var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
    var REGEX_SPLITALL_CRLF = /\r?\n/g;
    var REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
    var SLASH = "/";
    var KEY_IGNORE = typeof Symbol !== "undefined" ? Symbol.for("node-ignore") : "node-ignore";
    var define2 = (object, key, value) => Object.defineProperty(object, key, {value});
    var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
    var sanitizeRange = (range) => range.replace(REGEX_REGEXP_RANGE, (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY);
    var cleanRangeBackSlash = (slashes) => {
      const {length} = slashes;
      return slashes.slice(0, length - length % 2);
    };
    var REPLACERS = [
      [
        /\\?\s+$/,
        (match) => match.indexOf("\\") === 0 ? SPACE : EMPTY
      ],
      [
        /\\\s/g,
        () => SPACE
      ],
      [
        /[\\$.|*+(){^]/g,
        (match) => `\\${match}`
      ],
      [
        /(?!\\)\?/g,
        () => "[^/]"
      ],
      [
        /^\//,
        () => "^"
      ],
      [
        /\//g,
        () => "\\/"
      ],
      [
        /^\^*\\\*\\\*\\\//,
        () => "^(?:.*\\/)?"
      ],
      [
        /^(?=[^^])/,
        function startingReplacer() {
          return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
        }
      ],
      [
        /\\\/\\\*\\\*(?=\\\/|$)/g,
        (_2, index, str) => index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
      ],
      [
        /(^|[^\\]+)\\\*(?=.+)/g,
        (_2, p1) => `${p1}[^\\/]*`
      ],
      [
        /\\\\\\(?=[$.|*+(){^])/g,
        () => ESCAPE
      ],
      [
        /\\\\/g,
        () => ESCAPE
      ],
      [
        /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
        (match, leadEscape, range, endEscape, close2) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close2}` : close2 === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"
      ],
      [
        /(?:[^*])$/,
        (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
      ],
      [
        /(\^|\\\/)?\\\*$/,
        (_2, p1) => {
          const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
          return `${prefix}(?=$|\\/$)`;
        }
      ]
    ];
    var regexCache = Object.create(null);
    var makeRegex = (pattern, negative, ignorecase) => {
      const r = regexCache[pattern];
      if (r) {
        return r;
      }
      const source = REPLACERS.reduce((prev, current) => prev.replace(current[0], current[1].bind(pattern)), pattern);
      return regexCache[pattern] = ignorecase ? new RegExp(source, "i") : new RegExp(source);
    };
    var isString = (subject) => typeof subject === "string";
    var checkPattern = (pattern) => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && pattern.indexOf("#") !== 0;
    var splitPattern = (pattern) => pattern.split(REGEX_SPLITALL_CRLF);
    var IgnoreRule = class {
      constructor(origin, pattern, negative, regex) {
        this.origin = origin;
        this.pattern = pattern;
        this.negative = negative;
        this.regex = regex;
      }
    };
    var createRule = (pattern, ignorecase) => {
      const origin = pattern;
      let negative = false;
      if (pattern.indexOf("!") === 0) {
        negative = true;
        pattern = pattern.substr(1);
      }
      pattern = pattern.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
      const regex = makeRegex(pattern, negative, ignorecase);
      return new IgnoreRule(origin, pattern, negative, regex);
    };
    var throwError = (message, Ctor) => {
      throw new Ctor(message);
    };
    var checkPath2 = (path22, originalPath, doThrow) => {
      if (!isString(path22)) {
        return doThrow(`path must be a string, but got \`${originalPath}\``, TypeError);
      }
      if (!path22) {
        return doThrow(`path must not be empty`, TypeError);
      }
      if (checkPath2.isNotRelative(path22)) {
        const r = "`path.relative()`d";
        return doThrow(`path should be a ${r} string, but got "${originalPath}"`, RangeError);
      }
      return true;
    };
    var isNotRelative = (path22) => REGEX_TEST_INVALID_PATH.test(path22);
    checkPath2.isNotRelative = isNotRelative;
    checkPath2.convert = (p) => p;
    var Ignore = class {
      constructor({
        ignorecase = true
      } = {}) {
        this._rules = [];
        this._ignorecase = ignorecase;
        define2(this, KEY_IGNORE, true);
        this._initCache();
      }
      _initCache() {
        this._ignoreCache = Object.create(null);
        this._testCache = Object.create(null);
      }
      _addPattern(pattern) {
        if (pattern && pattern[KEY_IGNORE]) {
          this._rules = this._rules.concat(pattern._rules);
          this._added = true;
          return;
        }
        if (checkPattern(pattern)) {
          const rule = createRule(pattern, this._ignorecase);
          this._added = true;
          this._rules.push(rule);
        }
      }
      add(pattern) {
        this._added = false;
        makeArray(isString(pattern) ? splitPattern(pattern) : pattern).forEach(this._addPattern, this);
        if (this._added) {
          this._initCache();
        }
        return this;
      }
      addPattern(pattern) {
        return this.add(pattern);
      }
      _testOne(path22, checkUnignored) {
        let ignored = false;
        let unignored = false;
        this._rules.forEach((rule) => {
          const {negative} = rule;
          if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
            return;
          }
          const matched = rule.regex.test(path22);
          if (matched) {
            ignored = !negative;
            unignored = negative;
          }
        });
        return {
          ignored,
          unignored
        };
      }
      _test(originalPath, cache, checkUnignored, slices) {
        const path22 = originalPath && checkPath2.convert(originalPath);
        checkPath2(path22, originalPath, throwError);
        return this._t(path22, cache, checkUnignored, slices);
      }
      _t(path22, cache, checkUnignored, slices) {
        if (path22 in cache) {
          return cache[path22];
        }
        if (!slices) {
          slices = path22.split(SLASH);
        }
        slices.pop();
        if (!slices.length) {
          return cache[path22] = this._testOne(path22, checkUnignored);
        }
        const parent = this._t(slices.join(SLASH) + SLASH, cache, checkUnignored, slices);
        return cache[path22] = parent.ignored ? parent : this._testOne(path22, checkUnignored);
      }
      ignores(path22) {
        return this._test(path22, this._ignoreCache, false).ignored;
      }
      createFilter() {
        return (path22) => !this.ignores(path22);
      }
      filter(paths) {
        return makeArray(paths).filter(this.createFilter());
      }
      test(path22) {
        return this._test(path22, this._testCache, true);
      }
    };
    var factory = (options) => new Ignore(options);
    var returnFalse = () => false;
    var isPathValid = (path22) => checkPath2(path22 && checkPath2.convert(path22), path22, returnFalse);
    factory.isPathValid = isPathValid;
    factory.default = factory;
    module2.exports = factory;
    if (typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")) {
      const makePosix = (str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/");
      checkPath2.convert = makePosix;
      const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
      checkPath2.isNotRelative = (path22) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path22) || isNotRelative(path22);
    }
  });
  var require_slash = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = (path22) => {
      const isExtendedLengthPath = /^\\\\\?\\/.test(path22);
      const hasNonAscii = /[^\u0000-\u0080]+/.test(path22);
      if (isExtendedLengthPath || hasNonAscii) {
        return path22;
      }
      return path22.replace(/\\/g, "/");
    };
  });
  var require_gitignore = __commonJS((exports2, module2) => {
    "use strict";
    var {promisify: promisify2} = require("util");
    var fs2 = require("fs");
    var path22 = require("path");
    var fastGlob = require_out4();
    var gitIgnore = require_ignore();
    var slash = require_slash();
    var DEFAULT_IGNORE = [
      "**/node_modules/**",
      "**/flow-typed/**",
      "**/coverage/**",
      "**/.git"
    ];
    var readFileP = promisify2(fs2.readFile);
    var mapGitIgnorePatternTo = (base) => (ignore) => {
      if (ignore.startsWith("!")) {
        return "!" + path22.posix.join(base, ignore.slice(1));
      }
      return path22.posix.join(base, ignore);
    };
    var parseGitIgnore = (content, options) => {
      const base = slash(path22.relative(options.cwd, path22.dirname(options.fileName)));
      return content.split(/\r?\n/).filter(Boolean).filter((line) => !line.startsWith("#")).map(mapGitIgnorePatternTo(base));
    };
    var reduceIgnore = (files) => {
      const ignores = gitIgnore();
      for (const file of files) {
        ignores.add(parseGitIgnore(file.content, {
          cwd: file.cwd,
          fileName: file.filePath
        }));
      }
      return ignores;
    };
    var ensureAbsolutePathForCwd = (cwd, p) => {
      cwd = slash(cwd);
      if (path22.isAbsolute(p)) {
        if (p.startsWith(cwd)) {
          return p;
        }
        throw new Error(`Path ${p} is not in cwd ${cwd}`);
      }
      return path22.join(cwd, p);
    };
    var getIsIgnoredPredecate = (ignores, cwd) => {
      return (p) => ignores.ignores(slash(path22.relative(cwd, ensureAbsolutePathForCwd(cwd, p.path || p))));
    };
    var getFile = async (file, cwd) => {
      const filePath = path22.join(cwd, file);
      const content = await readFileP(filePath, "utf8");
      return {
        cwd,
        filePath,
        content
      };
    };
    var getFileSync = (file, cwd) => {
      const filePath = path22.join(cwd, file);
      const content = fs2.readFileSync(filePath, "utf8");
      return {
        cwd,
        filePath,
        content
      };
    };
    var normalizeOptions = ({
      ignore = [],
      cwd = slash(process.cwd())
    } = {}) => {
      return {ignore, cwd};
    };
    module2.exports = async (options) => {
      options = normalizeOptions(options);
      const paths = await fastGlob("**/.gitignore", {
        ignore: DEFAULT_IGNORE.concat(options.ignore),
        cwd: options.cwd
      });
      const files = await Promise.all(paths.map((file) => getFile(file, options.cwd)));
      const ignores = reduceIgnore(files);
      return getIsIgnoredPredecate(ignores, options.cwd);
    };
    module2.exports.sync = (options) => {
      options = normalizeOptions(options);
      const paths = fastGlob.sync("**/.gitignore", {
        ignore: DEFAULT_IGNORE.concat(options.ignore),
        cwd: options.cwd
      });
      const files = paths.map((file) => getFileSync(file, options.cwd));
      const ignores = reduceIgnore(files);
      return getIsIgnoredPredecate(ignores, options.cwd);
    };
  });
  var require_stream_utils = __commonJS((exports2, module2) => {
    "use strict";
    var {Transform} = require("stream");
    var ObjectTransform = class extends Transform {
      constructor() {
        super({
          objectMode: true
        });
      }
    };
    var FilterStream = class extends ObjectTransform {
      constructor(filter) {
        super();
        this._filter = filter;
      }
      _transform(data, encoding, callback) {
        if (this._filter(data)) {
          this.push(data);
        }
        callback();
      }
    };
    var UniqueStream = class extends ObjectTransform {
      constructor() {
        super();
        this._pushed = new Set();
      }
      _transform(data, encoding, callback) {
        if (!this._pushed.has(data)) {
          this.push(data);
          this._pushed.add(data);
        }
        callback();
      }
    };
    module2.exports = {
      FilterStream,
      UniqueStream
    };
  });
  var require_globby = __commonJS((exports2, module2) => {
    "use strict";
    var fs2 = require("fs");
    var arrayUnion = require_array_union();
    var merge2 = require_merge2();
    var fastGlob = require_out4();
    var dirGlob = require_dir_glob();
    var gitignore = require_gitignore();
    var {FilterStream, UniqueStream} = require_stream_utils();
    var DEFAULT_FILTER = () => false;
    var isNegative = (pattern) => pattern[0] === "!";
    var assertPatternsInput = (patterns) => {
      if (!patterns.every((pattern) => typeof pattern === "string")) {
        throw new TypeError("Patterns must be a string or an array of strings");
      }
    };
    var checkCwdOption = (options = {}) => {
      if (!options.cwd) {
        return;
      }
      let stat2;
      try {
        stat2 = fs2.statSync(options.cwd);
      } catch (e) {
        return;
      }
      if (!stat2.isDirectory()) {
        throw new Error("The `cwd` option must be a path to a directory");
      }
    };
    var getPathString = (p) => p.stats instanceof fs2.Stats ? p.path : p;
    var generateGlobTasks = (patterns, taskOptions) => {
      patterns = arrayUnion([].concat(patterns));
      assertPatternsInput(patterns);
      checkCwdOption(taskOptions);
      const globTasks = [];
      taskOptions = {
        ignore: [],
        expandDirectories: true,
        ...taskOptions
      };
      for (const [index, pattern] of patterns.entries()) {
        if (isNegative(pattern)) {
          continue;
        }
        const ignore = patterns.slice(index).filter((pattern2) => isNegative(pattern2)).map((pattern2) => pattern2.slice(1));
        const options = {
          ...taskOptions,
          ignore: taskOptions.ignore.concat(ignore)
        };
        globTasks.push({pattern, options});
      }
      return globTasks;
    };
    var globDirs = (task, fn) => {
      let options = {};
      if (task.options.cwd) {
        options.cwd = task.options.cwd;
      }
      if (Array.isArray(task.options.expandDirectories)) {
        options = {
          ...options,
          files: task.options.expandDirectories
        };
      } else if (typeof task.options.expandDirectories === "object") {
        options = {
          ...options,
          ...task.options.expandDirectories
        };
      }
      return fn(task.pattern, options);
    };
    var getPattern = (task, fn) => task.options.expandDirectories ? globDirs(task, fn) : [task.pattern];
    var getFilterSync = (options) => {
      return options && options.gitignore ? gitignore.sync({cwd: options.cwd, ignore: options.ignore}) : DEFAULT_FILTER;
    };
    var globToTask = (task) => (glob) => {
      const {options} = task;
      if (options.ignore && Array.isArray(options.ignore) && options.expandDirectories) {
        options.ignore = dirGlob.sync(options.ignore);
      }
      return {
        pattern: glob,
        options
      };
    };
    module2.exports = async (patterns, options) => {
      const globTasks = generateGlobTasks(patterns, options);
      const getFilter = async () => {
        return options && options.gitignore ? gitignore({cwd: options.cwd, ignore: options.ignore}) : DEFAULT_FILTER;
      };
      const getTasks = async () => {
        const tasks2 = await Promise.all(globTasks.map(async (task) => {
          const globs = await getPattern(task, dirGlob);
          return Promise.all(globs.map(globToTask(task)));
        }));
        return arrayUnion(...tasks2);
      };
      const [filter, tasks] = await Promise.all([getFilter(), getTasks()]);
      const paths = await Promise.all(tasks.map((task) => fastGlob(task.pattern, task.options)));
      return arrayUnion(...paths).filter((path_) => !filter(getPathString(path_)));
    };
    module2.exports.sync = (patterns, options) => {
      const globTasks = generateGlobTasks(patterns, options);
      const tasks = [];
      for (const task of globTasks) {
        const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));
        tasks.push(...newTask);
      }
      const filter = getFilterSync(options);
      let matches = [];
      for (const task of tasks) {
        matches = arrayUnion(matches, fastGlob.sync(task.pattern, task.options));
      }
      return matches.filter((path_) => !filter(path_));
    };
    module2.exports.stream = (patterns, options) => {
      const globTasks = generateGlobTasks(patterns, options);
      const tasks = [];
      for (const task of globTasks) {
        const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));
        tasks.push(...newTask);
      }
      const filter = getFilterSync(options);
      const filterStream = new FilterStream((p) => !filter(p));
      const uniqueStream = new UniqueStream();
      return merge2(tasks.map((task) => fastGlob.stream(task.pattern, task.options))).pipe(filterStream).pipe(uniqueStream);
    };
    module2.exports.generateGlobTasks = generateGlobTasks;
    module2.exports.hasMagic = (patterns, options) => [].concat(patterns).some((pattern) => fastGlob.isDynamicPattern(pattern, options));
    module2.exports.gitignore = gitignore;
  });
  var require_polyfills = __commonJS((exports2, module2) => {
    var constants = require("constants");
    var origCwd = process.cwd;
    var cwd = null;
    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d2) {
        cwd = null;
        chdir.call(process, d2);
      };
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module2.exports = patch;
    function patch(fs2) {
      if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs2);
      }
      if (!fs2.lutimes) {
        patchLutimes(fs2);
      }
      fs2.chown = chownFix(fs2.chown);
      fs2.fchown = chownFix(fs2.fchown);
      fs2.lchown = chownFix(fs2.lchown);
      fs2.chmod = chmodFix(fs2.chmod);
      fs2.fchmod = chmodFix(fs2.fchmod);
      fs2.lchmod = chmodFix(fs2.lchmod);
      fs2.chownSync = chownFixSync(fs2.chownSync);
      fs2.fchownSync = chownFixSync(fs2.fchownSync);
      fs2.lchownSync = chownFixSync(fs2.lchownSync);
      fs2.chmodSync = chmodFixSync(fs2.chmodSync);
      fs2.fchmodSync = chmodFixSync(fs2.fchmodSync);
      fs2.lchmodSync = chmodFixSync(fs2.lchmodSync);
      fs2.stat = statFix(fs2.stat);
      fs2.fstat = statFix(fs2.fstat);
      fs2.lstat = statFix(fs2.lstat);
      fs2.statSync = statFixSync(fs2.statSync);
      fs2.fstatSync = statFixSync(fs2.fstatSync);
      fs2.lstatSync = statFixSync(fs2.lstatSync);
      if (!fs2.lchmod) {
        fs2.lchmod = function(path22, mode, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs2.lchmodSync = function() {
        };
      }
      if (!fs2.lchown) {
        fs2.lchown = function(path22, uid, gid, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs2.lchownSync = function() {
        };
      }
      if (platform === "win32") {
        fs2.rename = function(fs$rename) {
          return function(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs2.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb)
                cb(er);
            });
          };
        }(fs2.rename);
      }
      fs2.read = function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _2, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(read, fs$read);
        return read;
      }(fs2.read);
      fs2.readSync = function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs2, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs2.readSync);
      function patchLchmod(fs22) {
        fs22.lchmod = function(path22, mode, callback) {
          fs22.open(path22, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
            if (err) {
              if (callback)
                callback(err);
              return;
            }
            fs22.fchmod(fd, mode, function(err2) {
              fs22.close(fd, function(err22) {
                if (callback)
                  callback(err2 || err22);
              });
            });
          });
        };
        fs22.lchmodSync = function(path22, mode) {
          var fd = fs22.openSync(path22, constants.O_WRONLY | constants.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs22.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs22.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs22.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs22) {
        if (constants.hasOwnProperty("O_SYMLINK")) {
          fs22.lutimes = function(path22, at, mt, cb) {
            fs22.open(path22, constants.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb)
                  cb(er);
                return;
              }
              fs22.futimes(fd, at, mt, function(er2) {
                fs22.close(fd, function(er22) {
                  if (cb)
                    cb(er2 || er22);
                });
              });
            });
          };
          fs22.lutimesSync = function(path22, at, mt) {
            var fd = fs22.openSync(path22, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs22.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs22.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs22.closeSync(fd);
              }
            }
            return ret;
          };
        } else {
          fs22.lutimes = function(_a, _b, _c, cb) {
            if (cb)
              process.nextTick(cb);
          };
          fs22.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig)
          return orig;
        return function(target, mode, cb) {
          return orig.call(fs2, target, mode, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, mode) {
          try {
            return orig.call(fs2, target, mode);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs2, target, uid, gid, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs2, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig)
          return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0)
                stats.uid += 4294967296;
              if (stats.gid < 0)
                stats.gid += 4294967296;
            }
            if (cb)
              cb.apply(this, arguments);
          }
          return options ? orig.call(fs2, target, options, callback) : orig.call(fs2, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs2, target, options) : orig.call(fs2, target);
          if (stats.uid < 0)
            stats.uid += 4294967296;
          if (stats.gid < 0)
            stats.gid += 4294967296;
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  });
  var require_legacy_streams = __commonJS((exports2, module2) => {
    var Stream = require("stream").Stream;
    module2.exports = legacy;
    function legacy(fs2) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path22, options) {
        if (!(this instanceof ReadStream))
          return new ReadStream(path22, options);
        Stream.call(this);
        var self2 = this;
        this.path = path22;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding)
          this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if (typeof this.start !== "number") {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if (typeof this.end !== "number") {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self2._read();
          });
          return;
        }
        fs2.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self2.emit("error", err);
            self2.readable = false;
            return;
          }
          self2.fd = fd;
          self2.emit("open", fd);
          self2._read();
        });
      }
      function WriteStream(path22, options) {
        if (!(this instanceof WriteStream))
          return new WriteStream(path22, options);
        Stream.call(this);
        this.path = path22;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if (typeof this.start !== "number") {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs2.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  });
  var require_clone = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = clone2;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone2(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy2 = {__proto__: getPrototypeOf(obj)};
      else
        var copy2 = Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy2, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy2;
    }
  });
  var require_graceful_fs = __commonJS((exports2, module2) => {
    var fs2 = require("fs");
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone2 = require_clone();
    var util2 = require("util");
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug32 = noop;
    if (util2.debuglog)
      debug32 = util2.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug32 = function() {
        var m2 = util2.format.apply(util2, arguments);
        m2 = "GFS4: " + m2.split(/\n/).join("\nGFS4: ");
        console.error(m2);
      };
    if (!fs2[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs2, queue);
      fs2.close = function(fs$close) {
        function close2(fd, cb) {
          return fs$close.call(fs2, fd, function(err) {
            if (!err) {
              retry();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close2, previousSymbol, {
          value: fs$close
        });
        return close2;
      }(fs2.close);
      fs2.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs2, arguments);
          retry();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs2.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug32(fs2[gracefulQueue]);
          require("assert").equal(fs2[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs2[gracefulQueue]);
    }
    module2.exports = patch(clone2(fs2));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs2.__patched) {
      module2.exports = patch(fs2);
      fs2.__patched = true;
    }
    function patch(fs22) {
      polyfills(fs22);
      fs22.gracefulify = patch;
      fs22.createReadStream = createReadStream;
      fs22.createWriteStream = createWriteStream;
      var fs$readFile = fs22.readFile;
      fs22.readFile = readFile2;
      function readFile2(path22, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path22, options, cb);
        function go$readFile(path32, options2, cb2) {
          return fs$readFile(path32, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path32, options2, cb2]]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
              retry();
            }
          });
        }
      }
      var fs$writeFile = fs22.writeFile;
      fs22.writeFile = writeFile2;
      function writeFile2(path22, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path22, data, options, cb);
        function go$writeFile(path32, data2, options2, cb2) {
          return fs$writeFile(path32, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path32, data2, options2, cb2]]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
              retry();
            }
          });
        }
      }
      var fs$appendFile = fs22.appendFile;
      if (fs$appendFile)
        fs22.appendFile = appendFile;
      function appendFile(path22, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path22, data, options, cb);
        function go$appendFile(path32, data2, options2, cb2) {
          return fs$appendFile(path32, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path32, data2, options2, cb2]]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
              retry();
            }
          });
        }
      }
      var fs$copyFile = fs22.copyFile;
      if (fs$copyFile)
        fs22.copyFile = copyFile2;
      function copyFile2(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return fs$copyFile(src, dest, flags, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([fs$copyFile, [src, dest, flags, cb]]);
          else {
            if (typeof cb === "function")
              cb.apply(this, arguments);
            retry();
          }
        });
      }
      var fs$readdir = fs22.readdir;
      fs22.readdir = readdir2;
      function readdir2(path22, options, cb) {
        var args = [path22];
        if (typeof options !== "function") {
          args.push(options);
        } else {
          cb = options;
        }
        args.push(go$readdir$cb);
        return go$readdir(args);
        function go$readdir$cb(err, files) {
          if (files && files.sort)
            files.sort();
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$readdir, [args]]);
          else {
            if (typeof cb === "function")
              cb.apply(this, arguments);
            retry();
          }
        }
      }
      function go$readdir(args) {
        return fs$readdir.apply(fs22, args);
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs22);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs22.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs22.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs22, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs22, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs22, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs22, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path22, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open2(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path22, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open2(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream(path22, options) {
        return new fs22.ReadStream(path22, options);
      }
      function createWriteStream(path22, options) {
        return new fs22.WriteStream(path22, options);
      }
      var fs$open = fs22.open;
      fs22.open = open2;
      function open2(path22, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path22, flags, mode, cb);
        function go$open(path32, flags2, mode2, cb2) {
          return fs$open(path32, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path32, flags2, mode2, cb2]]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
              retry();
            }
          });
        }
      }
      return fs22;
    }
    function enqueue(elem) {
      debug32("ENQUEUE", elem[0].name, elem[1]);
      fs2[gracefulQueue].push(elem);
    }
    function retry() {
      var elem = fs2[gracefulQueue].shift();
      if (elem) {
        debug32("RETRY", elem[0].name, elem[1]);
        elem[0].apply(null, elem[1]);
      }
    }
  });
  var require_is_path_cwd = __commonJS((exports2, module2) => {
    "use strict";
    var path22 = require("path");
    module2.exports = (path_) => {
      let cwd = process.cwd();
      path_ = path22.resolve(path_);
      if (process.platform === "win32") {
        cwd = cwd.toLowerCase();
        path_ = path_.toLowerCase();
      }
      return path_ === cwd;
    };
  });
  var require_is_path_inside = __commonJS((exports2, module2) => {
    "use strict";
    var path22 = require("path");
    module2.exports = (childPath2, parentPath) => {
      const relation = path22.relative(parentPath, childPath2);
      return Boolean(relation && relation !== ".." && !relation.startsWith(`..${path22.sep}`) && relation !== path22.resolve(childPath2));
    };
  });
  var require_del = __commonJS((exports2, module2) => {
    "use strict";
    var {promisify: promisify2} = require("util");
    var path22 = require("path");
    var globby = require_globby();
    var isGlob = require_is_glob();
    var slash = require_slash();
    var gracefulFs = require_graceful_fs();
    var isPathCwd = require_is_path_cwd();
    var isPathInside = require_is_path_inside();
    var rimraf = require_rimraf();
    var pMap = require_p_map();
    var rimrafP = promisify2(rimraf);
    var rimrafOptions = {
      glob: false,
      unlink: gracefulFs.unlink,
      unlinkSync: gracefulFs.unlinkSync,
      chmod: gracefulFs.chmod,
      chmodSync: gracefulFs.chmodSync,
      stat: gracefulFs.stat,
      statSync: gracefulFs.statSync,
      lstat: gracefulFs.lstat,
      lstatSync: gracefulFs.lstatSync,
      rmdir: gracefulFs.rmdir,
      rmdirSync: gracefulFs.rmdirSync,
      readdir: gracefulFs.readdir,
      readdirSync: gracefulFs.readdirSync
    };
    function safeCheck(file, cwd) {
      if (isPathCwd(file)) {
        throw new Error("Cannot delete the current working directory. Can be overridden with the `force` option.");
      }
      if (!isPathInside(file, cwd)) {
        throw new Error("Cannot delete files/directories outside the current working directory. Can be overridden with the `force` option.");
      }
    }
    function normalizePatterns(patterns) {
      patterns = Array.isArray(patterns) ? patterns : [patterns];
      patterns = patterns.map((pattern) => {
        if (process.platform === "win32" && isGlob(pattern) === false) {
          return slash(pattern);
        }
        return pattern;
      });
      return patterns;
    }
    module2.exports = async (patterns, {force, dryRun, cwd = process.cwd(), ...options} = {}) => {
      options = {
        expandDirectories: false,
        onlyFiles: false,
        followSymbolicLinks: false,
        cwd,
        ...options
      };
      patterns = normalizePatterns(patterns);
      const files = (await globby(patterns, options)).sort((a, b) => b.localeCompare(a));
      const mapper = async (file) => {
        file = path22.resolve(cwd, file);
        if (!force) {
          safeCheck(file, cwd);
        }
        if (!dryRun) {
          await rimrafP(file, rimrafOptions);
        }
        return file;
      };
      const removedFiles = await pMap(files, mapper, options);
      removedFiles.sort((a, b) => a.localeCompare(b));
      return removedFiles;
    };
    module2.exports.sync = (patterns, {force, dryRun, cwd = process.cwd(), ...options} = {}) => {
      options = {
        expandDirectories: false,
        onlyFiles: false,
        followSymbolicLinks: false,
        cwd,
        ...options
      };
      patterns = normalizePatterns(patterns);
      const files = globby.sync(patterns, options).sort((a, b) => b.localeCompare(a));
      const removedFiles = files.map((file) => {
        file = path22.resolve(cwd, file);
        if (!force) {
          safeCheck(file, cwd);
        }
        if (!dryRun) {
          rimraf.sync(file, rimrafOptions);
        }
        return file;
      });
      removedFiles.sort((a, b) => a.localeCompare(b));
      return removedFiles;
    };
  });
  var require_tempy = __commonJS((exports2, module2) => {
    "use strict";
    var fs2 = require("fs");
    var path22 = require("path");
    var uniqueString = require_unique_string();
    var tempDir = require_temp_dir();
    var isStream = require_is_stream();
    var del = require_del();
    var stream = require("stream");
    var {promisify: promisify2} = require("util");
    var pipeline = promisify2(stream.pipeline);
    var {writeFile: writeFile2} = fs2.promises;
    var getPath = (prefix = "") => path22.join(tempDir, prefix + uniqueString());
    var writeStream = async (filePath, data) => pipeline(data, fs2.createWriteStream(filePath));
    var createTask = (tempyFunction, {extraArguments = 0} = {}) => async (...arguments_) => {
      const [callback, options] = arguments_.slice(extraArguments);
      const result = await tempyFunction(...arguments_.slice(0, extraArguments), options);
      const returnValue = await callback(result);
      await del(result, {force: true});
      return returnValue;
    };
    module2.exports.file = (options) => {
      options = {
        ...options
      };
      if (options.name) {
        if (options.extension !== void 0 && options.extension !== null) {
          throw new Error("The `name` and `extension` options are mutually exclusive");
        }
        return path22.join(module2.exports.directory(), options.name);
      }
      return getPath() + (options.extension === void 0 || options.extension === null ? "" : "." + options.extension.replace(/^\./, ""));
    };
    module2.exports.file.task = createTask(module2.exports.file);
    module2.exports.directory = ({prefix = ""} = {}) => {
      const directory = getPath(prefix);
      fs2.mkdirSync(directory);
      return directory;
    };
    module2.exports.directory.task = createTask(module2.exports.directory);
    module2.exports.write = async (data, options) => {
      const filename = module2.exports.file(options);
      const write2 = isStream(data) ? writeStream : writeFile2;
      await write2(filename, data);
      return filename;
    };
    module2.exports.write.task = createTask(module2.exports.write, {extraArguments: 1});
    module2.exports.writeSync = (data, options) => {
      const filename = module2.exports.file(options);
      fs2.writeFileSync(filename, data);
      return filename;
    };
    Object.defineProperty(module2.exports, "root", {
      get() {
        return tempDir;
      }
    });
  });
  var require_hasha = __commonJS((exports2, module2) => {
    "use strict";
    var fs2 = require("fs");
    var path22 = require("path");
    var crypto2 = require("crypto");
    var isStream = require_is_stream();
    var {Worker} = (() => {
      try {
        return require("worker_threads");
      } catch (_2) {
        return {};
      }
    })();
    var worker;
    var taskIdCounter = 0;
    var tasks = new Map();
    var recreateWorkerError = (sourceError) => {
      const error = new Error(sourceError.message);
      for (const [key, value] of Object.entries(sourceError)) {
        if (key !== "message") {
          error[key] = value;
        }
      }
      return error;
    };
    var createWorker = () => {
      worker = new Worker(path22.join(__dirname, "thread.js"));
      worker.on("message", (message) => {
        const task = tasks.get(message.id);
        tasks.delete(message.id);
        if (tasks.size === 0) {
          worker.unref();
        }
        if (message.error === void 0) {
          task.resolve(message.value);
        } else {
          task.reject(recreateWorkerError(message.error));
        }
      });
      worker.on("error", (error) => {
        throw error;
      });
    };
    var taskWorker = (method, args, transferList) => new Promise((resolve, reject) => {
      const id = taskIdCounter++;
      tasks.set(id, {resolve, reject});
      if (worker === void 0) {
        createWorker();
      }
      worker.ref();
      worker.postMessage({id, method, args}, transferList);
    });
    var hasha = (input, options = {}) => {
      let outputEncoding = options.encoding || "hex";
      if (outputEncoding === "buffer") {
        outputEncoding = void 0;
      }
      const hash = crypto2.createHash(options.algorithm || "sha512");
      const update = (buffer) => {
        const inputEncoding = typeof buffer === "string" ? "utf8" : void 0;
        hash.update(buffer, inputEncoding);
      };
      if (Array.isArray(input)) {
        input.forEach(update);
      } else {
        update(input);
      }
      return hash.digest(outputEncoding);
    };
    hasha.stream = (options = {}) => {
      let outputEncoding = options.encoding || "hex";
      if (outputEncoding === "buffer") {
        outputEncoding = void 0;
      }
      const stream = crypto2.createHash(options.algorithm || "sha512");
      stream.setEncoding(outputEncoding);
      return stream;
    };
    hasha.fromStream = async (stream, options = {}) => {
      if (!isStream(stream)) {
        throw new TypeError("Expected a stream");
      }
      return new Promise((resolve, reject) => {
        stream.on("error", reject).pipe(hasha.stream(options)).on("error", reject).on("finish", function() {
          resolve(this.read());
        });
      });
    };
    if (Worker === void 0) {
      hasha.fromFile = async (filePath, options) => hasha.fromStream(fs2.createReadStream(filePath), options);
      hasha.async = async (input, options) => hasha(input, options);
    } else {
      hasha.fromFile = async (filePath, {algorithm = "sha512", encoding = "hex"} = {}) => {
        const hash = await taskWorker("hashFile", [algorithm, filePath]);
        if (encoding === "buffer") {
          return Buffer.from(hash);
        }
        return Buffer.from(hash).toString(encoding);
      };
      hasha.async = async (input, {algorithm = "sha512", encoding = "hex"} = {}) => {
        if (encoding === "buffer") {
          encoding = void 0;
        }
        const hash = await taskWorker("hash", [algorithm, input]);
        if (encoding === void 0) {
          return Buffer.from(hash);
        }
        return Buffer.from(hash).toString(encoding);
      };
    }
    hasha.fromFileSync = (filePath, options) => hasha(fs2.readFileSync(filePath), options);
    module2.exports = hasha;
  });
  var require_downloadZip = __commonJS((exports2) => {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : {default: mod2};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.downloadZip = void 0;
    var zlib_1 = __importDefault2(require("zlib"));
    var p_retry_1 = __importDefault2(require_p_retry());
    var node_fetch_1 = __importDefault2(require_lib());
    var fs_12 = __importDefault2(require("fs"));
    var getProxyAgent_1 = require_getProxyAgent();
    var tempy_1 = __importDefault2(require_tempy());
    var path_12 = __importDefault2(require("path"));
    var debug_12 = __importDefault2(require_dist());
    var hasha_1 = __importDefault2(require_hasha());
    var util_12 = require("util");
    var rimraf_1 = __importDefault2(require_rimraf());
    var debug32 = debug_12.default("prisma:downloadZip");
    var del = util_12.promisify(rimraf_1.default);
    async function fetchSha256(url) {
      const [zippedSha256, sha256] = [
        (await node_fetch_1.default(`${url}.sha256`, {
          agent: getProxyAgent_1.getProxyAgent(url)
        }).then((res) => res.text())).split(/\s+/)[0],
        (await node_fetch_1.default(`${url.slice(0, url.length - 3)}.sha256`, {
          agent: getProxyAgent_1.getProxyAgent(url.slice(0, url.length - 3))
        }).then((res) => res.text())).split(/\s+/)[0]
      ];
      return {sha256, zippedSha256};
    }
    async function downloadZip(url, target, progressCb) {
      const tmpDir = tempy_1.default.directory();
      const partial = path_12.default.join(tmpDir, "partial");
      const {sha256, zippedSha256} = await fetchSha256(url);
      const result = await p_retry_1.default(async () => {
        try {
          const resp = await node_fetch_1.default(url, {
            compress: false,
            agent: getProxyAgent_1.getProxyAgent(url)
          });
          if (resp.status !== 200) {
            throw new Error(resp.statusText + " " + url);
          }
          const lastModified = resp.headers.get("last-modified");
          const size = parseFloat(resp.headers.get("content-length"));
          const ws = fs_12.default.createWriteStream(partial);
          return await new Promise(async (resolve, reject) => {
            let bytesRead = 0;
            resp.body.on("error", reject).on("data", (chunk) => {
              bytesRead += chunk.length;
              if (size && progressCb) {
                progressCb(bytesRead / size);
              }
            });
            const gunzip = zlib_1.default.createGunzip();
            gunzip.on("error", reject);
            const zipStream = resp.body.pipe(gunzip);
            const zippedHashPromise = hasha_1.default.fromStream(resp.body, {
              algorithm: "sha256"
            });
            const hashPromise = hasha_1.default.fromStream(zipStream, {
              algorithm: "sha256"
            });
            zipStream.pipe(ws);
            ws.on("error", reject).on("close", () => {
              resolve({lastModified, sha256, zippedSha256});
            });
            const hash = await hashPromise;
            const zippedHash = await zippedHashPromise;
            if (zippedHash !== zippedSha256) {
              throw new Error(`sha256 of ${url} (zipped) should be ${zippedSha256} but is ${zippedHash}`);
            }
            if (hash !== sha256) {
              throw new Error(`sha256 of ${url} (uzipped) should be ${sha256} but is ${hash}`);
            }
          });
        } finally {
        }
      }, {
        retries: 2,
        onFailedAttempt: (err) => debug32(err)
      });
      fs_12.default.copyFileSync(partial, target);
      try {
        await del(partial);
        await del(tmpDir);
      } catch (e) {
        debug32(e);
      }
      return result;
    }
    exports2.downloadZip = downloadZip;
  });
  var require_flatMap = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.flatMap = void 0;
    function flatten(array) {
      return Array.prototype.concat.apply([], array);
    }
    function flatMap(array, callbackFn, thisArg) {
      return flatten(array.map(callbackFn, thisArg));
    }
    exports2.flatMap = flatMap;
  });
  var require_getHash = __commonJS((exports2) => {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : {default: mod2};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.getHash = void 0;
    var crypto_1 = __importDefault2(require("crypto"));
    var fs_12 = __importDefault2(require("fs"));
    function getHash(filePath) {
      const hash = crypto_1.default.createHash("sha256");
      const input = fs_12.default.createReadStream(filePath);
      return new Promise((resolve) => {
        input.on("readable", () => {
          const data = input.read();
          if (data) {
            hash.update(data);
          } else {
            resolve(hash.digest("hex"));
          }
        });
      });
    }
    exports2.getHash = getHash;
  });
  var require_getLatestTag = __commonJS((exports2) => {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : {default: mod2};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.urlExists = exports2.getAllUrls = exports2.getLatestTag = void 0;
    var get_platform_12 = require_dist2();
    var chalk_12 = __importDefault2(require_source());
    var execa_12 = __importDefault2(require_execa());
    var node_fetch_1 = __importDefault2(require_lib());
    var p_map_1 = __importDefault2(require_p_map());
    var getProxyAgent_1 = require_getProxyAgent();
    var util_12 = require_util2();
    async function getLatestTag() {
      let branch = await getBranch();
      if (branch !== "master" && !isPatchBranch(branch) && !branch.startsWith("integration/")) {
        branch = "master";
      }
      branch = branch.replace(/^integration\//, "");
      let commits = await getCommits(branch);
      if ((!commits || !Array.isArray(commits)) && branch !== "master" && !isPatchBranch(branch)) {
        console.log(`Overwriting branch "${branch}" with "master" as it's not a branch we have binaries for`);
        branch = "master";
        commits = await getCommits(branch);
      }
      if (!Array.isArray(commits)) {
        console.error(commits);
        throw new Error(`Could not fetch commits from github: ${JSON.stringify(commits, null, 2)}`);
      }
      return getFirstFinishedCommit(branch, commits);
    }
    exports2.getLatestTag = getLatestTag;
    function getAllUrls(branch, commit) {
      const urls = [];
      const excludedPlatforms = [
        "freebsd",
        "arm",
        "linux-nixos",
        "openbsd",
        "netbsd",
        "freebsd11",
        "freebsd12"
      ];
      const relevantPlatforms = get_platform_12.platforms.filter((p) => !excludedPlatforms.includes(p));
      for (const platform of relevantPlatforms) {
        for (const engine of [
          "query-engine",
          "introspection-engine",
          "migration-engine",
          "prisma-fmt"
        ]) {
          for (const extension of [
            ".gz",
            ".gz.sha256",
            ".gz.sig",
            ".sig",
            ".sha256"
          ]) {
            const downloadUrl = util_12.getDownloadUrl(branch, commit, platform, engine, extension);
            urls.push(downloadUrl);
          }
        }
      }
      return urls;
    }
    exports2.getAllUrls = getAllUrls;
    async function getFirstFinishedCommit(branch, commits) {
      for (const commit of commits) {
        const urls = getAllUrls(branch, commit);
        const exist = await p_map_1.default(urls, urlExists, {concurrency: 10});
        const hasMissing = exist.some((e) => !e);
        if (!hasMissing) {
          return commit;
        } else {
          const missing = urls.filter((_2, i) => !exist[i]);
          if (missing.length !== urls.length) {
            console.log(`${chalk_12.default.blueBright("info")} The engine commit ${commit} is not yet done. We're skipping it as we're in dev. Missing urls: ${missing.length}`);
          }
        }
      }
    }
    async function urlExists(url) {
      try {
        const res = await node_fetch_1.default(url, {
          method: "HEAD",
          agent: getProxyAgent_1.getProxyAgent(url)
        });
        const headers = fromEntries(res.headers.entries());
        if (res.status > 200) {
        }
        if (parseInt(headers["content-length"]) > 0) {
          return res.status < 300;
        }
      } catch (e) {
      }
      return false;
    }
    exports2.urlExists = urlExists;
    function fromEntries(entries) {
      const result = {};
      for (const [key, value] of entries) {
        result[key] = value;
      }
      return result;
    }
    async function getBranch() {
      if (process.env.NODE_ENV !== "test") {
        if (process.env.PATCH_BRANCH) {
          return process.env.PATCH_BRANCH;
        }
        if (process.env.BUILDKITE_BRANCH) {
          return process.env.BUILDKITE_BRANCH;
        }
        if (process.env.GITHUB_CONTEXT) {
          const context = JSON.parse(process.env.GITHUB_CONTEXT);
          return context.head_ref;
        }
      }
      try {
        const result = await execa_12.default.command("git rev-parse --abbrev-ref HEAD", {
          shell: true,
          stdio: "pipe"
        });
        return result.stdout;
      } catch (e) {
        console.error(e);
      }
      return;
    }
    function isPatchBranch(version) {
      return /^2\.(\d+)\.x/.test(version);
    }
    async function getCommits(branch) {
      const url = `https://github-cache.prisma.workers.dev/repos/prisma/prisma-engines/commits?sha=${branch}`;
      const result = await node_fetch_1.default(url, {
        agent: getProxyAgent_1.getProxyAgent(url),
        headers: {
          Authorization: process.env.GITHUB_TOKEN ? `token ${process.env.GITHUB_TOKEN}` : void 0
        }
      }).then((res) => res.json());
      if (!Array.isArray(result)) {
        return result;
      }
      const commits = result.map((r) => r.sha);
      return commits;
    }
  });
  var require_node_progress = __commonJS((exports2, module2) => {
    /*!
     * node-progress
     * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>
     * MIT Licensed
     */
    exports2 = module2.exports = ProgressBar;
    function ProgressBar(fmt, options) {
      this.stream = options.stream || process.stderr;
      if (typeof options == "number") {
        var total = options;
        options = {};
        options.total = total;
      } else {
        options = options || {};
        if (typeof fmt != "string")
          throw new Error("format required");
        if (typeof options.total != "number")
          throw new Error("total required");
      }
      this.fmt = fmt;
      this.curr = options.curr || 0;
      this.total = options.total;
      this.width = options.width || this.total;
      this.clear = options.clear;
      this.chars = {
        complete: options.complete || "=",
        incomplete: options.incomplete || "-",
        head: options.head || (options.complete || "=")
      };
      this.renderThrottle = options.renderThrottle !== 0 ? options.renderThrottle || 16 : 0;
      this.lastRender = -Infinity;
      this.callback = options.callback || function() {
      };
      this.tokens = {};
      this.lastDraw = "";
    }
    ProgressBar.prototype.tick = function(len, tokens) {
      if (len !== 0)
        len = len || 1;
      if (typeof len == "object")
        tokens = len, len = 1;
      if (tokens)
        this.tokens = tokens;
      if (this.curr == 0)
        this.start = new Date();
      this.curr += len;
      this.render();
      if (this.curr >= this.total) {
        this.render(void 0, true);
        this.complete = true;
        this.terminate();
        this.callback(this);
        return;
      }
    };
    ProgressBar.prototype.render = function(tokens, force) {
      force = force !== void 0 ? force : false;
      if (tokens)
        this.tokens = tokens;
      if (!this.stream.isTTY)
        return;
      var now = Date.now();
      var delta = now - this.lastRender;
      if (!force && delta < this.renderThrottle) {
        return;
      } else {
        this.lastRender = now;
      }
      var ratio = this.curr / this.total;
      ratio = Math.min(Math.max(ratio, 0), 1);
      var percent = Math.floor(ratio * 100);
      var incomplete, complete, completeLength;
      var elapsed = new Date() - this.start;
      var eta = percent == 100 ? 0 : elapsed * (this.total / this.curr - 1);
      var rate = this.curr / (elapsed / 1e3);
      var str = this.fmt.replace(":current", this.curr).replace(":total", this.total).replace(":elapsed", isNaN(elapsed) ? "0.0" : (elapsed / 1e3).toFixed(1)).replace(":eta", isNaN(eta) || !isFinite(eta) ? "0.0" : (eta / 1e3).toFixed(1)).replace(":percent", percent.toFixed(0) + "%").replace(":rate", Math.round(rate));
      var availableSpace = Math.max(0, this.stream.columns - str.replace(":bar", "").length);
      if (availableSpace && process.platform === "win32") {
        availableSpace = availableSpace - 1;
      }
      var width = Math.min(this.width, availableSpace);
      completeLength = Math.round(width * ratio);
      complete = Array(Math.max(0, completeLength + 1)).join(this.chars.complete);
      incomplete = Array(Math.max(0, width - completeLength + 1)).join(this.chars.incomplete);
      if (completeLength > 0)
        complete = complete.slice(0, -1) + this.chars.head;
      str = str.replace(":bar", complete + incomplete);
      if (this.tokens)
        for (var key in this.tokens)
          str = str.replace(":" + key, this.tokens[key]);
      if (this.lastDraw !== str) {
        this.stream.cursorTo(0);
        this.stream.write(str);
        this.stream.clearLine(1);
        this.lastDraw = str;
      }
    };
    ProgressBar.prototype.update = function(ratio, tokens) {
      var goal = Math.floor(ratio * this.total);
      var delta = goal - this.curr;
      this.tick(delta, tokens);
    };
    ProgressBar.prototype.interrupt = function(message) {
      this.stream.clearLine();
      this.stream.cursorTo(0);
      this.stream.write(message);
      this.stream.write("\n");
      this.stream.write(this.lastDraw);
    };
    ProgressBar.prototype.terminate = function() {
      if (this.clear) {
        if (this.stream.clearLine) {
          this.stream.clearLine();
          this.stream.cursorTo(0);
        }
      } else {
        this.stream.write("\n");
      }
    };
  });
  var require_progress = __commonJS((exports2, module2) => {
    module2.exports = require_node_progress();
  });
  var require_log = __commonJS((exports2) => {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : {default: mod2};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.getBar = void 0;
    var progress_1 = __importDefault2(require_progress());
    function getBar(text) {
      return new progress_1.default(`> ${text} [:bar] :percent`, {
        stream: process.stdout,
        width: 20,
        complete: "=",
        incomplete: " ",
        total: 100,
        head: "",
        clear: true
      });
    }
    exports2.getBar = getBar;
  });
  var require_download = __commonJS((exports, module) => {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : {default: mod2};
    };
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.plusX = exports.maybeCopyToTmp = exports.getBinaryEnvVarPath = exports.getBinaryName = exports.checkVersionCommand = exports.getVersion = exports.download = exports.BinaryType = void 0;
    var debug_1 = __importDefault(require_dist());
    var get_platform_1 = require_dist2();
    var chalk_1 = __importDefault(require_source());
    var execa_1 = __importDefault(require_execa());
    var fs_1 = __importDefault(require("fs"));
    var make_dir_1 = __importDefault(require_make_dir());
    var p_filter_1 = __importDefault(require_p_filter());
    var path_1 = __importDefault(require("path"));
    var temp_dir_1 = __importDefault(require_temp_dir());
    var util_1 = require("util");
    var chmod_1 = __importDefault(require_chmod());
    var cleanupCache_1 = require_cleanupCache();
    var downloadZip_1 = require_downloadZip();
    var flatMap_1 = require_flatMap();
    var getHash_1 = require_getHash();
    var getLatestTag_1 = require_getLatestTag();
    var log_1 = require_log();
    var util_2 = require_util2();
    var debug = debug_1.default("prisma:download");
    var writeFile = util_1.promisify(fs_1.default.writeFile);
    var exists = util_1.promisify(fs_1.default.exists);
    var readFile = util_1.promisify(fs_1.default.readFile);
    var copyFile = util_1.promisify(fs_1.default.copyFile);
    var utimes = util_1.promisify(fs_1.default.utimes);
    var channel = "master";
    var BinaryType;
    (function(BinaryType3) {
      BinaryType3["queryEngine"] = "query-engine";
      BinaryType3["libqueryEngine"] = "libquery-engine";
      BinaryType3["migrationEngine"] = "migration-engine";
      BinaryType3["introspectionEngine"] = "introspection-engine";
      BinaryType3["prismaFmt"] = "prisma-fmt";
    })(BinaryType = exports.BinaryType || (exports.BinaryType = {}));
    var BINARY_TO_ENV_VAR = {
      [BinaryType.migrationEngine]: "PRISMA_MIGRATION_ENGINE_BINARY",
      [BinaryType.queryEngine]: "PRISMA_QUERY_ENGINE_BINARY",
      [BinaryType.libqueryEngine]: "PRISMA_QUERY_ENGINE_LIBRARY",
      [BinaryType.introspectionEngine]: "PRISMA_INTROSPECTION_ENGINE_BINARY",
      [BinaryType.prismaFmt]: "PRISMA_FMT_BINARY"
    };
    async function download(options) {
      var _a, _b;
      const platform = await get_platform_1.getPlatform();
      const os = await get_platform_1.getos();
      if (os.distro && ["nixos"].includes(os.distro)) {
        console.error(`${chalk_1.default.yellow("Warning")} Precompiled binaries are not available for ${os.distro}.`);
      } else if (["freebsd11", "freebsd12", "openbsd", "netbsd"].includes(platform)) {
        console.error(`${chalk_1.default.yellow("Warning")} Precompiled binaries are not available for ${platform}. Read more about building your own binaries at https://pris.ly/d/build-binaries`);
      } else if (BinaryType.libqueryEngine in options.binaries) {
        await get_platform_1.isNodeAPISupported();
      }
      if (!options.binaries || Object.values(options.binaries).length === 0) {
        return {};
      }
      const opts = {
        ...options,
        binaryTargets: (_a = options.binaryTargets) !== null && _a !== void 0 ? _a : [platform],
        version: (_b = options.version) !== null && _b !== void 0 ? _b : "latest",
        binaries: mapKeys(options.binaries, (key) => engineTypeToBinaryType(key, platform))
      };
      const binaryJobs = flatMap_1.flatMap(Object.entries(opts.binaries), ([binaryName, targetFolder]) => opts.binaryTargets.map((binaryTarget) => {
        const fileName = binaryName === BinaryType.libqueryEngine ? get_platform_1.getNodeAPIName(binaryTarget, "fs") : getBinaryName(binaryName, binaryTarget);
        const targetFilePath = path_1.default.join(targetFolder, fileName);
        return {
          binaryName,
          targetFolder,
          binaryTarget,
          fileName,
          targetFilePath,
          envVarPath: getBinaryEnvVarPath(binaryName)
        };
      }));
      if (process.env.BINARY_DOWNLOAD_VERSION) {
        opts.version = process.env.BINARY_DOWNLOAD_VERSION;
      }
      if (opts.version === "latest") {
        opts.version = await getLatestTag_1.getLatestTag();
      }
      if (opts.printVersion) {
        console.log(`version: ${opts.version}`);
      }
      const binariesToDownload = await p_filter_1.default(binaryJobs, async (job) => {
        const needsToBeDownloaded = await binaryNeedsToBeDownloaded(job, platform, opts.version, opts.failSilent);
        const isSupported = get_platform_1.platforms.includes(job.binaryTarget);
        const shouldDownload = isSupported && !job.envVarPath && (opts.ignoreCache || needsToBeDownloaded);
        if (needsToBeDownloaded && !isSupported) {
          throw new Error(`Unknown binaryTarget ${job.binaryTarget} and no custom binaries were provided`);
        }
        return shouldDownload;
      });
      if (binariesToDownload.length > 0) {
        const cleanupPromise = cleanupCache_1.cleanupCache();
        let finishBar;
        let setProgress;
        if (opts.showProgress) {
          const collectiveBar = getCollectiveBar(opts);
          finishBar = collectiveBar.finishBar;
          setProgress = collectiveBar.setProgress;
        }
        await Promise.all(binariesToDownload.map((job) => downloadBinary({
          ...job,
          version: opts.version,
          failSilent: opts.failSilent,
          progressCb: setProgress ? setProgress(job.targetFilePath) : void 0
        })));
        await cleanupPromise;
        if (finishBar) {
          finishBar();
        }
      }
      const binaryPaths = binaryJobsToBinaryPaths(binaryJobs);
      const dir = eval("__dirname");
      if (dir.startsWith("/snapshot/")) {
        for (const engineType in binaryPaths) {
          const binaryTargets = binaryPaths[engineType];
          for (const binaryTarget in binaryTargets) {
            const binaryPath = binaryTargets[binaryTarget];
            binaryTargets[binaryTarget] = await maybeCopyToTmp(binaryPath);
          }
        }
      }
      return binaryPaths;
    }
    exports.download = download;
    function getCollectiveBar(options) {
      var _a, _b;
      const hasNodeAPI = "libquery-engine" in options.binaries;
      const bar = log_1.getBar(`Downloading Prisma engines${hasNodeAPI ? " for Node-API" : ""} for ${(_a = options.binaryTargets) === null || _a === void 0 ? void 0 : _a.map((p) => chalk_1.default.bold(p)).join(" and ")}`);
      const progressMap = {};
      const numDownloads = Object.values(options.binaries).length * Object.values((_b = options === null || options === void 0 ? void 0 : options.binaryTargets) !== null && _b !== void 0 ? _b : []).length;
      const setProgress = (sourcePath) => (progress) => {
        progressMap[sourcePath] = progress;
        const progressValues = Object.values(progressMap);
        const totalProgress = progressValues.reduce((acc, curr) => {
          return acc + curr;
        }, 0) / numDownloads;
        if (options.progressCb) {
          options.progressCb(totalProgress);
        }
        if (bar) {
          bar.update(totalProgress);
        }
      };
      return {
        setProgress,
        finishBar: () => {
          bar.update(1);
          bar.terminate();
        }
      };
    }
    function binaryJobsToBinaryPaths(jobs) {
      return jobs.reduce((acc, job) => {
        if (!acc[job.binaryName]) {
          acc[job.binaryName] = {};
        }
        acc[job.binaryName][job.binaryTarget] = job.envVarPath || job.targetFilePath;
        return acc;
      }, {});
    }
    async function binaryNeedsToBeDownloaded(job, nativePlatform, version, failSilent) {
      if (job.envVarPath && fs_1.default.existsSync(job.envVarPath)) {
        return false;
      }
      const targetExists = await exists(job.targetFilePath);
      const cachedFile = await getCachedBinaryPath({
        ...job,
        version,
        failSilent
      });
      if (cachedFile) {
        const sha256FilePath = cachedFile + ".sha256";
        if (await exists(sha256FilePath)) {
          const sha256File = await readFile(sha256FilePath, "utf-8");
          const sha256Cache = await getHash_1.getHash(cachedFile);
          if (sha256File === sha256Cache) {
            if (!targetExists) {
              debug(`copying ${cachedFile} to ${job.targetFilePath}`);
              await utimes(cachedFile, new Date(), new Date());
              await copyFile(cachedFile, job.targetFilePath);
            }
            const targetSha256 = await getHash_1.getHash(job.targetFilePath);
            if (sha256File !== targetSha256) {
              debug(`overwriting ${job.targetFilePath} with ${cachedFile} as hashes do not match`);
              await copyFile(cachedFile, job.targetFilePath);
            }
            return false;
          } else {
            return true;
          }
        } else {
          return true;
        }
      }
      if (!targetExists) {
        debug(`file ${job.targetFilePath} does not exist and must be downloaded`);
        return true;
      }
      if (job.binaryTarget === nativePlatform && job.binaryName !== BinaryType.libqueryEngine) {
        const works = await checkVersionCommand(job.targetFilePath);
        return !works;
      }
      return false;
    }
    async function getVersion(enginePath) {
      const result = await execa_1.default(enginePath, ["--version"]);
      return result.stdout;
    }
    exports.getVersion = getVersion;
    async function checkVersionCommand(enginePath) {
      try {
        const version = await getVersion(enginePath);
        return version.length > 0;
      } catch (e) {
        return false;
      }
    }
    exports.checkVersionCommand = checkVersionCommand;
    function getBinaryName(binaryName, platform) {
      if (binaryName === BinaryType.libqueryEngine) {
        return `${get_platform_1.getNodeAPIName(platform, "url")}`;
      }
      const extension = platform === "windows" ? ".exe" : "";
      return `${binaryName}-${platform}${extension}`;
    }
    exports.getBinaryName = getBinaryName;
    async function getCachedBinaryPath({version, binaryTarget, binaryName}) {
      const cacheDir = await util_2.getCacheDir(channel, version, binaryTarget);
      if (!cacheDir) {
        return null;
      }
      const cachedTargetPath = path_1.default.join(cacheDir, binaryName);
      if (!fs_1.default.existsSync(cachedTargetPath)) {
        return null;
      }
      if (version !== "latest") {
        return cachedTargetPath;
      }
      if (await exists(cachedTargetPath)) {
        return cachedTargetPath;
      }
      return null;
    }
    function getBinaryEnvVarPath(binaryName) {
      const envVar = BINARY_TO_ENV_VAR[binaryName];
      if (envVar && process.env[envVar]) {
        const envVarPath = path_1.default.resolve(process.cwd(), process.env[envVar]);
        if (!fs_1.default.existsSync(envVarPath)) {
          throw new Error(`Env var ${chalk_1.default.bold(envVar)} is provided but provided path ${chalk_1.default.underline(process.env[envVar])} can't be resolved.`);
        }
        debug(`Using env var ${chalk_1.default.bold(envVar)} for binary ${chalk_1.default.bold(binaryName)}, which points to ${chalk_1.default.underline(process.env[envVar])}`);
        return envVarPath;
      }
      return null;
    }
    exports.getBinaryEnvVarPath = getBinaryEnvVarPath;
    async function downloadBinary(options) {
      const {version, progressCb, targetFilePath, binaryTarget, binaryName} = options;
      const downloadUrl = util_2.getDownloadUrl("all_commits", version, binaryTarget, binaryName);
      const targetDir = path_1.default.dirname(targetFilePath);
      try {
        fs_1.default.accessSync(targetDir, fs_1.default.constants.W_OK);
        await make_dir_1.default(targetDir);
      } catch (e) {
        if (options.failSilent || e.code !== "EACCES") {
          return;
        } else {
          throw new Error(`Can't write to ${targetDir} please make sure you install "prisma" with the right permissions.`);
        }
      }
      debug(`Downloading ${downloadUrl} to ${targetFilePath}`);
      if (progressCb) {
        progressCb(0);
      }
      const {sha256, zippedSha256} = await downloadZip_1.downloadZip(downloadUrl, targetFilePath, progressCb);
      if (progressCb) {
        progressCb(1);
      }
      if (process.platform !== "win32") {
        chmod_1.default(targetFilePath);
      }
      await saveFileToCache(options, version, sha256, zippedSha256);
    }
    async function saveFileToCache(job, version, sha256, zippedSha256) {
      const cacheDir = await util_2.getCacheDir(channel, version, job.binaryTarget);
      if (!cacheDir) {
        return;
      }
      const cachedTargetPath = path_1.default.join(cacheDir, job.binaryName);
      const cachedSha256Path = path_1.default.join(cacheDir, job.binaryName + ".sha256");
      const cachedSha256ZippedPath = path_1.default.join(cacheDir, job.binaryName + ".gz.sha256");
      try {
        await copyFile(job.targetFilePath, cachedTargetPath);
        await writeFile(cachedSha256Path, sha256);
        await writeFile(cachedSha256ZippedPath, zippedSha256);
      } catch (e) {
        debug(e);
      }
    }
    function engineTypeToBinaryType(engineType, binaryTarget) {
      if (BinaryType[engineType]) {
        return BinaryType[engineType];
      }
      if (engineType === "native") {
        return binaryTarget;
      }
      return engineType;
    }
    function mapKeys(obj, mapper) {
      return Object.entries(obj).reduce((acc, [key, value]) => {
        acc[mapper(key)] = value;
        return acc;
      }, {});
    }
    async function maybeCopyToTmp(file) {
      const dir = eval("__dirname");
      if (dir.startsWith("/snapshot/")) {
        const targetDir = path_1.default.join(temp_dir_1.default, "prisma-binaries");
        await make_dir_1.default(targetDir);
        const target = path_1.default.join(targetDir, path_1.default.basename(file));
        const data = await readFile(file);
        await writeFile(target, data);
        plusX(target);
        return target;
      }
      return file;
    }
    exports.maybeCopyToTmp = maybeCopyToTmp;
    function plusX(file) {
      const s2 = fs_1.default.statSync(file);
      const newMode = s2.mode | 64 | 8 | 1;
      if (s2.mode === newMode) {
        return;
      }
      const base8 = newMode.toString(8).slice(-3);
      fs_1.default.chmodSync(file, base8);
    }
    exports.plusX = plusX;
  });
  var require_dist6 = __commonJS((exports2) => {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m2[k];
      }});
    } : function(o, m2, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m2[k];
    });
    var __exportStar22 = exports2 && exports2.__exportStar || function(m2, exports3) {
      for (var p in m2)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m2, p);
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.getProxyAgent = exports2.urlExists = exports2.getLatestTag = exports2.getAllUrls = void 0;
    __exportStar22(require_download(), exports2);
    var getLatestTag_12 = require_getLatestTag();
    Object.defineProperty(exports2, "getAllUrls", {enumerable: true, get: function() {
      return getLatestTag_12.getAllUrls;
    }});
    Object.defineProperty(exports2, "getLatestTag", {enumerable: true, get: function() {
      return getLatestTag_12.getLatestTag;
    }});
    Object.defineProperty(exports2, "urlExists", {enumerable: true, get: function() {
      return getLatestTag_12.urlExists;
    }});
    var getProxyAgent_1 = require_getProxyAgent();
    Object.defineProperty(exports2, "getProxyAgent", {enumerable: true, get: function() {
      return getProxyAgent_1.getProxyAgent;
    }});
  });
  __markAsModule(exports);
  __export(exports, {
    DEFAULT_CLI_QUERY_ENGINE_BINARY_TYPE: () => DEFAULT_CLI_QUERY_ENGINE_BINARY_TYPE,
    enginesVersion: () => import_engines_version2.enginesVersion,
    ensureBinariesExist: () => ensureBinariesExist,
    getCliQueryEngineBinaryType: () => getCliQueryEngineBinaryType,
    getEnginesPath: () => getEnginesPath
  });
  var import_debug = __toModule(require_dist());
  var import_engines_version = __toModule(require_engines_version());
  var import_fetch_engine = __toModule(require_dist6());
  var import_path = __toModule(require("path"));
  var import_engines_version2 = __toModule(require_engines_version());
  var debug2 = import_debug.default("prisma:engines");
  function getEnginesPath() {
    return import_path.default.join(__dirname, "../");
  }
  var DEFAULT_CLI_QUERY_ENGINE_BINARY_TYPE = import_fetch_engine.BinaryType.queryEngine;
  function getCliQueryEngineBinaryType() {
    const envCliQueryEngineType = process.env.PRISMA_CLI_QUERY_ENGINE_TYPE;
    if (envCliQueryEngineType) {
      if (envCliQueryEngineType === "binary") {
        return import_fetch_engine.BinaryType.queryEngine;
      }
      if (envCliQueryEngineType === "library") {
        return import_fetch_engine.BinaryType.libqueryEngine;
      }
    }
    return DEFAULT_CLI_QUERY_ENGINE_BINARY_TYPE;
  }
  async function ensureBinariesExist() {
    const binaryDir = import_path.default.join(__dirname, "../");
    let binaryTargets = void 0;
    if (process.env.PRISMA_CLI_BINARY_TARGETS) {
      binaryTargets = process.env.PRISMA_CLI_BINARY_TARGETS.split(",");
    }
    const cliQueryEngineBinaryType = getCliQueryEngineBinaryType();
    const binaries = {
      [cliQueryEngineBinaryType]: binaryDir,
      [import_fetch_engine.BinaryType.migrationEngine]: binaryDir,
      [import_fetch_engine.BinaryType.introspectionEngine]: binaryDir,
      [import_fetch_engine.BinaryType.prismaFmt]: binaryDir
    };
    debug2(`binaries to download ${Object.keys(binaries).join(", ")}`);
    await import_fetch_engine.download({
      binaries,
      showProgress: true,
      version: import_engines_version.enginesVersion,
      failSilent: false,
      binaryTargets
    });
  }
  import_path.default.join(__dirname, "../query-engine-darwin");
  import_path.default.join(__dirname, "../introspection-engine-darwin");
  import_path.default.join(__dirname, "../prisma-fmt-darwin");
  import_path.default.join(__dirname, "../query-engine-darwin-arm64");
  import_path.default.join(__dirname, "../introspection-engine-darwin-arm64");
  import_path.default.join(__dirname, "../prisma-fmt-darwin-arm64");
  import_path.default.join(__dirname, "../query-engine-debian-openssl-1.0.x");
  import_path.default.join(__dirname, "../introspection-engine-debian-openssl-1.0.x");
  import_path.default.join(__dirname, "../prisma-fmt-debian-openssl-1.0.x");
  import_path.default.join(__dirname, "../query-engine-debian-openssl-1.1.x");
  import_path.default.join(__dirname, "../introspection-engine-debian-openssl-1.1.x");
  import_path.default.join(__dirname, "../prisma-fmt-debian-openssl-1.1.x");
  import_path.default.join(__dirname, "../query-engine-rhel-openssl-1.0.x");
  import_path.default.join(__dirname, "../introspection-engine-rhel-openssl-1.0.x");
  import_path.default.join(__dirname, "../prisma-fmt-rhel-openssl-1.0.x");
  import_path.default.join(__dirname, "../query-engine-rhel-openssl-1.1.x");
  import_path.default.join(__dirname, "../introspection-engine-rhel-openssl-1.1.x");
  import_path.default.join(__dirname, "../prisma-fmt-rhel-openssl-1.1.x");
  import_path.default.join(__dirname, "../libquery_engine-darwin.dylib.node");
  import_path.default.join(__dirname, "../libquery_engine-darwin-arm64.dylib.node");
  import_path.default.join(__dirname, "../libquery_engine-debian-openssl-1.0.x.so.node");
  import_path.default.join(__dirname, "../libquery_engine-debian-openssl-1.1.x.so.node");
  import_path.default.join(__dirname, "../libquery_engine-linux-arm-openssl-1.0.x.so.node");
  import_path.default.join(__dirname, "../libquery_engine-linux-arm-openssl-1.1.x.so.node");
  import_path.default.join(__dirname, "../libquery_engine-linux-musl.so.node");
  import_path.default.join(__dirname, "../libquery_engine-rhel-openssl-1.0.x.so.node");
  import_path.default.join(__dirname, "../libquery_engine-rhel-openssl-1.1.x.so.node");
  import_path.default.join(__dirname, "../query_engine-windows.dll.node");
});

// ../../node_modules/.pnpm/ansi-escapes@4.3.2/node_modules/ansi-escapes/index.js
var require_ansi_escapes = __commonJS2((exports2, module2) => {
  "use strict";
  var ansiEscapes = module2.exports;
  module2.exports.default = ansiEscapes;
  var ESC = "[";
  var OSC = "]";
  var BEL = "\x07";
  var SEP = ";";
  var isTerminalApp = process.env.TERM_PROGRAM === "Apple_Terminal";
  ansiEscapes.cursorTo = (x, y2) => {
    if (typeof x !== "number") {
      throw new TypeError("The `x` argument is required");
    }
    if (typeof y2 !== "number") {
      return ESC + (x + 1) + "G";
    }
    return ESC + (y2 + 1) + ";" + (x + 1) + "H";
  };
  ansiEscapes.cursorMove = (x, y2) => {
    if (typeof x !== "number") {
      throw new TypeError("The `x` argument is required");
    }
    let ret = "";
    if (x < 0) {
      ret += ESC + -x + "D";
    } else if (x > 0) {
      ret += ESC + x + "C";
    }
    if (y2 < 0) {
      ret += ESC + -y2 + "A";
    } else if (y2 > 0) {
      ret += ESC + y2 + "B";
    }
    return ret;
  };
  ansiEscapes.cursorUp = (count = 1) => ESC + count + "A";
  ansiEscapes.cursorDown = (count = 1) => ESC + count + "B";
  ansiEscapes.cursorForward = (count = 1) => ESC + count + "C";
  ansiEscapes.cursorBackward = (count = 1) => ESC + count + "D";
  ansiEscapes.cursorLeft = ESC + "G";
  ansiEscapes.cursorSavePosition = isTerminalApp ? "7" : ESC + "s";
  ansiEscapes.cursorRestorePosition = isTerminalApp ? "8" : ESC + "u";
  ansiEscapes.cursorGetPosition = ESC + "6n";
  ansiEscapes.cursorNextLine = ESC + "E";
  ansiEscapes.cursorPrevLine = ESC + "F";
  ansiEscapes.cursorHide = ESC + "?25l";
  ansiEscapes.cursorShow = ESC + "?25h";
  ansiEscapes.eraseLines = (count) => {
    let clear = "";
    for (let i = 0; i < count; i++) {
      clear += ansiEscapes.eraseLine + (i < count - 1 ? ansiEscapes.cursorUp() : "");
    }
    if (count) {
      clear += ansiEscapes.cursorLeft;
    }
    return clear;
  };
  ansiEscapes.eraseEndLine = ESC + "K";
  ansiEscapes.eraseStartLine = ESC + "1K";
  ansiEscapes.eraseLine = ESC + "2K";
  ansiEscapes.eraseDown = ESC + "J";
  ansiEscapes.eraseUp = ESC + "1J";
  ansiEscapes.eraseScreen = ESC + "2J";
  ansiEscapes.scrollUp = ESC + "S";
  ansiEscapes.scrollDown = ESC + "T";
  ansiEscapes.clearScreen = "c";
  ansiEscapes.clearTerminal = process.platform === "win32" ? `${ansiEscapes.eraseScreen}${ESC}0f` : `${ansiEscapes.eraseScreen}${ESC}3J${ESC}H`;
  ansiEscapes.beep = BEL;
  ansiEscapes.link = (text, url) => {
    return [
      OSC,
      "8",
      SEP,
      SEP,
      url,
      BEL,
      text,
      OSC,
      "8",
      SEP,
      SEP,
      BEL
    ].join("");
  };
  ansiEscapes.image = (buffer, options = {}) => {
    let ret = `${OSC}1337;File=inline=1`;
    if (options.width) {
      ret += `;width=${options.width}`;
    }
    if (options.height) {
      ret += `;height=${options.height}`;
    }
    if (options.preserveAspectRatio === false) {
      ret += ";preserveAspectRatio=0";
    }
    return ret + ":" + buffer.toString("base64") + BEL;
  };
  ansiEscapes.iTerm = {
    setCwd: (cwd = process.cwd()) => `${OSC}50;CurrentDir=${cwd}${BEL}`,
    annotation: (message, options = {}) => {
      let ret = `${OSC}1337;`;
      const hasX = typeof options.x !== "undefined";
      const hasY = typeof options.y !== "undefined";
      if ((hasX || hasY) && !(hasX && hasY && typeof options.length !== "undefined")) {
        throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");
      }
      message = message.replace(/\|/g, "");
      ret += options.isHidden ? "AddHiddenAnnotation=" : "AddAnnotation=";
      if (options.length > 0) {
        ret += (hasX ? [message, options.length, options.x, options.y] : [options.length, message]).join("|");
      } else {
        ret += message;
      }
      return ret + BEL;
    }
  };
});

// ../../node_modules/.pnpm/supports-hyperlinks@2.2.0/node_modules/supports-hyperlinks/index.js
var require_supports_hyperlinks = __commonJS2((exports2, module2) => {
  "use strict";
  var supportsColor = require_supports_color2();
  var hasFlag = require_has_flag2();
  function parseVersion(versionString) {
    if (/^\d{3,4}$/.test(versionString)) {
      const m2 = /(\d{1,2})(\d{2})/.exec(versionString);
      return {
        major: 0,
        minor: parseInt(m2[1], 10),
        patch: parseInt(m2[2], 10)
      };
    }
    const versions = (versionString || "").split(".").map((n) => parseInt(n, 10));
    return {
      major: versions[0],
      minor: versions[1],
      patch: versions[2]
    };
  }
  function supportsHyperlink(stream) {
    const {env: env2} = process;
    if ("FORCE_HYPERLINK" in env2) {
      return !(env2.FORCE_HYPERLINK.length > 0 && parseInt(env2.FORCE_HYPERLINK, 10) === 0);
    }
    if (hasFlag("no-hyperlink") || hasFlag("no-hyperlinks") || hasFlag("hyperlink=false") || hasFlag("hyperlink=never")) {
      return false;
    }
    if (hasFlag("hyperlink=true") || hasFlag("hyperlink=always")) {
      return true;
    }
    if (!supportsColor.supportsColor(stream)) {
      return false;
    }
    if (stream && !stream.isTTY) {
      return false;
    }
    if (process.platform === "win32") {
      return false;
    }
    if ("NETLIFY" in env2) {
      return true;
    }
    if ("CI" in env2) {
      return false;
    }
    if ("TEAMCITY_VERSION" in env2) {
      return false;
    }
    if ("TERM_PROGRAM" in env2) {
      const version = parseVersion(env2.TERM_PROGRAM_VERSION);
      switch (env2.TERM_PROGRAM) {
        case "iTerm.app":
          if (version.major === 3) {
            return version.minor >= 1;
          }
          return version.major > 3;
      }
    }
    if ("VTE_VERSION" in env2) {
      if (env2.VTE_VERSION === "0.50.0") {
        return false;
      }
      const version = parseVersion(env2.VTE_VERSION);
      return version.major > 0 || version.minor >= 50;
    }
    return false;
  }
  module2.exports = {
    supportsHyperlink,
    stdout: supportsHyperlink(process.stdout),
    stderr: supportsHyperlink(process.stderr)
  };
});

// ../../node_modules/.pnpm/terminal-link@2.1.1/node_modules/terminal-link/index.js
var require_terminal_link = __commonJS2((exports2, module2) => {
  "use strict";
  var ansiEscapes = require_ansi_escapes();
  var supportsHyperlinks = require_supports_hyperlinks();
  var terminalLink = (text, url, {target = "stdout", ...options} = {}) => {
    if (!supportsHyperlinks[target]) {
      if (options.fallback === false) {
        return text;
      }
      return typeof options.fallback === "function" ? options.fallback(text, url) : `${text} (\u200B${url}\u200B)`;
    }
    return ansiEscapes.link(text, url);
  };
  module2.exports = (text, url, options = {}) => terminalLink(text, url, options);
  module2.exports.stderr = (text, url, options = {}) => terminalLink(text, url, {target: "stderr", ...options});
  module2.exports.isSupported = supportsHyperlinks.stdout;
  module2.exports.stderr.isSupported = supportsHyperlinks.stderr;
});

// ../../node_modules/.pnpm/new-github-issue-url@0.2.1/node_modules/new-github-issue-url/index.js
var require_new_github_issue_url = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = (options = {}) => {
    let repoUrl;
    if (options.repoUrl) {
      repoUrl = options.repoUrl;
    } else if (options.user && options.repo) {
      repoUrl = `https://github.com/${options.user}/${options.repo}`;
    } else {
      throw new Error("You need to specify either the `repoUrl` option or both the `user` and `repo` options");
    }
    const url = new URL(`${repoUrl}/issues/new`);
    const types = [
      "body",
      "title",
      "labels",
      "template",
      "milestone",
      "assignee",
      "projects"
    ];
    for (const type of types) {
      let value = options[type];
      if (value === void 0) {
        continue;
      }
      if (type === "labels" || type === "projects") {
        if (!Array.isArray(value)) {
          throw new TypeError(`The \`${type}\` option should be an array`);
        }
        value = value.join(",");
      }
      url.searchParams.set(type, value);
    }
    return url.toString();
  };
  module2.exports.default = module2.exports;
});

// ../engine-core/dist/common/utils/util.js
var require_util5 = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    fixBinaryTargets: () => fixBinaryTargets2,
    getGithubIssueUrl: () => getGithubIssueUrl,
    getRandomString: () => getRandomString,
    link: () => link2,
    plusX: () => plusX2
  });
  var import_fs2 = __toModule3(require("fs"));
  var import_terminal_link = __toModule3(require_terminal_link());
  var import_new_github_issue_url = __toModule3(require_new_github_issue_url());
  var import_chalk3 = __toModule3(require_source2());
  var import_debug3 = __toModule3(require_dist7());
  var import_crypto = __toModule3(require("crypto"));
  var debug4 = (0, import_debug3.default)("plusX");
  function plusX2(file) {
    const s2 = import_fs2.default.statSync(file);
    const newMode = s2.mode | 64 | 8 | 1;
    if (s2.mode === newMode) {
      debug4(`Execution permissions of ${file} are fine`);
      return;
    }
    const base8 = newMode.toString(8).slice(-3);
    debug4(`Have to call plusX on ${file}`);
    import_fs2.default.chmodSync(file, base8);
  }
  function transformPlatformToEnvValue(platform) {
    return {fromEnvVar: null, value: platform};
  }
  function fixBinaryTargets2(binaryTargets, platform) {
    binaryTargets = binaryTargets || [];
    if (!binaryTargets.find((object) => object.value === "native")) {
      return [transformPlatformToEnvValue("native"), ...binaryTargets];
    }
    return [...binaryTargets, transformPlatformToEnvValue(platform)];
  }
  function link2(url) {
    return (0, import_terminal_link.default)(url, url, {
      fallback: (url2) => import_chalk3.default.underline(url2)
    });
  }
  function getGithubIssueUrl({
    title,
    user = "prisma",
    repo = "prisma",
    template = "bug_report.md",
    body
  }) {
    return (0, import_new_github_issue_url.default)({
      user,
      repo,
      template,
      title,
      body
    });
  }
  function getRandomString() {
    return import_crypto.default.randomBytes(12).toString("hex");
  }
});

// ../engine-core/dist/common/errors/utils/maskQuery.js
var require_maskQuery = __commonJS2((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    maskQuery: () => maskQuery
  });
  function maskQuery(query) {
    if (!query) {
      return "";
    }
    return query.replace(/".*"/g, '"X"').replace(/[\s:\[]([+-]?([0-9]*[.])?[0-9]+)/g, (substr) => {
      return `${substr[0]}5`;
    });
  }
});

// ../engine-core/dist/common/errors/utils/normalizeLogs.js
var require_normalizeLogs = __commonJS2((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    normalizeLogs: () => normalizeLogs
  });
  function normalizeLogs(logs) {
    return logs.split("\n").map((l) => {
      return l.replace(/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)\s*/, "").replace(/\+\d+\s*ms$/, "");
    }).join("\n");
  }
});

// ../engine-core/dist/common/errors/utils/getErrorMessageWithLink.js
var require_getErrorMessageWithLink = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    getErrorMessageWithLink: () => getErrorMessageWithLink
  });
  var import_debug3 = __toModule3(require_dist7());
  var import_util3 = __toModule3(require_util5());
  var import_strip_ansi = __toModule3(require_strip_ansi());
  var import_maskQuery = __toModule3(require_maskQuery());
  var import_normalizeLogs = __toModule3(require_normalizeLogs());
  function getErrorMessageWithLink({
    version,
    platform,
    title,
    description,
    engineVersion,
    database,
    query
  }) {
    var _a, _b;
    const gotLogs = (0, import_debug3.getLogs)(6e3 - ((_a = query == null ? void 0 : query.length) != null ? _a : 0));
    const logs = (0, import_normalizeLogs.normalizeLogs)((0, import_strip_ansi.default)(gotLogs));
    const moreInfo = description ? `# Description
\`\`\`
${description}
\`\`\`` : "";
    const body = (0, import_strip_ansi.default)(`Hi Prisma Team! My Prisma Client just crashed. This is the report:
## Versions

| Name            | Version            |
|-----------------|--------------------|
| Node            | ${(_b = process.version) == null ? void 0 : _b.padEnd(19)}| 
| OS              | ${platform == null ? void 0 : platform.padEnd(19)}|
| Prisma Client   | ${version == null ? void 0 : version.padEnd(19)}|
| Query Engine    | ${engineVersion == null ? void 0 : engineVersion.padEnd(19)}|
| Database        | ${database == null ? void 0 : database.padEnd(19)}|

${moreInfo}

## Logs
\`\`\`
${logs}
\`\`\`

## Client Snippet
\`\`\`ts
// PLEASE FILL YOUR CODE SNIPPET HERE
\`\`\`

## Schema
\`\`\`prisma
// PLEASE ADD YOUR SCHEMA HERE IF POSSIBLE
\`\`\`

## Prisma Engine Query
\`\`\`
${query ? (0, import_maskQuery.maskQuery)(query) : ""}
\`\`\`
`);
    const url = (0, import_util3.getGithubIssueUrl)({title, body});
    return `${title}

This is a non-recoverable error which probably happens when the Prisma Query Engine has a panic.

${(0, import_util3.link)(url)}

If you want the Prisma team to look into it, please open the link above \u{1F64F}
To increase the chance of success, please post your schema and a snippet of
how you used Prisma Client in the issue. 
`;
  }
});

// ../engine-core/dist/common/utils/printGeneratorConfig.js
var require_printGeneratorConfig = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    GeneratorConfigClass: () => GeneratorConfigClass,
    getOriginalBinaryTargetsValue: () => getOriginalBinaryTargetsValue2,
    printDatamodelObject: () => printDatamodelObject,
    printGeneratorConfig: () => printGeneratorConfig2
  });
  var import_indent_string14 = __toModule3(require_indent_string2());
  function printGeneratorConfig2(config2) {
    return String(new GeneratorConfigClass(config2));
  }
  var GeneratorConfigClass = class {
    constructor(config2) {
      this.config = config2;
    }
    toString() {
      const {config: config2} = this;
      const provider = config2.provider.fromEnvVar ? `env("${config2.provider.fromEnvVar}")` : config2.provider.value;
      const obj = JSON.parse(JSON.stringify({
        provider,
        binaryTargets: getOriginalBinaryTargetsValue2(config2.binaryTargets)
      }));
      return `generator ${config2.name} {
${(0, import_indent_string14.default)(printDatamodelObject(obj), 2)}
}`;
    }
  };
  function getOriginalBinaryTargetsValue2(binaryTargets) {
    let value;
    if (binaryTargets.length > 0) {
      const binaryTargetsFromEnvVar = binaryTargets.find((object) => object.fromEnvVar !== null);
      if (binaryTargetsFromEnvVar) {
        value = `env("${binaryTargetsFromEnvVar.fromEnvVar}")`;
      } else {
        value = binaryTargets.map((object) => object.value);
      }
    } else {
      value = void 0;
    }
    return value;
  }
  function printDatamodelObject(obj) {
    const maxLength = Object.keys(obj).reduce((max2, curr) => Math.max(max2, curr.length), 0);
    return Object.entries(obj).map(([key, value]) => `${key.padEnd(maxLength)} = ${niceStringify(value)}`).join("\n");
  }
  function niceStringify(value) {
    return JSON.parse(JSON.stringify(value, (_2, value2) => {
      if (Array.isArray(value2)) {
        return `[${value2.map((element) => JSON.stringify(element)).join(", ")}]`;
      }
      return JSON.stringify(value2);
    }));
  }
});

// ../engine-core/dist/library/LibraryEngine.js
var require_LibraryEngine = __commonJS2((exports, module) => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name in all)
      __defProp(target, name, {get: all[name], enumerable: true});
  };
  var __reExport = (target, module2, desc) => {
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
      for (let key of __getOwnPropNames(module2))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule = (module2) => {
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
  };
  __export(exports, {
    LibraryEngine: () => LibraryEngine
  });
  var import_debug = __toModule(require_dist7());
  var import_engines = __toModule(require_dist16());
  var import_get_platform = __toModule(require_dist11());
  var import_chalk = __toModule(require_source2());
  var import_events = __toModule(require("events"));
  var import_fs = __toModule(require("fs"));
  var import_path = __toModule(require("path"));
  var import_Engine = __toModule(require_Engine());
  var import_PrismaClientKnownRequestError = __toModule(require_PrismaClientKnownRequestError());
  var import_PrismaClientInitializationError = __toModule(require_PrismaClientInitializationError());
  var import_PrismaClientRustPanicError = __toModule(require_PrismaClientRustPanicError());
  var import_PrismaClientUnknownRequestError = __toModule(require_PrismaClientUnknownRequestError());
  var import_getErrorMessageWithLink = __toModule(require_getErrorMessageWithLink());
  var import_printGeneratorConfig = __toModule(require_printGeneratorConfig());
  var import_util = __toModule(require_util5());
  var debug = (0, import_debug.default)("prisma:client:libraryEngine");
  function isQueryEvent(event) {
    return event["item_type"] === "query" && "query" in event;
  }
  function isPanicEvent(event) {
    return event.level === "error" && event["message"] === "PANIC";
  }
  var knownPlatforms = [...import_get_platform.platforms, "native"];
  var engines = [];
  var LibraryEngine = class extends import_Engine.Engine {
    constructor(config2) {
      super();
      var _a, _b;
      this.datamodel = import_fs.default.readFileSync(config2.datamodelPath, "utf-8");
      this.config = config2;
      this.libraryStarted = false;
      this.logQueries = (_a = config2.logQueries) != null ? _a : false;
      this.logLevel = (_b = config2.logLevel) != null ? _b : "error";
      this.logEmitter = new import_events.default();
      this.logEmitter.on("error", (e) => {
      });
      this.datasourceOverrides = config2.datasources ? this.convertDatasources(config2.datasources) : {};
      if (config2.enableEngineDebugMode) {
        this.logLevel = "debug";
      }
      this.libraryInstantiationPromise = this.instantiateLibrary();
      initHooks();
      engines.push(this);
      this.checkForTooManyEngines();
    }
    checkForTooManyEngines() {
      if (engines.length >= 10) {
        const runningEngines = engines.filter((e) => e.engine);
        if (runningEngines.length === 10) {
          console.warn(`${import_chalk.default.yellow("warn(prisma-client)")} Already 10 Prisma Clients are actively running.`);
        }
      }
    }
    async transaction(action, arg2) {
      var _a, _b, _c, _d, _e;
      await this.start();
      if (action === "start") {
        const jsonOptions = JSON.stringify({
          max_wait: (_a = arg2 == null ? void 0 : arg2.maxWait) != null ? _a : 2e3,
          timeout: (_b = arg2 == null ? void 0 : arg2.timeout) != null ? _b : 5e3
        });
        const result = await ((_c = this.engine) == null ? void 0 : _c.startTransaction(jsonOptions, "{}"));
        return this.parseEngineResponse(result);
      } else if (action === "commit") {
        await ((_d = this.engine) == null ? void 0 : _d.commitTransaction(arg2.id, "{}"));
      } else if (action === "rollback") {
        await ((_e = this.engine) == null ? void 0 : _e.rollbackTransaction(arg2.id, "{}"));
      }
      return void 0;
    }
    async instantiateLibrary() {
      debug("internalSetup");
      if (this.libraryInstantiationPromise) {
        return this.libraryInstantiationPromise;
      }
      await (0, import_get_platform.isNodeAPISupported)();
      this.platform = await this.getPlatform();
      await this.loadEngine();
      this.version();
    }
    async getPlatform() {
      if (this.platform)
        return this.platform;
      const platform = await (0, import_get_platform.getPlatform)();
      if (!knownPlatforms.includes(platform)) {
        throw new import_PrismaClientInitializationError.PrismaClientInitializationError(`Unknown ${import_chalk.default.red("PRISMA_QUERY_ENGINE_LIBRARY")} ${import_chalk.default.redBright.bold(this.platform)}. Possible binaryTargets: ${import_chalk.default.greenBright(knownPlatforms.join(", "))} or a path to the query engine library.
You may have to run ${import_chalk.default.greenBright("prisma generate")} for your changes to take effect.`, this.config.clientVersion);
      }
      return platform;
    }
    parseEngineResponse(response) {
      if (!response) {
        throw new import_PrismaClientUnknownRequestError.PrismaClientUnknownRequestError(`Response from the Engine was empty`, this.config.clientVersion);
      }
      try {
        const config2 = JSON.parse(response);
        return config2;
      } catch (err) {
        throw new import_PrismaClientUnknownRequestError.PrismaClientUnknownRequestError(`Unable to JSON.parse response from engine`, this.config.clientVersion);
      }
    }
    convertDatasources(datasources) {
      const obj = Object.create(null);
      for (const {name, url} of datasources) {
        obj[name] = url;
      }
      return obj;
    }
    async loadEngine() {
      var _a;
      if (!this.libQueryEnginePath) {
        this.libQueryEnginePath = await this.getLibQueryEnginePath();
      }
      debug(`loadEngine using ${this.libQueryEnginePath}`);
      if (!this.engine) {
        if (!this.QueryEngineConstructor) {
          try {
            this.library = eval("require")(this.libQueryEnginePath);
            this.QueryEngineConstructor = this.library.QueryEngine;
          } catch (e) {
            if (import_fs.default.existsSync(this.libQueryEnginePath)) {
              if (this.libQueryEnginePath.endsWith(".node")) {
                throw new import_PrismaClientInitializationError.PrismaClientInitializationError(`Unable to load Node-API Library from ${import_chalk.default.dim(this.libQueryEnginePath)}, Library may be corrupt`, this.config.clientVersion);
              } else {
                throw new import_PrismaClientInitializationError.PrismaClientInitializationError(`Expected an Node-API Library but received ${import_chalk.default.dim(this.libQueryEnginePath)}`, this.config.clientVersion);
              }
            } else {
              throw new import_PrismaClientInitializationError.PrismaClientInitializationError(`Unable to load Node-API Library from ${import_chalk.default.dim(this.libQueryEnginePath)}, It does not exist`, this.config.clientVersion);
            }
          }
        }
        if (this.QueryEngineConstructor) {
          try {
            this.engine = new this.QueryEngineConstructor({
              datamodel: this.datamodel,
              env: process.env,
              logQueries: (_a = this.config.logQueries) != null ? _a : false,
              ignoreEnvVarErrors: false,
              datasourceOverrides: this.datasourceOverrides,
              logLevel: this.logLevel,
              configDir: this.config.cwd
            }, (err, log3) => this.logger(err, log3));
          } catch (e) {
            const error = this.parseInitError(e.message);
            if (typeof error === "string") {
              throw e;
            } else {
              throw new import_PrismaClientInitializationError.PrismaClientInitializationError(error.message, this.config.clientVersion, error.error_code);
            }
          }
        }
      }
    }
    logger(err, log3) {
      var _a;
      if (err) {
        throw err;
      }
      const event = this.parseEngineResponse(log3);
      if (!event)
        return;
      event.level = (_a = event == null ? void 0 : event.level.toLowerCase()) != null ? _a : "unknown";
      if (isQueryEvent(event)) {
        this.logEmitter.emit("query", {
          timestamp: Date.now(),
          query: event.query,
          params: event.params,
          duration: event.duration_ms,
          target: event.module_path
        });
      } else if (isPanicEvent(event)) {
        this.loggerRustPanic = new import_PrismaClientRustPanicError.PrismaClientRustPanicError(this.getErrorMessageWithLink(`${event.message}: ${event.reason} in ${event.file}:${event.line}:${event.column}`), this.config.clientVersion);
        this.logEmitter.emit("error", this.loggerRustPanic);
      } else {
        this.logEmitter.emit(event.level, event);
      }
    }
    getErrorMessageWithLink(title) {
      var _a;
      return (0, import_getErrorMessageWithLink.getErrorMessageWithLink)({
        platform: this.platform,
        title,
        version: this.config.clientVersion,
        engineVersion: (_a = this.versionInfo) == null ? void 0 : _a.version,
        database: this.config.activeProvider,
        query: this.lastQuery
      });
    }
    parseInitError(str) {
      try {
        const error = JSON.parse(str);
        if (typeof error.is_panic !== "undefined") {
          return error;
        }
      } catch (e) {
      }
      return str;
    }
    parseRequestError(str) {
      try {
        const error = JSON.parse(str);
        if (typeof error.is_panic !== "undefined") {
          return error;
        }
      } catch (e) {
      }
      return str;
    }
    on(event, listener) {
      if (event === "beforeExit") {
        this.beforeExitListener = listener;
      } else {
        this.logEmitter.on(event, listener);
      }
    }
    async runBeforeExit() {
      debug("runBeforeExit");
      if (this.beforeExitListener) {
        try {
          await this.beforeExitListener();
        } catch (e) {
          console.error(e);
        }
      }
    }
    async start() {
      await this.libraryInstantiationPromise;
      await this.libraryStoppingPromise;
      if (this.libraryStartingPromise) {
        debug(`library already starting, this.libraryStarted: ${this.libraryStarted}`);
        await this.libraryStartingPromise;
        if (this.libraryStarted) {
          return;
        }
      }
      if (!this.libraryStarted) {
        this.libraryStartingPromise = new Promise(async (res) => {
          var _a;
          debug("library starting");
          await ((_a = this.engine) == null ? void 0 : _a.connect({enableRawQueries: true}));
          this.libraryStarted = true;
          debug("library started");
          res();
        });
        return this.libraryStartingPromise;
      }
    }
    async stop() {
      await this.libraryStartingPromise;
      await this.executingQueryPromise;
      debug(`library stopping, this.libraryStarted: ${this.libraryStarted}`);
      if (this.libraryStoppingPromise) {
        debug("library is already disconnecting");
        await this.libraryStoppingPromise;
        if (!this.libraryStarted) {
          this.libraryStoppingPromise = void 0;
          return;
        }
      }
      if (this.libraryStarted) {
        this.libraryStoppingPromise = new Promise(async (res) => {
          var _a;
          await new Promise((r) => setTimeout(r, 5));
          debug("library stopping");
          await ((_a = this.engine) == null ? void 0 : _a.disconnect());
          this.libraryStarted = false;
          debug("library stopped");
          res();
        });
      }
      return this.libraryStoppingPromise;
    }
    getConfig() {
      return this.library.getConfig({
        datamodel: this.datamodel,
        datasourceOverrides: this.datasourceOverrides,
        ignoreEnvVarErrors: true,
        env: process.env
      });
    }
    version() {
      var _a, _b, _c;
      this.versionInfo = (_a = this.library) == null ? void 0 : _a.version();
      return (_c = (_b = this.versionInfo) == null ? void 0 : _b.version) != null ? _c : "unknown";
    }
    prismaGraphQLToJSError(error) {
      debug("graphQLToJSError");
      if (error.user_facing_error.error_code) {
        return new import_PrismaClientKnownRequestError.PrismaClientKnownRequestError(error.user_facing_error.message, error.user_facing_error.error_code, this.config.clientVersion, error.user_facing_error.meta);
      }
      return new import_PrismaClientUnknownRequestError.PrismaClientUnknownRequestError(error.error, this.config.clientVersion);
    }
    async request(query, headers = {}, numTry = 1) {
      var _a;
      try {
        debug(`sending request, this.libraryStarted: ${this.libraryStarted}`);
        const request = {query, variables: {}};
        const queryStr = JSON.stringify(request);
        const headerStr = JSON.stringify(headers);
        await this.start();
        this.executingQueryPromise = (_a = this.engine) == null ? void 0 : _a.query(queryStr, headerStr, headers.transactionId);
        this.lastQuery = queryStr;
        const data = this.parseEngineResponse(await this.executingQueryPromise);
        if (data.errors) {
          if (data.errors.length === 1) {
            throw this.prismaGraphQLToJSError(data.errors[0]);
          }
          throw new import_PrismaClientUnknownRequestError.PrismaClientUnknownRequestError(JSON.stringify(data.errors), this.config.clientVersion);
        } else if (this.loggerRustPanic) {
          throw this.loggerRustPanic;
        }
        return {data, elapsed: 0};
      } catch (e) {
        const error = this.parseRequestError(e.message);
        if (typeof error === "string") {
          throw e;
        } else {
          throw new import_PrismaClientUnknownRequestError.PrismaClientUnknownRequestError(`${error.message}
${error.backtrace}`, this.config.clientVersion);
        }
      }
    }
    async requestBatch(queries, headers = {}, transaction = false, numTry = 1) {
      debug("requestBatch");
      const request = {
        batch: queries.map((query) => ({query, variables: {}})),
        transaction
      };
      await this.start();
      this.lastQuery = JSON.stringify(request);
      this.executingQueryPromise = this.engine.query(this.lastQuery, JSON.stringify(headers), headers.transactionId);
      const result = await this.executingQueryPromise;
      const data = this.parseEngineResponse(result);
      if (data.errors) {
        if (data.errors.length === 1) {
          throw this.prismaGraphQLToJSError(data.errors[0]);
        }
        throw new import_PrismaClientUnknownRequestError.PrismaClientUnknownRequestError(JSON.stringify(data.errors), this.config.clientVersion);
      }
      const {batchResult, errors} = data;
      if (Array.isArray(batchResult)) {
        return batchResult.map((result2) => {
          var _a;
          if (result2.errors) {
            return (_a = this.loggerRustPanic) != null ? _a : this.prismaGraphQLToJSError(result2.errors[0]);
          }
          return {
            data: result2,
            elapsed: 0
          };
        });
      } else {
        if (errors && errors.length === 1) {
          throw new Error(errors[0].error);
        }
        throw new Error(JSON.stringify(data));
      }
    }
    async resolveEnginePath() {
      var _a, _b, _c, _d;
      const searchedLocations = [];
      let enginePath;
      if (this.libQueryEnginePath) {
        return {enginePath: this.libQueryEnginePath, searchedLocations};
      }
      this.platform = (_a = this.platform) != null ? _a : await (0, import_get_platform.getPlatform)();
      if (__filename.includes("LibraryEngine")) {
        enginePath = import_path.default.join((0, import_engines.getEnginesPath)(), (0, import_get_platform.getNodeAPIName)(this.platform, "fs"));
        return {enginePath, searchedLocations};
      }
      const searchLocations = [
        eval(`require('path').join(__dirname, '../../../.prisma/client')`),
        (_d = (_c = (_b = this.config.generator) == null ? void 0 : _b.output) == null ? void 0 : _c.value) != null ? _d : eval("__dirname"),
        import_path.default.join(eval("__dirname"), ".."),
        import_path.default.dirname(this.config.datamodelPath),
        this.config.cwd,
        "/tmp/prisma-engines"
      ];
      if (this.config.dirname) {
        searchLocations.push(this.config.dirname);
      }
      for (const location of searchLocations) {
        searchedLocations.push(location);
        debug(`Search for Query Engine Library in ${location}`);
        enginePath = import_path.default.join(location, (0, import_get_platform.getNodeAPIName)(this.platform, "fs"));
        if (import_fs.default.existsSync(enginePath)) {
          return {enginePath, searchedLocations};
        }
      }
      enginePath = import_path.default.join(__dirname, (0, import_get_platform.getNodeAPIName)(this.platform, "fs"));
      return {enginePath: enginePath != null ? enginePath : "", searchedLocations};
    }
    async getLibQueryEnginePath() {
      var _a, _b, _c, _d;
      const libPath = (_a = process.env.PRISMA_QUERY_ENGINE_LIBRARY) != null ? _a : this.config.prismaPath;
      if (libPath && import_fs.default.existsSync(libPath) && libPath.endsWith(".node")) {
        return libPath;
      }
      this.platform = (_b = this.platform) != null ? _b : await (0, import_get_platform.getPlatform)();
      const {enginePath, searchedLocations} = await this.resolveEnginePath();
      if (!import_fs.default.existsSync(enginePath)) {
        const incorrectPinnedPlatformErrorStr = this.platform ? `
You incorrectly pinned it to ${import_chalk.default.redBright.bold(`${this.platform}`)}
` : "";
        let errorText = `Query engine library for current platform "${import_chalk.default.bold(this.platform)}" could not be found.${incorrectPinnedPlatformErrorStr}
This probably happens, because you built Prisma Client on a different platform.
(Prisma Client looked in "${import_chalk.default.underline(enginePath)}")

Searched Locations:

${searchedLocations.map((f) => {
          let msg = `  ${f}`;
          if (process.env.DEBUG === "node-engine-search-locations" && import_fs.default.existsSync(f)) {
            const dir = import_fs.default.readdirSync(f);
            msg += dir.map((d2) => `    ${d2}`).join("\n");
          }
          return msg;
        }).join("\n" + (process.env.DEBUG === "node-engine-search-locations" ? "\n" : ""))}
`;
        if (this.config.generator) {
          this.platform = (_c = this.platform) != null ? _c : await (0, import_get_platform.getPlatform)();
          if (this.config.generator.binaryTargets.find((object) => object.value === this.platform) || this.config.generator.binaryTargets.find((object) => object.value === "native")) {
            errorText += `
You already added the platform${this.config.generator.binaryTargets.length > 1 ? "s" : ""} ${this.config.generator.binaryTargets.map((t) => `"${import_chalk.default.bold(t.value)}"`).join(", ")} to the "${import_chalk.default.underline("generator")}" block
in the "schema.prisma" file as described in https://pris.ly/d/client-generator,
but something went wrong. That's suboptimal.

Please create an issue at https://github.com/prisma/prisma/issues/new`;
            errorText += ``;
          } else {
            errorText += `

To solve this problem, add the platform "${this.platform}" to the "${import_chalk.default.underline("binaryTargets")}" attribute in the "${import_chalk.default.underline("generator")}" block in the "schema.prisma" file:
${import_chalk.default.greenBright(this.getFixedGenerator())}

Then run "${import_chalk.default.greenBright("prisma generate")}" for your changes to take effect.
Read more about deploying Prisma Client: https://pris.ly/d/client-generator`;
          }
        } else {
          errorText += `

Read more about deploying Prisma Client: https://pris.ly/d/client-generator
`;
        }
        throw new import_PrismaClientInitializationError.PrismaClientInitializationError(errorText, this.config.clientVersion);
      }
      this.platform = (_d = this.platform) != null ? _d : await (0, import_get_platform.getPlatform)();
      return enginePath;
    }
    getFixedGenerator() {
      const fixedGenerator = {
        ...this.config.generator,
        binaryTargets: (0, import_util.fixBinaryTargets)(this.config.generator.binaryTargets, this.platform)
      };
      return (0, import_printGeneratorConfig.printGeneratorConfig)(fixedGenerator);
    }
  };
  function hookProcess(handler, exit = false) {
    process.once(handler, async () => {
      debug(`hookProcess received: ${handler}`);
      for (const engine of engines) {
        await engine.runBeforeExit();
      }
      engines.splice(0, engines.length);
      if (exit && process.listenerCount(handler) === 0) {
        process.exit();
      }
    });
  }
  var hooksInitialized = false;
  function initHooks() {
    if (!hooksInitialized) {
      hookProcess("beforeExit");
      hookProcess("exit");
      hookProcess("SIGINT", true);
      hookProcess("SIGUSR1", true);
      hookProcess("SIGUSR2", true);
      hookProcess("SIGTERM", true);
      hooksInitialized = true;
    }
  }
});

// ../engine-core/dist/tools/byline.js
var require_byline2 = __commonJS2((exports2, module2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    createLineStream: () => createLineStream,
    default: () => byline
  });
  var stream = require("stream");
  var util2 = require("util");
  function byline(readStream, options) {
    return module2.exports.createStream(readStream, options);
  }
  module2.exports.createStream = function(readStream, options) {
    if (readStream) {
      return createLineStream(readStream, options);
    } else {
      return new LineStream(options);
    }
  };
  function createLineStream(readStream, options) {
    if (!readStream) {
      throw new Error("expected readStream");
    }
    if (!readStream.readable) {
      throw new Error("readStream must be readable");
    }
    const ls = new LineStream(options);
    readStream.pipe(ls);
    return ls;
  }
  module2.exports.LineStream = LineStream;
  function LineStream(options) {
    stream.Transform.call(this, options);
    options = options || {};
    this._readableState.objectMode = true;
    this._lineBuffer = [];
    this._keepEmptyLines = options.keepEmptyLines || false;
    this._lastChunkEndedWithCR = false;
    this.on("pipe", function(src) {
      if (!this.encoding) {
        if (src instanceof stream.Readable) {
          this.encoding = src._readableState.encoding;
        }
      }
    });
  }
  util2.inherits(LineStream, stream.Transform);
  LineStream.prototype._transform = function(chunk, encoding, done) {
    encoding = encoding || "utf8";
    if (Buffer.isBuffer(chunk)) {
      if (encoding == "buffer") {
        chunk = chunk.toString();
        encoding = "utf8";
      } else {
        chunk = chunk.toString(encoding);
      }
    }
    this._chunkEncoding = encoding;
    const lines = chunk.split(/\r\n|\r|\n/g);
    if (this._lastChunkEndedWithCR && chunk[0] == "\n") {
      lines.shift();
    }
    if (this._lineBuffer.length > 0) {
      this._lineBuffer[this._lineBuffer.length - 1] += lines[0];
      lines.shift();
    }
    this._lastChunkEndedWithCR = chunk[chunk.length - 1] == "\r";
    this._lineBuffer = this._lineBuffer.concat(lines);
    this._pushBuffer(encoding, 1, done);
  };
  LineStream.prototype._pushBuffer = function(encoding, keep, done) {
    while (this._lineBuffer.length > keep) {
      const line = this._lineBuffer.shift();
      if (this._keepEmptyLines || line.length > 0) {
        if (!this.push(this._reencode(line, encoding))) {
          const self2 = this;
          setImmediate(function() {
            self2._pushBuffer(encoding, keep, done);
          });
          return;
        }
      }
    }
    done();
  };
  LineStream.prototype._flush = function(done) {
    this._pushBuffer(this._chunkEncoding, 0, done);
  };
  LineStream.prototype._reencode = function(line, chunkEncoding) {
    if (this.encoding && this.encoding != chunkEncoding) {
      return Buffer.from(line, chunkEncoding).toString(this.encoding);
    } else if (this.encoding) {
      return line;
    } else {
      return Buffer.from(line, chunkEncoding);
    }
  };
});

// ../engine-core/dist/common/errors/utils/log.js
var require_log3 = __commonJS2((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    convertLog: () => convertLog,
    getBacktraceFromLog: () => getBacktraceFromLog,
    getBacktraceFromRustError: () => getBacktraceFromRustError,
    getMessage: () => getMessage,
    isRustError: () => isRustError,
    isRustErrorLog: () => isRustErrorLog,
    isRustLog: () => isRustLog
  });
  function getMessage(log3) {
    if (typeof log3 === "string") {
      return log3;
    } else if (isRustError(log3)) {
      return getBacktraceFromRustError(log3);
    } else if (isRustLog(log3)) {
      return getBacktraceFromLog(log3);
    }
    return JSON.stringify(log3);
  }
  function getBacktraceFromLog(log3) {
    var _a, _b, _c, _d, _e, _f, _g;
    if ((_a = log3.fields) == null ? void 0 : _a.message) {
      let str = (_b = log3.fields) == null ? void 0 : _b.message;
      if ((_c = log3.fields) == null ? void 0 : _c.file) {
        str += ` in ${log3.fields.file}`;
        if ((_d = log3.fields) == null ? void 0 : _d.line) {
          str += `:${log3.fields.line}`;
        }
        if ((_e = log3.fields) == null ? void 0 : _e.column) {
          str += `:${log3.fields.column}`;
        }
      }
      if ((_f = log3.fields) == null ? void 0 : _f.reason) {
        str += `
${(_g = log3.fields) == null ? void 0 : _g.reason}`;
      }
      return str;
    }
    return "Unknown error";
  }
  function getBacktraceFromRustError(err) {
    let str = "";
    if (err.is_panic) {
      str += `PANIC`;
    }
    if (err.backtrace) {
      str += ` in ${err.backtrace}`;
    }
    if (err.message) {
      str += `
${err.message}`;
    }
    return str;
  }
  function isRustLog(e) {
    return e.timestamp && typeof e.level === "string" && typeof e.target === "string";
  }
  function isRustErrorLog(e) {
    var _a, _b;
    return isRustLog(e) && (e.level === "error" || ((_b = (_a = e.fields) == null ? void 0 : _a.message) == null ? void 0 : _b.includes("fatal error")));
  }
  function isRustError(e) {
    return typeof e.is_panic !== "undefined";
  }
  function convertLog(rustLog) {
    const isQuery = isQueryLog(rustLog.fields);
    const level = isQuery ? "query" : rustLog.level.toLowerCase();
    return {
      ...rustLog,
      level,
      timestamp: new Date(new Date().getFullYear() + " " + rustLog.timestamp)
    };
  }
  function isQueryLog(fields) {
    return Boolean(fields.query);
  }
});

// ../engine-core/dist/common/errors/PrismaClientRustError.js
var require_PrismaClientRustError = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    PrismaClientRustError: () => PrismaClientRustError
  });
  var import_log2 = __toModule3(require_log3());
  var PrismaClientRustError = class extends Error {
    constructor({clientVersion: clientVersion2, log: log3, error}) {
      if (log3) {
        const backtrace = (0, import_log2.getBacktraceFromLog)(log3);
        super(backtrace != null ? backtrace : "Unkown error");
      } else if (error) {
        const backtrace = (0, import_log2.getBacktraceFromRustError)(error);
        super(backtrace);
      } else {
        super(`Unknown error`);
      }
      this.clientVersion = clientVersion2;
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientRustPanicError";
    }
  };
});

// ../engine-core/dist/tools/omit.js
var require_omit = __commonJS2((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    omit: () => omit
  });
  function omit(obj, keys) {
    return Object.keys(obj).filter((key) => !keys.includes(key)).reduce((result, key) => {
      result[key] = obj[key];
      return result;
    }, {});
  }
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/node/http-parser.js
var require_http_parser = __commonJS2((exports2, module2) => {
  "use strict";
  var common = require("_http_common");
  if (common.HTTPParser) {
    module2.exports = common.HTTPParser;
  } else {
    module2.exports = process.binding("http_parser").HTTPParser;
  }
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/core/symbols.js
var require_symbols = __commonJS2((exports2, module2) => {
  module2.exports = {
    kUrl: Symbol("url"),
    kWriting: Symbol("writing"),
    kResuming: Symbol("resuming"),
    kQueue: Symbol("queue"),
    kConnect: Symbol("connect"),
    kIdleTimeout: Symbol("idle timeout"),
    kIdleTimeoutValue: Symbol("idle timeout value"),
    kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
    kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
    kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
    kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
    kKeepAlive: Symbol("keep alive"),
    kHeadersTimeout: Symbol("headers timeout"),
    kBodyTimeout: Symbol("body timeout"),
    kTLSServerName: Symbol("server name"),
    kHost: Symbol("host"),
    kTLSOpts: Symbol("TLS Options"),
    kClosed: Symbol("closed"),
    kNeedDrain: Symbol("need drain"),
    kReset: Symbol("reset"),
    kDestroyed: Symbol("destroyed"),
    kMaxHeadersSize: Symbol("max headers size"),
    kRunningIdx: Symbol("running index"),
    kPendingIdx: Symbol("pending index"),
    kError: Symbol("error"),
    kClient: Symbol("client"),
    kParser: Symbol("parser"),
    kOnDestroyed: Symbol("destroy callbacks"),
    kPipelining: Symbol("pipelinig"),
    kSocketPath: Symbol("socket path"),
    kSocket: Symbol("socket"),
    kTLSSession: Symbol("tls session cache"),
    kHostHeader: Symbol("host header"),
    kAgentOpts: Symbol("agent opts"),
    kAgentCache: Symbol("agent cache")
  };
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/core/errors.js
var require_errors = __commonJS2((exports2, module2) => {
  "use strict";
  var UndiciError = class extends Error {
    constructor(message) {
      super(message);
      this.name = "UndiciError";
      this.code = "UND_ERR";
    }
  };
  var HeadersTimeoutError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, HeadersTimeoutError);
      this.name = "HeadersTimeoutError";
      this.message = message || "Headers Timeout Error";
      this.code = "UND_ERR_HEADERS_TIMEOUT";
    }
  };
  var BodyTimeoutError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, BodyTimeoutError);
      this.name = "BodyTimeoutError";
      this.message = message || "Body Timeout Error";
      this.code = "UND_ERR_BODY_TIMEOUT";
    }
  };
  var InvalidArgumentError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, InvalidArgumentError);
      this.name = "InvalidArgumentError";
      this.message = message || "Invalid Argument Error";
      this.code = "UND_ERR_INVALID_ARG";
    }
  };
  var InvalidReturnValueError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, InvalidReturnValueError);
      this.name = "InvalidReturnValueError";
      this.message = message || "Invalid Return Value Error";
      this.code = "UND_ERR_INVALID_RETURN_VALUE";
    }
  };
  var RequestAbortedError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, RequestAbortedError);
      this.name = "RequestAbortedError";
      this.message = message || "Request aborted";
      this.code = "UND_ERR_ABORTED";
    }
  };
  var InformationalError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, InformationalError);
      this.name = "InformationalError";
      this.message = message || "Request information";
      this.code = "UND_ERR_INFO";
    }
  };
  var ContentLengthMismatchError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ContentLengthMismatchError);
      this.name = "ContentLengthMismatchError";
      this.message = message || "Request body length does not match content-length header";
      this.code = "UND_ERR_CONTENT_LENGTH_MISMATCH";
    }
  };
  var TrailerMismatchError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, TrailerMismatchError);
      this.name = "TrailerMismatchError";
      this.message = message || "Trailers does not match trailer header";
      this.code = "UND_ERR_TRAILER_MISMATCH";
    }
  };
  var ClientDestroyedError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ClientDestroyedError);
      this.name = "ClientDestroyedError";
      this.message = message || "The client is destroyed";
      this.code = "UND_ERR_DESTROYED";
    }
  };
  var ClientClosedError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ClientClosedError);
      this.name = "ClientClosedError";
      this.message = message || "The client is closed";
      this.code = "UND_ERR_CLOSED";
    }
  };
  var SocketError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, SocketError);
      this.name = "SocketError";
      this.message = message || "Socket error";
      this.code = "UND_ERR_SOCKET";
    }
  };
  var NotSupportedError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, NotSupportedError);
      this.name = "NotSupportedError";
      this.message = message || "Not supported error";
      this.code = "UND_ERR_NOT_SUPPORTED";
    }
  };
  module2.exports = {
    UndiciError,
    HeadersTimeoutError,
    BodyTimeoutError,
    ContentLengthMismatchError,
    TrailerMismatchError,
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError,
    ClientDestroyedError,
    ClientClosedError,
    InformationalError,
    SocketError,
    NotSupportedError
  };
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/core/util.js
var require_util6 = __commonJS2((exports2, module2) => {
  "use strict";
  var assert = require("assert");
  var {kDestroyed} = require_symbols();
  var {IncomingMessage} = require("http");
  var util2 = require("util");
  var net = require("net");
  var {InvalidArgumentError} = require_errors();
  function nop() {
  }
  function isStream(body) {
    return !!(body && typeof body.on === "function");
  }
  function parseURL(url) {
    if (typeof url === "string") {
      url = new URL(url);
    }
    if (!url || typeof url !== "object") {
      throw new InvalidArgumentError("invalid url");
    }
    if (url.port != null && url.port !== "" && !Number.isFinite(parseInt(url.port))) {
      throw new InvalidArgumentError("invalid port");
    }
    if (url.hostname != null && typeof url.hostname !== "string") {
      throw new InvalidArgumentError("invalid hostname");
    }
    if (!/https?/.test(url.protocol)) {
      throw new InvalidArgumentError("invalid protocol");
    }
    if (!(url instanceof URL)) {
      const port = url.port || {
        "http:": 80,
        "https:": 443
      }[url.protocol];
      assert(port != null);
      const path4 = url.path || `${url.pathname || "/"}${url.search || ""}`;
      url = new URL(`${url.protocol}//${url.hostname}:${port}${path4}`);
    }
    return url;
  }
  function parseOrigin(url) {
    url = parseURL(url);
    if (/\/.+/.test(url.pathname) || url.search || url.hash) {
      throw new InvalidArgumentError("invalid url");
    }
    return url;
  }
  function getServerName(host) {
    if (!host) {
      return null;
    }
    let servername = host;
    if (servername.startsWith("[")) {
      const idx = servername.indexOf("]");
      servername = idx === -1 ? servername : servername.substr(1, idx - 1);
    } else {
      servername = servername.split(":", 1)[0];
    }
    if (net.isIP(servername)) {
      servername = null;
    }
    return servername;
  }
  function bodyLength(body) {
    if (body && typeof body.on === "function") {
      const state = body._readableState;
      return state && state.ended === true && Number.isFinite(state.length) ? state.length : null;
    }
    assert(!body || Number.isFinite(body.byteLength));
    return body ? body.length : 0;
  }
  function isDestroyed(stream) {
    return !stream || !!(stream.destroyed || stream[kDestroyed]);
  }
  function destroy(stream, err) {
    if (!isStream(stream) || isDestroyed(stream)) {
      return;
    }
    if (typeof stream.destroy === "function") {
      if (err || Object.getPrototypeOf(stream).constructor !== IncomingMessage) {
        stream.destroy(err);
      }
    } else if (err) {
      process.nextTick((stream2, err2) => {
        stream2.emit("error", err2);
      }, stream, err);
    }
    if (stream.destroyed !== true) {
      stream[kDestroyed] = true;
    }
  }
  var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
  function parseKeepAliveTimeout(val) {
    const m2 = val.match(KEEPALIVE_TIMEOUT_EXPR);
    return m2 ? parseInt(m2[1]) * 1e3 : null;
  }
  function parseHeaders(headers, obj = {}) {
    for (let i = 0; i < headers.length; i += 2) {
      const key = headers[i].toLowerCase();
      let val = obj[key];
      if (!val) {
        obj[key] = headers[i + 1];
      } else {
        if (!Array.isArray(val)) {
          val = [val];
          obj[key] = val;
        }
        val.push(headers[i + 1]);
      }
    }
    return obj;
  }
  function isBuffer(buffer) {
    return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
  }
  function errnoException(code, syscall) {
    const name = util2.getSystemErrorName(code);
    const err = new Error(`${syscall} ${name}`);
    err.errno = err;
    err.code = code;
    err.syscall = syscall;
    return err;
  }
  module2.exports = {
    nop,
    parseOrigin,
    parseURL,
    getServerName,
    errnoException,
    isStream,
    isDestroyed,
    parseHeaders,
    parseKeepAliveTimeout,
    destroy,
    bodyLength,
    isBuffer,
    queueMicrotask: global.queueMicrotask ? global.queueMicrotask.bind(global) : (cb) => Promise.resolve().then(cb).catch((err) => setTimeout(() => {
      throw err;
    }, 0))
  };
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/core/request.js
var require_request = __commonJS2((exports2, module2) => {
  "use strict";
  var {
    InvalidArgumentError,
    NotSupportedError
  } = require_errors();
  var util2 = require_util6();
  var assert = require("assert");
  var kHandler = Symbol("handler");
  var REGEXP_ABSOLUTE_URL = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\x00a1-\xffff0-9]+-?)*[a-z\x00a1-\xffff0-9]+)(?:\.(?:[a-z\x00a1-\xffff0-9]+-?)*[a-z\x00a1-\xffff0-9]+)*(?:\.(?:[a-z\x00a1-\xffff]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/ius;
  var Request = class {
    constructor({
      path: path4,
      method,
      body,
      headers,
      idempotent,
      upgrade
    }, handler) {
      if (typeof path4 !== "string") {
        throw new InvalidArgumentError("path must be a string");
      } else if (path4[0] !== "/" && !REGEXP_ABSOLUTE_URL.test(path4)) {
        throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
      }
      if (typeof method !== "string") {
        throw new InvalidArgumentError("method must be a string");
      }
      if (upgrade && typeof upgrade !== "string") {
        throw new InvalidArgumentError("upgrade must be a string");
      }
      this.method = method;
      if (body == null) {
        this.body = null;
      } else if (util2.isStream(body)) {
        this.body = body;
      } else if (util2.isBuffer(body)) {
        this.body = body.length ? body : null;
      } else if (typeof body === "string") {
        this.body = body.length ? Buffer.from(body) : null;
      } else {
        throw new InvalidArgumentError("body must be a string, a Buffer or a Readable stream");
      }
      this.aborted = false;
      this.upgrade = upgrade || method === "CONNECT" || null;
      this.path = path4;
      this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
      this.host = null;
      this.contentLength = null;
      this.headers = "";
      if (Array.isArray(headers)) {
        if (headers.length % 2 !== 0) {
          throw new InvalidArgumentError("headers array must be even");
        }
        for (let i = 0; i < headers.length; i += 2) {
          processHeader(this, headers[i + 0], headers[i + 1]);
        }
      } else if (headers && typeof headers === "object") {
        for (const [key, val] of Object.entries(headers)) {
          processHeader(this, key, val);
        }
      } else if (headers != null) {
        throw new InvalidArgumentError("headers must be an object or an array");
      }
      if (typeof handler.onConnect !== "function") {
        throw new InvalidArgumentError("invalid onConnect method");
      }
      if (typeof handler.onError !== "function") {
        throw new InvalidArgumentError("invalid onError method");
      }
      if (this.upgrade) {
        if (typeof handler.onUpgrade !== "function") {
          throw new InvalidArgumentError("invalid onUpgrade method");
        }
      } else {
        if (typeof handler.onHeaders !== "function") {
          throw new InvalidArgumentError("invalid onHeaders method");
        }
        if (typeof handler.onData !== "function") {
          throw new InvalidArgumentError("invalid onData method");
        }
        if (typeof handler.onComplete !== "function") {
          throw new InvalidArgumentError("invalid onComplete method");
        }
      }
      this[kHandler] = handler;
    }
    onConnect(abort) {
      assert(!this.aborted);
      return this[kHandler].onConnect(abort);
    }
    onHeaders(statusCode, headers, resume) {
      assert(!this.aborted);
      return this[kHandler].onHeaders(statusCode, headers, resume);
    }
    onData(chunk) {
      assert(!this.aborted);
      assert(!this.upgrade);
      return this[kHandler].onData(chunk);
    }
    onUpgrade(statusCode, headers, socket) {
      assert(!this.aborted);
      assert(this.upgrade);
      return this[kHandler].onUpgrade(statusCode, headers, socket);
    }
    onComplete(trailers) {
      assert(!this.aborted);
      assert(!this.upgrade);
      return this[kHandler].onComplete(trailers);
    }
    onError(err) {
      if (this.aborted) {
        return;
      }
      this.aborted = true;
      util2.queueMicrotask(() => this[kHandler].onError(err));
    }
  };
  function processHeader(request, key, val) {
    if (val && typeof val === "object") {
      throw new InvalidArgumentError(`invalid ${key} header`);
    } else if (val === void 0) {
      return;
    }
    if (request.host === null && key.length === 4 && key.toLowerCase() === "host") {
      request.host = val;
      request.headers += `${key}: ${val}\r
`;
    } else if (request.contentLength === null && key.length === 14 && key.toLowerCase() === "content-length") {
      request.contentLength = parseInt(val);
      if (!Number.isFinite(request.contentLength)) {
        throw new InvalidArgumentError("invalid content-length header");
      }
    } else if (key.length === 17 && key.toLowerCase() === "transfer-encoding") {
      throw new InvalidArgumentError("invalid transfer-encoding header");
    } else if (key.length === 10 && key.toLowerCase() === "connection") {
      throw new InvalidArgumentError("invalid connection header");
    } else if (key.length === 10 && key.toLowerCase() === "keep-alive") {
      throw new InvalidArgumentError("invalid keep-alive header");
    } else if (key.length === 7 && key.toLowerCase() === "upgrade") {
      throw new InvalidArgumentError("invalid upgrade header");
    } else if (key.length === 6 && key.toLowerCase() === "expect") {
      throw new NotSupportedError("expect header not supported");
    } else {
      request.headers += `${key}: ${val}\r
`;
    }
  }
  module2.exports = Request;
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/core/client.js
var require_client = __commonJS2((exports2, module2) => {
  "use strict";
  var net = require("net");
  var tls = require("tls");
  var HTTPParser = require_http_parser();
  var EventEmitter = require("events");
  var assert = require("assert");
  var util2 = require_util6();
  var Request = require_request();
  var {
    ContentLengthMismatchError,
    TrailerMismatchError,
    InvalidArgumentError,
    RequestAbortedError,
    HeadersTimeoutError,
    ClientDestroyedError,
    ClientClosedError,
    SocketError,
    InformationalError,
    BodyTimeoutError
  } = require_errors();
  var {
    kUrl,
    kReset,
    kHost,
    kClient,
    kParser,
    kConnect,
    kResuming,
    kWriting,
    kQueue,
    kNeedDrain,
    kTLSServerName,
    kKeepAliveDefaultTimeout,
    kHostHeader,
    kTLSOpts,
    kClosed,
    kDestroyed,
    kPendingIdx,
    kRunningIdx,
    kError,
    kOnDestroyed,
    kPipelining,
    kSocket,
    kSocketPath,
    kKeepAliveTimeoutValue,
    kMaxHeadersSize,
    kKeepAliveMaxTimeout,
    kKeepAliveTimeoutThreshold,
    kTLSSession,
    kIdleTimeout,
    kIdleTimeoutValue,
    kHeadersTimeout,
    kBodyTimeout
  } = require_symbols();
  var nodeVersions = process.version.split(".");
  var nodeMajorVersion = parseInt(nodeVersions[0].slice(1));
  var nodeMinorVersion = parseInt(nodeVersions[1]);
  var insecureHTTPParser = process.execArgv.includes("--insecure-http-parser");
  function getServerName(client, host) {
    return util2.getServerName(host) || client[kTLSOpts] && client[kTLSOpts].servername || util2.getServerName(client[kUrl].host || client[kUrl].hostname) || null;
  }
  var Client = class extends EventEmitter {
    constructor(url, {
      maxHeaderSize,
      headersTimeout,
      socketTimeout,
      requestTimeout,
      bodyTimeout,
      idleTimeout,
      keepAlive,
      keepAliveTimeout,
      maxKeepAliveTimeout,
      keepAliveMaxTimeout,
      keepAliveTimeoutThreshold,
      socketPath,
      pipelining,
      tls: tls2
    } = {}) {
      super();
      if (keepAlive !== void 0) {
        throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
      }
      if (socketTimeout !== void 0) {
        throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
      }
      if (requestTimeout !== void 0) {
        throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
      }
      if (idleTimeout !== void 0) {
        throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
      }
      if (maxKeepAliveTimeout !== void 0) {
        throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
      }
      if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
        throw new InvalidArgumentError("invalid maxHeaderSize");
      }
      if (socketPath != null && typeof socketPath !== "string") {
        throw new InvalidArgumentError("invalid socketPath");
      }
      if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
        throw new InvalidArgumentError("invalid keepAliveTimeout");
      }
      if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
        throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
      }
      if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
        throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
      }
      if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
        throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
      }
      if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
        throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
      }
      this[kSocket] = null;
      this[kPipelining] = pipelining != null ? pipelining : 1;
      this[kMaxHeadersSize] = maxHeaderSize || 16384;
      this[kUrl] = util2.parseOrigin(url);
      this[kSocketPath] = socketPath;
      this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
      this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
      this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;
      this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
      this[kClosed] = false;
      this[kDestroyed] = false;
      this[kTLSOpts] = tls2;
      this[kTLSServerName] = getServerName(this);
      this[kHost] = null;
      this[kOnDestroyed] = [];
      this[kResuming] = 0;
      this[kNeedDrain] = 0;
      this[kTLSSession] = null;
      this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r
`;
      this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e4;
      this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e4;
      this[kQueue] = [];
      this[kRunningIdx] = 0;
      this[kPendingIdx] = 0;
    }
    get url() {
      return this[kUrl];
    }
    get pipelining() {
      return this[kPipelining];
    }
    set pipelining(value) {
      this[kPipelining] = value;
      resume(this, true);
    }
    get connected() {
      return this[kSocket] && this[kSocket].connecting !== true && (this[kSocket].authorized !== false || this[kSocket].authorizationError) && !this[kSocket].destroyed;
    }
    get pending() {
      return this[kQueue].length - this[kPendingIdx];
    }
    get running() {
      return this[kPendingIdx] - this[kRunningIdx];
    }
    get size() {
      return this[kQueue].length - this[kRunningIdx];
    }
    get busy() {
      const socket = this[kSocket];
      return socket && (socket[kReset] || socket[kWriting]) || this.size >= (this[kPipelining] || 1) || this.pending > 0;
    }
    get destroyed() {
      return this[kDestroyed];
    }
    get closed() {
      return this[kClosed];
    }
    [kConnect](cb) {
      connect(this);
      this.once("connect", cb);
    }
    dispatch(opts, handler) {
      try {
        const request = new Request(opts, handler);
        if (this[kDestroyed]) {
          throw new ClientDestroyedError();
        }
        if (this[kClosed]) {
          throw new ClientClosedError();
        }
        this[kQueue].push(request);
        if (this[kResuming]) {
        } else if (util2.isStream(request.body)) {
          this[kResuming] = 1;
          process.nextTick(resume, this);
        } else {
          resume(this, true);
        }
      } catch (err) {
        if (typeof handler.onError !== "function") {
          throw new InvalidArgumentError("invalid onError method");
        }
        handler.onError(err);
      }
    }
    close(callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          this.close((err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      if (this[kDestroyed]) {
        process.nextTick(callback, new ClientDestroyedError(), null);
        return;
      }
      this[kClosed] = true;
      if (!this.size) {
        this.destroy(callback);
      } else {
        this[kOnDestroyed].push(callback);
      }
    }
    destroy(err, callback) {
      if (typeof err === "function") {
        callback = err;
        err = null;
      }
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          this.destroy(err, (err2, data) => {
            return err2 ? reject(err2) : resolve(data);
          });
        });
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      if (this[kDestroyed]) {
        if (this[kOnDestroyed]) {
          this[kOnDestroyed].push(callback);
        } else {
          process.nextTick(callback, null, null);
        }
        return;
      }
      if (!err) {
        err = new ClientDestroyedError();
      }
      for (const request of this[kQueue].splice(this[kPendingIdx])) {
        request.onError(err);
      }
      this[kClosed] = true;
      this[kDestroyed] = true;
      this[kOnDestroyed].push(callback);
      const onDestroyed = () => {
        const callbacks = this[kOnDestroyed];
        this[kOnDestroyed] = null;
        for (const callback2 of callbacks) {
          callback2(null, null);
        }
      };
      if (!this[kSocket]) {
        process.nextTick(onDestroyed);
      } else {
        util2.destroy(this[kSocket].on("close", onDestroyed), err);
      }
      resume(this);
    }
  };
  var Parser = class extends HTTPParser {
    constructor(client, socket) {
      if (nodeMajorVersion === 12 && nodeMinorVersion < 19) {
        super();
        this.initialize(HTTPParser.RESPONSE, {}, 0);
      } else if (nodeMajorVersion === 12 && nodeMinorVersion >= 19) {
        super();
        this.initialize(HTTPParser.RESPONSE, {}, client[kMaxHeadersSize], 0);
      } else if (nodeMajorVersion > 12 && nodeMajorVersion < 16) {
        super();
        this.initialize(HTTPParser.RESPONSE, {}, client[kMaxHeadersSize], insecureHTTPParser, 0);
      } else if (nodeMajorVersion >= 16) {
        super();
        this.initialize(HTTPParser.RESPONSE, {}, client[kMaxHeadersSize], 0);
      } else {
        super(HTTPParser.RESPONSE);
      }
      this.client = client;
      this.socket = socket;
      this.timeout = null;
      this.statusCode = null;
      this.upgrade = false;
      this.headers = null;
      this.shouldKeepAlive = false;
      this.request = null;
      this.paused = false;
      this.resuming = false;
      this.queue = [];
      this._resume = () => {
        if (!this.paused || this.resuming) {
          return;
        }
        this.paused = false;
        this.resuming = true;
        while (this.queue.length) {
          const [fn, ...args] = this.queue.shift();
          Reflect.apply(fn, this, args);
          if (this.paused) {
            this.resuming = false;
            return;
          }
        }
        this.resuming = false;
        socketResume(this.socket);
      };
      this._pause = () => {
        if (this.paused) {
          return;
        }
        this.paused = true;
        socketPause(this.socket);
      };
    }
    [HTTPParser.kOnHeaders](rawHeaders) {
      if (this.paused) {
        this.queue.push([this[HTTPParser.kOnHeaders], rawHeaders]);
        return;
      }
      if (this.headers) {
        Array.prototype.push.apply(this.headers, rawHeaders);
      } else {
        this.headers = rawHeaders;
      }
    }
    [HTTPParser.kOnExecute](ret) {
      if (this.paused) {
        this.queue.push([this[HTTPParser.kOnExecute], ret]);
        return;
      }
      const {upgrade, socket} = this;
      if (!Number.isFinite(ret)) {
        assert(ret instanceof Error);
        util2.destroy(socket, ret);
        return;
      }
      if (upgrade && !socket.destroyed) {
        const {client, headers, statusCode, request} = this;
        assert(!socket.destroyed);
        assert(socket === client[kSocket]);
        assert(!socket.isPaused());
        assert(socket._handle && socket._handle.reading);
        assert(request.upgrade);
        this.headers = null;
        this.statusCode = null;
        this.request = null;
        socket._readableState.flowing = null;
        socket.unshift(this.getCurrentBuffer().slice(ret));
        try {
          request.onUpgrade(statusCode, headers, socket);
          if (!socket.destroyed && !request.aborted) {
            detachSocket(socket);
            client[kSocket] = null;
            client[kQueue][client[kRunningIdx]++] = null;
            client.emit("disconnect", new InformationalError("upgrade"));
          }
          resume(client);
        } catch (err) {
          util2.destroy(socket, err);
        }
      }
    }
    [HTTPParser.kOnHeadersComplete](versionMajor, versionMinor, rawHeaders, method, url, statusCode, statusMessage, upgrade, shouldKeepAlive) {
      if (this.paused) {
        this.queue.push([
          this[HTTPParser.kOnHeadersComplete],
          versionMajor,
          versionMinor,
          rawHeaders,
          method,
          url,
          statusCode,
          statusMessage,
          upgrade,
          shouldKeepAlive
        ]);
        return;
      }
      const {client, socket} = this;
      const request = client[kQueue][client[kRunningIdx]];
      if (socket.destroyed) {
        return;
      }
      clearTimeout(this.timeout);
      this.timeout = client[kBodyTimeout] ? setTimeout(onBodyTimeout, client[kBodyTimeout], this) : null;
      assert(!this.upgrade);
      assert(this.statusCode < 200);
      if (statusCode === 100) {
        util2.destroy(socket, new SocketError("bad response"));
        return 1;
      }
      if (request.upgrade !== true && upgrade !== Boolean(request.upgrade)) {
        util2.destroy(socket, new SocketError("bad upgrade"));
        return 1;
      }
      if (this.headers) {
        Array.prototype.push.apply(this.headers, rawHeaders);
      } else {
        this.headers = rawHeaders;
      }
      this.statusCode = statusCode;
      this.shouldKeepAlive = shouldKeepAlive;
      this.request = request;
      if (request.upgrade) {
        this.unconsume();
        this.upgrade = true;
        return 2;
      }
      let keepAlive;
      let trailers;
      const {headers} = this;
      this.headers = null;
      for (let n = 0; n < headers.length; n += 2) {
        const key = headers[n + 0];
        const val = headers[n + 1];
        if (!keepAlive && key.length === 10 && key.toLowerCase() === "keep-alive") {
          keepAlive = val;
        } else if (!trailers && key.length === 7 && key.toLowerCase() === "trailer") {
          trailers = val;
        }
      }
      this.trailers = trailers ? trailers.toLowerCase().split(/,\s*/) : null;
      if (shouldKeepAlive && client[kPipelining]) {
        const keepAliveTimeout = keepAlive ? util2.parseKeepAliveTimeout(keepAlive) : null;
        if (keepAliveTimeout != null) {
          const timeout = Math.min(keepAliveTimeout - client[kKeepAliveTimeoutThreshold], client[kKeepAliveMaxTimeout]);
          if (timeout <= 0) {
            socket[kReset] = true;
          } else {
            client[kKeepAliveTimeoutValue] = timeout;
          }
        } else {
          client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
        }
      } else {
        socket[kReset] = true;
      }
      try {
        if (request.onHeaders(statusCode, headers, this._resume) === false) {
          this._pause();
        }
      } catch (err) {
        util2.destroy(socket, err);
        return 1;
      }
      return request.method === "HEAD" || statusCode < 200 ? 1 : 0;
    }
    [HTTPParser.kOnBody](chunk, offset, length) {
      if (this.paused) {
        this.queue.push([this[HTTPParser.kOnBody], chunk, offset, length]);
        return;
      }
      const {socket, statusCode, request, timeout} = this;
      if (socket.destroyed) {
        return;
      }
      if (timeout && timeout.refresh) {
        timeout.refresh();
      }
      assert(statusCode >= 200);
      try {
        if (request.onData(chunk.slice(offset, offset + length)) === false) {
          this._pause();
        }
      } catch (err) {
        util2.destroy(socket, err);
      }
    }
    [HTTPParser.kOnMessageComplete]() {
      if (this.paused) {
        this.queue.push([this[HTTPParser.kOnMessageComplete]]);
        return;
      }
      const {client, socket, statusCode, headers, upgrade, request, trailers} = this;
      if (socket.destroyed) {
        return;
      }
      assert(statusCode >= 100);
      assert(this.resuming || socket._handle && socket._handle.reading);
      if (upgrade) {
        assert(statusCode < 300 || request.method === "CONNECT");
        return;
      }
      this.statusCode = null;
      this.headers = null;
      this.request = null;
      this.trailers = null;
      clearTimeout(this.timeout);
      this.timeout = client[kHeadersTimeout] ? setTimeout(onHeadersTimeout, client[kHeadersTimeout], this) : null;
      if (statusCode < 200) {
        return;
      }
      try {
        if (trailers) {
          if (!headers) {
            throw new TrailerMismatchError();
          }
          for (const trailer of trailers) {
            let found = false;
            for (let n = 0; n < headers.length; n += 2) {
              const key = headers[n + 0];
              if (key.length === trailer.length && key.toLowerCase() === trailer.toLowerCase()) {
                found = true;
                break;
              }
            }
            if (!found) {
              throw new TrailerMismatchError();
            }
          }
        }
        try {
          request.onComplete(headers);
        } catch (err) {
          request.onError(err);
        }
      } catch (err) {
        util2.destroy(socket, err);
        return;
      }
      client[kQueue][client[kRunningIdx]++] = null;
      if (socket[kWriting]) {
        util2.destroy(socket, new InformationalError("reset"));
      } else if (!this.shouldKeepAlive) {
        util2.destroy(socket, new InformationalError("reset"));
      } else if (socket[kReset] && !client.running) {
        util2.destroy(socket, new InformationalError("reset"));
      } else {
        resume(client);
      }
    }
    destroy() {
      clearTimeout(this.timeout);
      this.timeout = null;
      this.unconsume();
      setImmediate((self2) => self2.close(), this);
    }
  };
  function onBodyTimeout(self2) {
    if (!self2.paused) {
      util2.destroy(self2.socket, new BodyTimeoutError());
    }
  }
  function onHeadersTimeout(self2) {
    util2.destroy(self2.socket, new HeadersTimeoutError());
  }
  function onSocketConnect() {
    const {[kClient]: client} = this;
    client.emit("connect");
    resume(client);
  }
  function onSocketError(err) {
    const {[kClient]: client} = this;
    this[kError] = err;
    if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
      assert(!client.running);
      while (client.pending && client[kQueue][client[kPendingIdx]].host === client[kHost]) {
        client[kQueue][client[kPendingIdx]++].onError(err);
      }
    } else if (!client.running && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
      assert(client[kPendingIdx] === client[kRunningIdx]);
      for (const request of client[kQueue].splice(client[kRunningIdx])) {
        request.onError(err);
      }
    }
  }
  function onSocketEnd() {
    util2.destroy(this, new SocketError("other side closed"));
  }
  function detachSocket(socket) {
    clearTimeout(socket[kIdleTimeout]);
    socket[kIdleTimeout] = null;
    socket[kIdleTimeoutValue] = null;
    socket[kParser].destroy();
    socket[kParser] = null;
    socket[kClient] = null;
    socket[kError] = null;
    socket.removeListener("session", onSocketSession).removeListener("error", onSocketError).removeListener("end", onSocketEnd).removeListener("close", onSocketClose);
  }
  function onSocketClose() {
    const {[kClient]: client} = this;
    const err = this[kError] || new SocketError("closed");
    detachSocket(this);
    client[kSocket] = null;
    if (err.code !== "UND_ERR_INFO") {
      client[kTLSSession] = null;
    }
    if (client[kDestroyed]) {
      assert(!client.pending);
      for (const request of client[kQueue].splice(client[kRunningIdx])) {
        request.onError(err);
      }
      client[kPendingIdx] = client[kRunningIdx];
    } else {
      if (client.running && err.code !== "UND_ERR_INFO") {
        client[kQueue][client[kRunningIdx]].onError(err);
        client[kQueue][client[kRunningIdx]++] = null;
      }
      client[kPendingIdx] = client[kRunningIdx];
      client.emit("disconnect", err);
    }
    resume(client);
  }
  function onSocketSession(session) {
    const {[kClient]: client} = this;
    client[kTLSSession] = session;
  }
  function connect(client) {
    assert(!client[kSocket]);
    const {protocol, port, hostname} = client[kUrl];
    let socket;
    if (protocol === "https:") {
      const tlsOpts = {
        ...client[kTLSOpts],
        servername: client[kTLSServerName],
        session: client[kTLSSession]
      };
      socket = client[kSocketPath] ? tls.connect(client[kSocketPath], tlsOpts) : tls.connect(port || 443, hostname, tlsOpts);
      socket.on("session", onSocketSession);
    } else {
      socket = client[kSocketPath] ? net.connect(client[kSocketPath]) : net.connect(port || 80, hostname);
    }
    client[kSocket] = socket;
    const parser = new Parser(client, socket);
    if (nodeMajorVersion >= 12) {
      assert(socket._handle);
      parser.consume(socket._handle);
    } else {
      assert(socket._handle && socket._handle._externalStream);
      parser.consume(socket._handle._externalStream);
    }
    socket[kIdleTimeout] = null;
    socket[kIdleTimeoutValue] = null;
    socket[kWriting] = false;
    socket[kReset] = false;
    socket[kError] = null;
    socket[kParser] = parser;
    socket[kClient] = client;
    socket.setNoDelay(true).on(protocol === "https:" ? "secureConnect" : "connect", onSocketConnect).on("error", onSocketError).on("end", onSocketEnd).on("close", onSocketClose);
  }
  function socketPause(socket) {
    if (socket._handle && socket._handle.reading) {
      socket._handle.reading = false;
      const err = socket._handle.readStop();
      if (err) {
        socket.destroy(util2.errnoException(err, "read"));
      }
    }
  }
  function socketResume(socket) {
    if (socket._handle && !socket._handle.reading) {
      socket._handle.reading = true;
      const err = socket._handle.readStart();
      if (err) {
        socket.destroy(util2.errnoException(err, "read"));
      }
    }
  }
  function emitDrain(client) {
    client[kNeedDrain] = 0;
    client.emit("drain");
  }
  function resume(client, sync2) {
    if (client[kResuming] === 2) {
      return;
    }
    client[kResuming] = 2;
    _resume(client, sync2);
    client[kResuming] = 0;
    if (client[kRunningIdx] > 256) {
      client[kQueue].splice(0, client[kRunningIdx]);
      client[kPendingIdx] -= client[kRunningIdx];
      client[kRunningIdx] = 0;
    }
  }
  function _resume(client, sync2) {
    while (true) {
      if (client[kDestroyed]) {
        assert(!client.pending);
        return;
      }
      if (client[kClosed] && !client.size) {
        client.destroy(util2.nop);
        continue;
      }
      if (client[kSocket]) {
        const socket2 = client[kSocket];
        const timeout = client.running ? 0 : client[kKeepAliveTimeoutValue];
        if (socket2[kIdleTimeoutValue] !== timeout) {
          clearTimeout(socket2[kIdleTimeout]);
          if (timeout) {
            socket2[kIdleTimeout] = setTimeout((socket3) => {
              util2.destroy(socket3, new InformationalError("socket idle timeout"));
            }, timeout, socket2);
          }
          socket2[kIdleTimeoutValue] = timeout;
        }
      }
      if (client.running) {
        const {aborted} = client[kQueue][client[kRunningIdx]];
        if (aborted) {
          util2.destroy(client[kSocket]);
          return;
        }
      }
      if (client.busy) {
        client[kNeedDrain] = 2;
      } else if (client[kNeedDrain] === 2) {
        if (sync2) {
          client[kNeedDrain] = 1;
          process.nextTick(emitDrain, client);
        } else {
          emitDrain(client);
        }
        continue;
      }
      if (!client.pending) {
        return;
      }
      if (client.running >= (client[kPipelining] || 1)) {
        return;
      }
      const socket = client[kSocket];
      const request = client[kQueue][client[kPendingIdx]];
      if (client[kUrl].protocol === "https:" && client[kHost] !== request.host) {
        if (client.running) {
          return;
        }
        client[kHost] = request.host;
        const servername = getServerName(client, request.host);
        if (client[kTLSServerName] !== servername) {
          client[kTLSServerName] = servername;
          client[kTLSSession] = null;
          if (socket) {
            util2.destroy(socket, new InformationalError("servername changed"));
            return;
          }
        }
      }
      if (!socket) {
        connect(client);
        return;
      }
      if (!client.connected) {
        return;
      }
      if (socket[kWriting] || socket[kReset]) {
        return;
      }
      if (client.running && !request.idempotent) {
        return;
      }
      if (client.running && request.upgrade) {
        return;
      }
      if (util2.isStream(request.body) && util2.bodyLength(request.body) === 0) {
        request.body.on("data", function() {
          assert(false);
        }).on("error", function(err) {
          request.onError(err);
        }).on("end", function() {
          util2.destroy(this);
        });
        request.body = null;
      }
      if (client.running && util2.isStream(request.body)) {
        return;
      }
      if (!request.aborted && write2(client, request)) {
        const parser = client[kSocket][kParser];
        if (!parser.timeout && client[kHeadersTimeout]) {
          parser.timeout = setTimeout(onHeadersTimeout, client[kHeadersTimeout], parser);
        }
        client[kPendingIdx]++;
      } else {
        client[kQueue].splice(client[kPendingIdx], 1);
      }
    }
  }
  function write2(client, request) {
    const {body, method, path: path4, host, upgrade, headers} = request;
    const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
    if (body && typeof body.read === "function") {
      body.read(0);
    }
    let contentLength = util2.bodyLength(body);
    if (contentLength === null) {
      contentLength = request.contentLength;
    }
    if (contentLength === 0 && !expectsPayload) {
      contentLength = null;
    }
    if (request.contentLength !== null && request.contentLength !== contentLength) {
      request.onError(new ContentLengthMismatchError());
      return false;
    }
    if (request.aborted) {
      return false;
    }
    try {
      request.onConnect((err) => {
        if (request.aborted) {
          return;
        }
        request.onError(err || new RequestAbortedError());
        if (client[kResuming] === 0) {
          resume(client, true);
        }
      });
    } catch (err) {
      request.onError(err);
    }
    if (request.aborted) {
      return false;
    }
    const socket = client[kSocket];
    if (method === "HEAD") {
      socket[kReset] = true;
    }
    if (upgrade) {
      socket[kReset] = true;
    }
    let header;
    if (typeof upgrade === "string") {
      header = `${method} ${path4} HTTP/1.1\r
connection: upgrade\r
upgrade: ${upgrade}\r
`;
    } else if (client[kPipelining]) {
      header = `${method} ${path4} HTTP/1.1\r
connection: keep-alive\r
`;
    } else {
      header = `${method} ${path4} HTTP/1.1\r
connection: close\r
`;
    }
    if (!host) {
      header += client[kHostHeader];
    }
    if (headers) {
      header += headers;
    }
    if (!body) {
      if (contentLength === 0) {
        socket.write(`${header}content-length: ${contentLength}\r
\r
\r
`, "ascii");
      } else {
        assert(contentLength === null, "no body must not have content length");
        socket.write(`${header}\r
`, "ascii");
      }
    } else if (util2.isBuffer(body)) {
      assert(contentLength !== null, "buffer body must have content length");
      socket.cork();
      socket.write(`${header}content-length: ${contentLength}\r
\r
`, "ascii");
      socket.write(body);
      socket.write("\r\n", "ascii");
      socket.uncork();
      if (!expectsPayload) {
        socket[kReset] = true;
      }
    } else {
      socket[kWriting] = true;
      assert(util2.isStream(body));
      assert(contentLength !== 0 || !client.running, "stream body cannot be pipelined");
      let finished = false;
      let bytesWritten = 0;
      const onData = function(chunk) {
        try {
          assert(!finished);
          const len = Buffer.byteLength(chunk);
          if (!len) {
            return;
          }
          if (contentLength !== null && bytesWritten + len > contentLength) {
            util2.destroy(socket, new ContentLengthMismatchError());
            return;
          }
          if (bytesWritten === 0) {
            if (!expectsPayload) {
              socket[kReset] = true;
            }
            if (contentLength === null) {
              socket.write(`${header}transfer-encoding: chunked\r
`, "ascii");
            } else {
              socket.write(`${header}content-length: ${contentLength}\r
\r
`, "ascii");
            }
          }
          if (contentLength === null) {
            socket.write(`\r
${len.toString(16)}\r
`, "ascii");
          }
          bytesWritten += len;
          if (!socket.write(chunk) && this.pause) {
            this.pause();
          }
        } catch (err) {
          util2.destroy(this, err);
        }
      };
      const onDrain = function() {
        assert(!finished);
        if (body.resume) {
          body.resume();
        }
      };
      const onAbort = function() {
        onFinished(new RequestAbortedError());
      };
      const onFinished = function(err) {
        if (finished) {
          return;
        }
        finished = true;
        assert(socket.destroyed || socket[kWriting] && client.running <= 1);
        socket[kWriting] = false;
        if (!err && contentLength !== null && bytesWritten !== contentLength) {
          err = new ContentLengthMismatchError();
        }
        socket.removeListener("drain", onDrain).removeListener("error", onFinished);
        body.removeListener("data", onData).removeListener("end", onFinished).removeListener("error", onFinished).removeListener("close", onAbort);
        util2.destroy(body, err);
        if (err) {
          assert(client.running <= 1, "pipeline should only contain this request");
          util2.destroy(socket, err);
        }
        if (socket.destroyed) {
          return;
        }
        if (bytesWritten === 0) {
          if (expectsPayload) {
            socket.write(`${header}content-length: 0\r
\r
\r
`, "ascii");
          } else {
            socket.write(`${header}\r
`, "ascii");
          }
        } else if (contentLength === null) {
          socket.write("\r\n0\r\n\r\n", "ascii");
        }
        resume(client);
      };
      body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onAbort);
      socket.on("drain", onDrain).on("error", onFinished);
    }
    return true;
  }
  module2.exports = Client;
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/node/fixed-queue.js
var require_fixed_queue = __commonJS2((exports2, module2) => {
  "use strict";
  var kSize = 2048;
  var kMask = kSize - 1;
  var FixedCircularBuffer = class {
    constructor() {
      this.bottom = 0;
      this.top = 0;
      this.list = new Array(kSize);
      this.next = null;
    }
    isEmpty() {
      return this.top === this.bottom;
    }
    isFull() {
      return (this.top + 1 & kMask) === this.bottom;
    }
    push(data) {
      this.list[this.top] = data;
      this.top = this.top + 1 & kMask;
    }
    shift() {
      const nextItem = this.list[this.bottom];
      if (nextItem === void 0)
        return null;
      this.list[this.bottom] = void 0;
      this.bottom = this.bottom + 1 & kMask;
      return nextItem;
    }
  };
  module2.exports = class FixedQueue {
    constructor() {
      this.head = this.tail = new FixedCircularBuffer();
    }
    isEmpty() {
      return this.head.isEmpty();
    }
    push(data) {
      if (this.head.isFull()) {
        this.head = this.head.next = new FixedCircularBuffer();
      }
      this.head.push(data);
    }
    shift() {
      const tail = this.tail;
      const next = tail.shift();
      if (tail.isEmpty() && tail.next !== null) {
        this.tail = tail.next;
      }
      return next;
    }
  };
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/abort-signal.js
var require_abort_signal = __commonJS2((exports2, module2) => {
  var {RequestAbortedError} = require_errors();
  var kListener = Symbol("kListener");
  var kSignal = Symbol("kSignal");
  function abort(self2) {
    if (self2.abort) {
      self2.abort();
    } else {
      self2.onError(new RequestAbortedError());
    }
  }
  function addSignal(self2, signal) {
    self2[kSignal] = null;
    self2[kListener] = null;
    if (!signal) {
      return;
    }
    if (signal.aborted) {
      abort(self2);
      return;
    }
    self2[kSignal] = signal;
    self2[kListener] = () => {
      abort(self2);
    };
    if ("addEventListener" in self2[kSignal]) {
      self2[kSignal].addEventListener("abort", self2[kListener]);
    } else {
      self2[kSignal].addListener("abort", self2[kListener]);
    }
  }
  function removeSignal(self2) {
    if (!self2[kSignal]) {
      return;
    }
    if ("removeEventListener" in self2[kSignal]) {
      self2[kSignal].removeEventListener("abort", self2[kListener]);
    } else {
      self2[kSignal].removeListener("abort", self2[kListener]);
    }
    self2[kSignal] = null;
    self2[kListener] = null;
  }
  module2.exports = {
    addSignal,
    removeSignal
  };
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/client-request.js
var require_client_request = __commonJS2((exports2, module2) => {
  "use strict";
  var {Readable} = require("stream");
  var {
    InvalidArgumentError,
    RequestAbortedError
  } = require_errors();
  var util2 = require_util6();
  var {AsyncResource} = require("async_hooks");
  var {addSignal, removeSignal} = require_abort_signal();
  var kAbort = Symbol("abort");
  var RequestResponse = class extends Readable {
    constructor(resume, abort) {
      super({autoDestroy: true, read: resume});
      this[kAbort] = abort;
    }
    _destroy(err, callback) {
      if (!err && !this._readableState.endEmitted) {
        err = new RequestAbortedError();
      }
      if (err) {
        this[kAbort]();
      }
      callback(err);
    }
  };
  var RequestHandler = class extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      const {signal, method, opaque, body} = opts;
      try {
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        super("UNDICI_REQUEST");
      } catch (err) {
        if (util2.isStream(body)) {
          util2.destroy(body.on("error", util2.nop), err);
        }
        throw err;
      }
      this.opaque = opaque || null;
      this.callback = callback;
      this.res = null;
      this.abort = null;
      this.body = body;
      this.trailers = {};
      if (util2.isStream(body)) {
        body.on("error", (err) => {
          this.onError(err);
        });
      }
      addSignal(this, signal);
    }
    onConnect(abort) {
      if (!this.callback) {
        throw new RequestAbortedError();
      }
      this.abort = abort;
    }
    onHeaders(statusCode, headers, resume) {
      const {callback, opaque, abort} = this;
      if (statusCode < 200) {
        return;
      }
      const body = new RequestResponse(resume, abort);
      this.callback = null;
      this.res = body;
      this.runInAsyncScope(callback, null, null, {
        statusCode,
        headers: util2.parseHeaders(headers),
        trailers: this.trailers,
        opaque,
        body
      });
    }
    onData(chunk) {
      const {res} = this;
      return res.push(chunk);
    }
    onComplete(trailers) {
      const {res} = this;
      removeSignal(this);
      if (trailers) {
        util2.parseHeaders(trailers, this.trailers);
      }
      res.push(null);
    }
    onError(err) {
      const {res, callback, body, opaque} = this;
      removeSignal(this);
      if (callback) {
        this.callback = null;
        process.nextTick((self2, callback2, err2, opaque2) => {
          self2.runInAsyncScope(callback2, null, err2, {opaque: opaque2});
        }, this, callback, err, opaque);
      }
      if (res) {
        this.res = null;
        util2.destroy(res, err);
      }
      if (body) {
        this.body = null;
        util2.destroy(body, err);
      }
    }
  };
  function request(opts, callback) {
    if (callback === void 0) {
      return new Promise((resolve, reject) => {
        request.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    try {
      this.dispatch(opts, new RequestHandler(opts, callback));
    } catch (err) {
      if (typeof callback === "function") {
        process.nextTick(callback, err, {opaque: opts && opts.opaque});
      } else {
        throw err;
      }
    }
  }
  module2.exports = request;
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/client-stream.js
var require_client_stream = __commonJS2((exports2, module2) => {
  "use strict";
  var {finished} = require("stream");
  var {
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError
  } = require_errors();
  var util2 = require_util6();
  var {AsyncResource} = require("async_hooks");
  var {addSignal, removeSignal} = require_abort_signal();
  var StreamHandler = class extends AsyncResource {
    constructor(opts, factory, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      const {signal, method, opaque, body} = opts;
      try {
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("invalid factory");
        }
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        super("UNDICI_STREAM");
      } catch (err) {
        if (util2.isStream(body)) {
          util2.destroy(body.on("error", util2.nop), err);
        }
        throw err;
      }
      this.opaque = opaque || null;
      this.factory = factory;
      this.callback = callback;
      this.res = null;
      this.abort = null;
      this.trailers = null;
      this.body = body;
      if (util2.isStream(body)) {
        body.on("error", (err) => {
          this.onError(err);
        });
      }
      addSignal(this, signal);
    }
    onConnect(abort) {
      if (!this.callback) {
        throw new RequestAbortedError();
      }
      this.abort = abort;
    }
    onHeaders(statusCode, headers, resume) {
      const {factory, opaque} = this;
      if (statusCode < 200) {
        return;
      }
      this.factory = null;
      const res = this.runInAsyncScope(factory, null, {
        statusCode,
        headers: util2.parseHeaders(headers),
        opaque
      });
      if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") {
        throw new InvalidReturnValueError("expected Writable");
      }
      res.on("drain", resume);
      finished(res, {readable: false}, (err) => {
        const {callback, res: res2, opaque: opaque2, trailers, abort} = this;
        this.res = null;
        if (err || !res2.readable) {
          util2.destroy(res2, err);
        }
        this.callback = null;
        this.runInAsyncScope(callback, null, err || null, {opaque: opaque2, trailers});
        if (err) {
          abort();
        }
      });
      this.res = res;
      const needDrain = res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;
      return needDrain !== true;
    }
    onData(chunk) {
      const {res} = this;
      return res.write(chunk);
    }
    onComplete(trailers) {
      const {res} = this;
      removeSignal(this);
      this.trailers = trailers ? util2.parseHeaders(trailers) : {};
      res.end();
    }
    onError(err) {
      const {res, callback, opaque, body} = this;
      removeSignal(this);
      this.factory = null;
      if (res) {
        this.res = null;
        util2.destroy(res, err);
      } else if (callback) {
        this.callback = null;
        process.nextTick((self2, callback2, err2, opaque2) => {
          self2.runInAsyncScope(callback2, null, err2, {opaque: opaque2});
        }, this, callback, err, opaque);
      }
      if (body) {
        this.body = null;
        util2.destroy(body, err);
      }
    }
  };
  function stream(opts, factory, callback) {
    if (callback === void 0) {
      return new Promise((resolve, reject) => {
        stream.call(this, opts, factory, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    try {
      this.dispatch(opts, new StreamHandler(opts, factory, callback));
    } catch (err) {
      if (typeof callback === "function") {
        process.nextTick(callback, err, {opaque: opts && opts.opaque});
      } else {
        throw err;
      }
    }
  }
  module2.exports = stream;
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/client-pipeline.js
var require_client_pipeline = __commonJS2((exports2, module2) => {
  "use strict";
  var {
    Readable,
    Duplex,
    PassThrough
  } = require("stream");
  var {
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError
  } = require_errors();
  var util2 = require_util6();
  var {AsyncResource} = require("async_hooks");
  var {assert} = require("console");
  var {addSignal, removeSignal} = require_abort_signal();
  var kResume = Symbol("resume");
  var PipelineRequest = class extends Readable {
    constructor() {
      super({autoDestroy: true});
      this[kResume] = null;
    }
    _read() {
      const {[kResume]: resume} = this;
      if (resume) {
        this[kResume] = null;
        resume();
      }
    }
    _destroy(err, callback) {
      this._read();
      assert(err || this._readableState.endEmitted);
      callback(err);
    }
  };
  var PipelineResponse = class extends Readable {
    constructor(resume) {
      super({autoDestroy: true});
      this[kResume] = resume;
    }
    _read() {
      this[kResume]();
    }
    _destroy(err, callback) {
      if (!err && !this._readableState.endEmitted) {
        err = new RequestAbortedError();
      }
      callback(err);
    }
  };
  var PipelineHandler = class extends AsyncResource {
    constructor(opts, handler) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (typeof handler !== "function") {
        throw new InvalidArgumentError("invalid handler");
      }
      const {signal, method, opaque} = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      if (method === "CONNECT") {
        throw new InvalidArgumentError("invalid method");
      }
      super("UNDICI_PIPELINE");
      this.opaque = opaque || null;
      this.handler = handler;
      this.abort = null;
      this.req = new PipelineRequest().on("error", util2.nop);
      this.ret = new Duplex({
        readableObjectMode: opts.objectMode,
        autoDestroy: true,
        read: () => {
          const {body} = this;
          if (body && body.resume) {
            body.resume();
          }
        },
        write: (chunk, encoding, callback) => {
          const {req} = this;
          if (req.push(chunk, encoding) || req._readableState.destroyed) {
            callback();
          } else {
            req[kResume] = callback;
          }
        },
        destroy: (err, callback) => {
          const {body, req, res, ret, abort} = this;
          if (!err && !ret._readableState.endEmitted) {
            err = new RequestAbortedError();
          }
          if (abort && err) {
            abort();
          }
          util2.destroy(body, err);
          util2.destroy(req, err);
          util2.destroy(res, err);
          removeSignal(this);
          callback(err);
        }
      }).on("prefinish", () => {
        const {req} = this;
        req.push(null);
      });
      this.res = null;
      addSignal(this, signal);
    }
    onConnect(abort) {
      const {ret} = this;
      if (ret.destroyed) {
        throw new RequestAbortedError();
      }
      this.abort = abort;
    }
    onHeaders(statusCode, headers, resume) {
      const {opaque, handler} = this;
      if (statusCode < 200) {
        return;
      }
      this.res = new PipelineResponse(resume);
      let body;
      try {
        this.handler = null;
        body = this.runInAsyncScope(handler, null, {
          statusCode,
          headers: util2.parseHeaders(headers),
          opaque,
          body: this.res
        });
      } catch (err) {
        this.res.on("error", util2.nop);
        throw err;
      }
      if (!body || typeof body.on !== "function") {
        throw new InvalidReturnValueError("expected Readable");
      }
      body.on("data", (chunk) => {
        const {ret, body: body2} = this;
        if (!ret.push(chunk) && body2.pause) {
          body2.pause();
        }
      }).on("error", (err) => {
        const {ret} = this;
        util2.destroy(ret, err);
      }).on("end", () => {
        const {ret} = this;
        ret.push(null);
      }).on("close", () => {
        const {ret} = this;
        if (!ret._readableState.ended) {
          util2.destroy(ret, new RequestAbortedError());
        }
      });
      this.body = body;
    }
    onData(chunk) {
      const {res} = this;
      return res.push(chunk);
    }
    onComplete(trailers) {
      const {res} = this;
      res.push(null);
    }
    onError(err) {
      const {ret} = this;
      this.handler = null;
      util2.destroy(ret, err);
    }
  };
  function pipeline(opts, handler) {
    try {
      const pipelineHandler = new PipelineHandler(opts, handler);
      const {
        path: path4,
        method,
        headers,
        idempotent,
        signal
      } = opts;
      this.dispatch({
        path: path4,
        method,
        body: pipelineHandler.req,
        headers,
        idempotent,
        signal
      }, pipelineHandler);
      return pipelineHandler.ret;
    } catch (err) {
      return new PassThrough().destroy(err);
    }
  }
  module2.exports = pipeline;
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/client-upgrade.js
var require_client_upgrade = __commonJS2((exports2, module2) => {
  "use strict";
  var {InvalidArgumentError, RequestAbortedError} = require_errors();
  var {AsyncResource} = require("async_hooks");
  var util2 = require_util6();
  var {addSignal, removeSignal} = require_abort_signal();
  var assert = require("assert");
  var UpgradeHandler = class extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      const {signal, opaque} = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      super("UNDICI_UPGRADE");
      this.opaque = opaque || null;
      this.callback = callback;
      this.abort = null;
      addSignal(this, signal);
    }
    onConnect(abort) {
      if (!this.callback) {
        throw new RequestAbortedError();
      }
      this.abort = abort;
    }
    onUpgrade(statusCode, headers, socket) {
      const {callback, opaque} = this;
      assert.strictEqual(statusCode, 101);
      removeSignal(this);
      this.callback = null;
      this.runInAsyncScope(callback, null, null, {
        headers: util2.parseHeaders(headers),
        socket,
        opaque
      });
    }
    onError(err) {
      const {callback, opaque} = this;
      removeSignal(this);
      if (callback) {
        this.callback = null;
        process.nextTick((self2, callback2, err2, opaque2) => {
          self2.runInAsyncScope(callback2, null, err2, {opaque: opaque2});
        }, this, callback, err, opaque);
      }
    }
  };
  function upgrade(opts, callback) {
    if (callback === void 0) {
      return new Promise((resolve, reject) => {
        upgrade.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    if (typeof callback !== "function") {
      throw new InvalidArgumentError("invalid callback");
    }
    try {
      const upgradeHandler = new UpgradeHandler(opts, callback);
      const {
        path: path4,
        method,
        headers,
        signal,
        protocol
      } = opts;
      this.dispatch({
        path: path4,
        method: method || "GET",
        headers,
        signal,
        upgrade: protocol || "Websocket"
      }, upgradeHandler);
    } catch (err) {
      process.nextTick(callback, err, {opaque: opts && opts.opaque});
    }
  }
  module2.exports = upgrade;
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/client-connect.js
var require_client_connect = __commonJS2((exports2, module2) => {
  "use strict";
  var {InvalidArgumentError, RequestAbortedError} = require_errors();
  var {AsyncResource} = require("async_hooks");
  var util2 = require_util6();
  var {addSignal, removeSignal} = require_abort_signal();
  var ConnectHandler = class extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      const {signal, opaque} = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      super("UNDICI_CONNECT");
      this.opaque = opaque || null;
      this.callback = callback;
      this.abort = null;
      addSignal(this, signal);
    }
    onConnect(abort) {
      if (!this.callback) {
        throw new RequestAbortedError();
      }
      this.abort = abort;
    }
    onUpgrade(statusCode, headers, socket) {
      const {callback, opaque} = this;
      removeSignal(this);
      this.callback = null;
      this.runInAsyncScope(callback, null, null, {
        statusCode,
        headers: util2.parseHeaders(headers),
        socket,
        opaque
      });
    }
    onError(err) {
      const {callback, opaque} = this;
      removeSignal(this);
      if (callback) {
        this.callback = null;
        process.nextTick((self2, callback2, err2, opaque2) => {
          self2.runInAsyncScope(callback2, null, err2, {opaque: opaque2});
        }, this, callback, err, opaque);
      }
    }
  };
  function connect(opts, callback) {
    if (callback === void 0) {
      return new Promise((resolve, reject) => {
        connect.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    if (typeof callback !== "function") {
      throw new InvalidArgumentError("invalid callback");
    }
    try {
      const connectHandler = new ConnectHandler(opts, callback);
      const {
        path: path4,
        headers,
        signal
      } = opts;
      this.dispatch({
        path: path4,
        method: "CONNECT",
        headers,
        signal
      }, connectHandler);
    } catch (err) {
      process.nextTick(callback, err, {opaque: opts && opts.opaque});
    }
  }
  module2.exports = connect;
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/pool.js
var require_pool = __commonJS2((exports2, module2) => {
  "use strict";
  var EventEmitter = require("events");
  var Client = require_client();
  var {
    ClientClosedError,
    InvalidArgumentError,
    ClientDestroyedError
  } = require_errors();
  var FixedQueue = require_fixed_queue();
  var util2 = require_util6();
  var kClients = Symbol("clients");
  var kNeedDrain = Symbol("needDrain");
  var kQueue = Symbol("queue");
  var kDestroyed = Symbol("destroyed");
  var kClosedPromise = Symbol("closed promise");
  var kClosedResolve = Symbol("closed resolve");
  var kOptions = Symbol("options");
  var kUrl = Symbol("url");
  var kOnDrain = Symbol("onDrain");
  var kOnConnect = Symbol("onConnect");
  var kOnDisconnect = Symbol("onDisconnect");
  var kPending = Symbol("pending");
  var kConnected = Symbol("connected");
  var kConnections = Symbol("connections");
  var Pool = class extends EventEmitter {
    constructor(origin, {connections, ...options} = {}) {
      super();
      if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
        throw new InvalidArgumentError("invalid connections");
      }
      this[kConnections] = connections || null;
      this[kUrl] = util2.parseOrigin(origin);
      this[kOptions] = JSON.parse(JSON.stringify(options));
      this[kQueue] = new FixedQueue();
      this[kClosedPromise] = null;
      this[kClosedResolve] = null;
      this[kDestroyed] = false;
      this[kClients] = [];
      this[kNeedDrain] = false;
      this[kPending] = 0;
      this[kConnected] = 0;
      const pool = this;
      this[kOnDrain] = function onDrain() {
        const queue = pool[kQueue];
        while (!this.busy) {
          const item = queue.shift();
          if (!item) {
            break;
          }
          pool[kPending]--;
          this.dispatch(item.opts, item.handler);
        }
        if (pool[kNeedDrain] && !this.busy) {
          pool[kNeedDrain] = false;
          pool.emit("drain");
        }
        if (pool[kClosedResolve] && queue.isEmpty()) {
          Promise.all(pool[kClients].map((c) => c.close())).then(pool[kClosedResolve]);
        }
      };
      this[kOnConnect] = function onConnect() {
        pool[kConnected]++;
        pool.emit("connect", this);
      };
      this[kOnDisconnect] = function onDisconnect(err) {
        pool[kConnected]--;
        pool.emit("disconnect", this, err);
      };
    }
    get url() {
      return this[kUrl];
    }
    get connected() {
      return this[kConnected];
    }
    get busy() {
      if (this[kPending] > 0) {
        return true;
      }
      if (this[kConnections] && this[kClients].length === this[kConnections]) {
        for (const {busy} of this[kClients]) {
          if (!busy) {
            return false;
          }
        }
        return true;
      }
      return false;
    }
    get pending() {
      let ret = this[kPending];
      for (const {pending} of this[kClients]) {
        ret += pending;
      }
      return ret;
    }
    get running() {
      let ret = 0;
      for (const {running} of this[kClients]) {
        ret += running;
      }
      return ret;
    }
    get size() {
      let ret = this[kPending];
      for (const {size} of this[kClients]) {
        ret += size;
      }
      return ret;
    }
    get destroyed() {
      return this[kDestroyed];
    }
    get closed() {
      return this[kClosedPromise] != null;
    }
    dispatch(opts, handler) {
      try {
        if (this[kDestroyed]) {
          throw new ClientDestroyedError();
        }
        if (this[kClosedPromise]) {
          throw new ClientClosedError();
        }
        let client = this[kClients].find((client2) => !client2.busy);
        if (!client) {
          if (!this[kConnections] || this[kClients].length < this[kConnections]) {
            client = new Client(this[kUrl], this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]);
            this[kClients].push(client);
          }
        }
        if (!client) {
          this[kNeedDrain] = true;
          this[kQueue].push({opts, handler});
          this[kPending]++;
        } else {
          client.dispatch(opts, handler);
          if (client.busy && this.busy) {
            this[kNeedDrain] = true;
          }
        }
      } catch (err) {
        if (typeof handler.onError !== "function") {
          throw new InvalidArgumentError("invalid onError method");
        }
        handler.onError(err);
      }
    }
    close(cb) {
      try {
        if (this[kDestroyed]) {
          throw new ClientDestroyedError();
        }
        if (!this[kClosedPromise]) {
          if (this[kQueue].isEmpty()) {
            this[kClosedPromise] = Promise.all(this[kClients].map((c) => c.close()));
          } else {
            this[kClosedPromise] = new Promise((resolve) => {
              this[kClosedResolve] = resolve;
            });
          }
          this[kClosedPromise] = this[kClosedPromise].then(() => {
            this[kDestroyed] = true;
          });
        }
        if (cb) {
          this[kClosedPromise].then(() => cb(null, null));
        } else {
          return this[kClosedPromise];
        }
      } catch (err) {
        if (cb) {
          cb(err);
        } else {
          return Promise.reject(err);
        }
      }
    }
    destroy(err, cb) {
      this[kDestroyed] = true;
      if (typeof err === "function") {
        cb = err;
        err = null;
      }
      if (!err) {
        err = new ClientDestroyedError();
      }
      while (true) {
        const item = this[kQueue].shift();
        if (!item) {
          break;
        }
        item.handler.onError(err);
      }
      const promise = Promise.all(this[kClients].map((c) => c.destroy(err)));
      if (cb) {
        promise.then(() => cb(null, null));
      } else {
        return promise;
      }
    }
  };
  Pool.prototype.request = require_client_request();
  Pool.prototype.stream = require_client_stream();
  Pool.prototype.pipeline = require_client_pipeline();
  Pool.prototype.upgrade = require_client_upgrade();
  Pool.prototype.connect = require_client_connect();
  module2.exports = Pool;
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/agent.js
var require_agent5 = __commonJS2((exports2, module2) => {
  "use strict";
  var {InvalidArgumentError, InvalidReturnValueError} = require_errors();
  var Pool = require_pool();
  var util2 = require_util6();
  var {kAgentOpts, kAgentCache} = require_symbols();
  var Agent = class {
    constructor(opts) {
      this[kAgentOpts] = opts;
      this[kAgentCache] = new Map();
    }
    get(origin) {
      if (typeof origin !== "string" || origin === "") {
        throw new InvalidArgumentError("Origin must be a non-empty string.");
      }
      const self2 = this;
      let pool = self2[kAgentCache].get(origin);
      function onDisconnect() {
        if (this.connected === 0 && this.size === 0) {
          this.off("disconnect", onDisconnect);
          self2[kAgentCache].delete(origin);
        }
      }
      if (!pool) {
        pool = new Pool(origin, self2[kAgentOpts]);
        pool.on("disconnect", onDisconnect);
        self2[kAgentCache].set(origin, pool);
      }
      return pool;
    }
    close() {
      const closePromises = [];
      for (const pool of this[kAgentCache].values()) {
        closePromises.push(pool.close());
      }
      return Promise.all(closePromises);
    }
    destroy() {
      const destroyPromises = [];
      for (const pool of this[kAgentCache].values()) {
        destroyPromises.push(pool.destroy());
      }
      return Promise.all(destroyPromises);
    }
  };
  var globalAgent = new Agent({connections: null});
  function setGlobalAgent(agent) {
    if (!agent || typeof agent.get !== "function") {
      throw new InvalidArgumentError("Argument agent must implement Agent");
    }
    globalAgent = agent;
  }
  function dispatchFromAgent(requestType) {
    return (url, {agent = globalAgent, method = "GET", ...opts} = {}, ...additionalArgs) => {
      if (opts.path != null) {
        throw new InvalidArgumentError("unsupported opts.path");
      }
      const {origin, pathname, search} = util2.parseURL(url);
      const path4 = `${pathname || "/"}${search || ""}`;
      const client = agent.get(origin);
      if (client && typeof client[requestType] !== "function") {
        throw new InvalidReturnValueError(`Client returned from Agent.get() does not implement method ${requestType}`);
      }
      return client[requestType]({...opts, method, path: path4}, ...additionalArgs);
    };
  }
  module2.exports = {
    request: dispatchFromAgent("request"),
    stream: dispatchFromAgent("stream"),
    pipeline: dispatchFromAgent("pipeline"),
    connect: dispatchFromAgent("connect"),
    upgrade: dispatchFromAgent("upgrade"),
    setGlobalAgent,
    Agent
  };
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/index.js
var require_undici = __commonJS2((exports2, module2) => {
  "use strict";
  var Client = require_client();
  var errors = require_errors();
  var Pool = require_pool();
  var {Agent, request, stream, pipeline, setGlobalAgent} = require_agent5();
  Client.prototype.request = require_client_request();
  Client.prototype.stream = require_client_stream();
  Client.prototype.pipeline = require_client_pipeline();
  Client.prototype.upgrade = require_client_upgrade();
  Client.prototype.connect = require_client_connect();
  function undici(url, opts) {
    return new Pool(url, opts);
  }
  undici.Pool = Pool;
  undici.Client = Client;
  undici.errors = errors;
  undici.Agent = Agent;
  undici.request = request;
  undici.stream = stream;
  undici.pipeline = pipeline;
  undici.setGlobalAgent = setGlobalAgent;
  module2.exports = undici;
});

// ../engine-core/dist/binary/Connection.js
var require_Connection = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    Connection: () => Connection
  });
  var import_undici = __toModule3(require_undici());
  var getStream = require_get_stream2();
  function assertHasPool(pool) {
    if (pool === void 0) {
      throw new Error("Connection has not been opened");
    }
  }
  var Connection = class {
    constructor() {
    }
    static async onHttpError(response, handler) {
      const _response = await response;
      if (_response.statusCode >= 400) {
        return handler(_response);
      }
      return _response;
    }
    open(url, options) {
      if (this._pool)
        return;
      this._pool = new import_undici.Pool(url, {
        connections: 100,
        pipelining: 10,
        keepAliveMaxTimeout: 6e5,
        headersTimeout: 0,
        ...options
      });
    }
    async raw(method, endpoint, headers, body) {
      assertHasPool(this._pool);
      const response = await this._pool.request({
        path: endpoint,
        method,
        headers: {
          "Content-Type": "application/json",
          ...headers
        },
        body,
        bodyTimeout: 0
      });
      const result = {
        statusCode: response.statusCode,
        headers: response.headers,
        data: JSON.parse(await getStream(response.body))
      };
      return result;
    }
    post(endpoint, body, headers) {
      return this.raw("POST", endpoint, headers, body);
    }
    get(path4, headers) {
      return this.raw("GET", path4, headers);
    }
    close() {
      if (this._pool) {
        this._pool.close(() => {
        });
      }
      this._pool = void 0;
    }
  };
});

// ../engine-core/dist/binary/BinaryEngine.js
var require_BinaryEngine = __commonJS2((exports, module) => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name in all)
      __defProp(target, name, {get: all[name], enumerable: true});
  };
  var __reExport = (target, module2, desc) => {
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
      for (let key of __getOwnPropNames(module2))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule = (module2) => {
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
  };
  __export(exports, {
    BinaryEngine: () => BinaryEngine
  });
  var import_debug = __toModule(require_dist7());
  var import_engines = __toModule(require_dist16());
  var import_get_platform = __toModule(require_dist11());
  var import_chalk = __toModule(require_source2());
  var import_child_process = __toModule(require("child_process"));
  var import_events = __toModule(require("events"));
  var import_execa = __toModule(require_execa2());
  var import_fs = __toModule(require("fs"));
  var import_net = __toModule(require("net"));
  var import_p_retry = __toModule(require_p_retry2());
  var import_path = __toModule(require("path"));
  var import_url = __toModule(require("url"));
  var import_util = __toModule(require("util"));
  var import_byline = __toModule(require_byline2());
  var import_Engine = __toModule(require_Engine());
  var import_PrismaClientKnownRequestError = __toModule(require_PrismaClientKnownRequestError());
  var import_PrismaClientInitializationError = __toModule(require_PrismaClientInitializationError());
  var import_PrismaClientRustError = __toModule(require_PrismaClientRustError());
  var import_PrismaClientRustPanicError = __toModule(require_PrismaClientRustPanicError());
  var import_PrismaClientUnknownRequestError = __toModule(require_PrismaClientUnknownRequestError());
  var import_getErrorMessageWithLink = __toModule(require_getErrorMessageWithLink());
  var import_log = __toModule(require_log3());
  var import_omit = __toModule(require_omit());
  var import_printGeneratorConfig = __toModule(require_printGeneratorConfig());
  var import_Connection = __toModule(require_Connection());
  var import_util2 = __toModule(require_util5());
  var debug = (0, import_debug.default)("prisma:engine");
  var exists = (0, import_util.promisify)(import_fs.default.exists);
  var logger = (...args) => {
  };
  var knownPlatforms = [...import_get_platform.platforms, "native"];
  var engines = [];
  var socketPaths = [];
  var MAX_STARTS = process.env.PRISMA_CLIENT_NO_RETRY ? 1 : 2;
  var MAX_REQUEST_RETRIES = process.env.PRISMA_CLIENT_NO_RETRY ? 1 : 2;
  var BinaryEngine = class extends import_Engine.Engine {
    constructor({
      cwd,
      datamodelPath,
      prismaPath,
      generator,
      datasources,
      showColors,
      logLevel,
      logQueries,
      env: env2,
      flags,
      clientVersion: clientVersion2,
      previewFeatures,
      engineEndpoint,
      enableDebugLogs,
      enableEngineDebugMode,
      dirname: dirname2,
      useUds,
      activeProvider
    }) {
      super();
      this.startCount = 0;
      this.previewFeatures = [];
      this.useUds = false;
      this.stderrLogs = "";
      this.handleRequestError = async (error, graceful = false) => {
        var _a2, _b;
        debug({error});
        if (this.startPromise) {
          await this.startPromise;
        }
        this.throwAsyncErrorIfExists();
        if ((_a2 = this.currentRequestPromise) == null ? void 0 : _a2.isCanceled) {
          this.throwAsyncErrorIfExists();
        } else if (error.code === "ECONNRESET" || error.code === "ECONNREFUSED" || error.code === "UND_ERR_CLOSED" || error.code === "UND_ERR_SOCKET" || error.code === "UND_ERR_DESTROYED" || error.code === "UND_ERR_ABORTED" || error.message.toLowerCase().includes("client is destroyed") || error.message.toLowerCase().includes("other side closed") || error.message.toLowerCase().includes("the client is closed")) {
          if (this.globalKillSignalReceived && !((_b = this.child) == null ? void 0 : _b.connected)) {
            throw new import_PrismaClientUnknownRequestError.PrismaClientUnknownRequestError(`The Node.js process already received a ${this.globalKillSignalReceived} signal, therefore the Prisma query engine exited
and your request can't be processed.
You probably have some open handle that prevents your process from exiting.
It could be an open http server or stream that didn't close yet.
We recommend using the \`wtfnode\` package to debug open handles.`, this.clientVersion);
          }
          this.throwAsyncErrorIfExists();
          if (this.startCount > MAX_STARTS) {
            for (let i = 0; i < 5; i++) {
              await new Promise((r) => setTimeout(r, 50));
              this.throwAsyncErrorIfExists(true);
            }
            throw new Error(`Query engine is trying to restart, but can't.
Please look into the logs or turn on the env var DEBUG=* to debug the constantly restarting query engine.`);
          }
        }
        if (!graceful) {
          this.throwAsyncErrorIfExists(true);
          throw error;
        }
        return false;
      };
      var _a;
      this.dirname = dirname2;
      this.useUds = useUds != null ? useUds : false;
      this.env = env2;
      this.cwd = this.resolveCwd(cwd);
      this.enableDebugLogs = enableDebugLogs != null ? enableDebugLogs : false;
      this.enableEngineDebugMode = enableEngineDebugMode != null ? enableEngineDebugMode : false;
      this.datamodelPath = datamodelPath;
      this.prismaPath = (_a = process.env.PRISMA_QUERY_ENGINE_BINARY) != null ? _a : prismaPath;
      this.generator = generator;
      this.datasources = datasources;
      this.logEmitter = new import_events.default();
      this.logEmitter.on("error", () => {
      });
      this.showColors = showColors != null ? showColors : false;
      this.logLevel = logLevel;
      this.logQueries = logQueries != null ? logQueries : false;
      this.clientVersion = clientVersion2;
      this.flags = flags != null ? flags : [];
      this.previewFeatures = previewFeatures != null ? previewFeatures : [];
      this.activeProvider = activeProvider;
      this.connection = new import_Connection.Connection();
      initHooks();
      const removedFlags = [
        "middlewares",
        "aggregateApi",
        "distinct",
        "aggregations",
        "insensitiveFilters",
        "atomicNumberOperations",
        "transactionApi",
        "transaction",
        "connectOrCreate",
        "uncheckedScalarInputs",
        "nativeTypes",
        "createMany",
        "groupBy"
      ];
      const removedFlagsUsed = this.previewFeatures.filter((e) => removedFlags.includes(e));
      if (removedFlagsUsed.length > 0 && !process.env.PRISMA_HIDE_PREVIEW_FLAG_WARNINGS) {
        console.log(`${import_chalk.default.blueBright("info")} The preview flags \`${removedFlagsUsed.join("`, `")}\` were removed, you can now safely remove them from your schema.prisma.`);
      }
      this.previewFeatures = this.previewFeatures.filter((e) => !removedFlags.includes(e));
      this.engineEndpoint = engineEndpoint;
      if (engineEndpoint) {
        const url = new import_url.URL(engineEndpoint);
        this.port = Number(url.port);
      }
      if (this.platform) {
        if (!knownPlatforms.includes(this.platform) && !import_fs.default.existsSync(this.platform)) {
          throw new import_PrismaClientInitializationError.PrismaClientInitializationError(`Unknown ${import_chalk.default.red("PRISMA_QUERY_ENGINE_BINARY")} ${import_chalk.default.redBright.bold(this.platform)}. Possible binaryTargets: ${import_chalk.default.greenBright(knownPlatforms.join(", "))} or a path to the query engine binary.
You may have to run ${import_chalk.default.greenBright("prisma generate")} for your changes to take effect.`, this.clientVersion);
        }
      } else {
        void this.getPlatform();
      }
      if (this.enableDebugLogs) {
        import_debug.default.enable("*");
      }
      engines.push(this);
      this.checkForTooManyEngines();
    }
    setError(err) {
      var _a;
      if ((0, import_log.isRustError)(err)) {
        this.lastRustError = err;
        this.logEmitter.emit("error", new import_PrismaClientRustError.PrismaClientRustError({
          clientVersion: this.clientVersion,
          error: err
        }));
        if (err.is_panic) {
          this.handlePanic();
        }
      } else if ((0, import_log.isRustErrorLog)(err)) {
        this.lastErrorLog = err;
        this.logEmitter.emit("error", new import_PrismaClientRustError.PrismaClientRustError({
          clientVersion: this.clientVersion,
          log: err
        }));
        if (((_a = err.fields) == null ? void 0 : _a.message) === "PANIC") {
          this.handlePanic();
        }
      } else {
        this.logEmitter.emit("error", err);
      }
    }
    checkForTooManyEngines() {
      if (engines.length >= 10) {
        const runningEngines = engines.filter((e) => e.child);
        if (runningEngines.length === 10) {
          console.warn(`${import_chalk.default.yellow("warn(prisma-client)")} Already 10 Prisma Clients are actively running.`);
        }
      }
    }
    resolveCwd(cwd) {
      if (cwd && import_fs.default.existsSync(cwd) && import_fs.default.lstatSync(cwd).isDirectory()) {
        return cwd;
      }
      return process.cwd();
    }
    on(event, listener) {
      if (event === "beforeExit") {
        this.beforeExitListener = listener;
      } else {
        this.logEmitter.on(event, listener);
      }
    }
    async emitExit() {
      if (this.beforeExitListener) {
        try {
          await this.beforeExitListener();
        } catch (e) {
          console.error(e);
        }
      }
    }
    async getPlatform() {
      if (this.platformPromise) {
        return this.platformPromise;
      }
      this.platformPromise = (0, import_get_platform.getPlatform)();
      return this.platformPromise;
    }
    getQueryEnginePath(platform, prefix = __dirname) {
      let queryEnginePath = import_path.default.join(prefix, `query-engine-${platform}`);
      if (platform === "windows") {
        queryEnginePath = `${queryEnginePath}.exe`;
      }
      return queryEnginePath;
    }
    handlePanic() {
      var _a, _b;
      (_a = this.child) == null ? void 0 : _a.kill();
      if ((_b = this.currentRequestPromise) == null ? void 0 : _b.cancel) {
        this.currentRequestPromise.cancel();
      }
    }
    async resolvePrismaPath() {
      var _a, _b, _c;
      const searchedLocations = [];
      let enginePath;
      if (this.prismaPath) {
        return {prismaPath: this.prismaPath, searchedLocations};
      }
      const platform = await this.getPlatform();
      if (this.platform && this.platform !== platform) {
        this.incorrectlyPinnedBinaryTarget = this.platform;
      }
      this.platform = this.platform || platform;
      if (__filename.includes("BinaryEngine")) {
        enginePath = this.getQueryEnginePath(this.platform, (0, import_engines.getEnginesPath)());
        return {prismaPath: enginePath, searchedLocations};
      }
      const searchLocations = [
        eval(`require('path').join(__dirname, '../../../.prisma/client')`),
        (_c = (_b = (_a = this.generator) == null ? void 0 : _a.output) == null ? void 0 : _b.value) != null ? _c : eval("__dirname"),
        import_path.default.join(eval("__dirname"), ".."),
        import_path.default.dirname(this.datamodelPath),
        this.cwd,
        "/tmp/prisma-engines"
      ];
      if (this.dirname) {
        searchLocations.push(this.dirname);
      }
      for (const location of searchLocations) {
        searchedLocations.push(location);
        debug(`Search for Query Engine in ${location}`);
        enginePath = this.getQueryEnginePath(this.platform, location);
        if (import_fs.default.existsSync(enginePath)) {
          return {prismaPath: enginePath, searchedLocations};
        }
      }
      enginePath = this.getQueryEnginePath(this.platform);
      return {prismaPath: enginePath != null ? enginePath : "", searchedLocations};
    }
    async getPrismaPath() {
      const {prismaPath, searchedLocations} = await this.resolvePrismaPath();
      const platform = await this.getPlatform();
      if (!await exists(prismaPath)) {
        const pinnedStr = this.incorrectlyPinnedBinaryTarget ? `
You incorrectly pinned it to ${import_chalk.default.redBright.bold(`${this.incorrectlyPinnedBinaryTarget}`)}
` : "";
        let errorText = `Query engine binary for current platform "${import_chalk.default.bold(platform)}" could not be found.${pinnedStr}
This probably happens, because you built Prisma Client on a different platform.
(Prisma Client looked in "${import_chalk.default.underline(prismaPath)}")

Searched Locations:

${searchedLocations.map((f) => {
          let msg = `  ${f}`;
          if (process.env.DEBUG === "node-engine-search-locations" && import_fs.default.existsSync(f)) {
            const dir = import_fs.default.readdirSync(f);
            msg += dir.map((d2) => `    ${d2}`).join("\n");
          }
          return msg;
        }).join("\n" + (process.env.DEBUG === "node-engine-search-locations" ? "\n" : ""))}
`;
        if (this.generator) {
          if (this.generator.binaryTargets.find((object) => object.value === this.platform) || this.generator.binaryTargets.find((object) => object.value === "native")) {
            errorText += `
You already added the platform${this.generator.binaryTargets.length > 1 ? "s" : ""} ${this.generator.binaryTargets.map((t) => `"${import_chalk.default.bold(t.value)}"`).join(", ")} to the "${import_chalk.default.underline("generator")}" block
in the "schema.prisma" file as described in https://pris.ly/d/client-generator,
but something went wrong. That's suboptimal.

Please create an issue at https://github.com/prisma/prisma/issues/new`;
            errorText += ``;
          } else {
            errorText += `

To solve this problem, add the platform "${this.platform}" to the "${import_chalk.default.underline("binaryTargets")}" attribute in the "${import_chalk.default.underline("generator")}" block in the "schema.prisma" file:
${import_chalk.default.greenBright(this.getFixedGenerator())}

Then run "${import_chalk.default.greenBright("prisma generate")}" for your changes to take effect.
Read more about deploying Prisma Client: https://pris.ly/d/client-generator`;
          }
        } else {
          errorText += `

Read more about deploying Prisma Client: https://pris.ly/d/client-generator
`;
        }
        throw new import_PrismaClientInitializationError.PrismaClientInitializationError(errorText, this.clientVersion);
      }
      if (this.incorrectlyPinnedBinaryTarget) {
        console.error(`${import_chalk.default.yellow("Warning:")} You pinned the platform ${import_chalk.default.bold(this.incorrectlyPinnedBinaryTarget)}, but Prisma Client detects ${import_chalk.default.bold(await this.getPlatform())}.
This means you should very likely pin the platform ${import_chalk.default.greenBright(await this.getPlatform())} instead.
${import_chalk.default.dim("In case we're mistaken, please report this to us \u{1F64F}.")}`);
      }
      if (process.platform !== "win32") {
        (0, import_util2.plusX)(prismaPath);
      }
      return prismaPath;
    }
    getFixedGenerator() {
      const fixedGenerator = {
        ...this.generator,
        binaryTargets: (0, import_util2.fixBinaryTargets)(this.generator.binaryTargets, this.platform)
      };
      return (0, import_printGeneratorConfig.printGeneratorConfig)(fixedGenerator);
    }
    printDatasources() {
      if (this.datasources) {
        return JSON.stringify(this.datasources);
      }
      return "[]";
    }
    async start() {
      if (this.stopPromise) {
        await this.stopPromise;
      }
      if (!this.startPromise) {
        this.startCount++;
        this.startPromise = this.internalStart();
      }
      await this.startPromise;
      if (!this.child && !this.engineEndpoint) {
        throw new import_PrismaClientUnknownRequestError.PrismaClientUnknownRequestError(`Can't perform request, as the Engine has already been stopped`, this.clientVersion);
      }
      return this.startPromise;
    }
    getEngineEnvVars() {
      const env2 = {
        PRISMA_DML_PATH: this.datamodelPath,
        RUST_BACKTRACE: "1",
        RUST_LOG: "info"
      };
      if (this.logQueries || this.logLevel === "info") {
        env2.RUST_LOG = "info";
        if (this.logQueries) {
          env2.LOG_QUERIES = "true";
        }
      }
      if (this.datasources) {
        env2.OVERWRITE_DATASOURCES = this.printDatasources();
      }
      if (!process.env.NO_COLOR && this.showColors) {
        env2.CLICOLOR_FORCE = "1";
      }
      return {
        ...this.env,
        ...process.env,
        ...env2
      };
    }
    internalStart() {
      return new Promise(async (resolve, reject) => {
        var _a, _b, _c;
        await new Promise((r) => process.nextTick(r));
        if (this.stopPromise) {
          await this.stopPromise;
        }
        if (this.engineEndpoint) {
          try {
            await (0, import_p_retry.default)(() => this.connection.get("/"), {
              retries: 10
            });
          } catch (e) {
            return reject(e);
          }
          return resolve();
        }
        try {
          if (((_a = this.child) == null ? void 0 : _a.connected) || this.child && !((_b = this.child) == null ? void 0 : _b.killed)) {
            debug(`There is a child that still runs and we want to start again`);
          }
          this.lastRustError = void 0;
          this.lastErrorLog = void 0;
          this.lastPanic = void 0;
          logger("startin & resettin");
          this.globalKillSignalReceived = void 0;
          if (this.useUds) {
            this.socketPath = `/tmp/prisma-${(0, import_util2.getRandomString)()}.sock`;
            socketPaths.push(this.socketPath);
          }
          debug({cwd: this.cwd});
          const prismaPath = await this.getPrismaPath();
          const debugFlag = this.enableEngineDebugMode ? ["--debug"] : [];
          const flags = [...debugFlag, "--enable-raw-queries", ...this.flags];
          if (this.useUds) {
            flags.push("--unix-path", this.socketPath);
          } else {
            this.port = await this.getFreePort();
            flags.push("--port", String(this.port));
          }
          debug({flags});
          const env2 = this.getEngineEnvVars();
          this.child = (0, import_child_process.spawn)(prismaPath, flags, {
            env: env2,
            cwd: this.cwd,
            windowsHide: true,
            stdio: ["ignore", "pipe", "pipe"]
          });
          (0, import_byline.default)(this.child.stderr).on("data", (msg) => {
            const data = String(msg);
            debug("stderr", data);
            try {
              const json = JSON.parse(data);
              if (typeof json.is_panic !== "undefined") {
                debug(json);
                this.setError(json);
                if (this.engineStartDeferred) {
                  const err = new import_PrismaClientInitializationError.PrismaClientInitializationError(json.message, this.clientVersion);
                  this.engineStartDeferred.reject(err);
                }
              }
            } catch (e) {
              if (!data.includes("Printing to stderr") && !data.includes("Listening on ")) {
                this.stderrLogs += "\n" + data;
              }
            }
          });
          (0, import_byline.default)(this.child.stdout).on("data", (msg) => {
            var _a2, _b2;
            const data = String(msg);
            try {
              const json = JSON.parse(data);
              debug("stdout", (0, import_log.getMessage)(json));
              if (this.engineStartDeferred && json.level === "INFO" && json.target === "query_engine::server" && ((_b2 = (_a2 = json.fields) == null ? void 0 : _a2.message) == null ? void 0 : _b2.startsWith("Started http server"))) {
                if (this.useUds) {
                  this.connection.open("http://localhost", {
                    socketPath: this.socketPath
                  });
                } else {
                  this.connection.open(`http://localhost:${this.port}`);
                }
                this.engineStartDeferred.resolve();
                this.engineStartDeferred = void 0;
              }
              if (typeof json.is_panic === "undefined") {
                const log3 = (0, import_log.convertLog)(json);
                const logIsRustErrorLog = (0, import_log.isRustErrorLog)(log3);
                if (logIsRustErrorLog) {
                  this.setError(log3);
                } else {
                  this.logEmitter.emit(log3.level, log3);
                }
              } else {
                this.setError(json);
              }
            } catch (e) {
              debug(e, data);
            }
          });
          this.child.on("exit", (code) => {
            var _a2;
            logger("removing startPromise");
            this.startPromise = void 0;
            if (this.engineStopDeferred) {
              this.engineStopDeferred.resolve(code);
              return;
            }
            this.connection.close();
            if (code !== 0 && this.engineStartDeferred && this.startCount === 1) {
              let err;
              let msg = this.stderrLogs;
              if (this.lastRustError) {
                msg = (0, import_log.getMessage)(this.lastRustError);
              } else if (this.lastErrorLog) {
                msg = (0, import_log.getMessage)(this.lastErrorLog);
              }
              if (code !== null) {
                err = new import_PrismaClientInitializationError.PrismaClientInitializationError(`Query engine exited with code ${code}
` + msg, this.clientVersion);
              } else if ((_a2 = this.child) == null ? void 0 : _a2.signalCode) {
                err = new import_PrismaClientInitializationError.PrismaClientInitializationError(`Query engine process killed with signal ${this.child.signalCode} for unknown reason.
Make sure that the engine binary at ${prismaPath} is not corrupt.
` + msg, this.clientVersion);
              } else {
                err = new import_PrismaClientInitializationError.PrismaClientInitializationError(msg, this.clientVersion);
              }
              this.engineStartDeferred.reject(err);
            }
            if (!this.child) {
              return;
            }
            if (this.lastRustError) {
              return;
            }
            if (code === 126) {
              this.setError({
                timestamp: new Date(),
                target: "exit",
                level: "error",
                fields: {
                  message: `Couldn't start query engine as it's not executable on this operating system.
You very likely have the wrong "binaryTarget" defined in the schema.prisma file.`
                }
              });
            }
          });
          this.child.on("error", (err) => {
            this.setError({
              message: err.message,
              backtrace: "Could not start query engine",
              is_panic: false
            });
            reject(err);
          });
          this.child.on("close", (code, signal) => {
            var _a2;
            this.connection.close();
            if (code === null && signal === "SIGABRT" && this.child) {
              const error = new import_PrismaClientRustPanicError.PrismaClientRustPanicError(this.getErrorMessageWithLink("Panic in Query Engine with SIGABRT signal"), this.clientVersion);
              this.logEmitter.emit("error", error);
            } else if (code === 255 && signal === null && ((_a2 = this.lastErrorLog) == null ? void 0 : _a2.fields.message) === "PANIC" && !this.lastPanic) {
              const error = new import_PrismaClientRustPanicError.PrismaClientRustPanicError(this.getErrorMessageWithLink(`${this.lastErrorLog.fields.message}: ${this.lastErrorLog.fields.reason} in ${this.lastErrorLog.fields.file}:${this.lastErrorLog.fields.line}:${this.lastErrorLog.fields.column}`), this.clientVersion);
              this.setError(error);
            }
          });
          if (this.lastRustError) {
            return reject(new import_PrismaClientInitializationError.PrismaClientInitializationError((0, import_log.getMessage)(this.lastRustError), this.clientVersion));
          }
          if (this.lastErrorLog) {
            return reject(new import_PrismaClientInitializationError.PrismaClientInitializationError((0, import_log.getMessage)(this.lastErrorLog), this.clientVersion));
          }
          try {
            await new Promise((resolve2, reject2) => {
              this.engineStartDeferred = {resolve: resolve2, reject: reject2};
            });
          } catch (err) {
            (_c = this.child) == null ? void 0 : _c.kill();
            throw err;
          }
          void (async () => {
            try {
              const engineVersion = await this.version(true);
              debug(`Client Version: ${this.clientVersion}`);
              debug(`Engine Version: ${engineVersion}`);
              debug(`Active provider: ${this.activeProvider}`);
            } catch (e) {
              debug(e);
            }
          })();
          this.stopPromise = void 0;
          resolve();
        } catch (e) {
          reject(e);
        }
      });
    }
    async stop() {
      if (!this.stopPromise) {
        this.stopPromise = this._stop();
      }
      return this.stopPromise;
    }
    async _stop() {
      var _a;
      if (this.startPromise) {
        await this.startPromise;
      }
      await new Promise((resolve) => process.nextTick(resolve));
      if (this.currentRequestPromise) {
        try {
          await this.currentRequestPromise;
        } catch (e) {
        }
      }
      this.getConfigPromise = void 0;
      let stopChildPromise;
      if (this.child) {
        debug(`Stopping Prisma engine4`);
        if (this.startPromise) {
          debug(`Waiting for start promise`);
          await this.startPromise;
        }
        debug(`Done waiting for start promise`);
        stopChildPromise = new Promise((resolve, reject) => {
          this.engineStopDeferred = {resolve, reject};
        });
        this.connection.close();
        (_a = this.child) == null ? void 0 : _a.kill();
        this.child = void 0;
      }
      if (stopChildPromise) {
        await stopChildPromise;
      }
      await new Promise((r) => process.nextTick(r));
      this.startPromise = void 0;
      this.engineStopDeferred = void 0;
    }
    kill(signal) {
      var _a;
      this.getConfigPromise = void 0;
      this.globalKillSignalReceived = signal;
      (_a = this.child) == null ? void 0 : _a.kill();
      this.connection.close();
    }
    getFreePort() {
      return new Promise((resolve, reject) => {
        const server = import_net.default.createServer((s2) => s2.end(""));
        server.unref();
        server.on("error", reject);
        server.listen(0, () => {
          const address = server.address();
          const port = typeof address === "string" ? parseInt(address.split(":").slice(-1)[0], 10) : address.port;
          server.close((e) => {
            if (e) {
              reject(e);
            }
            resolve(port);
          });
        });
      });
    }
    async getConfig() {
      if (!this.getConfigPromise) {
        this.getConfigPromise = this._getConfig();
      }
      return this.getConfigPromise;
    }
    async _getConfig() {
      const prismaPath = await this.getPrismaPath();
      const env2 = await this.getEngineEnvVars();
      const result = await (0, import_execa.default)(prismaPath, ["cli", "get-config"], {
        env: (0, import_omit.omit)(env2, ["PORT"]),
        cwd: this.cwd
      });
      return JSON.parse(result.stdout);
    }
    async version(forceRun = false) {
      if (this.versionPromise && !forceRun) {
        return this.versionPromise;
      }
      this.versionPromise = this.internalVersion();
      return this.versionPromise;
    }
    async internalVersion() {
      const prismaPath = await this.getPrismaPath();
      const result = await (0, import_execa.default)(prismaPath, ["--version"]);
      this.lastVersion = result.stdout;
      return this.lastVersion;
    }
    async request(query, headers = {}, numTry = 1) {
      await this.start();
      this.currentRequestPromise = this.connection.post("/", stringifyQuery(query), runtimeHeadersToHttpHeaders(headers));
      this.lastQuery = query;
      try {
        const {data, headers: headers2} = await this.currentRequestPromise;
        if (data.errors) {
          if (data.errors.length === 1) {
            throw this.graphQLToJSError(data.errors[0]);
          }
          throw new import_PrismaClientUnknownRequestError.PrismaClientUnknownRequestError(JSON.stringify(data.errors), this.clientVersion);
        }
        const elapsed = parseInt(headers2["x-elapsed"]) / 1e3;
        if (this.startCount > 0) {
          this.startCount = 0;
        }
        this.currentRequestPromise = void 0;
        return {data, elapsed};
      } catch (error) {
        logger("req - e", error);
        if (error instanceof import_PrismaClientKnownRequestError.PrismaClientKnownRequestError) {
          throw error;
        }
        await this.handleRequestError(error, numTry <= MAX_REQUEST_RETRIES);
        if (numTry <= MAX_REQUEST_RETRIES) {
          logger("trying a retry now");
          return this.request(query, headers, numTry + 1);
        }
      }
      return null;
    }
    async requestBatch(queries, headers = {}, transaction = false, numTry = 1) {
      await this.start();
      const request = {
        batch: queries.map((query) => ({query, variables: {}})),
        transaction
      };
      this.lastQuery = JSON.stringify(request);
      this.currentRequestPromise = this.connection.post("/", this.lastQuery, runtimeHeadersToHttpHeaders(headers));
      return this.currentRequestPromise.then(({data, headers: headers2}) => {
        const elapsed = parseInt(headers2["x-elapsed"]) / 1e3;
        const {batchResult, errors} = data;
        if (Array.isArray(batchResult)) {
          return batchResult.map((result) => {
            if (result.errors) {
              throw this.graphQLToJSError(result.errors[0]);
            }
            return {
              data: result,
              elapsed
            };
          });
        } else {
          throw this.graphQLToJSError(errors[0]);
        }
      }).catch(async (e) => {
        const isError2 = await this.handleRequestError(e, numTry < 3);
        if (!isError2) {
          if (numTry <= MAX_REQUEST_RETRIES) {
            return this.requestBatch(queries, headers, transaction, numTry + 1);
          }
        }
        throw isError2;
      });
    }
    async transaction(action, arg2) {
      var _a, _b;
      await this.start();
      try {
        if (action === "start") {
          const jsonOptions = JSON.stringify({
            max_wait: (_a = arg2 == null ? void 0 : arg2.maxWait) != null ? _a : 2e3,
            timeout: (_b = arg2 == null ? void 0 : arg2.timeout) != null ? _b : 5e3
          });
          const result = await import_Connection.Connection.onHttpError(this.connection.post("/transaction/start", jsonOptions), transactionHttpErrorHandler);
          return result.data;
        } else if (action === "commit") {
          await import_Connection.Connection.onHttpError(this.connection.post(`/transaction/${arg2.id}/commit`), transactionHttpErrorHandler);
        } else if (action === "rollback") {
          await import_Connection.Connection.onHttpError(this.connection.post(`/transaction/${arg2.id}/rollback`), transactionHttpErrorHandler);
        }
      } catch (error) {
        this.setError(error);
      }
      return void 0;
    }
    get hasMaxRestarts() {
      return this.startCount >= MAX_STARTS;
    }
    throwAsyncErrorIfExists(forceThrow = false) {
      var _a, _b;
      logger("throwAsyncErrorIfExists", this.startCount, this.hasMaxRestarts);
      if (this.lastRustError) {
        const err = new import_PrismaClientRustPanicError.PrismaClientRustPanicError(this.getErrorMessageWithLink((0, import_log.getMessage)(this.lastRustError)), this.clientVersion);
        if (this.lastRustError.is_panic) {
          this.lastPanic = err;
        }
        if (this.hasMaxRestarts || forceThrow) {
          throw err;
        }
      }
      if (this.lastErrorLog && (0, import_log.isRustErrorLog)(this.lastErrorLog)) {
        const err = new import_PrismaClientUnknownRequestError.PrismaClientUnknownRequestError(this.getErrorMessageWithLink((0, import_log.getMessage)(this.lastErrorLog)), this.clientVersion);
        if (((_b = (_a = this.lastErrorLog) == null ? void 0 : _a.fields) == null ? void 0 : _b.message) === "PANIC") {
          this.lastPanic = err;
        }
        if (this.hasMaxRestarts || forceThrow) {
          throw err;
        }
      }
    }
    getErrorMessageWithLink(title) {
      return (0, import_getErrorMessageWithLink.getErrorMessageWithLink)({
        platform: this.platform,
        title,
        version: this.clientVersion,
        engineVersion: this.lastVersion,
        database: this.lastActiveProvider,
        query: this.lastQuery
      });
    }
    graphQLToJSError(error) {
      if (error.user_facing_error.error_code) {
        return new import_PrismaClientKnownRequestError.PrismaClientKnownRequestError(error.user_facing_error.message, error.user_facing_error.error_code, this.clientVersion, error.user_facing_error.meta);
      }
      return new import_PrismaClientUnknownRequestError.PrismaClientUnknownRequestError(error.user_facing_error.message, this.clientVersion);
    }
  };
  function stringifyQuery(q) {
    return `{"variables":{},"query":${JSON.stringify(q)}}`;
  }
  function hookProcess(handler, exit = false) {
    process.once(handler, async () => {
      for (const engine of engines) {
        await engine.emitExit();
        engine.kill(handler);
      }
      engines.splice(0, engines.length);
      if (socketPaths.length > 0) {
        for (const socketPath of socketPaths) {
          try {
            import_fs.default.unlinkSync(socketPath);
          } catch (e) {
          }
        }
      }
      if (exit && process.listenerCount(handler) === 0) {
        process.exit();
      }
    });
  }
  var hooksInitialized = false;
  function initHooks() {
    if (!hooksInitialized) {
      hookProcess("beforeExit");
      hookProcess("exit");
      hookProcess("SIGINT", true);
      hookProcess("SIGUSR1", true);
      hookProcess("SIGUSR2", true);
      hookProcess("SIGTERM", true);
      hooksInitialized = true;
    }
  }
  function transactionHttpErrorHandler(result) {
    throw result.data;
  }
  function runtimeHeadersToHttpHeaders(headers) {
    return Object.keys(headers).reduce((acc, runtimeHeaderKey) => {
      let httpHeaderKey = runtimeHeaderKey;
      if (runtimeHeaderKey === "transactionId") {
        httpHeaderKey = "X-transaction-id";
      }
      acc[httpHeaderKey] = headers[runtimeHeaderKey];
      return acc;
    }, {});
  }
});

// ../engine-core/dist/library/types/Library.js
var require_Library = __commonJS2((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  __markAsModule3(exports2);
});

// ../engine-core/dist/common/utils/getInternalDatamodelJson.js
var require_getInternalDatamodelJson = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    getInternalDatamodelJson: () => getInternalDatamodelJson2
  });
  var import_path4 = __toModule3(require("path"));
  var import_child_process2 = __toModule3(require("child_process"));
  var import_byline2 = __toModule3(require_byline2());
  function getInternalDatamodelJson2(datamodel, schemaInferrerPath = import_path4.default.join(__dirname, "../schema-inferrer-bin")) {
    return new Promise((resolve, reject) => {
      const proc = (0, import_child_process2.spawn)(schemaInferrerPath, {
        stdio: ["pipe", "pipe", process.stderr]
      });
      proc.on("error", function(err) {
        console.error("[schema-inferrer-bin] error: %s", err);
        reject(err);
      });
      proc.on("exit", function(code, signal) {
        if (code !== 0) {
          console.error("[schema-inferrer-bin] exit: code=%s signal=%s", code, signal);
        }
        reject();
      });
      const out = (0, import_byline2.default)(proc.stdout);
      out.on("data", (line) => {
        const result = JSON.parse(line);
        const resultB64 = Buffer.from(JSON.stringify(result)).toString("base64");
        resolve(resultB64);
      });
      const cut = datamodel.replace(/\n/g, " ");
      proc.stdin.write(JSON.stringify({dataModel: cut}) + "\n");
    });
  }
});

// ../engine-core/dist/index.js
var require_dist17 = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    BinaryEngine: () => import_BinaryEngine.BinaryEngine,
    DatasourceOverwrite: () => import_Engine4.DatasourceOverwrite,
    Engine: () => import_Engine2.Engine,
    EngineConfig: () => import_Engine22.EngineConfig,
    EngineEventType: () => import_Engine3.EngineEventType,
    LibraryEngine: () => import_LibraryEngine.LibraryEngine,
    NodeAPILibraryTypes: () => NodeAPILibraryTypes,
    PrismaClientInitializationError: () => import_PrismaClientInitializationError2.PrismaClientInitializationError,
    PrismaClientKnownRequestError: () => import_PrismaClientKnownRequestError2.PrismaClientKnownRequestError,
    PrismaClientRustPanicError: () => import_PrismaClientRustPanicError2.PrismaClientRustPanicError,
    PrismaClientUnknownRequestError: () => import_PrismaClientUnknownRequestError2.PrismaClientUnknownRequestError,
    fixBinaryTargets: () => import_util3.fixBinaryTargets,
    getInternalDatamodelJson: () => import_getInternalDatamodelJson.getInternalDatamodelJson,
    getOriginalBinaryTargetsValue: () => import_printGeneratorConfig2.getOriginalBinaryTargetsValue,
    plusX: () => import_util22.plusX,
    printGeneratorConfig: () => import_printGeneratorConfig2.printGeneratorConfig
  });
  var import_PrismaClientInitializationError2 = __toModule3(require_PrismaClientInitializationError());
  var import_PrismaClientKnownRequestError2 = __toModule3(require_PrismaClientKnownRequestError());
  var import_PrismaClientRustPanicError2 = __toModule3(require_PrismaClientRustPanicError());
  var import_PrismaClientUnknownRequestError2 = __toModule3(require_PrismaClientUnknownRequestError());
  var import_Engine2 = __toModule3(require_Engine());
  var import_Engine22 = __toModule3(require_Engine());
  var import_Engine3 = __toModule3(require_Engine());
  var import_Engine4 = __toModule3(require_Engine());
  var import_LibraryEngine = __toModule3(require_LibraryEngine());
  var import_BinaryEngine = __toModule3(require_BinaryEngine());
  var NodeAPILibraryTypes = __toModule3(require_Library());
  var import_printGeneratorConfig2 = __toModule3(require_printGeneratorConfig());
  var import_getInternalDatamodelJson = __toModule3(require_getInternalDatamodelJson());
  var import_util3 = __toModule3(require_util5());
  var import_util22 = __toModule3(require_util5());
});

// ../sdk/dist/resolveBinary.js
var require_resolveBinary = __commonJS2((exports, module) => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name in all)
      __defProp(target, name, {get: all[name], enumerable: true});
  };
  var __reExport = (target, module2, desc) => {
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
      for (let key of __getOwnPropNames(module2))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule = (module2) => {
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
  };
  __export(exports, {
    BinaryType: () => import_fetch_engine.BinaryType,
    engineEnvVarMap: () => engineEnvVarMap,
    maybeCopyToTmp: () => maybeCopyToTmp,
    resolveBinary: () => resolveBinary
  });
  var import_debug = __toModule(require_dist7());
  var import_engine_core = __toModule(require_dist17());
  var import_engines = __toModule(require_dist16());
  var import_fetch_engine = __toModule(require_dist15());
  var import_get_platform = __toModule(require_dist11());
  var import_fs = __toModule(require("fs"));
  var import_make_dir = __toModule(require_make_dir2());
  var import_path = __toModule(require("path"));
  var import_temp_dir = __toModule(require_temp_dir2());
  var import_util = __toModule(require("util"));
  var readFile = (0, import_util.promisify)(import_fs.default.readFile);
  var writeFile = (0, import_util.promisify)(import_fs.default.writeFile);
  var debug = (0, import_debug.default)("prisma:resolveBinary");
  var engineEnvVarMap = {
    [import_fetch_engine.BinaryType.queryEngine]: "PRISMA_QUERY_ENGINE_BINARY",
    [import_fetch_engine.BinaryType.libqueryEngine]: "PRISMA_QUERY_ENGINE_LIBRARY",
    [import_fetch_engine.BinaryType.migrationEngine]: "PRISMA_MIGRATION_ENGINE_BINARY",
    [import_fetch_engine.BinaryType.introspectionEngine]: "PRISMA_INTROSPECTION_ENGINE_BINARY",
    [import_fetch_engine.BinaryType.prismaFmt]: "PRISMA_FMT_BINARY"
  };
  async function resolveBinary(name, proposedPath) {
    if (proposedPath && !proposedPath.startsWith("/snapshot/") && import_fs.default.existsSync(proposedPath)) {
      return proposedPath;
    }
    const envVar = engineEnvVarMap[name];
    if (process.env[envVar]) {
      if (!import_fs.default.existsSync(process.env[envVar])) {
        throw new Error(`Env var ${envVar} is provided, but provided path ${process.env[envVar]} can't be resolved.`);
      }
      return process.env[envVar];
    }
    const dir = eval("__dirname");
    const platform = await (0, import_get_platform.getPlatform)();
    const extension = platform === "windows" ? ".exe" : "";
    let binaryName = `${name}-${platform}${extension}`;
    if (name === import_fetch_engine.BinaryType.libqueryEngine) {
      binaryName = (0, import_get_platform.getNodeAPIName)(platform, "fs");
      if (!import_fs.default.existsSync(import_path.default.join((0, import_engines.getEnginesPath)(), binaryName))) {
        debug("Downloading Node-API Library");
        await (0, import_fetch_engine.download)({
          binaries: {
            "libquery-engine": (0, import_engines.getEnginesPath)()
          },
          version: import_engines.enginesVersion
        });
      }
    }
    let prismaPath = import_path.default.join((0, import_engines.getEnginesPath)(), binaryName);
    if (import_fs.default.existsSync(prismaPath)) {
      return maybeCopyToTmp(prismaPath);
    }
    prismaPath = import_path.default.join(__dirname, "..", binaryName);
    if (import_fs.default.existsSync(prismaPath)) {
      return maybeCopyToTmp(prismaPath);
    }
    prismaPath = import_path.default.join(__dirname, "../..", binaryName);
    if (import_fs.default.existsSync(prismaPath)) {
      return maybeCopyToTmp(prismaPath);
    }
    prismaPath = import_path.default.join(__dirname, "../runtime", binaryName);
    if (import_fs.default.existsSync(prismaPath)) {
      return maybeCopyToTmp(prismaPath);
    }
    throw new Error(`Could not find ${name} binary. Searched in ${import_path.default.join(dir, "..", binaryName)} and ${import_path.default.join(dir, "../..", binaryName)}`);
  }
  async function maybeCopyToTmp(file) {
    const dir = eval("__dirname");
    if (dir.startsWith("/snapshot/")) {
      const targetDir = import_path.default.join(import_temp_dir.default, "prisma-binaries");
      await (0, import_make_dir.default)(targetDir);
      const target = import_path.default.join(targetDir, import_path.default.basename(file));
      const data = await readFile(file);
      await writeFile(target, data);
      (0, import_engine_core.plusX)(target);
      return target;
    }
    return file;
  }
});

// ../sdk/dist/engine-commands/formatSchema.js
var require_formatSchema = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    formatSchema: () => formatSchema2
  });
  var import_debug3 = __toModule3(require_dist7());
  var import_fetch_engine2 = __toModule3(require_dist15());
  var import_execa2 = __toModule3(require_execa2());
  var import_fs2 = __toModule3(require("fs"));
  var import_resolveBinary = __toModule3(require_resolveBinary());
  var debug4 = (0, import_debug3.default)("prisma:formatSchema");
  var MAX_BUFFER = 1e9;
  async function formatSchema2({
    schemaPath,
    schema
  }) {
    if (!schema && !schemaPath) {
      throw new Error(`Parameter schema or schemaPath must be passed.`);
    }
    const prismaFmtPath = await (0, import_resolveBinary.resolveBinary)(import_fetch_engine2.BinaryType.prismaFmt);
    const showColors = !process.env.NO_COLOR && process.stdout.isTTY;
    const options = {
      env: {
        RUST_BACKTRACE: "1",
        ...showColors ? {CLICOLOR_FORCE: "1"} : {}
      },
      maxBuffer: MAX_BUFFER
    };
    let result;
    if (schemaPath) {
      if (!import_fs2.default.existsSync(schemaPath)) {
        throw new Error(`Schema at ${schemaPath} does not exist.`);
      }
      result = await (0, import_execa2.default)(prismaFmtPath, ["format", "-i", schemaPath], options);
    } else if (schema) {
      result = await (0, import_execa2.default)(prismaFmtPath, ["format"], {
        ...options,
        input: schema
      });
    }
    return result.stdout;
  }
});

// ../../node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/lib/rng.js
var require_rng = __commonJS2((exports2, module2) => {
  var crypto2 = require("crypto");
  module2.exports = function nodeRNG() {
    return crypto2.randomBytes(16);
  };
});

// ../../node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/lib/bytesToUuid.js
var require_bytesToUuid = __commonJS2((exports2, module2) => {
  var byteToHex2 = [];
  for (var i = 0; i < 256; ++i) {
    byteToHex2[i] = (i + 256).toString(16).substr(1);
  }
  function bytesToUuid(buf, offset) {
    var i2 = offset || 0;
    var bth = byteToHex2;
    return [
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]]
    ].join("");
  }
  module2.exports = bytesToUuid;
});

// ../../node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/v1.js
var require_v1 = __commonJS2((exports2, module2) => {
  var rng2 = require_rng();
  var bytesToUuid = require_bytesToUuid();
  var _nodeId;
  var _clockseq;
  var _lastMSecs = 0;
  var _lastNSecs = 0;
  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];
    options = options || {};
    var node = options.node || _nodeId;
    var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
    if (node == null || clockseq == null) {
      var seedBytes = rng2();
      if (node == null) {
        node = _nodeId = [
          seedBytes[0] | 1,
          seedBytes[1],
          seedBytes[2],
          seedBytes[3],
          seedBytes[4],
          seedBytes[5]
        ];
      }
      if (clockseq == null) {
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
      }
    }
    var msecs = options.msecs !== void 0 ? options.msecs : new Date().getTime();
    var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
    var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options.clockseq === void 0) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 122192928e5;
    var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b[i++] = tl >>> 24 & 255;
    b[i++] = tl >>> 16 & 255;
    b[i++] = tl >>> 8 & 255;
    b[i++] = tl & 255;
    var tmh = msecs / 4294967296 * 1e4 & 268435455;
    b[i++] = tmh >>> 8 & 255;
    b[i++] = tmh & 255;
    b[i++] = tmh >>> 24 & 15 | 16;
    b[i++] = tmh >>> 16 & 255;
    b[i++] = clockseq >>> 8 | 128;
    b[i++] = clockseq & 255;
    for (var n = 0; n < 6; ++n) {
      b[i + n] = node[n];
    }
    return buf ? buf : bytesToUuid(b);
  }
  module2.exports = v1;
});

// ../../node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/v4.js
var require_v4 = __commonJS2((exports2, module2) => {
  var rng2 = require_rng();
  var bytesToUuid = require_bytesToUuid();
  function v42(options, buf, offset) {
    var i = buf && offset || 0;
    if (typeof options == "string") {
      buf = options === "binary" ? new Array(16) : null;
      options = null;
    }
    options = options || {};
    var rnds = options.random || (options.rng || rng2)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      for (var ii = 0; ii < 16; ++ii) {
        buf[i + ii] = rnds[ii];
      }
    }
    return buf || bytesToUuid(rnds);
  }
  module2.exports = v42;
});

// ../../node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/index.js
var require_uuid = __commonJS2((exports2, module2) => {
  var v1 = require_v1();
  var v42 = require_v4();
  var uuid = v42;
  uuid.v1 = v1;
  uuid.v4 = v42;
  module2.exports = uuid;
});

// ../../node_modules/.pnpm/temp-dir@1.0.0/node_modules/temp-dir/index.js
var require_temp_dir3 = __commonJS2((exports2, module2) => {
  "use strict";
  var fs2 = require("fs");
  var os2 = require("os");
  var ID = "__RESOLVED_TMP_DIR__";
  if (!global[ID]) {
    Object.defineProperty(global, ID, {
      value: fs2.realpathSync(os2.tmpdir())
    });
  }
  module2.exports = global[ID];
});

// ../../node_modules/.pnpm/temp-write@4.0.0/node_modules/temp-write/index.js
var require_temp_write = __commonJS2((exports2, module2) => {
  "use strict";
  var {promisify: promisify2} = require("util");
  var path4 = require("path");
  var fs2 = require_graceful_fs2();
  var isStream = require_is_stream2();
  var makeDir2 = require_make_dir2();
  var uuid = require_uuid();
  var tempDir = require_temp_dir3();
  var writeFileP = promisify2(fs2.writeFile);
  var tempfile = (filePath) => path4.join(tempDir, uuid.v4(), filePath || "");
  var writeStream = async (filePath, fileContent) => new Promise((resolve, reject) => {
    const writable = fs2.createWriteStream(filePath);
    fileContent.on("error", (error) => {
      reject(error);
      fileContent.unpipe(writable);
      writable.end();
    }).pipe(writable).on("error", reject).on("finish", resolve);
  });
  module2.exports = async (fileContent, filePath) => {
    const tempPath = tempfile(filePath);
    const write2 = isStream(fileContent) ? writeStream : writeFileP;
    await makeDir2(path4.dirname(tempPath));
    await write2(tempPath, fileContent);
    return tempPath;
  };
  module2.exports.sync = (fileContent, filePath) => {
    const tempPath = tempfile(filePath);
    makeDir2.sync(path4.dirname(tempPath));
    fs2.writeFileSync(tempPath, fileContent);
    return tempPath;
  };
});

// ../sdk/dist/utils/load.js
var require_load = __commonJS2((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    load: () => load2
  });
  function load2(id) {
    try {
      return require(id);
    } catch (e) {
      throw new Error(`Unable to require(\`${id}\`)
 ${e.message}`);
    }
  }
});

// ../sdk/dist/engine-commands/getConfig.js
var require_getConfig = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    GetConfigError: () => GetConfigError,
    getConfig: () => getConfig2
  });
  var import_debug3 = __toModule3(require_dist7());
  var import_engines2 = __toModule3(require_dist16());
  var import_fetch_engine2 = __toModule3(require_dist15());
  var import_get_platform2 = __toModule3(require_dist11());
  var import_chalk3 = __toModule3(require_source2());
  var import_execa2 = __toModule3(require_execa2());
  var import_fs2 = __toModule3(require("fs"));
  var import_temp_write = __toModule3(require_temp_write());
  var import_util3 = __toModule3(require("util"));
  var import_resolveBinary = __toModule3(require_resolveBinary());
  var import_load = __toModule3(require_load());
  var debug4 = (0, import_debug3.default)("prisma:getConfig");
  var unlink2 = (0, import_util3.promisify)(import_fs2.default.unlink);
  var MAX_BUFFER = 1e9;
  var GetConfigError = class extends Error {
    constructor(message) {
      super(import_chalk3.default.redBright.bold("Get config: ") + message);
    }
  };
  async function getConfig2(options) {
    var _a, _b;
    const cliEngineBinaryType = (0, import_engines2.getCliQueryEngineBinaryType)();
    let data;
    if (cliEngineBinaryType === import_fetch_engine2.BinaryType.libqueryEngine) {
      data = await getConfigNodeAPI(options);
    } else {
      data = await getConfigBinary(options);
    }
    if (!data)
      throw new GetConfigError(`Failed to return any data`);
    if (((_b = (_a = data.datasources) == null ? void 0 : _a[0]) == null ? void 0 : _b.provider) === "sqlite" && data.generators.some((g) => g.previewFeatures.includes("createMany"))) {
      const message = `Database provider "sqlite" and the preview feature "createMany" can't be used at the same time.
  Please either remove the "createMany" feature flag or use any other database type that Prisma supports: postgres, mysql or sqlserver.`;
      throw new GetConfigError(message);
    }
    return data;
  }
  async function getConfigNodeAPI(options) {
    var _a;
    let data;
    const queryEnginePath = await (0, import_resolveBinary.resolveBinary)(import_fetch_engine2.BinaryType.libqueryEngine, options.prismaPath);
    await (0, import_get_platform2.isNodeAPISupported)();
    debug4(`Using Node-API Query Engine at: ${queryEnginePath}`);
    try {
      const NodeAPIQueryEngineLibrary = (0, import_load.load)(queryEnginePath);
      data = await NodeAPIQueryEngineLibrary.getConfig({
        datamodel: options.datamodel,
        datasourceOverrides: {},
        ignoreEnvVarErrors: (_a = options.ignoreEnvVarErrors) != null ? _a : false,
        env: process.env
      });
    } catch (e) {
      let error;
      try {
        error = JSON.parse(e.message);
      } catch (e2) {
        throw e;
      }
      let message;
      if (error.error_code === "P1012") {
        message = import_chalk3.default.redBright(`Schema Parsing ${error.error_code}

`) + error.message + "\n";
      } else {
        message = import_chalk3.default.redBright(`${error.error_code}

`) + error;
      }
      throw new GetConfigError(message);
    }
    return data;
  }
  async function getConfigBinary(options) {
    let data;
    const queryEnginePath = await (0, import_resolveBinary.resolveBinary)(import_fetch_engine2.BinaryType.queryEngine, options.prismaPath);
    debug4(`Using Query Engine Binary at: ${queryEnginePath}`);
    try {
      let tempDatamodelPath = options.datamodelPath;
      if (!tempDatamodelPath) {
        try {
          tempDatamodelPath = await (0, import_temp_write.default)(options.datamodel);
        } catch (err) {
          throw new GetConfigError("Unable to write temp data model path");
        }
      }
      const engineArgs = [];
      const args = options.ignoreEnvVarErrors ? ["--ignoreEnvVarErrors"] : [];
      const result = await (0, import_execa2.default)(queryEnginePath, [...engineArgs, "cli", "get-config", ...args], {
        cwd: options.cwd,
        env: {
          PRISMA_DML_PATH: tempDatamodelPath,
          RUST_BACKTRACE: "1"
        },
        maxBuffer: MAX_BUFFER
      });
      if (!options.datamodelPath) {
        await unlink2(tempDatamodelPath);
      }
      data = JSON.parse(result.stdout);
    } catch (e) {
      if (e.stderr || e.stdout) {
        const error = e.stderr ? e.stderr : e.stout;
        let jsonError, message;
        try {
          jsonError = JSON.parse(error);
          message = `${import_chalk3.default.redBright(jsonError.message)}
`;
          if (jsonError.error_code) {
            if (jsonError.error_code === "P1012") {
              message = import_chalk3.default.redBright(`Schema Parsing ${jsonError.error_code}

`) + message;
            } else {
              message = import_chalk3.default.redBright(`${jsonError.error_code}

`) + message;
            }
          }
        } catch (e2) {
          throw new GetConfigError(error);
        }
        throw new GetConfigError(message);
      }
      throw new GetConfigError(e);
    }
    return data;
  }
});

// ../sdk/dist/engine-commands/getDmmf.js
var require_getDmmf = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    getDMMF: () => getDMMF3
  });
  var import_debug3 = __toModule3(require_dist7());
  var import_engines2 = __toModule3(require_dist16());
  var import_fetch_engine2 = __toModule3(require_dist15());
  var import_get_platform2 = __toModule3(require_dist11());
  var import_chalk3 = __toModule3(require_source2());
  var import_execa2 = __toModule3(require_execa2());
  var import_fs2 = __toModule3(require("fs"));
  var import_temp_write = __toModule3(require_temp_write());
  var import_util3 = __toModule3(require("util"));
  var import_resolveBinary = __toModule3(require_resolveBinary());
  var import_load = __toModule3(require_load());
  var debug4 = (0, import_debug3.default)("prisma:getDMMF");
  var unlink2 = (0, import_util3.promisify)(import_fs2.default.unlink);
  var MAX_BUFFER = 1e9;
  async function getDMMF3(options) {
    warnOnDeprecatedFeatureFlag(options.previewFeatures);
    const cliEngineBinaryType = (0, import_engines2.getCliQueryEngineBinaryType)();
    let dmmf;
    if (cliEngineBinaryType === import_fetch_engine2.BinaryType.libqueryEngine) {
      dmmf = await getDmmfNodeAPI(options);
    } else {
      dmmf = await getDmmfBinary(options);
    }
    return dmmf;
  }
  async function getDmmfNodeAPI(options) {
    var _a;
    const queryEnginePath = await (0, import_resolveBinary.resolveBinary)(import_fetch_engine2.BinaryType.libqueryEngine, options.prismaPath);
    await (0, import_get_platform2.isNodeAPISupported)();
    debug4(`Using Node-API Query Engine at: ${queryEnginePath}`);
    const NodeAPIQueryEngineLibrary = (0, import_load.load)(queryEnginePath);
    const datamodel = (_a = options.datamodel) != null ? _a : import_fs2.default.readFileSync(options.datamodelPath, "utf-8");
    let dmmf;
    try {
      dmmf = JSON.parse(await NodeAPIQueryEngineLibrary.dmmf(datamodel));
    } catch (e) {
      const error = JSON.parse(e.message);
      const message = addMissingOpenSSLInfo(error.message);
      throw new Error(import_chalk3.default.redBright.bold("Schema parsing\n") + message);
    }
    return dmmf;
  }
  async function getDmmfBinary(options) {
    let result;
    const queryEnginePath = await (0, import_resolveBinary.resolveBinary)(import_fetch_engine2.BinaryType.queryEngine, options.prismaPath);
    debug4(`Using Query Engine Binary at: ${queryEnginePath}`);
    try {
      let tempDatamodelPath = options.datamodelPath;
      if (!tempDatamodelPath) {
        try {
          tempDatamodelPath = await (0, import_temp_write.default)(options.datamodel);
        } catch (err) {
          throw new Error(import_chalk3.default.redBright.bold("Get DMMF ") + "unable to write temp data model path");
        }
      }
      const execaOptions = {
        cwd: options.cwd,
        env: {
          PRISMA_DML_PATH: tempDatamodelPath,
          RUST_BACKTRACE: "1",
          ...process.env.NO_COLOR ? {} : {CLICOLOR_FORCE: "1"}
        },
        maxBuffer: MAX_BUFFER
      };
      const args = ["--enable-raw-queries", "cli", "dmmf"];
      result = await (0, import_execa2.default)(queryEnginePath, args, execaOptions);
      if (!options.datamodelPath) {
        await unlink2(tempDatamodelPath);
      }
      if (result.stdout.includes("Please wait until the") && options.retry && options.retry > 0) {
        debug4('Retrying after "Please wait until"');
        await new Promise((r) => setTimeout(r, 5e3));
        return getDMMF3({
          ...options,
          retry: options.retry - 1
        });
      }
      const firstCurly = result.stdout.indexOf("{");
      const stdout = result.stdout.slice(firstCurly);
      return JSON.parse(stdout);
    } catch (e) {
      debug4("getDMMF failed", e);
      if (e.message.includes("Command failed with exit code 26 (ETXTBSY)") && options.retry && options.retry > 0) {
        await new Promise((resolve) => setTimeout(resolve, 500));
        debug4("Retrying after ETXTBSY");
        return getDMMF3({
          ...options,
          retry: options.retry - 1
        });
      }
      const output = e.stderr || e.stdout;
      if (output) {
        let json;
        try {
          json = JSON.parse(output);
        } catch (e2) {
        }
        let message = json && json.message || output;
        message = addMissingOpenSSLInfo(message);
        throw new Error(import_chalk3.default.redBright.bold("Schema parsing\n") + message);
      }
      if (e.message.includes("in JSON at position")) {
        throw new Error(`Problem while parsing the query engine response at ${queryEnginePath}. ${result == null ? void 0 : result.stdout}
${e.stack}`);
      }
      throw new Error(e);
    }
  }
  function addMissingOpenSSLInfo(message) {
    if (message.includes("debian-openssl-1.1.x: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directory") || message.includes("debian-openssl-1.0.x: error while loading shared libraries: libssl.so.1.0.0: cannot open shared object file: No such file or directory")) {
      message += `
${import_chalk3.default.green(`Your linux installation misses the openssl package. You can install it like so:
`)}${import_chalk3.default.green.bold("apt-get -qy update && apt-get -qy install openssl")}`;
    }
    return message;
  }
  function warnOnDeprecatedFeatureFlag(previewFeatures) {
    const getMessage = (flag) => `${import_chalk3.default.blueBright("info")} The preview flag "${flag}" is not needed anymore, please remove it from your schema.prisma`;
    const removedFeatureFlagMap = {
      insensitiveFilters: getMessage("insensitiveFilters"),
      atomicNumberOperations: getMessage("atomicNumberOperations"),
      connectOrCreate: getMessage("connectOrCreate"),
      transaction: getMessage("transaction"),
      transactionApi: getMessage("transactionApi"),
      uncheckedScalarInputs: getMessage("uncheckedScalarInputs"),
      nativeTypes: getMessage("nativeTypes"),
      createMany: getMessage("createMany"),
      groupBy: getMessage("groupBy")
    };
    previewFeatures == null ? void 0 : previewFeatures.forEach((f) => {
      const removedMessage = removedFeatureFlagMap[f];
      if (removedMessage && !process.env.PRISMA_HIDE_PREVIEW_FLAG_WARNINGS) {
        console.warn(removedMessage);
      }
    });
  }
});

// ../sdk/dist/engine-commands/getVersion.js
var require_getVersion = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    getVersion: () => getVersion2
  });
  var import_debug3 = __toModule3(require_dist7());
  var import_engines2 = __toModule3(require_dist16());
  var import_fetch_engine2 = __toModule3(require_dist15());
  var import_get_platform2 = __toModule3(require_dist11());
  var import_execa2 = __toModule3(require_execa2());
  var import_resolveBinary = __toModule3(require_resolveBinary());
  var import_load = __toModule3(require_load());
  var debug4 = (0, import_debug3.default)("prisma:getVersion");
  var MAX_BUFFER = 1e9;
  async function getVersion2(enginePath, binaryName) {
    if (!binaryName) {
      binaryName = (0, import_engines2.getCliQueryEngineBinaryType)();
    }
    enginePath = await (0, import_resolveBinary.resolveBinary)(binaryName, enginePath);
    if (binaryName === import_fetch_engine2.BinaryType.libqueryEngine) {
      await (0, import_get_platform2.isNodeAPISupported)();
      const QE = (0, import_load.load)(enginePath);
      return `libquery-engine ${QE.version().commit}`;
    } else {
      const result = await (0, import_execa2.default)(enginePath, ["--version"], {
        maxBuffer: MAX_BUFFER
      });
      return result.stdout;
    }
  }
});

// ../sdk/dist/engine-commands/index.js
var require_engine_commands = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    ConfigMetaFormat: () => import_getConfig.ConfigMetaFormat,
    GetDMMFOptions: () => import_getDmmf2.GetDMMFOptions,
    formatSchema: () => import_formatSchema.formatSchema,
    getConfig: () => import_getConfig.getConfig,
    getDMMF: () => import_getDmmf2.getDMMF,
    getVersion: () => import_getVersion.getVersion
  });
  var import_formatSchema = __toModule3(require_formatSchema());
  var import_getConfig = __toModule3(require_getConfig());
  var import_getDmmf2 = __toModule3(require_getDmmf());
  var import_getVersion = __toModule3(require_getVersion());
});

// ../sdk/dist/Generator.js
var require_Generator = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    Generator: () => Generator2
  });
  var import_generator_helper3 = __toModule3(require_dist8());
  var Generator2 = class {
    constructor(executablePath, config2, isNode) {
      this.manifest = null;
      this.config = config2;
      this.generatorProcess = new import_generator_helper3.GeneratorProcess(executablePath, isNode);
    }
    async init() {
      await this.generatorProcess.init();
      this.manifest = await this.generatorProcess.getManifest(this.config);
    }
    stop() {
      this.generatorProcess.stop();
    }
    generate() {
      if (!this.options) {
        throw new Error(`Please first run .setOptions() on the Generator to initialize the options`);
      }
      return this.generatorProcess.generate(this.options);
    }
    setOptions(options) {
      this.options = options;
    }
    setBinaryPaths(binaryPaths) {
      if (!this.options) {
        throw new Error(`Please first run .setOptions() on the Generator to initialize the options`);
      }
      this.options.binaryPaths = binaryPaths;
    }
  };
});

// ../../node_modules/.pnpm/ini@2.0.0/node_modules/ini/ini.js
var require_ini = __commonJS2((exports2, module2) => {
  var {hasOwnProperty} = Object.prototype;
  var eol = typeof process !== "undefined" && process.platform === "win32" ? "\r\n" : "\n";
  var encode = (obj, opt) => {
    const children = [];
    let out = "";
    if (typeof opt === "string") {
      opt = {
        section: opt,
        whitespace: false
      };
    } else {
      opt = opt || Object.create(null);
      opt.whitespace = opt.whitespace === true;
    }
    const separator = opt.whitespace ? " = " : "=";
    for (const k of Object.keys(obj)) {
      const val = obj[k];
      if (val && Array.isArray(val)) {
        for (const item of val)
          out += safe(k + "[]") + separator + safe(item) + "\n";
      } else if (val && typeof val === "object")
        children.push(k);
      else
        out += safe(k) + separator + safe(val) + eol;
    }
    if (opt.section && out.length)
      out = "[" + safe(opt.section) + "]" + eol + out;
    for (const k of children) {
      const nk = dotSplit(k).join("\\.");
      const section = (opt.section ? opt.section + "." : "") + nk;
      const {whitespace} = opt;
      const child = encode(obj[k], {
        section,
        whitespace
      });
      if (out.length && child.length)
        out += eol;
      out += child;
    }
    return out;
  };
  var dotSplit = (str) => str.replace(/\1/g, "LITERAL\\1LITERAL").replace(/\\\./g, "").split(/\./).map((part) => part.replace(/\1/g, "\\.").replace(/\2LITERAL\\1LITERAL\2/g, ""));
  var decode = (str) => {
    const out = Object.create(null);
    let p = out;
    let section = null;
    const re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i;
    const lines = str.split(/[\r\n]+/g);
    for (const line of lines) {
      if (!line || line.match(/^\s*[;#]/))
        continue;
      const match = line.match(re);
      if (!match)
        continue;
      if (match[1] !== void 0) {
        section = unsafe(match[1]);
        if (section === "__proto__") {
          p = Object.create(null);
          continue;
        }
        p = out[section] = out[section] || Object.create(null);
        continue;
      }
      const keyRaw = unsafe(match[2]);
      const isArray = keyRaw.length > 2 && keyRaw.slice(-2) === "[]";
      const key = isArray ? keyRaw.slice(0, -2) : keyRaw;
      if (key === "__proto__")
        continue;
      const valueRaw = match[3] ? unsafe(match[4]) : true;
      const value = valueRaw === "true" || valueRaw === "false" || valueRaw === "null" ? JSON.parse(valueRaw) : valueRaw;
      if (isArray) {
        if (!hasOwnProperty.call(p, key))
          p[key] = [];
        else if (!Array.isArray(p[key]))
          p[key] = [p[key]];
      }
      if (Array.isArray(p[key]))
        p[key].push(value);
      else
        p[key] = value;
    }
    const remove2 = [];
    for (const k of Object.keys(out)) {
      if (!hasOwnProperty.call(out, k) || typeof out[k] !== "object" || Array.isArray(out[k]))
        continue;
      const parts = dotSplit(k);
      let p2 = out;
      const l = parts.pop();
      const nl = l.replace(/\\\./g, ".");
      for (const part of parts) {
        if (part === "__proto__")
          continue;
        if (!hasOwnProperty.call(p2, part) || typeof p2[part] !== "object")
          p2[part] = Object.create(null);
        p2 = p2[part];
      }
      if (p2 === out && nl === l)
        continue;
      p2[nl] = out[k];
      remove2.push(k);
    }
    for (const del of remove2)
      delete out[del];
    return out;
  };
  var isQuoted = (val) => val.charAt(0) === '"' && val.slice(-1) === '"' || val.charAt(0) === "'" && val.slice(-1) === "'";
  var safe = (val) => typeof val !== "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim() ? JSON.stringify(val) : val.replace(/;/g, "\\;").replace(/#/g, "\\#");
  var unsafe = (val, doUnesc) => {
    val = (val || "").trim();
    if (isQuoted(val)) {
      if (val.charAt(0) === "'")
        val = val.substr(1, val.length - 2);
      try {
        val = JSON.parse(val);
      } catch (_2) {
      }
    } else {
      let esc = false;
      let unesc = "";
      for (let i = 0, l = val.length; i < l; i++) {
        const c = val.charAt(i);
        if (esc) {
          if ("\\;#".indexOf(c) !== -1)
            unesc += c;
          else
            unesc += "\\" + c;
          esc = false;
        } else if (";#".indexOf(c) !== -1)
          break;
        else if (c === "\\")
          esc = true;
        else
          unesc += c;
      }
      if (esc)
        unesc += "\\";
      return unesc.trim();
    }
    return val;
  };
  module2.exports = {
    parse: decode,
    decode,
    stringify: encode,
    encode,
    safe,
    unsafe
  };
});

// ../../node_modules/.pnpm/global-dirs@3.0.0/node_modules/global-dirs/index.js
var require_global_dirs = __commonJS2((exports2) => {
  "use strict";
  var path4 = require("path");
  var os2 = require("os");
  var fs2 = require("fs");
  var ini = require_ini();
  var isWindows = process.platform === "win32";
  var readRc = (filePath) => {
    try {
      return ini.parse(fs2.readFileSync(filePath, "utf8")).prefix;
    } catch (e) {
    }
  };
  var getEnvNpmPrefix = () => {
    return Object.keys(process.env).reduce((prefix, name) => {
      return /^npm_config_prefix$/i.test(name) ? process.env[name] : prefix;
    }, void 0);
  };
  var getGlobalNpmrc = () => {
    if (isWindows && process.env.APPDATA) {
      return path4.join(process.env.APPDATA, "/npm/etc/npmrc");
    }
    if (process.execPath.includes("/Cellar/node")) {
      const homebrewPrefix = process.execPath.slice(0, process.execPath.indexOf("/Cellar/node"));
      return path4.join(homebrewPrefix, "/lib/node_modules/npm/npmrc");
    }
    if (process.execPath.endsWith("/bin/node")) {
      const installDir = path4.dirname(path4.dirname(process.execPath));
      return path4.join(installDir, "/etc/npmrc");
    }
  };
  var getDefaultNpmPrefix = () => {
    if (isWindows) {
      return path4.dirname(process.execPath);
    }
    return path4.dirname(path4.dirname(process.execPath));
  };
  var getNpmPrefix = () => {
    const envPrefix = getEnvNpmPrefix();
    if (envPrefix) {
      return envPrefix;
    }
    const homePrefix = readRc(path4.join(os2.homedir(), ".npmrc"));
    if (homePrefix) {
      return homePrefix;
    }
    if (process.env.PREFIX) {
      return process.env.PREFIX;
    }
    const globalPrefix = readRc(getGlobalNpmrc());
    if (globalPrefix) {
      return globalPrefix;
    }
    return getDefaultNpmPrefix();
  };
  var npmPrefix = path4.resolve(getNpmPrefix());
  var getYarnWindowsDirectory = () => {
    if (isWindows && process.env.LOCALAPPDATA) {
      const dir = path4.join(process.env.LOCALAPPDATA, "Yarn");
      if (fs2.existsSync(dir)) {
        return dir;
      }
    }
    return false;
  };
  var getYarnPrefix = () => {
    if (process.env.PREFIX) {
      return process.env.PREFIX;
    }
    const windowsPrefix = getYarnWindowsDirectory();
    if (windowsPrefix) {
      return windowsPrefix;
    }
    const configPrefix = path4.join(os2.homedir(), ".config/yarn");
    if (fs2.existsSync(configPrefix)) {
      return configPrefix;
    }
    const homePrefix = path4.join(os2.homedir(), ".yarn-config");
    if (fs2.existsSync(homePrefix)) {
      return homePrefix;
    }
    return npmPrefix;
  };
  exports2.npm = {};
  exports2.npm.prefix = npmPrefix;
  exports2.npm.packages = path4.join(npmPrefix, isWindows ? "node_modules" : "lib/node_modules");
  exports2.npm.binaries = isWindows ? npmPrefix : path4.join(npmPrefix, "bin");
  var yarnPrefix = path4.resolve(getYarnPrefix());
  exports2.yarn = {};
  exports2.yarn.prefix = yarnPrefix;
  exports2.yarn.packages = path4.join(yarnPrefix, getYarnWindowsDirectory() ? "Data/global/node_modules" : "global/node_modules");
  exports2.yarn.binaries = path4.join(exports2.yarn.packages, ".bin");
});

// ../sdk/dist/isCurrentBinInstalledGlobally.js
var require_isCurrentBinInstalledGlobally = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    isCurrentBinInstalledGlobally: () => isCurrentBinInstalledGlobally2
  });
  var import_fs2 = __toModule3(require("fs"));
  var import_global_dirs = __toModule3(require_global_dirs());
  function isCurrentBinInstalledGlobally2() {
    try {
      const realPrismaPath = import_fs2.default.realpathSync(process.argv[1]);
      const usingGlobalYarn = realPrismaPath.indexOf(import_global_dirs.default.yarn.packages) === 0;
      const usingGlobalNpm = realPrismaPath.indexOf(import_fs2.default.realpathSync(import_global_dirs.default.npm.packages)) === 0;
      if (usingGlobalNpm) {
        return "npm";
      }
      if (usingGlobalYarn) {
        return "yarn";
      } else {
        false;
      }
    } catch (e) {
    }
    return false;
  }
});

// ../sdk/dist/getCommandWithExecutor.js
var require_getCommandWithExecutor = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    getCommandWithExecutor: () => getCommandWithExecutor2
  });
  var import_isCurrentBinInstalledGlobally = __toModule3(require_isCurrentBinInstalledGlobally());
  function getCommandWithExecutor2(command) {
    var _a;
    if ((0, import_isCurrentBinInstalledGlobally.isCurrentBinInstalledGlobally)()) {
      return command;
    } else {
      const yarnUsed = (_a = process.env.npm_config_user_agent) == null ? void 0 : _a.includes("yarn");
      const npxUsed = __dirname.includes("_npx");
      if (npxUsed) {
        return `npx ${command}`;
      } else if (yarnUsed) {
        return `yarn ${command}`;
      } else {
        return command;
      }
    }
  }
});

// ../sdk/dist/versions.js
var require_versions = __commonJS2((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    engineVersions: () => engineVersions2
  });
  var engineVersions2 = {
    "2.0.0-preview025": "8814060fa684793b73d07dbfccd4b7777b3361ae",
    "2.0.0-beta.1": "2accb9c7eacdc984874eaeb63377fe705dfd3203",
    "2.0.0-beta.2": "76857c35ba1e1764dd5473656ecbbb2f739e1822",
    "2.0.0-beta.3": "2fb8f444d9cdf7c0beee7b041194b42d7a9ce1e6",
    "2.0.0-beta.4": "afd294205618b1c825b013ba6f5a6ebe4aa4a514",
    "2.0.0-beta.5": "0c2ec197653b278b2978845ef958db88824cd82e",
    "2.0.0-beta.6": "c48b94aa8d1d9a0e5582dcd14e25202b76303dca",
    "2.0.0-beta.7": "5d39801acf2e3475bd9dab029a63634358b07bf1",
    "2.0.0-beta.8": "ff6959d77f8880ec037ed8201fff4a92f3aabaa0",
    "2.0.0-beta.9": "de2bc1cbdb5561ad73d2f08463fa2eec48993f56",
    "2.0.0": "de2bc1cbdb5561ad73d2f08463fa2eec48993f56",
    "2.1.0-dev.1": "de2bc1cbdb5561ad73d2f08463fa2eec48993f56",
    "2.1.0-dev.3": "de2bc1cbdb5561ad73d2f08463fa2eec48993f56",
    "2.1.0-dev.4": "de2bc1cbdb5561ad73d2f08463fa2eec48993f56",
    "2.1.0-dev.5": "8276c7c5aa78dbfea6213a4f9918200ee909b9a1",
    "2.1.0-dev.6": "f64916f0b6ce4210f7793b551f6bf9bfab7fd45a",
    "2.1.0-dev.7": "f64916f0b6ce4210f7793b551f6bf9bfab7fd45a",
    "2.1.0-dev.8": "f64916f0b6ce4210f7793b551f6bf9bfab7fd45a",
    "2.1.0-dev.9": "dc0f43d1460553447c563479493914279205d48f",
    "2.1.0-dev.10": "dc0f43d1460553447c563479493914279205d48f",
    "2.1.0-dev.11": "dc0f43d1460553447c563479493914279205d48f",
    "2.1.0-dev.12": "e52ce7fbe503b390ca40425e62efeb5bc2cefb7e",
    "2.1.0-dev.13": "6c7b34889020f8b10eea253f37022b6a1a935de3",
    "2.1.0-dev.14": "d75f4952ce0649fcf62c068cf03c18944b0bce34",
    "2.1.0-dev.15": "e172ae243853e2a47c75a1abe5547d0677980346",
    "2.1.0-dev.16": "077166a5c1ab914cf3d9764adc44ed812c7aa5b3",
    "2.1.0-dev.17": "7862cc88dc37aad8eb16913b5c09af408e5239fc",
    "2.1.0-dev.18": "487d9dd9cd33fa68a3eb9f3a991be11927fee9aa",
    "2.1.0-dev.19": "4e71ba30f44f81b4a62e51502941aa71e451be66",
    "2.1.0-dev.20": "55f869ed93b06baf167e981f5d4f2d8161f49998",
    "2.1.0-dev.21": "55f869ed93b06baf167e981f5d4f2d8161f49998",
    "2.1.0-dev.22": "55f869ed93b06baf167e981f5d4f2d8161f49998",
    "2.1.0-dev.24": "55f869ed93b06baf167e981f5d4f2d8161f49998",
    "2.1.0-dev.25": "8375158b46e194d6f48fb78be6e4ac58e693f2d4",
    "2.1.0-dev.26": "8375158b46e194d6f48fb78be6e4ac58e693f2d4",
    "2.1.0-dev.27": "8375158b46e194d6f48fb78be6e4ac58e693f2d4",
    "2.0.1-dev.1": "7d77a7cd570c9dedb4cdf31a1cbec615cf2e1eda",
    "2.0.1-dev.2": "7d77a7cd570c9dedb4cdf31a1cbec615cf2e1eda",
    "2.1.0-dev.28": "6838566f3107ff9f8de79e3bb8a731e70c02fb00",
    "2.1.0-dev.29": "6838566f3107ff9f8de79e3bb8a731e70c02fb00",
    "2.0.1-dev.3": "7d77a7cd570c9dedb4cdf31a1cbec615cf2e1eda",
    "2.0.1": "7d77a7cd570c9dedb4cdf31a1cbec615cf2e1eda",
    "2.1.0-dev.30": "2e65011d592bae491ee9dd5f8a6159c85c35e767",
    "2.1.0-dev.31": "2e65011d592bae491ee9dd5f8a6159c85c35e767",
    "2.1.0-dev.32": "2e65011d592bae491ee9dd5f8a6159c85c35e767",
    "2.1.0-dev.33": "2e65011d592bae491ee9dd5f8a6159c85c35e767",
    "2.1.0-dev.34": "2e65011d592bae491ee9dd5f8a6159c85c35e767",
    "2.1.0-dev.35": "2e65011d592bae491ee9dd5f8a6159c85c35e767",
    "2.1.0-dev.36": "12d156ebbe4bd254b3d20a2fa132bcc66a802502",
    "2.1.0-dev.37": "12d156ebbe4bd254b3d20a2fa132bcc66a802502",
    "2.1.0-dev.38": "12d156ebbe4bd254b3d20a2fa132bcc66a802502",
    "2.1.0-dev.39": "ffc156935b82a02a6770ab5e355e33312a0d0706",
    "2.1.0-dev.40": "bb1356b9cbd72b74787bfa66bbe5c8e338810b05",
    "2.1.0-dev.41": "bb1356b9cbd72b74787bfa66bbe5c8e338810b05",
    "2.1.0-dev.42": "bb1356b9cbd72b74787bfa66bbe5c8e338810b05",
    "2.1.0-dev.43": "bb1356b9cbd72b74787bfa66bbe5c8e338810b05",
    "2.1.0-dev.44": "9a43c75685826419972aa2ee5847d7a7107a176f",
    "2.1.0-dev.45": "9a43c75685826419972aa2ee5847d7a7107a176f",
    "2.1.0-dev.46": "9a43c75685826419972aa2ee5847d7a7107a176f",
    "2.1.0-dev.47": "9a43c75685826419972aa2ee5847d7a7107a176f",
    "2.1.0-dev.48": "dbeb321de898f94b03cd6f9b525c0187d93c3119",
    "2.1.0-dev.49": "64064ad0b1018ccb2309d97cbe958b666e5c55ea",
    "2.1.0-dev.50": "eef69002f93443908594c3293eca977e22008b22",
    "2.1.0-dev.51": "38d970371091514dcd2965847e30e9bf56820057",
    "2.1.0-dev.52": "c60e0db03225f303cfed42afcb6814999c95c6d8",
    "2.1.0-dev.53": "18c02927ce69cd6d593e1bfca4647ec46ee172d7",
    "2.1.0-dev.54": "6b10f7bfb5c09d707016877e7ec2e0c35f26eb67",
    "2.1.0-dev.55": "713204c8241b1870c0ae1145a256232744708cce",
    "2.1.0-dev.56": "713204c8241b1870c0ae1145a256232744708cce",
    "2.1.0-dev.57": "713204c8241b1870c0ae1145a256232744708cce",
    "2.1.0-dev.58": "4440772035795a0424be62040e2295c56e5c6ad0",
    "2.1.0-dev.59": "4440772035795a0424be62040e2295c56e5c6ad0",
    "2.1.0": "4440772035795a0424be62040e2295c56e5c6ad0",
    "2.2.0-dev.1": "30a3b13a02ea2b9a1bfa980e7c25b41bdbf77ea5",
    "2.2.0-dev.2": "30a3b13a02ea2b9a1bfa980e7c25b41bdbf77ea5",
    "2.1.1-dev.2": "34b761660584e32d715c3e86ecec3e2c4d50d0d9",
    "2.1.1": "34b761660584e32d715c3e86ecec3e2c4d50d0d9",
    "2.2.0-dev.3": "34b761660584e32d715c3e86ecec3e2c4d50d0d9",
    "2.2.0-dev.4": "43a04d7fe56db1d914cdd3619ef5c819c783d243",
    "2.2.0-dev.5": "219a8d806a3568142dee4c8673e767750e9d0136",
    "2.2.0-dev.6": "36247a04e8ff91aec3ecd2af1680494201048f34",
    "2.2.0-dev.7": "36247a04e8ff91aec3ecd2af1680494201048f34",
    "2.2.0-dev.8": "e006ba7fcfd6257d81e616e4e1bbbab8e017a9fe",
    "2.2.0-dev.9": "632c075edd87eff798b1babf16a4965ae2b45a9b",
    "2.2.0-dev.10": "632c075edd87eff798b1babf16a4965ae2b45a9b",
    "2.2.0-dev.11": "4414d4e066670f6edb6da381e6c8fcf544d6178f",
    "2.2.0-dev.12": "d23f217662512ed9c9a4a6a920c377154053a0a4",
    "2.2.0-dev.13": "700298ef090d8d45bed3750e99f56ba0be03673d",
    "2.2.0-dev.14": "700298ef090d8d45bed3750e99f56ba0be03673d",
    "2.2.0-dev.15": "297d4dddf12cd89b7c6de31ef15c42967f5cc559",
    "2.1.2-dev.1": "363f5a521d6b06543e53d134652a0037a3096d41",
    "2.1.2-dev.2": "363f5a521d6b06543e53d134652a0037a3096d41",
    "2.1.2": "363f5a521d6b06543e53d134652a0037a3096d41",
    "2.1.3-dev.1": "363f5a521d6b06543e53d134652a0037a3096d41",
    "2.1.3": "363f5a521d6b06543e53d134652a0037a3096d41",
    "2.2.0-dev.16": "297d4dddf12cd89b7c6de31ef15c42967f5cc559",
    "2.2.0-dev.17": "297d4dddf12cd89b7c6de31ef15c42967f5cc559",
    "2.2.0-dev.18": "297d4dddf12cd89b7c6de31ef15c42967f5cc559",
    "2.2.0-dev.19": "cb47e060d4a557e1e7870f50fc7b3c014f278114",
    "2.2.0-dev.20": "9216be08662d7280cc02246b4f5cc5f4b93cf8a3",
    "2.2.0-dev.21": "9216be08662d7280cc02246b4f5cc5f4b93cf8a3",
    "2.2.0-dev.23": "9216be08662d7280cc02246b4f5cc5f4b93cf8a3",
    "2.2.0-dev.24": "9216be08662d7280cc02246b4f5cc5f4b93cf8a3",
    "2.2.0-dev.25": "9216be08662d7280cc02246b4f5cc5f4b93cf8a3",
    "2.2.0-dev.26": "c29fbcd0f57c67e11722e479b9d135b346767e69",
    "2.2.0-dev.27": "c29fbcd0f57c67e11722e479b9d135b346767e69",
    "2.2.0-dev.28": "d6ff7119649922b84e413b3b69660e2f49e2ddf3",
    "2.2.0-dev.29": "d6ff7119649922b84e413b3b69660e2f49e2ddf3",
    "2.2.0-dev.30": "f5632770336d9cd89b6fa90204c3decf335c065a",
    "2.2.0-dev.31": "f5632770336d9cd89b6fa90204c3decf335c065a",
    "2.2.0-dev.32": "f5632770336d9cd89b6fa90204c3decf335c065a",
    "2.2.0-dev.33": "f5632770336d9cd89b6fa90204c3decf335c065a",
    "2.2.0-dev.34": "75d49d38ea10c8099ff9e90336c721fa6b47b90a",
    "2.2.0-dev.35": "c65f7b5d18ee8dbd0f43f654571bd3e85b625d80",
    "2.2.0-dev.36": "a0b56e4a4bc0dc6216e1cb26bd91a4094b868010",
    "2.2.0-dev.37": "ea035543e59571161e00ccd4063f5638283bfba7",
    "2.2.0-dev.38": "ea035543e59571161e00ccd4063f5638283bfba7",
    "2.2.0-dev.39": "ea035543e59571161e00ccd4063f5638283bfba7",
    "2.2.0-dev.40": "ea035543e59571161e00ccd4063f5638283bfba7",
    "2.2.0-dev.41": "1c840bb755d3b03acf9259f689303db93159c7b5",
    "2.2.0-dev.42": "1c840bb755d3b03acf9259f689303db93159c7b5",
    "2.2.0-dev.43": "ed51c9476579e3aa52ec43079fb2a351c70f5bb7",
    "2.2.0-dev.44": "ed51c9476579e3aa52ec43079fb2a351c70f5bb7",
    "2.2.0-dev.45": "ed51c9476579e3aa52ec43079fb2a351c70f5bb7",
    "2.2.0-dev.46": "ed51c9476579e3aa52ec43079fb2a351c70f5bb7",
    "2.2.0-dev.47": "ed51c9476579e3aa52ec43079fb2a351c70f5bb7",
    "2.2.0-dev.48": "ed51c9476579e3aa52ec43079fb2a351c70f5bb7",
    "2.2.0-dev.49": "ed51c9476579e3aa52ec43079fb2a351c70f5bb7",
    "2.2.0-dev.50": "83ac782d5d93dcee37efeba8ccbeff596701148a",
    "2.2.0-dev.51": "83ac782d5d93dcee37efeba8ccbeff596701148a",
    "2.2.0-dev.52": "83ac782d5d93dcee37efeba8ccbeff596701148a",
    "2.2.0-dev.53": "83ac782d5d93dcee37efeba8ccbeff596701148a",
    "2.2.0-dev.54": "83ac782d5d93dcee37efeba8ccbeff596701148a",
    "2.2.0-dev.55": "87846242af9393fb8fe9d3644cbb2dec2e322155",
    "2.2.0-dev.56": "87846242af9393fb8fe9d3644cbb2dec2e322155",
    "2.2.0-dev.57": "87846242af9393fb8fe9d3644cbb2dec2e322155",
    "2.2.0-dev.58": "87846242af9393fb8fe9d3644cbb2dec2e322155",
    "2.2.0-dev.59": "87846242af9393fb8fe9d3644cbb2dec2e322155",
    "2.2.0-dev.60": "87846242af9393fb8fe9d3644cbb2dec2e322155",
    "2.2.0-dev.61": "87846242af9393fb8fe9d3644cbb2dec2e322155",
    "2.2.0-dev.62": "87846242af9393fb8fe9d3644cbb2dec2e322155",
    "2.2.0-dev.63": "45c4da4dd3ccd6a322796b228bdf937c7ce884e8",
    "2.2.0": "45c4da4dd3ccd6a322796b228bdf937c7ce884e8",
    "2.3.0-dev.1": "3b7bab56afd3c41d2b1e92b21607c25527376819",
    "2.3.0-dev.2": "341b5a03061332a0a107760fc5be098168b7af49",
    "2.3.0-dev.3": "f21b611f21983123efdd86b230717b552898db2c",
    "2.3.0-dev.4": "7c61a28fce591bca9794f84bada575727c8d3a81",
    "2.3.0-dev.5": "7c61a28fce591bca9794f84bada575727c8d3a81",
    "2.3.0-dev.6": "9a238f2a34ac96b4006d0622063cda5d7c550f39",
    "2.3.0-dev.7": "225c75492b90e646e0224803ae30926eb676bdd0",
    "2.3.0-dev.8": "6b4130069651151477456fde7c6f1adce7e5aba1",
    "2.3.0-dev.9": "6b4130069651151477456fde7c6f1adce7e5aba1",
    "2.3.0-dev.10": "9fa0e57d0617e4e18ceae3b23280702f90b18412",
    "2.3.0-dev.11": "9fa0e57d0617e4e18ceae3b23280702f90b18412",
    "2.3.0-dev.12": "68efc71c4b657c5dbd59b177ecf2daf18e5b0201",
    "2.2.1-dev.1": "832e37683666c748b0a1cbdc2c5068b5e443e816",
    "2.2.1-dev.2": "832e37683666c748b0a1cbdc2c5068b5e443e816",
    "2.3.0-dev.13": "ba2d82113a01f9d56c88cf52279fb0bd5f74fac0",
    "2.2.1-dev.3": "832e37683666c748b0a1cbdc2c5068b5e443e816",
    "2.2.1-dev.4": "832e37683666c748b0a1cbdc2c5068b5e443e816",
    "2.3.0-dev.14": "21bd701db858e37b8f3157190a86da93e21ec5df",
    "2.2.1-dev.5": "832e37683666c748b0a1cbdc2c5068b5e443e816",
    "2.3.0-dev.15": "21bd701db858e37b8f3157190a86da93e21ec5df",
    "2.3.0-dev.16": "21bd701db858e37b8f3157190a86da93e21ec5df",
    "2.3.0-dev.17": "21bd701db858e37b8f3157190a86da93e21ec5df",
    "2.2.1-dev.6": "832e37683666c748b0a1cbdc2c5068b5e443e816",
    "2.3.0-dev.18": "21bd701db858e37b8f3157190a86da93e21ec5df",
    "2.2.1": "832e37683666c748b0a1cbdc2c5068b5e443e816",
    "2.3.0-dev.19": "81e452517f2e53825001cddd130dc09e0862711b",
    "2.2.2-dev.1": "a9e8c3d97ef2a0cf59256e6b26097f2a80f0a6a4",
    "2.2.2": "a9e8c3d97ef2a0cf59256e6b26097f2a80f0a6a4",
    "2.3.0-dev.20": "7dd62871982e0897f81591928ef43d4669b2a176",
    "2.3.0-dev.21": "7dd62871982e0897f81591928ef43d4669b2a176",
    "2.3.0-dev.23": "b032e1220061befb095deef6f8ee2e36bacbf4d9",
    "2.3.0-dev.25": "b032e1220061befb095deef6f8ee2e36bacbf4d9",
    "2.3.0-dev.26": "b032e1220061befb095deef6f8ee2e36bacbf4d9",
    "2.3.0-dev.27": "b032e1220061befb095deef6f8ee2e36bacbf4d9",
    "2.3.0-dev.28": "b032e1220061befb095deef6f8ee2e36bacbf4d9",
    "2.3.0-dev.29": "99bc0e4998e8148ef5716312495fcaa7293b62ff",
    "2.3.0-dev.30": "a1ea05fcba2ecf3d741a559a8394a61a0958b662",
    "2.3.0-dev.31": "a1ea05fcba2ecf3d741a559a8394a61a0958b662",
    "2.3.0-dev.32": "a6590bef185927e77afebb0bf8a1bc3defe5d0ad",
    "2.3.0-dev.33": "ba26cce0f10f923f1de113aae0763d2412e18247",
    "2.3.0-dev.34": "ba26cce0f10f923f1de113aae0763d2412e18247",
    "2.3.0-dev.35": "ba26cce0f10f923f1de113aae0763d2412e18247",
    "2.3.0-dev.36": "0335c039a0bc842a20ffe7832d26e592f34ea916",
    "2.3.0-dev.37": "0335c039a0bc842a20ffe7832d26e592f34ea916",
    "2.3.0-dev.38": "cdc255245a255c24b3dd50db25a050636973ec77",
    "2.3.0-dev.39": "1efe9b96955f1316d84351b2e771d81246873022",
    "2.3.0-dev.40": "156ad9546453b9b64fd2feeede6ad8991bb9de22",
    "2.3.0-dev.41": "8619f7cdd8edc678160849a499cdaaf73dc9b63c",
    "2.3.0-dev.42": "f7829d796be36394ee9a64f1fc67c643aae046f2",
    "2.3.0-dev.43": "f7829d796be36394ee9a64f1fc67c643aae046f2",
    "2.3.0-dev.44": "ede20e7638e18c628b4f70b3d2483c87b919982a",
    "2.3.0-dev.45": "862d67e6b9ca50e232d4cdbc3b12b3f1f08cec8a",
    "2.3.0-dev.46": "862d67e6b9ca50e232d4cdbc3b12b3f1f08cec8a",
    "2.3.0-dev.47": "862d67e6b9ca50e232d4cdbc3b12b3f1f08cec8a",
    "2.3.0-dev.48": "143a8265b75aefe077e9f483f4a275ab5e0ad5f6",
    "2.3.0-dev.49": "143a8265b75aefe077e9f483f4a275ab5e0ad5f6",
    "2.3.0-dev.50": "143a8265b75aefe077e9f483f4a275ab5e0ad5f6",
    "2.3.0-dev.51": "143a8265b75aefe077e9f483f4a275ab5e0ad5f6",
    "2.3.0-dev.52": "143a8265b75aefe077e9f483f4a275ab5e0ad5f6",
    "2.3.0-dev.53": "b1c5396ac9832eb8481b3c7f36c393ab1747211d",
    "2.3.0-dev.54": "b1c5396ac9832eb8481b3c7f36c393ab1747211d",
    "2.3.0-dev.55": "b1c5396ac9832eb8481b3c7f36c393ab1747211d",
    "2.3.0-dev.56": "b1c5396ac9832eb8481b3c7f36c393ab1747211d",
    "2.3.0-dev.57": "e11114fa1ea826f9e7b4fa1ced34e78892fe8e0e",
    "2.3.0": "e11114fa1ea826f9e7b4fa1ced34e78892fe8e0e",
    "2.4.0-dev.1": "bbc9be76da4bf5af6bacb8655633ae4ea56b6f6f",
    "2.4.0-dev.2": "346c7b5b70ae5ed4e10b0342b556e7d53c27c0af",
    "2.4.0-dev.3": "84202350ac21bc9479513fe91cc3510629aac69f",
    "2.4.0-dev.4": "1fdb184ea79af011b9c0ac677562719088f490af",
    "2.4.0-dev.5": "d995a75689d1bd4e90b019fd083d90d6fa2d48fa",
    "2.4.0-dev.6": "d995a75689d1bd4e90b019fd083d90d6fa2d48fa",
    "2.4.0-dev.7": "0f3750ce5b6509b766811fbe350e83f232daa57f",
    "2.4.0-dev.8": "0f3750ce5b6509b766811fbe350e83f232daa57f",
    "2.4.0-dev.9": "05ff93c8e9cea55e82b3bd3e50f71a571c6b0de5",
    "2.4.0-dev.10": "1e19628edbd4755d416300449b4c7bbb9d85e03f",
    "2.4.0-dev.11": "70bbce05e86a6109ced7ad133bd5dca095b3fa58",
    "2.4.0-dev.12": "054d8fd21e5ab5c9955492c3aad62dbb8c15f40b",
    "2.4.0-dev.13": "0912eb4031e6d77c4e13637447099b7100e602a3",
    "2.4.0-dev.14": "3a3fd0fe2660782248c1e42fa75ae0731fed8819",
    "2.4.0-dev.15": "9d759290dff266f4d4c39e415d8ac846827a4053",
    "2.4.0-dev.16": "ab6fccbd80bff0d30b57f371c8929de7b48c77e2",
    "2.4.0-dev.17": "fed4a488fd2a7c81fc556262f9ece4eb3fe6bd23",
    "2.4.0-dev.18": "b5c495e1e22d312e3ade4f4d8dbf5123e1ff9e30",
    "2.4.0-dev.19": "37468de984a57c89edf7ebde8c5ebd81d1e7183b",
    "2.4.0-dev.20": "37468de984a57c89edf7ebde8c5ebd81d1e7183b",
    "2.4.0-dev.21": "37468de984a57c89edf7ebde8c5ebd81d1e7183b",
    "2.4.0-dev.22": "37468de984a57c89edf7ebde8c5ebd81d1e7183b",
    "2.4.0-dev.23": "37468de984a57c89edf7ebde8c5ebd81d1e7183b",
    "2.4.0-dev.24": "37468de984a57c89edf7ebde8c5ebd81d1e7183b",
    "2.4.0-dev.25": "37468de984a57c89edf7ebde8c5ebd81d1e7183b",
    "2.4.0-dev.26": "f12ffba327775df35dca10f5cbcb829e866614e8",
    "2.4.0-dev.27": "1e72e2311f531c77af7675b1e1acac595d26bb49",
    "2.4.0-dev.28": "8eb4af13db3ce3b6b0e02e11d4d236082544281a",
    "2.4.0-dev.29": "8eb4af13db3ce3b6b0e02e11d4d236082544281a",
    "2.4.0-dev.30": "8eb4af13db3ce3b6b0e02e11d4d236082544281a",
    "2.4.0-dev.31": "8eb4af13db3ce3b6b0e02e11d4d236082544281a",
    "2.4.0-dev.32": "8eb4af13db3ce3b6b0e02e11d4d236082544281a",
    "2.4.0-dev.33": "8eb4af13db3ce3b6b0e02e11d4d236082544281a",
    "2.4.0-dev.34": "8eb4af13db3ce3b6b0e02e11d4d236082544281a",
    "2.4.0-dev.35": "8eb4af13db3ce3b6b0e02e11d4d236082544281a",
    "2.4.0-dev.36": "8eb4af13db3ce3b6b0e02e11d4d236082544281a",
    "2.4.0-dev.37": "8eb4af13db3ce3b6b0e02e11d4d236082544281a",
    "2.4.0-dev.38": "8eb4af13db3ce3b6b0e02e11d4d236082544281a",
    "2.4.0-dev.39": "8eb4af13db3ce3b6b0e02e11d4d236082544281a",
    "2.4.0-dev.40": "8eb4af13db3ce3b6b0e02e11d4d236082544281a",
    "2.4.0-dev.41": "8eb4af13db3ce3b6b0e02e11d4d236082544281a",
    "2.4.0-dev.42": "8eb4af13db3ce3b6b0e02e11d4d236082544281a",
    "2.4.0-dev.43": "8337329d29aec488119918879493ab6fd38c880e",
    "2.4.0-dev.44": "8337329d29aec488119918879493ab6fd38c880e",
    "2.4.0-dev.45": "8337329d29aec488119918879493ab6fd38c880e",
    "2.4.0-dev.46": "8337329d29aec488119918879493ab6fd38c880e",
    "2.4.0-dev.47": "8337329d29aec488119918879493ab6fd38c880e",
    "2.4.0-dev.48": "8337329d29aec488119918879493ab6fd38c880e",
    "2.4.0-dev.49": "4c91943360cd3d09eb0a9d55286c2670ed9e5e88",
    "2.4.0-dev.50": "4c91943360cd3d09eb0a9d55286c2670ed9e5e88",
    "2.4.0-dev.51": "4c91943360cd3d09eb0a9d55286c2670ed9e5e88",
    "2.4.0-dev.52": "d65a057850f62704205d0e392faf01613293d6f4",
    "2.4.0-dev.53": "bb57b5bea80ee2dd82fcae105e0204a2349a54c2",
    "2.4.0-dev.54": "bb57b5bea80ee2dd82fcae105e0204a2349a54c2",
    "2.4.0-dev.55": "6c777331554df4c3e0a90dd841339c7b0619d0e1",
    "2.4.0-dev.56": "6c777331554df4c3e0a90dd841339c7b0619d0e1",
    "2.4.0-dev.57": "6c777331554df4c3e0a90dd841339c7b0619d0e1",
    "2.4.0-dev.58": "6c777331554df4c3e0a90dd841339c7b0619d0e1",
    "2.4.0-dev.59": "6c777331554df4c3e0a90dd841339c7b0619d0e1",
    "2.4.0-dev.60": "6c777331554df4c3e0a90dd841339c7b0619d0e1",
    "2.4.0": "6c777331554df4c3e0a90dd841339c7b0619d0e1",
    "2.5.0-dev.1": "8badef702a0bb0e6121197ccec5976d9af178cc4",
    "2.5.0-dev.2": "8badef702a0bb0e6121197ccec5976d9af178cc4",
    "2.5.0-dev.3": "e745b5f2a9bea5d04faeb768b619aa761d176b7d",
    "2.5.0-dev.4": "e745b5f2a9bea5d04faeb768b619aa761d176b7d",
    "2.5.0-dev.5": "6e674469fff1a603c0139a09a5c7665af0c0b915",
    "2.4.1-dev.1": "195d4bdc2d16132977f4ba7a8ca312f7906cb086",
    "2.4.1": "195d4bdc2d16132977f4ba7a8ca312f7906cb086",
    "2.5.0-dev.6": "a4c0b19a07ff370234d8e6205a60aa885daed3c9",
    "2.5.0-dev.7": "2d5db567f479b50d4a793d4141fb3dad6b6d14af",
    "2.5.0-dev.8": "2dbcdc81e4161f23e736d2d7a5356926f4abfda7",
    "2.5.0-dev.9": "8e4f3a5c140fa60e254d5ca37536c5991960dc7f",
    "2.5.0-dev.10": "734ab53bd8e2cadf18b8b71cb53bf2d2bed46517",
    "2.5.0-dev.11": "734ab53bd8e2cadf18b8b71cb53bf2d2bed46517",
    "2.5.0-dev.12": "96dcc3c34f040c9808059de63409f04687c9beff",
    "2.5.0-dev.13": "2deb6252cdc82d12effe3a000748397cd6a1ba6e",
    "2.5.0-dev.14": "2deb6252cdc82d12effe3a000748397cd6a1ba6e",
    "2.5.0-dev.15": "2deb6252cdc82d12effe3a000748397cd6a1ba6e",
    "2.5.0-dev.16": "9f61a69f7e2e04c849ba039136a8ee3625e03859",
    "2.5.0-dev.17": "9f61a69f7e2e04c849ba039136a8ee3625e03859",
    "2.5.0-dev.18": "9f61a69f7e2e04c849ba039136a8ee3625e03859",
    "2.5.0-dev.19": "9f61a69f7e2e04c849ba039136a8ee3625e03859",
    "2.5.0-dev.20": "6fa13fa129a579cce403a8cdf65aa3bd7a19028b",
    "2.5.0-dev.21": "e8c86b2eed97ef06abd25651f450e957b21f5c31",
    "2.5.0-dev.22": "e8c86b2eed97ef06abd25651f450e957b21f5c31",
    "2.5.0-dev.23": "e8c86b2eed97ef06abd25651f450e957b21f5c31",
    "2.5.0-dev.24": "e8c86b2eed97ef06abd25651f450e957b21f5c31",
    "2.5.0-dev.25": "e8c86b2eed97ef06abd25651f450e957b21f5c31",
    "2.5.0-dev.26": "b6c3e2ef9589d6e08cb9ad74d68e733f4007650c",
    "2.5.0-dev.27": "ac051172582b2c03c3d6e2f1470a0eccb274e4c5",
    "2.5.0-dev.28": "c0231c315abebc8c3ed7c32927a2a091bffda4a3",
    "2.5.0-dev.29": "c0231c315abebc8c3ed7c32927a2a091bffda4a3",
    "2.5.0-dev.30": "c0231c315abebc8c3ed7c32927a2a091bffda4a3",
    "2.5.0-dev.31": "c0231c315abebc8c3ed7c32927a2a091bffda4a3",
    "2.5.0-dev.32": "c0231c315abebc8c3ed7c32927a2a091bffda4a3",
    "2.5.0-dev.33": "c0231c315abebc8c3ed7c32927a2a091bffda4a3",
    "2.5.0-dev.34": "c0231c315abebc8c3ed7c32927a2a091bffda4a3",
    "2.5.0-dev.35": "c0231c315abebc8c3ed7c32927a2a091bffda4a3",
    "2.5.0-dev.36": "c0231c315abebc8c3ed7c32927a2a091bffda4a3",
    "2.5.0-dev.37": "c0231c315abebc8c3ed7c32927a2a091bffda4a3",
    "2.5.0-dev.38": "31a949effe4ea834d8ccd4f8087e0375bcffccfa",
    "2.5.0-dev.39": "ee46c0006296d91f8a23684a8ced0ce259386cea",
    "2.5.0-dev.40": "ee46c0006296d91f8a23684a8ced0ce259386cea",
    "2.5.0-dev.41": "5ae6907bd5ffc701ed7d93ba74080da8d2f7c158",
    "2.5.0-dev.42": "5ae6907bd5ffc701ed7d93ba74080da8d2f7c158",
    "2.5.0-dev.43": "5ae6907bd5ffc701ed7d93ba74080da8d2f7c158",
    "2.5.0-dev.44": "5ae6907bd5ffc701ed7d93ba74080da8d2f7c158",
    "2.5.0-dev.45": "5ae6907bd5ffc701ed7d93ba74080da8d2f7c158",
    "2.5.0-dev.46": "5ae6907bd5ffc701ed7d93ba74080da8d2f7c158",
    "2.5.0-dev.47": "f3df39ce7a842e659445cf7436ee8b268b8bff17",
    "2.5.0-dev.48": "f3df39ce7a842e659445cf7436ee8b268b8bff17",
    "2.5.0-dev.49": "f3df39ce7a842e659445cf7436ee8b268b8bff17",
    "2.5.0-dev.50": "8f08c6fa89afd00710e41d99621786150b7eebbe",
    "2.5.0-dev.51": "8f08c6fa89afd00710e41d99621786150b7eebbe",
    "2.5.0-dev.52": "8f08c6fa89afd00710e41d99621786150b7eebbe",
    "2.5.0-dev.53": "8f08c6fa89afd00710e41d99621786150b7eebbe",
    "2.5.0-dev.54": "8f08c6fa89afd00710e41d99621786150b7eebbe",
    "2.5.0-dev.55": "8f08c6fa89afd00710e41d99621786150b7eebbe",
    "2.5.0-dev.56": "8f08c6fa89afd00710e41d99621786150b7eebbe",
    "2.5.0-dev.57": "8f08c6fa89afd00710e41d99621786150b7eebbe",
    "2.5.0-dev.58": "cc6843945c4485b397f541fcbe18d1bd94346ef7",
    "2.5.0-dev.59": "cc6843945c4485b397f541fcbe18d1bd94346ef7",
    "2.5.0-dev.60": "cc6843945c4485b397f541fcbe18d1bd94346ef7",
    "2.5.0-dev.61": "cc6843945c4485b397f541fcbe18d1bd94346ef7",
    "2.5.0-dev.62": "fa212b81aa9797f9cc8290b31cf74f49a242cb4a",
    "2.5.0-dev.63": "fa212b81aa9797f9cc8290b31cf74f49a242cb4a",
    "2.5.0-dev.64": "fa212b81aa9797f9cc8290b31cf74f49a242cb4a",
    "2.5.0-dev.65": "e280b792354efc65b91253bfb9a0f4b73dca85e7",
    "2.5.0-dev.66": "e280b792354efc65b91253bfb9a0f4b73dca85e7",
    "2.5.0-dev.67": "e280b792354efc65b91253bfb9a0f4b73dca85e7",
    "2.5.0-dev.68": "f2e54efb31f58a6c1c6d697e0c40aaddbb306993",
    "2.5.0-dev.69": "f2e54efb31f58a6c1c6d697e0c40aaddbb306993",
    "2.5.0-dev.70": "f2e54efb31f58a6c1c6d697e0c40aaddbb306993",
    "2.5.0-dev.71": "9a670138b1db276001d785a2adcba1584c869d24",
    "2.5.0-dev.72": "9a670138b1db276001d785a2adcba1584c869d24",
    "2.5.0-dev.73": "9a670138b1db276001d785a2adcba1584c869d24",
    "2.5.0": "9a670138b1db276001d785a2adcba1584c869d24",
    "2.6.0-dev.1": "03bb4d5bc838046aeb5f477d8fd5940864f0ecd8",
    "2.6.0-dev.2": "03bb4d5bc838046aeb5f477d8fd5940864f0ecd8",
    "2.6.0-dev.3": "499fa463c4bce9f1e4773876b7659d1a0a1c59fe",
    "2.6.0-dev.4": "499fa463c4bce9f1e4773876b7659d1a0a1c59fe",
    "2.6.0-dev.5": "499fa463c4bce9f1e4773876b7659d1a0a1c59fe",
    "2.6.0-dev.6": "499fa463c4bce9f1e4773876b7659d1a0a1c59fe",
    "2.6.0-dev.7": "62c83f00cd815bc777fd0f326c7284d5b1556f8f",
    "2.6.0-dev.8": "62c83f00cd815bc777fd0f326c7284d5b1556f8f",
    "2.5.1-dev.1": "9a670138b1db276001d785a2adcba1584c869d24",
    "2.5.1-dev.2": "9a670138b1db276001d785a2adcba1584c869d24",
    "2.5.1-dev.3": "9a670138b1db276001d785a2adcba1584c869d24",
    "2.5.1-dev.4": "c88925ce44a9b89b4351aec85ba6a28979d2658e",
    "2.6.0-dev.9": "24a240e041612473ba2085961b4571205450fc13",
    "2.5.1-dev.5": "c88925ce44a9b89b4351aec85ba6a28979d2658e",
    "2.5.1": "c88925ce44a9b89b4351aec85ba6a28979d2658e",
    "2.6.0-dev.10": "08d3349c7d493866c34e5e403fe1a4220509b1b6",
    "2.6.0-dev.11": "08d3349c7d493866c34e5e403fe1a4220509b1b6",
    "2.6.0-dev.12": "08d3349c7d493866c34e5e403fe1a4220509b1b6",
    "2.6.0-dev.13": "fff0920741f15deea278830b4afd16f5fa81708b",
    "2.6.0-dev.14": "22ce6892be334bb50f8d7dcb5829d0ee124cd444",
    "2.6.0-dev.15": "62af2a2328bf6013fb6633f83eaf8c31617e641a",
    "2.6.0-dev.16": "62af2a2328bf6013fb6633f83eaf8c31617e641a",
    "2.6.0-dev.17": "acfba31b83f7edec8e740dc4d94e0aec0855b2d6",
    "2.6.0-dev.18": "acfba31b83f7edec8e740dc4d94e0aec0855b2d6",
    "2.6.0-dev.19": "a5fde664c5c57de5ac374be1138dd0f7ec5dc5ab",
    "2.6.0-dev.20": "a5fde664c5c57de5ac374be1138dd0f7ec5dc5ab",
    "2.6.0-dev.21": "a5fde664c5c57de5ac374be1138dd0f7ec5dc5ab",
    "2.6.0-dev.22": "a5fde664c5c57de5ac374be1138dd0f7ec5dc5ab",
    "2.6.0-dev.23": "a5fde664c5c57de5ac374be1138dd0f7ec5dc5ab",
    "2.6.0-dev.24": "4207c64a590fe98ef0e456b5f49e99ea4f7f0ce0",
    "2.6.0-dev.25": "4207c64a590fe98ef0e456b5f49e99ea4f7f0ce0",
    "2.6.0-dev.26": "4207c64a590fe98ef0e456b5f49e99ea4f7f0ce0",
    "2.6.0-dev.27": "4207c64a590fe98ef0e456b5f49e99ea4f7f0ce0",
    "2.6.0-dev.28": "4207c64a590fe98ef0e456b5f49e99ea4f7f0ce0",
    "2.6.0-dev.29": "4207c64a590fe98ef0e456b5f49e99ea4f7f0ce0",
    "2.6.0-dev.30": "4207c64a590fe98ef0e456b5f49e99ea4f7f0ce0",
    "2.6.0-dev.31": "4207c64a590fe98ef0e456b5f49e99ea4f7f0ce0",
    "2.6.0-dev.32": "4207c64a590fe98ef0e456b5f49e99ea4f7f0ce0",
    "2.6.0-dev.33": "4207c64a590fe98ef0e456b5f49e99ea4f7f0ce0",
    "2.6.0-dev.34": "4207c64a590fe98ef0e456b5f49e99ea4f7f0ce0",
    "2.6.0-dev.35": "4207c64a590fe98ef0e456b5f49e99ea4f7f0ce0",
    "2.6.0-dev.36": "4207c64a590fe98ef0e456b5f49e99ea4f7f0ce0",
    "2.6.0-dev.37": "4207c64a590fe98ef0e456b5f49e99ea4f7f0ce0",
    "2.6.0-dev.38": "0250d982a01f9505bba89c380f5d8b0a7649633e",
    "2.6.0-dev.39": "96965f6c3db61abe3a54aee1a2f2af4e9bddace1",
    "2.6.0-dev.40": "96965f6c3db61abe3a54aee1a2f2af4e9bddace1",
    "2.6.0-dev.41": "ef1b5f6a28c2cf3933b0be3b48677edd6e0852a0",
    "2.6.0-dev.42": "ef1b5f6a28c2cf3933b0be3b48677edd6e0852a0",
    "2.6.0-dev.43": "b9dcf38b7fb0a74d3a8c9a0e8234bf7cee8417c2",
    "2.6.0-dev.44": "686b1f56ade7661ab2f1e60a6b3346abe2746175",
    "2.6.0-dev.45": "919f9059847d54a5f74e5c6e1f0ca9e036b91925",
    "2.6.0-dev.46": "a0b427d77d040aa7a76ddeedfb63e269351d63d7",
    "2.6.0-dev.47": "9da5ffb8b4a4d6b30bb6a124b6427493733e25c0",
    "2.6.0-dev.48": "650b5d0348ec38ae61e1e7db69bb54808418ede4",
    "2.6.0-dev.49": "650b5d0348ec38ae61e1e7db69bb54808418ede4",
    "2.6.0-dev.50": "650b5d0348ec38ae61e1e7db69bb54808418ede4",
    "2.6.0-dev.51": "650b5d0348ec38ae61e1e7db69bb54808418ede4",
    "2.6.0-dev.52": "650b5d0348ec38ae61e1e7db69bb54808418ede4",
    "2.6.0-dev.53": "650b5d0348ec38ae61e1e7db69bb54808418ede4",
    "2.6.0-dev.54": "650b5d0348ec38ae61e1e7db69bb54808418ede4",
    "2.6.0-dev.55": "650b5d0348ec38ae61e1e7db69bb54808418ede4",
    "2.6.0-dev.56": "650b5d0348ec38ae61e1e7db69bb54808418ede4",
    "2.6.0-dev.57": "650b5d0348ec38ae61e1e7db69bb54808418ede4",
    "2.6.0-dev.58": "650b5d0348ec38ae61e1e7db69bb54808418ede4",
    "2.6.0-dev.59": "650b5d0348ec38ae61e1e7db69bb54808418ede4",
    "2.6.0-dev.60": "650b5d0348ec38ae61e1e7db69bb54808418ede4",
    "2.6.0-dev.61": "650b5d0348ec38ae61e1e7db69bb54808418ede4",
    "2.6.0": "650b5d0348ec38ae61e1e7db69bb54808418ede4",
    "2.6.1-dev.1": "6a8054bb549e4cc23f157b0010cb2e95cb2637fb",
    "2.7.0-dev.1": "0dfa041d0d802be2e3ae0dd1ce2e4c307e39038b",
    "2.7.0-dev.2": "d1dd8a0508dfc82ae8bd83d91159e0ac807593ec",
    "2.6.1-dev.2": "6a8054bb549e4cc23f157b0010cb2e95cb2637fb",
    "2.6.1": "6a8054bb549e4cc23f157b0010cb2e95cb2637fb",
    "2.7.0-dev.3": "d1dd8a0508dfc82ae8bd83d91159e0ac807593ec",
    "2.7.0-dev.4": "d1dd8a0508dfc82ae8bd83d91159e0ac807593ec",
    "2.7.0-dev.5": "d1dd8a0508dfc82ae8bd83d91159e0ac807593ec",
    "2.7.0-dev.6": "d1dd8a0508dfc82ae8bd83d91159e0ac807593ec",
    "2.7.0-dev.7": "d1dd8a0508dfc82ae8bd83d91159e0ac807593ec",
    "2.7.0-dev.8": "e7e85356e6a71c0fda2447148512ca5ee761dbea",
    "2.6.2-dev.1": "6a8054bb549e4cc23f157b0010cb2e95cb2637fb",
    "2.7.0-dev.9": "7fe7c5b50aa571ac388a8183b3abae2114f948e8",
    "2.7.0-dev.10": "7fe7c5b50aa571ac388a8183b3abae2114f948e8",
    "2.7.0-dev.11": "7c19ae69057b1b46b2e7f90d531d99909cc85502",
    "2.6.2-dev.2": "6a8054bb549e4cc23f157b0010cb2e95cb2637fb",
    "2.6.2": "6a8054bb549e4cc23f157b0010cb2e95cb2637fb",
    "2.7.0-dev.12": "7c19ae69057b1b46b2e7f90d531d99909cc85502",
    "2.7.0-dev.13": "7c19ae69057b1b46b2e7f90d531d99909cc85502",
    "2.7.0-dev.14": "8ac7250d6543fc68cb07fb097003323856fb77fd",
    "2.7.0-dev.15": "8ac7250d6543fc68cb07fb097003323856fb77fd",
    "2.7.0-dev.16": "8ac7250d6543fc68cb07fb097003323856fb77fd",
    "2.7.0-dev.17": "8ac7250d6543fc68cb07fb097003323856fb77fd",
    "2.7.0-dev.18": "8ac7250d6543fc68cb07fb097003323856fb77fd",
    "2.7.0-dev.19": "8ac7250d6543fc68cb07fb097003323856fb77fd",
    "2.7.0-dev.20": "8ac7250d6543fc68cb07fb097003323856fb77fd",
    "2.7.0-dev.21": "8ac7250d6543fc68cb07fb097003323856fb77fd",
    "2.7.0-dev.22": "8ac7250d6543fc68cb07fb097003323856fb77fd",
    "2.7.0-dev.23": "8ac7250d6543fc68cb07fb097003323856fb77fd",
    "2.7.0-dev.24": "66ab5fb1ad3262553bee50cedb3144f3c26f67a7",
    "2.7.0-dev.25": "66ab5fb1ad3262553bee50cedb3144f3c26f67a7",
    "2.7.0-dev.26": "66ab5fb1ad3262553bee50cedb3144f3c26f67a7",
    "2.7.0-dev.27": "66ab5fb1ad3262553bee50cedb3144f3c26f67a7",
    "2.7.0-dev.28": "66ab5fb1ad3262553bee50cedb3144f3c26f67a7",
    "2.7.0-dev.29": "0d6f8376a03ae544c2be7c0279bc58a42d4bd302",
    "2.7.0-dev.30": "69cfbd5356b6cc807550b1660a501d6343cd805e",
    "2.7.0-dev.31": "69cfbd5356b6cc807550b1660a501d6343cd805e",
    "2.7.0-dev.32": "69cfbd5356b6cc807550b1660a501d6343cd805e",
    "2.7.0-dev.33": "69cfbd5356b6cc807550b1660a501d6343cd805e",
    "2.7.0-dev.34": "e6ec802febb5404ce4444eb440b0771ac896e3a4",
    "2.7.0-dev.35": "8b73a3e33a902f2b1f66f0ee82aecd716d3df824",
    "2.7.0-dev.36": "9552a36ff01a7ca7c7b811dc629ca3678da321f4",
    "2.7.0-dev.37": "a25d3c320c457986fe1b343b25c7f9182d8072f7",
    "2.7.0-dev.38": "a70da9750b0dd1eabc6b11c8548c40b856e298db",
    "2.7.0-dev.39": "a70da9750b0dd1eabc6b11c8548c40b856e298db",
    "2.7.0-dev.40": "a70da9750b0dd1eabc6b11c8548c40b856e298db",
    "2.7.0-dev.41": "a70da9750b0dd1eabc6b11c8548c40b856e298db",
    "2.7.0-dev.42": "a25edead86c5f3f39055ab41b078b8d7cb36477a",
    "2.7.0-dev.43": "a25edead86c5f3f39055ab41b078b8d7cb36477a",
    "2.7.0-dev.44": "a25edead86c5f3f39055ab41b078b8d7cb36477a",
    "2.7.0-dev.45": "a25edead86c5f3f39055ab41b078b8d7cb36477a",
    "2.7.0-dev.46": "a25edead86c5f3f39055ab41b078b8d7cb36477a",
    "2.7.0-dev.47": "a25edead86c5f3f39055ab41b078b8d7cb36477a",
    "2.7.0-dev.48": "a25edead86c5f3f39055ab41b078b8d7cb36477a",
    "2.7.0-dev.49": "a25edead86c5f3f39055ab41b078b8d7cb36477a",
    "2.7.0-dev.50": "a25edead86c5f3f39055ab41b078b8d7cb36477a",
    "2.7.0-dev.51": "3425da02811ca5d0994ba994c81192f304545fbc",
    "2.7.0-dev.52": "3425da02811ca5d0994ba994c81192f304545fbc",
    "2.7.0-dev.53": "3425da02811ca5d0994ba994c81192f304545fbc",
    "2.7.0-dev.54": "3425da02811ca5d0994ba994c81192f304545fbc",
    "2.7.0-dev.55": "1326cc350d369f69e2b4c0ea3bddc97ff384629e",
    "2.7.0-dev.56": "c508cbd521381ba4f3926e3f5ab1878a2881537d",
    "2.7.0-dev.57": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.58": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.59": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.60": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.61": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.62": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.63": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.64": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.65": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.66": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.67": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.68": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.69": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.70": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.71": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.72": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.73": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.74": "a6a6ecba74cbaeee0756c312b1b0f2502b27e49c",
    "2.7.0-dev.75": "eaade828a21d8ee3f4940f0af7da3ae0922db4df",
    "2.7.0-dev.76": "eaade828a21d8ee3f4940f0af7da3ae0922db4df",
    "2.7.0-dev.77": "eaade828a21d8ee3f4940f0af7da3ae0922db4df",
    "2.7.0-dev.78": "eaade828a21d8ee3f4940f0af7da3ae0922db4df",
    "2.7.0-dev.79": "eaade828a21d8ee3f4940f0af7da3ae0922db4df",
    "2.7.0-dev.80": "eaade828a21d8ee3f4940f0af7da3ae0922db4df",
    "2.7.0-dev.81": "eaade828a21d8ee3f4940f0af7da3ae0922db4df",
    "2.7.0-dev.82": "eaade828a21d8ee3f4940f0af7da3ae0922db4df",
    "2.7.0": "eaade828a21d8ee3f4940f0af7da3ae0922db4df",
    "2.8.0-dev.1": "290eb7c11a5561ad869041aa86323b85b337b12d",
    "2.8.0-dev.2": "2b4c3254badf30765f7839e350e4aa11a0842a8d",
    "2.8.0-dev.3": "2b4c3254badf30765f7839e350e4aa11a0842a8d",
    "2.7.1-dev.1": "5c2ad460cf4fe8c9330e6640b266c046542c8b6a",
    "2.8.0-dev.4": "2b4c3254badf30765f7839e350e4aa11a0842a8d",
    "2.8.0-dev.5": "d516bd2a52ad91031ba1c2ff3bd6d4429e727322",
    "2.8.0-dev.6": "d516bd2a52ad91031ba1c2ff3bd6d4429e727322",
    "2.7.1": "5c2ad460cf4fe8c9330e6640b266c046542c8b6a",
    "2.8.0-dev.7": "d516bd2a52ad91031ba1c2ff3bd6d4429e727322",
    "2.8.0-dev.8": "d516bd2a52ad91031ba1c2ff3bd6d4429e727322",
    "2.8.0-dev.9": "d516bd2a52ad91031ba1c2ff3bd6d4429e727322",
    "2.8.0-dev.10": "296e3b5c93fde73fdf2df594765395c51ddbdae0",
    "2.8.0-dev.11": "296e3b5c93fde73fdf2df594765395c51ddbdae0",
    "2.8.0-dev.12": "a1097622fd3779393f345f246e050da017d3aa2d",
    "2.8.0-dev.13": "97b83cec7c1e2276d16624341947ddf44379cff6",
    "2.8.0-dev.14": "97b83cec7c1e2276d16624341947ddf44379cff6",
    "2.8.0-dev.15": "014c300b2749e2f856db131ea8fdc8ad4a3c00e8",
    "2.8.0-dev.16": "16b2e7be003d50a60b7f0ebff88ae7e2c8caf863",
    "2.8.0-dev.17": "16b2e7be003d50a60b7f0ebff88ae7e2c8caf863",
    "2.8.0-dev.18": "16b2e7be003d50a60b7f0ebff88ae7e2c8caf863",
    "2.8.0-dev.19": "16b2e7be003d50a60b7f0ebff88ae7e2c8caf863",
    "2.8.0-dev.20": "16b2e7be003d50a60b7f0ebff88ae7e2c8caf863",
    "2.8.0-dev.21": "16b2e7be003d50a60b7f0ebff88ae7e2c8caf863",
    "2.8.0-dev.22": "2c8f6b14f5d65afe712de0b8b7a18eae29446d45",
    "2.8.0-dev.23": "1c3ee33299fa6f9ae067f6b37867467d1749f74d",
    "2.8.0-dev.24": "4ad878f36e79cf50b5b4f9781fd8be266a2e8eea",
    "2.8.0-dev.25": "b2ba0251835a0fb068871fe65272136853245dd3",
    "2.8.0-dev.26": "ee3559ca54391582e5fe8c208f93ae6e178aeed8",
    "2.8.0-dev.27": "7aef029819840cd88e6333b5037105264c82e2f4",
    "2.8.0-dev.28": "37b9492b5e3f80c980323b027712a9ec227ebb07",
    "2.8.0-dev.29": "37b9492b5e3f80c980323b027712a9ec227ebb07",
    "2.8.0-dev.30": "62fcc29194c5c1ed16d16c65c21b944d60acfd81",
    "2.8.0-dev.31": "62fcc29194c5c1ed16d16c65c21b944d60acfd81",
    "2.8.0-dev.32": "62fcc29194c5c1ed16d16c65c21b944d60acfd81",
    "2.8.0-dev.33": "62fcc29194c5c1ed16d16c65c21b944d60acfd81",
    "2.8.0-dev.34": "9b958b23288b9108f357c08d16ab5a054e9456b8",
    "2.8.0-dev.35": "9b958b23288b9108f357c08d16ab5a054e9456b8",
    "2.8.0-dev.36": "9b958b23288b9108f357c08d16ab5a054e9456b8",
    "2.8.0-dev.37": "5ed0deef17ce35faf058462e43ccc86fed761dfe",
    "2.8.0-dev.38": "fc6db18a9ab2e659cbf600340f5d4f4abb0b1974",
    "2.8.0-dev.39": "4a88935fd579c4284cec066046b3fcfe32f0c0fa",
    "2.8.0-dev.40": "eff0f4d1aecdbd12d9f5ca2ff0a21b54f4b90bf5",
    "2.8.0-dev.41": "3eba5fc0d5e2f0b42c495e3fcb677f16157a0549",
    "2.8.0-dev.42": "3eba5fc0d5e2f0b42c495e3fcb677f16157a0549",
    "2.8.0-dev.43": "2c65c7e137baad4c34f9d7c410633f3b0398a373",
    "2.8.0-dev.44": "4f4fb2e5ea3d830a9cf8f4e83b824f844fa43a0d",
    "2.8.0-dev.45": "2c65c7e137baad4c34f9d7c410633f3b0398a373",
    "2.8.0-dev.46": "2c65c7e137baad4c34f9d7c410633f3b0398a373",
    "2.8.0-dev.47": "2c65c7e137baad4c34f9d7c410633f3b0398a373",
    "2.8.0-dev.48": "301a95d643e1ba39474bb520faba726ce856884c",
    "2.8.0-dev.49": "301a95d643e1ba39474bb520faba726ce856884c",
    "2.8.0-dev.50": "b2d67bfad6619134331404603b61ab85fde90771",
    "2.8.0-dev.51": "aff73c7aeee85c32082de75962424f199530284d"
  };
});

// ../sdk/dist/getAllVersions.js
var require_getAllVersions = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    engineVersions: () => import_versions.engineVersions
  });
  var import_versions = __toModule3(require_versions());
});

// ../sdk/dist/pick.js
var require_pick = __commonJS2((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    pick: () => pick2
  });
  function pick2(obj, keys) {
    return Object.entries(obj).reduce((acc, [key, value]) => {
      if (keys.includes(key)) {
        acc[key] = value;
      }
      return acc;
    }, {});
  }
});

// ../../node_modules/.pnpm/has-yarn@2.1.0/node_modules/has-yarn/index.js
var require_has_yarn = __commonJS2((exports2, module2) => {
  "use strict";
  var path4 = require("path");
  var fs2 = require("fs");
  var hasYarn = (cwd = process.cwd()) => fs2.existsSync(path4.resolve(cwd, "yarn.lock"));
  module2.exports = hasYarn;
  module2.exports.default = hasYarn;
});

// ../sdk/dist/utils/resolve.js
var require_resolve2 = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    resolve: () => resolve,
    resolvePkg: () => resolvePkg
  });
  var import_resolve = __toModule3(require_resolve());
  var import_path4 = __toModule3(require("path"));
  async function resolve(id, options) {
    const _options = {preserveSymlinks: false, ...options};
    return new Promise((res) => {
      (0, import_resolve.default)(id, _options, (e, v) => {
        if (e)
          res(void 0);
        res(v);
      });
    });
  }
  async function resolvePkg(id, options) {
    const resolvedPath = await resolve(`${id}/package.json`, options);
    return resolvedPath && import_path4.default.dirname(resolvedPath);
  }
});

// ../sdk/dist/predefinedGeneratorResolvers.js
var require_predefinedGeneratorResolvers = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    predefinedGeneratorResolvers: () => predefinedGeneratorResolvers
  });
  var import_debug3 = __toModule3(require_dist7());
  var import_chalk3 = __toModule3(require_source2());
  var import_execa2 = __toModule3(require_execa2());
  var import_fs2 = __toModule3(require("fs"));
  var import_has_yarn = __toModule3(require_has_yarn());
  var import_path4 = __toModule3(require("path"));
  var import_resolve = __toModule3(require_resolve2());
  var import__2 = __toModule3(require_dist19());
  var import_getCommandWithExecutor = __toModule3(require_getCommandWithExecutor());
  var debug4 = (0, import_debug3.default)("prisma:generator");
  var realPath = import_fs2.default.promises.realpath;
  async function findPrismaClientDir(baseDir) {
    const resolveOpts = {basedir: baseDir, preserveSymlinks: true};
    const CLIDir = await (0, import_resolve.resolvePkg)("prisma", resolveOpts);
    const clientDir = await (0, import_resolve.resolvePkg)("@prisma/client", resolveOpts);
    const resolvedClientDir = clientDir && await realPath(clientDir);
    debug4("prismaCLIDir", CLIDir);
    debug4("prismaClientDir", clientDir);
    if (CLIDir === void 0)
      return resolvedClientDir;
    if (clientDir === void 0)
      return resolvedClientDir;
    const relDir = import_path4.default.relative(CLIDir, clientDir).split(import_path4.default.sep);
    if (relDir[0] !== ".." || relDir[1] === "..")
      return void 0;
    return resolvedClientDir;
  }
  var predefinedGeneratorResolvers = {
    photonjs: () => {
      throw new Error(`Oops! Photon has been renamed to Prisma Client. Please make the following adjustments:
  1. Rename ${import_chalk3.default.red('provider = "photonjs"')} to ${import_chalk3.default.green('provider = "prisma-client-js"')} in your ${import_chalk3.default.bold("schema.prisma")} file.
  2. Replace your ${import_chalk3.default.bold("package.json")}'s ${import_chalk3.default.red("@prisma/photon")} dependency to ${import_chalk3.default.green("@prisma/client")}
  3. Replace ${import_chalk3.default.red("import { Photon } from '@prisma/photon'")} with ${import_chalk3.default.green("import { PrismaClient } from '@prisma/client'")} in your code.
  4. Run ${import_chalk3.default.green((0, import_getCommandWithExecutor.getCommandWithExecutor)("prisma generate"))} again.
      `);
    },
    "prisma-client-js": async (baseDir, version) => {
      let prismaClientDir = await findPrismaClientDir(baseDir);
      debug4("baseDir", baseDir);
      checkYarnVersion();
      await checkTypeScriptVersion();
      if (!prismaClientDir && !process.env.PRISMA_GENERATE_SKIP_AUTOINSTALL) {
        if (!import_fs2.default.existsSync(import_path4.default.join(process.cwd(), "package.json")) && !import_fs2.default.existsSync(import_path4.default.join(process.cwd(), "../package.json"))) {
          const defaultPackageJson = `{
  "name": "my-prisma-project",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \\"Error: no test specified\\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
`;
          import_fs2.default.writeFileSync(import_path4.default.join(process.cwd(), "package.json"), defaultPackageJson);
          console.info(`\u2714 Created ${import_chalk3.default.bold.green("./package.json")}`);
        }
        await installPackage(baseDir, `-D prisma@${version != null ? version : "latest"}`);
        await installPackage(baseDir, `@prisma/client@${version != null ? version : "latest"}`);
        prismaClientDir = await findPrismaClientDir(import_path4.default.join(".", baseDir));
        if (!prismaClientDir) {
          throw new Error(`Could not resolve @prisma/client despite the installation that we just tried.
Please try to install it by hand with ${import_chalk3.default.bold.greenBright("npm install @prisma/client")} and rerun ${import_chalk3.default.bold((0, import_getCommandWithExecutor.getCommandWithExecutor)("prisma generate"))} \u{1F64F}.`);
        }
        console.info(`
\u2714 Installed the ${import_chalk3.default.bold.green("@prisma/client")} and ${import_chalk3.default.bold.green("prisma")} packages in your project`);
      }
      if (!prismaClientDir) {
        throw new Error(`Could not resolve @prisma/client.
Please try to install it with ${import_chalk3.default.bold.greenBright("npm install @prisma/client")} and rerun ${import_chalk3.default.bold((0, import_getCommandWithExecutor.getCommandWithExecutor)("prisma generate"))} \u{1F64F}.`);
      }
      return {
        outputPath: prismaClientDir,
        generatorPath: import_path4.default.resolve(prismaClientDir, "generator-build/index.js"),
        isNode: true
      };
    }
  };
  async function installPackage(baseDir, pkg2) {
    const yarnUsed = (0, import_has_yarn.default)(baseDir) || (0, import_has_yarn.default)(import_path4.default.join(baseDir, ".."));
    const cmdName = yarnUsed ? "yarn add" : "npm install";
    await import_execa2.default.command(`${cmdName} ${pkg2}`, {
      cwd: baseDir,
      stdio: "inherit",
      env: {
        PRISMA_SKIP_POSTINSTALL_GENERATE: "true"
      }
    });
  }
  function checkYarnVersion() {
    if (process.env.npm_config_user_agent) {
      const match = parseUserAgentString(process.env.npm_config_user_agent);
      if (match) {
        const {agent, major, minor, patch} = match;
        if (agent === "yarn" && major === 1) {
          const currentYarnVersion = `${major}.${minor}.${patch}`;
          const minYarnVersion = "1.19.2";
          if (semverLt(currentYarnVersion, minYarnVersion)) {
            import__2.logger.warn(`Your ${import_chalk3.default.bold("yarn")} has version ${currentYarnVersion}, which is outdated. Please update it to ${import_chalk3.default.bold(minYarnVersion)} or ${import_chalk3.default.bold("newer")} in order to use Prisma.`);
          }
        }
      }
    }
  }
  async function checkTypeScriptVersion() {
    const minVersion = "4.1.0";
    try {
      const typescriptPath = await (0, import_resolve.resolvePkg)("typescript", {
        basedir: process.cwd()
      });
      const typescriptPkg = typescriptPath && import_path4.default.join(typescriptPath, "package.json");
      if (typescriptPkg && import_fs2.default.existsSync(typescriptPkg)) {
        const pjson = require(typescriptPkg);
        const currentVersion = pjson.version;
        if (semverLt(currentVersion, minVersion)) {
          import__2.logger.warn(`Prisma detected that your ${import_chalk3.default.bold("TypeScript")} version ${currentVersion} is outdated. If you want to use Prisma Client with TypeScript please update it to version ${import_chalk3.default.bold(minVersion)} or ${import_chalk3.default.bold("newer")}`);
        }
      }
    } catch (e) {
    }
  }
  function semverLt(a, b) {
    const [major1, minor1, patch1] = a.split(".");
    const [major2, minor2, patch2] = b.split(".");
    if (major1 < major2) {
      return true;
    }
    if (major1 > major2) {
      return false;
    }
    if (minor1 < minor2) {
      return true;
    }
    if (minor1 > minor2) {
      return false;
    }
    if (patch1 < patch2) {
      return true;
    }
    if (patch1 > patch2) {
      return false;
    }
    return false;
  }
  function parseUserAgentString(str) {
    const userAgentRegex = /(\w+)\/(\d+)\.(\d+)\.(\d+)/;
    const match = userAgentRegex.exec(str);
    if (match) {
      const agent = match[1];
      const major = parseInt(match[2]);
      const minor = parseInt(match[3]);
      const patch = parseInt(match[4]);
      return {agent, major, minor, patch};
    }
    return null;
  }
});

// ../sdk/dist/resolveOutput.js
var require_resolveOutput = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    resolveOutput: () => resolveOutput
  });
  var import_fs2 = __toModule3(require("fs"));
  var import_path4 = __toModule3(require("path"));
  var import_util3 = __toModule3(require("util"));
  var exists2 = (0, import_util3.promisify)(import_fs2.default.exists);
  async function resolveNodeModulesBase(cwd) {
    if (await exists2(import_path4.default.resolve(process.cwd(), "prisma/schema.prisma"))) {
      return process.cwd();
    }
    if (import_path4.default.relative(process.cwd(), cwd) === "prisma" && await exists2(import_path4.default.resolve(process.cwd(), "package.json"))) {
      return process.cwd();
    }
    if (await exists2(import_path4.default.resolve(cwd, "node_modules"))) {
      return cwd;
    }
    if (await exists2(import_path4.default.resolve(cwd, "../node_modules"))) {
      return import_path4.default.join(cwd, "../");
    }
    if (await exists2(import_path4.default.resolve(cwd, "package.json"))) {
      return cwd;
    }
    if (await exists2(import_path4.default.resolve(cwd, "../package.json"))) {
      return import_path4.default.join(cwd, "../");
    }
    return cwd;
  }
  async function resolveOutput(options) {
    const defaultOutput = stripRelativePath(options.defaultOutput);
    if (defaultOutput.startsWith("node_modules")) {
      const nodeModulesBase = await resolveNodeModulesBase(options.baseDir);
      return import_path4.default.resolve(nodeModulesBase, defaultOutput);
    }
    return import_path4.default.resolve(options.baseDir, defaultOutput);
  }
  function stripRelativePath(pathString) {
    if (pathString.startsWith("./")) {
      return pathString.slice(2);
    }
    return pathString;
  }
});

// ../sdk/dist/utils/parseEnvValue.js
var require_parseEnvValue = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    parseBinaryTargetsEnvValue: () => parseBinaryTargetsEnvValue2,
    parseEnvValue: () => parseEnvValue3
  });
  var import_chalk3 = __toModule3(require_source2());
  function parseEnvValue3(object) {
    if (object.fromEnvVar && object.fromEnvVar != "null") {
      const value = process.env[object.fromEnvVar];
      if (!value) {
        throw new Error(`Attempted to load provider value using \`env(${object.fromEnvVar})\` but it was not present. Please ensure that ${import_chalk3.default.dim(object.fromEnvVar)} is present in your Environment Variables`);
      }
      return value;
    }
    return object.value;
  }
  function parseBinaryTargetsEnvValue2(object) {
    if (object.fromEnvVar && object.fromEnvVar != "null") {
      const value = process.env[object.fromEnvVar];
      if (!value) {
        throw new Error(`Attempted to load binaryTargets value using \`env(${object.fromEnvVar})\` but it was not present. Please ensure that ${import_chalk3.default.dim(object.fromEnvVar)} is present in your Environment Variables`);
      }
      return JSON.parse(value);
    }
    return object.value;
  }
});

// ../sdk/dist/utils/extractPreviewFeatures.js
var require_extractPreviewFeatures = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    extractPreviewFeatures: () => extractPreviewFeatures2
  });
  var import_parseEnvValue2 = __toModule3(require_parseEnvValue());
  function extractPreviewFeatures2(config2) {
    var _a;
    return ((_a = config2.generators.find((g) => (0, import_parseEnvValue2.parseEnvValue)(g.provider) === "prisma-client-js")) == null ? void 0 : _a.previewFeatures) || [];
  }
});

// ../sdk/dist/utils/mapPreviewFeatures.js
var require_mapPreviewFeatures = __commonJS2((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    mapPreviewFeatures: () => mapPreviewFeatures2
  });
  var featureFlagMap = {
    transactionApi: "transaction",
    aggregateApi: "aggregations"
  };
  function mapPreviewFeatures2(features) {
    if (Array.isArray(features) && features.length > 0) {
      return features.map((f) => {
        var _a;
        return (_a = featureFlagMap[f]) != null ? _a : f;
      });
    }
    return [];
  }
});

// ../sdk/dist/highlight/theme.js
var require_theme = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    blue: () => blue,
    brightBlue: () => brightBlue,
    darkBrightBlue: () => darkBrightBlue,
    gamboge: () => gamboge,
    identity: () => identity,
    theme: () => theme
  });
  var import_chalk3 = __toModule3(require_source2());
  var gamboge = import_chalk3.default.rgb(228, 155, 15);
  var darkBrightBlue = import_chalk3.default.rgb(107, 139, 140);
  var blue = import_chalk3.default.cyan;
  var brightBlue = import_chalk3.default.rgb(127, 155, 175);
  var identity = (str) => str || "";
  var theme = {
    keyword: blue,
    entity: blue,
    value: brightBlue,
    punctuation: darkBrightBlue,
    directive: blue,
    function: blue,
    variable: brightBlue,
    string: brightBlue,
    boolean: gamboge,
    comment: import_chalk3.default.dim
  };
});

// ../sdk/dist/highlight/prism.js
var require_prism = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    Prism: () => Prism,
    Token: () => Token
  });
  var import_theme = __toModule3(require_theme());
  var _self = {};
  var uniqueId = 0;
  var Prism = {
    manual: _self.Prism && _self.Prism.manual,
    disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,
    util: {
      encode: function(tokens) {
        if (tokens instanceof Token) {
          const anyTokens = tokens;
          return new Token(anyTokens.type, Prism.util.encode(anyTokens.content), anyTokens.alias);
        } else if (Array.isArray(tokens)) {
          return tokens.map(Prism.util.encode);
        } else {
          return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
        }
      },
      type: function(o) {
        return Object.prototype.toString.call(o).slice(8, -1);
      },
      objId: function(obj) {
        if (!obj["__id"]) {
          Object.defineProperty(obj, "__id", {value: ++uniqueId});
        }
        return obj["__id"];
      },
      clone: function deepClone(o, visited) {
        visited = visited || {};
        let clone2, id;
        const type = Prism.util.type(o);
        switch (type) {
          case "Object":
            id = Prism.util.objId(o);
            if (visited[id]) {
              return visited[id];
            }
            clone2 = {};
            visited[id] = clone2;
            for (const key in o) {
              if (o.hasOwnProperty(key)) {
                clone2[key] = deepClone(o[key], visited);
              }
            }
            return clone2;
          case "Array":
            id = Prism.util.objId(o);
            if (visited[id]) {
              return visited[id];
            }
            clone2 = [];
            visited[id] = clone2;
            o.forEach(function(v, i) {
              clone2[i] = deepClone(v, visited);
            });
            return clone2;
          default:
            return o;
        }
      }
    },
    languages: {
      extend: function(id, redef) {
        const lang = Prism.util.clone(Prism.languages[id]);
        for (const key in redef) {
          lang[key] = redef[key];
        }
        return lang;
      },
      insertBefore: function(inside, before, insert, root) {
        root = root || Prism.languages;
        const grammar = root[inside];
        const ret = {};
        for (const token in grammar) {
          if (grammar.hasOwnProperty(token)) {
            if (token == before) {
              for (const newToken in insert) {
                if (insert.hasOwnProperty(newToken)) {
                  ret[newToken] = insert[newToken];
                }
              }
            }
            if (!insert.hasOwnProperty(token)) {
              ret[token] = grammar[token];
            }
          }
        }
        const old = root[inside];
        root[inside] = ret;
        Prism.languages.DFS(Prism.languages, function(key, value) {
          if (value === old && key != inside) {
            this[key] = ret;
          }
        });
        return ret;
      },
      DFS: function DFS(o, callback, type, visited) {
        visited = visited || {};
        const objId = Prism.util.objId;
        for (const i in o) {
          if (o.hasOwnProperty(i)) {
            callback.call(o, i, o[i], type || i);
            const property = o[i], propertyType = Prism.util.type(property);
            if (propertyType === "Object" && !visited[objId(property)]) {
              visited[objId(property)] = true;
              DFS(property, callback, null, visited);
            } else if (propertyType === "Array" && !visited[objId(property)]) {
              visited[objId(property)] = true;
              DFS(property, callback, i, visited);
            }
          }
        }
      }
    },
    plugins: {},
    highlight: function(text, grammar, language) {
      const env2 = {
        code: text,
        grammar,
        language
      };
      Prism.hooks.run("before-tokenize", env2);
      env2.tokens = Prism.tokenize(env2.code, env2.grammar);
      Prism.hooks.run("after-tokenize", env2);
      return Token.stringify(Prism.util.encode(env2.tokens), env2.language);
    },
    matchGrammar: function(text, strarr, grammar, index, startPos, oneshot, target) {
      for (const token in grammar) {
        if (!grammar.hasOwnProperty(token) || !grammar[token]) {
          continue;
        }
        if (token == target) {
          return;
        }
        let patterns = grammar[token];
        patterns = Prism.util.type(patterns) === "Array" ? patterns : [patterns];
        for (let j = 0; j < patterns.length; ++j) {
          let pattern = patterns[j], inside = pattern.inside, lookbehind = !!pattern.lookbehind, greedy = !!pattern.greedy, lookbehindLength = 0, alias = pattern.alias;
          if (greedy && !pattern.pattern.global) {
            const flags = pattern.pattern.toString().match(/[imuy]*$/)[0];
            pattern.pattern = RegExp(pattern.pattern.source, flags + "g");
          }
          pattern = pattern.pattern || pattern;
          for (let i = index, pos = startPos; i < strarr.length; pos += strarr[i].length, ++i) {
            let str = strarr[i];
            if (strarr.length > text.length) {
              return;
            }
            if (str instanceof Token) {
              continue;
            }
            if (greedy && i != strarr.length - 1) {
              pattern.lastIndex = pos;
              const match2 = pattern.exec(text);
              if (!match2) {
                break;
              }
              var from = match2.index + (lookbehind ? match2[1].length : 0), to = match2.index + match2[0].length, k = i, p = pos;
              for (let len = strarr.length; k < len && (p < to || !strarr[k].type && !strarr[k - 1].greedy); ++k) {
                p += strarr[k].length;
                if (from >= p) {
                  ++i;
                  pos = p;
                }
              }
              if (strarr[i] instanceof Token) {
                continue;
              }
              delNum = k - i;
              str = text.slice(pos, p);
              match2.index -= pos;
            } else {
              pattern.lastIndex = 0;
              var match = pattern.exec(str), delNum = 1;
            }
            if (!match) {
              if (oneshot) {
                break;
              }
              continue;
            }
            if (lookbehind) {
              lookbehindLength = match[1] ? match[1].length : 0;
            }
            var from = match.index + lookbehindLength, match = match[0].slice(lookbehindLength), to = from + match.length, before = str.slice(0, from), after = str.slice(to);
            const args = [i, delNum];
            if (before) {
              ++i;
              pos += before.length;
              args.push(before);
            }
            const wrapped = new Token(token, inside ? Prism.tokenize(match, inside) : match, alias, match, greedy);
            args.push(wrapped);
            if (after) {
              args.push(after);
            }
            Array.prototype.splice.apply(strarr, args);
            if (delNum != 1)
              Prism.matchGrammar(text, strarr, grammar, i, pos, true, token);
            if (oneshot)
              break;
          }
        }
      }
    },
    tokenize: function(text, grammar) {
      const strarr = [text];
      const rest = grammar.rest;
      if (rest) {
        for (const token in rest) {
          grammar[token] = rest[token];
        }
        delete grammar.rest;
      }
      Prism.matchGrammar(text, strarr, grammar, 0, 0, false);
      return strarr;
    },
    hooks: {
      all: {},
      add: function(name, callback) {
        const hooks = Prism.hooks.all;
        hooks[name] = hooks[name] || [];
        hooks[name].push(callback);
      },
      run: function(name, env2) {
        const callbacks = Prism.hooks.all[name];
        if (!callbacks || !callbacks.length) {
          return;
        }
        for (var i = 0, callback; callback = callbacks[i++]; ) {
          callback(env2);
        }
      }
    },
    Token
  };
  Prism.languages.clike = {
    comment: [
      {
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: true
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: true,
        greedy: true
      }
    ],
    string: {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: true
    },
    "class-name": {
      pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i,
      lookbehind: true,
      inside: {
        punctuation: /[.\\]/
      }
    },
    keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
    boolean: /\b(?:true|false)\b/,
    function: /\w+(?=\()/,
    number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,
    operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
    punctuation: /[{}[\];(),.:]/
  };
  Prism.languages.javascript = Prism.languages.extend("clike", {
    "class-name": [
      Prism.languages.clike["class-name"],
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/,
        lookbehind: true
      }
    ],
    keyword: [
      {
        pattern: /((?:^|})\s*)(?:catch|finally)\b/,
        lookbehind: true
      },
      {
        pattern: /(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
        lookbehind: true
      }
    ],
    number: /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,
    function: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    operator: /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/
  });
  Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;
  Prism.languages.insertBefore("javascript", "keyword", {
    regex: {
      pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/,
      lookbehind: true,
      greedy: true
    },
    "function-variable": {
      pattern: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/,
      alias: "function"
    },
    parameter: [
      {
        pattern: /(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/,
        lookbehind: true,
        inside: Prism.languages.javascript
      },
      {
        pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i,
        inside: Prism.languages.javascript
      },
      {
        pattern: /(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/,
        lookbehind: true,
        inside: Prism.languages.javascript
      },
      {
        pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/,
        lookbehind: true,
        inside: Prism.languages.javascript
      }
    ],
    constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
  });
  Prism.languages.insertBefore("javascript", "string", {
    "template-string": {
      pattern: /`(?:\\[\s\S]|\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}|[^\\`])*`/,
      greedy: true,
      inside: {
        interpolation: {
          pattern: /\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}/,
          inside: {
            "interpolation-punctuation": {
              pattern: /^\${|}$/,
              alias: "punctuation"
            },
            rest: Prism.languages.javascript
          }
        },
        string: /[\s\S]+/
      }
    }
  });
  if (Prism.languages.markup) {
    Prism.languages.markup.tag.addInlined("script", "javascript");
  }
  Prism.languages.js = Prism.languages.javascript;
  Prism.languages.typescript = Prism.languages.extend("javascript", {
    keyword: /\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\b/,
    builtin: /\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/
  });
  Prism.languages.ts = Prism.languages.typescript;
  function Token(type, content, alias, matchedStr, greedy) {
    this.type = type;
    this.content = content;
    this.alias = alias;
    this.length = (matchedStr || "").length | 0;
    this.greedy = !!greedy;
  }
  Token.stringify = function(o, language) {
    if (typeof o == "string") {
      return o;
    }
    if (Array.isArray(o)) {
      return o.map(function(element) {
        return Token.stringify(element, language);
      }).join("");
    }
    return getColorForSyntaxKind(o.type)(o.content);
  };
  function getColorForSyntaxKind(syntaxKind) {
    return import_theme.theme[syntaxKind] || import_theme.identity;
  }
});

// ../sdk/dist/highlight/languages/dml.js
var require_dml = __commonJS2((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    dml: () => dml
  });
  var dml = {
    string: [/\"(.*)\"/g, /\'(.*)\'/g],
    directive: {pattern: /(@.*)/g},
    entity: [
      /model\s+\w+/g,
      /enum\s+\w+/g,
      /datasource\s+\w+/g,
      /source\s+\w+/g,
      /generator\s+\w+/g
    ],
    comment: /#.*/g,
    value: [/\b\s+(\w+)/g],
    punctuation: /(\:|}|{|"|=)/g,
    boolean: /(true|false)/g
  };
});

// ../sdk/dist/highlight/languages/sql.js
var require_sql = __commonJS2((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    sql: () => sql
  });
  var sql = {
    comment: {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
      lookbehind: true
    },
    variable: [
      {
        pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
        greedy: true
      },
      /@[\w.$]+/
    ],
    string: {
      pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
      greedy: true,
      lookbehind: true
    },
    function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
    keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:_INSERT|COL)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURNS?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
    boolean: /\b(?:TRUE|FALSE|NULL)\b/i,
    number: /\b0x[\da-f]+\b|\b\d+\.?\d*|\B\.\d+\b/i,
    operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|IN|LIKE|NOT|OR|IS|DIV|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
    punctuation: /[;[\]()`,.]/
  };
});

// ../sdk/dist/highlight/highlight.js
var require_highlight = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    highlightDatamodel: () => highlightDatamodel2,
    highlightSql: () => highlightSql2,
    highlightTS: () => highlightTS2
  });
  var import_prism = __toModule3(require_prism());
  var import_dml = __toModule3(require_dml());
  var import_sql = __toModule3(require_sql());
  function highlightDatamodel2(str) {
    return highlight(str, import_dml.dml);
  }
  function highlightSql2(str) {
    return highlight(str, import_sql.sql);
  }
  function highlightTS2(str) {
    return highlight(str, import_prism.Prism.languages.javascript);
  }
  function highlight(str, grammar) {
    const tokens = import_prism.Prism.tokenize(str, grammar);
    return tokens.map((t) => import_prism.Token.stringify(t)).join("");
  }
});

// ../sdk/dist/link.js
var require_link = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    link: () => link2
  });
  var import_terminal_link = __toModule3(require_terminal_link());
  var import_chalk3 = __toModule3(require_source2());
  function link2(url) {
    return (0, import_terminal_link.default)(url, url, {
      fallback: (url2) => import_chalk3.default.underline(url2)
    });
  }
});

// ../sdk/dist/utils/missingDatasource.js
var require_missingDatasource = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    missingDatasource: () => missingDatasource
  });
  var import_chalk3 = __toModule3(require_source2());
  var import_highlight = __toModule3(require_highlight());
  var import_link = __toModule3(require_link());
  var missingDatasource = `
You don't have any ${import_chalk3.default.bold("datasource")} defined in your ${import_chalk3.default.bold("schema.prisma")}.
You can define a datasource like this:

${import_chalk3.default.bold((0, import_highlight.highlightDatamodel)(`datasource db {
  provider = "postgresql"
  url      = env("DB_URL")
}`))}

More information in our documentation:
${(0, import_link.link)("https://pris.ly/d/prisma-schema")}
`;
});

// ../sdk/dist/utils/missingGeneratorMessage.js
var require_missingGeneratorMessage = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    missingGeneratorMessage: () => missingGeneratorMessage2,
    missingModelMessage: () => missingModelMessage,
    missingModelMessageMongoDB: () => missingModelMessageMongoDB
  });
  var import_chalk3 = __toModule3(require_source2());
  var import_highlight = __toModule3(require_highlight());
  var import_link = __toModule3(require_link());
  var missingGeneratorMessage2 = `
${import_chalk3.default.blue("info")} You don't have any generators defined in your ${import_chalk3.default.bold("schema.prisma")}, so nothing will be generated.
You can define them like this:

${import_chalk3.default.bold((0, import_highlight.highlightDatamodel)(`generator client {
  provider = "prisma-client-js"
}`))}`;
  var missingModelMessage = `
You don't have any ${import_chalk3.default.bold("models")} defined in your ${import_chalk3.default.bold("schema.prisma")}, so nothing will be generated.
You can define a model like this:

${import_chalk3.default.bold((0, import_highlight.highlightDatamodel)(`model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
}`))}

More information in our documentation:
${(0, import_link.link)("https://pris.ly/d/prisma-schema")}
`;
  var missingModelMessageMongoDB = `
You don't have any ${import_chalk3.default.bold("models")} defined in your ${import_chalk3.default.bold("schema.prisma")}, so nothing will be generated.
You can define a model like this:

${import_chalk3.default.bold((0, import_highlight.highlightDatamodel)(`model User {
  id    String  @id @default(dbgenerated()) @map("_id") @db.ObjectId
  email String  @unique
  name  String?
}`))}

More information in our documentation:
${(0, import_link.link)("https://pris.ly/d/prisma-schema")}
`;
});

// ../sdk/dist/utils/mongoFeatureFlagMissingMessage.js
var require_mongoFeatureFlagMissingMessage = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    mongoFeatureFlagMissingMessage: () => mongoFeatureFlagMissingMessage
  });
  var import_chalk3 = __toModule3(require_source2());
  var import_highlight = __toModule3(require_highlight());
  var import_link = __toModule3(require_link());
  var mongoFeatureFlagMissingMessage = `
In order to use the ${import_chalk3.default.bold("mongodb")} provider,
you need to set the ${import_chalk3.default.green("mongodb")} feature flag.
You can define the feature flag like this:

${import_chalk3.default.bold((0, import_highlight.highlightDatamodel)(`generator client {
    provider = "prisma-client-js"
    previewFeatures = ["mongodb"]
  }`))}

More information in our documentation:
${(0, import_link.link)("https://pris.ly/d/prisma-schema")}
`;
});

// ../sdk/dist/utils/printConfigWarnings.js
var require_printConfigWarnings = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    printConfigWarnings: () => printConfigWarnings2
  });
  var import_chalk3 = __toModule3(require_source2());
  function printConfigWarnings2(warnings) {
    if (warnings && warnings.length > 0) {
      const message = warnings.map((warning) => `${import_chalk3.default.yellow("warn")} ${warning}`).join("\n");
      console.warn(message);
    }
  }
});

// ../sdk/dist/getGenerators.js
var require_getGenerators = __commonJS2((exports, module) => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name in all)
      __defProp(target, name, {get: all[name], enumerable: true});
  };
  var __reExport = (target, module2, desc) => {
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
      for (let key of __getOwnPropNames(module2))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule = (module2) => {
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
  };
  __export(exports, {
    getGenerator: () => getGenerator,
    getGenerators: () => getGenerators,
    knownBinaryTargets: () => knownBinaryTargets,
    skipIndex: () => skipIndex
  });
  var import_debug = __toModule(require_dist7());
  var import_engine_core = __toModule(require_dist17());
  var import_engines = __toModule(require_dist16());
  var import_fetch_engine = __toModule(require_dist15());
  var import_get_platform = __toModule(require_dist11());
  var import_chalk = __toModule(require_source2());
  var import_fs = __toModule(require("fs"));
  var import_make_dir = __toModule(require_make_dir2());
  var import_p_map = __toModule(require_p_map3());
  var import_path = __toModule(require("path"));
  var import__ = __toModule(require_dist19());
  var import_Generator = __toModule(require_Generator());
  var import_getAllVersions = __toModule(require_getAllVersions());
  var import_pick = __toModule(require_pick());
  var import_predefinedGeneratorResolvers = __toModule(require_predefinedGeneratorResolvers());
  var import_resolveOutput = __toModule(require_resolveOutput());
  var import_extractPreviewFeatures = __toModule(require_extractPreviewFeatures());
  var import_mapPreviewFeatures = __toModule(require_mapPreviewFeatures());
  var import_missingDatasource = __toModule(require_missingDatasource());
  var import_missingGeneratorMessage = __toModule(require_missingGeneratorMessage());
  var import_mongoFeatureFlagMissingMessage = __toModule(require_mongoFeatureFlagMissingMessage());
  var import_parseEnvValue = __toModule(require_parseEnvValue());
  var import_printConfigWarnings = __toModule(require_printConfigWarnings());
  var debug = (0, import_debug.default)("prisma:getGenerators");
  async function getGenerators({
    schemaPath,
    providerAliases: aliases,
    version,
    cliVersion,
    printDownloadProgress,
    baseDir = import_path.default.dirname(schemaPath),
    overrideGenerators,
    skipDownload,
    binaryPathsOverride
  }) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    if (!schemaPath) {
      throw new Error(`schemaPath for getGenerators got invalid value ${schemaPath}`);
    }
    if (!import_fs.default.existsSync(schemaPath)) {
      throw new Error(`${schemaPath} does not exist`);
    }
    const platform = await (0, import_get_platform.getPlatform)();
    const queryEngineBinaryType = (0, import_engines.getCliQueryEngineBinaryType)();
    const queryEngineType = binaryTypeToEngineType(queryEngineBinaryType);
    let prismaPath = binaryPathsOverride == null ? void 0 : binaryPathsOverride[queryEngineType];
    if (version && !prismaPath) {
      const potentialPath = eval(`require('path').join(__dirname, '..')`);
      if (!potentialPath.startsWith("/snapshot/")) {
        const downloadParams = {
          binaries: {
            [queryEngineBinaryType]: potentialPath
          },
          binaryTargets: [platform],
          showProgress: false,
          version,
          skipDownload
        };
        const binaryPathsWithEngineType = await (0, import_fetch_engine.download)(downloadParams);
        prismaPath = binaryPathsWithEngineType[queryEngineBinaryType][platform];
      }
    }
    const datamodel = import_fs.default.readFileSync(schemaPath, "utf-8");
    const config = await (0, import__.getConfig)({
      datamodel,
      datamodelPath: schemaPath,
      prismaPath,
      ignoreEnvVarErrors: true
    });
    if (config.datasources.length === 0) {
      throw new Error(import_missingDatasource.missingDatasource);
    }
    (0, import_printConfigWarnings.printConfigWarnings)(config.warnings);
    const previewFeatures = (0, import_mapPreviewFeatures.mapPreviewFeatures)((0, import_extractPreviewFeatures.extractPreviewFeatures)(config));
    const dmmf = await (0, import__.getDMMF)({
      datamodel,
      datamodelPath: schemaPath,
      prismaPath,
      previewFeatures
    });
    if (dmmf.datamodel.models.length === 0) {
      if (config.datasources.some((d2) => d2.provider === "mongodb")) {
        throw new Error(import_missingGeneratorMessage.missingModelMessageMongoDB);
      }
      throw new Error(import_missingGeneratorMessage.missingModelMessage);
    }
    if (config.datasources.some((d2) => d2.provider === "mongodb") && !previewFeatures.includes("mongoDb")) {
      throw new Error(import_mongoFeatureFlagMissingMessage.mongoFeatureFlagMissingMessage);
    }
    const generatorConfigs = overrideGenerators || config.generators;
    await validateGenerators(generatorConfigs);
    const runningGenerators = [];
    try {
      const generators = await (0, import_p_map.default)(generatorConfigs, async (generator, index) => {
        let generatorPath = (0, import_parseEnvValue.parseEnvValue)(generator.provider);
        let paths;
        const providerValue = (0, import_parseEnvValue.parseEnvValue)(generator.provider);
        if (aliases && aliases[providerValue]) {
          generatorPath = aliases[providerValue].generatorPath;
          paths = aliases[providerValue];
        } else if (import_predefinedGeneratorResolvers.predefinedGeneratorResolvers[providerValue]) {
          paths = await import_predefinedGeneratorResolvers.predefinedGeneratorResolvers[providerValue](baseDir, cliVersion);
          generatorPath = paths.generatorPath;
        }
        const generatorInstance = new import_Generator.Generator(generatorPath, generator, paths == null ? void 0 : paths.isNode);
        await generatorInstance.init();
        if (generator.output) {
          generator.output = {
            value: import_path.default.resolve(baseDir, (0, import_parseEnvValue.parseEnvValue)(generator.output)),
            fromEnvVar: null
          };
          generator.isCustomOutput = true;
        } else if (paths) {
          generator.output = {
            value: paths.outputPath,
            fromEnvVar: null
          };
        } else {
          if (!generatorInstance.manifest || !generatorInstance.manifest.defaultOutput) {
            throw new Error(`Can't resolve output dir for generator ${import_chalk.default.bold(generator.name)} with provider ${import_chalk.default.bold(generator.provider)}.
The generator needs to either define the \`defaultOutput\` path in the manifest or you need to define \`output\` in the datamodel.prisma file.`);
          }
          generator.output = {
            value: await (0, import_resolveOutput.resolveOutput)({
              defaultOutput: generatorInstance.manifest.defaultOutput,
              baseDir
            }),
            fromEnvVar: "null"
          };
        }
        const options = {
          datamodel,
          datasources: config.datasources,
          generator,
          dmmf,
          otherGenerators: skipIndex(generatorConfigs, index),
          schemaPath,
          version: version || import_engines.enginesVersion
        };
        generatorInstance.setOptions(options);
        runningGenerators.push(generatorInstance);
        return generatorInstance;
      }, {
        stopOnError: false
      });
      const generatorProviders = generatorConfigs.map((g) => (0, import_parseEnvValue.parseEnvValue)(g.provider));
      for (const g of generators) {
        if (((_a = g == null ? void 0 : g.manifest) == null ? void 0 : _a.requiresGenerators) && ((_b = g == null ? void 0 : g.manifest) == null ? void 0 : _b.requiresGenerators.length) > 0) {
          for (const neededGenerator of (_c = g == null ? void 0 : g.manifest) == null ? void 0 : _c.requiresGenerators) {
            if (!generatorProviders.includes(neededGenerator)) {
              throw new Error(`Generator "${g.manifest.prettyName}" requires generator "${neededGenerator}", but it is missing in your schema.prisma.
Please add it to your schema.prisma:

generator gen {
  provider = "${neededGenerator}"
}
`);
            }
          }
        }
      }
      const neededVersions = Object.create(null);
      for (const g of generators) {
        if (((_d = g.manifest) == null ? void 0 : _d.requiresEngines) && Array.isArray((_e = g.manifest) == null ? void 0 : _e.requiresEngines) && g.manifest.requiresEngines.length > 0) {
          const neededVersion = getEngineVersionForGenerator(g.manifest, version);
          if (!neededVersions[neededVersion]) {
            neededVersions[neededVersion] = {engines: [], binaryTargets: []};
          }
          for (const engine of (_f = g.manifest) == null ? void 0 : _f.requiresEngines) {
            if (!neededVersions[neededVersion].engines.includes(engine)) {
              neededVersions[neededVersion].engines.push(engine);
            }
          }
          const generatorBinaryTargets = (_h = (_g = g.options) == null ? void 0 : _g.generator) == null ? void 0 : _h.binaryTargets;
          if (generatorBinaryTargets && generatorBinaryTargets.length > 0) {
            const binaryTarget0 = generatorBinaryTargets[0];
            if (binaryTarget0.fromEnvVar !== null) {
              const parsedBinaryTargetsEnvValue = (0, import_parseEnvValue.parseBinaryTargetsEnvValue)(binaryTarget0);
              generatorBinaryTargets.shift();
              if (Array.isArray(parsedBinaryTargetsEnvValue)) {
                for (const platformName of parsedBinaryTargetsEnvValue) {
                  generatorBinaryTargets.push({
                    fromEnvVar: binaryTarget0.fromEnvVar,
                    value: platformName
                  });
                }
              } else {
                generatorBinaryTargets.push({
                  fromEnvVar: binaryTarget0.fromEnvVar,
                  value: parsedBinaryTargetsEnvValue
                });
              }
            }
            for (const binaryTarget of generatorBinaryTargets) {
              if (binaryTarget.value === "native") {
                binaryTarget.value = platform;
              }
              if (!neededVersions[neededVersion].binaryTargets.find((object) => object.value === binaryTarget.value)) {
                neededVersions[neededVersion].binaryTargets.push(binaryTarget);
              }
            }
          }
        }
      }
      debug("neededVersions", JSON.stringify(neededVersions, null, 2));
      const binaryPathsByVersion = await getBinaryPathsByVersion({
        neededVersions,
        platform,
        version,
        printDownloadProgress,
        skipDownload,
        binaryPathsOverride
      });
      for (const generator of generators) {
        if (generator.manifest && generator.manifest.requiresEngines) {
          const engineVersion = getEngineVersionForGenerator(generator.manifest, version);
          const binaryPaths = binaryPathsByVersion[engineVersion];
          const generatorBinaryPaths = (0, import_pick.pick)(binaryPaths, generator.manifest.requiresEngines);
          debug({generatorBinaryPaths});
          generator.setBinaryPaths(generatorBinaryPaths);
          if (engineVersion !== version && generator.options && generator.manifest.requiresEngines.includes(queryEngineType) && generatorBinaryPaths[queryEngineType] && ((_i = generatorBinaryPaths[queryEngineType]) == null ? void 0 : _i[platform])) {
            const customDmmf = await (0, import__.getDMMF)({
              datamodel,
              datamodelPath: schemaPath,
              prismaPath: (_j = generatorBinaryPaths[queryEngineType]) == null ? void 0 : _j[platform],
              previewFeatures
            });
            const options = {...generator.options, dmmf: customDmmf};
            debug("generator.manifest.prettyName", generator.manifest.prettyName);
            debug("options", options);
            debug("options.generator.binaryTargets", options.generator.binaryTargets);
            generator.setOptions(options);
          }
        }
      }
      return generators;
    } catch (e) {
      runningGenerators.forEach((g) => g.stop());
      throw e;
    }
  }
  async function getBinaryPathsByVersion({
    neededVersions,
    platform,
    version,
    printDownloadProgress,
    skipDownload,
    binaryPathsOverride
  }) {
    const binaryPathsByVersion = Object.create(null);
    for (const currentVersion in neededVersions) {
      binaryPathsByVersion[currentVersion] = {};
      const neededVersion = neededVersions[currentVersion];
      if (neededVersion.binaryTargets.length === 0) {
        neededVersion.binaryTargets = [{fromEnvVar: null, value: platform}];
      }
      if (process.env.NETLIFY && !neededVersion.binaryTargets.find((object) => object.value === "rhel-openssl-1.0.x")) {
        neededVersion.binaryTargets.push({
          fromEnvVar: null,
          value: "rhel-openssl-1.0.x"
        });
      }
      let binaryTargetBaseDir = eval(`require('path').join(__dirname, '..')`);
      if (version !== currentVersion) {
        binaryTargetBaseDir = import_path.default.join(binaryTargetBaseDir, `./engines/${currentVersion}/`);
        await (0, import_make_dir.default)(binaryTargetBaseDir).catch((e) => console.error(e));
      }
      const binariesConfig = neededVersion.engines.reduce((acc, curr) => {
        if (!(binaryPathsOverride == null ? void 0 : binaryPathsOverride[curr])) {
          acc[engineTypeToBinaryType(curr)] = binaryTargetBaseDir;
        }
        return acc;
      }, Object.create(null));
      if (Object.values(binariesConfig).length > 0) {
        const platforms2 = neededVersion.binaryTargets.map((binaryTarget) => binaryTarget.value);
        const downloadParams = {
          binaries: binariesConfig,
          binaryTargets: platforms2,
          showProgress: typeof printDownloadProgress === "boolean" ? printDownloadProgress : true,
          version: currentVersion && currentVersion !== "latest" ? currentVersion : import_engines.enginesVersion,
          skipDownload
        };
        const binaryPathsWithEngineType = await (0, import_fetch_engine.download)(downloadParams);
        const binaryPaths = mapKeys(binaryPathsWithEngineType, binaryTypeToEngineType);
        binaryPathsByVersion[currentVersion] = binaryPaths;
      }
      if (binaryPathsOverride) {
        const overrideEngines = Object.keys(binaryPathsOverride);
        const enginesCoveredByOverride = neededVersion.engines.filter((engine) => overrideEngines.includes(engine));
        if (enginesCoveredByOverride.length > 0) {
          for (const engine of enginesCoveredByOverride) {
            const enginePath = binaryPathsOverride[engine];
            binaryPathsByVersion[currentVersion][engine] = {
              [platform]: enginePath
            };
          }
        }
      }
    }
    return binaryPathsByVersion;
  }
  async function getGenerator(options) {
    const generators = await getGenerators(options);
    return generators[0];
  }
  function skipIndex(arr, index) {
    return [...arr.slice(0, index), ...arr.slice(index + 1)];
  }
  var knownBinaryTargets = [...import_get_platform.platforms, "native"];
  var oldToNewBinaryTargetsMapping = {
    "linux-glibc-libssl1.0.1": "debian-openssl-1.0.x",
    "linux-glibc-libssl1.0.2": "debian-openssl-1.0.x",
    "linux-glibc-libssl1.1.0": "debian-openssl1.1.x"
  };
  async function validateGenerators(generators) {
    const platform = await (0, import_get_platform.getPlatform)();
    for (const generator of generators) {
      if ((0, import_parseEnvValue.parseEnvValue)(generator.provider) === "photonjs") {
        throw new Error(`Oops! Photon has been renamed to Prisma Client. Please make the following adjustments:
  1. Rename ${import_chalk.default.red('provider = "photonjs"')} to ${import_chalk.default.green('provider = "prisma-client-js"')} in your ${import_chalk.default.bold("schema.prisma")} file.
  2. Replace your ${import_chalk.default.bold("package.json")}'s ${import_chalk.default.red("@prisma/photon")} dependency to ${import_chalk.default.green("@prisma/client")}
  3. Replace ${import_chalk.default.red("import { Photon } from '@prisma/photon'")} with ${import_chalk.default.green("import { PrismaClient } from '@prisma/client'")} in your code.
  4. Run ${import_chalk.default.green("prisma generate")} again.
      `);
      }
      if (generator.config.platforms) {
        throw new Error(`The \`platforms\` field on the generator definition is deprecated. Please rename it to \`binaryTargets\`.`);
      }
      if (generator.config.pinnedBinaryTargets) {
        throw new Error(`The \`pinnedBinaryTargets\` field on the generator definition is deprecated.
Please use the PRISMA_QUERY_ENGINE_BINARY env var instead to pin the binary target.`);
      }
      if (generator.binaryTargets) {
        const binaryTargets = generator.binaryTargets && generator.binaryTargets.length > 0 ? generator.binaryTargets : [{fromEnvVar: null, value: "native"}];
        const resolvedBinaryTargets = binaryTargets.flatMap((object) => (0, import_parseEnvValue.parseBinaryTargetsEnvValue)(object)).map((p) => p === "native" ? platform : p);
        for (const resolvedBinaryTarget of resolvedBinaryTargets) {
          if (oldToNewBinaryTargetsMapping[resolvedBinaryTarget]) {
            throw new Error(`Binary target ${import_chalk.default.red.bold(resolvedBinaryTarget)} is deprecated. Please use ${import_chalk.default.green.bold(oldToNewBinaryTargetsMapping[resolvedBinaryTarget])} instead.`);
          }
          if (!knownBinaryTargets.includes(resolvedBinaryTarget)) {
            throw new Error(`Unknown binary target ${import_chalk.default.red(resolvedBinaryTarget)} in generator ${import_chalk.default.bold(generator.name)}.
Possible binaryTargets: ${import_chalk.default.greenBright(knownBinaryTargets.join(", "))}`);
          }
        }
        if (!resolvedBinaryTargets.includes(platform)) {
          const originalBinaryTargetsConfig = (0, import_engine_core.getOriginalBinaryTargetsValue)(generator.binaryTargets);
          if (generator) {
            console.log(`${import_chalk.default.yellow("Warning:")} Your current platform \`${import_chalk.default.bold(platform)}\` is not included in your generator's \`binaryTargets\` configuration ${JSON.stringify(originalBinaryTargetsConfig)}.
    To fix it, use this generator config in your ${import_chalk.default.bold("schema.prisma")}:
    ${import_chalk.default.greenBright((0, import_engine_core.printGeneratorConfig)({
              ...generator,
              binaryTargets: (0, import_engine_core.fixBinaryTargets)(generator.binaryTargets, platform)
            }))}
    ${import_chalk.default.gray(`Note, that by providing \`native\`, Prisma Client automatically resolves \`${platform}\`.
    Read more about deploying Prisma Client: ${import_chalk.default.underline("https://github.com/prisma/prisma/blob/main/docs/core/generators/prisma-client-js.md")}`)}
`);
          } else {
            console.log(`${import_chalk.default.yellow("Warning")} The binaryTargets ${JSON.stringify(originalBinaryTargetsConfig)} don't include your local platform ${platform}, which you can also point to with \`native\`.
    In case you want to fix this, you can provide ${import_chalk.default.greenBright(`binaryTargets: ${JSON.stringify(["native", ...binaryTargets || []])}`)} in the schema.prisma file.`);
          }
        }
      }
    }
  }
  function engineTypeToBinaryType(engineType) {
    if (engineType === "introspectionEngine") {
      return import_fetch_engine.BinaryType.introspectionEngine;
    }
    if (engineType === "migrationEngine") {
      return import_fetch_engine.BinaryType.migrationEngine;
    }
    if (engineType === "queryEngine") {
      return import_fetch_engine.BinaryType.queryEngine;
    }
    if (engineType === "libqueryEngine") {
      return import_fetch_engine.BinaryType.libqueryEngine;
    }
    if (engineType === "prismaFmt") {
      return import_fetch_engine.BinaryType.prismaFmt;
    }
    throw new Error(`Could not convert engine type ${engineType}`);
  }
  function binaryTypeToEngineType(binaryType) {
    if (binaryType === import_fetch_engine.BinaryType.introspectionEngine) {
      return "introspectionEngine";
    }
    if (binaryType === import_fetch_engine.BinaryType.migrationEngine) {
      return "migrationEngine";
    }
    if (binaryType === import_fetch_engine.BinaryType.libqueryEngine) {
      return "libqueryEngine";
    }
    if (binaryType === import_fetch_engine.BinaryType.queryEngine) {
      return "queryEngine";
    }
    if (binaryType === import_fetch_engine.BinaryType.prismaFmt) {
      return "prismaFmt";
    }
    throw new Error(`Could not convert binary type ${binaryType}`);
  }
  function mapKeys(obj, mapper) {
    return Object.entries(obj).reduce((acc, [key, value]) => {
      acc[mapper(key)] = value;
      return acc;
    }, {});
  }
  function getEngineVersionForGenerator(manifest, defaultVersion) {
    let neededVersion = manifest.requiresEngineVersion;
    if ((manifest == null ? void 0 : manifest.version) && import_getAllVersions.engineVersions[manifest == null ? void 0 : manifest.version]) {
      neededVersion = import_getAllVersions.engineVersions[manifest == null ? void 0 : manifest.version];
    }
    neededVersion = neededVersion != null ? neededVersion : defaultVersion;
    return neededVersion != null ? neededVersion : "latest";
  }
});

// ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/opts-arg.js
var require_opts_arg = __commonJS2((exports2, module2) => {
  var {promisify: promisify2} = require("util");
  var fs2 = require("fs");
  var optsArg = (opts) => {
    if (!opts)
      opts = {mode: 511, fs: fs2};
    else if (typeof opts === "object")
      opts = {mode: 511, fs: fs2, ...opts};
    else if (typeof opts === "number")
      opts = {mode: opts, fs: fs2};
    else if (typeof opts === "string")
      opts = {mode: parseInt(opts, 8), fs: fs2};
    else
      throw new TypeError("invalid options argument");
    opts.mkdir = opts.mkdir || opts.fs.mkdir || fs2.mkdir;
    opts.mkdirAsync = promisify2(opts.mkdir);
    opts.stat = opts.stat || opts.fs.stat || fs2.stat;
    opts.statAsync = promisify2(opts.stat);
    opts.statSync = opts.statSync || opts.fs.statSync || fs2.statSync;
    opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs2.mkdirSync;
    return opts;
  };
  module2.exports = optsArg;
});

// ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/path-arg.js
var require_path_arg = __commonJS2((exports2, module2) => {
  var platform = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform;
  var {resolve, parse: parse2} = require("path");
  var pathArg = (path4) => {
    if (/\0/.test(path4)) {
      throw Object.assign(new TypeError("path must be a string without null bytes"), {
        path: path4,
        code: "ERR_INVALID_ARG_VALUE"
      });
    }
    path4 = resolve(path4);
    if (platform === "win32") {
      const badWinChars = /[*|"<>?:]/;
      const {root} = parse2(path4);
      if (badWinChars.test(path4.substr(root.length))) {
        throw Object.assign(new Error("Illegal characters in path."), {
          path: path4,
          code: "EINVAL"
        });
      }
    }
    return path4;
  };
  module2.exports = pathArg;
});

// ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/find-made.js
var require_find_made = __commonJS2((exports2, module2) => {
  var {dirname: dirname2} = require("path");
  var findMade = (opts, parent, path4 = void 0) => {
    if (path4 === parent)
      return Promise.resolve();
    return opts.statAsync(parent).then((st) => st.isDirectory() ? path4 : void 0, (er) => er.code === "ENOENT" ? findMade(opts, dirname2(parent), parent) : void 0);
  };
  var findMadeSync = (opts, parent, path4 = void 0) => {
    if (path4 === parent)
      return void 0;
    try {
      return opts.statSync(parent).isDirectory() ? path4 : void 0;
    } catch (er) {
      return er.code === "ENOENT" ? findMadeSync(opts, dirname2(parent), parent) : void 0;
    }
  };
  module2.exports = {findMade, findMadeSync};
});

// ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/mkdirp-manual.js
var require_mkdirp_manual = __commonJS2((exports2, module2) => {
  var {dirname: dirname2} = require("path");
  var mkdirpManual = (path4, opts, made) => {
    opts.recursive = false;
    const parent = dirname2(path4);
    if (parent === path4) {
      return opts.mkdirAsync(path4, opts).catch((er) => {
        if (er.code !== "EISDIR")
          throw er;
      });
    }
    return opts.mkdirAsync(path4, opts).then(() => made || path4, (er) => {
      if (er.code === "ENOENT")
        return mkdirpManual(parent, opts).then((made2) => mkdirpManual(path4, opts, made2));
      if (er.code !== "EEXIST" && er.code !== "EROFS")
        throw er;
      return opts.statAsync(path4).then((st) => {
        if (st.isDirectory())
          return made;
        else
          throw er;
      }, () => {
        throw er;
      });
    });
  };
  var mkdirpManualSync = (path4, opts, made) => {
    const parent = dirname2(path4);
    opts.recursive = false;
    if (parent === path4) {
      try {
        return opts.mkdirSync(path4, opts);
      } catch (er) {
        if (er.code !== "EISDIR")
          throw er;
        else
          return;
      }
    }
    try {
      opts.mkdirSync(path4, opts);
      return made || path4;
    } catch (er) {
      if (er.code === "ENOENT")
        return mkdirpManualSync(path4, opts, mkdirpManualSync(parent, opts, made));
      if (er.code !== "EEXIST" && er.code !== "EROFS")
        throw er;
      try {
        if (!opts.statSync(path4).isDirectory())
          throw er;
      } catch (_2) {
        throw er;
      }
    }
  };
  module2.exports = {mkdirpManual, mkdirpManualSync};
});

// ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/mkdirp-native.js
var require_mkdirp_native = __commonJS2((exports2, module2) => {
  var {dirname: dirname2} = require("path");
  var {findMade, findMadeSync} = require_find_made();
  var {mkdirpManual, mkdirpManualSync} = require_mkdirp_manual();
  var mkdirpNative = (path4, opts) => {
    opts.recursive = true;
    const parent = dirname2(path4);
    if (parent === path4)
      return opts.mkdirAsync(path4, opts);
    return findMade(opts, path4).then((made) => opts.mkdirAsync(path4, opts).then(() => made).catch((er) => {
      if (er.code === "ENOENT")
        return mkdirpManual(path4, opts);
      else
        throw er;
    }));
  };
  var mkdirpNativeSync = (path4, opts) => {
    opts.recursive = true;
    const parent = dirname2(path4);
    if (parent === path4)
      return opts.mkdirSync(path4, opts);
    const made = findMadeSync(opts, path4);
    try {
      opts.mkdirSync(path4, opts);
      return made;
    } catch (er) {
      if (er.code === "ENOENT")
        return mkdirpManualSync(path4, opts);
      else
        throw er;
    }
  };
  module2.exports = {mkdirpNative, mkdirpNativeSync};
});

// ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/use-native.js
var require_use_native = __commonJS2((exports2, module2) => {
  var fs2 = require("fs");
  var version = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version;
  var versArr = version.replace(/^v/, "").split(".");
  var hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12;
  var useNative = !hasNative ? () => false : (opts) => opts.mkdir === fs2.mkdir;
  var useNativeSync = !hasNative ? () => false : (opts) => opts.mkdirSync === fs2.mkdirSync;
  module2.exports = {useNative, useNativeSync};
});

// ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/index.js
var require_mkdirp = __commonJS2((exports2, module2) => {
  var optsArg = require_opts_arg();
  var pathArg = require_path_arg();
  var {mkdirpNative, mkdirpNativeSync} = require_mkdirp_native();
  var {mkdirpManual, mkdirpManualSync} = require_mkdirp_manual();
  var {useNative, useNativeSync} = require_use_native();
  var mkdirp = (path4, opts) => {
    path4 = pathArg(path4);
    opts = optsArg(opts);
    return useNative(opts) ? mkdirpNative(path4, opts) : mkdirpManual(path4, opts);
  };
  var mkdirpSync = (path4, opts) => {
    path4 = pathArg(path4);
    opts = optsArg(opts);
    return useNativeSync(opts) ? mkdirpNativeSync(path4, opts) : mkdirpManualSync(path4, opts);
  };
  mkdirp.sync = mkdirpSync;
  mkdirp.native = (path4, opts) => mkdirpNative(pathArg(path4), optsArg(opts));
  mkdirp.manual = (path4, opts) => mkdirpManual(pathArg(path4), optsArg(opts));
  mkdirp.nativeSync = (path4, opts) => mkdirpNativeSync(pathArg(path4), optsArg(opts));
  mkdirp.manualSync = (path4, opts) => mkdirpManualSync(pathArg(path4), optsArg(opts));
  module2.exports = mkdirp;
});

// ../../node_modules/.pnpm/prettysize@2.0.0/node_modules/prettysize/index.js
var require_prettysize = __commonJS2((exports2, module2) => {
  "use strict";
  var sizes = [
    "Bytes",
    "kB",
    "MB",
    "GB",
    "TB",
    "PB",
    "EB"
  ];
  module2.exports = function(size, nospace, one, places, numOnly) {
    if (typeof nospace === "object") {
      var opts = nospace;
      nospace = opts.nospace;
      one = opts.one;
      places = opts.places || 1;
      numOnly = opts.numOnly;
    } else {
      places = places || 1;
    }
    var mysize;
    for (var id = 0; id < sizes.length; ++id) {
      var unit = sizes[id];
      if (one) {
        unit = unit.slice(0, 1);
      }
      var s2 = Math.pow(1024, id);
      var fixed;
      if (size >= s2) {
        fixed = String((size / s2).toFixed(places));
        if (fixed.indexOf(".0") === fixed.length - 2) {
          fixed = fixed.slice(0, -2);
        }
        mysize = fixed + (nospace ? "" : " ") + unit;
      }
    }
    if (!mysize) {
      var _unit = one ? sizes[0].slice(0, 1) : sizes[0];
      mysize = "0" + (nospace ? "" : " ") + _unit;
    }
    if (numOnly) {
      mysize = Number.parseFloat(mysize);
    }
    return mysize;
  };
});

// ../../node_modules/.pnpm/@timsuchanek+sleep-promise@8.0.1/node_modules/@timsuchanek/sleep-promise/build/cjs.js
var require_cjs = __commonJS2((exports2, module2) => {
  "use strict";
  var cachedSetTimeout = setTimeout;
  function createSleepPromise(a, b) {
    var c = b.useCachedSetTimeout, d2 = c ? cachedSetTimeout : setTimeout;
    return new Promise(function(b2) {
      d2(b2, a);
    });
  }
  function sleep(a) {
    function b(a2) {
      return e.then(function() {
        return a2;
      });
    }
    var c = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : {}, d2 = c.useCachedSetTimeout, e = createSleepPromise(a, {useCachedSetTimeout: d2});
    return b.then = function() {
      return e.then.apply(e, arguments);
    }, b.catch = Promise.resolve().catch, b;
  }
  module2.exports = sleep;
});

// ../../node_modules/.pnpm/@timsuchanek+copy@1.4.5/node_modules/@timsuchanek/copy/index.js
var require_copy = __commonJS2((exports2, module2) => {
  var fs2 = require("fs");
  var path4 = require("path");
  var {promisify: promisify2} = require("util");
  var readFile2 = promisify2(fs2.readFile);
  var writeFile2 = promisify2(fs2.writeFile);
  var mkdir2 = promisify2(fs2.mkdir);
  var mkdirp = require_mkdirp();
  var pretty = require_prettysize();
  var sleep = require_cjs();
  var assert = require("assert");
  var Copy = class {
    constructor(options = {}) {
      this.from = path4.normalize(options.from);
      this.to = path4.normalize(options.to);
      this.recursive = options.recursive || false;
      this.overwrite = options.overwrite || false;
      this.overwriteMismatches = options.overwriteMismatches || false;
      this.verbose = options.verbose || false;
      this.json = options.json || false;
      this.ignoreErrors = options.ignoreErrors || false;
      this.parallelJobs = options.parallelJobs || 1;
      this.stateFile = options.state;
      this.stateFrequency = options.stateFrequency || 100;
      this.fns = {
        stat: promisify2(options.stat || fs2.stat),
        readdir: promisify2(options.readdir || fs2.readdir),
        copyFile: promisify2(options.copyFile || fs2.copyFile)
      };
      this.stateCatchUp = 0;
      this.state = {
        wip: [],
        counts: {
          directories: 0,
          files: 0,
          copies: 0
        }
      };
      this.pending = [];
      this.errors = [];
      assert.equal(typeof this.from, "string", "from should be a string");
      assert.equal(typeof this.to, "string", "to should be a string");
      assert.equal(typeof this.parallelJobs, "number", "parallelJobs should be a number");
      assert.equal(typeof this.stateFrequency, "number", "stateFrequency should be a number");
      assert.equal(typeof this.fns.stat, "function", "stat should be a function");
      assert.equal(typeof this.fns.readdir, "function", "readdir should be a function");
      assert.equal(typeof this.fns.copyFile, "function", "copyFile should be a function");
    }
    async start() {
      try {
        await this.loadState();
        if ((await this.fns.stat(this.from)).isDirectory()) {
          await mkdirp(this.to);
        } else {
          const basedir = path4.dirname(this.to);
          await mkdirp(basedir);
        }
        await this.copy(this.from, this.to);
        while (this.pending.length > 0) {
          await sleep(10);
        }
        await this.processJobErrors();
        await this.saveState();
        if (this.state.wip.length) {
          throw new Error("Incomplete `wip` found. Copy likely incomplete.");
        }
        return this.state;
      } catch (err) {
        err.state = this.state;
        throw err;
      }
    }
    async loadState() {
      if (!this.stateFile)
        return;
      try {
        await this.fns.stat(this.stateFile);
        this.state = JSON.parse(await readFile2(this.stateFile));
        this.stateCatchUp = this.state.wip.length;
      } catch (err) {
        if (err.code !== "ENOENT") {
          throw err;
        }
      }
    }
    async saveState() {
      if (!this.stateFile)
        return;
      await writeFile2(this.stateFile, JSON.stringify(this.state, null, 2));
    }
    async processJobErrors() {
      let err = this.errors.shift();
      while (err) {
        this.handleError(err);
        err = this.errors.shift();
      }
    }
    async copy(from, to) {
      let catchingUp = this.stateCatchUp > 0;
      if (catchingUp) {
        if (this.state.wip.includes(from)) {
          this.stateCatchUp -= 1;
        } else if (!this.state.wip.some((wipFile) => wipFile.startsWith(from))) {
          return;
        }
      }
      try {
        await this.processJobErrors();
        const fromStat = await this.fns.stat(from);
        const isDirectory = fromStat.isDirectory();
        if (isDirectory && this.recursive) {
          await this.copyDirectory(from, to);
        } else if (!isDirectory) {
          if (!catchingUp) {
            this.state.wip.push(from);
          }
          await this.queueAction(() => this.copyFile(from, to, fromStat));
          if (this.state.counts.files % this.stateFrequency === 0) {
            await this.saveState();
          }
        }
      } catch (err) {
        this.handleError(err);
      }
    }
    async copyDirectory(from, to) {
      try {
        try {
          await this.fns.stat(to);
        } catch (err) {
          if (err.code === "ENOENT") {
            await mkdir2(to);
          } else {
            throw err;
          }
        }
        const files = await this.fns.readdir(from);
        for (let file of files) {
          await this.copy(path4.join(from, file), path4.join(to, file));
        }
      } catch (err) {
        this.handleError(err);
      } finally {
        this.state.counts.directories++;
      }
    }
    async queueAction(asyncFunction) {
      while (this.pending.length >= this.parallelJobs) {
        await sleep(10);
      }
      const action = async () => {
        try {
          await asyncFunction();
        } finally {
          this.pending.splice(this.pending.indexOf(asyncFunction), 1);
        }
      };
      this.pending.push(action);
      action().catch((err) => this.errors.push(err));
    }
    async copyFile(from, to, fromStat) {
      this.logCopyAction(to, "start");
      try {
        const toStat = await this.fns.stat(to);
        if (this.overwrite) {
          await this.doCopy(from, to, fromStat);
        } else if (this.overwriteMismatches) {
          if (fromStat.size !== toStat.size || fromStat.mtimeMs > toStat.mtimeMs) {
            this.logCopyAction(to, "stats mismatch", {
              fromStat: {
                size: fromStat.size,
                mtimeMs: fromStat.mtimeMs
              },
              toStat: {
                size: toStat.size,
                mtimeMs: toStat.mtimeMs
              }
            });
            await this.doCopy(from, to, fromStat);
          } else {
            this.logCopyAction(to, "skipped, stats match");
          }
        } else {
          this.logCopyAction(to, "skipped");
        }
        this.removeWip(from);
      } catch (err) {
        if (err.code === "ENOENT") {
          await this.doCopy(from, to, fromStat);
          this.removeWip(from);
        } else {
          throw err;
        }
      }
      this.state.counts.files++;
    }
    async doCopy(from, to, fromStat) {
      try {
        if (this.verbose || this.json) {
          const start = Date.now();
          await this.fns.copyFile(from, to);
          const speed = fromStat.size / ((Date.now() - start) / 1e3);
          this.logCopyAction(to, "complete", {speed});
        } else {
          await this.fns.copyFile(from, to);
        }
        this.state.counts.copies++;
      } catch (err) {
        this.logCopyAction(to, "error");
        this.handleError(err);
      }
    }
    removeWip(from) {
      let wipIndex = this.state.wip.indexOf(from);
      if (wipIndex >= 0) {
        this.state.wip.splice(wipIndex, 1);
      }
    }
    log(message) {
      if (this.verbose || this.json) {
        if (this.json === "pretty") {
          console.log(JSON.stringify({message, state: this.state}, null, 2) + "\n");
        } else if (this.json) {
          console.log(JSON.stringify({message, state: this.state}));
        } else {
          console.log(`Count: ${this.state.counts.directories}d ${this.state.counts.files}f Jobs: ${this.pending.length} ${message}`);
        }
      }
    }
    logCopyAction(file, action, extra) {
      if (this.json) {
        let message = {file, action};
        if (extra) {
          Object.assign(message, extra);
        }
        this.log(message);
      } else {
        let message = `Copying: '${file}' (${action})`;
        if (extra && extra.speed !== void 0) {
          message += ` (${pretty(extra.speed)}/s)`;
        }
        this.log(message);
      }
    }
    handleError(err) {
      if (this.ignoreErrors) {
        console.error(err);
      } else {
        throw err;
      }
    }
  };
  module2.exports = (options) => {
    const copy2 = new Copy(options);
    return copy2.start();
  };
  module2.exports.Copy = Copy;
});

// ../../node_modules/.pnpm/shell-quote@1.7.2/node_modules/shell-quote/index.js
var require_shell_quote = __commonJS2((exports2) => {
  exports2.quote = function(xs) {
    return xs.map(function(s2) {
      if (s2 && typeof s2 === "object") {
        return s2.op.replace(/(.)/g, "\\$1");
      } else if (/["\s]/.test(s2) && !/'/.test(s2)) {
        return "'" + s2.replace(/(['\\])/g, "\\$1") + "'";
      } else if (/["'\s]/.test(s2)) {
        return '"' + s2.replace(/(["\\$`!])/g, "\\$1") + '"';
      } else {
        return String(s2).replace(/([A-z]:)?([#!"$&'()*,:;<=>?@\[\\\]^`{|}])/g, "$1\\$2");
      }
    }).join(" ");
  };
  var CONTROL = "(?:" + [
    "\\|\\|",
    "\\&\\&",
    ";;",
    "\\|\\&",
    "\\<\\(",
    ">>",
    ">\\&",
    "[&;()|<>]"
  ].join("|") + ")";
  var META = "|&;()<> \\t";
  var BAREWORD = `(\\\\['"` + META + `]|[^\\s'"` + META + "])+";
  var SINGLE_QUOTE = '"((\\\\"|[^"])*?)"';
  var DOUBLE_QUOTE = "'((\\\\'|[^'])*?)'";
  var TOKEN = "";
  for (var i = 0; i < 4; i++) {
    TOKEN += (Math.pow(16, 8) * Math.random()).toString(16);
  }
  exports2.parse = function(s2, env2, opts) {
    var mapped = parse2(s2, env2, opts);
    if (typeof env2 !== "function")
      return mapped;
    return mapped.reduce(function(acc, s3) {
      if (typeof s3 === "object")
        return acc.concat(s3);
      var xs = s3.split(RegExp("(" + TOKEN + ".*?" + TOKEN + ")", "g"));
      if (xs.length === 1)
        return acc.concat(xs[0]);
      return acc.concat(xs.filter(Boolean).map(function(x) {
        if (RegExp("^" + TOKEN).test(x)) {
          return JSON.parse(x.split(TOKEN)[1]);
        } else
          return x;
      }));
    }, []);
  };
  function parse2(s2, env2, opts) {
    var chunker = new RegExp([
      "(" + CONTROL + ")",
      "(" + BAREWORD + "|" + SINGLE_QUOTE + "|" + DOUBLE_QUOTE + ")*"
    ].join("|"), "g");
    var match = s2.match(chunker).filter(Boolean);
    var commented = false;
    if (!match)
      return [];
    if (!env2)
      env2 = {};
    if (!opts)
      opts = {};
    return match.map(function(s3, j) {
      if (commented) {
        return;
      }
      if (RegExp("^" + CONTROL + "$").test(s3)) {
        return {op: s3};
      }
      var SQ = "'";
      var DQ = '"';
      var DS = "$";
      var BS = opts.escape || "\\";
      var quote = false;
      var esc = false;
      var out = "";
      var isGlob = false;
      for (var i2 = 0, len = s3.length; i2 < len; i2++) {
        var c = s3.charAt(i2);
        isGlob = isGlob || !quote && (c === "*" || c === "?");
        if (esc) {
          out += c;
          esc = false;
        } else if (quote) {
          if (c === quote) {
            quote = false;
          } else if (quote == SQ) {
            out += c;
          } else {
            if (c === BS) {
              i2 += 1;
              c = s3.charAt(i2);
              if (c === DQ || c === BS || c === DS) {
                out += c;
              } else {
                out += BS + c;
              }
            } else if (c === DS) {
              out += parseEnvVar();
            } else {
              out += c;
            }
          }
        } else if (c === DQ || c === SQ) {
          quote = c;
        } else if (RegExp("^" + CONTROL + "$").test(c)) {
          return {op: s3};
        } else if (RegExp("^#$").test(c)) {
          commented = true;
          if (out.length) {
            return [out, {comment: s3.slice(i2 + 1) + match.slice(j + 1).join(" ")}];
          }
          return [{comment: s3.slice(i2 + 1) + match.slice(j + 1).join(" ")}];
        } else if (c === BS) {
          esc = true;
        } else if (c === DS) {
          out += parseEnvVar();
        } else
          out += c;
      }
      if (isGlob)
        return {op: "glob", pattern: out};
      return out;
      function parseEnvVar() {
        i2 += 1;
        var varend, varname;
        if (s3.charAt(i2) === "{") {
          i2 += 1;
          if (s3.charAt(i2) === "}") {
            throw new Error("Bad substitution: " + s3.substr(i2 - 2, 3));
          }
          varend = s3.indexOf("}", i2);
          if (varend < 0) {
            throw new Error("Bad substitution: " + s3.substr(i2));
          }
          varname = s3.substr(i2, varend - i2);
          i2 = varend;
        } else if (/[*@#?$!_\-]/.test(s3.charAt(i2))) {
          varname = s3.charAt(i2);
          i2 += 1;
        } else {
          varend = s3.substr(i2).match(/[^\w\d_]/);
          if (!varend) {
            varname = s3.substr(i2);
            i2 = s3.length;
          } else {
            varname = s3.substr(i2, varend.index);
            i2 += varend.index - 1;
          }
        }
        return getVar(null, "", varname);
      }
    }).reduce(function(prev, arg2) {
      if (arg2 === void 0) {
        return prev;
      }
      return prev.concat(arg2);
    }, []);
    function getVar(_2, pre, key) {
      var r = typeof env2 === "function" ? env2(key) : env2[key];
      if (r === void 0 && key != "")
        r = "";
      else if (r === void 0)
        r = "$";
      if (typeof r === "object") {
        return pre + TOKEN + JSON.stringify(r) + TOKEN;
      } else
        return pre + r;
    }
  }
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/high-level-opt.js
var require_high_level_opt = __commonJS2((exports2, module2) => {
  "use strict";
  var argmap = new Map([
    ["C", "cwd"],
    ["f", "file"],
    ["z", "gzip"],
    ["P", "preservePaths"],
    ["U", "unlink"],
    ["strip-components", "strip"],
    ["stripComponents", "strip"],
    ["keep-newer", "newer"],
    ["keepNewer", "newer"],
    ["keep-newer-files", "newer"],
    ["keepNewerFiles", "newer"],
    ["k", "keep"],
    ["keep-existing", "keep"],
    ["keepExisting", "keep"],
    ["m", "noMtime"],
    ["no-mtime", "noMtime"],
    ["p", "preserveOwner"],
    ["L", "follow"],
    ["h", "follow"]
  ]);
  module2.exports = (opt) => opt ? Object.keys(opt).map((k) => [
    argmap.has(k) ? argmap.get(k) : k,
    opt[k]
  ]).reduce((set, kv) => (set[kv[0]] = kv[1], set), Object.create(null)) : {};
});

// ../../node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/iterator.js
var require_iterator2 = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = function(Yallist) {
    Yallist.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head; walker; walker = walker.next) {
        yield walker.value;
      }
    };
  };
});

// ../../node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/yallist.js
var require_yallist2 = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = Yallist;
  Yallist.Node = Node;
  Yallist.create = Yallist;
  function Yallist(list) {
    var self2 = this;
    if (!(self2 instanceof Yallist)) {
      self2 = new Yallist();
    }
    self2.tail = null;
    self2.head = null;
    self2.length = 0;
    if (list && typeof list.forEach === "function") {
      list.forEach(function(item) {
        self2.push(item);
      });
    } else if (arguments.length > 0) {
      for (var i = 0, l = arguments.length; i < l; i++) {
        self2.push(arguments[i]);
      }
    }
    return self2;
  }
  Yallist.prototype.removeNode = function(node) {
    if (node.list !== this) {
      throw new Error("removing node which does not belong to this list");
    }
    var next = node.next;
    var prev = node.prev;
    if (next) {
      next.prev = prev;
    }
    if (prev) {
      prev.next = next;
    }
    if (node === this.head) {
      this.head = next;
    }
    if (node === this.tail) {
      this.tail = prev;
    }
    node.list.length--;
    node.next = null;
    node.prev = null;
    node.list = null;
    return next;
  };
  Yallist.prototype.unshiftNode = function(node) {
    if (node === this.head) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var head = this.head;
    node.list = this;
    node.next = head;
    if (head) {
      head.prev = node;
    }
    this.head = node;
    if (!this.tail) {
      this.tail = node;
    }
    this.length++;
  };
  Yallist.prototype.pushNode = function(node) {
    if (node === this.tail) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var tail = this.tail;
    node.list = this;
    node.prev = tail;
    if (tail) {
      tail.next = node;
    }
    this.tail = node;
    if (!this.head) {
      this.head = node;
    }
    this.length++;
  };
  Yallist.prototype.push = function() {
    for (var i = 0, l = arguments.length; i < l; i++) {
      push(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.unshift = function() {
    for (var i = 0, l = arguments.length; i < l; i++) {
      unshift(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.pop = function() {
    if (!this.tail) {
      return void 0;
    }
    var res = this.tail.value;
    this.tail = this.tail.prev;
    if (this.tail) {
      this.tail.next = null;
    } else {
      this.head = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.shift = function() {
    if (!this.head) {
      return void 0;
    }
    var res = this.head.value;
    this.head = this.head.next;
    if (this.head) {
      this.head.prev = null;
    } else {
      this.tail = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.forEach = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.head, i = 0; walker !== null; i++) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.next;
    }
  };
  Yallist.prototype.forEachReverse = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.prev;
    }
  };
  Yallist.prototype.get = function(n) {
    for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
      walker = walker.next;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.getReverse = function(n) {
    for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
      walker = walker.prev;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.map = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for (var walker = this.head; walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.next;
    }
    return res;
  };
  Yallist.prototype.mapReverse = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for (var walker = this.tail; walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.prev;
    }
    return res;
  };
  Yallist.prototype.reduce = function(fn, initial) {
    var acc;
    var walker = this.head;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.head) {
      walker = this.head.next;
      acc = this.head.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = 0; walker !== null; i++) {
      acc = fn(acc, walker.value, i);
      walker = walker.next;
    }
    return acc;
  };
  Yallist.prototype.reduceReverse = function(fn, initial) {
    var acc;
    var walker = this.tail;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.tail) {
      walker = this.tail.prev;
      acc = this.tail.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = this.length - 1; walker !== null; i--) {
      acc = fn(acc, walker.value, i);
      walker = walker.prev;
    }
    return acc;
  };
  Yallist.prototype.toArray = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.head; walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.next;
    }
    return arr;
  };
  Yallist.prototype.toArrayReverse = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.tail; walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.prev;
    }
    return arr;
  };
  Yallist.prototype.slice = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist();
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
      walker = walker.next;
    }
    for (; walker !== null && i < to; i++, walker = walker.next) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.sliceReverse = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist();
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
      walker = walker.prev;
    }
    for (; walker !== null && i > from; i--, walker = walker.prev) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
    if (start > this.length) {
      start = this.length - 1;
    }
    if (start < 0) {
      start = this.length + start;
    }
    for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
      walker = walker.next;
    }
    var ret = [];
    for (var i = 0; walker && i < deleteCount; i++) {
      ret.push(walker.value);
      walker = this.removeNode(walker);
    }
    if (walker === null) {
      walker = this.tail;
    }
    if (walker !== this.head && walker !== this.tail) {
      walker = walker.prev;
    }
    for (var i = 0; i < nodes.length; i++) {
      walker = insert(this, walker, nodes[i]);
    }
    return ret;
  };
  Yallist.prototype.reverse = function() {
    var head = this.head;
    var tail = this.tail;
    for (var walker = head; walker !== null; walker = walker.prev) {
      var p = walker.prev;
      walker.prev = walker.next;
      walker.next = p;
    }
    this.head = tail;
    this.tail = head;
    return this;
  };
  function insert(self2, node, value) {
    var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
    if (inserted.next === null) {
      self2.tail = inserted;
    }
    if (inserted.prev === null) {
      self2.head = inserted;
    }
    self2.length++;
    return inserted;
  }
  function push(self2, item) {
    self2.tail = new Node(item, self2.tail, null, self2);
    if (!self2.head) {
      self2.head = self2.tail;
    }
    self2.length++;
  }
  function unshift(self2, item) {
    self2.head = new Node(item, null, self2.head, self2);
    if (!self2.tail) {
      self2.tail = self2.head;
    }
    self2.length++;
  }
  function Node(value, prev, next, list) {
    if (!(this instanceof Node)) {
      return new Node(value, prev, next, list);
    }
    this.list = list;
    this.value = value;
    if (prev) {
      prev.next = this;
      this.prev = prev;
    } else {
      this.prev = null;
    }
    if (next) {
      next.prev = this;
      this.next = next;
    } else {
      this.next = null;
    }
  }
  try {
    require_iterator2()(Yallist);
  } catch (er) {
  }
});

// ../../node_modules/.pnpm/minipass@3.1.3/node_modules/minipass/index.js
var require_minipass = __commonJS2((exports2, module2) => {
  "use strict";
  var EE = require("events");
  var Stream = require("stream");
  var Yallist = require_yallist2();
  var SD = require("string_decoder").StringDecoder;
  var EOF = Symbol("EOF");
  var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
  var EMITTED_END = Symbol("emittedEnd");
  var EMITTING_END = Symbol("emittingEnd");
  var CLOSED = Symbol("closed");
  var READ = Symbol("read");
  var FLUSH = Symbol("flush");
  var FLUSHCHUNK = Symbol("flushChunk");
  var ENCODING = Symbol("encoding");
  var DECODER = Symbol("decoder");
  var FLOWING = Symbol("flowing");
  var PAUSED = Symbol("paused");
  var RESUME = Symbol("resume");
  var BUFFERLENGTH = Symbol("bufferLength");
  var BUFFERPUSH = Symbol("bufferPush");
  var BUFFERSHIFT = Symbol("bufferShift");
  var OBJECTMODE = Symbol("objectMode");
  var DESTROYED = Symbol("destroyed");
  var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
  var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
  var ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
  var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
  var isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
  var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
  module2.exports = class Minipass extends Stream {
    constructor(options) {
      super();
      this[FLOWING] = false;
      this[PAUSED] = false;
      this.pipes = new Yallist();
      this.buffer = new Yallist();
      this[OBJECTMODE] = options && options.objectMode || false;
      if (this[OBJECTMODE])
        this[ENCODING] = null;
      else
        this[ENCODING] = options && options.encoding || null;
      if (this[ENCODING] === "buffer")
        this[ENCODING] = null;
      this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
      this[EOF] = false;
      this[EMITTED_END] = false;
      this[EMITTING_END] = false;
      this[CLOSED] = false;
      this.writable = true;
      this.readable = true;
      this[BUFFERLENGTH] = 0;
      this[DESTROYED] = false;
    }
    get bufferLength() {
      return this[BUFFERLENGTH];
    }
    get encoding() {
      return this[ENCODING];
    }
    set encoding(enc) {
      if (this[OBJECTMODE])
        throw new Error("cannot set encoding in objectMode");
      if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
        throw new Error("cannot change encoding");
      if (this[ENCODING] !== enc) {
        this[DECODER] = enc ? new SD(enc) : null;
        if (this.buffer.length)
          this.buffer = this.buffer.map((chunk) => this[DECODER].write(chunk));
      }
      this[ENCODING] = enc;
    }
    setEncoding(enc) {
      this.encoding = enc;
    }
    get objectMode() {
      return this[OBJECTMODE];
    }
    set objectMode(om) {
      this[OBJECTMODE] = this[OBJECTMODE] || !!om;
    }
    write(chunk, encoding, cb) {
      if (this[EOF])
        throw new Error("write after end");
      if (this[DESTROYED]) {
        this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), {code: "ERR_STREAM_DESTROYED"}));
        return true;
      }
      if (typeof encoding === "function")
        cb = encoding, encoding = "utf8";
      if (!encoding)
        encoding = "utf8";
      if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
        if (isArrayBufferView(chunk))
          chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
        else if (isArrayBuffer(chunk))
          chunk = Buffer.from(chunk);
        else if (typeof chunk !== "string")
          this.objectMode = true;
      }
      if (!this.objectMode && !chunk.length) {
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          cb();
        return this.flowing;
      }
      if (typeof chunk === "string" && !this[OBJECTMODE] && !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
        chunk = Buffer.from(chunk, encoding);
      }
      if (Buffer.isBuffer(chunk) && this[ENCODING])
        chunk = this[DECODER].write(chunk);
      if (this.flowing) {
        if (this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        this.emit("data", chunk);
      } else
        this[BUFFERPUSH](chunk);
      if (this[BUFFERLENGTH] !== 0)
        this.emit("readable");
      if (cb)
        cb();
      return this.flowing;
    }
    read(n) {
      if (this[DESTROYED])
        return null;
      try {
        if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH])
          return null;
        if (this[OBJECTMODE])
          n = null;
        if (this.buffer.length > 1 && !this[OBJECTMODE]) {
          if (this.encoding)
            this.buffer = new Yallist([
              Array.from(this.buffer).join("")
            ]);
          else
            this.buffer = new Yallist([
              Buffer.concat(Array.from(this.buffer), this[BUFFERLENGTH])
            ]);
        }
        return this[READ](n || null, this.buffer.head.value);
      } finally {
        this[MAYBE_EMIT_END]();
      }
    }
    [READ](n, chunk) {
      if (n === chunk.length || n === null)
        this[BUFFERSHIFT]();
      else {
        this.buffer.head.value = chunk.slice(n);
        chunk = chunk.slice(0, n);
        this[BUFFERLENGTH] -= n;
      }
      this.emit("data", chunk);
      if (!this.buffer.length && !this[EOF])
        this.emit("drain");
      return chunk;
    }
    end(chunk, encoding, cb) {
      if (typeof chunk === "function")
        cb = chunk, chunk = null;
      if (typeof encoding === "function")
        cb = encoding, encoding = "utf8";
      if (chunk)
        this.write(chunk, encoding);
      if (cb)
        this.once("end", cb);
      this[EOF] = true;
      this.writable = false;
      if (this.flowing || !this[PAUSED])
        this[MAYBE_EMIT_END]();
      return this;
    }
    [RESUME]() {
      if (this[DESTROYED])
        return;
      this[PAUSED] = false;
      this[FLOWING] = true;
      this.emit("resume");
      if (this.buffer.length)
        this[FLUSH]();
      else if (this[EOF])
        this[MAYBE_EMIT_END]();
      else
        this.emit("drain");
    }
    resume() {
      return this[RESUME]();
    }
    pause() {
      this[FLOWING] = false;
      this[PAUSED] = true;
    }
    get destroyed() {
      return this[DESTROYED];
    }
    get flowing() {
      return this[FLOWING];
    }
    get paused() {
      return this[PAUSED];
    }
    [BUFFERPUSH](chunk) {
      if (this[OBJECTMODE])
        this[BUFFERLENGTH] += 1;
      else
        this[BUFFERLENGTH] += chunk.length;
      return this.buffer.push(chunk);
    }
    [BUFFERSHIFT]() {
      if (this.buffer.length) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] -= 1;
        else
          this[BUFFERLENGTH] -= this.buffer.head.value.length;
      }
      return this.buffer.shift();
    }
    [FLUSH](noDrain) {
      do {
      } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));
      if (!noDrain && !this.buffer.length && !this[EOF])
        this.emit("drain");
    }
    [FLUSHCHUNK](chunk) {
      return chunk ? (this.emit("data", chunk), this.flowing) : false;
    }
    pipe(dest, opts) {
      if (this[DESTROYED])
        return;
      const ended = this[EMITTED_END];
      opts = opts || {};
      if (dest === process.stdout || dest === process.stderr)
        opts.end = false;
      else
        opts.end = opts.end !== false;
      const p = {dest, opts, ondrain: (_2) => this[RESUME]()};
      this.pipes.push(p);
      dest.on("drain", p.ondrain);
      this[RESUME]();
      if (ended && p.opts.end)
        p.dest.end();
      return dest;
    }
    addListener(ev, fn) {
      return this.on(ev, fn);
    }
    on(ev, fn) {
      try {
        return super.on(ev, fn);
      } finally {
        if (ev === "data" && !this.pipes.length && !this.flowing)
          this[RESUME]();
        else if (isEndish(ev) && this[EMITTED_END]) {
          super.emit(ev);
          this.removeAllListeners(ev);
        }
      }
    }
    get emittedEnd() {
      return this[EMITTED_END];
    }
    [MAYBE_EMIT_END]() {
      if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this.buffer.length === 0 && this[EOF]) {
        this[EMITTING_END] = true;
        this.emit("end");
        this.emit("prefinish");
        this.emit("finish");
        if (this[CLOSED])
          this.emit("close");
        this[EMITTING_END] = false;
      }
    }
    emit(ev, data) {
      if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
        return;
      else if (ev === "data") {
        if (!data)
          return;
        if (this.pipes.length)
          this.pipes.forEach((p) => p.dest.write(data) === false && this.pause());
      } else if (ev === "end") {
        if (this[EMITTED_END] === true)
          return;
        this[EMITTED_END] = true;
        this.readable = false;
        if (this[DECODER]) {
          data = this[DECODER].end();
          if (data) {
            this.pipes.forEach((p) => p.dest.write(data));
            super.emit("data", data);
          }
        }
        this.pipes.forEach((p) => {
          p.dest.removeListener("drain", p.ondrain);
          if (p.opts.end)
            p.dest.end();
        });
      } else if (ev === "close") {
        this[CLOSED] = true;
        if (!this[EMITTED_END] && !this[DESTROYED])
          return;
      }
      const args = new Array(arguments.length);
      args[0] = ev;
      args[1] = data;
      if (arguments.length > 2) {
        for (let i = 2; i < arguments.length; i++) {
          args[i] = arguments[i];
        }
      }
      try {
        return super.emit.apply(this, args);
      } finally {
        if (!isEndish(ev))
          this[MAYBE_EMIT_END]();
        else
          this.removeAllListeners(ev);
      }
    }
    collect() {
      const buf = [];
      if (!this[OBJECTMODE])
        buf.dataLength = 0;
      const p = this.promise();
      this.on("data", (c) => {
        buf.push(c);
        if (!this[OBJECTMODE])
          buf.dataLength += c.length;
      });
      return p.then(() => buf);
    }
    concat() {
      return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then((buf) => this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength));
    }
    promise() {
      return new Promise((resolve, reject) => {
        this.on(DESTROYED, () => reject(new Error("stream destroyed")));
        this.on("end", () => resolve());
        this.on("error", (er) => reject(er));
      });
    }
    [ASYNCITERATOR]() {
      const next = () => {
        const res = this.read();
        if (res !== null)
          return Promise.resolve({done: false, value: res});
        if (this[EOF])
          return Promise.resolve({done: true});
        let resolve = null;
        let reject = null;
        const onerr = (er) => {
          this.removeListener("data", ondata);
          this.removeListener("end", onend);
          reject(er);
        };
        const ondata = (value) => {
          this.removeListener("error", onerr);
          this.removeListener("end", onend);
          this.pause();
          resolve({value, done: !!this[EOF]});
        };
        const onend = () => {
          this.removeListener("error", onerr);
          this.removeListener("data", ondata);
          resolve({done: true});
        };
        const ondestroy = () => onerr(new Error("stream destroyed"));
        return new Promise((res2, rej) => {
          reject = rej;
          resolve = res2;
          this.once(DESTROYED, ondestroy);
          this.once("error", onerr);
          this.once("end", onend);
          this.once("data", ondata);
        });
      };
      return {next};
    }
    [ITERATOR]() {
      const next = () => {
        const value = this.read();
        const done = value === null;
        return {value, done};
      };
      return {next};
    }
    destroy(er) {
      if (this[DESTROYED]) {
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      this[DESTROYED] = true;
      this.buffer = new Yallist();
      this[BUFFERLENGTH] = 0;
      if (typeof this.close === "function" && !this[CLOSED])
        this.close();
      if (er)
        this.emit("error", er);
      else
        this.emit(DESTROYED);
      return this;
    }
    static isStream(s2) {
      return !!s2 && (s2 instanceof Minipass || s2 instanceof Stream || s2 instanceof EE && (typeof s2.pipe === "function" || typeof s2.write === "function" && typeof s2.end === "function"));
    }
  };
});

// ../../node_modules/.pnpm/minizlib@2.1.2/node_modules/minizlib/constants.js
var require_constants8 = __commonJS2((exports2, module2) => {
  var realZlibConstants = require("zlib").constants || {ZLIB_VERNUM: 4736};
  module2.exports = Object.freeze(Object.assign(Object.create(null), {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    Z_VERSION_ERROR: -6,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    DEFLATE: 1,
    INFLATE: 2,
    GZIP: 3,
    GUNZIP: 4,
    DEFLATERAW: 5,
    INFLATERAW: 6,
    UNZIP: 7,
    BROTLI_DECODE: 8,
    BROTLI_ENCODE: 9,
    Z_MIN_WINDOWBITS: 8,
    Z_MAX_WINDOWBITS: 15,
    Z_DEFAULT_WINDOWBITS: 15,
    Z_MIN_CHUNK: 64,
    Z_MAX_CHUNK: Infinity,
    Z_DEFAULT_CHUNK: 16384,
    Z_MIN_MEMLEVEL: 1,
    Z_MAX_MEMLEVEL: 9,
    Z_DEFAULT_MEMLEVEL: 8,
    Z_MIN_LEVEL: -1,
    Z_MAX_LEVEL: 9,
    Z_DEFAULT_LEVEL: -1,
    BROTLI_OPERATION_PROCESS: 0,
    BROTLI_OPERATION_FLUSH: 1,
    BROTLI_OPERATION_FINISH: 2,
    BROTLI_OPERATION_EMIT_METADATA: 3,
    BROTLI_MODE_GENERIC: 0,
    BROTLI_MODE_TEXT: 1,
    BROTLI_MODE_FONT: 2,
    BROTLI_DEFAULT_MODE: 0,
    BROTLI_MIN_QUALITY: 0,
    BROTLI_MAX_QUALITY: 11,
    BROTLI_DEFAULT_QUALITY: 11,
    BROTLI_MIN_WINDOW_BITS: 10,
    BROTLI_MAX_WINDOW_BITS: 24,
    BROTLI_LARGE_MAX_WINDOW_BITS: 30,
    BROTLI_DEFAULT_WINDOW: 22,
    BROTLI_MIN_INPUT_BLOCK_BITS: 16,
    BROTLI_MAX_INPUT_BLOCK_BITS: 24,
    BROTLI_PARAM_MODE: 0,
    BROTLI_PARAM_QUALITY: 1,
    BROTLI_PARAM_LGWIN: 2,
    BROTLI_PARAM_LGBLOCK: 3,
    BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
    BROTLI_PARAM_SIZE_HINT: 5,
    BROTLI_PARAM_LARGE_WINDOW: 6,
    BROTLI_PARAM_NPOSTFIX: 7,
    BROTLI_PARAM_NDIRECT: 8,
    BROTLI_DECODER_RESULT_ERROR: 0,
    BROTLI_DECODER_RESULT_SUCCESS: 1,
    BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
    BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
    BROTLI_DECODER_NO_ERROR: 0,
    BROTLI_DECODER_SUCCESS: 1,
    BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
    BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
    BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
    BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
    BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
    BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
    BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
    BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
    BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
    BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
    BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
    BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
    BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
    BROTLI_DECODER_ERROR_UNREACHABLE: -31
  }, realZlibConstants));
});

// ../../node_modules/.pnpm/minizlib@2.1.2/node_modules/minizlib/index.js
var require_minizlib = __commonJS2((exports2) => {
  "use strict";
  var assert = require("assert");
  var Buffer2 = require("buffer").Buffer;
  var realZlib = require("zlib");
  var constants = exports2.constants = require_constants8();
  var Minipass = require_minipass();
  var OriginalBufferConcat = Buffer2.concat;
  var _superWrite = Symbol("_superWrite");
  var ZlibError = class extends Error {
    constructor(err) {
      super("zlib: " + err.message);
      this.code = err.code;
      this.errno = err.errno;
      if (!this.code)
        this.code = "ZLIB_ERROR";
      this.message = "zlib: " + err.message;
      Error.captureStackTrace(this, this.constructor);
    }
    get name() {
      return "ZlibError";
    }
  };
  var _opts = Symbol("opts");
  var _flushFlag = Symbol("flushFlag");
  var _finishFlushFlag = Symbol("finishFlushFlag");
  var _fullFlushFlag = Symbol("fullFlushFlag");
  var _handle = Symbol("handle");
  var _onError = Symbol("onError");
  var _sawError = Symbol("sawError");
  var _level = Symbol("level");
  var _strategy = Symbol("strategy");
  var _ended = Symbol("ended");
  var _defaultFullFlush = Symbol("_defaultFullFlush");
  var ZlibBase = class extends Minipass {
    constructor(opts, mode) {
      if (!opts || typeof opts !== "object")
        throw new TypeError("invalid options for ZlibBase constructor");
      super(opts);
      this[_sawError] = false;
      this[_ended] = false;
      this[_opts] = opts;
      this[_flushFlag] = opts.flush;
      this[_finishFlushFlag] = opts.finishFlush;
      try {
        this[_handle] = new realZlib[mode](opts);
      } catch (er) {
        throw new ZlibError(er);
      }
      this[_onError] = (err) => {
        if (this[_sawError])
          return;
        this[_sawError] = true;
        this.close();
        this.emit("error", err);
      };
      this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));
      this.once("end", () => this.close);
    }
    close() {
      if (this[_handle]) {
        this[_handle].close();
        this[_handle] = null;
        this.emit("close");
      }
    }
    reset() {
      if (!this[_sawError]) {
        assert(this[_handle], "zlib binding closed");
        return this[_handle].reset();
      }
    }
    flush(flushFlag) {
      if (this.ended)
        return;
      if (typeof flushFlag !== "number")
        flushFlag = this[_fullFlushFlag];
      this.write(Object.assign(Buffer2.alloc(0), {[_flushFlag]: flushFlag}));
    }
    end(chunk, encoding, cb) {
      if (chunk)
        this.write(chunk, encoding);
      this.flush(this[_finishFlushFlag]);
      this[_ended] = true;
      return super.end(null, null, cb);
    }
    get ended() {
      return this[_ended];
    }
    write(chunk, encoding, cb) {
      if (typeof encoding === "function")
        cb = encoding, encoding = "utf8";
      if (typeof chunk === "string")
        chunk = Buffer2.from(chunk, encoding);
      if (this[_sawError])
        return;
      assert(this[_handle], "zlib binding closed");
      const nativeHandle = this[_handle]._handle;
      const originalNativeClose = nativeHandle.close;
      nativeHandle.close = () => {
      };
      const originalClose = this[_handle].close;
      this[_handle].close = () => {
      };
      Buffer2.concat = (args) => args;
      let result;
      try {
        const flushFlag = typeof chunk[_flushFlag] === "number" ? chunk[_flushFlag] : this[_flushFlag];
        result = this[_handle]._processChunk(chunk, flushFlag);
        Buffer2.concat = OriginalBufferConcat;
      } catch (err) {
        Buffer2.concat = OriginalBufferConcat;
        this[_onError](new ZlibError(err));
      } finally {
        if (this[_handle]) {
          this[_handle]._handle = nativeHandle;
          nativeHandle.close = originalNativeClose;
          this[_handle].close = originalClose;
          this[_handle].removeAllListeners("error");
        }
      }
      if (this[_handle])
        this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));
      let writeReturn;
      if (result) {
        if (Array.isArray(result) && result.length > 0) {
          writeReturn = this[_superWrite](Buffer2.from(result[0]));
          for (let i = 1; i < result.length; i++) {
            writeReturn = this[_superWrite](result[i]);
          }
        } else {
          writeReturn = this[_superWrite](Buffer2.from(result));
        }
      }
      if (cb)
        cb();
      return writeReturn;
    }
    [_superWrite](data) {
      return super.write(data);
    }
  };
  var Zlib = class extends ZlibBase {
    constructor(opts, mode) {
      opts = opts || {};
      opts.flush = opts.flush || constants.Z_NO_FLUSH;
      opts.finishFlush = opts.finishFlush || constants.Z_FINISH;
      super(opts, mode);
      this[_fullFlushFlag] = constants.Z_FULL_FLUSH;
      this[_level] = opts.level;
      this[_strategy] = opts.strategy;
    }
    params(level, strategy) {
      if (this[_sawError])
        return;
      if (!this[_handle])
        throw new Error("cannot switch params when binding is closed");
      if (!this[_handle].params)
        throw new Error("not supported in this implementation");
      if (this[_level] !== level || this[_strategy] !== strategy) {
        this.flush(constants.Z_SYNC_FLUSH);
        assert(this[_handle], "zlib binding closed");
        const origFlush = this[_handle].flush;
        this[_handle].flush = (flushFlag, cb) => {
          this.flush(flushFlag);
          cb();
        };
        try {
          this[_handle].params(level, strategy);
        } finally {
          this[_handle].flush = origFlush;
        }
        if (this[_handle]) {
          this[_level] = level;
          this[_strategy] = strategy;
        }
      }
    }
  };
  var Deflate = class extends Zlib {
    constructor(opts) {
      super(opts, "Deflate");
    }
  };
  var Inflate = class extends Zlib {
    constructor(opts) {
      super(opts, "Inflate");
    }
  };
  var _portable = Symbol("_portable");
  var Gzip = class extends Zlib {
    constructor(opts) {
      super(opts, "Gzip");
      this[_portable] = opts && !!opts.portable;
    }
    [_superWrite](data) {
      if (!this[_portable])
        return super[_superWrite](data);
      this[_portable] = false;
      data[9] = 255;
      return super[_superWrite](data);
    }
  };
  var Gunzip = class extends Zlib {
    constructor(opts) {
      super(opts, "Gunzip");
    }
  };
  var DeflateRaw = class extends Zlib {
    constructor(opts) {
      super(opts, "DeflateRaw");
    }
  };
  var InflateRaw = class extends Zlib {
    constructor(opts) {
      super(opts, "InflateRaw");
    }
  };
  var Unzip = class extends Zlib {
    constructor(opts) {
      super(opts, "Unzip");
    }
  };
  var Brotli = class extends ZlibBase {
    constructor(opts, mode) {
      opts = opts || {};
      opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS;
      opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH;
      super(opts, mode);
      this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH;
    }
  };
  var BrotliCompress = class extends Brotli {
    constructor(opts) {
      super(opts, "BrotliCompress");
    }
  };
  var BrotliDecompress = class extends Brotli {
    constructor(opts) {
      super(opts, "BrotliDecompress");
    }
  };
  exports2.Deflate = Deflate;
  exports2.Inflate = Inflate;
  exports2.Gzip = Gzip;
  exports2.Gunzip = Gunzip;
  exports2.DeflateRaw = DeflateRaw;
  exports2.InflateRaw = InflateRaw;
  exports2.Unzip = Unzip;
  if (typeof realZlib.BrotliCompress === "function") {
    exports2.BrotliCompress = BrotliCompress;
    exports2.BrotliDecompress = BrotliDecompress;
  } else {
    exports2.BrotliCompress = exports2.BrotliDecompress = class {
      constructor() {
        throw new Error("Brotli is not supported in this version of Node.js");
      }
    };
  }
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/normalize-windows-path.js
var require_normalize_windows_path = __commonJS2((exports2, module2) => {
  var platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
  module2.exports = platform !== "win32" ? (p) => p : (p) => p && p.replace(/\\/g, "/");
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/read-entry.js
var require_read_entry = __commonJS2((exports2, module2) => {
  "use strict";
  var MiniPass = require_minipass();
  var normPath = require_normalize_windows_path();
  var SLURP = Symbol("slurp");
  module2.exports = class ReadEntry extends MiniPass {
    constructor(header, ex, gex) {
      super();
      this.pause();
      this.extended = ex;
      this.globalExtended = gex;
      this.header = header;
      this.startBlockSize = 512 * Math.ceil(header.size / 512);
      this.blockRemain = this.startBlockSize;
      this.remain = header.size;
      this.type = header.type;
      this.meta = false;
      this.ignore = false;
      switch (this.type) {
        case "File":
        case "OldFile":
        case "Link":
        case "SymbolicLink":
        case "CharacterDevice":
        case "BlockDevice":
        case "Directory":
        case "FIFO":
        case "ContiguousFile":
        case "GNUDumpDir":
          break;
        case "NextFileHasLongLinkpath":
        case "NextFileHasLongPath":
        case "OldGnuLongPath":
        case "GlobalExtendedHeader":
        case "ExtendedHeader":
        case "OldExtendedHeader":
          this.meta = true;
          break;
        default:
          this.ignore = true;
      }
      this.path = normPath(header.path);
      this.mode = header.mode;
      if (this.mode)
        this.mode = this.mode & 4095;
      this.uid = header.uid;
      this.gid = header.gid;
      this.uname = header.uname;
      this.gname = header.gname;
      this.size = header.size;
      this.mtime = header.mtime;
      this.atime = header.atime;
      this.ctime = header.ctime;
      this.linkpath = normPath(header.linkpath);
      this.uname = header.uname;
      this.gname = header.gname;
      if (ex)
        this[SLURP](ex);
      if (gex)
        this[SLURP](gex, true);
    }
    write(data) {
      const writeLen = data.length;
      if (writeLen > this.blockRemain)
        throw new Error("writing more to entry than is appropriate");
      const r = this.remain;
      const br = this.blockRemain;
      this.remain = Math.max(0, r - writeLen);
      this.blockRemain = Math.max(0, br - writeLen);
      if (this.ignore)
        return true;
      if (r >= writeLen)
        return super.write(data);
      return super.write(data.slice(0, r));
    }
    [SLURP](ex, global2) {
      for (const k in ex) {
        if (ex[k] !== null && ex[k] !== void 0 && !(global2 && k === "path"))
          this[k] = k === "path" || k === "linkpath" ? normPath(ex[k]) : ex[k];
      }
    }
  };
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/types.js
var require_types3 = __commonJS2((exports2) => {
  "use strict";
  exports2.name = new Map([
    ["0", "File"],
    ["", "OldFile"],
    ["1", "Link"],
    ["2", "SymbolicLink"],
    ["3", "CharacterDevice"],
    ["4", "BlockDevice"],
    ["5", "Directory"],
    ["6", "FIFO"],
    ["7", "ContiguousFile"],
    ["g", "GlobalExtendedHeader"],
    ["x", "ExtendedHeader"],
    ["A", "SolarisACL"],
    ["D", "GNUDumpDir"],
    ["I", "Inode"],
    ["K", "NextFileHasLongLinkpath"],
    ["L", "NextFileHasLongPath"],
    ["M", "ContinuationFile"],
    ["N", "OldGnuLongPath"],
    ["S", "SparseFile"],
    ["V", "TapeVolumeHeader"],
    ["X", "OldExtendedHeader"]
  ]);
  exports2.code = new Map(Array.from(exports2.name).map((kv) => [kv[1], kv[0]]));
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/large-numbers.js
var require_large_numbers = __commonJS2((exports2, module2) => {
  "use strict";
  var encode = (num, buf) => {
    if (!Number.isSafeInteger(num))
      throw Error("cannot encode number outside of javascript safe integer range");
    else if (num < 0)
      encodeNegative(num, buf);
    else
      encodePositive(num, buf);
    return buf;
  };
  var encodePositive = (num, buf) => {
    buf[0] = 128;
    for (var i = buf.length; i > 1; i--) {
      buf[i - 1] = num & 255;
      num = Math.floor(num / 256);
    }
  };
  var encodeNegative = (num, buf) => {
    buf[0] = 255;
    var flipped = false;
    num = num * -1;
    for (var i = buf.length; i > 1; i--) {
      var byte = num & 255;
      num = Math.floor(num / 256);
      if (flipped)
        buf[i - 1] = onesComp(byte);
      else if (byte === 0)
        buf[i - 1] = 0;
      else {
        flipped = true;
        buf[i - 1] = twosComp(byte);
      }
    }
  };
  var parse2 = (buf) => {
    const pre = buf[0];
    const value = pre === 128 ? pos(buf.slice(1, buf.length)) : pre === 255 ? twos(buf) : null;
    if (value === null)
      throw Error("invalid base256 encoding");
    if (!Number.isSafeInteger(value))
      throw Error("parsed number outside of javascript safe integer range");
    return value;
  };
  var twos = (buf) => {
    var len = buf.length;
    var sum2 = 0;
    var flipped = false;
    for (var i = len - 1; i > -1; i--) {
      var byte = buf[i];
      var f;
      if (flipped)
        f = onesComp(byte);
      else if (byte === 0)
        f = byte;
      else {
        flipped = true;
        f = twosComp(byte);
      }
      if (f !== 0)
        sum2 -= f * Math.pow(256, len - i - 1);
    }
    return sum2;
  };
  var pos = (buf) => {
    var len = buf.length;
    var sum2 = 0;
    for (var i = len - 1; i > -1; i--) {
      var byte = buf[i];
      if (byte !== 0)
        sum2 += byte * Math.pow(256, len - i - 1);
    }
    return sum2;
  };
  var onesComp = (byte) => (255 ^ byte) & 255;
  var twosComp = (byte) => (255 ^ byte) + 1 & 255;
  module2.exports = {
    encode,
    parse: parse2
  };
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/header.js
var require_header = __commonJS2((exports2, module2) => {
  "use strict";
  var types = require_types3();
  var pathModule = require("path").posix;
  var large = require_large_numbers();
  var SLURP = Symbol("slurp");
  var TYPE = Symbol("type");
  var Header = class {
    constructor(data, off, ex, gex) {
      this.cksumValid = false;
      this.needPax = false;
      this.nullBlock = false;
      this.block = null;
      this.path = null;
      this.mode = null;
      this.uid = null;
      this.gid = null;
      this.size = null;
      this.mtime = null;
      this.cksum = null;
      this[TYPE] = "0";
      this.linkpath = null;
      this.uname = null;
      this.gname = null;
      this.devmaj = 0;
      this.devmin = 0;
      this.atime = null;
      this.ctime = null;
      if (Buffer.isBuffer(data))
        this.decode(data, off || 0, ex, gex);
      else if (data)
        this.set(data);
    }
    decode(buf, off, ex, gex) {
      if (!off)
        off = 0;
      if (!buf || !(buf.length >= off + 512))
        throw new Error("need 512 bytes for header");
      this.path = decString(buf, off, 100);
      this.mode = decNumber(buf, off + 100, 8);
      this.uid = decNumber(buf, off + 108, 8);
      this.gid = decNumber(buf, off + 116, 8);
      this.size = decNumber(buf, off + 124, 12);
      this.mtime = decDate(buf, off + 136, 12);
      this.cksum = decNumber(buf, off + 148, 12);
      this[SLURP](ex);
      this[SLURP](gex, true);
      this[TYPE] = decString(buf, off + 156, 1);
      if (this[TYPE] === "")
        this[TYPE] = "0";
      if (this[TYPE] === "0" && this.path.substr(-1) === "/")
        this[TYPE] = "5";
      if (this[TYPE] === "5")
        this.size = 0;
      this.linkpath = decString(buf, off + 157, 100);
      if (buf.slice(off + 257, off + 265).toString() === "ustar\x0000") {
        this.uname = decString(buf, off + 265, 32);
        this.gname = decString(buf, off + 297, 32);
        this.devmaj = decNumber(buf, off + 329, 8);
        this.devmin = decNumber(buf, off + 337, 8);
        if (buf[off + 475] !== 0) {
          const prefix = decString(buf, off + 345, 155);
          this.path = prefix + "/" + this.path;
        } else {
          const prefix = decString(buf, off + 345, 130);
          if (prefix)
            this.path = prefix + "/" + this.path;
          this.atime = decDate(buf, off + 476, 12);
          this.ctime = decDate(buf, off + 488, 12);
        }
      }
      let sum2 = 8 * 32;
      for (let i = off; i < off + 148; i++)
        sum2 += buf[i];
      for (let i = off + 156; i < off + 512; i++)
        sum2 += buf[i];
      this.cksumValid = sum2 === this.cksum;
      if (this.cksum === null && sum2 === 8 * 32)
        this.nullBlock = true;
    }
    [SLURP](ex, global2) {
      for (const k in ex) {
        if (ex[k] !== null && ex[k] !== void 0 && !(global2 && k === "path"))
          this[k] = ex[k];
      }
    }
    encode(buf, off) {
      if (!buf) {
        buf = this.block = Buffer.alloc(512);
        off = 0;
      }
      if (!off)
        off = 0;
      if (!(buf.length >= off + 512))
        throw new Error("need 512 bytes for header");
      const prefixSize = this.ctime || this.atime ? 130 : 155;
      const split = splitPrefix(this.path || "", prefixSize);
      const path4 = split[0];
      const prefix = split[1];
      this.needPax = split[2];
      this.needPax = encString(buf, off, 100, path4) || this.needPax;
      this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax;
      this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax;
      this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax;
      this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax;
      this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax;
      buf[off + 156] = this[TYPE].charCodeAt(0);
      this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax;
      buf.write("ustar\x0000", off + 257, 8);
      this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax;
      this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax;
      this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax;
      this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax;
      this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax;
      if (buf[off + 475] !== 0)
        this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax;
      else {
        this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax;
        this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax;
        this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax;
      }
      let sum2 = 8 * 32;
      for (let i = off; i < off + 148; i++)
        sum2 += buf[i];
      for (let i = off + 156; i < off + 512; i++)
        sum2 += buf[i];
      this.cksum = sum2;
      encNumber(buf, off + 148, 8, this.cksum);
      this.cksumValid = true;
      return this.needPax;
    }
    set(data) {
      for (const i in data) {
        if (data[i] !== null && data[i] !== void 0)
          this[i] = data[i];
      }
    }
    get type() {
      return types.name.get(this[TYPE]) || this[TYPE];
    }
    get typeKey() {
      return this[TYPE];
    }
    set type(type) {
      if (types.code.has(type))
        this[TYPE] = types.code.get(type);
      else
        this[TYPE] = type;
    }
  };
  var splitPrefix = (p, prefixSize) => {
    const pathSize = 100;
    let pp = p;
    let prefix = "";
    let ret;
    const root = pathModule.parse(p).root || ".";
    if (Buffer.byteLength(pp) < pathSize)
      ret = [pp, prefix, false];
    else {
      prefix = pathModule.dirname(pp);
      pp = pathModule.basename(pp);
      do {
        if (Buffer.byteLength(pp) <= pathSize && Buffer.byteLength(prefix) <= prefixSize)
          ret = [pp, prefix, false];
        else if (Buffer.byteLength(pp) > pathSize && Buffer.byteLength(prefix) <= prefixSize)
          ret = [pp.substr(0, pathSize - 1), prefix, true];
        else {
          pp = pathModule.join(pathModule.basename(prefix), pp);
          prefix = pathModule.dirname(prefix);
        }
      } while (prefix !== root && !ret);
      if (!ret)
        ret = [p.substr(0, pathSize - 1), "", true];
    }
    return ret;
  };
  var decString = (buf, off, size) => buf.slice(off, off + size).toString("utf8").replace(/\0.*/, "");
  var decDate = (buf, off, size) => numToDate(decNumber(buf, off, size));
  var numToDate = (num) => num === null ? null : new Date(num * 1e3);
  var decNumber = (buf, off, size) => buf[off] & 128 ? large.parse(buf.slice(off, off + size)) : decSmallNumber(buf, off, size);
  var nanNull = (value) => isNaN(value) ? null : value;
  var decSmallNumber = (buf, off, size) => nanNull(parseInt(buf.slice(off, off + size).toString("utf8").replace(/\0.*$/, "").trim(), 8));
  var MAXNUM = {
    12: 8589934591,
    8: 2097151
  };
  var encNumber = (buf, off, size, number) => number === null ? false : number > MAXNUM[size] || number < 0 ? (large.encode(number, buf.slice(off, off + size)), true) : (encSmallNumber(buf, off, size, number), false);
  var encSmallNumber = (buf, off, size, number) => buf.write(octalString(number, size), off, size, "ascii");
  var octalString = (number, size) => padOctal(Math.floor(number).toString(8), size);
  var padOctal = (string, size) => (string.length === size - 1 ? string : new Array(size - string.length - 1).join("0") + string + " ") + "\0";
  var encDate = (buf, off, size, date) => date === null ? false : encNumber(buf, off, size, date.getTime() / 1e3);
  var NULLS = new Array(156).join("\0");
  var encString = (buf, off, size, string) => string === null ? false : (buf.write(string + NULLS, off, size, "utf8"), string.length !== Buffer.byteLength(string) || string.length > size);
  module2.exports = Header;
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/pax.js
var require_pax = __commonJS2((exports2, module2) => {
  "use strict";
  var Header = require_header();
  var path4 = require("path");
  var Pax = class {
    constructor(obj, global2) {
      this.atime = obj.atime || null;
      this.charset = obj.charset || null;
      this.comment = obj.comment || null;
      this.ctime = obj.ctime || null;
      this.gid = obj.gid || null;
      this.gname = obj.gname || null;
      this.linkpath = obj.linkpath || null;
      this.mtime = obj.mtime || null;
      this.path = obj.path || null;
      this.size = obj.size || null;
      this.uid = obj.uid || null;
      this.uname = obj.uname || null;
      this.dev = obj.dev || null;
      this.ino = obj.ino || null;
      this.nlink = obj.nlink || null;
      this.global = global2 || false;
    }
    encode() {
      const body = this.encodeBody();
      if (body === "")
        return null;
      const bodyLen = Buffer.byteLength(body);
      const bufLen = 512 * Math.ceil(1 + bodyLen / 512);
      const buf = Buffer.allocUnsafe(bufLen);
      for (let i = 0; i < 512; i++)
        buf[i] = 0;
      new Header({
        path: ("PaxHeader/" + path4.basename(this.path)).slice(0, 99),
        mode: this.mode || 420,
        uid: this.uid || null,
        gid: this.gid || null,
        size: bodyLen,
        mtime: this.mtime || null,
        type: this.global ? "GlobalExtendedHeader" : "ExtendedHeader",
        linkpath: "",
        uname: this.uname || "",
        gname: this.gname || "",
        devmaj: 0,
        devmin: 0,
        atime: this.atime || null,
        ctime: this.ctime || null
      }).encode(buf);
      buf.write(body, 512, bodyLen, "utf8");
      for (let i = bodyLen + 512; i < buf.length; i++)
        buf[i] = 0;
      return buf;
    }
    encodeBody() {
      return this.encodeField("path") + this.encodeField("ctime") + this.encodeField("atime") + this.encodeField("dev") + this.encodeField("ino") + this.encodeField("nlink") + this.encodeField("charset") + this.encodeField("comment") + this.encodeField("gid") + this.encodeField("gname") + this.encodeField("linkpath") + this.encodeField("mtime") + this.encodeField("size") + this.encodeField("uid") + this.encodeField("uname");
    }
    encodeField(field) {
      if (this[field] === null || this[field] === void 0)
        return "";
      const v = this[field] instanceof Date ? this[field].getTime() / 1e3 : this[field];
      const s2 = " " + (field === "dev" || field === "ino" || field === "nlink" ? "SCHILY." : "") + field + "=" + v + "\n";
      const byteLen = Buffer.byteLength(s2);
      let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1;
      if (byteLen + digits >= Math.pow(10, digits))
        digits += 1;
      const len = digits + byteLen;
      return len + s2;
    }
  };
  Pax.parse = (string, ex, g) => new Pax(merge(parseKV(string), ex), g);
  var merge = (a, b) => b ? Object.keys(a).reduce((s2, k) => (s2[k] = a[k], s2), b) : a;
  var parseKV = (string) => string.replace(/\n$/, "").split("\n").reduce(parseKVLine, Object.create(null));
  var parseKVLine = (set, line) => {
    const n = parseInt(line, 10);
    if (n !== Buffer.byteLength(line) + 1)
      return set;
    line = line.substr((n + " ").length);
    const kv = line.split("=");
    const k = kv.shift().replace(/^SCHILY\.(dev|ino|nlink)/, "$1");
    if (!k)
      return set;
    const v = kv.join("=");
    set[k] = /^([A-Z]+\.)?([mac]|birth|creation)time$/.test(k) ? new Date(v * 1e3) : /^[0-9]+$/.test(v) ? +v : v;
    return set;
  };
  module2.exports = Pax;
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/strip-trailing-slashes.js
var require_strip_trailing_slashes = __commonJS2((exports2, module2) => {
  var batchStrings = [
    "/".repeat(1024),
    "/".repeat(512),
    "/".repeat(256),
    "/".repeat(128),
    "/".repeat(64),
    "/".repeat(32),
    "/".repeat(16),
    "/".repeat(8),
    "/".repeat(4),
    "/".repeat(2),
    "/"
  ];
  module2.exports = (str) => {
    for (const s2 of batchStrings) {
      while (str.length >= s2.length && str.slice(-1 * s2.length) === s2)
        str = str.slice(0, -1 * s2.length);
    }
    return str;
  };
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/warn-mixin.js
var require_warn_mixin = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = (Base) => class extends Base {
    warn(code, message, data = {}) {
      if (this.file)
        data.file = this.file;
      if (this.cwd)
        data.cwd = this.cwd;
      data.code = message instanceof Error && message.code || code;
      data.tarCode = code;
      if (!this.strict && data.recoverable !== false) {
        if (message instanceof Error) {
          data = Object.assign(message, data);
          message = message.message;
        }
        this.emit("warn", data.tarCode, message, data);
      } else if (message instanceof Error)
        this.emit("error", Object.assign(message, data));
      else
        this.emit("error", Object.assign(new Error(`${code}: ${message}`), data));
    }
  };
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/winchars.js
var require_winchars = __commonJS2((exports2, module2) => {
  "use strict";
  var raw = [
    "|",
    "<",
    ">",
    "?",
    ":"
  ];
  var win = raw.map((char) => String.fromCharCode(61440 + char.charCodeAt(0)));
  var toWin = new Map(raw.map((char, i) => [char, win[i]]));
  var toRaw = new Map(win.map((char, i) => [char, raw[i]]));
  module2.exports = {
    encode: (s2) => raw.reduce((s3, c) => s3.split(c).join(toWin.get(c)), s2),
    decode: (s2) => win.reduce((s3, c) => s3.split(c).join(toRaw.get(c)), s2)
  };
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/strip-absolute-path.js
var require_strip_absolute_path = __commonJS2((exports2, module2) => {
  var {isAbsolute, parse: parse2} = require("path").win32;
  module2.exports = (path4) => {
    let r = "";
    while (isAbsolute(path4)) {
      const root = path4.charAt(0) === "/" ? "/" : parse2(path4).root;
      path4 = path4.substr(root.length);
      r += root;
    }
    return [r, path4];
  };
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/mode-fix.js
var require_mode_fix = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = (mode, isDir, portable) => {
    mode &= 4095;
    if (portable)
      mode = (mode | 384) & ~18;
    if (isDir) {
      if (mode & 256)
        mode |= 64;
      if (mode & 32)
        mode |= 8;
      if (mode & 4)
        mode |= 1;
    }
    return mode;
  };
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/write-entry.js
var require_write_entry = __commonJS2((exports2, module2) => {
  "use strict";
  var MiniPass = require_minipass();
  var Pax = require_pax();
  var Header = require_header();
  var fs2 = require("fs");
  var path4 = require("path");
  var normPath = require_normalize_windows_path();
  var stripSlash = require_strip_trailing_slashes();
  var prefixPath = (path5, prefix) => {
    if (!prefix)
      return normPath(path5);
    path5 = normPath(path5).replace(/^\.(\/|$)/, "");
    return stripSlash(prefix) + "/" + path5;
  };
  var maxReadSize = 16 * 1024 * 1024;
  var PROCESS = Symbol("process");
  var FILE = Symbol("file");
  var DIRECTORY = Symbol("directory");
  var SYMLINK = Symbol("symlink");
  var HARDLINK = Symbol("hardlink");
  var HEADER = Symbol("header");
  var READ = Symbol("read");
  var LSTAT = Symbol("lstat");
  var ONLSTAT = Symbol("onlstat");
  var ONREAD = Symbol("onread");
  var ONREADLINK = Symbol("onreadlink");
  var OPENFILE = Symbol("openfile");
  var ONOPENFILE = Symbol("onopenfile");
  var CLOSE = Symbol("close");
  var MODE = Symbol("mode");
  var AWAITDRAIN = Symbol("awaitDrain");
  var ONDRAIN = Symbol("ondrain");
  var PREFIX = Symbol("prefix");
  var HAD_ERROR = Symbol("hadError");
  var warner = require_warn_mixin();
  var winchars = require_winchars();
  var stripAbsolutePath = require_strip_absolute_path();
  var modeFix = require_mode_fix();
  var WriteEntry = warner(class WriteEntry extends MiniPass {
    constructor(p, opt) {
      opt = opt || {};
      super(opt);
      if (typeof p !== "string")
        throw new TypeError("path is required");
      this.path = normPath(p);
      this.portable = !!opt.portable;
      this.myuid = process.getuid && process.getuid() || 0;
      this.myuser = process.env.USER || "";
      this.maxReadSize = opt.maxReadSize || maxReadSize;
      this.linkCache = opt.linkCache || new Map();
      this.statCache = opt.statCache || new Map();
      this.preservePaths = !!opt.preservePaths;
      this.cwd = normPath(opt.cwd || process.cwd());
      this.strict = !!opt.strict;
      this.noPax = !!opt.noPax;
      this.noMtime = !!opt.noMtime;
      this.mtime = opt.mtime || null;
      this.prefix = opt.prefix ? normPath(opt.prefix) : null;
      this.fd = null;
      this.blockLen = null;
      this.blockRemain = null;
      this.buf = null;
      this.offset = null;
      this.length = null;
      this.pos = null;
      this.remain = null;
      if (typeof opt.onwarn === "function")
        this.on("warn", opt.onwarn);
      let pathWarn = false;
      if (!this.preservePaths) {
        const [root, stripped] = stripAbsolutePath(this.path);
        if (root) {
          this.path = stripped;
          pathWarn = root;
        }
      }
      this.win32 = !!opt.win32 || process.platform === "win32";
      if (this.win32) {
        this.path = winchars.decode(this.path.replace(/\\/g, "/"));
        p = p.replace(/\\/g, "/");
      }
      this.absolute = normPath(opt.absolute || path4.resolve(this.cwd, p));
      if (this.path === "")
        this.path = "./";
      if (pathWarn) {
        this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
          entry: this,
          path: pathWarn + this.path
        });
      }
      if (this.statCache.has(this.absolute))
        this[ONLSTAT](this.statCache.get(this.absolute));
      else
        this[LSTAT]();
    }
    emit(ev, ...data) {
      if (ev === "error")
        this[HAD_ERROR] = true;
      return super.emit(ev, ...data);
    }
    [LSTAT]() {
      fs2.lstat(this.absolute, (er, stat2) => {
        if (er)
          return this.emit("error", er);
        this[ONLSTAT](stat2);
      });
    }
    [ONLSTAT](stat2) {
      this.statCache.set(this.absolute, stat2);
      this.stat = stat2;
      if (!stat2.isFile())
        stat2.size = 0;
      this.type = getType2(stat2);
      this.emit("stat", stat2);
      this[PROCESS]();
    }
    [PROCESS]() {
      switch (this.type) {
        case "File":
          return this[FILE]();
        case "Directory":
          return this[DIRECTORY]();
        case "SymbolicLink":
          return this[SYMLINK]();
        default:
          return this.end();
      }
    }
    [MODE](mode) {
      return modeFix(mode, this.type === "Directory", this.portable);
    }
    [PREFIX](path5) {
      return prefixPath(path5, this.prefix);
    }
    [HEADER]() {
      if (this.type === "Directory" && this.portable)
        this.noMtime = true;
      this.header = new Header({
        path: this[PREFIX](this.path),
        linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
        mode: this[MODE](this.stat.mode),
        uid: this.portable ? null : this.stat.uid,
        gid: this.portable ? null : this.stat.gid,
        size: this.stat.size,
        mtime: this.noMtime ? null : this.mtime || this.stat.mtime,
        type: this.type,
        uname: this.portable ? null : this.stat.uid === this.myuid ? this.myuser : "",
        atime: this.portable ? null : this.stat.atime,
        ctime: this.portable ? null : this.stat.ctime
      });
      if (this.header.encode() && !this.noPax) {
        super.write(new Pax({
          atime: this.portable ? null : this.header.atime,
          ctime: this.portable ? null : this.header.ctime,
          gid: this.portable ? null : this.header.gid,
          mtime: this.noMtime ? null : this.mtime || this.header.mtime,
          path: this[PREFIX](this.path),
          linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
          size: this.header.size,
          uid: this.portable ? null : this.header.uid,
          uname: this.portable ? null : this.header.uname,
          dev: this.portable ? null : this.stat.dev,
          ino: this.portable ? null : this.stat.ino,
          nlink: this.portable ? null : this.stat.nlink
        }).encode());
      }
      super.write(this.header.block);
    }
    [DIRECTORY]() {
      if (this.path.substr(-1) !== "/")
        this.path += "/";
      this.stat.size = 0;
      this[HEADER]();
      this.end();
    }
    [SYMLINK]() {
      fs2.readlink(this.absolute, (er, linkpath) => {
        if (er)
          return this.emit("error", er);
        this[ONREADLINK](linkpath);
      });
    }
    [ONREADLINK](linkpath) {
      this.linkpath = normPath(linkpath);
      this[HEADER]();
      this.end();
    }
    [HARDLINK](linkpath) {
      this.type = "Link";
      this.linkpath = normPath(path4.relative(this.cwd, linkpath));
      this.stat.size = 0;
      this[HEADER]();
      this.end();
    }
    [FILE]() {
      if (this.stat.nlink > 1) {
        const linkKey = this.stat.dev + ":" + this.stat.ino;
        if (this.linkCache.has(linkKey)) {
          const linkpath = this.linkCache.get(linkKey);
          if (linkpath.indexOf(this.cwd) === 0)
            return this[HARDLINK](linkpath);
        }
        this.linkCache.set(linkKey, this.absolute);
      }
      this[HEADER]();
      if (this.stat.size === 0)
        return this.end();
      this[OPENFILE]();
    }
    [OPENFILE]() {
      fs2.open(this.absolute, "r", (er, fd) => {
        if (er)
          return this.emit("error", er);
        this[ONOPENFILE](fd);
      });
    }
    [ONOPENFILE](fd) {
      this.fd = fd;
      if (this[HAD_ERROR])
        return this[CLOSE]();
      this.blockLen = 512 * Math.ceil(this.stat.size / 512);
      this.blockRemain = this.blockLen;
      const bufLen = Math.min(this.blockLen, this.maxReadSize);
      this.buf = Buffer.allocUnsafe(bufLen);
      this.offset = 0;
      this.pos = 0;
      this.remain = this.stat.size;
      this.length = this.buf.length;
      this[READ]();
    }
    [READ]() {
      const {fd, buf, offset, length, pos} = this;
      fs2.read(fd, buf, offset, length, pos, (er, bytesRead) => {
        if (er) {
          return this[CLOSE](() => this.emit("error", er));
        }
        this[ONREAD](bytesRead);
      });
    }
    [CLOSE](cb) {
      fs2.close(this.fd, cb);
    }
    [ONREAD](bytesRead) {
      if (bytesRead <= 0 && this.remain > 0) {
        const er = new Error("encountered unexpected EOF");
        er.path = this.absolute;
        er.syscall = "read";
        er.code = "EOF";
        return this[CLOSE](() => this.emit("error", er));
      }
      if (bytesRead > this.remain) {
        const er = new Error("did not encounter expected EOF");
        er.path = this.absolute;
        er.syscall = "read";
        er.code = "EOF";
        return this[CLOSE](() => this.emit("error", er));
      }
      if (bytesRead === this.remain) {
        for (let i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++) {
          this.buf[i + this.offset] = 0;
          bytesRead++;
          this.remain++;
        }
      }
      const writeBuf = this.offset === 0 && bytesRead === this.buf.length ? this.buf : this.buf.slice(this.offset, this.offset + bytesRead);
      const flushed = this.write(writeBuf);
      if (!flushed)
        this[AWAITDRAIN](() => this[ONDRAIN]());
      else
        this[ONDRAIN]();
    }
    [AWAITDRAIN](cb) {
      this.once("drain", cb);
    }
    write(writeBuf) {
      if (this.blockRemain < writeBuf.length) {
        const er = new Error("writing more data than expected");
        er.path = this.absolute;
        return this.emit("error", er);
      }
      this.remain -= writeBuf.length;
      this.blockRemain -= writeBuf.length;
      this.pos += writeBuf.length;
      this.offset += writeBuf.length;
      return super.write(writeBuf);
    }
    [ONDRAIN]() {
      if (!this.remain) {
        if (this.blockRemain)
          super.write(Buffer.alloc(this.blockRemain));
        return this[CLOSE]((er) => er ? this.emit("error", er) : this.end());
      }
      if (this.offset >= this.length) {
        this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length));
        this.offset = 0;
      }
      this.length = this.buf.length - this.offset;
      this[READ]();
    }
  });
  var WriteEntrySync = class extends WriteEntry {
    [LSTAT]() {
      this[ONLSTAT](fs2.lstatSync(this.absolute));
    }
    [SYMLINK]() {
      this[ONREADLINK](fs2.readlinkSync(this.absolute));
    }
    [OPENFILE]() {
      this[ONOPENFILE](fs2.openSync(this.absolute, "r"));
    }
    [READ]() {
      let threw = true;
      try {
        const {fd, buf, offset, length, pos} = this;
        const bytesRead = fs2.readSync(fd, buf, offset, length, pos);
        this[ONREAD](bytesRead);
        threw = false;
      } finally {
        if (threw) {
          try {
            this[CLOSE](() => {
            });
          } catch (er) {
          }
        }
      }
    }
    [AWAITDRAIN](cb) {
      cb();
    }
    [CLOSE](cb) {
      fs2.closeSync(this.fd);
      cb();
    }
  };
  var WriteEntryTar = warner(class WriteEntryTar extends MiniPass {
    constructor(readEntry, opt) {
      opt = opt || {};
      super(opt);
      this.preservePaths = !!opt.preservePaths;
      this.portable = !!opt.portable;
      this.strict = !!opt.strict;
      this.noPax = !!opt.noPax;
      this.noMtime = !!opt.noMtime;
      this.readEntry = readEntry;
      this.type = readEntry.type;
      if (this.type === "Directory" && this.portable)
        this.noMtime = true;
      this.prefix = opt.prefix || null;
      this.path = normPath(readEntry.path);
      this.mode = this[MODE](readEntry.mode);
      this.uid = this.portable ? null : readEntry.uid;
      this.gid = this.portable ? null : readEntry.gid;
      this.uname = this.portable ? null : readEntry.uname;
      this.gname = this.portable ? null : readEntry.gname;
      this.size = readEntry.size;
      this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime;
      this.atime = this.portable ? null : readEntry.atime;
      this.ctime = this.portable ? null : readEntry.ctime;
      this.linkpath = normPath(readEntry.linkpath);
      if (typeof opt.onwarn === "function")
        this.on("warn", opt.onwarn);
      let pathWarn = false;
      if (!this.preservePaths) {
        const [root, stripped] = stripAbsolutePath(this.path);
        if (root) {
          this.path = stripped;
          pathWarn = root;
        }
      }
      this.remain = readEntry.size;
      this.blockRemain = readEntry.startBlockSize;
      this.header = new Header({
        path: this[PREFIX](this.path),
        linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
        mode: this.mode,
        uid: this.portable ? null : this.uid,
        gid: this.portable ? null : this.gid,
        size: this.size,
        mtime: this.noMtime ? null : this.mtime,
        type: this.type,
        uname: this.portable ? null : this.uname,
        atime: this.portable ? null : this.atime,
        ctime: this.portable ? null : this.ctime
      });
      if (pathWarn) {
        this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
          entry: this,
          path: pathWarn + this.path
        });
      }
      if (this.header.encode() && !this.noPax) {
        super.write(new Pax({
          atime: this.portable ? null : this.atime,
          ctime: this.portable ? null : this.ctime,
          gid: this.portable ? null : this.gid,
          mtime: this.noMtime ? null : this.mtime,
          path: this[PREFIX](this.path),
          linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
          size: this.size,
          uid: this.portable ? null : this.uid,
          uname: this.portable ? null : this.uname,
          dev: this.portable ? null : this.readEntry.dev,
          ino: this.portable ? null : this.readEntry.ino,
          nlink: this.portable ? null : this.readEntry.nlink
        }).encode());
      }
      super.write(this.header.block);
      readEntry.pipe(this);
    }
    [PREFIX](path5) {
      return prefixPath(path5, this.prefix);
    }
    [MODE](mode) {
      return modeFix(mode, this.type === "Directory", this.portable);
    }
    write(data) {
      const writeLen = data.length;
      if (writeLen > this.blockRemain)
        throw new Error("writing more to entry than is appropriate");
      this.blockRemain -= writeLen;
      return super.write(data);
    }
    end() {
      if (this.blockRemain)
        super.write(Buffer.alloc(this.blockRemain));
      return super.end();
    }
  });
  WriteEntry.Sync = WriteEntrySync;
  WriteEntry.Tar = WriteEntryTar;
  var getType2 = (stat2) => stat2.isFile() ? "File" : stat2.isDirectory() ? "Directory" : stat2.isSymbolicLink() ? "SymbolicLink" : "Unsupported";
  module2.exports = WriteEntry;
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/pack.js
var require_pack = __commonJS2((exports2, module2) => {
  "use strict";
  var PackJob = class {
    constructor(path5, absolute) {
      this.path = path5 || "./";
      this.absolute = absolute;
      this.entry = null;
      this.stat = null;
      this.readdir = null;
      this.pending = false;
      this.ignore = false;
      this.piped = false;
    }
  };
  var MiniPass = require_minipass();
  var zlib = require_minizlib();
  var ReadEntry = require_read_entry();
  var WriteEntry = require_write_entry();
  var WriteEntrySync = WriteEntry.Sync;
  var WriteEntryTar = WriteEntry.Tar;
  var Yallist = require_yallist2();
  var EOF = Buffer.alloc(1024);
  var ONSTAT = Symbol("onStat");
  var ENDED = Symbol("ended");
  var QUEUE = Symbol("queue");
  var CURRENT = Symbol("current");
  var PROCESS = Symbol("process");
  var PROCESSING = Symbol("processing");
  var PROCESSJOB = Symbol("processJob");
  var JOBS = Symbol("jobs");
  var JOBDONE = Symbol("jobDone");
  var ADDFSENTRY = Symbol("addFSEntry");
  var ADDTARENTRY = Symbol("addTarEntry");
  var STAT = Symbol("stat");
  var READDIR = Symbol("readdir");
  var ONREADDIR = Symbol("onreaddir");
  var PIPE = Symbol("pipe");
  var ENTRY = Symbol("entry");
  var ENTRYOPT = Symbol("entryOpt");
  var WRITEENTRYCLASS = Symbol("writeEntryClass");
  var WRITE = Symbol("write");
  var ONDRAIN = Symbol("ondrain");
  var fs2 = require("fs");
  var path4 = require("path");
  var warner = require_warn_mixin();
  var normPath = require_normalize_windows_path();
  var Pack = warner(class Pack extends MiniPass {
    constructor(opt) {
      super(opt);
      opt = opt || Object.create(null);
      this.opt = opt;
      this.file = opt.file || "";
      this.cwd = opt.cwd || process.cwd();
      this.maxReadSize = opt.maxReadSize;
      this.preservePaths = !!opt.preservePaths;
      this.strict = !!opt.strict;
      this.noPax = !!opt.noPax;
      this.prefix = normPath(opt.prefix || "");
      this.linkCache = opt.linkCache || new Map();
      this.statCache = opt.statCache || new Map();
      this.readdirCache = opt.readdirCache || new Map();
      this[WRITEENTRYCLASS] = WriteEntry;
      if (typeof opt.onwarn === "function")
        this.on("warn", opt.onwarn);
      this.portable = !!opt.portable;
      this.zip = null;
      if (opt.gzip) {
        if (typeof opt.gzip !== "object")
          opt.gzip = {};
        if (this.portable)
          opt.gzip.portable = true;
        this.zip = new zlib.Gzip(opt.gzip);
        this.zip.on("data", (chunk) => super.write(chunk));
        this.zip.on("end", (_2) => super.end());
        this.zip.on("drain", (_2) => this[ONDRAIN]());
        this.on("resume", (_2) => this.zip.resume());
      } else
        this.on("drain", this[ONDRAIN]);
      this.noDirRecurse = !!opt.noDirRecurse;
      this.follow = !!opt.follow;
      this.noMtime = !!opt.noMtime;
      this.mtime = opt.mtime || null;
      this.filter = typeof opt.filter === "function" ? opt.filter : (_2) => true;
      this[QUEUE] = new Yallist();
      this[JOBS] = 0;
      this.jobs = +opt.jobs || 4;
      this[PROCESSING] = false;
      this[ENDED] = false;
    }
    [WRITE](chunk) {
      return super.write(chunk);
    }
    add(path5) {
      this.write(path5);
      return this;
    }
    end(path5) {
      if (path5)
        this.write(path5);
      this[ENDED] = true;
      this[PROCESS]();
      return this;
    }
    write(path5) {
      if (this[ENDED])
        throw new Error("write after end");
      if (path5 instanceof ReadEntry)
        this[ADDTARENTRY](path5);
      else
        this[ADDFSENTRY](path5);
      return this.flowing;
    }
    [ADDTARENTRY](p) {
      const absolute = normPath(path4.resolve(this.cwd, p.path));
      if (!this.filter(p.path, p))
        p.resume();
      else {
        const job = new PackJob(p.path, absolute, false);
        job.entry = new WriteEntryTar(p, this[ENTRYOPT](job));
        job.entry.on("end", (_2) => this[JOBDONE](job));
        this[JOBS] += 1;
        this[QUEUE].push(job);
      }
      this[PROCESS]();
    }
    [ADDFSENTRY](p) {
      const absolute = normPath(path4.resolve(this.cwd, p));
      this[QUEUE].push(new PackJob(p, absolute));
      this[PROCESS]();
    }
    [STAT](job) {
      job.pending = true;
      this[JOBS] += 1;
      const stat2 = this.follow ? "stat" : "lstat";
      fs2[stat2](job.absolute, (er, stat3) => {
        job.pending = false;
        this[JOBS] -= 1;
        if (er)
          this.emit("error", er);
        else
          this[ONSTAT](job, stat3);
      });
    }
    [ONSTAT](job, stat2) {
      this.statCache.set(job.absolute, stat2);
      job.stat = stat2;
      if (!this.filter(job.path, stat2))
        job.ignore = true;
      this[PROCESS]();
    }
    [READDIR](job) {
      job.pending = true;
      this[JOBS] += 1;
      fs2.readdir(job.absolute, (er, entries) => {
        job.pending = false;
        this[JOBS] -= 1;
        if (er)
          return this.emit("error", er);
        this[ONREADDIR](job, entries);
      });
    }
    [ONREADDIR](job, entries) {
      this.readdirCache.set(job.absolute, entries);
      job.readdir = entries;
      this[PROCESS]();
    }
    [PROCESS]() {
      if (this[PROCESSING])
        return;
      this[PROCESSING] = true;
      for (let w2 = this[QUEUE].head; w2 !== null && this[JOBS] < this.jobs; w2 = w2.next) {
        this[PROCESSJOB](w2.value);
        if (w2.value.ignore) {
          const p = w2.next;
          this[QUEUE].removeNode(w2);
          w2.next = p;
        }
      }
      this[PROCESSING] = false;
      if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {
        if (this.zip)
          this.zip.end(EOF);
        else {
          super.write(EOF);
          super.end();
        }
      }
    }
    get [CURRENT]() {
      return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value;
    }
    [JOBDONE](job) {
      this[QUEUE].shift();
      this[JOBS] -= 1;
      this[PROCESS]();
    }
    [PROCESSJOB](job) {
      if (job.pending)
        return;
      if (job.entry) {
        if (job === this[CURRENT] && !job.piped)
          this[PIPE](job);
        return;
      }
      if (!job.stat) {
        if (this.statCache.has(job.absolute))
          this[ONSTAT](job, this.statCache.get(job.absolute));
        else
          this[STAT](job);
      }
      if (!job.stat)
        return;
      if (job.ignore)
        return;
      if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {
        if (this.readdirCache.has(job.absolute))
          this[ONREADDIR](job, this.readdirCache.get(job.absolute));
        else
          this[READDIR](job);
        if (!job.readdir)
          return;
      }
      job.entry = this[ENTRY](job);
      if (!job.entry) {
        job.ignore = true;
        return;
      }
      if (job === this[CURRENT] && !job.piped)
        this[PIPE](job);
    }
    [ENTRYOPT](job) {
      return {
        onwarn: (code, msg, data) => this.warn(code, msg, data),
        noPax: this.noPax,
        cwd: this.cwd,
        absolute: job.absolute,
        preservePaths: this.preservePaths,
        maxReadSize: this.maxReadSize,
        strict: this.strict,
        portable: this.portable,
        linkCache: this.linkCache,
        statCache: this.statCache,
        noMtime: this.noMtime,
        mtime: this.mtime,
        prefix: this.prefix
      };
    }
    [ENTRY](job) {
      this[JOBS] += 1;
      try {
        return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job)).on("end", () => this[JOBDONE](job)).on("error", (er) => this.emit("error", er));
      } catch (er) {
        this.emit("error", er);
      }
    }
    [ONDRAIN]() {
      if (this[CURRENT] && this[CURRENT].entry)
        this[CURRENT].entry.resume();
    }
    [PIPE](job) {
      job.piped = true;
      if (job.readdir) {
        job.readdir.forEach((entry) => {
          const p = job.path;
          const base = p === "./" ? "" : p.replace(/\/*$/, "/");
          this[ADDFSENTRY](base + entry);
        });
      }
      const source = job.entry;
      const zip = this.zip;
      if (zip) {
        source.on("data", (chunk) => {
          if (!zip.write(chunk))
            source.pause();
        });
      } else {
        source.on("data", (chunk) => {
          if (!super.write(chunk))
            source.pause();
        });
      }
    }
    pause() {
      if (this.zip)
        this.zip.pause();
      return super.pause();
    }
  });
  var PackSync = class extends Pack {
    constructor(opt) {
      super(opt);
      this[WRITEENTRYCLASS] = WriteEntrySync;
    }
    pause() {
    }
    resume() {
    }
    [STAT](job) {
      const stat2 = this.follow ? "statSync" : "lstatSync";
      this[ONSTAT](job, fs2[stat2](job.absolute));
    }
    [READDIR](job, stat2) {
      this[ONREADDIR](job, fs2.readdirSync(job.absolute));
    }
    [PIPE](job) {
      const source = job.entry;
      const zip = this.zip;
      if (job.readdir) {
        job.readdir.forEach((entry) => {
          const p = job.path;
          const base = p === "./" ? "" : p.replace(/\/*$/, "/");
          this[ADDFSENTRY](base + entry);
        });
      }
      if (zip) {
        source.on("data", (chunk) => {
          zip.write(chunk);
        });
      } else {
        source.on("data", (chunk) => {
          super[WRITE](chunk);
        });
      }
    }
  };
  Pack.Sync = PackSync;
  module2.exports = Pack;
});

// ../../node_modules/.pnpm/fs-minipass@2.1.0/node_modules/fs-minipass/index.js
var require_fs_minipass = __commonJS2((exports2) => {
  "use strict";
  var MiniPass = require_minipass();
  var EE = require("events").EventEmitter;
  var fs2 = require("fs");
  var writev = fs2.writev;
  if (!writev) {
    const binding = process.binding("fs");
    const FSReqWrap = binding.FSReqWrap || binding.FSReqCallback;
    writev = (fd, iovec, pos, cb) => {
      const done = (er, bw) => cb(er, bw, iovec);
      const req = new FSReqWrap();
      req.oncomplete = done;
      binding.writeBuffers(fd, iovec, pos, req);
    };
  }
  var _autoClose = Symbol("_autoClose");
  var _close = Symbol("_close");
  var _ended = Symbol("_ended");
  var _fd = Symbol("_fd");
  var _finished = Symbol("_finished");
  var _flags = Symbol("_flags");
  var _flush = Symbol("_flush");
  var _handleChunk = Symbol("_handleChunk");
  var _makeBuf = Symbol("_makeBuf");
  var _mode = Symbol("_mode");
  var _needDrain = Symbol("_needDrain");
  var _onerror = Symbol("_onerror");
  var _onopen = Symbol("_onopen");
  var _onread = Symbol("_onread");
  var _onwrite = Symbol("_onwrite");
  var _open = Symbol("_open");
  var _path = Symbol("_path");
  var _pos = Symbol("_pos");
  var _queue = Symbol("_queue");
  var _read = Symbol("_read");
  var _readSize = Symbol("_readSize");
  var _reading = Symbol("_reading");
  var _remain = Symbol("_remain");
  var _size = Symbol("_size");
  var _write = Symbol("_write");
  var _writing = Symbol("_writing");
  var _defaultFlag = Symbol("_defaultFlag");
  var _errored = Symbol("_errored");
  var ReadStream = class extends MiniPass {
    constructor(path4, opt) {
      opt = opt || {};
      super(opt);
      this.readable = true;
      this.writable = false;
      if (typeof path4 !== "string")
        throw new TypeError("path must be a string");
      this[_errored] = false;
      this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
      this[_path] = path4;
      this[_readSize] = opt.readSize || 16 * 1024 * 1024;
      this[_reading] = false;
      this[_size] = typeof opt.size === "number" ? opt.size : Infinity;
      this[_remain] = this[_size];
      this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
      if (typeof this[_fd] === "number")
        this[_read]();
      else
        this[_open]();
    }
    get fd() {
      return this[_fd];
    }
    get path() {
      return this[_path];
    }
    write() {
      throw new TypeError("this is a readable stream");
    }
    end() {
      throw new TypeError("this is a readable stream");
    }
    [_open]() {
      fs2.open(this[_path], "r", (er, fd) => this[_onopen](er, fd));
    }
    [_onopen](er, fd) {
      if (er)
        this[_onerror](er);
      else {
        this[_fd] = fd;
        this.emit("open", fd);
        this[_read]();
      }
    }
    [_makeBuf]() {
      return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));
    }
    [_read]() {
      if (!this[_reading]) {
        this[_reading] = true;
        const buf = this[_makeBuf]();
        if (buf.length === 0)
          return process.nextTick(() => this[_onread](null, 0, buf));
        fs2.read(this[_fd], buf, 0, buf.length, null, (er, br, buf2) => this[_onread](er, br, buf2));
      }
    }
    [_onread](er, br, buf) {
      this[_reading] = false;
      if (er)
        this[_onerror](er);
      else if (this[_handleChunk](br, buf))
        this[_read]();
    }
    [_close]() {
      if (this[_autoClose] && typeof this[_fd] === "number") {
        const fd = this[_fd];
        this[_fd] = null;
        fs2.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
      }
    }
    [_onerror](er) {
      this[_reading] = true;
      this[_close]();
      this.emit("error", er);
    }
    [_handleChunk](br, buf) {
      let ret = false;
      this[_remain] -= br;
      if (br > 0)
        ret = super.write(br < buf.length ? buf.slice(0, br) : buf);
      if (br === 0 || this[_remain] <= 0) {
        ret = false;
        this[_close]();
        super.end();
      }
      return ret;
    }
    emit(ev, data) {
      switch (ev) {
        case "prefinish":
        case "finish":
          break;
        case "drain":
          if (typeof this[_fd] === "number")
            this[_read]();
          break;
        case "error":
          if (this[_errored])
            return;
          this[_errored] = true;
          return super.emit(ev, data);
        default:
          return super.emit(ev, data);
      }
    }
  };
  var ReadStreamSync = class extends ReadStream {
    [_open]() {
      let threw = true;
      try {
        this[_onopen](null, fs2.openSync(this[_path], "r"));
        threw = false;
      } finally {
        if (threw)
          this[_close]();
      }
    }
    [_read]() {
      let threw = true;
      try {
        if (!this[_reading]) {
          this[_reading] = true;
          do {
            const buf = this[_makeBuf]();
            const br = buf.length === 0 ? 0 : fs2.readSync(this[_fd], buf, 0, buf.length, null);
            if (!this[_handleChunk](br, buf))
              break;
          } while (true);
          this[_reading] = false;
        }
        threw = false;
      } finally {
        if (threw)
          this[_close]();
      }
    }
    [_close]() {
      if (this[_autoClose] && typeof this[_fd] === "number") {
        const fd = this[_fd];
        this[_fd] = null;
        fs2.closeSync(fd);
        this.emit("close");
      }
    }
  };
  var WriteStream = class extends EE {
    constructor(path4, opt) {
      opt = opt || {};
      super(opt);
      this.readable = false;
      this.writable = true;
      this[_errored] = false;
      this[_writing] = false;
      this[_ended] = false;
      this[_needDrain] = false;
      this[_queue] = [];
      this[_path] = path4;
      this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
      this[_mode] = opt.mode === void 0 ? 438 : opt.mode;
      this[_pos] = typeof opt.start === "number" ? opt.start : null;
      this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
      const defaultFlag = this[_pos] !== null ? "r+" : "w";
      this[_defaultFlag] = opt.flags === void 0;
      this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags;
      if (this[_fd] === null)
        this[_open]();
    }
    emit(ev, data) {
      if (ev === "error") {
        if (this[_errored])
          return;
        this[_errored] = true;
      }
      return super.emit(ev, data);
    }
    get fd() {
      return this[_fd];
    }
    get path() {
      return this[_path];
    }
    [_onerror](er) {
      this[_close]();
      this[_writing] = true;
      this.emit("error", er);
    }
    [_open]() {
      fs2.open(this[_path], this[_flags], this[_mode], (er, fd) => this[_onopen](er, fd));
    }
    [_onopen](er, fd) {
      if (this[_defaultFlag] && this[_flags] === "r+" && er && er.code === "ENOENT") {
        this[_flags] = "w";
        this[_open]();
      } else if (er)
        this[_onerror](er);
      else {
        this[_fd] = fd;
        this.emit("open", fd);
        this[_flush]();
      }
    }
    end(buf, enc) {
      if (buf)
        this.write(buf, enc);
      this[_ended] = true;
      if (!this[_writing] && !this[_queue].length && typeof this[_fd] === "number")
        this[_onwrite](null, 0);
      return this;
    }
    write(buf, enc) {
      if (typeof buf === "string")
        buf = Buffer.from(buf, enc);
      if (this[_ended]) {
        this.emit("error", new Error("write() after end()"));
        return false;
      }
      if (this[_fd] === null || this[_writing] || this[_queue].length) {
        this[_queue].push(buf);
        this[_needDrain] = true;
        return false;
      }
      this[_writing] = true;
      this[_write](buf);
      return true;
    }
    [_write](buf) {
      fs2.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) => this[_onwrite](er, bw));
    }
    [_onwrite](er, bw) {
      if (er)
        this[_onerror](er);
      else {
        if (this[_pos] !== null)
          this[_pos] += bw;
        if (this[_queue].length)
          this[_flush]();
        else {
          this[_writing] = false;
          if (this[_ended] && !this[_finished]) {
            this[_finished] = true;
            this[_close]();
            this.emit("finish");
          } else if (this[_needDrain]) {
            this[_needDrain] = false;
            this.emit("drain");
          }
        }
      }
    }
    [_flush]() {
      if (this[_queue].length === 0) {
        if (this[_ended])
          this[_onwrite](null, 0);
      } else if (this[_queue].length === 1)
        this[_write](this[_queue].pop());
      else {
        const iovec = this[_queue];
        this[_queue] = [];
        writev(this[_fd], iovec, this[_pos], (er, bw) => this[_onwrite](er, bw));
      }
    }
    [_close]() {
      if (this[_autoClose] && typeof this[_fd] === "number") {
        const fd = this[_fd];
        this[_fd] = null;
        fs2.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
      }
    }
  };
  var WriteStreamSync = class extends WriteStream {
    [_open]() {
      let fd;
      if (this[_defaultFlag] && this[_flags] === "r+") {
        try {
          fd = fs2.openSync(this[_path], this[_flags], this[_mode]);
        } catch (er) {
          if (er.code === "ENOENT") {
            this[_flags] = "w";
            return this[_open]();
          } else
            throw er;
        }
      } else
        fd = fs2.openSync(this[_path], this[_flags], this[_mode]);
      this[_onopen](null, fd);
    }
    [_close]() {
      if (this[_autoClose] && typeof this[_fd] === "number") {
        const fd = this[_fd];
        this[_fd] = null;
        fs2.closeSync(fd);
        this.emit("close");
      }
    }
    [_write](buf) {
      let threw = true;
      try {
        this[_onwrite](null, fs2.writeSync(this[_fd], buf, 0, buf.length, this[_pos]));
        threw = false;
      } finally {
        if (threw)
          try {
            this[_close]();
          } catch (_2) {
          }
      }
    }
  };
  exports2.ReadStream = ReadStream;
  exports2.ReadStreamSync = ReadStreamSync;
  exports2.WriteStream = WriteStream;
  exports2.WriteStreamSync = WriteStreamSync;
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/parse.js
var require_parse9 = __commonJS2((exports2, module2) => {
  "use strict";
  var warner = require_warn_mixin();
  var Header = require_header();
  var EE = require("events");
  var Yallist = require_yallist2();
  var maxMetaEntrySize = 1024 * 1024;
  var Entry = require_read_entry();
  var Pax = require_pax();
  var zlib = require_minizlib();
  var gzipHeader = Buffer.from([31, 139]);
  var STATE = Symbol("state");
  var WRITEENTRY = Symbol("writeEntry");
  var READENTRY = Symbol("readEntry");
  var NEXTENTRY = Symbol("nextEntry");
  var PROCESSENTRY = Symbol("processEntry");
  var EX = Symbol("extendedHeader");
  var GEX = Symbol("globalExtendedHeader");
  var META = Symbol("meta");
  var EMITMETA = Symbol("emitMeta");
  var BUFFER = Symbol("buffer");
  var QUEUE = Symbol("queue");
  var ENDED = Symbol("ended");
  var EMITTEDEND = Symbol("emittedEnd");
  var EMIT = Symbol("emit");
  var UNZIP = Symbol("unzip");
  var CONSUMECHUNK = Symbol("consumeChunk");
  var CONSUMECHUNKSUB = Symbol("consumeChunkSub");
  var CONSUMEBODY = Symbol("consumeBody");
  var CONSUMEMETA = Symbol("consumeMeta");
  var CONSUMEHEADER = Symbol("consumeHeader");
  var CONSUMING = Symbol("consuming");
  var BUFFERCONCAT = Symbol("bufferConcat");
  var MAYBEEND = Symbol("maybeEnd");
  var WRITING = Symbol("writing");
  var ABORTED = Symbol("aborted");
  var DONE = Symbol("onDone");
  var SAW_VALID_ENTRY = Symbol("sawValidEntry");
  var SAW_NULL_BLOCK = Symbol("sawNullBlock");
  var SAW_EOF = Symbol("sawEOF");
  var noop = (_2) => true;
  module2.exports = warner(class Parser extends EE {
    constructor(opt) {
      opt = opt || {};
      super(opt);
      this.file = opt.file || "";
      this[SAW_VALID_ENTRY] = null;
      this.on(DONE, (_2) => {
        if (this[STATE] === "begin" || this[SAW_VALID_ENTRY] === false) {
          this.warn("TAR_BAD_ARCHIVE", "Unrecognized archive format");
        }
      });
      if (opt.ondone)
        this.on(DONE, opt.ondone);
      else {
        this.on(DONE, (_2) => {
          this.emit("prefinish");
          this.emit("finish");
          this.emit("end");
          this.emit("close");
        });
      }
      this.strict = !!opt.strict;
      this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize;
      this.filter = typeof opt.filter === "function" ? opt.filter : noop;
      this.writable = true;
      this.readable = false;
      this[QUEUE] = new Yallist();
      this[BUFFER] = null;
      this[READENTRY] = null;
      this[WRITEENTRY] = null;
      this[STATE] = "begin";
      this[META] = "";
      this[EX] = null;
      this[GEX] = null;
      this[ENDED] = false;
      this[UNZIP] = null;
      this[ABORTED] = false;
      this[SAW_NULL_BLOCK] = false;
      this[SAW_EOF] = false;
      if (typeof opt.onwarn === "function")
        this.on("warn", opt.onwarn);
      if (typeof opt.onentry === "function")
        this.on("entry", opt.onentry);
    }
    [CONSUMEHEADER](chunk, position) {
      if (this[SAW_VALID_ENTRY] === null)
        this[SAW_VALID_ENTRY] = false;
      let header;
      try {
        header = new Header(chunk, position, this[EX], this[GEX]);
      } catch (er) {
        return this.warn("TAR_ENTRY_INVALID", er);
      }
      if (header.nullBlock) {
        if (this[SAW_NULL_BLOCK]) {
          this[SAW_EOF] = true;
          if (this[STATE] === "begin")
            this[STATE] = "header";
          this[EMIT]("eof");
        } else {
          this[SAW_NULL_BLOCK] = true;
          this[EMIT]("nullBlock");
        }
      } else {
        this[SAW_NULL_BLOCK] = false;
        if (!header.cksumValid)
          this.warn("TAR_ENTRY_INVALID", "checksum failure", {header});
        else if (!header.path)
          this.warn("TAR_ENTRY_INVALID", "path is required", {header});
        else {
          const type = header.type;
          if (/^(Symbolic)?Link$/.test(type) && !header.linkpath)
            this.warn("TAR_ENTRY_INVALID", "linkpath required", {header});
          else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath)
            this.warn("TAR_ENTRY_INVALID", "linkpath forbidden", {header});
          else {
            const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX]);
            if (!this[SAW_VALID_ENTRY]) {
              if (entry.remain) {
                const onend = () => {
                  if (!entry.invalid)
                    this[SAW_VALID_ENTRY] = true;
                };
                entry.on("end", onend);
              } else
                this[SAW_VALID_ENTRY] = true;
            }
            if (entry.meta) {
              if (entry.size > this.maxMetaEntrySize) {
                entry.ignore = true;
                this[EMIT]("ignoredEntry", entry);
                this[STATE] = "ignore";
                entry.resume();
              } else if (entry.size > 0) {
                this[META] = "";
                entry.on("data", (c) => this[META] += c);
                this[STATE] = "meta";
              }
            } else {
              this[EX] = null;
              entry.ignore = entry.ignore || !this.filter(entry.path, entry);
              if (entry.ignore) {
                this[EMIT]("ignoredEntry", entry);
                this[STATE] = entry.remain ? "ignore" : "header";
                entry.resume();
              } else {
                if (entry.remain)
                  this[STATE] = "body";
                else {
                  this[STATE] = "header";
                  entry.end();
                }
                if (!this[READENTRY]) {
                  this[QUEUE].push(entry);
                  this[NEXTENTRY]();
                } else
                  this[QUEUE].push(entry);
              }
            }
          }
        }
      }
    }
    [PROCESSENTRY](entry) {
      let go = true;
      if (!entry) {
        this[READENTRY] = null;
        go = false;
      } else if (Array.isArray(entry))
        this.emit.apply(this, entry);
      else {
        this[READENTRY] = entry;
        this.emit("entry", entry);
        if (!entry.emittedEnd) {
          entry.on("end", (_2) => this[NEXTENTRY]());
          go = false;
        }
      }
      return go;
    }
    [NEXTENTRY]() {
      do {
      } while (this[PROCESSENTRY](this[QUEUE].shift()));
      if (!this[QUEUE].length) {
        const re = this[READENTRY];
        const drainNow = !re || re.flowing || re.size === re.remain;
        if (drainNow) {
          if (!this[WRITING])
            this.emit("drain");
        } else
          re.once("drain", (_2) => this.emit("drain"));
      }
    }
    [CONSUMEBODY](chunk, position) {
      const entry = this[WRITEENTRY];
      const br = entry.blockRemain;
      const c = br >= chunk.length && position === 0 ? chunk : chunk.slice(position, position + br);
      entry.write(c);
      if (!entry.blockRemain) {
        this[STATE] = "header";
        this[WRITEENTRY] = null;
        entry.end();
      }
      return c.length;
    }
    [CONSUMEMETA](chunk, position) {
      const entry = this[WRITEENTRY];
      const ret = this[CONSUMEBODY](chunk, position);
      if (!this[WRITEENTRY])
        this[EMITMETA](entry);
      return ret;
    }
    [EMIT](ev, data, extra) {
      if (!this[QUEUE].length && !this[READENTRY])
        this.emit(ev, data, extra);
      else
        this[QUEUE].push([ev, data, extra]);
    }
    [EMITMETA](entry) {
      this[EMIT]("meta", this[META]);
      switch (entry.type) {
        case "ExtendedHeader":
        case "OldExtendedHeader":
          this[EX] = Pax.parse(this[META], this[EX], false);
          break;
        case "GlobalExtendedHeader":
          this[GEX] = Pax.parse(this[META], this[GEX], true);
          break;
        case "NextFileHasLongPath":
        case "OldGnuLongPath":
          this[EX] = this[EX] || Object.create(null);
          this[EX].path = this[META].replace(/\0.*/, "");
          break;
        case "NextFileHasLongLinkpath":
          this[EX] = this[EX] || Object.create(null);
          this[EX].linkpath = this[META].replace(/\0.*/, "");
          break;
        default:
          throw new Error("unknown meta: " + entry.type);
      }
    }
    abort(error) {
      this[ABORTED] = true;
      this.emit("abort", error);
      this.warn("TAR_ABORT", error, {recoverable: false});
    }
    write(chunk) {
      if (this[ABORTED])
        return;
      if (this[UNZIP] === null && chunk) {
        if (this[BUFFER]) {
          chunk = Buffer.concat([this[BUFFER], chunk]);
          this[BUFFER] = null;
        }
        if (chunk.length < gzipHeader.length) {
          this[BUFFER] = chunk;
          return true;
        }
        for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {
          if (chunk[i] !== gzipHeader[i])
            this[UNZIP] = false;
        }
        if (this[UNZIP] === null) {
          const ended = this[ENDED];
          this[ENDED] = false;
          this[UNZIP] = new zlib.Unzip();
          this[UNZIP].on("data", (chunk2) => this[CONSUMECHUNK](chunk2));
          this[UNZIP].on("error", (er) => this.abort(er));
          this[UNZIP].on("end", (_2) => {
            this[ENDED] = true;
            this[CONSUMECHUNK]();
          });
          this[WRITING] = true;
          const ret2 = this[UNZIP][ended ? "end" : "write"](chunk);
          this[WRITING] = false;
          return ret2;
        }
      }
      this[WRITING] = true;
      if (this[UNZIP])
        this[UNZIP].write(chunk);
      else
        this[CONSUMECHUNK](chunk);
      this[WRITING] = false;
      const ret = this[QUEUE].length ? false : this[READENTRY] ? this[READENTRY].flowing : true;
      if (!ret && !this[QUEUE].length)
        this[READENTRY].once("drain", (_2) => this.emit("drain"));
      return ret;
    }
    [BUFFERCONCAT](c) {
      if (c && !this[ABORTED])
        this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c;
    }
    [MAYBEEND]() {
      if (this[ENDED] && !this[EMITTEDEND] && !this[ABORTED] && !this[CONSUMING]) {
        this[EMITTEDEND] = true;
        const entry = this[WRITEENTRY];
        if (entry && entry.blockRemain) {
          const have = this[BUFFER] ? this[BUFFER].length : 0;
          this.warn("TAR_BAD_ARCHIVE", `Truncated input (needed ${entry.blockRemain} more bytes, only ${have} available)`, {entry});
          if (this[BUFFER])
            entry.write(this[BUFFER]);
          entry.end();
        }
        this[EMIT](DONE);
      }
    }
    [CONSUMECHUNK](chunk) {
      if (this[CONSUMING])
        this[BUFFERCONCAT](chunk);
      else if (!chunk && !this[BUFFER])
        this[MAYBEEND]();
      else {
        this[CONSUMING] = true;
        if (this[BUFFER]) {
          this[BUFFERCONCAT](chunk);
          const c = this[BUFFER];
          this[BUFFER] = null;
          this[CONSUMECHUNKSUB](c);
        } else
          this[CONSUMECHUNKSUB](chunk);
        while (this[BUFFER] && this[BUFFER].length >= 512 && !this[ABORTED] && !this[SAW_EOF]) {
          const c = this[BUFFER];
          this[BUFFER] = null;
          this[CONSUMECHUNKSUB](c);
        }
        this[CONSUMING] = false;
      }
      if (!this[BUFFER] || this[ENDED])
        this[MAYBEEND]();
    }
    [CONSUMECHUNKSUB](chunk) {
      let position = 0;
      const length = chunk.length;
      while (position + 512 <= length && !this[ABORTED] && !this[SAW_EOF]) {
        switch (this[STATE]) {
          case "begin":
          case "header":
            this[CONSUMEHEADER](chunk, position);
            position += 512;
            break;
          case "ignore":
          case "body":
            position += this[CONSUMEBODY](chunk, position);
            break;
          case "meta":
            position += this[CONSUMEMETA](chunk, position);
            break;
          default:
            throw new Error("invalid state: " + this[STATE]);
        }
      }
      if (position < length) {
        if (this[BUFFER])
          this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]]);
        else
          this[BUFFER] = chunk.slice(position);
      }
    }
    end(chunk) {
      if (!this[ABORTED]) {
        if (this[UNZIP])
          this[UNZIP].end(chunk);
        else {
          this[ENDED] = true;
          this.write(chunk);
        }
      }
    }
  });
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/list.js
var require_list = __commonJS2((exports2, module2) => {
  "use strict";
  var hlo = require_high_level_opt();
  var Parser = require_parse9();
  var fs2 = require("fs");
  var fsm = require_fs_minipass();
  var path4 = require("path");
  var stripSlash = require_strip_trailing_slashes();
  module2.exports = (opt_, files, cb) => {
    if (typeof opt_ === "function")
      cb = opt_, files = null, opt_ = {};
    else if (Array.isArray(opt_))
      files = opt_, opt_ = {};
    if (typeof files === "function")
      cb = files, files = null;
    if (!files)
      files = [];
    else
      files = Array.from(files);
    const opt = hlo(opt_);
    if (opt.sync && typeof cb === "function")
      throw new TypeError("callback not supported for sync tar functions");
    if (!opt.file && typeof cb === "function")
      throw new TypeError("callback only supported with file option");
    if (files.length)
      filesFilter(opt, files);
    if (!opt.noResume)
      onentryFunction(opt);
    return opt.file && opt.sync ? listFileSync(opt) : opt.file ? listFile(opt, cb) : list(opt);
  };
  var onentryFunction = (opt) => {
    const onentry = opt.onentry;
    opt.onentry = onentry ? (e) => {
      onentry(e);
      e.resume();
    } : (e) => e.resume();
  };
  var filesFilter = (opt, files) => {
    const map = new Map(files.map((f) => [stripSlash(f), true]));
    const filter = opt.filter;
    const mapHas = (file, r) => {
      const root = r || path4.parse(file).root || ".";
      const ret = file === root ? false : map.has(file) ? map.get(file) : mapHas(path4.dirname(file), root);
      map.set(file, ret);
      return ret;
    };
    opt.filter = filter ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file)) : (file) => mapHas(stripSlash(file));
  };
  var listFileSync = (opt) => {
    const p = list(opt);
    const file = opt.file;
    let threw = true;
    let fd;
    try {
      const stat2 = fs2.statSync(file);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      if (stat2.size < readSize)
        p.end(fs2.readFileSync(file));
      else {
        let pos = 0;
        const buf = Buffer.allocUnsafe(readSize);
        fd = fs2.openSync(file, "r");
        while (pos < stat2.size) {
          const bytesRead = fs2.readSync(fd, buf, 0, readSize, pos);
          pos += bytesRead;
          p.write(buf.slice(0, bytesRead));
        }
        p.end();
      }
      threw = false;
    } finally {
      if (threw && fd) {
        try {
          fs2.closeSync(fd);
        } catch (er) {
        }
      }
    }
  };
  var listFile = (opt, cb) => {
    const parse2 = new Parser(opt);
    const readSize = opt.maxReadSize || 16 * 1024 * 1024;
    const file = opt.file;
    const p = new Promise((resolve, reject) => {
      parse2.on("error", reject);
      parse2.on("end", resolve);
      fs2.stat(file, (er, stat2) => {
        if (er)
          reject(er);
        else {
          const stream = new fsm.ReadStream(file, {
            readSize,
            size: stat2.size
          });
          stream.on("error", reject);
          stream.pipe(parse2);
        }
      });
    });
    return cb ? p.then(cb, cb) : p;
  };
  var list = (opt) => new Parser(opt);
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/create.js
var require_create = __commonJS2((exports2, module2) => {
  "use strict";
  var hlo = require_high_level_opt();
  var Pack = require_pack();
  var fsm = require_fs_minipass();
  var t = require_list();
  var path4 = require("path");
  module2.exports = (opt_, files, cb) => {
    if (typeof files === "function")
      cb = files;
    if (Array.isArray(opt_))
      files = opt_, opt_ = {};
    if (!files || !Array.isArray(files) || !files.length)
      throw new TypeError("no files or directories specified");
    files = Array.from(files);
    const opt = hlo(opt_);
    if (opt.sync && typeof cb === "function")
      throw new TypeError("callback not supported for sync tar functions");
    if (!opt.file && typeof cb === "function")
      throw new TypeError("callback only supported with file option");
    return opt.file && opt.sync ? createFileSync(opt, files) : opt.file ? createFile(opt, files, cb) : opt.sync ? createSync(opt, files) : create(opt, files);
  };
  var createFileSync = (opt, files) => {
    const p = new Pack.Sync(opt);
    const stream = new fsm.WriteStreamSync(opt.file, {
      mode: opt.mode || 438
    });
    p.pipe(stream);
    addFilesSync(p, files);
  };
  var createFile = (opt, files, cb) => {
    const p = new Pack(opt);
    const stream = new fsm.WriteStream(opt.file, {
      mode: opt.mode || 438
    });
    p.pipe(stream);
    const promise = new Promise((res, rej) => {
      stream.on("error", rej);
      stream.on("close", res);
      p.on("error", rej);
    });
    addFilesAsync(p, files);
    return cb ? promise.then(cb, cb) : promise;
  };
  var addFilesSync = (p, files) => {
    files.forEach((file) => {
      if (file.charAt(0) === "@") {
        t({
          file: path4.resolve(p.cwd, file.substr(1)),
          sync: true,
          noResume: true,
          onentry: (entry) => p.add(entry)
        });
      } else
        p.add(file);
    });
    p.end();
  };
  var addFilesAsync = (p, files) => {
    while (files.length) {
      const file = files.shift();
      if (file.charAt(0) === "@") {
        return t({
          file: path4.resolve(p.cwd, file.substr(1)),
          noResume: true,
          onentry: (entry) => p.add(entry)
        }).then((_2) => addFilesAsync(p, files));
      } else
        p.add(file);
    }
    p.end();
  };
  var createSync = (opt, files) => {
    const p = new Pack.Sync(opt);
    addFilesSync(p, files);
    return p;
  };
  var create = (opt, files) => {
    const p = new Pack(opt);
    addFilesAsync(p, files);
    return p;
  };
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/replace.js
var require_replace = __commonJS2((exports2, module2) => {
  "use strict";
  var hlo = require_high_level_opt();
  var Pack = require_pack();
  var fs2 = require("fs");
  var fsm = require_fs_minipass();
  var t = require_list();
  var path4 = require("path");
  var Header = require_header();
  module2.exports = (opt_, files, cb) => {
    const opt = hlo(opt_);
    if (!opt.file)
      throw new TypeError("file is required");
    if (opt.gzip)
      throw new TypeError("cannot append to compressed archives");
    if (!files || !Array.isArray(files) || !files.length)
      throw new TypeError("no files or directories specified");
    files = Array.from(files);
    return opt.sync ? replaceSync(opt, files) : replace(opt, files, cb);
  };
  var replaceSync = (opt, files) => {
    const p = new Pack.Sync(opt);
    let threw = true;
    let fd;
    let position;
    try {
      try {
        fd = fs2.openSync(opt.file, "r+");
      } catch (er) {
        if (er.code === "ENOENT")
          fd = fs2.openSync(opt.file, "w+");
        else
          throw er;
      }
      const st = fs2.fstatSync(fd);
      const headBuf = Buffer.alloc(512);
      POSITION:
        for (position = 0; position < st.size; position += 512) {
          for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {
            bytes = fs2.readSync(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos);
            if (position === 0 && headBuf[0] === 31 && headBuf[1] === 139)
              throw new Error("cannot append to compressed archives");
            if (!bytes)
              break POSITION;
          }
          const h2 = new Header(headBuf);
          if (!h2.cksumValid)
            break;
          const entryBlockSize = 512 * Math.ceil(h2.size / 512);
          if (position + entryBlockSize + 512 > st.size)
            break;
          position += entryBlockSize;
          if (opt.mtimeCache)
            opt.mtimeCache.set(h2.path, h2.mtime);
        }
      threw = false;
      streamSync(opt, p, position, fd, files);
    } finally {
      if (threw) {
        try {
          fs2.closeSync(fd);
        } catch (er) {
        }
      }
    }
  };
  var streamSync = (opt, p, position, fd, files) => {
    const stream = new fsm.WriteStreamSync(opt.file, {
      fd,
      start: position
    });
    p.pipe(stream);
    addFilesSync(p, files);
  };
  var replace = (opt, files, cb) => {
    files = Array.from(files);
    const p = new Pack(opt);
    const getPos = (fd, size, cb_) => {
      const cb2 = (er, pos) => {
        if (er)
          fs2.close(fd, (_2) => cb_(er));
        else
          cb_(null, pos);
      };
      let position = 0;
      if (size === 0)
        return cb2(null, 0);
      let bufPos = 0;
      const headBuf = Buffer.alloc(512);
      const onread = (er, bytes) => {
        if (er)
          return cb2(er);
        bufPos += bytes;
        if (bufPos < 512 && bytes) {
          return fs2.read(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos, onread);
        }
        if (position === 0 && headBuf[0] === 31 && headBuf[1] === 139)
          return cb2(new Error("cannot append to compressed archives"));
        if (bufPos < 512)
          return cb2(null, position);
        const h2 = new Header(headBuf);
        if (!h2.cksumValid)
          return cb2(null, position);
        const entryBlockSize = 512 * Math.ceil(h2.size / 512);
        if (position + entryBlockSize + 512 > size)
          return cb2(null, position);
        position += entryBlockSize + 512;
        if (position >= size)
          return cb2(null, position);
        if (opt.mtimeCache)
          opt.mtimeCache.set(h2.path, h2.mtime);
        bufPos = 0;
        fs2.read(fd, headBuf, 0, 512, position, onread);
      };
      fs2.read(fd, headBuf, 0, 512, position, onread);
    };
    const promise = new Promise((resolve, reject) => {
      p.on("error", reject);
      let flag = "r+";
      const onopen = (er, fd) => {
        if (er && er.code === "ENOENT" && flag === "r+") {
          flag = "w+";
          return fs2.open(opt.file, flag, onopen);
        }
        if (er)
          return reject(er);
        fs2.fstat(fd, (er2, st) => {
          if (er2)
            return fs2.close(fd, () => reject(er2));
          getPos(fd, st.size, (er3, position) => {
            if (er3)
              return reject(er3);
            const stream = new fsm.WriteStream(opt.file, {
              fd,
              start: position
            });
            p.pipe(stream);
            stream.on("error", reject);
            stream.on("close", resolve);
            addFilesAsync(p, files);
          });
        });
      };
      fs2.open(opt.file, flag, onopen);
    });
    return cb ? promise.then(cb, cb) : promise;
  };
  var addFilesSync = (p, files) => {
    files.forEach((file) => {
      if (file.charAt(0) === "@") {
        t({
          file: path4.resolve(p.cwd, file.substr(1)),
          sync: true,
          noResume: true,
          onentry: (entry) => p.add(entry)
        });
      } else
        p.add(file);
    });
    p.end();
  };
  var addFilesAsync = (p, files) => {
    while (files.length) {
      const file = files.shift();
      if (file.charAt(0) === "@") {
        return t({
          file: path4.resolve(p.cwd, file.substr(1)),
          noResume: true,
          onentry: (entry) => p.add(entry)
        }).then((_2) => addFilesAsync(p, files));
      } else
        p.add(file);
    }
    p.end();
  };
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/update.js
var require_update = __commonJS2((exports2, module2) => {
  "use strict";
  var hlo = require_high_level_opt();
  var r = require_replace();
  module2.exports = (opt_, files, cb) => {
    const opt = hlo(opt_);
    if (!opt.file)
      throw new TypeError("file is required");
    if (opt.gzip)
      throw new TypeError("cannot append to compressed archives");
    if (!files || !Array.isArray(files) || !files.length)
      throw new TypeError("no files or directories specified");
    files = Array.from(files);
    mtimeFilter(opt);
    return r(opt, files, cb);
  };
  var mtimeFilter = (opt) => {
    const filter = opt.filter;
    if (!opt.mtimeCache)
      opt.mtimeCache = new Map();
    opt.filter = filter ? (path4, stat2) => filter(path4, stat2) && !(opt.mtimeCache.get(path4) > stat2.mtime) : (path4, stat2) => !(opt.mtimeCache.get(path4) > stat2.mtime);
  };
});

// ../../node_modules/.pnpm/chownr@2.0.0/node_modules/chownr/chownr.js
var require_chownr = __commonJS2((exports2, module2) => {
  "use strict";
  var fs2 = require("fs");
  var path4 = require("path");
  var LCHOWN = fs2.lchown ? "lchown" : "chown";
  var LCHOWNSYNC = fs2.lchownSync ? "lchownSync" : "chownSync";
  var needEISDIRHandled = fs2.lchown && !process.version.match(/v1[1-9]+\./) && !process.version.match(/v10\.[6-9]/);
  var lchownSync = (path5, uid, gid) => {
    try {
      return fs2[LCHOWNSYNC](path5, uid, gid);
    } catch (er) {
      if (er.code !== "ENOENT")
        throw er;
    }
  };
  var chownSync = (path5, uid, gid) => {
    try {
      return fs2.chownSync(path5, uid, gid);
    } catch (er) {
      if (er.code !== "ENOENT")
        throw er;
    }
  };
  var handleEISDIR = needEISDIRHandled ? (path5, uid, gid, cb) => (er) => {
    if (!er || er.code !== "EISDIR")
      cb(er);
    else
      fs2.chown(path5, uid, gid, cb);
  } : (_2, __, ___, cb) => cb;
  var handleEISDirSync = needEISDIRHandled ? (path5, uid, gid) => {
    try {
      return lchownSync(path5, uid, gid);
    } catch (er) {
      if (er.code !== "EISDIR")
        throw er;
      chownSync(path5, uid, gid);
    }
  } : (path5, uid, gid) => lchownSync(path5, uid, gid);
  var nodeVersion = process.version;
  var readdir2 = (path5, options, cb) => fs2.readdir(path5, options, cb);
  var readdirSync = (path5, options) => fs2.readdirSync(path5, options);
  if (/^v4\./.test(nodeVersion))
    readdir2 = (path5, options, cb) => fs2.readdir(path5, cb);
  var chown = (cpath, uid, gid, cb) => {
    fs2[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, (er) => {
      cb(er && er.code !== "ENOENT" ? er : null);
    }));
  };
  var chownrKid = (p, child, uid, gid, cb) => {
    if (typeof child === "string")
      return fs2.lstat(path4.resolve(p, child), (er, stats) => {
        if (er)
          return cb(er.code !== "ENOENT" ? er : null);
        stats.name = child;
        chownrKid(p, stats, uid, gid, cb);
      });
    if (child.isDirectory()) {
      chownr(path4.resolve(p, child.name), uid, gid, (er) => {
        if (er)
          return cb(er);
        const cpath = path4.resolve(p, child.name);
        chown(cpath, uid, gid, cb);
      });
    } else {
      const cpath = path4.resolve(p, child.name);
      chown(cpath, uid, gid, cb);
    }
  };
  var chownr = (p, uid, gid, cb) => {
    readdir2(p, {withFileTypes: true}, (er, children) => {
      if (er) {
        if (er.code === "ENOENT")
          return cb();
        else if (er.code !== "ENOTDIR" && er.code !== "ENOTSUP")
          return cb(er);
      }
      if (er || !children.length)
        return chown(p, uid, gid, cb);
      let len = children.length;
      let errState = null;
      const then = (er2) => {
        if (errState)
          return;
        if (er2)
          return cb(errState = er2);
        if (--len === 0)
          return chown(p, uid, gid, cb);
      };
      children.forEach((child) => chownrKid(p, child, uid, gid, then));
    });
  };
  var chownrKidSync = (p, child, uid, gid) => {
    if (typeof child === "string") {
      try {
        const stats = fs2.lstatSync(path4.resolve(p, child));
        stats.name = child;
        child = stats;
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        else
          throw er;
      }
    }
    if (child.isDirectory())
      chownrSync(path4.resolve(p, child.name), uid, gid);
    handleEISDirSync(path4.resolve(p, child.name), uid, gid);
  };
  var chownrSync = (p, uid, gid) => {
    let children;
    try {
      children = readdirSync(p, {withFileTypes: true});
    } catch (er) {
      if (er.code === "ENOENT")
        return;
      else if (er.code === "ENOTDIR" || er.code === "ENOTSUP")
        return handleEISDirSync(p, uid, gid);
      else
        throw er;
    }
    if (children && children.length)
      children.forEach((child) => chownrKidSync(p, child, uid, gid));
    return handleEISDirSync(p, uid, gid);
  };
  module2.exports = chownr;
  chownr.sync = chownrSync;
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/mkdir.js
var require_mkdir = __commonJS2((exports2, module2) => {
  "use strict";
  var mkdirp = require_mkdirp();
  var fs2 = require("fs");
  var path4 = require("path");
  var chownr = require_chownr();
  var normPath = require_normalize_windows_path();
  var SymlinkError = class extends Error {
    constructor(symlink, path5) {
      super("Cannot extract through symbolic link");
      this.path = path5;
      this.symlink = symlink;
    }
    get name() {
      return "SylinkError";
    }
  };
  var CwdError = class extends Error {
    constructor(path5, code) {
      super(code + ": Cannot cd into '" + path5 + "'");
      this.path = path5;
      this.code = code;
    }
    get name() {
      return "CwdError";
    }
  };
  var cGet = (cache, key) => cache.get(normPath(key));
  var cSet = (cache, key, val) => cache.set(normPath(key), val);
  var checkCwd = (dir, cb) => {
    fs2.stat(dir, (er, st) => {
      if (er || !st.isDirectory())
        er = new CwdError(dir, er && er.code || "ENOTDIR");
      cb(er);
    });
  };
  module2.exports = (dir, opt, cb) => {
    dir = normPath(dir);
    const umask = opt.umask;
    const mode = opt.mode | 448;
    const needChmod = (mode & umask) !== 0;
    const uid = opt.uid;
    const gid = opt.gid;
    const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
    const preserve = opt.preserve;
    const unlink2 = opt.unlink;
    const cache = opt.cache;
    const cwd = normPath(opt.cwd);
    const done = (er, created) => {
      if (er)
        cb(er);
      else {
        cSet(cache, dir, true);
        if (created && doChown)
          chownr(created, uid, gid, (er2) => done(er2));
        else if (needChmod)
          fs2.chmod(dir, mode, cb);
        else
          cb();
      }
    };
    if (cache && cGet(cache, dir) === true)
      return done();
    if (dir === cwd)
      return checkCwd(dir, done);
    if (preserve)
      return mkdirp(dir, {mode}).then((made) => done(null, made), done);
    const sub2 = normPath(path4.relative(cwd, dir));
    const parts = sub2.split("/");
    mkdir_(cwd, parts, mode, cache, unlink2, cwd, null, done);
  };
  var mkdir_ = (base, parts, mode, cache, unlink2, cwd, created, cb) => {
    if (!parts.length)
      return cb(null, created);
    const p = parts.shift();
    const part = normPath(path4.resolve(base + "/" + p));
    if (cGet(cache, part))
      return mkdir_(part, parts, mode, cache, unlink2, cwd, created, cb);
    fs2.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink2, cwd, created, cb));
  };
  var onmkdir = (part, parts, mode, cache, unlink2, cwd, created, cb) => (er) => {
    if (er) {
      fs2.lstat(part, (statEr, st) => {
        if (statEr) {
          statEr.path = statEr.path && normPath(statEr.path);
          cb(statEr);
        } else if (st.isDirectory())
          mkdir_(part, parts, mode, cache, unlink2, cwd, created, cb);
        else if (unlink2) {
          fs2.unlink(part, (er2) => {
            if (er2)
              return cb(er2);
            fs2.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink2, cwd, created, cb));
          });
        } else if (st.isSymbolicLink())
          return cb(new SymlinkError(part, part + "/" + parts.join("/")));
        else
          cb(er);
      });
    } else {
      created = created || part;
      mkdir_(part, parts, mode, cache, unlink2, cwd, created, cb);
    }
  };
  var checkCwdSync = (dir) => {
    let ok = false;
    let code = "ENOTDIR";
    try {
      ok = fs2.statSync(dir).isDirectory();
    } catch (er) {
      code = er.code;
    } finally {
      if (!ok)
        throw new CwdError(dir, code);
    }
  };
  module2.exports.sync = (dir, opt) => {
    dir = normPath(dir);
    const umask = opt.umask;
    const mode = opt.mode | 448;
    const needChmod = (mode & umask) !== 0;
    const uid = opt.uid;
    const gid = opt.gid;
    const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
    const preserve = opt.preserve;
    const unlink2 = opt.unlink;
    const cache = opt.cache;
    const cwd = normPath(opt.cwd);
    const done = (created2) => {
      cSet(cache, dir, true);
      if (created2 && doChown)
        chownr.sync(created2, uid, gid);
      if (needChmod)
        fs2.chmodSync(dir, mode);
    };
    if (cache && cGet(cache, dir) === true)
      return done();
    if (dir === cwd) {
      checkCwdSync(cwd);
      return done();
    }
    if (preserve)
      return done(mkdirp.sync(dir, mode));
    const sub2 = normPath(path4.relative(cwd, dir));
    const parts = sub2.split("/");
    let created = null;
    for (let p = parts.shift(), part = cwd; p && (part += "/" + p); p = parts.shift()) {
      part = normPath(path4.resolve(part));
      if (cGet(cache, part))
        continue;
      try {
        fs2.mkdirSync(part, mode);
        created = created || part;
        cSet(cache, part, true);
      } catch (er) {
        const st = fs2.lstatSync(part);
        if (st.isDirectory()) {
          cSet(cache, part, true);
          continue;
        } else if (unlink2) {
          fs2.unlinkSync(part);
          fs2.mkdirSync(part, mode);
          created = created || part;
          cSet(cache, part, true);
          continue;
        } else if (st.isSymbolicLink())
          return new SymlinkError(part, part + "/" + parts.join("/"));
      }
    }
    return done(created);
  };
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/path-reservations.js
var require_path_reservations = __commonJS2((exports2, module2) => {
  var assert = require("assert");
  var normPath = require_normalize_windows_path();
  var {join: join2} = require("path");
  module2.exports = () => {
    const queues = new Map();
    const reservations = new Map();
    const getDirs = (path4) => path4.split("/").slice(0, -1).reduce((set, path5) => set.length ? set.concat(normPath(join2(set[set.length - 1], path5))) : [path5], []);
    const running = new Set();
    const getQueues = (fn) => {
      const res = reservations.get(fn);
      if (!res)
        throw new Error("function does not have any path reservations");
      return {
        paths: res.paths.map((path4) => queues.get(path4)),
        dirs: [...res.dirs].map((path4) => queues.get(path4))
      };
    };
    const check2 = (fn) => {
      const {paths, dirs} = getQueues(fn);
      return paths.every((q) => q[0] === fn) && dirs.every((q) => q[0] instanceof Set && q[0].has(fn));
    };
    const run = (fn) => {
      if (running.has(fn) || !check2(fn))
        return false;
      running.add(fn);
      fn(() => clear(fn));
      return true;
    };
    const clear = (fn) => {
      if (!running.has(fn))
        return false;
      const {paths, dirs} = reservations.get(fn);
      const next = new Set();
      paths.forEach((path4) => {
        const q = queues.get(path4);
        assert.equal(q[0], fn);
        if (q.length === 1)
          queues.delete(path4);
        else {
          q.shift();
          if (typeof q[0] === "function")
            next.add(q[0]);
          else
            q[0].forEach((fn2) => next.add(fn2));
        }
      });
      dirs.forEach((dir) => {
        const q = queues.get(dir);
        assert(q[0] instanceof Set);
        if (q[0].size === 1 && q.length === 1)
          queues.delete(dir);
        else if (q[0].size === 1) {
          q.shift();
          next.add(q[0]);
        } else
          q[0].delete(fn);
      });
      running.delete(fn);
      next.forEach((fn2) => run(fn2));
      return true;
    };
    const reserve = (paths, fn) => {
      paths = paths.map((p) => normPath(join2(p)).toLowerCase());
      const dirs = new Set(paths.map((path4) => getDirs(path4)).reduce((a, b) => a.concat(b)));
      reservations.set(fn, {dirs, paths});
      paths.forEach((path4) => {
        const q = queues.get(path4);
        if (!q)
          queues.set(path4, [fn]);
        else
          q.push(fn);
      });
      dirs.forEach((dir) => {
        const q = queues.get(dir);
        if (!q)
          queues.set(dir, [new Set([fn])]);
        else if (q[q.length - 1] instanceof Set)
          q[q.length - 1].add(fn);
        else
          q.push(new Set([fn]));
      });
      return run(fn);
    };
    return {check: check2, reserve};
  };
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/get-write-flag.js
var require_get_write_flag = __commonJS2((exports2, module2) => {
  var platform = process.env.__FAKE_PLATFORM__ || process.platform;
  var isWindows = platform === "win32";
  var fs2 = global.__FAKE_TESTING_FS__ || require("fs");
  var {O_CREAT, O_TRUNC, O_WRONLY, UV_FS_O_FILEMAP = 0} = fs2.constants;
  var fMapEnabled = isWindows && !!UV_FS_O_FILEMAP;
  var fMapLimit = 512 * 1024;
  var fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY;
  module2.exports = !fMapEnabled ? () => "w" : (size) => size < fMapLimit ? fMapFlag : "w";
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/unpack.js
var require_unpack = __commonJS2((exports2, module2) => {
  "use strict";
  var assert = require("assert");
  var Parser = require_parse9();
  var fs2 = require("fs");
  var fsm = require_fs_minipass();
  var path4 = require("path");
  var mkdir2 = require_mkdir();
  var wc = require_winchars();
  var pathReservations = require_path_reservations();
  var stripAbsolutePath = require_strip_absolute_path();
  var normPath = require_normalize_windows_path();
  var ONENTRY = Symbol("onEntry");
  var CHECKFS = Symbol("checkFs");
  var CHECKFS2 = Symbol("checkFs2");
  var ISREUSABLE = Symbol("isReusable");
  var MAKEFS = Symbol("makeFs");
  var FILE = Symbol("file");
  var DIRECTORY = Symbol("directory");
  var LINK = Symbol("link");
  var SYMLINK = Symbol("symlink");
  var HARDLINK = Symbol("hardlink");
  var UNSUPPORTED = Symbol("unsupported");
  var CHECKPATH = Symbol("checkPath");
  var MKDIR = Symbol("mkdir");
  var ONERROR = Symbol("onError");
  var PENDING = Symbol("pending");
  var PEND = Symbol("pend");
  var UNPEND = Symbol("unpend");
  var ENDED = Symbol("ended");
  var MAYBECLOSE = Symbol("maybeClose");
  var SKIP = Symbol("skip");
  var DOCHOWN = Symbol("doChown");
  var UID = Symbol("uid");
  var GID = Symbol("gid");
  var CHECKED_CWD = Symbol("checkedCwd");
  var crypto2 = require("crypto");
  var getFlag = require_get_write_flag();
  var unlinkFile = (path5, cb) => {
    if (process.platform !== "win32")
      return fs2.unlink(path5, cb);
    const name = path5 + ".DELETE." + crypto2.randomBytes(16).toString("hex");
    fs2.rename(path5, name, (er) => {
      if (er)
        return cb(er);
      fs2.unlink(name, cb);
    });
  };
  var unlinkFileSync = (path5) => {
    if (process.platform !== "win32")
      return fs2.unlinkSync(path5);
    const name = path5 + ".DELETE." + crypto2.randomBytes(16).toString("hex");
    fs2.renameSync(path5, name);
    fs2.unlinkSync(name);
  };
  var uint32 = (a, b, c) => a === a >>> 0 ? a : b === b >>> 0 ? b : c;
  var pruneCache = (cache, abs2) => {
    abs2 = normPath(abs2).toLowerCase();
    for (const path5 of cache.keys()) {
      const plower = path5.toLowerCase();
      if (plower === abs2 || plower.toLowerCase().indexOf(abs2 + "/") === 0)
        cache.delete(path5);
    }
  };
  var Unpack = class extends Parser {
    constructor(opt) {
      if (!opt)
        opt = {};
      opt.ondone = (_2) => {
        this[ENDED] = true;
        this[MAYBECLOSE]();
      };
      super(opt);
      this[CHECKED_CWD] = false;
      this.reservations = pathReservations();
      this.transform = typeof opt.transform === "function" ? opt.transform : null;
      this.writable = true;
      this.readable = false;
      this[PENDING] = 0;
      this[ENDED] = false;
      this.dirCache = opt.dirCache || new Map();
      if (typeof opt.uid === "number" || typeof opt.gid === "number") {
        if (typeof opt.uid !== "number" || typeof opt.gid !== "number")
          throw new TypeError("cannot set owner without number uid and gid");
        if (opt.preserveOwner) {
          throw new TypeError("cannot preserve owner in archive and also set owner explicitly");
        }
        this.uid = opt.uid;
        this.gid = opt.gid;
        this.setOwner = true;
      } else {
        this.uid = null;
        this.gid = null;
        this.setOwner = false;
      }
      if (opt.preserveOwner === void 0 && typeof opt.uid !== "number")
        this.preserveOwner = process.getuid && process.getuid() === 0;
      else
        this.preserveOwner = !!opt.preserveOwner;
      this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ? process.getuid() : null;
      this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ? process.getgid() : null;
      this.forceChown = opt.forceChown === true;
      this.win32 = !!opt.win32 || process.platform === "win32";
      this.newer = !!opt.newer;
      this.keep = !!opt.keep;
      this.noMtime = !!opt.noMtime;
      this.preservePaths = !!opt.preservePaths;
      this.unlink = !!opt.unlink;
      this.cwd = normPath(path4.resolve(opt.cwd || process.cwd()));
      this.strip = +opt.strip || 0;
      this.processUmask = opt.noChmod ? 0 : process.umask();
      this.umask = typeof opt.umask === "number" ? opt.umask : this.processUmask;
      this.dmode = opt.dmode || 511 & ~this.umask;
      this.fmode = opt.fmode || 438 & ~this.umask;
      this.on("entry", (entry) => this[ONENTRY](entry));
    }
    warn(code, msg, data = {}) {
      if (code === "TAR_BAD_ARCHIVE" || code === "TAR_ABORT")
        data.recoverable = false;
      return super.warn(code, msg, data);
    }
    [MAYBECLOSE]() {
      if (this[ENDED] && this[PENDING] === 0) {
        this.emit("prefinish");
        this.emit("finish");
        this.emit("end");
        this.emit("close");
      }
    }
    [CHECKPATH](entry) {
      if (this.strip) {
        const parts = normPath(entry.path).split("/");
        if (parts.length < this.strip)
          return false;
        entry.path = parts.slice(this.strip).join("/");
        if (entry.type === "Link") {
          const linkparts = normPath(entry.linkpath).split("/");
          if (linkparts.length >= this.strip)
            entry.linkpath = linkparts.slice(this.strip).join("/");
          else
            return false;
        }
      }
      if (!this.preservePaths) {
        const p = normPath(entry.path);
        if (p.split("/").includes("..")) {
          this.warn("TAR_ENTRY_ERROR", `path contains '..'`, {
            entry,
            path: p
          });
          return false;
        }
        const [root, stripped] = stripAbsolutePath(p);
        if (root) {
          entry.path = stripped;
          this.warn("TAR_ENTRY_INFO", `stripping ${root} from absolute path`, {
            entry,
            path: p
          });
        }
      }
      if (path4.isAbsolute(entry.path))
        entry.absolute = normPath(path4.resolve(entry.path));
      else
        entry.absolute = normPath(path4.resolve(this.cwd, entry.path));
      if (entry.absolute === this.cwd && entry.type !== "Directory" && entry.type !== "GNUDumpDir")
        return false;
      if (this.win32) {
        const {root: aRoot} = path4.win32.parse(entry.absolute);
        entry.absolute = aRoot + wc.encode(entry.absolute.substr(aRoot.length));
        const {root: pRoot} = path4.win32.parse(entry.path);
        entry.path = pRoot + wc.encode(entry.path.substr(pRoot.length));
      }
      return true;
    }
    [ONENTRY](entry) {
      if (!this[CHECKPATH](entry))
        return entry.resume();
      assert.equal(typeof entry.absolute, "string");
      switch (entry.type) {
        case "Directory":
        case "GNUDumpDir":
          if (entry.mode)
            entry.mode = entry.mode | 448;
        case "File":
        case "OldFile":
        case "ContiguousFile":
        case "Link":
        case "SymbolicLink":
          return this[CHECKFS](entry);
        case "CharacterDevice":
        case "BlockDevice":
        case "FIFO":
        default:
          return this[UNSUPPORTED](entry);
      }
    }
    [ONERROR](er, entry) {
      if (er.name === "CwdError")
        this.emit("error", er);
      else {
        this.warn("TAR_ENTRY_ERROR", er, {entry});
        this[UNPEND]();
        entry.resume();
      }
    }
    [MKDIR](dir, mode, cb) {
      mkdir2(normPath(dir), {
        uid: this.uid,
        gid: this.gid,
        processUid: this.processUid,
        processGid: this.processGid,
        umask: this.processUmask,
        preserve: this.preservePaths,
        unlink: this.unlink,
        cache: this.dirCache,
        cwd: this.cwd,
        mode,
        noChmod: this.noChmod
      }, cb);
    }
    [DOCHOWN](entry) {
      return this.forceChown || this.preserveOwner && (typeof entry.uid === "number" && entry.uid !== this.processUid || typeof entry.gid === "number" && entry.gid !== this.processGid) || (typeof this.uid === "number" && this.uid !== this.processUid || typeof this.gid === "number" && this.gid !== this.processGid);
    }
    [UID](entry) {
      return uint32(this.uid, entry.uid, this.processUid);
    }
    [GID](entry) {
      return uint32(this.gid, entry.gid, this.processGid);
    }
    [FILE](entry, fullyDone) {
      const mode = entry.mode & 4095 || this.fmode;
      const stream = new fsm.WriteStream(entry.absolute, {
        flags: getFlag(entry.size),
        mode,
        autoClose: false
      });
      stream.on("error", (er) => {
        if (stream.fd)
          fs2.close(stream.fd, () => {
          });
        stream.write = () => true;
        this[ONERROR](er, entry);
        fullyDone();
      });
      let actions = 1;
      const done = (er) => {
        if (er) {
          if (stream.fd)
            fs2.close(stream.fd, () => {
            });
          this[ONERROR](er, entry);
          fullyDone();
          return;
        }
        if (--actions === 0) {
          fs2.close(stream.fd, (er2) => {
            if (er2)
              this[ONERROR](er2, entry);
            else
              this[UNPEND]();
            fullyDone();
          });
        }
      };
      stream.on("finish", (_2) => {
        const abs2 = entry.absolute;
        const fd = stream.fd;
        if (entry.mtime && !this.noMtime) {
          actions++;
          const atime = entry.atime || new Date();
          const mtime = entry.mtime;
          fs2.futimes(fd, atime, mtime, (er) => er ? fs2.utimes(abs2, atime, mtime, (er2) => done(er2 && er)) : done());
        }
        if (this[DOCHOWN](entry)) {
          actions++;
          const uid = this[UID](entry);
          const gid = this[GID](entry);
          fs2.fchown(fd, uid, gid, (er) => er ? fs2.chown(abs2, uid, gid, (er2) => done(er2 && er)) : done());
        }
        done();
      });
      const tx = this.transform ? this.transform(entry) || entry : entry;
      if (tx !== entry) {
        tx.on("error", (er) => {
          this[ONERROR](er, entry);
          fullyDone();
        });
        entry.pipe(tx);
      }
      tx.pipe(stream);
    }
    [DIRECTORY](entry, fullyDone) {
      const mode = entry.mode & 4095 || this.dmode;
      this[MKDIR](entry.absolute, mode, (er) => {
        if (er) {
          this[ONERROR](er, entry);
          fullyDone();
          return;
        }
        let actions = 1;
        const done = (_2) => {
          if (--actions === 0) {
            fullyDone();
            this[UNPEND]();
            entry.resume();
          }
        };
        if (entry.mtime && !this.noMtime) {
          actions++;
          fs2.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done);
        }
        if (this[DOCHOWN](entry)) {
          actions++;
          fs2.chown(entry.absolute, this[UID](entry), this[GID](entry), done);
        }
        done();
      });
    }
    [UNSUPPORTED](entry) {
      entry.unsupported = true;
      this.warn("TAR_ENTRY_UNSUPPORTED", `unsupported entry type: ${entry.type}`, {entry});
      entry.resume();
    }
    [SYMLINK](entry, done) {
      this[LINK](entry, entry.linkpath, "symlink", done);
    }
    [HARDLINK](entry, done) {
      const linkpath = normPath(path4.resolve(this.cwd, entry.linkpath));
      this[LINK](entry, linkpath, "link", done);
    }
    [PEND]() {
      this[PENDING]++;
    }
    [UNPEND]() {
      this[PENDING]--;
      this[MAYBECLOSE]();
    }
    [SKIP](entry) {
      this[UNPEND]();
      entry.resume();
    }
    [ISREUSABLE](entry, st) {
      return entry.type === "File" && !this.unlink && st.isFile() && st.nlink <= 1 && process.platform !== "win32";
    }
    [CHECKFS](entry) {
      this[PEND]();
      const paths = [entry.path];
      if (entry.linkpath)
        paths.push(entry.linkpath);
      this.reservations.reserve(paths, (done) => this[CHECKFS2](entry, done));
    }
    [CHECKFS2](entry, done) {
      if (entry.type !== "Directory")
        pruneCache(this.dirCache, entry.absolute);
      const checkCwd = () => {
        this[MKDIR](this.cwd, this.dmode, (er) => {
          if (er) {
            this[ONERROR](er, entry);
            done();
            return;
          }
          this[CHECKED_CWD] = true;
          start();
        });
      };
      const start = () => {
        if (entry.absolute !== this.cwd) {
          const parent = normPath(path4.dirname(entry.absolute));
          if (parent !== this.cwd) {
            return this[MKDIR](parent, this.dmode, (er) => {
              if (er) {
                this[ONERROR](er, entry);
                done();
                return;
              }
              afterMakeParent();
            });
          }
        }
        afterMakeParent();
      };
      const afterMakeParent = () => {
        fs2.lstat(entry.absolute, (lstatEr, st) => {
          if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {
            this[SKIP](entry);
            done();
            return;
          }
          if (lstatEr || this[ISREUSABLE](entry, st))
            return this[MAKEFS](null, entry, done);
          if (st.isDirectory()) {
            if (entry.type === "Directory") {
              const needChmod = !this.noChmod && entry.mode && (st.mode & 4095) !== entry.mode;
              const afterChmod = (er) => this[MAKEFS](er, entry, done);
              if (!needChmod)
                return afterChmod();
              return fs2.chmod(entry.absolute, entry.mode, afterChmod);
            }
            if (entry.absolute !== this.cwd) {
              return fs2.rmdir(entry.absolute, (er) => this[MAKEFS](er, entry, done));
            }
          }
          if (entry.absolute === this.cwd)
            return this[MAKEFS](null, entry, done);
          unlinkFile(entry.absolute, (er) => this[MAKEFS](er, entry, done));
        });
      };
      if (this[CHECKED_CWD])
        start();
      else
        checkCwd();
    }
    [MAKEFS](er, entry, done) {
      if (er) {
        this[ONERROR](er, entry);
        done();
        return;
      }
      switch (entry.type) {
        case "File":
        case "OldFile":
        case "ContiguousFile":
          return this[FILE](entry, done);
        case "Link":
          return this[HARDLINK](entry, done);
        case "SymbolicLink":
          return this[SYMLINK](entry, done);
        case "Directory":
        case "GNUDumpDir":
          return this[DIRECTORY](entry, done);
      }
    }
    [LINK](entry, linkpath, link2, done) {
      fs2[link2](linkpath, entry.absolute, (er) => {
        if (er)
          this[ONERROR](er, entry);
        else {
          this[UNPEND]();
          entry.resume();
        }
        done();
      });
    }
  };
  var callSync = (fn) => {
    try {
      return [null, fn()];
    } catch (er) {
      return [er, null];
    }
  };
  var UnpackSync = class extends Unpack {
    [MAKEFS](er, entry) {
      return super[MAKEFS](er, entry, () => {
      });
    }
    [CHECKFS](entry) {
      if (entry.type !== "Directory")
        pruneCache(this.dirCache, entry.absolute);
      if (!this[CHECKED_CWD]) {
        const er2 = this[MKDIR](this.cwd, this.dmode);
        if (er2)
          return this[ONERROR](er2, entry);
        this[CHECKED_CWD] = true;
      }
      if (entry.absolute !== this.cwd) {
        const parent = normPath(path4.dirname(entry.absolute));
        if (parent !== this.cwd) {
          const mkParent = this[MKDIR](parent, this.dmode);
          if (mkParent)
            return this[ONERROR](mkParent, entry);
        }
      }
      const [lstatEr, st] = callSync(() => fs2.lstatSync(entry.absolute));
      if (st && (this.keep || this.newer && st.mtime > entry.mtime))
        return this[SKIP](entry);
      if (lstatEr || this[ISREUSABLE](entry, st))
        return this[MAKEFS](null, entry);
      if (st.isDirectory()) {
        if (entry.type === "Directory") {
          const needChmod = !this.noChmod && entry.mode && (st.mode & 4095) !== entry.mode;
          const [er3] = needChmod ? callSync(() => {
            fs2.chmodSync(entry.absolute, entry.mode);
          }) : [];
          return this[MAKEFS](er3, entry);
        }
        const [er2] = callSync(() => fs2.rmdirSync(entry.absolute));
        this[MAKEFS](er2, entry);
      }
      const [er] = entry.absolute === this.cwd ? [] : callSync(() => unlinkFileSync(entry.absolute));
      this[MAKEFS](er, entry);
    }
    [FILE](entry, _2) {
      const mode = entry.mode & 4095 || this.fmode;
      const oner = (er) => {
        let closeError;
        try {
          fs2.closeSync(fd);
        } catch (e) {
          closeError = e;
        }
        if (er || closeError)
          this[ONERROR](er || closeError, entry);
      };
      let fd;
      try {
        fd = fs2.openSync(entry.absolute, getFlag(entry.size), mode);
      } catch (er) {
        return oner(er);
      }
      const tx = this.transform ? this.transform(entry) || entry : entry;
      if (tx !== entry) {
        tx.on("error", (er) => this[ONERROR](er, entry));
        entry.pipe(tx);
      }
      tx.on("data", (chunk) => {
        try {
          fs2.writeSync(fd, chunk, 0, chunk.length);
        } catch (er) {
          oner(er);
        }
      });
      tx.on("end", (_3) => {
        let er = null;
        if (entry.mtime && !this.noMtime) {
          const atime = entry.atime || new Date();
          const mtime = entry.mtime;
          try {
            fs2.futimesSync(fd, atime, mtime);
          } catch (futimeser) {
            try {
              fs2.utimesSync(entry.absolute, atime, mtime);
            } catch (utimeser) {
              er = futimeser;
            }
          }
        }
        if (this[DOCHOWN](entry)) {
          const uid = this[UID](entry);
          const gid = this[GID](entry);
          try {
            fs2.fchownSync(fd, uid, gid);
          } catch (fchowner) {
            try {
              fs2.chownSync(entry.absolute, uid, gid);
            } catch (chowner) {
              er = er || fchowner;
            }
          }
        }
        oner(er);
      });
    }
    [DIRECTORY](entry, _2) {
      const mode = entry.mode & 4095 || this.dmode;
      const er = this[MKDIR](entry.absolute, mode);
      if (er)
        return this[ONERROR](er, entry);
      if (entry.mtime && !this.noMtime) {
        try {
          fs2.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime);
        } catch (er2) {
        }
      }
      if (this[DOCHOWN](entry)) {
        try {
          fs2.chownSync(entry.absolute, this[UID](entry), this[GID](entry));
        } catch (er2) {
        }
      }
      entry.resume();
    }
    [MKDIR](dir, mode) {
      try {
        return mkdir2.sync(normPath(dir), {
          uid: this.uid,
          gid: this.gid,
          processUid: this.processUid,
          processGid: this.processGid,
          umask: this.processUmask,
          preserve: this.preservePaths,
          unlink: this.unlink,
          cache: this.dirCache,
          cwd: this.cwd,
          mode
        });
      } catch (er) {
        return er;
      }
    }
    [LINK](entry, linkpath, link2, _2) {
      try {
        fs2[link2 + "Sync"](linkpath, entry.absolute);
        entry.resume();
      } catch (er) {
        return this[ONERROR](er, entry);
      }
    }
  };
  Unpack.Sync = UnpackSync;
  module2.exports = Unpack;
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/lib/extract.js
var require_extract = __commonJS2((exports2, module2) => {
  "use strict";
  var hlo = require_high_level_opt();
  var Unpack = require_unpack();
  var fs2 = require("fs");
  var fsm = require_fs_minipass();
  var path4 = require("path");
  var stripSlash = require_strip_trailing_slashes();
  module2.exports = (opt_, files, cb) => {
    if (typeof opt_ === "function")
      cb = opt_, files = null, opt_ = {};
    else if (Array.isArray(opt_))
      files = opt_, opt_ = {};
    if (typeof files === "function")
      cb = files, files = null;
    if (!files)
      files = [];
    else
      files = Array.from(files);
    const opt = hlo(opt_);
    if (opt.sync && typeof cb === "function")
      throw new TypeError("callback not supported for sync tar functions");
    if (!opt.file && typeof cb === "function")
      throw new TypeError("callback only supported with file option");
    if (files.length)
      filesFilter(opt, files);
    return opt.file && opt.sync ? extractFileSync(opt) : opt.file ? extractFile(opt, cb) : opt.sync ? extractSync(opt) : extract(opt);
  };
  var filesFilter = (opt, files) => {
    const map = new Map(files.map((f) => [stripSlash(f), true]));
    const filter = opt.filter;
    const mapHas = (file, r) => {
      const root = r || path4.parse(file).root || ".";
      const ret = file === root ? false : map.has(file) ? map.get(file) : mapHas(path4.dirname(file), root);
      map.set(file, ret);
      return ret;
    };
    opt.filter = filter ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file)) : (file) => mapHas(stripSlash(file));
  };
  var extractFileSync = (opt) => {
    const u = new Unpack.Sync(opt);
    const file = opt.file;
    const stat2 = fs2.statSync(file);
    const readSize = opt.maxReadSize || 16 * 1024 * 1024;
    const stream = new fsm.ReadStreamSync(file, {
      readSize,
      size: stat2.size
    });
    stream.pipe(u);
  };
  var extractFile = (opt, cb) => {
    const u = new Unpack(opt);
    const readSize = opt.maxReadSize || 16 * 1024 * 1024;
    const file = opt.file;
    const p = new Promise((resolve, reject) => {
      u.on("error", reject);
      u.on("close", resolve);
      fs2.stat(file, (er, stat2) => {
        if (er)
          reject(er);
        else {
          const stream = new fsm.ReadStream(file, {
            readSize,
            size: stat2.size
          });
          stream.on("error", reject);
          stream.pipe(u);
        }
      });
    });
    return cb ? p.then(cb, cb) : p;
  };
  var extractSync = (opt) => new Unpack.Sync(opt);
  var extract = (opt) => new Unpack(opt);
});

// ../../node_modules/.pnpm/tar@6.1.8/node_modules/tar/index.js
var require_tar = __commonJS2((exports2) => {
  "use strict";
  exports2.c = exports2.create = require_create();
  exports2.r = exports2.replace = require_replace();
  exports2.t = exports2.list = require_list();
  exports2.u = exports2.update = require_update();
  exports2.x = exports2.extract = require_extract();
  exports2.Pack = require_pack();
  exports2.Unpack = require_unpack();
  exports2.Parse = require_parse9();
  exports2.ReadEntry = require_read_entry();
  exports2.WriteEntry = require_write_entry();
  exports2.Header = require_header();
  exports2.Pax = require_pax();
  exports2.types = require_types3();
});

// ../sdk/dist/utils/hasYarn.js
var require_hasYarn = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    hasYarn: () => hasYarn
  });
  var import_execa2 = __toModule3(require_execa2());
  async function hasYarn(packageDir) {
    try {
      await import_execa2.default.command("yarn --version", {
        shell: true,
        cwd: packageDir
      });
      return true;
    } catch (e) {
      return false;
    }
  }
});

// ../sdk/dist/getPackedPackage.js
var require_getPackedPackage = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    getPackedPackage: () => getPackedPackage2
  });
  var import_copy = __toModule3(require_copy());
  var import_execa2 = __toModule3(require_execa2());
  var import_fs2 = __toModule3(require("fs"));
  var import_make_dir2 = __toModule3(require_make_dir2());
  var import_path4 = __toModule3(require("path"));
  var import_read_pkg_up = __toModule3(require_read_pkg_up());
  var import_resolve = __toModule3(require_resolve2());
  var import_rimraf = __toModule3(require_rimraf2());
  var import_shell_quote = __toModule3(require_shell_quote());
  var import_tar = __toModule3(require_tar());
  var import_tempy = __toModule3(require_tempy2());
  var import_util3 = __toModule3(require("util"));
  var import_hasYarn = __toModule3(require_hasYarn());
  var del = (0, import_util3.promisify)(import_rimraf.default);
  var readdir2 = (0, import_util3.promisify)(import_fs2.default.readdir);
  var rename2 = (0, import_util3.promisify)(import_fs2.default.rename);
  async function getPackedPackage2(name, target, packageDir) {
    packageDir = packageDir || await (0, import_resolve.resolvePkg)(name, {basedir: process.cwd()}) || await (0, import_resolve.resolvePkg)(name, {basedir: target});
    if (!packageDir) {
      const pkg2 = await (0, import_read_pkg_up.default)({
        cwd: target
      });
      if (pkg2 && pkg2.packageJson.name === name) {
        packageDir = import_path4.default.dirname(pkg2.path);
      }
    }
    if (!packageDir && import_fs2.default.existsSync(import_path4.default.join(process.cwd(), "package.json"))) {
      packageDir = process.cwd();
    }
    if (!packageDir) {
      throw new Error(`Error in getPackage: Could not resolve package ${name} from ${__dirname}`);
    }
    const tmpDir = import_tempy.default.directory();
    const archivePath = import_path4.default.join(tmpDir, `package.tgz`);
    const isYarn = await (0, import_hasYarn.hasYarn)(packageDir);
    const packCmd = isYarn ? ["yarn", "pack", "-f", archivePath] : ["npm", "pack", packageDir];
    const escapedCmd = (0, import_shell_quote.quote)(packCmd);
    await import_execa2.default.command(escapedCmd, {
      shell: true,
      cwd: isYarn ? packageDir : tmpDir
    });
    if (!isYarn) {
      const filename = (await readdir2(tmpDir))[0];
      await rename2(import_path4.default.join(tmpDir, filename), archivePath);
    }
    await import_tar.default.extract({
      cwd: tmpDir,
      file: archivePath
    });
    await del(archivePath);
    if (target) {
      await (0, import_make_dir2.default)(target);
      await (0, import_copy.default)({
        from: import_path4.default.join(tmpDir, "package"),
        to: target,
        recursive: true,
        parallelJobs: 20,
        overwrite: true
      });
      await del(tmpDir);
    }
    return import_path4.default.join(tmpDir, "package");
  }
});

// ../sdk/dist/panic.js
var require_panic = __commonJS2((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    ErrorArea: () => ErrorArea2,
    RustPanic: () => RustPanic2
  });
  var RustPanic2 = class extends Error {
    constructor(message, rustStack, request, area, schemaPath, schema, introspectionUrl) {
      super(message);
      this.rustStack = rustStack;
      this.request = request;
      this.area = area;
      this.schemaPath = schemaPath;
      this.schema = schema;
      this.introspectionUrl = introspectionUrl;
    }
  };
  var ErrorArea2;
  (function(ErrorArea22) {
    ErrorArea22["LIFT_CLI"] = "LIFT_CLI";
    ErrorArea22["PHOTON_STUDIO"] = "PHOTON_STUDIO";
    ErrorArea22["INTROSPECTION_CLI"] = "INTROSPECTION_CLI";
  })(ErrorArea2 || (ErrorArea2 = {}));
});

// ../sdk/dist/utils/byline.js
var require_byline3 = __commonJS2((exports2, module2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    createLineStream: () => createLineStream,
    default: () => byline
  });
  var stream = require("stream");
  var util2 = require("util");
  function byline(readStream, options) {
    return module2.exports.createStream(readStream, options);
  }
  module2.exports.createStream = function(readStream, options) {
    if (readStream) {
      return createLineStream(readStream, options);
    } else {
      return new LineStream(options);
    }
  };
  function createLineStream(readStream, options) {
    if (!readStream) {
      throw new Error("expected readStream");
    }
    if (!readStream.readable) {
      throw new Error("readStream must be readable");
    }
    const ls = new LineStream(options);
    readStream.pipe(ls);
    return ls;
  }
  module2.exports.LineStream = LineStream;
  function LineStream(options) {
    stream.Transform.call(this, options);
    options = options || {};
    this._readableState.objectMode = true;
    this._lineBuffer = [];
    this._keepEmptyLines = options.keepEmptyLines || false;
    this._lastChunkEndedWithCR = false;
    this.on("pipe", function(src) {
      if (!this.encoding) {
        if (src instanceof stream.Readable) {
          this.encoding = src._readableState.encoding;
        }
      }
    });
  }
  util2.inherits(LineStream, stream.Transform);
  LineStream.prototype._transform = function(chunk, encoding, done) {
    encoding = encoding || "utf8";
    if (Buffer.isBuffer(chunk)) {
      if (encoding == "buffer") {
        chunk = chunk.toString();
        encoding = "utf8";
      } else {
        chunk = chunk.toString(encoding);
      }
    }
    this._chunkEncoding = encoding;
    const lines = chunk.split(/\r\n|\r|\n/g);
    if (this._lastChunkEndedWithCR && chunk[0] == "\n") {
      lines.shift();
    }
    if (this._lineBuffer.length > 0) {
      this._lineBuffer[this._lineBuffer.length - 1] += lines[0];
      lines.shift();
    }
    this._lastChunkEndedWithCR = chunk[chunk.length - 1] == "\r";
    this._lineBuffer = this._lineBuffer.concat(lines);
    this._pushBuffer(encoding, 1, done);
  };
  LineStream.prototype._pushBuffer = function(encoding, keep, done) {
    while (this._lineBuffer.length > keep) {
      const line = this._lineBuffer.shift();
      if (this._keepEmptyLines || line.length > 0) {
        if (!this.push(this._reencode(line, encoding))) {
          const self2 = this;
          setImmediate(function() {
            self2._pushBuffer(encoding, keep, done);
          });
          return;
        }
      }
    }
    done();
  };
  LineStream.prototype._flush = function(done) {
    this._pushBuffer(this._chunkEncoding, 0, done);
  };
  LineStream.prototype._reencode = function(line, chunkEncoding) {
    if (this.encoding && this.encoding != chunkEncoding) {
      return Buffer.from(line, chunkEncoding).toString(this.encoding);
    } else if (this.encoding) {
      return line;
    } else {
      return Buffer.from(line, chunkEncoding);
    }
  };
});

// ../sdk/dist/IntrospectionEngine.js
var require_IntrospectionEngine = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    IntrospectionEngine: () => IntrospectionEngine2,
    IntrospectionError: () => IntrospectionError,
    IntrospectionPanic: () => IntrospectionPanic
  });
  var import_debug3 = __toModule3(require_dist7());
  var import_fetch_engine2 = __toModule3(require_dist15());
  var import_chalk3 = __toModule3(require_source2());
  var import_child_process2 = __toModule3(require("child_process"));
  var import_panic = __toModule3(require_panic());
  var import_resolveBinary = __toModule3(require_resolveBinary());
  var import_byline2 = __toModule3(require_byline3());
  var debugCli = (0, import_debug3.default)("prisma:introspectionEngine:cli");
  var debugRpc = (0, import_debug3.default)("prisma:introspectionEngine:rpc");
  var debugStderr = (0, import_debug3.default)("prisma:introspectionEngine:stderr");
  var debugStdin = (0, import_debug3.default)("prisma:introspectionEngine:stdin");
  var IntrospectionPanic = class extends Error {
    constructor(message, rustStack, request) {
      super(message);
      this.rustStack = rustStack;
      this.request = request;
    }
  };
  var IntrospectionError = class extends Error {
    constructor(message, code) {
      super(message);
      this.code = code;
    }
  };
  var messageId = 1;
  var IntrospectionEngine2 = class {
    constructor({debug: debug4, cwd} = {
      debug: false,
      cwd: process.cwd()
    }) {
      this.listeners = {};
      this.messages = [];
      this.isRunning = false;
      if (debug4) {
        import_debug3.default.enable("IntrospectionEngine*");
      }
      this.debug = Boolean(debug4);
      this.cwd = cwd || process.cwd();
    }
    stop() {
      if (this.child) {
        this.child.kill();
        this.isRunning = false;
      }
    }
    rejectAll(err) {
      Object.entries(this.listeners).map(([id, listener]) => {
        listener(null, err);
        delete this.listeners[id];
      });
    }
    registerCallback(id, callback) {
      this.listeners[id] = callback;
    }
    getDatabaseDescription(schema) {
      return this.runCommand(this.getRPCPayload("getDatabaseDescription", {schema}));
    }
    getDatabaseVersion(schema) {
      return this.runCommand(this.getRPCPayload("getDatabaseVersion", {schema}));
    }
    introspect(schema, force) {
      this.lastUrl = schema;
      return this.runCommand(this.getRPCPayload("introspect", {schema, force}));
    }
    debugPanic() {
      return this.runCommand(this.getRPCPayload("debugPanic", void 0));
    }
    listDatabases(schema) {
      this.lastUrl = schema;
      return this.runCommand(this.getRPCPayload("listDatabases", {schema}));
    }
    getDatabaseMetadata(schema) {
      this.lastUrl = schema;
      return this.runCommand(this.getRPCPayload("getDatabaseMetadata", {schema}));
    }
    handleResponse(response) {
      let result;
      try {
        result = JSON.parse(response);
      } catch (e) {
        console.error(`Could not parse introspection engine response: ${response.slice(0, 200)}`);
      }
      if (result) {
        if (result.backtrace) {
          console.log(result);
        }
        if (!result.id) {
          console.error(`Response ${JSON.stringify(result)} doesn't have an id and I can't handle that (yet)`);
        }
        if (!this.listeners[result.id]) {
          console.error(`Got result for unknown id ${result.id}`);
        }
        if (this.listeners[result.id]) {
          this.listeners[result.id](result);
          delete this.listeners[result.id];
        }
      }
    }
    init() {
      if (!this.initPromise) {
        this.initPromise = this.internalInit();
      }
      return this.initPromise;
    }
    internalInit() {
      return new Promise(async (resolve, reject) => {
        var _a, _b;
        try {
          const binaryPath = await (0, import_resolveBinary.resolveBinary)(import_fetch_engine2.BinaryType.introspectionEngine);
          debugRpc("starting introspection engine with binary: " + binaryPath);
          this.child = (0, import_child_process2.spawn)(binaryPath, {
            env: process.env,
            cwd: this.cwd,
            stdio: ["pipe", "pipe", "pipe"]
          });
          this.isRunning = true;
          this.child.on("error", (err) => {
            var _a2;
            console.error("[introspection-engine] error: %s", err);
            (_a2 = this.child) == null ? void 0 : _a2.kill();
            this.rejectAll(err);
            reject(err);
          });
          (_a = this.child.stdin) == null ? void 0 : _a.on("error", (err) => {
            var _a2;
            console.error(err);
            (_a2 = this.child) == null ? void 0 : _a2.kill();
          });
          this.child.on("exit", (code) => {
            this.isRunning = false;
            if (code === 255 && this.lastError && this.lastError.is_panic) {
              const err2 = new import_panic.RustPanic(this.lastError.message, this.lastError.backtrace, this.lastRequest, import_panic.ErrorArea.INTROSPECTION_CLI, void 0, this.lastUrl);
              this.rejectAll(err2);
              reject(err2);
              return;
            }
            const messages = this.messages.join("\n");
            let err;
            if (code !== 0 || messages.includes("panicked at")) {
              let errorMessage = import_chalk3.default.red.bold("Error in introspection engine: ") + messages;
              if (this.lastError && this.lastError.msg === "PANIC") {
                errorMessage = serializePanic(this.lastError);
                err = new IntrospectionPanic(errorMessage, messages, this.lastRequest);
              } else if (messages.includes("panicked at")) {
                err = new IntrospectionPanic(errorMessage, messages, this.lastRequest);
              }
              err = err || new Error(errorMessage);
              this.rejectAll(err);
              reject(err);
            }
          });
          this.child.stdin.on("error", (err) => {
            debugStdin(err);
          });
          (0, import_byline2.default)(this.child.stderr).on("data", (data) => {
            const msg = String(data);
            this.messages.push(msg);
            debugStderr(msg);
            try {
              const json = JSON.parse(msg);
              if (json.backtrace) {
                this.lastError = json;
              }
              if (json.level === "ERRO") {
                this.lastError = json;
              }
            } catch (e) {
              debugCli(e);
            }
          });
          (0, import_byline2.default)(this.child.stdout).on("data", (line) => {
            this.handleResponse(String(line));
          });
          setImmediate(() => {
            resolve();
          });
        } catch (e) {
          (_b = this.child) == null ? void 0 : _b.kill();
          reject(e);
        }
      });
    }
    async runCommand(request) {
      var _a;
      await this.init();
      if (process.env.FORCE_PANIC_INTROSPECTION_ENGINE) {
        request = this.getRPCPayload("debugPanic", void 0);
      }
      if ((_a = this.child) == null ? void 0 : _a.killed) {
        throw new Error(`Can't execute ${JSON.stringify(request)} because introspection engine already exited.`);
      }
      return new Promise((resolve, reject) => {
        this.registerCallback(request.id, (response, err) => {
          var _a2, _b, _c, _d, _e, _f, _g;
          if (err) {
            return reject(err);
          }
          if (typeof response.result !== "undefined") {
            resolve(response.result);
          } else {
            if (response.error) {
              (_a2 = this.child) == null ? void 0 : _a2.kill();
              debugRpc(response);
              if ((_b = response.error.data) == null ? void 0 : _b.is_panic) {
                const message = (_e = (_d = (_c = response.error.data) == null ? void 0 : _c.error) == null ? void 0 : _d.message) != null ? _e : response.error.message;
                reject(new import_panic.RustPanic(message, message, request, import_panic.ErrorArea.INTROSPECTION_CLI, void 0, this.lastUrl));
              } else if ((_f = response.error.data) == null ? void 0 : _f.message) {
                let message = `${import_chalk3.default.redBright(response.error.data.message)}
`;
                if ((_g = response.error.data) == null ? void 0 : _g.error_code) {
                  message = import_chalk3.default.redBright(`${response.error.data.error_code}

`) + message;
                  reject(new IntrospectionError(message, response.error.data.error_code));
                } else {
                  reject(new Error(message));
                }
              } else {
                reject(new Error(`${import_chalk3.default.redBright("Error in RPC")}
 Request: ${JSON.stringify(request, null, 2)}
Response: ${JSON.stringify(response, null, 2)}
${response.error.message}
`));
              }
            } else {
              reject(new Error(`Got invalid RPC response without .result property: ${JSON.stringify(response)}`));
            }
          }
        });
        if (this.child.stdin.destroyed) {
          throw new Error(`Can't execute ${JSON.stringify(request)} because introspection engine is destroyed.`);
        }
        debugRpc("SENDING RPC CALL", JSON.stringify(request));
        this.child.stdin.write(JSON.stringify(request) + "\n");
        this.lastRequest = request;
      });
    }
    getRPCPayload(method, params) {
      return {
        id: messageId++,
        jsonrpc: "2.0",
        method,
        params: params ? [{...params}] : void 0
      };
    }
  };
  function serializePanic(log3) {
    return `${import_chalk3.default.red.bold("Error in introspection engine.\nReason: ")}${import_chalk3.default.red(`${log3.reason} in ${import_chalk3.default.underline(`${log3.file}:${log3.line}:${log3.column}`)}`)}

Please create an issue in the ${import_chalk3.default.bold("prisma")} repo with the error \u{1F64F}:
${import_chalk3.default.underline("https://github.com/prisma/prisma/issues/new")}
`;
  }
});

// ../../node_modules/.pnpm/ci-info@3.2.0/node_modules/ci-info/vendors.json
var require_vendors = __commonJS2((exports2, module2) => {
  module2.exports = [
    {
      name: "AppVeyor",
      constant: "APPVEYOR",
      env: "APPVEYOR",
      pr: "APPVEYOR_PULL_REQUEST_NUMBER"
    },
    {
      name: "Azure Pipelines",
      constant: "AZURE_PIPELINES",
      env: "SYSTEM_TEAMFOUNDATIONCOLLECTIONURI",
      pr: "SYSTEM_PULLREQUEST_PULLREQUESTID"
    },
    {
      name: "Appcircle",
      constant: "APPCIRCLE",
      env: "AC_APPCIRCLE"
    },
    {
      name: "Bamboo",
      constant: "BAMBOO",
      env: "bamboo_planKey"
    },
    {
      name: "Bitbucket Pipelines",
      constant: "BITBUCKET",
      env: "BITBUCKET_COMMIT",
      pr: "BITBUCKET_PR_ID"
    },
    {
      name: "Bitrise",
      constant: "BITRISE",
      env: "BITRISE_IO",
      pr: "BITRISE_PULL_REQUEST"
    },
    {
      name: "Buddy",
      constant: "BUDDY",
      env: "BUDDY_WORKSPACE_ID",
      pr: "BUDDY_EXECUTION_PULL_REQUEST_ID"
    },
    {
      name: "Buildkite",
      constant: "BUILDKITE",
      env: "BUILDKITE",
      pr: {env: "BUILDKITE_PULL_REQUEST", ne: "false"}
    },
    {
      name: "CircleCI",
      constant: "CIRCLE",
      env: "CIRCLECI",
      pr: "CIRCLE_PULL_REQUEST"
    },
    {
      name: "Cirrus CI",
      constant: "CIRRUS",
      env: "CIRRUS_CI",
      pr: "CIRRUS_PR"
    },
    {
      name: "AWS CodeBuild",
      constant: "CODEBUILD",
      env: "CODEBUILD_BUILD_ARN"
    },
    {
      name: "Codefresh",
      constant: "CODEFRESH",
      env: "CF_BUILD_ID",
      pr: {any: ["CF_PULL_REQUEST_NUMBER", "CF_PULL_REQUEST_ID"]}
    },
    {
      name: "Codeship",
      constant: "CODESHIP",
      env: {CI_NAME: "codeship"}
    },
    {
      name: "Drone",
      constant: "DRONE",
      env: "DRONE",
      pr: {DRONE_BUILD_EVENT: "pull_request"}
    },
    {
      name: "dsari",
      constant: "DSARI",
      env: "DSARI"
    },
    {
      name: "GitHub Actions",
      constant: "GITHUB_ACTIONS",
      env: "GITHUB_ACTIONS",
      pr: {GITHUB_EVENT_NAME: "pull_request"}
    },
    {
      name: "GitLab CI",
      constant: "GITLAB",
      env: "GITLAB_CI",
      pr: "CI_MERGE_REQUEST_ID"
    },
    {
      name: "GoCD",
      constant: "GOCD",
      env: "GO_PIPELINE_LABEL"
    },
    {
      name: "LayerCI",
      constant: "LAYERCI",
      env: "LAYERCI",
      pr: "LAYERCI_PULL_REQUEST"
    },
    {
      name: "Hudson",
      constant: "HUDSON",
      env: "HUDSON_URL"
    },
    {
      name: "Jenkins",
      constant: "JENKINS",
      env: ["JENKINS_URL", "BUILD_ID"],
      pr: {any: ["ghprbPullId", "CHANGE_ID"]}
    },
    {
      name: "Magnum CI",
      constant: "MAGNUM",
      env: "MAGNUM"
    },
    {
      name: "Netlify CI",
      constant: "NETLIFY",
      env: "NETLIFY",
      pr: {env: "PULL_REQUEST", ne: "false"}
    },
    {
      name: "Nevercode",
      constant: "NEVERCODE",
      env: "NEVERCODE",
      pr: {env: "NEVERCODE_PULL_REQUEST", ne: "false"}
    },
    {
      name: "Render",
      constant: "RENDER",
      env: "RENDER",
      pr: {IS_PULL_REQUEST: "true"}
    },
    {
      name: "Sail CI",
      constant: "SAIL",
      env: "SAILCI",
      pr: "SAIL_PULL_REQUEST_NUMBER"
    },
    {
      name: "Semaphore",
      constant: "SEMAPHORE",
      env: "SEMAPHORE",
      pr: "PULL_REQUEST_NUMBER"
    },
    {
      name: "Screwdriver",
      constant: "SCREWDRIVER",
      env: "SCREWDRIVER",
      pr: {env: "SD_PULL_REQUEST", ne: "false"}
    },
    {
      name: "Shippable",
      constant: "SHIPPABLE",
      env: "SHIPPABLE",
      pr: {IS_PULL_REQUEST: "true"}
    },
    {
      name: "Solano CI",
      constant: "SOLANO",
      env: "TDDIUM",
      pr: "TDDIUM_PR_ID"
    },
    {
      name: "Strider CD",
      constant: "STRIDER",
      env: "STRIDER"
    },
    {
      name: "TaskCluster",
      constant: "TASKCLUSTER",
      env: ["TASK_ID", "RUN_ID"]
    },
    {
      name: "TeamCity",
      constant: "TEAMCITY",
      env: "TEAMCITY_VERSION"
    },
    {
      name: "Travis CI",
      constant: "TRAVIS",
      env: "TRAVIS",
      pr: {env: "TRAVIS_PULL_REQUEST", ne: "false"}
    },
    {
      name: "Vercel",
      constant: "VERCEL",
      env: "NOW_BUILDER"
    },
    {
      name: "Visual Studio App Center",
      constant: "APPCENTER",
      env: "APPCENTER_BUILD_ID"
    }
  ];
});

// ../../node_modules/.pnpm/ci-info@3.2.0/node_modules/ci-info/index.js
var require_ci_info = __commonJS2((exports2) => {
  "use strict";
  var vendors = require_vendors();
  var env2 = process.env;
  Object.defineProperty(exports2, "_vendors", {
    value: vendors.map(function(v) {
      return v.constant;
    })
  });
  exports2.name = null;
  exports2.isPR = null;
  vendors.forEach(function(vendor) {
    const envs = Array.isArray(vendor.env) ? vendor.env : [vendor.env];
    const isCI = envs.every(function(obj) {
      return checkEnv(obj);
    });
    exports2[vendor.constant] = isCI;
    if (isCI) {
      exports2.name = vendor.name;
      switch (typeof vendor.pr) {
        case "string":
          exports2.isPR = !!env2[vendor.pr];
          break;
        case "object":
          if ("env" in vendor.pr) {
            exports2.isPR = vendor.pr.env in env2 && env2[vendor.pr.env] !== vendor.pr.ne;
          } else if ("any" in vendor.pr) {
            exports2.isPR = vendor.pr.any.some(function(key) {
              return !!env2[key];
            });
          } else {
            exports2.isPR = checkEnv(vendor.pr);
          }
          break;
        default:
          exports2.isPR = null;
      }
    }
  });
  exports2.isCI = !!(env2.CI || env2.CONTINUOUS_INTEGRATION || env2.BUILD_NUMBER || env2.RUN_ID || exports2.name || false);
  function checkEnv(obj) {
    if (typeof obj === "string")
      return !!env2[obj];
    return Object.keys(obj).every(function(k) {
      return env2[k] === obj[k];
    });
  }
});

// ../../node_modules/.pnpm/is-ci@3.0.0/node_modules/is-ci/index.js
var require_is_ci = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = require_ci_info().isCI;
});

// ../sdk/dist/isCi.js
var require_isCi = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    isCi: () => isCi2
  });
  var import_is_ci = __toModule3(require_is_ci());
  var isCi2 = () => {
    return !process.stdout.isTTY || import_is_ci.isCi || Boolean(process.env.GITHUB_ACTIONS);
  };
});

// ../sdk/dist/keyBy.js
var require_keyBy = __commonJS2((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    keyBy: () => keyBy3
  });
  var keyBy3 = (collection, iteratee) => {
    return collection.reduce((acc, curr) => {
      acc[iteratee(curr)] = curr;
      return acc;
    }, {});
  };
});

// ../sdk/dist/logger.js
var require_logger = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    error: () => error,
    info: () => info,
    log: () => log3,
    query: () => query,
    should: () => should,
    tags: () => tags,
    warn: () => warn
  });
  var import_chalk3 = __toModule3(require_source2());
  var tags = {
    error: import_chalk3.default.red("prisma:error"),
    warn: import_chalk3.default.yellow("prisma:warn"),
    info: import_chalk3.default.cyan("prisma:info"),
    query: import_chalk3.default.blue("prisma:query")
  };
  var should = {
    warn: !process.env.PRISMA_DISABLE_WARNINGS
  };
  function log3(...data) {
    console.log(...data);
  }
  function warn(message, ...optionalParams) {
    if (should.warn) {
      console.warn(`${tags.warn} ${message}`, ...optionalParams);
    }
  }
  function info(message, ...optionalParams) {
    console.info(`${tags.info} ${message}`, ...optionalParams);
  }
  function error(message, ...optionalParams) {
    console.error(`${tags.error} ${message}`, ...optionalParams);
  }
  function query(message, ...optionalParams) {
    console.log(`${tags.query} ${message}`, ...optionalParams);
  }
});

// ../sdk/dist/migrateEngineCommands.js
var require_migrateEngineCommands = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    MigrateEngineExitCode: () => MigrateEngineExitCode2,
    canConnectToDatabase: () => canConnectToDatabase2,
    createDatabase: () => createDatabase2,
    doesSqliteDbExist: () => doesSqliteDbExist,
    dropDatabase: () => dropDatabase2,
    execaCommand: () => execaCommand
  });
  var import_fetch_engine2 = __toModule3(require_dist15());
  var import_execa2 = __toModule3(require_execa2());
  var import_fs2 = __toModule3(require("fs"));
  var import_path4 = __toModule3(require("path"));
  var import_util3 = __toModule3(require("util"));
  var import_getSchema = __toModule3(require_getSchema());
  var import_convertCredentials = __toModule3(require_convertCredentials());
  var import_resolveBinary = __toModule3(require_resolveBinary());
  var exists2 = (0, import_util3.promisify)(import_fs2.default.exists);
  var MigrateEngineExitCode2;
  (function(MigrateEngineExitCode22) {
    MigrateEngineExitCode22[MigrateEngineExitCode22["Success"] = 0] = "Success";
    MigrateEngineExitCode22[MigrateEngineExitCode22["Error"] = 1] = "Error";
    MigrateEngineExitCode22[MigrateEngineExitCode22["Panic"] = 101] = "Panic";
  })(MigrateEngineExitCode2 || (MigrateEngineExitCode2 = {}));
  function parseJsonFromStderr(stderr) {
    const lines = stderr.split(/\r?\n/).slice(1);
    const logs = [];
    for (const line of lines) {
      const data = String(line);
      try {
        const json = JSON.parse(data);
        logs.push(json);
      } catch (e) {
        throw new Error(`Could not parse migration engine response: ${e}`);
      }
    }
    return logs;
  }
  async function canConnectToDatabase2(connectionString, cwd = process.cwd(), migrationEnginePath) {
    if (!connectionString) {
      throw new Error("Connection url is empty. See https://www.prisma.io/docs/reference/database-reference/connection-urls");
    }
    const provider = (0, import_convertCredentials.protocolToConnectorType)(`${connectionString.split(":")[0]}:`);
    if (provider === "sqlite") {
      const sqliteExists = await doesSqliteDbExist(connectionString, cwd);
      if (sqliteExists) {
        return true;
      } else {
        return {
          code: "P1003",
          message: "SQLite database file doesn't exist"
        };
      }
    }
    try {
      await execaCommand({
        connectionString,
        cwd,
        migrationEnginePath,
        engineCommandName: "can-connect-to-database"
      });
    } catch (e) {
      if (e.stderr) {
        const logs = parseJsonFromStderr(e.stderr);
        const error = logs.find((it) => it.level === "ERROR" && it.target === "migration_engine::logger");
        if (error && error.fields.error_code && error.fields.message) {
          return {
            code: error.fields.error_code,
            message: error.fields.message
          };
        } else {
          throw new Error(`Migration engine error:
${logs.map((log3) => log3.fields.message).join("\n")}`);
        }
      } else {
        throw new Error(`Migration engine exited.`);
      }
    }
    return true;
  }
  async function createDatabase2(connectionString, cwd = process.cwd(), migrationEnginePath) {
    const dbExists = await canConnectToDatabase2(connectionString, cwd, migrationEnginePath);
    if (dbExists === true) {
      return false;
    }
    try {
      await execaCommand({
        connectionString,
        cwd,
        migrationEnginePath,
        engineCommandName: "create-database"
      });
      return true;
    } catch (e) {
      if (e.stderr) {
        const logs = parseJsonFromStderr(e.stderr);
        const error = logs.find((it) => it.level === "ERROR" && it.target === "migration_engine::logger");
        if (error && error.fields.error_code && error.fields.message) {
          throw new Error(`${error.fields.error_code}: ${error.fields.message}`);
        } else {
          throw new Error(`Migration engine error:
${logs.map((log3) => log3.fields.message).join("\n")}`);
        }
      } else {
        throw new Error(`Migration engine exited.`);
      }
    }
  }
  async function dropDatabase2(connectionString, cwd = process.cwd(), migrationEnginePath) {
    try {
      const result = await execaCommand({
        connectionString,
        cwd,
        migrationEnginePath,
        engineCommandName: "drop-database"
      });
      if (result && result.exitCode === 0 && result.stderr.includes("The database was successfully dropped")) {
        return true;
      } else {
        throw Error(`An error occurred during the drop: ${JSON.stringify(result, void 0, 2)}`);
      }
    } catch (e) {
      if (e.stderr) {
        const logs = parseJsonFromStderr(e.stderr);
        throw new Error(`Migration engine error:
${logs.map((log3) => log3.fields.message).join("\n")}`);
      } else {
        throw new Error(`Migration engine exited.`);
      }
    }
  }
  async function execaCommand({
    connectionString,
    cwd,
    migrationEnginePath,
    engineCommandName
  }) {
    migrationEnginePath = migrationEnginePath || await (0, import_resolveBinary.resolveBinary)(import_fetch_engine2.BinaryType.migrationEngine);
    try {
      return await (0, import_execa2.default)(migrationEnginePath, ["cli", "--datasource", connectionString, engineCommandName], {
        cwd,
        env: {
          RUST_BACKTRACE: "1",
          RUST_LOG: "info"
        }
      });
    } catch (e) {
      if (e.message) {
        e.message = e.message.replace(connectionString, "<REDACTED>");
      }
      if (e.stdout) {
        e.stdout = e.stdout.replace(connectionString, "<REDACTED>");
      }
      if (e.stderr) {
        e.stderr = e.stderr.replace(connectionString, "<REDACTED>");
      }
      throw e;
    }
  }
  async function doesSqliteDbExist(connectionString, schemaDir) {
    let filePath = connectionString;
    if (filePath.startsWith("file:")) {
      filePath = filePath.slice(5);
    } else if (filePath.startsWith("sqlite:")) {
      filePath = filePath.slice(7);
    }
    const cwd = schemaDir || await (0, import_getSchema.getSchemaDir)();
    if (!cwd) {
      throw new Error(`Could not find schema.prisma in ${process.cwd()}`);
    }
    const absoluteTarget = import_path4.default.resolve(cwd, filePath);
    return exists2(absoluteTarget);
  }
});

// ../../node_modules/.pnpm/async@3.2.0/node_modules/async/dist/async.js
var require_async12 = __commonJS2((exports2, module2) => {
  (function(global2, factory) {
    typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.async = {});
  })(exports2, function(exports3) {
    "use strict";
    function apply(fn, ...args) {
      return (...callArgs) => fn(...args, ...callArgs);
    }
    function initialParams(fn) {
      return function(...args) {
        var callback = args.pop();
        return fn.call(this, args, callback);
      };
    }
    var hasSetImmediate = typeof setImmediate === "function" && setImmediate;
    var hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
    function fallback(fn) {
      setTimeout(fn, 0);
    }
    function wrap(defer) {
      return (fn, ...args) => defer(() => fn(...args));
    }
    var _defer;
    if (hasSetImmediate) {
      _defer = setImmediate;
    } else if (hasNextTick) {
      _defer = process.nextTick;
    } else {
      _defer = fallback;
    }
    var setImmediate$1 = wrap(_defer);
    function asyncify(func) {
      if (isAsync(func)) {
        return function(...args) {
          const callback = args.pop();
          const promise = func.apply(this, args);
          return handlePromise(promise, callback);
        };
      }
      return initialParams(function(args, callback) {
        var result;
        try {
          result = func.apply(this, args);
        } catch (e) {
          return callback(e);
        }
        if (result && typeof result.then === "function") {
          return handlePromise(result, callback);
        } else {
          callback(null, result);
        }
      });
    }
    function handlePromise(promise, callback) {
      return promise.then((value) => {
        invokeCallback(callback, null, value);
      }, (err) => {
        invokeCallback(callback, err && err.message ? err : new Error(err));
      });
    }
    function invokeCallback(callback, error, value) {
      try {
        callback(error, value);
      } catch (err) {
        setImmediate$1((e) => {
          throw e;
        }, err);
      }
    }
    function isAsync(fn) {
      return fn[Symbol.toStringTag] === "AsyncFunction";
    }
    function isAsyncGenerator(fn) {
      return fn[Symbol.toStringTag] === "AsyncGenerator";
    }
    function isAsyncIterable(obj) {
      return typeof obj[Symbol.asyncIterator] === "function";
    }
    function wrapAsync(asyncFn) {
      if (typeof asyncFn !== "function")
        throw new Error("expected a function");
      return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
    }
    function awaitify(asyncFn, arity = asyncFn.length) {
      if (!arity)
        throw new Error("arity is undefined");
      function awaitable(...args) {
        if (typeof args[arity - 1] === "function") {
          return asyncFn.apply(this, args);
        }
        return new Promise((resolve, reject2) => {
          args[arity - 1] = (err, ...cbArgs) => {
            if (err)
              return reject2(err);
            resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
          };
          asyncFn.apply(this, args);
        });
      }
      return awaitable;
    }
    function applyEach(eachfn) {
      return function applyEach2(fns, ...callArgs) {
        const go = awaitify(function(callback) {
          var that = this;
          return eachfn(fns, (fn, cb) => {
            wrapAsync(fn).apply(that, callArgs.concat(cb));
          }, callback);
        });
        return go;
      };
    }
    function _asyncMap(eachfn, arr, iteratee, callback) {
      arr = arr || [];
      var results = [];
      var counter2 = 0;
      var _iteratee = wrapAsync(iteratee);
      return eachfn(arr, (value, _2, iterCb) => {
        var index2 = counter2++;
        _iteratee(value, (err, v) => {
          results[index2] = v;
          iterCb(err);
        });
      }, (err) => {
        callback(err, results);
      });
    }
    function isArrayLike(value) {
      return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
    }
    const breakLoop = {};
    function once(fn) {
      function wrapper(...args) {
        if (fn === null)
          return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
      }
      Object.assign(wrapper, fn);
      return wrapper;
    }
    function getIterator(coll) {
      return coll[Symbol.iterator] && coll[Symbol.iterator]();
    }
    function createArrayIterator(coll) {
      var i = -1;
      var len = coll.length;
      return function next() {
        return ++i < len ? {value: coll[i], key: i} : null;
      };
    }
    function createES2015Iterator(iterator) {
      var i = -1;
      return function next() {
        var item = iterator.next();
        if (item.done)
          return null;
        i++;
        return {value: item.value, key: i};
      };
    }
    function createObjectIterator(obj) {
      var okeys = obj ? Object.keys(obj) : [];
      var i = -1;
      var len = okeys.length;
      return function next() {
        var key = okeys[++i];
        return i < len ? {value: obj[key], key} : null;
      };
    }
    function createIterator(coll) {
      if (isArrayLike(coll)) {
        return createArrayIterator(coll);
      }
      var iterator = getIterator(coll);
      return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
    }
    function onlyOnce(fn) {
      return function(...args) {
        if (fn === null)
          throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
      };
    }
    function asyncEachOfLimit(generator, limit, iteratee, callback) {
      let done = false;
      let canceled = false;
      let awaiting = false;
      let running = 0;
      let idx = 0;
      function replenish() {
        if (running >= limit || awaiting || done)
          return;
        awaiting = true;
        generator.next().then(({value, done: iterDone}) => {
          if (canceled || done)
            return;
          awaiting = false;
          if (iterDone) {
            done = true;
            if (running <= 0) {
              callback(null);
            }
            return;
          }
          running++;
          iteratee(value, idx, iterateeCallback);
          idx++;
          replenish();
        }).catch(handleError);
      }
      function iterateeCallback(err, result) {
        running -= 1;
        if (canceled)
          return;
        if (err)
          return handleError(err);
        if (err === false) {
          done = true;
          canceled = true;
          return;
        }
        if (result === breakLoop || done && running <= 0) {
          done = true;
          return callback(null);
        }
        replenish();
      }
      function handleError(err) {
        if (canceled)
          return;
        awaiting = false;
        done = true;
        callback(err);
      }
      replenish();
    }
    var eachOfLimit = (limit) => {
      return (obj, iteratee, callback) => {
        callback = once(callback);
        if (limit <= 0) {
          throw new RangeError("concurrency limit cannot be less than 1");
        }
        if (!obj) {
          return callback(null);
        }
        if (isAsyncGenerator(obj)) {
          return asyncEachOfLimit(obj, limit, iteratee, callback);
        }
        if (isAsyncIterable(obj)) {
          return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit, iteratee, callback);
        }
        var nextElem = createIterator(obj);
        var done = false;
        var canceled = false;
        var running = 0;
        var looping = false;
        function iterateeCallback(err, value) {
          if (canceled)
            return;
          running -= 1;
          if (err) {
            done = true;
            callback(err);
          } else if (err === false) {
            done = true;
            canceled = true;
          } else if (value === breakLoop || done && running <= 0) {
            done = true;
            return callback(null);
          } else if (!looping) {
            replenish();
          }
        }
        function replenish() {
          looping = true;
          while (running < limit && !done) {
            var elem = nextElem();
            if (elem === null) {
              done = true;
              if (running <= 0) {
                callback(null);
              }
              return;
            }
            running += 1;
            iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
          }
          looping = false;
        }
        replenish();
      };
    };
    function eachOfLimit$1(coll, limit, iteratee, callback) {
      return eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);
    }
    var eachOfLimit$2 = awaitify(eachOfLimit$1, 4);
    function eachOfArrayLike(coll, iteratee, callback) {
      callback = once(callback);
      var index2 = 0, completed = 0, {length} = coll, canceled = false;
      if (length === 0) {
        callback(null);
      }
      function iteratorCallback(err, value) {
        if (err === false) {
          canceled = true;
        }
        if (canceled === true)
          return;
        if (err) {
          callback(err);
        } else if (++completed === length || value === breakLoop) {
          callback(null);
        }
      }
      for (; index2 < length; index2++) {
        iteratee(coll[index2], index2, onlyOnce(iteratorCallback));
      }
    }
    function eachOfGeneric(coll, iteratee, callback) {
      return eachOfLimit$2(coll, Infinity, iteratee, callback);
    }
    function eachOf(coll, iteratee, callback) {
      var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
      return eachOfImplementation(coll, wrapAsync(iteratee), callback);
    }
    var eachOf$1 = awaitify(eachOf, 3);
    function map(coll, iteratee, callback) {
      return _asyncMap(eachOf$1, coll, iteratee, callback);
    }
    var map$1 = awaitify(map, 3);
    var applyEach$1 = applyEach(map$1);
    function eachOfSeries(coll, iteratee, callback) {
      return eachOfLimit$2(coll, 1, iteratee, callback);
    }
    var eachOfSeries$1 = awaitify(eachOfSeries, 3);
    function mapSeries(coll, iteratee, callback) {
      return _asyncMap(eachOfSeries$1, coll, iteratee, callback);
    }
    var mapSeries$1 = awaitify(mapSeries, 3);
    var applyEachSeries = applyEach(mapSeries$1);
    const PROMISE_SYMBOL = Symbol("promiseCallback");
    function promiseCallback() {
      let resolve, reject2;
      function callback(err, ...args) {
        if (err)
          return reject2(err);
        resolve(args.length > 1 ? args : args[0]);
      }
      callback[PROMISE_SYMBOL] = new Promise((res, rej) => {
        resolve = res, reject2 = rej;
      });
      return callback;
    }
    function auto(tasks, concurrency, callback) {
      if (typeof concurrency !== "number") {
        callback = concurrency;
        concurrency = null;
      }
      callback = once(callback || promiseCallback());
      var numTasks = Object.keys(tasks).length;
      if (!numTasks) {
        return callback(null);
      }
      if (!concurrency) {
        concurrency = numTasks;
      }
      var results = {};
      var runningTasks = 0;
      var canceled = false;
      var hasError = false;
      var listeners = Object.create(null);
      var readyTasks = [];
      var readyToCheck = [];
      var uncheckedDependencies = {};
      Object.keys(tasks).forEach((key) => {
        var task = tasks[key];
        if (!Array.isArray(task)) {
          enqueueTask(key, [task]);
          readyToCheck.push(key);
          return;
        }
        var dependencies = task.slice(0, task.length - 1);
        var remainingDependencies = dependencies.length;
        if (remainingDependencies === 0) {
          enqueueTask(key, task);
          readyToCheck.push(key);
          return;
        }
        uncheckedDependencies[key] = remainingDependencies;
        dependencies.forEach((dependencyName) => {
          if (!tasks[dependencyName]) {
            throw new Error("async.auto task `" + key + "` has a non-existent dependency `" + dependencyName + "` in " + dependencies.join(", "));
          }
          addListener(dependencyName, () => {
            remainingDependencies--;
            if (remainingDependencies === 0) {
              enqueueTask(key, task);
            }
          });
        });
      });
      checkForDeadlocks();
      processQueue();
      function enqueueTask(key, task) {
        readyTasks.push(() => runTask(key, task));
      }
      function processQueue() {
        if (canceled)
          return;
        if (readyTasks.length === 0 && runningTasks === 0) {
          return callback(null, results);
        }
        while (readyTasks.length && runningTasks < concurrency) {
          var run = readyTasks.shift();
          run();
        }
      }
      function addListener(taskName, fn) {
        var taskListeners = listeners[taskName];
        if (!taskListeners) {
          taskListeners = listeners[taskName] = [];
        }
        taskListeners.push(fn);
      }
      function taskComplete(taskName) {
        var taskListeners = listeners[taskName] || [];
        taskListeners.forEach((fn) => fn());
        processQueue();
      }
      function runTask(key, task) {
        if (hasError)
          return;
        var taskCallback = onlyOnce((err, ...result) => {
          runningTasks--;
          if (err === false) {
            canceled = true;
            return;
          }
          if (result.length < 2) {
            [result] = result;
          }
          if (err) {
            var safeResults = {};
            Object.keys(results).forEach((rkey) => {
              safeResults[rkey] = results[rkey];
            });
            safeResults[key] = result;
            hasError = true;
            listeners = Object.create(null);
            if (canceled)
              return;
            callback(err, safeResults);
          } else {
            results[key] = result;
            taskComplete(key);
          }
        });
        runningTasks++;
        var taskFn = wrapAsync(task[task.length - 1]);
        if (task.length > 1) {
          taskFn(results, taskCallback);
        } else {
          taskFn(taskCallback);
        }
      }
      function checkForDeadlocks() {
        var currentTask;
        var counter2 = 0;
        while (readyToCheck.length) {
          currentTask = readyToCheck.pop();
          counter2++;
          getDependents(currentTask).forEach((dependent) => {
            if (--uncheckedDependencies[dependent] === 0) {
              readyToCheck.push(dependent);
            }
          });
        }
        if (counter2 !== numTasks) {
          throw new Error("async.auto cannot execute tasks due to a recursive dependency");
        }
      }
      function getDependents(taskName) {
        var result = [];
        Object.keys(tasks).forEach((key) => {
          const task = tasks[key];
          if (Array.isArray(task) && task.indexOf(taskName) >= 0) {
            result.push(key);
          }
        });
        return result;
      }
      return callback[PROMISE_SYMBOL];
    }
    var FN_ARGS = /^(?:async\s+)?(?:function)?\s*\w*\s*\(\s*([^)]+)\s*\)(?:\s*{)/;
    var ARROW_FN_ARGS = /^(?:async\s+)?\(?\s*([^)=]+)\s*\)?(?:\s*=>)/;
    var FN_ARG_SPLIT = /,/;
    var FN_ARG = /(=.+)?(\s*)$/;
    var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
    function parseParams(func) {
      const src = func.toString().replace(STRIP_COMMENTS, "");
      let match = src.match(FN_ARGS);
      if (!match) {
        match = src.match(ARROW_FN_ARGS);
      }
      if (!match)
        throw new Error("could not parse args in autoInject\nSource:\n" + src);
      let [, args] = match;
      return args.replace(/\s/g, "").split(FN_ARG_SPLIT).map((arg2) => arg2.replace(FN_ARG, "").trim());
    }
    function autoInject(tasks, callback) {
      var newTasks = {};
      Object.keys(tasks).forEach((key) => {
        var taskFn = tasks[key];
        var params;
        var fnIsAsync = isAsync(taskFn);
        var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;
        if (Array.isArray(taskFn)) {
          params = [...taskFn];
          taskFn = params.pop();
          newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
        } else if (hasNoDeps) {
          newTasks[key] = taskFn;
        } else {
          params = parseParams(taskFn);
          if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {
            throw new Error("autoInject task functions require explicit parameters.");
          }
          if (!fnIsAsync)
            params.pop();
          newTasks[key] = params.concat(newTask);
        }
        function newTask(results, taskCb) {
          var newArgs = params.map((name) => results[name]);
          newArgs.push(taskCb);
          wrapAsync(taskFn)(...newArgs);
        }
      });
      return auto(newTasks, callback);
    }
    class DLL {
      constructor() {
        this.head = this.tail = null;
        this.length = 0;
      }
      removeLink(node) {
        if (node.prev)
          node.prev.next = node.next;
        else
          this.head = node.next;
        if (node.next)
          node.next.prev = node.prev;
        else
          this.tail = node.prev;
        node.prev = node.next = null;
        this.length -= 1;
        return node;
      }
      empty() {
        while (this.head)
          this.shift();
        return this;
      }
      insertAfter(node, newNode) {
        newNode.prev = node;
        newNode.next = node.next;
        if (node.next)
          node.next.prev = newNode;
        else
          this.tail = newNode;
        node.next = newNode;
        this.length += 1;
      }
      insertBefore(node, newNode) {
        newNode.prev = node.prev;
        newNode.next = node;
        if (node.prev)
          node.prev.next = newNode;
        else
          this.head = newNode;
        node.prev = newNode;
        this.length += 1;
      }
      unshift(node) {
        if (this.head)
          this.insertBefore(this.head, node);
        else
          setInitial(this, node);
      }
      push(node) {
        if (this.tail)
          this.insertAfter(this.tail, node);
        else
          setInitial(this, node);
      }
      shift() {
        return this.head && this.removeLink(this.head);
      }
      pop() {
        return this.tail && this.removeLink(this.tail);
      }
      toArray() {
        return [...this];
      }
      *[Symbol.iterator]() {
        var cur = this.head;
        while (cur) {
          yield cur.data;
          cur = cur.next;
        }
      }
      remove(testFn) {
        var curr = this.head;
        while (curr) {
          var {next} = curr;
          if (testFn(curr)) {
            this.removeLink(curr);
          }
          curr = next;
        }
        return this;
      }
    }
    function setInitial(dll, node) {
      dll.length = 1;
      dll.head = dll.tail = node;
    }
    function queue(worker, concurrency, payload) {
      if (concurrency == null) {
        concurrency = 1;
      } else if (concurrency === 0) {
        throw new RangeError("Concurrency must not be zero");
      }
      var _worker = wrapAsync(worker);
      var numRunning = 0;
      var workersList = [];
      const events = {
        error: [],
        drain: [],
        saturated: [],
        unsaturated: [],
        empty: []
      };
      function on(event, handler) {
        events[event].push(handler);
      }
      function once2(event, handler) {
        const handleAndRemove = (...args) => {
          off(event, handleAndRemove);
          handler(...args);
        };
        events[event].push(handleAndRemove);
      }
      function off(event, handler) {
        if (!event)
          return Object.keys(events).forEach((ev) => events[ev] = []);
        if (!handler)
          return events[event] = [];
        events[event] = events[event].filter((ev) => ev !== handler);
      }
      function trigger(event, ...args) {
        events[event].forEach((handler) => handler(...args));
      }
      var processingScheduled = false;
      function _insert(data, insertAtFront, rejectOnError, callback) {
        if (callback != null && typeof callback !== "function") {
          throw new Error("task callback must be a function");
        }
        q.started = true;
        var res, rej;
        function promiseCallback2(err, ...args) {
          if (err)
            return rejectOnError ? rej(err) : res();
          if (args.length <= 1)
            return res(args[0]);
          res(args);
        }
        var item = {
          data,
          callback: rejectOnError ? promiseCallback2 : callback || promiseCallback2
        };
        if (insertAtFront) {
          q._tasks.unshift(item);
        } else {
          q._tasks.push(item);
        }
        if (!processingScheduled) {
          processingScheduled = true;
          setImmediate$1(() => {
            processingScheduled = false;
            q.process();
          });
        }
        if (rejectOnError || !callback) {
          return new Promise((resolve, reject2) => {
            res = resolve;
            rej = reject2;
          });
        }
      }
      function _createCB(tasks) {
        return function(err, ...args) {
          numRunning -= 1;
          for (var i = 0, l = tasks.length; i < l; i++) {
            var task = tasks[i];
            var index2 = workersList.indexOf(task);
            if (index2 === 0) {
              workersList.shift();
            } else if (index2 > 0) {
              workersList.splice(index2, 1);
            }
            task.callback(err, ...args);
            if (err != null) {
              trigger("error", err, task.data);
            }
          }
          if (numRunning <= q.concurrency - q.buffer) {
            trigger("unsaturated");
          }
          if (q.idle()) {
            trigger("drain");
          }
          q.process();
        };
      }
      function _maybeDrain(data) {
        if (data.length === 0 && q.idle()) {
          setImmediate$1(() => trigger("drain"));
          return true;
        }
        return false;
      }
      const eventMethod = (name) => (handler) => {
        if (!handler) {
          return new Promise((resolve, reject2) => {
            once2(name, (err, data) => {
              if (err)
                return reject2(err);
              resolve(data);
            });
          });
        }
        off(name);
        on(name, handler);
      };
      var isProcessing = false;
      var q = {
        _tasks: new DLL(),
        *[Symbol.iterator]() {
          yield* q._tasks[Symbol.iterator]();
        },
        concurrency,
        payload,
        buffer: concurrency / 4,
        started: false,
        paused: false,
        push(data, callback) {
          if (Array.isArray(data)) {
            if (_maybeDrain(data))
              return;
            return data.map((datum) => _insert(datum, false, false, callback));
          }
          return _insert(data, false, false, callback);
        },
        pushAsync(data, callback) {
          if (Array.isArray(data)) {
            if (_maybeDrain(data))
              return;
            return data.map((datum) => _insert(datum, false, true, callback));
          }
          return _insert(data, false, true, callback);
        },
        kill() {
          off();
          q._tasks.empty();
        },
        unshift(data, callback) {
          if (Array.isArray(data)) {
            if (_maybeDrain(data))
              return;
            return data.map((datum) => _insert(datum, true, false, callback));
          }
          return _insert(data, true, false, callback);
        },
        unshiftAsync(data, callback) {
          if (Array.isArray(data)) {
            if (_maybeDrain(data))
              return;
            return data.map((datum) => _insert(datum, true, true, callback));
          }
          return _insert(data, true, true, callback);
        },
        remove(testFn) {
          q._tasks.remove(testFn);
        },
        process() {
          if (isProcessing) {
            return;
          }
          isProcessing = true;
          while (!q.paused && numRunning < q.concurrency && q._tasks.length) {
            var tasks = [], data = [];
            var l = q._tasks.length;
            if (q.payload)
              l = Math.min(l, q.payload);
            for (var i = 0; i < l; i++) {
              var node = q._tasks.shift();
              tasks.push(node);
              workersList.push(node);
              data.push(node.data);
            }
            numRunning += 1;
            if (q._tasks.length === 0) {
              trigger("empty");
            }
            if (numRunning === q.concurrency) {
              trigger("saturated");
            }
            var cb = onlyOnce(_createCB(tasks));
            _worker(data, cb);
          }
          isProcessing = false;
        },
        length() {
          return q._tasks.length;
        },
        running() {
          return numRunning;
        },
        workersList() {
          return workersList;
        },
        idle() {
          return q._tasks.length + numRunning === 0;
        },
        pause() {
          q.paused = true;
        },
        resume() {
          if (q.paused === false) {
            return;
          }
          q.paused = false;
          setImmediate$1(q.process);
        }
      };
      Object.defineProperties(q, {
        saturated: {
          writable: false,
          value: eventMethod("saturated")
        },
        unsaturated: {
          writable: false,
          value: eventMethod("unsaturated")
        },
        empty: {
          writable: false,
          value: eventMethod("empty")
        },
        drain: {
          writable: false,
          value: eventMethod("drain")
        },
        error: {
          writable: false,
          value: eventMethod("error")
        }
      });
      return q;
    }
    function cargo(worker, payload) {
      return queue(worker, 1, payload);
    }
    function cargo$1(worker, concurrency, payload) {
      return queue(worker, concurrency, payload);
    }
    function reduce(coll, memo, iteratee, callback) {
      callback = once(callback);
      var _iteratee = wrapAsync(iteratee);
      return eachOfSeries$1(coll, (x, i, iterCb) => {
        _iteratee(memo, x, (err, v) => {
          memo = v;
          iterCb(err);
        });
      }, (err) => callback(err, memo));
    }
    var reduce$1 = awaitify(reduce, 4);
    function seq(...functions) {
      var _functions = functions.map(wrapAsync);
      return function(...args) {
        var that = this;
        var cb = args[args.length - 1];
        if (typeof cb == "function") {
          args.pop();
        } else {
          cb = promiseCallback();
        }
        reduce$1(_functions, args, (newargs, fn, iterCb) => {
          fn.apply(that, newargs.concat((err, ...nextargs) => {
            iterCb(err, nextargs);
          }));
        }, (err, results) => cb(err, ...results));
        return cb[PROMISE_SYMBOL];
      };
    }
    function compose(...args) {
      return seq(...args.reverse());
    }
    function mapLimit(coll, limit, iteratee, callback) {
      return _asyncMap(eachOfLimit(limit), coll, iteratee, callback);
    }
    var mapLimit$1 = awaitify(mapLimit, 4);
    function concatLimit(coll, limit, iteratee, callback) {
      var _iteratee = wrapAsync(iteratee);
      return mapLimit$1(coll, limit, (val, iterCb) => {
        _iteratee(val, (err, ...args) => {
          if (err)
            return iterCb(err);
          return iterCb(err, args);
        });
      }, (err, mapResults) => {
        var result = [];
        for (var i = 0; i < mapResults.length; i++) {
          if (mapResults[i]) {
            result = result.concat(...mapResults[i]);
          }
        }
        return callback(err, result);
      });
    }
    var concatLimit$1 = awaitify(concatLimit, 4);
    function concat(coll, iteratee, callback) {
      return concatLimit$1(coll, Infinity, iteratee, callback);
    }
    var concat$1 = awaitify(concat, 3);
    function concatSeries(coll, iteratee, callback) {
      return concatLimit$1(coll, 1, iteratee, callback);
    }
    var concatSeries$1 = awaitify(concatSeries, 3);
    function constant(...args) {
      return function(...ignoredArgs) {
        var callback = ignoredArgs.pop();
        return callback(null, ...args);
      };
    }
    function _createTester(check2, getResult) {
      return (eachfn, arr, _iteratee, cb) => {
        var testPassed = false;
        var testResult;
        const iteratee = wrapAsync(_iteratee);
        eachfn(arr, (value, _2, callback) => {
          iteratee(value, (err, result) => {
            if (err || err === false)
              return callback(err);
            if (check2(result) && !testResult) {
              testPassed = true;
              testResult = getResult(true, value);
              return callback(null, breakLoop);
            }
            callback();
          });
        }, (err) => {
          if (err)
            return cb(err);
          cb(null, testPassed ? testResult : getResult(false));
        });
      };
    }
    function detect(coll, iteratee, callback) {
      return _createTester((bool) => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback);
    }
    var detect$1 = awaitify(detect, 3);
    function detectLimit(coll, limit, iteratee, callback) {
      return _createTester((bool) => bool, (res, item) => item)(eachOfLimit(limit), coll, iteratee, callback);
    }
    var detectLimit$1 = awaitify(detectLimit, 4);
    function detectSeries(coll, iteratee, callback) {
      return _createTester((bool) => bool, (res, item) => item)(eachOfLimit(1), coll, iteratee, callback);
    }
    var detectSeries$1 = awaitify(detectSeries, 3);
    function consoleFunc(name) {
      return (fn, ...args) => wrapAsync(fn)(...args, (err, ...resultArgs) => {
        if (typeof console === "object") {
          if (err) {
            if (console.error) {
              console.error(err);
            }
          } else if (console[name]) {
            resultArgs.forEach((x) => console[name](x));
          }
        }
      });
    }
    var dir = consoleFunc("dir");
    function doWhilst(iteratee, test, callback) {
      callback = onlyOnce(callback);
      var _fn = wrapAsync(iteratee);
      var _test = wrapAsync(test);
      var results;
      function next(err, ...args) {
        if (err)
          return callback(err);
        if (err === false)
          return;
        results = args;
        _test(...args, check2);
      }
      function check2(err, truth) {
        if (err)
          return callback(err);
        if (err === false)
          return;
        if (!truth)
          return callback(null, ...results);
        _fn(next);
      }
      return check2(null, true);
    }
    var doWhilst$1 = awaitify(doWhilst, 3);
    function doUntil(iteratee, test, callback) {
      const _test = wrapAsync(test);
      return doWhilst$1(iteratee, (...args) => {
        const cb = args.pop();
        _test(...args, (err, truth) => cb(err, !truth));
      }, callback);
    }
    function _withoutIndex(iteratee) {
      return (value, index2, callback) => iteratee(value, callback);
    }
    function eachLimit(coll, iteratee, callback) {
      return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);
    }
    var each = awaitify(eachLimit, 3);
    function eachLimit$1(coll, limit, iteratee, callback) {
      return eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
    }
    var eachLimit$2 = awaitify(eachLimit$1, 4);
    function eachSeries(coll, iteratee, callback) {
      return eachLimit$2(coll, 1, iteratee, callback);
    }
    var eachSeries$1 = awaitify(eachSeries, 3);
    function ensureAsync(fn) {
      if (isAsync(fn))
        return fn;
      return function(...args) {
        var callback = args.pop();
        var sync2 = true;
        args.push((...innerArgs) => {
          if (sync2) {
            setImmediate$1(() => callback(...innerArgs));
          } else {
            callback(...innerArgs);
          }
        });
        fn.apply(this, args);
        sync2 = false;
      };
    }
    function every(coll, iteratee, callback) {
      return _createTester((bool) => !bool, (res) => !res)(eachOf$1, coll, iteratee, callback);
    }
    var every$1 = awaitify(every, 3);
    function everyLimit(coll, limit, iteratee, callback) {
      return _createTester((bool) => !bool, (res) => !res)(eachOfLimit(limit), coll, iteratee, callback);
    }
    var everyLimit$1 = awaitify(everyLimit, 4);
    function everySeries(coll, iteratee, callback) {
      return _createTester((bool) => !bool, (res) => !res)(eachOfSeries$1, coll, iteratee, callback);
    }
    var everySeries$1 = awaitify(everySeries, 3);
    function filterArray(eachfn, arr, iteratee, callback) {
      var truthValues = new Array(arr.length);
      eachfn(arr, (x, index2, iterCb) => {
        iteratee(x, (err, v) => {
          truthValues[index2] = !!v;
          iterCb(err);
        });
      }, (err) => {
        if (err)
          return callback(err);
        var results = [];
        for (var i = 0; i < arr.length; i++) {
          if (truthValues[i])
            results.push(arr[i]);
        }
        callback(null, results);
      });
    }
    function filterGeneric(eachfn, coll, iteratee, callback) {
      var results = [];
      eachfn(coll, (x, index2, iterCb) => {
        iteratee(x, (err, v) => {
          if (err)
            return iterCb(err);
          if (v) {
            results.push({index: index2, value: x});
          }
          iterCb(err);
        });
      }, (err) => {
        if (err)
          return callback(err);
        callback(null, results.sort((a, b) => a.index - b.index).map((v) => v.value));
      });
    }
    function _filter(eachfn, coll, iteratee, callback) {
      var filter2 = isArrayLike(coll) ? filterArray : filterGeneric;
      return filter2(eachfn, coll, wrapAsync(iteratee), callback);
    }
    function filter(coll, iteratee, callback) {
      return _filter(eachOf$1, coll, iteratee, callback);
    }
    var filter$1 = awaitify(filter, 3);
    function filterLimit(coll, limit, iteratee, callback) {
      return _filter(eachOfLimit(limit), coll, iteratee, callback);
    }
    var filterLimit$1 = awaitify(filterLimit, 4);
    function filterSeries(coll, iteratee, callback) {
      return _filter(eachOfSeries$1, coll, iteratee, callback);
    }
    var filterSeries$1 = awaitify(filterSeries, 3);
    function forever(fn, errback) {
      var done = onlyOnce(errback);
      var task = wrapAsync(ensureAsync(fn));
      function next(err) {
        if (err)
          return done(err);
        if (err === false)
          return;
        task(next);
      }
      return next();
    }
    var forever$1 = awaitify(forever, 2);
    function groupByLimit(coll, limit, iteratee, callback) {
      var _iteratee = wrapAsync(iteratee);
      return mapLimit$1(coll, limit, (val, iterCb) => {
        _iteratee(val, (err, key) => {
          if (err)
            return iterCb(err);
          return iterCb(err, {key, val});
        });
      }, (err, mapResults) => {
        var result = {};
        var {hasOwnProperty} = Object.prototype;
        for (var i = 0; i < mapResults.length; i++) {
          if (mapResults[i]) {
            var {key} = mapResults[i];
            var {val} = mapResults[i];
            if (hasOwnProperty.call(result, key)) {
              result[key].push(val);
            } else {
              result[key] = [val];
            }
          }
        }
        return callback(err, result);
      });
    }
    var groupByLimit$1 = awaitify(groupByLimit, 4);
    function groupBy(coll, iteratee, callback) {
      return groupByLimit$1(coll, Infinity, iteratee, callback);
    }
    function groupBySeries(coll, iteratee, callback) {
      return groupByLimit$1(coll, 1, iteratee, callback);
    }
    var log3 = consoleFunc("log");
    function mapValuesLimit(obj, limit, iteratee, callback) {
      callback = once(callback);
      var newObj = {};
      var _iteratee = wrapAsync(iteratee);
      return eachOfLimit(limit)(obj, (val, key, next) => {
        _iteratee(val, key, (err, result) => {
          if (err)
            return next(err);
          newObj[key] = result;
          next(err);
        });
      }, (err) => callback(err, newObj));
    }
    var mapValuesLimit$1 = awaitify(mapValuesLimit, 4);
    function mapValues(obj, iteratee, callback) {
      return mapValuesLimit$1(obj, Infinity, iteratee, callback);
    }
    function mapValuesSeries(obj, iteratee, callback) {
      return mapValuesLimit$1(obj, 1, iteratee, callback);
    }
    function memoize(fn, hasher = (v) => v) {
      var memo = Object.create(null);
      var queues = Object.create(null);
      var _fn = wrapAsync(fn);
      var memoized = initialParams((args, callback) => {
        var key = hasher(...args);
        if (key in memo) {
          setImmediate$1(() => callback(null, ...memo[key]));
        } else if (key in queues) {
          queues[key].push(callback);
        } else {
          queues[key] = [callback];
          _fn(...args, (err, ...resultArgs) => {
            if (!err) {
              memo[key] = resultArgs;
            }
            var q = queues[key];
            delete queues[key];
            for (var i = 0, l = q.length; i < l; i++) {
              q[i](err, ...resultArgs);
            }
          });
        }
      });
      memoized.memo = memo;
      memoized.unmemoized = fn;
      return memoized;
    }
    var _defer$1;
    if (hasNextTick) {
      _defer$1 = process.nextTick;
    } else if (hasSetImmediate) {
      _defer$1 = setImmediate;
    } else {
      _defer$1 = fallback;
    }
    var nextTick = wrap(_defer$1);
    var parallel = awaitify((eachfn, tasks, callback) => {
      var results = isArrayLike(tasks) ? [] : {};
      eachfn(tasks, (task, key, taskCb) => {
        wrapAsync(task)((err, ...result) => {
          if (result.length < 2) {
            [result] = result;
          }
          results[key] = result;
          taskCb(err);
        });
      }, (err) => callback(err, results));
    }, 3);
    function parallel$1(tasks, callback) {
      return parallel(eachOf$1, tasks, callback);
    }
    function parallelLimit(tasks, limit, callback) {
      return parallel(eachOfLimit(limit), tasks, callback);
    }
    function queue$1(worker, concurrency) {
      var _worker = wrapAsync(worker);
      return queue((items, cb) => {
        _worker(items[0], cb);
      }, concurrency, 1);
    }
    class Heap {
      constructor() {
        this.heap = [];
        this.pushCount = Number.MIN_SAFE_INTEGER;
      }
      get length() {
        return this.heap.length;
      }
      empty() {
        this.heap = [];
        return this;
      }
      percUp(index2) {
        let p;
        while (index2 > 0 && smaller(this.heap[index2], this.heap[p = parent(index2)])) {
          let t = this.heap[index2];
          this.heap[index2] = this.heap[p];
          this.heap[p] = t;
          index2 = p;
        }
      }
      percDown(index2) {
        let l;
        while ((l = leftChi(index2)) < this.heap.length) {
          if (l + 1 < this.heap.length && smaller(this.heap[l + 1], this.heap[l])) {
            l = l + 1;
          }
          if (smaller(this.heap[index2], this.heap[l])) {
            break;
          }
          let t = this.heap[index2];
          this.heap[index2] = this.heap[l];
          this.heap[l] = t;
          index2 = l;
        }
      }
      push(node) {
        node.pushCount = ++this.pushCount;
        this.heap.push(node);
        this.percUp(this.heap.length - 1);
      }
      unshift(node) {
        return this.heap.push(node);
      }
      shift() {
        let [top] = this.heap;
        this.heap[0] = this.heap[this.heap.length - 1];
        this.heap.pop();
        this.percDown(0);
        return top;
      }
      toArray() {
        return [...this];
      }
      *[Symbol.iterator]() {
        for (let i = 0; i < this.heap.length; i++) {
          yield this.heap[i].data;
        }
      }
      remove(testFn) {
        let j = 0;
        for (let i = 0; i < this.heap.length; i++) {
          if (!testFn(this.heap[i])) {
            this.heap[j] = this.heap[i];
            j++;
          }
        }
        this.heap.splice(j);
        for (let i = parent(this.heap.length - 1); i >= 0; i--) {
          this.percDown(i);
        }
        return this;
      }
    }
    function leftChi(i) {
      return (i << 1) + 1;
    }
    function parent(i) {
      return (i + 1 >> 1) - 1;
    }
    function smaller(x, y2) {
      if (x.priority !== y2.priority) {
        return x.priority < y2.priority;
      } else {
        return x.pushCount < y2.pushCount;
      }
    }
    function priorityQueue(worker, concurrency) {
      var q = queue$1(worker, concurrency);
      q._tasks = new Heap();
      q.push = function(data, priority = 0, callback = () => {
      }) {
        if (typeof callback !== "function") {
          throw new Error("task callback must be a function");
        }
        q.started = true;
        if (!Array.isArray(data)) {
          data = [data];
        }
        if (data.length === 0 && q.idle()) {
          return setImmediate$1(() => q.drain());
        }
        for (var i = 0, l = data.length; i < l; i++) {
          var item = {
            data: data[i],
            priority,
            callback
          };
          q._tasks.push(item);
        }
        setImmediate$1(q.process);
      };
      delete q.unshift;
      return q;
    }
    function race(tasks, callback) {
      callback = once(callback);
      if (!Array.isArray(tasks))
        return callback(new TypeError("First argument to race must be an array of functions"));
      if (!tasks.length)
        return callback();
      for (var i = 0, l = tasks.length; i < l; i++) {
        wrapAsync(tasks[i])(callback);
      }
    }
    var race$1 = awaitify(race, 2);
    function reduceRight(array, memo, iteratee, callback) {
      var reversed = [...array].reverse();
      return reduce$1(reversed, memo, iteratee, callback);
    }
    function reflect(fn) {
      var _fn = wrapAsync(fn);
      return initialParams(function reflectOn(args, reflectCallback) {
        args.push((error, ...cbArgs) => {
          let retVal = {};
          if (error) {
            retVal.error = error;
          }
          if (cbArgs.length > 0) {
            var value = cbArgs;
            if (cbArgs.length <= 1) {
              [value] = cbArgs;
            }
            retVal.value = value;
          }
          reflectCallback(null, retVal);
        });
        return _fn.apply(this, args);
      });
    }
    function reflectAll(tasks) {
      var results;
      if (Array.isArray(tasks)) {
        results = tasks.map(reflect);
      } else {
        results = {};
        Object.keys(tasks).forEach((key) => {
          results[key] = reflect.call(this, tasks[key]);
        });
      }
      return results;
    }
    function reject(eachfn, arr, _iteratee, callback) {
      const iteratee = wrapAsync(_iteratee);
      return _filter(eachfn, arr, (value, cb) => {
        iteratee(value, (err, v) => {
          cb(err, !v);
        });
      }, callback);
    }
    function reject$1(coll, iteratee, callback) {
      return reject(eachOf$1, coll, iteratee, callback);
    }
    var reject$2 = awaitify(reject$1, 3);
    function rejectLimit(coll, limit, iteratee, callback) {
      return reject(eachOfLimit(limit), coll, iteratee, callback);
    }
    var rejectLimit$1 = awaitify(rejectLimit, 4);
    function rejectSeries(coll, iteratee, callback) {
      return reject(eachOfSeries$1, coll, iteratee, callback);
    }
    var rejectSeries$1 = awaitify(rejectSeries, 3);
    function constant$1(value) {
      return function() {
        return value;
      };
    }
    const DEFAULT_TIMES = 5;
    const DEFAULT_INTERVAL = 0;
    function retry(opts, task, callback) {
      var options = {
        times: DEFAULT_TIMES,
        intervalFunc: constant$1(DEFAULT_INTERVAL)
      };
      if (arguments.length < 3 && typeof opts === "function") {
        callback = task || promiseCallback();
        task = opts;
      } else {
        parseTimes(options, opts);
        callback = callback || promiseCallback();
      }
      if (typeof task !== "function") {
        throw new Error("Invalid arguments for async.retry");
      }
      var _task = wrapAsync(task);
      var attempt = 1;
      function retryAttempt() {
        _task((err, ...args) => {
          if (err === false)
            return;
          if (err && attempt++ < options.times && (typeof options.errorFilter != "function" || options.errorFilter(err))) {
            setTimeout(retryAttempt, options.intervalFunc(attempt - 1));
          } else {
            callback(err, ...args);
          }
        });
      }
      retryAttempt();
      return callback[PROMISE_SYMBOL];
    }
    function parseTimes(acc, t) {
      if (typeof t === "object") {
        acc.times = +t.times || DEFAULT_TIMES;
        acc.intervalFunc = typeof t.interval === "function" ? t.interval : constant$1(+t.interval || DEFAULT_INTERVAL);
        acc.errorFilter = t.errorFilter;
      } else if (typeof t === "number" || typeof t === "string") {
        acc.times = +t || DEFAULT_TIMES;
      } else {
        throw new Error("Invalid arguments for async.retry");
      }
    }
    function retryable(opts, task) {
      if (!task) {
        task = opts;
        opts = null;
      }
      let arity = opts && opts.arity || task.length;
      if (isAsync(task)) {
        arity += 1;
      }
      var _task = wrapAsync(task);
      return initialParams((args, callback) => {
        if (args.length < arity - 1 || callback == null) {
          args.push(callback);
          callback = promiseCallback();
        }
        function taskFn(cb) {
          _task(...args, cb);
        }
        if (opts)
          retry(opts, taskFn, callback);
        else
          retry(taskFn, callback);
        return callback[PROMISE_SYMBOL];
      });
    }
    function series(tasks, callback) {
      return parallel(eachOfSeries$1, tasks, callback);
    }
    function some(coll, iteratee, callback) {
      return _createTester(Boolean, (res) => res)(eachOf$1, coll, iteratee, callback);
    }
    var some$1 = awaitify(some, 3);
    function someLimit(coll, limit, iteratee, callback) {
      return _createTester(Boolean, (res) => res)(eachOfLimit(limit), coll, iteratee, callback);
    }
    var someLimit$1 = awaitify(someLimit, 4);
    function someSeries(coll, iteratee, callback) {
      return _createTester(Boolean, (res) => res)(eachOfSeries$1, coll, iteratee, callback);
    }
    var someSeries$1 = awaitify(someSeries, 3);
    function sortBy(coll, iteratee, callback) {
      var _iteratee = wrapAsync(iteratee);
      return map$1(coll, (x, iterCb) => {
        _iteratee(x, (err, criteria) => {
          if (err)
            return iterCb(err);
          iterCb(err, {value: x, criteria});
        });
      }, (err, results) => {
        if (err)
          return callback(err);
        callback(null, results.sort(comparator).map((v) => v.value));
      });
      function comparator(left, right) {
        var a = left.criteria, b = right.criteria;
        return a < b ? -1 : a > b ? 1 : 0;
      }
    }
    var sortBy$1 = awaitify(sortBy, 3);
    function timeout(asyncFn, milliseconds, info) {
      var fn = wrapAsync(asyncFn);
      return initialParams((args, callback) => {
        var timedOut = false;
        var timer;
        function timeoutCallback() {
          var name = asyncFn.name || "anonymous";
          var error = new Error('Callback function "' + name + '" timed out.');
          error.code = "ETIMEDOUT";
          if (info) {
            error.info = info;
          }
          timedOut = true;
          callback(error);
        }
        args.push((...cbArgs) => {
          if (!timedOut) {
            callback(...cbArgs);
            clearTimeout(timer);
          }
        });
        timer = setTimeout(timeoutCallback, milliseconds);
        fn(...args);
      });
    }
    function range(size) {
      var result = Array(size);
      while (size--) {
        result[size] = size;
      }
      return result;
    }
    function timesLimit(count, limit, iteratee, callback) {
      var _iteratee = wrapAsync(iteratee);
      return mapLimit$1(range(count), limit, _iteratee, callback);
    }
    function times(n, iteratee, callback) {
      return timesLimit(n, Infinity, iteratee, callback);
    }
    function timesSeries(n, iteratee, callback) {
      return timesLimit(n, 1, iteratee, callback);
    }
    function transform(coll, accumulator, iteratee, callback) {
      if (arguments.length <= 3 && typeof accumulator === "function") {
        callback = iteratee;
        iteratee = accumulator;
        accumulator = Array.isArray(coll) ? [] : {};
      }
      callback = once(callback || promiseCallback());
      var _iteratee = wrapAsync(iteratee);
      eachOf$1(coll, (v, k, cb) => {
        _iteratee(accumulator, v, k, cb);
      }, (err) => callback(err, accumulator));
      return callback[PROMISE_SYMBOL];
    }
    function tryEach(tasks, callback) {
      var error = null;
      var result;
      return eachSeries$1(tasks, (task, taskCb) => {
        wrapAsync(task)((err, ...args) => {
          if (err === false)
            return taskCb(err);
          if (args.length < 2) {
            [result] = args;
          } else {
            result = args;
          }
          error = err;
          taskCb(err ? null : {});
        });
      }, () => callback(error, result));
    }
    var tryEach$1 = awaitify(tryEach);
    function unmemoize(fn) {
      return (...args) => {
        return (fn.unmemoized || fn)(...args);
      };
    }
    function whilst(test, iteratee, callback) {
      callback = onlyOnce(callback);
      var _fn = wrapAsync(iteratee);
      var _test = wrapAsync(test);
      var results = [];
      function next(err, ...rest) {
        if (err)
          return callback(err);
        results = rest;
        if (err === false)
          return;
        _test(check2);
      }
      function check2(err, truth) {
        if (err)
          return callback(err);
        if (err === false)
          return;
        if (!truth)
          return callback(null, ...results);
        _fn(next);
      }
      return _test(check2);
    }
    var whilst$1 = awaitify(whilst, 3);
    function until(test, iteratee, callback) {
      const _test = wrapAsync(test);
      return whilst$1((cb) => _test((err, truth) => cb(err, !truth)), iteratee, callback);
    }
    function waterfall(tasks, callback) {
      callback = once(callback);
      if (!Array.isArray(tasks))
        return callback(new Error("First argument to waterfall must be an array of functions"));
      if (!tasks.length)
        return callback();
      var taskIndex = 0;
      function nextTask(args) {
        var task = wrapAsync(tasks[taskIndex++]);
        task(...args, onlyOnce(next));
      }
      function next(err, ...args) {
        if (err === false)
          return;
        if (err || taskIndex === tasks.length) {
          return callback(err, ...args);
        }
        nextTask(args);
      }
      nextTask([]);
    }
    var waterfall$1 = awaitify(waterfall);
    var index = {
      apply,
      applyEach: applyEach$1,
      applyEachSeries,
      asyncify,
      auto,
      autoInject,
      cargo,
      cargoQueue: cargo$1,
      compose,
      concat: concat$1,
      concatLimit: concatLimit$1,
      concatSeries: concatSeries$1,
      constant,
      detect: detect$1,
      detectLimit: detectLimit$1,
      detectSeries: detectSeries$1,
      dir,
      doUntil,
      doWhilst: doWhilst$1,
      each,
      eachLimit: eachLimit$2,
      eachOf: eachOf$1,
      eachOfLimit: eachOfLimit$2,
      eachOfSeries: eachOfSeries$1,
      eachSeries: eachSeries$1,
      ensureAsync,
      every: every$1,
      everyLimit: everyLimit$1,
      everySeries: everySeries$1,
      filter: filter$1,
      filterLimit: filterLimit$1,
      filterSeries: filterSeries$1,
      forever: forever$1,
      groupBy,
      groupByLimit: groupByLimit$1,
      groupBySeries,
      log: log3,
      map: map$1,
      mapLimit: mapLimit$1,
      mapSeries: mapSeries$1,
      mapValues,
      mapValuesLimit: mapValuesLimit$1,
      mapValuesSeries,
      memoize,
      nextTick,
      parallel: parallel$1,
      parallelLimit,
      priorityQueue,
      queue: queue$1,
      race: race$1,
      reduce: reduce$1,
      reduceRight,
      reflect,
      reflectAll,
      reject: reject$2,
      rejectLimit: rejectLimit$1,
      rejectSeries: rejectSeries$1,
      retry,
      retryable,
      seq,
      series,
      setImmediate: setImmediate$1,
      some: some$1,
      someLimit: someLimit$1,
      someSeries: someSeries$1,
      sortBy: sortBy$1,
      timeout,
      times,
      timesLimit,
      timesSeries,
      transform,
      tryEach: tryEach$1,
      unmemoize,
      until,
      waterfall: waterfall$1,
      whilst: whilst$1,
      all: every$1,
      allLimit: everyLimit$1,
      allSeries: everySeries$1,
      any: some$1,
      anyLimit: someLimit$1,
      anySeries: someSeries$1,
      find: detect$1,
      findLimit: detectLimit$1,
      findSeries: detectSeries$1,
      flatMap: concat$1,
      flatMapLimit: concatLimit$1,
      flatMapSeries: concatSeries$1,
      forEach: each,
      forEachSeries: eachSeries$1,
      forEachLimit: eachLimit$2,
      forEachOf: eachOf$1,
      forEachOfSeries: eachOfSeries$1,
      forEachOfLimit: eachOfLimit$2,
      inject: reduce$1,
      foldl: reduce$1,
      foldr: reduceRight,
      select: filter$1,
      selectLimit: filterLimit$1,
      selectSeries: filterSeries$1,
      wrapSync: asyncify,
      during: whilst$1,
      doDuring: doWhilst$1
    };
    exports3.default = index;
    exports3.apply = apply;
    exports3.applyEach = applyEach$1;
    exports3.applyEachSeries = applyEachSeries;
    exports3.asyncify = asyncify;
    exports3.auto = auto;
    exports3.autoInject = autoInject;
    exports3.cargo = cargo;
    exports3.cargoQueue = cargo$1;
    exports3.compose = compose;
    exports3.concat = concat$1;
    exports3.concatLimit = concatLimit$1;
    exports3.concatSeries = concatSeries$1;
    exports3.constant = constant;
    exports3.detect = detect$1;
    exports3.detectLimit = detectLimit$1;
    exports3.detectSeries = detectSeries$1;
    exports3.dir = dir;
    exports3.doUntil = doUntil;
    exports3.doWhilst = doWhilst$1;
    exports3.each = each;
    exports3.eachLimit = eachLimit$2;
    exports3.eachOf = eachOf$1;
    exports3.eachOfLimit = eachOfLimit$2;
    exports3.eachOfSeries = eachOfSeries$1;
    exports3.eachSeries = eachSeries$1;
    exports3.ensureAsync = ensureAsync;
    exports3.every = every$1;
    exports3.everyLimit = everyLimit$1;
    exports3.everySeries = everySeries$1;
    exports3.filter = filter$1;
    exports3.filterLimit = filterLimit$1;
    exports3.filterSeries = filterSeries$1;
    exports3.forever = forever$1;
    exports3.groupBy = groupBy;
    exports3.groupByLimit = groupByLimit$1;
    exports3.groupBySeries = groupBySeries;
    exports3.log = log3;
    exports3.map = map$1;
    exports3.mapLimit = mapLimit$1;
    exports3.mapSeries = mapSeries$1;
    exports3.mapValues = mapValues;
    exports3.mapValuesLimit = mapValuesLimit$1;
    exports3.mapValuesSeries = mapValuesSeries;
    exports3.memoize = memoize;
    exports3.nextTick = nextTick;
    exports3.parallel = parallel$1;
    exports3.parallelLimit = parallelLimit;
    exports3.priorityQueue = priorityQueue;
    exports3.queue = queue$1;
    exports3.race = race$1;
    exports3.reduce = reduce$1;
    exports3.reduceRight = reduceRight;
    exports3.reflect = reflect;
    exports3.reflectAll = reflectAll;
    exports3.reject = reject$2;
    exports3.rejectLimit = rejectLimit$1;
    exports3.rejectSeries = rejectSeries$1;
    exports3.retry = retry;
    exports3.retryable = retryable;
    exports3.seq = seq;
    exports3.series = series;
    exports3.setImmediate = setImmediate$1;
    exports3.some = some$1;
    exports3.someLimit = someLimit$1;
    exports3.someSeries = someSeries$1;
    exports3.sortBy = sortBy$1;
    exports3.timeout = timeout;
    exports3.times = times;
    exports3.timesLimit = timesLimit;
    exports3.timesSeries = timesSeries;
    exports3.transform = transform;
    exports3.tryEach = tryEach$1;
    exports3.unmemoize = unmemoize;
    exports3.until = until;
    exports3.waterfall = waterfall$1;
    exports3.whilst = whilst$1;
    exports3.all = every$1;
    exports3.allLimit = everyLimit$1;
    exports3.allSeries = everySeries$1;
    exports3.any = some$1;
    exports3.anyLimit = someLimit$1;
    exports3.anySeries = someSeries$1;
    exports3.find = detect$1;
    exports3.findLimit = detectLimit$1;
    exports3.findSeries = detectSeries$1;
    exports3.flatMap = concat$1;
    exports3.flatMapLimit = concatLimit$1;
    exports3.flatMapSeries = concatSeries$1;
    exports3.forEach = each;
    exports3.forEachSeries = eachSeries$1;
    exports3.forEachLimit = eachLimit$2;
    exports3.forEachOf = eachOf$1;
    exports3.forEachOfSeries = eachOfSeries$1;
    exports3.forEachOfLimit = eachOfLimit$2;
    exports3.inject = reduce$1;
    exports3.foldl = reduce$1;
    exports3.foldr = reduceRight;
    exports3.select = filter$1;
    exports3.selectLimit = filterLimit$1;
    exports3.selectSeries = filterSeries$1;
    exports3.wrapSync = asyncify;
    exports3.during = whilst$1;
    exports3.doDuring = doWhilst$1;
    Object.defineProperty(exports3, "__esModule", {value: true});
  });
});

// ../../node_modules/.pnpm/process-nextick-args@2.0.1/node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS2((exports2, module2) => {
  "use strict";
  if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
    module2.exports = {nextTick};
  } else {
    module2.exports = process;
  }
  function nextTick(fn, arg1, arg2, arg3) {
    if (typeof fn !== "function") {
      throw new TypeError('"callback" argument must be a function');
    }
    var len = arguments.length;
    var args, i;
    switch (len) {
      case 0:
      case 1:
        return process.nextTick(fn);
      case 2:
        return process.nextTick(function afterTickOne() {
          fn.call(null, arg1);
        });
      case 3:
        return process.nextTick(function afterTickTwo() {
          fn.call(null, arg1, arg2);
        });
      case 4:
        return process.nextTick(function afterTickThree() {
          fn.call(null, arg1, arg2, arg3);
        });
      default:
        args = new Array(len - 1);
        i = 0;
        while (i < args.length) {
          args[i++] = arguments[i];
        }
        return process.nextTick(function afterTick() {
          fn.apply(null, args);
        });
    }
  }
});

// ../../node_modules/.pnpm/isarray@1.0.0/node_modules/isarray/index.js
var require_isarray = __commonJS2((exports2, module2) => {
  var toString = {}.toString;
  module2.exports = Array.isArray || function(arr) {
    return toString.call(arr) == "[object Array]";
  };
});

// ../../node_modules/.pnpm/readable-stream@2.3.7/node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream11 = __commonJS2((exports2, module2) => {
  module2.exports = require("stream");
});

// ../../node_modules/.pnpm/safe-buffer@5.1.2/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS2((exports2, module2) => {
  var buffer = require("buffer");
  var Buffer2 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module2.exports = buffer;
  } else {
    copyProps(buffer, exports2);
    exports2.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg2, encodingOrOffset, length) {
    return Buffer2(arg2, encodingOrOffset, length);
  }
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg2, encodingOrOffset, length) {
    if (typeof arg2 === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg2, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== void 0) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// ../../node_modules/.pnpm/core-util-is@1.0.2/node_modules/core-util-is/lib/util.js
var require_util7 = __commonJS2((exports2) => {
  function isArray(arg2) {
    if (Array.isArray) {
      return Array.isArray(arg2);
    }
    return objectToString(arg2) === "[object Array]";
  }
  exports2.isArray = isArray;
  function isBoolean(arg2) {
    return typeof arg2 === "boolean";
  }
  exports2.isBoolean = isBoolean;
  function isNull(arg2) {
    return arg2 === null;
  }
  exports2.isNull = isNull;
  function isNullOrUndefined(arg2) {
    return arg2 == null;
  }
  exports2.isNullOrUndefined = isNullOrUndefined;
  function isNumber(arg2) {
    return typeof arg2 === "number";
  }
  exports2.isNumber = isNumber;
  function isString(arg2) {
    return typeof arg2 === "string";
  }
  exports2.isString = isString;
  function isSymbol(arg2) {
    return typeof arg2 === "symbol";
  }
  exports2.isSymbol = isSymbol;
  function isUndefined(arg2) {
    return arg2 === void 0;
  }
  exports2.isUndefined = isUndefined;
  function isRegExp(re) {
    return objectToString(re) === "[object RegExp]";
  }
  exports2.isRegExp = isRegExp;
  function isObject(arg2) {
    return typeof arg2 === "object" && arg2 !== null;
  }
  exports2.isObject = isObject;
  function isDate(d2) {
    return objectToString(d2) === "[object Date]";
  }
  exports2.isDate = isDate;
  function isError2(e) {
    return objectToString(e) === "[object Error]" || e instanceof Error;
  }
  exports2.isError = isError2;
  function isFunction(arg2) {
    return typeof arg2 === "function";
  }
  exports2.isFunction = isFunction;
  function isPrimitive(arg2) {
    return arg2 === null || typeof arg2 === "boolean" || typeof arg2 === "number" || typeof arg2 === "string" || typeof arg2 === "symbol" || typeof arg2 === "undefined";
  }
  exports2.isPrimitive = isPrimitive;
  exports2.isBuffer = Buffer.isBuffer;
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
});

// ../../node_modules/.pnpm/readable-stream@2.3.7/node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS2((exports2, module2) => {
  "use strict";
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var Buffer2 = require_safe_buffer().Buffer;
  var util2 = require("util");
  function copyBuffer(src, target, offset) {
    src.copy(target, offset);
  }
  module2.exports = function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    BufferList.prototype.push = function push(v) {
      var entry = {data: v, next: null};
      if (this.length > 0)
        this.tail.next = entry;
      else
        this.head = entry;
      this.tail = entry;
      ++this.length;
    };
    BufferList.prototype.unshift = function unshift(v) {
      var entry = {data: v, next: this.head};
      if (this.length === 0)
        this.tail = entry;
      this.head = entry;
      ++this.length;
    };
    BufferList.prototype.shift = function shift() {
      if (this.length === 0)
        return;
      var ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret;
    };
    BufferList.prototype.clear = function clear() {
      this.head = this.tail = null;
      this.length = 0;
    };
    BufferList.prototype.join = function join2(s2) {
      if (this.length === 0)
        return "";
      var p = this.head;
      var ret = "" + p.data;
      while (p = p.next) {
        ret += s2 + p.data;
      }
      return ret;
    };
    BufferList.prototype.concat = function concat(n) {
      if (this.length === 0)
        return Buffer2.alloc(0);
      if (this.length === 1)
        return this.head.data;
      var ret = Buffer2.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    };
    return BufferList;
  }();
  if (util2 && util2.inspect && util2.inspect.custom) {
    module2.exports.prototype[util2.inspect.custom] = function() {
      var obj = util2.inspect({length: this.length});
      return this.constructor.name + " " + obj;
    };
  }
});

// ../../node_modules/.pnpm/readable-stream@2.3.7/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS2((exports2, module2) => {
  "use strict";
  var pna = require_process_nextick_args();
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
        pna.nextTick(emitErrorNT, this, err);
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        pna.nextTick(emitErrorNT, _this, err2);
        if (_this._writableState) {
          _this._writableState.errorEmitted = true;
        }
      } else if (cb) {
        cb(err2);
      }
    });
    return this;
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  module2.exports = {
    destroy,
    undestroy
  };
});

// ../../node_modules/.pnpm/util-deprecate@1.0.2/node_modules/util-deprecate/node.js
var require_node6 = __commonJS2((exports2, module2) => {
  module2.exports = require("util").deprecate;
});

// ../../node_modules/.pnpm/readable-stream@2.3.7/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS2((exports2, module2) => {
  "use strict";
  var pna = require_process_nextick_args();
  module2.exports = Writable;
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state);
    };
  }
  var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
  var Duplex;
  Writable.WritableState = WritableState;
  var util2 = Object.create(require_util7());
  util2.inherits = require_inherits2();
  var internalUtil = {
    deprecate: require_node6()
  };
  var Stream = require_stream11();
  var Buffer2 = require_safe_buffer().Buffer;
  var OurUint8Array = global.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = require_destroy();
  util2.inherits(Writable, Stream);
  function nop() {
  }
  function WritableState(options, stream) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    var isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0))
      this.highWaterMark = writableHwm;
    else
      this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_2) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function(object) {
      return object instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require_stream_duplex();
    if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
      return new Writable(options);
    }
    this._writableState = new WritableState(options, this);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function writeAfterEnd(stream, cb) {
    var er = new Error("write after end");
    stream.emit("error", er);
    pna.nextTick(cb, er);
  }
  function validChunk(stream, state, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
      er = new TypeError("May not write null values to stream");
    } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
      stream.emit("error", er);
      pna.nextTick(cb, er);
      valid = false;
    }
    return valid;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state.ended)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    var state = this._writableState;
    state.corked++;
  };
  Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (writev)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, sync2, er, cb) {
    --state.pendingcb;
    if (sync2) {
      pna.nextTick(cb, er);
      pna.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
      finishMaybe(stream, state);
    }
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync2 = state.sync;
    var cb = state.writecb;
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream, state, sync2, er, cb);
    else {
      var finished = needFinish(state);
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }
      if (sync2) {
        asyncWrite(afterWrite, stream, state, finished, cb);
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  }
  function afterWrite(stream, state, finished, cb) {
    if (!finished)
      onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l = state.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream, state, true, state.length, buffer, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("_write() is not implemented"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0)
      this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending && !state.finished)
      endWritable(this, state, cb);
  };
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function callFinal(stream, state) {
    stream._final(function(err) {
      state.pendingcb--;
      if (err) {
        stream.emit("error", err);
      }
      state.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state);
    });
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === "function") {
        state.pendingcb++;
        state.finalCalled = true;
        pna.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit("finish");
      }
    }
    return need;
  }
  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished)
        pna.nextTick(cb);
      else
        stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = corkReq;
    } else {
      state.corkedRequestsFree = corkReq;
    }
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    get: function() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    this.end();
    cb(err);
  };
});

// ../../node_modules/.pnpm/readable-stream@2.3.7/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS2((exports2, module2) => {
  "use strict";
  var pna = require_process_nextick_args();
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  module2.exports = Duplex;
  var util2 = Object.create(require_util7());
  util2.inherits = require_inherits2();
  var Readable = require_stream_readable();
  var Writable = require_stream_writable();
  util2.inherits(Duplex, Readable);
  {
    keys = objectKeys(Writable.prototype);
    for (v = 0; v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  var keys;
  var method;
  var v;
  function Duplex(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    if (options && options.readable === false)
      this.readable = false;
    if (options && options.writable === false)
      this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false)
      this.allowHalfOpen = false;
    this.once("end", onend);
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended)
      return;
    pna.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  Duplex.prototype._destroy = function(err, cb) {
    this.push(null);
    this.end();
    pna.nextTick(cb, err);
  };
});

// ../../node_modules/.pnpm/readable-stream@2.3.7/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS2((exports2, module2) => {
  "use strict";
  var pna = require_process_nextick_args();
  module2.exports = Readable;
  var isArray = require_isarray();
  var Duplex;
  Readable.ReadableState = ReadableState;
  var EE = require("events").EventEmitter;
  var EElistenerCount = function(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream = require_stream11();
  var Buffer2 = require_safe_buffer().Buffer;
  var OurUint8Array = global.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var util2 = Object.create(require_util7());
  util2.inherits = require_inherits2();
  var debugUtil = require("util");
  var debug4 = void 0;
  if (debugUtil && debugUtil.debuglog) {
    debug4 = debugUtil.debuglog("stream");
  } else {
    debug4 = function() {
    };
  }
  var BufferList = require_BufferList();
  var destroyImpl = require_destroy();
  var StringDecoder;
  util2.inherits(Readable, Stream);
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    var isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    var hwm = options.highWaterMark;
    var readableHwm = options.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0))
      this.highWaterMark = readableHwm;
    else
      this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = require("string_decoder/").StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex = Duplex || require_stream_duplex();
    if (!(this instanceof Readable))
      return new Readable(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    this.push(null);
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    var state = stream._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit("error", er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state.endEmitted)
            stream.emit("error", new Error("stream.unshift() after end event"));
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          stream.emit("error", new Error("stream.push() after EOF"));
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
      }
    }
    return needMoreData(state);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      stream.emit("data", chunk);
      stream.read(0);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if (state.needReadable)
        emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  }
  function needMoreData(state) {
    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = require("string_decoder/").StringDecoder;
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
  };
  var MAX_HWM = 8388608;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n !== n) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length)
      return n;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  Readable.prototype.read = function(n) {
    debug4("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0)
      state.emittedReadable = false;
    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
      debug4("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug4("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug4("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug4("reading or ended", doRead);
    } else if (doRead) {
      debug4("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0)
        state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading)
        n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0)
      ret = fromList(n, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = true;
      n = 0;
    } else {
      state.length -= n;
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state) {
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    emitReadable(stream);
  }
  function emitReadable(stream) {
    var state = stream._readableState;
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug4("emitReadable", state.flowing);
      state.emittedReadable = true;
      if (state.sync)
        pna.nextTick(emitReadable_, stream);
      else
        emitReadable_(stream);
    }
  }
  function emitReadable_(stream) {
    debug4("emit readable");
    stream.emit("readable");
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      pna.nextTick(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    var len = state.length;
    while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
      debug4("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
      else
        len = state.length;
    }
    state.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug4("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      pna.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug4("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup2();
        }
      }
    }
    function onend() {
      debug4("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup2() {
      debug4("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    var increasedAwaitDrain = false;
    src.on("data", ondata);
    function ondata(chunk) {
      debug4("ondata");
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (ret === false && !increasedAwaitDrain) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug4("false write response, pause", src._readableState.awaitDrain);
          src._readableState.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug4("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        dest.emit("error", er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug4("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug4("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug4("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function() {
      var state = src._readableState;
      debug4("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {hasUnpiped: false};
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i = 0; i < len; i++) {
        dests[i].emit("unpipe", this, unpipeInfo);
      }
      return this;
    }
    var index = indexOf(state.pipes, dest);
    if (index === -1)
      return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
      state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    if (ev === "data") {
      if (this._readableState.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      var state = this._readableState;
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.emittedReadable = false;
        if (!state.reading) {
          pna.nextTick(nReadingNextTick, this);
        } else if (state.length) {
          emitReadable(this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  function nReadingNextTick(self2) {
    debug4("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug4("resume");
      state.flowing = true;
      resume(this, state);
    }
    return this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      pna.nextTick(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    if (!state.reading) {
      debug4("resume read 0");
      stream.read(0);
    }
    state.resumeScheduled = false;
    state.awaitDrain = 0;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading)
      stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug4("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug4("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    return this;
  };
  function flow(stream) {
    var state = stream._readableState;
    debug4("flow", state.flowing);
    while (state.flowing && stream.read() !== null) {
    }
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug4("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug4("wrapped data");
      if (state.decoder)
        chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === void 0))
        return;
      else if (!state.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i in stream) {
      if (this[i] === void 0 && typeof stream[i] === "function") {
        this[i] = function(method) {
          return function() {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug4("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  });
  Readable._fromList = fromList;
  function fromList(n, state) {
    if (state.length === 0)
      return null;
    var ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n || n >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.head.data;
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = fromListPartial(n, state.buffer, state.decoder);
    }
    return ret;
  }
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      ret = list.shift();
    } else {
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length)
        ret += str;
      else
        ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function copyFromBuffer(n, list) {
    var ret = Buffer2.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function endReadable(stream) {
    var state = stream._readableState;
    if (state.length > 0)
      throw new Error('"endReadable()" called on non-empty stream');
    if (!state.endEmitted) {
      state.ended = true;
      pna.nextTick(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
    }
  }
  function indexOf(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x)
        return i;
    }
    return -1;
  }
});

// ../../node_modules/.pnpm/readable-stream@2.3.7/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = Transform;
  var Duplex = require_stream_duplex();
  var util2 = Object.create(require_util7());
  util2.inherits = require_inherits2();
  util2.inherits(Transform, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) {
      return this.emit("error", new Error("write callback called multiple times"));
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform))
      return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function") {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("_transform() is not implemented");
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    var _this2 = this;
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
      _this2.emit("close");
    });
  };
  function done(stream, er, data) {
    if (er)
      return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length)
      throw new Error("Calling transform done when ws.length != 0");
    if (stream._transformState.transforming)
      throw new Error("Calling transform done when still transforming");
    return stream.push(null);
  }
});

// ../../node_modules/.pnpm/readable-stream@2.3.7/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = PassThrough;
  var Transform = require_stream_transform();
  var util2 = Object.create(require_util7());
  util2.inherits = require_inherits2();
  util2.inherits(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
});

// ../../node_modules/.pnpm/readable-stream@2.3.7/node_modules/readable-stream/readable.js
var require_readable = __commonJS2((exports2, module2) => {
  var Stream = require("stream");
  if (process.env.READABLE_STREAM === "disable" && Stream) {
    module2.exports = Stream;
    exports2 = module2.exports = Stream.Readable;
    exports2.Readable = Stream.Readable;
    exports2.Writable = Stream.Writable;
    exports2.Duplex = Stream.Duplex;
    exports2.Transform = Stream.Transform;
    exports2.PassThrough = Stream.PassThrough;
    exports2.Stream = Stream;
  } else {
    exports2 = module2.exports = require_stream_readable();
    exports2.Stream = Stream || exports2;
    exports2.Readable = exports2;
    exports2.Writable = require_stream_writable();
    exports2.Duplex = require_stream_duplex();
    exports2.Transform = require_stream_transform();
    exports2.PassThrough = require_stream_passthrough();
  }
});

// ../../node_modules/.pnpm/readable-stream@2.3.7/node_modules/readable-stream/passthrough.js
var require_passthrough = __commonJS2((exports2, module2) => {
  module2.exports = require_readable().PassThrough;
});

// ../../node_modules/.pnpm/lazystream@1.0.0/node_modules/lazystream/lib/lazystream.js
var require_lazystream = __commonJS2((exports2, module2) => {
  var util2 = require("util");
  var PassThrough = require_passthrough();
  module2.exports = {
    Readable,
    Writable
  };
  util2.inherits(Readable, PassThrough);
  util2.inherits(Writable, PassThrough);
  function beforeFirstCall(instance, method, callback) {
    instance[method] = function() {
      delete instance[method];
      callback.apply(this, arguments);
      return this[method].apply(this, arguments);
    };
  }
  function Readable(fn, options) {
    if (!(this instanceof Readable))
      return new Readable(fn, options);
    PassThrough.call(this, options);
    beforeFirstCall(this, "_read", function() {
      var source = fn.call(this, options);
      var emit = this.emit.bind(this, "error");
      source.on("error", emit);
      source.pipe(this);
    });
    this.emit("readable");
  }
  function Writable(fn, options) {
    if (!(this instanceof Writable))
      return new Writable(fn, options);
    PassThrough.call(this, options);
    beforeFirstCall(this, "_write", function() {
      var destination = fn.call(this, options);
      var emit = this.emit.bind(this, "error");
      destination.on("error", emit);
      this.pipe(destination);
    });
    this.emit("writable");
  }
});

// ../../node_modules/.pnpm/normalize-path@3.0.0/node_modules/normalize-path/index.js
var require_normalize_path = __commonJS2((exports2, module2) => {
  /*!
   * normalize-path <https://github.com/jonschlinkert/normalize-path>
   *
   * Copyright (c) 2014-2018, Jon Schlinkert.
   * Released under the MIT License.
   */
  module2.exports = function(path4, stripTrailing) {
    if (typeof path4 !== "string") {
      throw new TypeError("expected path to be a string");
    }
    if (path4 === "\\" || path4 === "/")
      return "/";
    var len = path4.length;
    if (len <= 1)
      return path4;
    var prefix = "";
    if (len > 4 && path4[3] === "\\") {
      var ch = path4[2];
      if ((ch === "?" || ch === ".") && path4.slice(0, 2) === "\\\\") {
        path4 = path4.slice(2);
        prefix = "//";
      }
    }
    var segs = path4.split(/[/\\]+/);
    if (stripTrailing !== false && segs[segs.length - 1] === "") {
      segs.pop();
    }
    return prefix + segs.join("/");
  };
});

// ../../node_modules/.pnpm/lodash.defaults@4.2.0/node_modules/lodash.defaults/index.js
var require_lodash = __commonJS2((exports2, module2) => {
  var MAX_SAFE_INTEGER2 = 9007199254740991;
  var argsTag = "[object Arguments]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var nativeMax = Math.max;
  function arrayLikeKeys(value, inherited) {
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function assignInDefaults(objValue, srcValue, key, object) {
    if (objValue === void 0 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
      return srcValue;
    }
    return objValue;
  }
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
      object[key] = value;
    }
  }
  function baseKeysIn(object) {
    if (!isObject(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object), result = [];
    for (var key in object) {
      if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }
  function baseRest(func, start) {
    start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
    return function() {
      var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = array;
      return apply(func, this, otherArgs);
    };
  }
  function copyObject(source, props, object, customizer) {
    object || (object = {});
    var index = -1, length = props.length;
    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
      assignValue(object, key, newValue === void 0 ? source[key] : newValue);
    }
    return object;
  }
  function createAssigner(assigner) {
    return baseRest(function(object, sources) {
      var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? void 0 : customizer;
        length = 1;
      }
      object = Object(object);
      while (++index < length) {
        var source = sources[index];
        if (source) {
          assigner(object, source, index, customizer);
        }
      }
      return object;
    });
  }
  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER2 : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isIterateeCall(value, index, object) {
    if (!isObject(object)) {
      return false;
    }
    var type = typeof index;
    if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
      return eq(object[index], value);
    }
    return false;
  }
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
  }
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  }
  var isArray = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  function isFunction(value) {
    var tag2 = isObject(value) ? objectToString.call(value) : "";
    return tag2 == funcTag || tag2 == genTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
    copyObject(source, keysIn(source), object, customizer);
  });
  var defaults = baseRest(function(args) {
    args.push(void 0, assignInDefaults);
    return apply(assignInWith, void 0, args);
  });
  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }
  module2.exports = defaults;
});

// ../../node_modules/.pnpm/lodash.flatten@4.4.0/node_modules/lodash.flatten/index.js
var require_lodash2 = __commonJS2((exports2, module2) => {
  var MAX_SAFE_INTEGER2 = 9007199254740991;
  var argsTag = "[object Arguments]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var Symbol2 = root.Symbol;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1, length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index < length) {
      var value = array[index];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }
  function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  function flatten(array) {
    var length = array ? array.length : 0;
    return length ? baseFlatten(array, 1) : [];
  }
  function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  }
  var isArray = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  function isFunction(value) {
    var tag2 = isObject(value) ? objectToString.call(value) : "";
    return tag2 == funcTag || tag2 == genTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  module2.exports = flatten;
});

// ../../node_modules/.pnpm/lodash.difference@4.5.0/node_modules/lodash.difference/index.js
var require_lodash3 = __commonJS2((exports2, module2) => {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var MAX_SAFE_INTEGER2 = 9007199254740991;
  var argsTag = "[object Arguments]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  function arrayIncludes(array, value) {
    var length = array ? array.length : 0;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }
  function arrayIncludesWith(array, value, comparator) {
    var index = -1, length = array ? array.length : 0;
    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }
  function arrayMap(array, iteratee) {
    var index = -1, length = array ? array.length : 0, result = Array(length);
    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }
  function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }
  function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
      return baseFindIndex(array, baseIsNaN, fromIndex);
    }
    var index = fromIndex - 1, length = array.length;
    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }
  function baseIsNaN(value) {
    return value !== value;
  }
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  function cacheHas(cache, key) {
    return cache.has(key);
  }
  function getValue(object, key) {
    return object == null ? void 0 : object[key];
  }
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result = !!(value + "");
      } catch (e) {
      }
    }
    return result;
  }
  var arrayProto = Array.prototype;
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var coreJsData = root["__core-js_shared__"];
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  var Symbol2 = root.Symbol;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var splice = arrayProto.splice;
  var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
  var nativeMax = Math.max;
  var Map2 = getNative(root, "Map");
  var nativeCreate = getNative(Object, "create");
  function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }
  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : void 0;
  }
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
  }
  function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
  }
  function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    return true;
  }
  function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? void 0 : data[index][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.__data__ = {
      hash: new Hash(),
      map: new (Map2 || ListCache)(),
      string: new Hash()
    };
  }
  function mapCacheDelete(key) {
    return getMapData(this, key)["delete"](key);
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function SetCache(values) {
    var index = -1, length = values ? values.length : 0;
    this.__data__ = new MapCache();
    while (++index < length) {
      this.add(values[index]);
    }
  }
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseDifference(array, values, iteratee, comparator) {
    var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
    if (!length) {
      return result;
    }
    if (iteratee) {
      values = arrayMap(values, baseUnary(iteratee));
    }
    if (comparator) {
      includes = arrayIncludesWith;
      isCommon = false;
    } else if (values.length >= LARGE_ARRAY_SIZE) {
      includes = cacheHas;
      isCommon = false;
      values = new SetCache(values);
    }
    outer:
      while (++index < length) {
        var value = array[index], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        } else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
    return result;
  }
  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1, length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index < length) {
      var value = array[index];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function baseRest(func, start) {
    start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
    return function() {
      var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = array;
      return apply(func, this, otherArgs);
    };
  }
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : void 0;
  }
  function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  var difference = baseRest(function(array, values) {
    return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
  });
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  }
  var isArray = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  function isFunction(value) {
    var tag2 = isObject(value) ? objectToString.call(value) : "";
    return tag2 == funcTag || tag2 == genTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  module2.exports = difference;
});

// ../../node_modules/.pnpm/lodash.union@4.6.0/node_modules/lodash.union/index.js
var require_lodash4 = __commonJS2((exports2, module2) => {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var INFINITY = 1 / 0;
  var MAX_SAFE_INTEGER2 = 9007199254740991;
  var argsTag = "[object Arguments]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  function arrayIncludes(array, value) {
    var length = array ? array.length : 0;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }
  function arrayIncludesWith(array, value, comparator) {
    var index = -1, length = array ? array.length : 0;
    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }
  function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }
  function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
      return baseFindIndex(array, baseIsNaN, fromIndex);
    }
    var index = fromIndex - 1, length = array.length;
    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }
  function baseIsNaN(value) {
    return value !== value;
  }
  function cacheHas(cache, key) {
    return cache.has(key);
  }
  function getValue(object, key) {
    return object == null ? void 0 : object[key];
  }
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result = !!(value + "");
      } catch (e) {
      }
    }
    return result;
  }
  function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }
  var arrayProto = Array.prototype;
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var coreJsData = root["__core-js_shared__"];
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  var Symbol2 = root.Symbol;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var splice = arrayProto.splice;
  var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
  var nativeMax = Math.max;
  var Map2 = getNative(root, "Map");
  var Set2 = getNative(root, "Set");
  var nativeCreate = getNative(Object, "create");
  function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }
  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : void 0;
  }
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
  }
  function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
  }
  function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    return true;
  }
  function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? void 0 : data[index][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.__data__ = {
      hash: new Hash(),
      map: new (Map2 || ListCache)(),
      string: new Hash()
    };
  }
  function mapCacheDelete(key) {
    return getMapData(this, key)["delete"](key);
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function SetCache(values) {
    var index = -1, length = values ? values.length : 0;
    this.__data__ = new MapCache();
    while (++index < length) {
      this.add(values[index]);
    }
  }
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1, length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index < length) {
      var value = array[index];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function baseRest(func, start) {
    start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
    return function() {
      var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = array;
      return apply(func, this, otherArgs);
    };
  }
  function baseUniq(array, iteratee, comparator) {
    var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
    if (comparator) {
      isCommon = false;
      includes = arrayIncludesWith;
    } else if (length >= LARGE_ARRAY_SIZE) {
      var set = iteratee ? null : createSet(array);
      if (set) {
        return setToArray(set);
      }
      isCommon = false;
      includes = cacheHas;
      seen = new SetCache();
    } else {
      seen = iteratee ? [] : result;
    }
    outer:
      while (++index < length) {
        var value = array[index], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        } else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
    return result;
  }
  var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
    return new Set2(values);
  };
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : void 0;
  }
  function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  var union = baseRest(function(arrays) {
    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
  });
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  }
  var isArray = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  function isFunction(value) {
    var tag2 = isObject(value) ? objectToString.call(value) : "";
    return tag2 == funcTag || tag2 == genTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function noop() {
  }
  module2.exports = union;
});

// ../../node_modules/.pnpm/lodash.isplainobject@4.0.6/node_modules/lodash.isplainobject/index.js
var require_lodash5 = __commonJS2((exports2, module2) => {
  var objectTag = "[object Object]";
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result = !!(value + "");
      } catch (e) {
      }
    }
    return result;
  }
  function overArg(func, transform) {
    return function(arg2) {
      return func(transform(arg2));
    };
  }
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  var objectToString = objectProto.toString;
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isPlainObject(value) {
    if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  module2.exports = isPlainObject;
});

// ../../node_modules/.pnpm/archiver-utils@2.1.0/node_modules/archiver-utils/file.js
var require_file = __commonJS2((exports2, module2) => {
  var fs2 = require_graceful_fs2();
  var path4 = require("path");
  var flatten = require_lodash2();
  var difference = require_lodash3();
  var union = require_lodash4();
  var isPlainObject = require_lodash5();
  var glob = require_glob2();
  var file = module2.exports = {};
  var pathSeparatorRe = /[\/\\]/g;
  var processPatterns = function(patterns, fn) {
    var result = [];
    flatten(patterns).forEach(function(pattern) {
      var exclusion = pattern.indexOf("!") === 0;
      if (exclusion) {
        pattern = pattern.slice(1);
      }
      var matches = fn(pattern);
      if (exclusion) {
        result = difference(result, matches);
      } else {
        result = union(result, matches);
      }
    });
    return result;
  };
  file.exists = function() {
    var filepath = path4.join.apply(path4, arguments);
    return fs2.existsSync(filepath);
  };
  file.expand = function(...args) {
    var options = isPlainObject(args[0]) ? args.shift() : {};
    var patterns = Array.isArray(args[0]) ? args[0] : args;
    if (patterns.length === 0) {
      return [];
    }
    var matches = processPatterns(patterns, function(pattern) {
      return glob.sync(pattern, options);
    });
    if (options.filter) {
      matches = matches.filter(function(filepath) {
        filepath = path4.join(options.cwd || "", filepath);
        try {
          if (typeof options.filter === "function") {
            return options.filter(filepath);
          } else {
            return fs2.statSync(filepath)[options.filter]();
          }
        } catch (e) {
          return false;
        }
      });
    }
    return matches;
  };
  file.expandMapping = function(patterns, destBase, options) {
    options = Object.assign({
      rename: function(destBase2, destPath) {
        return path4.join(destBase2 || "", destPath);
      }
    }, options);
    var files = [];
    var fileByDest = {};
    file.expand(options, patterns).forEach(function(src) {
      var destPath = src;
      if (options.flatten) {
        destPath = path4.basename(destPath);
      }
      if (options.ext) {
        destPath = destPath.replace(/(\.[^\/]*)?$/, options.ext);
      }
      var dest = options.rename(destBase, destPath, options);
      if (options.cwd) {
        src = path4.join(options.cwd, src);
      }
      dest = dest.replace(pathSeparatorRe, "/");
      src = src.replace(pathSeparatorRe, "/");
      if (fileByDest[dest]) {
        fileByDest[dest].src.push(src);
      } else {
        files.push({
          src: [src],
          dest
        });
        fileByDest[dest] = files[files.length - 1];
      }
    });
    return files;
  };
  file.normalizeFilesArray = function(data) {
    var files = [];
    data.forEach(function(obj) {
      var prop;
      if ("src" in obj || "dest" in obj) {
        files.push(obj);
      }
    });
    if (files.length === 0) {
      return [];
    }
    files = _(files).chain().forEach(function(obj) {
      if (!("src" in obj) || !obj.src) {
        return;
      }
      if (Array.isArray(obj.src)) {
        obj.src = flatten(obj.src);
      } else {
        obj.src = [obj.src];
      }
    }).map(function(obj) {
      var expandOptions = Object.assign({}, obj);
      delete expandOptions.src;
      delete expandOptions.dest;
      if (obj.expand) {
        return file.expandMapping(obj.src, obj.dest, expandOptions).map(function(mapObj) {
          var result2 = Object.assign({}, obj);
          result2.orig = Object.assign({}, obj);
          result2.src = mapObj.src;
          result2.dest = mapObj.dest;
          ["expand", "cwd", "flatten", "rename", "ext"].forEach(function(prop) {
            delete result2[prop];
          });
          return result2;
        });
      }
      var result = Object.assign({}, obj);
      result.orig = Object.assign({}, obj);
      if ("src" in result) {
        Object.defineProperty(result, "src", {
          enumerable: true,
          get: function fn() {
            var src;
            if (!("result" in fn)) {
              src = obj.src;
              src = Array.isArray(src) ? flatten(src) : [src];
              fn.result = file.expand(expandOptions, src);
            }
            return fn.result;
          }
        });
      }
      if ("dest" in result) {
        result.dest = obj.dest;
      }
      return result;
    }).flatten().value();
    return files;
  };
});

// ../../node_modules/.pnpm/archiver-utils@2.1.0/node_modules/archiver-utils/index.js
var require_archiver_utils = __commonJS2((exports2, module2) => {
  var fs2 = require_graceful_fs2();
  var path4 = require("path");
  var nutil = require("util");
  var lazystream = require_lazystream();
  var normalizePath = require_normalize_path();
  var defaults = require_lodash();
  var Stream = require("stream").Stream;
  var PassThrough = require_readable().PassThrough;
  var utils = module2.exports = {};
  utils.file = require_file();
  utils.collectStream = function(source, callback) {
    var collection = [];
    var size = 0;
    source.on("error", callback);
    source.on("data", function(chunk) {
      collection.push(chunk);
      size += chunk.length;
    });
    source.on("end", function() {
      var buf = new Buffer(size);
      var offset = 0;
      collection.forEach(function(data) {
        data.copy(buf, offset);
        offset += data.length;
      });
      callback(null, buf);
    });
  };
  utils.dateify = function(dateish) {
    dateish = dateish || new Date();
    if (dateish instanceof Date) {
      dateish = dateish;
    } else if (typeof dateish === "string") {
      dateish = new Date(dateish);
    } else {
      dateish = new Date();
    }
    return dateish;
  };
  utils.defaults = function(object, source, guard) {
    var args = arguments;
    args[0] = args[0] || {};
    return defaults(...args);
  };
  utils.isStream = function(source) {
    return source instanceof Stream;
  };
  utils.lazyReadStream = function(filepath) {
    return new lazystream.Readable(function() {
      return fs2.createReadStream(filepath);
    });
  };
  utils.normalizeInputSource = function(source) {
    if (source === null) {
      return new Buffer(0);
    } else if (typeof source === "string") {
      return new Buffer(source);
    } else if (utils.isStream(source) && !source._readableState) {
      var normalized = new PassThrough();
      source.pipe(normalized);
      return normalized;
    }
    return source;
  };
  utils.sanitizePath = function(filepath) {
    return normalizePath(filepath, false).replace(/^\w+:/, "").replace(/^(\.\.\/|\/)+/, "");
  };
  utils.trailingSlashIt = function(str) {
    return str.slice(-1) !== "/" ? str + "/" : str;
  };
  utils.unixifyPath = function(filepath) {
    return normalizePath(filepath, false).replace(/^\w+:/, "");
  };
  utils.walkdir = function(dirpath, base, callback) {
    var results = [];
    if (typeof base === "function") {
      callback = base;
      base = dirpath;
    }
    fs2.readdir(dirpath, function(err, list) {
      var i = 0;
      var file;
      var filepath;
      if (err) {
        return callback(err);
      }
      (function next() {
        file = list[i++];
        if (!file) {
          return callback(null, results);
        }
        filepath = path4.join(dirpath, file);
        fs2.stat(filepath, function(err2, stats) {
          results.push({
            path: filepath,
            relative: path4.relative(base, filepath).replace(/\\/g, "/"),
            stats
          });
          if (stats && stats.isDirectory()) {
            utils.walkdir(filepath, base, function(err3, res) {
              res.forEach(function(dirEntry) {
                results.push(dirEntry);
              });
              next();
            });
          } else {
            next();
          }
        });
      })();
    });
  };
});

// ../../node_modules/.pnpm/archiver@4.0.2/node_modules/archiver/lib/error.js
var require_error5 = __commonJS2((exports2, module2) => {
  /**
   * Archiver Core
   *
   * @ignore
   * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
   * @copyright (c) 2012-2014 Chris Talkington, contributors.
   */
  var util2 = require("util");
  var ERROR_CODES = {
    ABORTED: "archive was aborted",
    DIRECTORYDIRPATHREQUIRED: "diretory dirpath argument must be a non-empty string value",
    DIRECTORYFUNCTIONINVALIDDATA: "invalid data returned by directory custom data function",
    ENTRYNAMEREQUIRED: "entry name must be a non-empty string value",
    FILEFILEPATHREQUIRED: "file filepath argument must be a non-empty string value",
    FINALIZING: "archive already finalizing",
    QUEUECLOSED: "queue closed",
    NOENDMETHOD: "no suitable finalize/end method defined by module",
    DIRECTORYNOTSUPPORTED: "support for directory entries not defined by module",
    FORMATSET: "archive format already set",
    INPUTSTEAMBUFFERREQUIRED: "input source must be valid Stream or Buffer instance",
    MODULESET: "module already set",
    SYMLINKNOTSUPPORTED: "support for symlink entries not defined by module",
    SYMLINKFILEPATHREQUIRED: "symlink filepath argument must be a non-empty string value",
    SYMLINKTARGETREQUIRED: "symlink target argument must be a non-empty string value",
    ENTRYNOTSUPPORTED: "entry not supported"
  };
  function ArchiverError(code, data) {
    Error.captureStackTrace(this, this.constructor);
    this.message = ERROR_CODES[code] || code;
    this.code = code;
    this.data = data;
  }
  util2.inherits(ArchiverError, Error);
  exports2 = module2.exports = ArchiverError;
});

// ../../node_modules/.pnpm/readable-stream@3.6.0/node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream12 = __commonJS2((exports2, module2) => {
  module2.exports = require("stream");
});

// ../../node_modules/.pnpm/readable-stream@3.6.0/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS2((exports2, module2) => {
  "use strict";
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  var _require = require("buffer");
  var Buffer2 = _require.Buffer;
  var _require2 = require("util");
  var inspect = _require2.inspect;
  var custom = inspect && inspect.custom || "inspect";
  function copyBuffer(src, target, offset) {
    Buffer2.prototype.copy.call(src, target, offset);
  }
  module2.exports = /* @__PURE__ */ function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList, [{
      key: "push",
      value: function push(v) {
        var entry = {
          data: v,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v) {
        var entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join2(s2) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s2 + p.data;
        }
        return ret;
      }
    }, {
      key: "concat",
      value: function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
    }, {
      key: "consume",
      value: function consume(n, hasStrings) {
        var ret;
        if (n < this.head.data.length) {
          ret = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
    }, {
      key: "_getString",
      value: function _getString(n) {
        var p = this.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length)
            ret += str;
          else
            ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n) {
        var ret = Buffer2.allocUnsafe(n);
        var p = this.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
    }, {
      key: custom,
      value: function value(_2, options) {
        return inspect(this, _objectSpread({}, options, {
          depth: 0,
          customInspect: false
        }));
      }
    }]);
    return BufferList;
  }();
});

// ../../node_modules/.pnpm/readable-stream@3.6.0/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy2 = __commonJS2((exports2, module2) => {
  "use strict";
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          process.nextTick(emitErrorAndCloseNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process.nextTick(emitErrorAndCloseNT, _this, err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process.nextTick(emitCloseNT, _this);
        cb(err2);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    });
    return this;
  }
  function emitErrorAndCloseNT(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    if (self2._writableState && !self2._writableState.emitClose)
      return;
    if (self2._readableState && !self2._readableState.emitClose)
      return;
    self2.emit("close");
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  function errorOrDestroy(stream, err) {
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy)
      stream.destroy(err);
    else
      stream.emit("error", err);
  }
  module2.exports = {
    destroy,
    undestroy,
    errorOrDestroy
  };
});

// ../../node_modules/.pnpm/readable-stream@3.6.0/node_modules/readable-stream/errors.js
var require_errors2 = __commonJS2((exports2, module2) => {
  "use strict";
  var codes = {};
  function createErrorType(code, message, Base) {
    if (!Base) {
      Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }
    class NodeError extends Base {
      constructor(arg1, arg2, arg3) {
        super(getMessage(arg1, arg2, arg3));
      }
    }
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
  }
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      const len = expected.length;
      expected = expected.map((i) => String(i));
      if (len > 2) {
        return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
      } else if (len === 2) {
        return `one of ${thing} ${expected[0]} or ${expected[1]}`;
      } else {
        return `of ${thing} ${expected[0]}`;
      }
    } else {
      return `of ${thing} ${String(expected)}`;
    }
  }
  function startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
  }
  function endsWith(str, search, this_len) {
    if (this_len === void 0 || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function includes(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }
  createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    let determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    let msg;
    if (endsWith(name, " argument")) {
      msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
    } else {
      const type = includes(name, ".") ? "property" : "argument";
      msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
    }
    msg += `. Received type ${typeof actual}`;
    return msg;
  }, TypeError);
  createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
    return "The " + name + " method is not implemented";
  });
  createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  createErrorType("ERR_STREAM_DESTROYED", function(name) {
    return "Cannot call " + name + " after a stream was destroyed";
  });
  createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  createErrorType("ERR_UNKNOWN_ENCODING", function(arg2) {
    return "Unknown encoding: " + arg2;
  }, TypeError);
  createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  module2.exports.codes = codes;
});

// ../../node_modules/.pnpm/readable-stream@3.6.0/node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS2((exports2, module2) => {
  "use strict";
  var ERR_INVALID_OPT_VALUE = require_errors2().codes.ERR_INVALID_OPT_VALUE;
  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }
  function getHighWaterMark(state, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name, hwm);
      }
      return Math.floor(hwm);
    }
    return state.objectMode ? 16 : 16 * 1024;
  }
  module2.exports = {
    getHighWaterMark
  };
});

// ../../node_modules/.pnpm/readable-stream@3.6.0/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable2 = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = Writable;
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state);
    };
  }
  var Duplex;
  Writable.WritableState = WritableState;
  var internalUtil = {
    deprecate: require_node6()
  };
  var Stream = require_stream12();
  var Buffer2 = require("buffer").Buffer;
  var OurUint8Array = global.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = require_destroy2();
  var _require = require_state();
  var getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = require_errors2().codes;
  var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
  var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
  var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
  var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
  var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  require_inherits2()(Writable, Stream);
  function nop() {
  }
  function WritableState(options, stream, isDuplex) {
    Duplex = Duplex || require_stream_duplex2();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_2) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function value(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance2(object) {
      return object instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require_stream_duplex2();
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this))
      return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
  };
  function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
  }
  function validChunk(stream, state, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== "string" && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
      return false;
    }
    return true;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state.ending)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableBuffer", {
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed)
      state.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, sync2, er, cb) {
    --state.pendingcb;
    if (sync2) {
      process.nextTick(cb, er);
      process.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
      finishMaybe(stream, state);
    }
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync2 = state.sync;
    var cb = state.writecb;
    if (typeof cb !== "function")
      throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream, state, sync2, er, cb);
    else {
      var finished = needFinish(state) || stream.destroyed;
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }
      if (sync2) {
        process.nextTick(afterWrite, stream, state, finished, cb);
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  }
  function afterWrite(stream, state, finished, cb) {
    if (!finished)
      onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l = state.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream, state, true, state.length, buffer, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0)
      this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending)
      endWritable(this, state, cb);
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableLength", {
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function callFinal(stream, state) {
    stream._final(function(err) {
      state.pendingcb--;
      if (err) {
        errorOrDestroy(stream, err);
      }
      state.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state);
    });
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === "function" && !state.destroyed) {
        state.pendingcb++;
        state.finalCalled = true;
        process.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit("finish");
        if (state.autoDestroy) {
          var rState = stream._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished)
        process.nextTick(cb);
      else
        stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    cb(err);
  };
});

// ../../node_modules/.pnpm/readable-stream@3.6.0/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex2 = __commonJS2((exports2, module2) => {
  "use strict";
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  module2.exports = Duplex;
  var Readable = require_stream_readable2();
  var Writable = require_stream_writable2();
  require_inherits2()(Duplex, Readable);
  {
    keys = objectKeys(Writable.prototype);
    for (v = 0; v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  var keys;
  var method;
  var v;
  function Duplex(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false)
        this.readable = false;
      if (options.writable === false)
        this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex.prototype, "writableBuffer", {
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex.prototype, "writableLength", {
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended)
      return;
    process.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
});

// ../../node_modules/.pnpm/readable-stream@3.6.0/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS2((exports2, module2) => {
  "use strict";
  var ERR_STREAM_PREMATURE_CLOSE = require_errors2().codes.ERR_STREAM_PREMATURE_CLOSE;
  function once(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.apply(this, args);
    };
  }
  function noop() {
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function eos(stream, opts, callback) {
    if (typeof opts === "function")
      return eos(stream, null, opts);
    if (!opts)
      opts = {};
    callback = once(callback || noop);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish2() {
      if (!stream.writable)
        onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish2() {
      writable = false;
      writableEnded = true;
      if (!readable)
        callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend2() {
      readable = false;
      readableEnded = true;
      if (!writable)
        callback.call(stream);
    };
    var onerror = function onerror2(err) {
      callback.call(stream, err);
    };
    var onclose = function onclose2() {
      var err;
      if (readable && !readableEnded) {
        if (!stream._readableState || !stream._readableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
      if (writable && !writableEnded) {
        if (!stream._writableState || !stream._writableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
    };
    var onrequest = function onrequest2() {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req)
        onrequest();
      else
        stream.on("request", onrequest);
    } else if (writable && !stream._writableState) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false)
      stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req)
        stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  }
  module2.exports = eos;
});

// ../../node_modules/.pnpm/readable-stream@3.6.0/node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS2((exports2, module2) => {
  "use strict";
  var _Object$setPrototypeO;
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var finished = require_end_of_stream();
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult(value, done) {
    return {
      value,
      done
    };
  }
  function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
      var data = iter[kStream].read();
      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve(createIterResult(data, false));
      }
    }
  }
  function onReadable(iter) {
    process.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve(createIterResult(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error = this[kError];
      if (error !== null) {
        return Promise.reject(error);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve, reject) {
          process.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve(createIterResult(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data = this[kStream].read();
        if (data !== null) {
          return Promise.resolve(createIterResult(data, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve(createIterResult(void 0, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve, reject) {
        var data = iterator[kStream].read();
        if (data) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(data, false));
        } else {
          iterator[kLastResolve] = resolve;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator[kLastReject];
        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err);
        }
        iterator[kError] = err;
        return;
      }
      var resolve = iterator[kLastResolve];
      if (resolve !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(void 0, true));
      }
      iterator[kEnded] = true;
    });
    stream.on("readable", onReadable.bind(null, iterator));
    return iterator;
  };
  module2.exports = createReadableStreamAsyncIterator;
});

// ../../node_modules/.pnpm/readable-stream@3.6.0/node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS2((exports2, module2) => {
  "use strict";
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg2) {
    try {
      var info = gen[key](arg2);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function() {
      var self2 = this, args = arguments;
      return new Promise(function(resolve, reject) {
        var gen = fn.apply(self2, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(void 0);
      });
    };
  }
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var ERR_INVALID_ARG_TYPE = require_errors2().codes.ERR_INVALID_ARG_TYPE;
  function from(Readable, iterable, opts) {
    var iterator;
    if (iterable && typeof iterable.next === "function") {
      iterator = iterable;
    } else if (iterable && iterable[Symbol.asyncIterator])
      iterator = iterable[Symbol.asyncIterator]();
    else if (iterable && iterable[Symbol.iterator])
      iterator = iterable[Symbol.iterator]();
    else
      throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
    var readable = new Readable(_objectSpread({
      objectMode: true
    }, opts));
    var reading = false;
    readable._read = function() {
      if (!reading) {
        reading = true;
        next();
      }
    };
    function next() {
      return _next2.apply(this, arguments);
    }
    function _next2() {
      _next2 = _asyncToGenerator(function* () {
        try {
          var _ref = yield iterator.next(), value = _ref.value, done = _ref.done;
          if (done) {
            readable.push(null);
          } else if (readable.push(yield value)) {
            next();
          } else {
            reading = false;
          }
        } catch (err) {
          readable.destroy(err);
        }
      });
      return _next2.apply(this, arguments);
    }
    return readable;
  }
  module2.exports = from;
});

// ../../node_modules/.pnpm/readable-stream@3.6.0/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable2 = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = Readable;
  var Duplex;
  Readable.ReadableState = ReadableState;
  var EE = require("events").EventEmitter;
  var EElistenerCount = function EElistenerCount2(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream = require_stream12();
  var Buffer2 = require("buffer").Buffer;
  var OurUint8Array = global.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var debugUtil = require("util");
  var debug4;
  if (debugUtil && debugUtil.debuglog) {
    debug4 = debugUtil.debuglog("stream");
  } else {
    debug4 = function debug5() {
    };
  }
  var BufferList = require_buffer_list();
  var destroyImpl = require_destroy2();
  var _require = require_state();
  var getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = require_errors2().codes;
  var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
  var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;
  require_inherits2()(Readable, Stream);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream, isDuplex) {
    Duplex = Duplex || require_stream_duplex2();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = require("string_decoder/").StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex = Duplex || require_stream_duplex2();
    if (!(this instanceof Readable))
      return new Readable(options);
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug4("readableAddChunk", chunk);
    var state = stream._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state, chunk);
      if (er) {
        errorOrDestroy(stream, er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state.endEmitted)
            errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed) {
          return false;
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
        maybeReadMore(stream, state);
      }
    }
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      state.awaitDrain = 0;
      stream.emit("data", chunk);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if (state.needReadable)
        emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = require("string_decoder/").StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p = this._readableState.buffer.head;
    var content = "";
    while (p !== null) {
      content += decoder.write(p.data);
      p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== "")
      this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n !== n) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length)
      return n;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  Readable.prototype.read = function(n) {
    debug4("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0)
      state.emittedReadable = false;
    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
      debug4("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug4("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug4("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug4("reading or ended", doRead);
    } else if (doRead) {
      debug4("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0)
        state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading)
        n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0)
      ret = fromList(n, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = state.length <= state.highWaterMark;
      n = 0;
    } else {
      state.length -= n;
      state.awaitDrain = 0;
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state) {
    debug4("onEofChunk");
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    if (state.sync) {
      emitReadable(stream);
    } else {
      state.needReadable = false;
      if (!state.emittedReadable) {
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
  }
  function emitReadable(stream) {
    var state = stream._readableState;
    debug4("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug4("emitReadable", state.flowing);
      state.emittedReadable = true;
      process.nextTick(emitReadable_, stream);
    }
  }
  function emitReadable_(stream) {
    var state = stream._readableState;
    debug4("emitReadable_", state.destroyed, state.length, state.ended);
    if (!state.destroyed && (state.length || state.ended)) {
      stream.emit("readable");
      state.emittedReadable = false;
    }
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      process.nextTick(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
      var len = state.length;
      debug4("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
    }
    state.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug4("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      process.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug4("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup2();
        }
      }
    }
    function onend() {
      debug4("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup2() {
      debug4("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug4("ondata");
      var ret = dest.write(chunk);
      debug4("dest.write", ret);
      if (ret === false) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug4("false write response, pause", state.awaitDrain);
          state.awaitDrain++;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug4("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        errorOrDestroy(dest, er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug4("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug4("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug4("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
      var state = src._readableState;
      debug4("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i = 0; i < len; i++) {
        dests[i].emit("unpipe", this, {
          hasUnpiped: false
        });
      }
      return this;
    }
    var index = indexOf(state.pipes, dest);
    if (index === -1)
      return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
      state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state = this._readableState;
    if (ev === "data") {
      state.readableListening = this.listenerCount("readable") > 0;
      if (state.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.flowing = false;
        state.emittedReadable = false;
        debug4("on readable", state.length, state.reading);
        if (state.length) {
          emitReadable(this);
        } else if (!state.reading) {
          process.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  Readable.prototype.removeListener = function(ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === void 0) {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    var state = self2._readableState;
    state.readableListening = self2.listenerCount("readable") > 0;
    if (state.resumeScheduled && !state.paused) {
      state.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug4("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug4("resume");
      state.flowing = !state.readableListening;
      resume(this, state);
    }
    state.paused = false;
    return this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      process.nextTick(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    debug4("resume", state.reading);
    if (!state.reading) {
      stream.read(0);
    }
    state.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading)
      stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug4("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug4("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream) {
    var state = stream._readableState;
    debug4("flow", state.flowing);
    while (state.flowing && stream.read() !== null) {
      ;
    }
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug4("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug4("wrapped data");
      if (state.decoder)
        chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === void 0))
        return;
      else if (!state.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i in stream) {
      if (this[i] === void 0 && typeof stream[i] === "function") {
        this[i] = function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug4("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === void 0) {
        createReadableStreamAsyncIterator = require_async_iterator();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable.prototype, "readableBuffer", {
    enumerable: false,
    get: function get() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable.prototype, "readableFlowing", {
    enumerable: false,
    get: function get() {
      return this._readableState.flowing;
    },
    set: function set(state) {
      if (this._readableState) {
        this._readableState.flowing = state;
      }
    }
  });
  Readable._fromList = fromList;
  Object.defineProperty(Readable.prototype, "readableLength", {
    enumerable: false,
    get: function get() {
      return this._readableState.length;
    }
  });
  function fromList(n, state) {
    if (state.length === 0)
      return null;
    var ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n || n >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.first();
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = state.buffer.consume(n, state.decoder);
    }
    return ret;
  }
  function endReadable(stream) {
    var state = stream._readableState;
    debug4("endReadable", state.endEmitted);
    if (!state.endEmitted) {
      state.ended = true;
      process.nextTick(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    debug4("endReadableNT", state.endEmitted, state.length);
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
      if (state.autoDestroy) {
        var wState = stream._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream.destroy();
        }
      }
    }
  }
  if (typeof Symbol === "function") {
    Readable.from = function(iterable, opts) {
      if (from === void 0) {
        from = require_from();
      }
      return from(Readable, iterable, opts);
    };
  }
  function indexOf(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x)
        return i;
    }
    return -1;
  }
});

// ../../node_modules/.pnpm/readable-stream@3.6.0/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform2 = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = Transform;
  var _require$codes = require_errors2().codes;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
  var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
  var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex = require_stream_duplex2();
  require_inherits2()(Transform, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
      return this.emit("error", new ERR_MULTIPLE_CALLBACK());
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform))
      return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
    });
  };
  function done(stream, er, data) {
    if (er)
      return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length)
      throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream._transformState.transforming)
      throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream.push(null);
  }
});

// ../../node_modules/.pnpm/readable-stream@3.6.0/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough2 = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = PassThrough;
  var Transform = require_stream_transform2();
  require_inherits2()(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
});

// ../../node_modules/.pnpm/readable-stream@3.6.0/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS2((exports2, module2) => {
  "use strict";
  var eos;
  function once(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      callback.apply(void 0, arguments);
    };
  }
  var _require$codes = require_errors2().codes;
  var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
  var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  function noop(err) {
    if (err)
      throw err;
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function destroyer(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on("close", function() {
      closed = true;
    });
    if (eos === void 0)
      eos = require_end_of_stream();
    eos(stream, {
      readable: reading,
      writable: writing
    }, function(err) {
      if (err)
        return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed)
        return;
      if (destroyed)
        return;
      destroyed = true;
      if (isRequest(stream))
        return stream.abort();
      if (typeof stream.destroy === "function")
        return stream.destroy();
      callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
  }
  function call(fn) {
    fn();
  }
  function pipe(from, to) {
    return from.pipe(to);
  }
  function popCallback(streams) {
    if (!streams.length)
      return noop;
    if (typeof streams[streams.length - 1] !== "function")
      return noop;
    return streams.pop();
  }
  function pipeline() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
      streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0]))
      streams = streams[0];
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    var error;
    var destroys = streams.map(function(stream, i) {
      var reading = i < streams.length - 1;
      var writing = i > 0;
      return destroyer(stream, reading, writing, function(err) {
        if (!error)
          error = err;
        if (err)
          destroys.forEach(call);
        if (reading)
          return;
        destroys.forEach(call);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  }
  module2.exports = pipeline;
});

// ../../node_modules/.pnpm/readable-stream@3.6.0/node_modules/readable-stream/readable.js
var require_readable2 = __commonJS2((exports2, module2) => {
  var Stream = require("stream");
  if (process.env.READABLE_STREAM === "disable" && Stream) {
    module2.exports = Stream.Readable;
    Object.assign(module2.exports, Stream);
    module2.exports.Stream = Stream;
  } else {
    exports2 = module2.exports = require_stream_readable2();
    exports2.Stream = Stream || exports2;
    exports2.Readable = exports2;
    exports2.Writable = require_stream_writable2();
    exports2.Duplex = require_stream_duplex2();
    exports2.Transform = require_stream_transform2();
    exports2.PassThrough = require_stream_passthrough2();
    exports2.finished = require_end_of_stream();
    exports2.pipeline = require_pipeline();
  }
});

// ../../node_modules/.pnpm/archiver@4.0.2/node_modules/archiver/lib/core.js
var require_core6 = __commonJS2((exports2, module2) => {
  /**
   * Archiver Core
   *
   * @ignore
   * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
   * @copyright (c) 2012-2014 Chris Talkington, contributors.
   */
  var fs2 = require("fs");
  var glob = require_glob2();
  var async = require_async12();
  var path4 = require("path");
  var util2 = require_archiver_utils();
  var inherits = require("util").inherits;
  var ArchiverError = require_error5();
  var Transform = require_readable2().Transform;
  var win32 = process.platform === "win32";
  var Archiver = function(format2, options) {
    if (!(this instanceof Archiver)) {
      return new Archiver(format2, options);
    }
    if (typeof format2 !== "string") {
      options = format2;
      format2 = "zip";
    }
    options = this.options = util2.defaults(options, {
      highWaterMark: 1024 * 1024,
      statConcurrency: 4
    });
    Transform.call(this, options);
    this._format = false;
    this._module = false;
    this._pending = 0;
    this._pointer = 0;
    this._entriesCount = 0;
    this._entriesProcessedCount = 0;
    this._fsEntriesTotalBytes = 0;
    this._fsEntriesProcessedBytes = 0;
    this._queue = async.queue(this._onQueueTask.bind(this), 1);
    this._queue.drain(this._onQueueDrain.bind(this));
    this._statQueue = async.queue(this._onStatQueueTask.bind(this), options.statConcurrency);
    this._statQueue.drain(this._onQueueDrain.bind(this));
    this._state = {
      aborted: false,
      finalize: false,
      finalizing: false,
      finalized: false,
      modulePiped: false
    };
    this._streams = [];
  };
  inherits(Archiver, Transform);
  Archiver.prototype._abort = function() {
    this._state.aborted = true;
    this._queue.kill();
    this._statQueue.kill();
    if (this._queue.idle()) {
      this._shutdown();
    }
  };
  Archiver.prototype._append = function(filepath, data) {
    data = data || {};
    var task = {
      source: null,
      filepath
    };
    if (!data.name) {
      data.name = filepath;
    }
    data.sourcePath = filepath;
    task.data = data;
    this._entriesCount++;
    if (data.stats && data.stats instanceof fs2.Stats) {
      task = this._updateQueueTaskWithStats(task, data.stats);
      if (task) {
        if (data.stats.size) {
          this._fsEntriesTotalBytes += data.stats.size;
        }
        this._queue.push(task);
      }
    } else {
      this._statQueue.push(task);
    }
  };
  Archiver.prototype._finalize = function() {
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
      return;
    }
    this._state.finalizing = true;
    this._moduleFinalize();
    this._state.finalizing = false;
    this._state.finalized = true;
  };
  Archiver.prototype._maybeFinalize = function() {
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
      return false;
    }
    if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {
      this._finalize();
      return true;
    }
    return false;
  };
  Archiver.prototype._moduleAppend = function(source, data, callback) {
    if (this._state.aborted) {
      callback();
      return;
    }
    this._module.append(source, data, function(err) {
      this._task = null;
      if (this._state.aborted) {
        this._shutdown();
        return;
      }
      if (err) {
        this.emit("error", err);
        setImmediate(callback);
        return;
      }
      this.emit("entry", data);
      this._entriesProcessedCount++;
      if (data.stats && data.stats.size) {
        this._fsEntriesProcessedBytes += data.stats.size;
      }
      this.emit("progress", {
        entries: {
          total: this._entriesCount,
          processed: this._entriesProcessedCount
        },
        fs: {
          totalBytes: this._fsEntriesTotalBytes,
          processedBytes: this._fsEntriesProcessedBytes
        }
      });
      setImmediate(callback);
    }.bind(this));
  };
  Archiver.prototype._moduleFinalize = function() {
    if (typeof this._module.finalize === "function") {
      this._module.finalize();
    } else if (typeof this._module.end === "function") {
      this._module.end();
    } else {
      this.emit("error", new ArchiverError("NOENDMETHOD"));
    }
  };
  Archiver.prototype._modulePipe = function() {
    this._module.on("error", this._onModuleError.bind(this));
    this._module.pipe(this);
    this._state.modulePiped = true;
  };
  Archiver.prototype._moduleSupports = function(key) {
    if (!this._module.supports || !this._module.supports[key]) {
      return false;
    }
    return this._module.supports[key];
  };
  Archiver.prototype._moduleUnpipe = function() {
    this._module.unpipe(this);
    this._state.modulePiped = false;
  };
  Archiver.prototype._normalizeEntryData = function(data, stats) {
    data = util2.defaults(data, {
      type: "file",
      name: null,
      date: null,
      mode: null,
      prefix: null,
      sourcePath: null,
      stats: false
    });
    if (stats && data.stats === false) {
      data.stats = stats;
    }
    var isDir = data.type === "directory";
    if (data.name) {
      if (typeof data.prefix === "string" && data.prefix !== "") {
        data.name = data.prefix + "/" + data.name;
        data.prefix = null;
      }
      data.name = util2.sanitizePath(data.name);
      if (data.type !== "symlink" && data.name.slice(-1) === "/") {
        isDir = true;
        data.type = "directory";
      } else if (isDir) {
        data.name += "/";
      }
    }
    if (typeof data.mode === "number") {
      if (win32) {
        data.mode &= 511;
      } else {
        data.mode &= 4095;
      }
    } else if (data.stats && data.mode === null) {
      if (win32) {
        data.mode = data.stats.mode & 511;
      } else {
        data.mode = data.stats.mode & 4095;
      }
      if (win32 && isDir) {
        data.mode = 493;
      }
    } else if (data.mode === null) {
      data.mode = isDir ? 493 : 420;
    }
    if (data.stats && data.date === null) {
      data.date = data.stats.mtime;
    } else {
      data.date = util2.dateify(data.date);
    }
    return data;
  };
  Archiver.prototype._onModuleError = function(err) {
    this.emit("error", err);
  };
  Archiver.prototype._onQueueDrain = function() {
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
      return;
    }
    if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {
      this._finalize();
    }
  };
  Archiver.prototype._onQueueTask = function(task, callback) {
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
      callback();
      return;
    }
    this._task = task;
    this._moduleAppend(task.source, task.data, callback);
  };
  Archiver.prototype._onStatQueueTask = function(task, callback) {
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
      callback();
      return;
    }
    fs2.lstat(task.filepath, function(err, stats) {
      if (this._state.aborted) {
        setImmediate(callback);
        return;
      }
      if (err) {
        this._entriesCount--;
        this.emit("warning", err);
        setImmediate(callback);
        return;
      }
      task = this._updateQueueTaskWithStats(task, stats);
      if (task) {
        if (stats.size) {
          this._fsEntriesTotalBytes += stats.size;
        }
        this._queue.push(task);
      }
      setImmediate(callback);
    }.bind(this));
  };
  Archiver.prototype._shutdown = function() {
    this._moduleUnpipe();
    this.end();
  };
  Archiver.prototype._transform = function(chunk, encoding, callback) {
    if (chunk) {
      this._pointer += chunk.length;
    }
    callback(null, chunk);
  };
  Archiver.prototype._updateQueueTaskWithStats = function(task, stats) {
    if (stats.isFile()) {
      task.data.type = "file";
      task.data.sourceType = "stream";
      task.source = util2.lazyReadStream(task.filepath);
    } else if (stats.isDirectory() && this._moduleSupports("directory")) {
      task.data.name = util2.trailingSlashIt(task.data.name);
      task.data.type = "directory";
      task.data.sourcePath = util2.trailingSlashIt(task.filepath);
      task.data.sourceType = "buffer";
      task.source = Buffer.concat([]);
    } else if (stats.isSymbolicLink() && this._moduleSupports("symlink")) {
      var linkPath = fs2.readlinkSync(task.filepath);
      var dirName = path4.dirname(task.filepath);
      task.data.type = "symlink";
      task.data.linkname = path4.relative(dirName, path4.resolve(dirName, linkPath));
      task.data.sourceType = "buffer";
      task.source = Buffer.concat([]);
    } else {
      if (stats.isDirectory()) {
        this.emit("warning", new ArchiverError("DIRECTORYNOTSUPPORTED", task.data));
      } else if (stats.isSymbolicLink()) {
        this.emit("warning", new ArchiverError("SYMLINKNOTSUPPORTED", task.data));
      } else {
        this.emit("warning", new ArchiverError("ENTRYNOTSUPPORTED", task.data));
      }
      return null;
    }
    task.data = this._normalizeEntryData(task.data, stats);
    return task;
  };
  Archiver.prototype.abort = function() {
    if (this._state.aborted || this._state.finalized) {
      return this;
    }
    this._abort();
    return this;
  };
  Archiver.prototype.append = function(source, data) {
    if (this._state.finalize || this._state.aborted) {
      this.emit("error", new ArchiverError("QUEUECLOSED"));
      return this;
    }
    data = this._normalizeEntryData(data);
    if (typeof data.name !== "string" || data.name.length === 0) {
      this.emit("error", new ArchiverError("ENTRYNAMEREQUIRED"));
      return this;
    }
    if (data.type === "directory" && !this._moduleSupports("directory")) {
      this.emit("error", new ArchiverError("DIRECTORYNOTSUPPORTED", {name: data.name}));
      return this;
    }
    source = util2.normalizeInputSource(source);
    if (Buffer.isBuffer(source)) {
      data.sourceType = "buffer";
    } else if (util2.isStream(source)) {
      data.sourceType = "stream";
    } else {
      this.emit("error", new ArchiverError("INPUTSTEAMBUFFERREQUIRED", {name: data.name}));
      return this;
    }
    this._entriesCount++;
    this._queue.push({
      data,
      source
    });
    return this;
  };
  Archiver.prototype.directory = function(dirpath, destpath, data) {
    if (this._state.finalize || this._state.aborted) {
      this.emit("error", new ArchiverError("QUEUECLOSED"));
      return this;
    }
    if (typeof dirpath !== "string" || dirpath.length === 0) {
      this.emit("error", new ArchiverError("DIRECTORYDIRPATHREQUIRED"));
      return this;
    }
    this._pending++;
    if (destpath === false) {
      destpath = "";
    } else if (typeof destpath !== "string") {
      destpath = dirpath;
    }
    var dataFunction = false;
    if (typeof data === "function") {
      dataFunction = data;
      data = {};
    } else if (typeof data !== "object") {
      data = {};
    }
    var globOptions = {
      stat: false,
      dot: true,
      cwd: dirpath
    };
    function onGlobEnd() {
      this._pending--;
      this._maybeFinalize();
    }
    function onGlobError(err) {
      this.emit("error", err);
    }
    function onGlobMatch(match) {
      var ignoreMatch = false;
      var entryData = Object.assign({}, data);
      entryData.name = match;
      entryData.prefix = destpath;
      match = globber._makeAbs(match);
      try {
        if (dataFunction) {
          entryData = dataFunction(entryData);
          if (entryData === false) {
            ignoreMatch = true;
          } else if (typeof entryData !== "object") {
            throw new ArchiverError("DIRECTORYFUNCTIONINVALIDDATA", {dirpath});
          }
        }
      } catch (e) {
        this.emit("error", e);
        return;
      }
      if (ignoreMatch) {
        return;
      }
      this._append(match, entryData);
    }
    var globber = glob("**", globOptions);
    globber.on("error", onGlobError.bind(this));
    globber.on("match", onGlobMatch.bind(this));
    globber.on("end", onGlobEnd.bind(this));
    return this;
  };
  Archiver.prototype.file = function(filepath, data) {
    if (this._state.finalize || this._state.aborted) {
      this.emit("error", new ArchiverError("QUEUECLOSED"));
      return this;
    }
    if (typeof filepath !== "string" || filepath.length === 0) {
      this.emit("error", new ArchiverError("FILEFILEPATHREQUIRED"));
      return this;
    }
    this._append(filepath, data);
    return this;
  };
  Archiver.prototype.glob = function(pattern, options, data) {
    this._pending++;
    options = util2.defaults(options, {
      stat: false
    });
    function onGlobEnd() {
      this._pending--;
      this._maybeFinalize();
    }
    function onGlobError(err) {
      this.emit("error", err);
    }
    function onGlobMatch(match) {
      var entryData = Object.assign({}, data);
      if (options.cwd) {
        entryData.name = match;
        match = globber._makeAbs(match);
      }
      this._append(match, entryData);
    }
    var globber = glob(pattern, options);
    globber.on("error", onGlobError.bind(this));
    globber.on("match", onGlobMatch.bind(this));
    globber.on("end", onGlobEnd.bind(this));
    return this;
  };
  Archiver.prototype.finalize = function() {
    if (this._state.aborted) {
      this.emit("error", new ArchiverError("ABORTED"));
      return this;
    }
    if (this._state.finalize) {
      this.emit("error", new ArchiverError("FINALIZING"));
      return this;
    }
    this._state.finalize = true;
    if (this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {
      this._finalize();
    }
    var self2 = this;
    return new Promise(function(resolve, reject) {
      var errored;
      self2._module.on("end", function() {
        if (!errored) {
          resolve();
        }
      });
      self2._module.on("error", function(err) {
        errored = true;
        reject(err);
      });
    });
  };
  Archiver.prototype.setFormat = function(format2) {
    if (this._format) {
      this.emit("error", new ArchiverError("FORMATSET"));
      return this;
    }
    this._format = format2;
    return this;
  };
  Archiver.prototype.setModule = function(module3) {
    if (this._state.aborted) {
      this.emit("error", new ArchiverError("ABORTED"));
      return this;
    }
    if (this._state.module) {
      this.emit("error", new ArchiverError("MODULESET"));
      return this;
    }
    this._module = module3;
    this._modulePipe();
    return this;
  };
  Archiver.prototype.symlink = function(filepath, target) {
    if (this._state.finalize || this._state.aborted) {
      this.emit("error", new ArchiverError("QUEUECLOSED"));
      return this;
    }
    if (typeof filepath !== "string" || filepath.length === 0) {
      this.emit("error", new ArchiverError("SYMLINKFILEPATHREQUIRED"));
      return this;
    }
    if (typeof target !== "string" || target.length === 0) {
      this.emit("error", new ArchiverError("SYMLINKTARGETREQUIRED", {filepath}));
      return this;
    }
    if (!this._moduleSupports("symlink")) {
      this.emit("error", new ArchiverError("SYMLINKNOTSUPPORTED", {filepath}));
      return this;
    }
    var data = {};
    data.type = "symlink";
    data.name = filepath.replace(/\\/g, "/");
    data.linkname = target.replace(/\\/g, "/");
    data.sourceType = "buffer";
    this._entriesCount++;
    this._queue.push({
      data,
      source: Buffer.concat([])
    });
    return this;
  };
  Archiver.prototype.pointer = function() {
    return this._pointer;
  };
  Archiver.prototype.use = function(plugin) {
    this._streams.push(plugin);
    return this;
  };
  module2.exports = Archiver;
});

// ../../node_modules/.pnpm/compress-commons@3.0.0/node_modules/compress-commons/lib/archivers/archive-entry.js
var require_archive_entry = __commonJS2((exports2, module2) => {
  var ArchiveEntry = module2.exports = function() {
  };
  ArchiveEntry.prototype.getName = function() {
  };
  ArchiveEntry.prototype.getSize = function() {
  };
  ArchiveEntry.prototype.getLastModifiedDate = function() {
  };
  ArchiveEntry.prototype.isDirectory = function() {
  };
});

// ../../node_modules/.pnpm/compress-commons@3.0.0/node_modules/compress-commons/lib/archivers/zip/util.js
var require_util8 = __commonJS2((exports2, module2) => {
  var util2 = module2.exports = {};
  util2.dateToDos = function(d2, forceLocalTime) {
    forceLocalTime = forceLocalTime || false;
    var year = forceLocalTime ? d2.getFullYear() : d2.getUTCFullYear();
    if (year < 1980) {
      return 2162688;
    } else if (year >= 2044) {
      return 2141175677;
    }
    var val = {
      year,
      month: forceLocalTime ? d2.getMonth() : d2.getUTCMonth(),
      date: forceLocalTime ? d2.getDate() : d2.getUTCDate(),
      hours: forceLocalTime ? d2.getHours() : d2.getUTCHours(),
      minutes: forceLocalTime ? d2.getMinutes() : d2.getUTCMinutes(),
      seconds: forceLocalTime ? d2.getSeconds() : d2.getUTCSeconds()
    };
    return val.year - 1980 << 25 | val.month + 1 << 21 | val.date << 16 | val.hours << 11 | val.minutes << 5 | val.seconds / 2;
  };
  util2.dosToDate = function(dos) {
    return new Date((dos >> 25 & 127) + 1980, (dos >> 21 & 15) - 1, dos >> 16 & 31, dos >> 11 & 31, dos >> 5 & 63, (dos & 31) << 1);
  };
  util2.fromDosTime = function(buf) {
    return util2.dosToDate(buf.readUInt32LE(0));
  };
  util2.getEightBytes = function(v) {
    var buf = Buffer.alloc(8);
    buf.writeUInt32LE(v % 4294967296, 0);
    buf.writeUInt32LE(v / 4294967296 | 0, 4);
    return buf;
  };
  util2.getShortBytes = function(v) {
    var buf = Buffer.alloc(2);
    buf.writeUInt16LE((v & 65535) >>> 0, 0);
    return buf;
  };
  util2.getShortBytesValue = function(buf, offset) {
    return buf.readUInt16LE(offset);
  };
  util2.getLongBytes = function(v) {
    var buf = Buffer.alloc(4);
    buf.writeUInt32LE((v & 4294967295) >>> 0, 0);
    return buf;
  };
  util2.getLongBytesValue = function(buf, offset) {
    return buf.readUInt32LE(offset);
  };
  util2.toDosTime = function(d2) {
    return util2.getLongBytes(util2.dateToDos(d2));
  };
});

// ../../node_modules/.pnpm/compress-commons@3.0.0/node_modules/compress-commons/lib/archivers/zip/general-purpose-bit.js
var require_general_purpose_bit = __commonJS2((exports2, module2) => {
  var zipUtil = require_util8();
  var DATA_DESCRIPTOR_FLAG = 1 << 3;
  var ENCRYPTION_FLAG = 1 << 0;
  var NUMBER_OF_SHANNON_FANO_TREES_FLAG = 1 << 2;
  var SLIDING_DICTIONARY_SIZE_FLAG = 1 << 1;
  var STRONG_ENCRYPTION_FLAG = 1 << 6;
  var UFT8_NAMES_FLAG = 1 << 11;
  var GeneralPurposeBit = module2.exports = function() {
    if (!(this instanceof GeneralPurposeBit)) {
      return new GeneralPurposeBit();
    }
    this.descriptor = false;
    this.encryption = false;
    this.utf8 = false;
    this.numberOfShannonFanoTrees = 0;
    this.strongEncryption = false;
    this.slidingDictionarySize = 0;
    return this;
  };
  GeneralPurposeBit.prototype.encode = function() {
    return zipUtil.getShortBytes((this.descriptor ? DATA_DESCRIPTOR_FLAG : 0) | (this.utf8 ? UFT8_NAMES_FLAG : 0) | (this.encryption ? ENCRYPTION_FLAG : 0) | (this.strongEncryption ? STRONG_ENCRYPTION_FLAG : 0));
  };
  GeneralPurposeBit.prototype.parse = function(buf, offset) {
    var flag = zipUtil.getShortBytesValue(buf, offset);
    var gbp = new GeneralPurposeBit();
    gbp.useDataDescriptor((flag & DATA_DESCRIPTOR_FLAG) !== 0);
    gbp.useUTF8ForNames((flag & UFT8_NAMES_FLAG) !== 0);
    gbp.useStrongEncryption((flag & STRONG_ENCRYPTION_FLAG) !== 0);
    gbp.useEncryption((flag & ENCRYPTION_FLAG) !== 0);
    gbp.setSlidingDictionarySize((flag & SLIDING_DICTIONARY_SIZE_FLAG) !== 0 ? 8192 : 4096);
    gbp.setNumberOfShannonFanoTrees((flag & NUMBER_OF_SHANNON_FANO_TREES_FLAG) !== 0 ? 3 : 2);
    return gbp;
  };
  GeneralPurposeBit.prototype.setNumberOfShannonFanoTrees = function(n) {
    this.numberOfShannonFanoTrees = n;
  };
  GeneralPurposeBit.prototype.getNumberOfShannonFanoTrees = function() {
    return this.numberOfShannonFanoTrees;
  };
  GeneralPurposeBit.prototype.setSlidingDictionarySize = function(n) {
    this.slidingDictionarySize = n;
  };
  GeneralPurposeBit.prototype.getSlidingDictionarySize = function() {
    return this.slidingDictionarySize;
  };
  GeneralPurposeBit.prototype.useDataDescriptor = function(b) {
    this.descriptor = b;
  };
  GeneralPurposeBit.prototype.usesDataDescriptor = function() {
    return this.descriptor;
  };
  GeneralPurposeBit.prototype.useEncryption = function(b) {
    this.encryption = b;
  };
  GeneralPurposeBit.prototype.usesEncryption = function() {
    return this.encryption;
  };
  GeneralPurposeBit.prototype.useStrongEncryption = function(b) {
    this.strongEncryption = b;
  };
  GeneralPurposeBit.prototype.usesStrongEncryption = function() {
    return this.strongEncryption;
  };
  GeneralPurposeBit.prototype.useUTF8ForNames = function(b) {
    this.utf8 = b;
  };
  GeneralPurposeBit.prototype.usesUTF8ForNames = function() {
    return this.utf8;
  };
});

// ../../node_modules/.pnpm/compress-commons@3.0.0/node_modules/compress-commons/lib/archivers/zip/unix-stat.js
var require_unix_stat = __commonJS2((exports2, module2) => {
  module2.exports = {
    PERM_MASK: 4095,
    FILE_TYPE_FLAG: 61440,
    LINK_FLAG: 40960,
    FILE_FLAG: 32768,
    DIR_FLAG: 16384,
    DEFAULT_LINK_PERM: 511,
    DEFAULT_DIR_PERM: 493,
    DEFAULT_FILE_PERM: 420
  };
});

// ../../node_modules/.pnpm/compress-commons@3.0.0/node_modules/compress-commons/lib/archivers/zip/constants.js
var require_constants9 = __commonJS2((exports2, module2) => {
  module2.exports = {
    WORD: 4,
    DWORD: 8,
    EMPTY: Buffer.alloc(0),
    SHORT: 2,
    SHORT_MASK: 65535,
    SHORT_SHIFT: 16,
    SHORT_ZERO: Buffer.from(Array(2)),
    LONG: 4,
    LONG_ZERO: Buffer.from(Array(4)),
    MIN_VERSION_INITIAL: 10,
    MIN_VERSION_DATA_DESCRIPTOR: 20,
    MIN_VERSION_ZIP64: 45,
    VERSION_MADEBY: 45,
    METHOD_STORED: 0,
    METHOD_DEFLATED: 8,
    PLATFORM_UNIX: 3,
    PLATFORM_FAT: 0,
    SIG_LFH: 67324752,
    SIG_DD: 134695760,
    SIG_CFH: 33639248,
    SIG_EOCD: 101010256,
    SIG_ZIP64_EOCD: 101075792,
    SIG_ZIP64_EOCD_LOC: 117853008,
    ZIP64_MAGIC_SHORT: 65535,
    ZIP64_MAGIC: 4294967295,
    ZIP64_EXTRA_ID: 1,
    ZLIB_NO_COMPRESSION: 0,
    ZLIB_BEST_SPEED: 1,
    ZLIB_BEST_COMPRESSION: 9,
    ZLIB_DEFAULT_COMPRESSION: -1,
    MODE_MASK: 4095,
    DEFAULT_FILE_MODE: 33188,
    DEFAULT_DIR_MODE: 16877,
    EXT_FILE_ATTR_DIR: 1106051088,
    EXT_FILE_ATTR_FILE: 2175008800,
    S_IFMT: 61440,
    S_IFIFO: 4096,
    S_IFCHR: 8192,
    S_IFDIR: 16384,
    S_IFBLK: 24576,
    S_IFREG: 32768,
    S_IFLNK: 40960,
    S_IFSOCK: 49152,
    S_DOS_A: 32,
    S_DOS_D: 16,
    S_DOS_V: 8,
    S_DOS_S: 4,
    S_DOS_H: 2,
    S_DOS_R: 1
  };
});

// ../../node_modules/.pnpm/compress-commons@3.0.0/node_modules/compress-commons/lib/archivers/zip/zip-archive-entry.js
var require_zip_archive_entry = __commonJS2((exports2, module2) => {
  var inherits = require("util").inherits;
  var normalizePath = require_normalize_path();
  var ArchiveEntry = require_archive_entry();
  var GeneralPurposeBit = require_general_purpose_bit();
  var UnixStat = require_unix_stat();
  var constants = require_constants9();
  var zipUtil = require_util8();
  var ZipArchiveEntry = module2.exports = function(name) {
    if (!(this instanceof ZipArchiveEntry)) {
      return new ZipArchiveEntry(name);
    }
    ArchiveEntry.call(this);
    this.platform = constants.PLATFORM_FAT;
    this.method = -1;
    this.name = null;
    this.size = 0;
    this.csize = 0;
    this.gpb = new GeneralPurposeBit();
    this.crc = 0;
    this.time = -1;
    this.minver = constants.MIN_VERSION_INITIAL;
    this.mode = -1;
    this.extra = null;
    this.exattr = 0;
    this.inattr = 0;
    this.comment = null;
    if (name) {
      this.setName(name);
    }
  };
  inherits(ZipArchiveEntry, ArchiveEntry);
  ZipArchiveEntry.prototype.getCentralDirectoryExtra = function() {
    return this.getExtra();
  };
  ZipArchiveEntry.prototype.getComment = function() {
    return this.comment !== null ? this.comment : "";
  };
  ZipArchiveEntry.prototype.getCompressedSize = function() {
    return this.csize;
  };
  ZipArchiveEntry.prototype.getCrc = function() {
    return this.crc;
  };
  ZipArchiveEntry.prototype.getExternalAttributes = function() {
    return this.exattr;
  };
  ZipArchiveEntry.prototype.getExtra = function() {
    return this.extra !== null ? this.extra : constants.EMPTY;
  };
  ZipArchiveEntry.prototype.getGeneralPurposeBit = function() {
    return this.gpb;
  };
  ZipArchiveEntry.prototype.getInternalAttributes = function() {
    return this.inattr;
  };
  ZipArchiveEntry.prototype.getLastModifiedDate = function() {
    return this.getTime();
  };
  ZipArchiveEntry.prototype.getLocalFileDataExtra = function() {
    return this.getExtra();
  };
  ZipArchiveEntry.prototype.getMethod = function() {
    return this.method;
  };
  ZipArchiveEntry.prototype.getName = function() {
    return this.name;
  };
  ZipArchiveEntry.prototype.getPlatform = function() {
    return this.platform;
  };
  ZipArchiveEntry.prototype.getSize = function() {
    return this.size;
  };
  ZipArchiveEntry.prototype.getTime = function() {
    return this.time !== -1 ? zipUtil.dosToDate(this.time) : -1;
  };
  ZipArchiveEntry.prototype.getTimeDos = function() {
    return this.time !== -1 ? this.time : 0;
  };
  ZipArchiveEntry.prototype.getUnixMode = function() {
    return this.platform !== constants.PLATFORM_UNIX ? 0 : this.getExternalAttributes() >> constants.SHORT_SHIFT & constants.SHORT_MASK;
  };
  ZipArchiveEntry.prototype.getVersionNeededToExtract = function() {
    return this.minver;
  };
  ZipArchiveEntry.prototype.setComment = function(comment) {
    if (Buffer.byteLength(comment) !== comment.length) {
      this.getGeneralPurposeBit().useUTF8ForNames(true);
    }
    this.comment = comment;
  };
  ZipArchiveEntry.prototype.setCompressedSize = function(size) {
    if (size < 0) {
      throw new Error("invalid entry compressed size");
    }
    this.csize = size;
  };
  ZipArchiveEntry.prototype.setCrc = function(crc) {
    if (crc < 0) {
      throw new Error("invalid entry crc32");
    }
    this.crc = crc;
  };
  ZipArchiveEntry.prototype.setExternalAttributes = function(attr) {
    this.exattr = attr >>> 0;
  };
  ZipArchiveEntry.prototype.setExtra = function(extra) {
    this.extra = extra;
  };
  ZipArchiveEntry.prototype.setGeneralPurposeBit = function(gpb) {
    if (!(gpb instanceof GeneralPurposeBit)) {
      throw new Error("invalid entry GeneralPurposeBit");
    }
    this.gpb = gpb;
  };
  ZipArchiveEntry.prototype.setInternalAttributes = function(attr) {
    this.inattr = attr;
  };
  ZipArchiveEntry.prototype.setMethod = function(method) {
    if (method < 0) {
      throw new Error("invalid entry compression method");
    }
    this.method = method;
  };
  ZipArchiveEntry.prototype.setName = function(name) {
    name = normalizePath(name, false).replace(/^\w+:/, "").replace(/^(\.\.\/|\/)+/, "");
    if (Buffer.byteLength(name) !== name.length) {
      this.getGeneralPurposeBit().useUTF8ForNames(true);
    }
    this.name = name;
  };
  ZipArchiveEntry.prototype.setPlatform = function(platform) {
    this.platform = platform;
  };
  ZipArchiveEntry.prototype.setSize = function(size) {
    if (size < 0) {
      throw new Error("invalid entry size");
    }
    this.size = size;
  };
  ZipArchiveEntry.prototype.setTime = function(time, forceLocalTime) {
    if (!(time instanceof Date)) {
      throw new Error("invalid entry time");
    }
    this.time = zipUtil.dateToDos(time, forceLocalTime);
  };
  ZipArchiveEntry.prototype.setUnixMode = function(mode) {
    mode |= this.isDirectory() ? constants.S_IFDIR : constants.S_IFREG;
    var extattr = 0;
    extattr |= mode << constants.SHORT_SHIFT | (this.isDirectory() ? constants.S_DOS_D : constants.S_DOS_A);
    this.setExternalAttributes(extattr);
    this.mode = mode & constants.MODE_MASK;
    this.platform = constants.PLATFORM_UNIX;
  };
  ZipArchiveEntry.prototype.setVersionNeededToExtract = function(minver) {
    this.minver = minver;
  };
  ZipArchiveEntry.prototype.isDirectory = function() {
    return this.getName().slice(-1) === "/";
  };
  ZipArchiveEntry.prototype.isUnixSymlink = function() {
    return (this.getUnixMode() & UnixStat.FILE_TYPE_FLAG) === UnixStat.LINK_FLAG;
  };
  ZipArchiveEntry.prototype.isZip64 = function() {
    return this.csize > constants.ZIP64_MAGIC || this.size > constants.ZIP64_MAGIC;
  };
});

// ../../node_modules/.pnpm/compress-commons@3.0.0/node_modules/compress-commons/lib/util/index.js
var require_util9 = __commonJS2((exports2, module2) => {
  var Stream = require("stream").Stream;
  var PassThrough = require_readable().PassThrough;
  var util2 = module2.exports = {};
  util2.isStream = function(source) {
    return source instanceof Stream;
  };
  util2.normalizeInputSource = function(source) {
    if (source === null) {
      return Buffer.alloc(0);
    } else if (typeof source === "string") {
      return Buffer.from(source);
    } else if (util2.isStream(source) && !source._readableState) {
      var normalized = new PassThrough();
      source.pipe(normalized);
      return normalized;
    }
    return source;
  };
});

// ../../node_modules/.pnpm/compress-commons@3.0.0/node_modules/compress-commons/lib/archivers/archive-output-stream.js
var require_archive_output_stream = __commonJS2((exports2, module2) => {
  var inherits = require("util").inherits;
  var Transform = require_readable().Transform;
  var ArchiveEntry = require_archive_entry();
  var util2 = require_util9();
  var ArchiveOutputStream = module2.exports = function(options) {
    if (!(this instanceof ArchiveOutputStream)) {
      return new ArchiveOutputStream(options);
    }
    Transform.call(this, options);
    this.offset = 0;
    this._archive = {
      finish: false,
      finished: false,
      processing: false
    };
  };
  inherits(ArchiveOutputStream, Transform);
  ArchiveOutputStream.prototype._appendBuffer = function(zae, source, callback) {
  };
  ArchiveOutputStream.prototype._appendStream = function(zae, source, callback) {
  };
  ArchiveOutputStream.prototype._emitErrorCallback = function(err) {
    if (err) {
      this.emit("error", err);
    }
  };
  ArchiveOutputStream.prototype._finish = function(ae) {
  };
  ArchiveOutputStream.prototype._normalizeEntry = function(ae) {
  };
  ArchiveOutputStream.prototype._transform = function(chunk, encoding, callback) {
    callback(null, chunk);
  };
  ArchiveOutputStream.prototype.entry = function(ae, source, callback) {
    source = source || null;
    if (typeof callback !== "function") {
      callback = this._emitErrorCallback.bind(this);
    }
    if (!(ae instanceof ArchiveEntry)) {
      callback(new Error("not a valid instance of ArchiveEntry"));
      return;
    }
    if (this._archive.finish || this._archive.finished) {
      callback(new Error("unacceptable entry after finish"));
      return;
    }
    if (this._archive.processing) {
      callback(new Error("already processing an entry"));
      return;
    }
    this._archive.processing = true;
    this._normalizeEntry(ae);
    this._entry = ae;
    source = util2.normalizeInputSource(source);
    if (Buffer.isBuffer(source)) {
      this._appendBuffer(ae, source, callback);
    } else if (util2.isStream(source)) {
      this._appendStream(ae, source, callback);
    } else {
      this._archive.processing = false;
      callback(new Error("input source must be valid Stream or Buffer instance"));
      return;
    }
    return this;
  };
  ArchiveOutputStream.prototype.finish = function() {
    if (this._archive.processing) {
      this._archive.finish = true;
      return;
    }
    this._finish();
  };
  ArchiveOutputStream.prototype.getBytesWritten = function() {
    return this.offset;
  };
  ArchiveOutputStream.prototype.write = function(chunk, cb) {
    if (chunk) {
      this.offset += chunk.length;
    }
    return Transform.prototype.write.call(this, chunk, cb);
  };
});

// ../../node_modules/.pnpm/buffer-crc32@0.2.13/node_modules/buffer-crc32/index.js
var require_buffer_crc32 = __commonJS2((exports2, module2) => {
  var Buffer2 = require("buffer").Buffer;
  var CRC_TABLE = [
    0,
    1996959894,
    3993919788,
    2567524794,
    124634137,
    1886057615,
    3915621685,
    2657392035,
    249268274,
    2044508324,
    3772115230,
    2547177864,
    162941995,
    2125561021,
    3887607047,
    2428444049,
    498536548,
    1789927666,
    4089016648,
    2227061214,
    450548861,
    1843258603,
    4107580753,
    2211677639,
    325883990,
    1684777152,
    4251122042,
    2321926636,
    335633487,
    1661365465,
    4195302755,
    2366115317,
    997073096,
    1281953886,
    3579855332,
    2724688242,
    1006888145,
    1258607687,
    3524101629,
    2768942443,
    901097722,
    1119000684,
    3686517206,
    2898065728,
    853044451,
    1172266101,
    3705015759,
    2882616665,
    651767980,
    1373503546,
    3369554304,
    3218104598,
    565507253,
    1454621731,
    3485111705,
    3099436303,
    671266974,
    1594198024,
    3322730930,
    2970347812,
    795835527,
    1483230225,
    3244367275,
    3060149565,
    1994146192,
    31158534,
    2563907772,
    4023717930,
    1907459465,
    112637215,
    2680153253,
    3904427059,
    2013776290,
    251722036,
    2517215374,
    3775830040,
    2137656763,
    141376813,
    2439277719,
    3865271297,
    1802195444,
    476864866,
    2238001368,
    4066508878,
    1812370925,
    453092731,
    2181625025,
    4111451223,
    1706088902,
    314042704,
    2344532202,
    4240017532,
    1658658271,
    366619977,
    2362670323,
    4224994405,
    1303535960,
    984961486,
    2747007092,
    3569037538,
    1256170817,
    1037604311,
    2765210733,
    3554079995,
    1131014506,
    879679996,
    2909243462,
    3663771856,
    1141124467,
    855842277,
    2852801631,
    3708648649,
    1342533948,
    654459306,
    3188396048,
    3373015174,
    1466479909,
    544179635,
    3110523913,
    3462522015,
    1591671054,
    702138776,
    2966460450,
    3352799412,
    1504918807,
    783551873,
    3082640443,
    3233442989,
    3988292384,
    2596254646,
    62317068,
    1957810842,
    3939845945,
    2647816111,
    81470997,
    1943803523,
    3814918930,
    2489596804,
    225274430,
    2053790376,
    3826175755,
    2466906013,
    167816743,
    2097651377,
    4027552580,
    2265490386,
    503444072,
    1762050814,
    4150417245,
    2154129355,
    426522225,
    1852507879,
    4275313526,
    2312317920,
    282753626,
    1742555852,
    4189708143,
    2394877945,
    397917763,
    1622183637,
    3604390888,
    2714866558,
    953729732,
    1340076626,
    3518719985,
    2797360999,
    1068828381,
    1219638859,
    3624741850,
    2936675148,
    906185462,
    1090812512,
    3747672003,
    2825379669,
    829329135,
    1181335161,
    3412177804,
    3160834842,
    628085408,
    1382605366,
    3423369109,
    3138078467,
    570562233,
    1426400815,
    3317316542,
    2998733608,
    733239954,
    1555261956,
    3268935591,
    3050360625,
    752459403,
    1541320221,
    2607071920,
    3965973030,
    1969922972,
    40735498,
    2617837225,
    3943577151,
    1913087877,
    83908371,
    2512341634,
    3803740692,
    2075208622,
    213261112,
    2463272603,
    3855990285,
    2094854071,
    198958881,
    2262029012,
    4057260610,
    1759359992,
    534414190,
    2176718541,
    4139329115,
    1873836001,
    414664567,
    2282248934,
    4279200368,
    1711684554,
    285281116,
    2405801727,
    4167216745,
    1634467795,
    376229701,
    2685067896,
    3608007406,
    1308918612,
    956543938,
    2808555105,
    3495958263,
    1231636301,
    1047427035,
    2932959818,
    3654703836,
    1088359270,
    936918e3,
    2847714899,
    3736837829,
    1202900863,
    817233897,
    3183342108,
    3401237130,
    1404277552,
    615818150,
    3134207493,
    3453421203,
    1423857449,
    601450431,
    3009837614,
    3294710456,
    1567103746,
    711928724,
    3020668471,
    3272380065,
    1510334235,
    755167117
  ];
  if (typeof Int32Array !== "undefined") {
    CRC_TABLE = new Int32Array(CRC_TABLE);
  }
  function ensureBuffer(input) {
    if (Buffer2.isBuffer(input)) {
      return input;
    }
    var hasNewBufferAPI = typeof Buffer2.alloc === "function" && typeof Buffer2.from === "function";
    if (typeof input === "number") {
      return hasNewBufferAPI ? Buffer2.alloc(input) : new Buffer2(input);
    } else if (typeof input === "string") {
      return hasNewBufferAPI ? Buffer2.from(input) : new Buffer2(input);
    } else {
      throw new Error("input must be buffer, number, or string, received " + typeof input);
    }
  }
  function bufferizeInt(num) {
    var tmp = ensureBuffer(4);
    tmp.writeInt32BE(num, 0);
    return tmp;
  }
  function _crc32(buf, previous) {
    buf = ensureBuffer(buf);
    if (Buffer2.isBuffer(previous)) {
      previous = previous.readUInt32BE(0);
    }
    var crc = ~~previous ^ -1;
    for (var n = 0; n < buf.length; n++) {
      crc = CRC_TABLE[(crc ^ buf[n]) & 255] ^ crc >>> 8;
    }
    return crc ^ -1;
  }
  function crc32() {
    return bufferizeInt(_crc32.apply(null, arguments));
  }
  crc32.signed = function() {
    return _crc32.apply(null, arguments);
  };
  crc32.unsigned = function() {
    return _crc32.apply(null, arguments) >>> 0;
  };
  module2.exports = crc32;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/es6/create_buffer.js
var require_create_buffer = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _buffer = require("buffer");
  var createBuffer = _buffer.Buffer.from && _buffer.Buffer.alloc && _buffer.Buffer.allocUnsafe && _buffer.Buffer.allocUnsafeSlow ? _buffer.Buffer.from : function(val) {
    return new _buffer.Buffer(val);
  };
  exports2.default = createBuffer;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/es6/define_crc.js
var require_define_crc = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = function(model, calc) {
    var fn = function fn2(buf, previous) {
      return calc(buf, previous) >>> 0;
    };
    fn.signed = calc;
    fn.unsigned = fn;
    fn.model = model;
    return fn;
  };
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/es6/crc1.js
var require_crc1 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _buffer = require("buffer");
  var _create_buffer = require_create_buffer();
  var _create_buffer2 = _interopRequireDefault(_create_buffer);
  var _define_crc = require_define_crc();
  var _define_crc2 = _interopRequireDefault(_define_crc);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var crc1 = (0, _define_crc2.default)("crc1", function(buf, previous) {
    if (!_buffer.Buffer.isBuffer(buf))
      buf = (0, _create_buffer2.default)(buf);
    var crc = ~~previous;
    var accum = 0;
    for (var index = 0; index < buf.length; index++) {
      var byte = buf[index];
      accum += byte;
    }
    crc += accum % 256;
    return crc % 256;
  });
  exports2.default = crc1;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/crc1.js
var require_crc12 = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = require_crc1().default;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/es6/crc8.js
var require_crc8 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _buffer = require("buffer");
  var _create_buffer = require_create_buffer();
  var _create_buffer2 = _interopRequireDefault(_create_buffer);
  var _define_crc = require_define_crc();
  var _define_crc2 = _interopRequireDefault(_define_crc);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var TABLE = [0, 7, 14, 9, 28, 27, 18, 21, 56, 63, 54, 49, 36, 35, 42, 45, 112, 119, 126, 121, 108, 107, 98, 101, 72, 79, 70, 65, 84, 83, 90, 93, 224, 231, 238, 233, 252, 251, 242, 245, 216, 223, 214, 209, 196, 195, 202, 205, 144, 151, 158, 153, 140, 139, 130, 133, 168, 175, 166, 161, 180, 179, 186, 189, 199, 192, 201, 206, 219, 220, 213, 210, 255, 248, 241, 246, 227, 228, 237, 234, 183, 176, 185, 190, 171, 172, 165, 162, 143, 136, 129, 134, 147, 148, 157, 154, 39, 32, 41, 46, 59, 60, 53, 50, 31, 24, 17, 22, 3, 4, 13, 10, 87, 80, 89, 94, 75, 76, 69, 66, 111, 104, 97, 102, 115, 116, 125, 122, 137, 142, 135, 128, 149, 146, 155, 156, 177, 182, 191, 184, 173, 170, 163, 164, 249, 254, 247, 240, 229, 226, 235, 236, 193, 198, 207, 200, 221, 218, 211, 212, 105, 110, 103, 96, 117, 114, 123, 124, 81, 86, 95, 88, 77, 74, 67, 68, 25, 30, 23, 16, 5, 2, 11, 12, 33, 38, 47, 40, 61, 58, 51, 52, 78, 73, 64, 71, 82, 85, 92, 91, 118, 113, 120, 127, 106, 109, 100, 99, 62, 57, 48, 55, 34, 37, 44, 43, 6, 1, 8, 15, 26, 29, 20, 19, 174, 169, 160, 167, 178, 181, 188, 187, 150, 145, 152, 159, 138, 141, 132, 131, 222, 217, 208, 215, 194, 197, 204, 203, 230, 225, 232, 239, 250, 253, 244, 243];
  if (typeof Int32Array !== "undefined")
    TABLE = new Int32Array(TABLE);
  var crc8 = (0, _define_crc2.default)("crc-8", function(buf, previous) {
    if (!_buffer.Buffer.isBuffer(buf))
      buf = (0, _create_buffer2.default)(buf);
    var crc = ~~previous;
    for (var index = 0; index < buf.length; index++) {
      var byte = buf[index];
      crc = TABLE[(crc ^ byte) & 255] & 255;
    }
    return crc;
  });
  exports2.default = crc8;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/crc8.js
var require_crc82 = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = require_crc8().default;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/es6/crc81wire.js
var require_crc81wire = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _buffer = require("buffer");
  var _create_buffer = require_create_buffer();
  var _create_buffer2 = _interopRequireDefault(_create_buffer);
  var _define_crc = require_define_crc();
  var _define_crc2 = _interopRequireDefault(_define_crc);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var TABLE = [0, 94, 188, 226, 97, 63, 221, 131, 194, 156, 126, 32, 163, 253, 31, 65, 157, 195, 33, 127, 252, 162, 64, 30, 95, 1, 227, 189, 62, 96, 130, 220, 35, 125, 159, 193, 66, 28, 254, 160, 225, 191, 93, 3, 128, 222, 60, 98, 190, 224, 2, 92, 223, 129, 99, 61, 124, 34, 192, 158, 29, 67, 161, 255, 70, 24, 250, 164, 39, 121, 155, 197, 132, 218, 56, 102, 229, 187, 89, 7, 219, 133, 103, 57, 186, 228, 6, 88, 25, 71, 165, 251, 120, 38, 196, 154, 101, 59, 217, 135, 4, 90, 184, 230, 167, 249, 27, 69, 198, 152, 122, 36, 248, 166, 68, 26, 153, 199, 37, 123, 58, 100, 134, 216, 91, 5, 231, 185, 140, 210, 48, 110, 237, 179, 81, 15, 78, 16, 242, 172, 47, 113, 147, 205, 17, 79, 173, 243, 112, 46, 204, 146, 211, 141, 111, 49, 178, 236, 14, 80, 175, 241, 19, 77, 206, 144, 114, 44, 109, 51, 209, 143, 12, 82, 176, 238, 50, 108, 142, 208, 83, 13, 239, 177, 240, 174, 76, 18, 145, 207, 45, 115, 202, 148, 118, 40, 171, 245, 23, 73, 8, 86, 180, 234, 105, 55, 213, 139, 87, 9, 235, 181, 54, 104, 138, 212, 149, 203, 41, 119, 244, 170, 72, 22, 233, 183, 85, 11, 136, 214, 52, 106, 43, 117, 151, 201, 74, 20, 246, 168, 116, 42, 200, 150, 21, 75, 169, 247, 182, 232, 10, 84, 215, 137, 107, 53];
  if (typeof Int32Array !== "undefined")
    TABLE = new Int32Array(TABLE);
  var crc81wire = (0, _define_crc2.default)("dallas-1-wire", function(buf, previous) {
    if (!_buffer.Buffer.isBuffer(buf))
      buf = (0, _create_buffer2.default)(buf);
    var crc = ~~previous;
    for (var index = 0; index < buf.length; index++) {
      var byte = buf[index];
      crc = TABLE[(crc ^ byte) & 255] & 255;
    }
    return crc;
  });
  exports2.default = crc81wire;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/crc8_1wire.js
var require_crc8_1wire = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = require_crc81wire().default;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/es6/crc16.js
var require_crc16 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _buffer = require("buffer");
  var _create_buffer = require_create_buffer();
  var _create_buffer2 = _interopRequireDefault(_create_buffer);
  var _define_crc = require_define_crc();
  var _define_crc2 = _interopRequireDefault(_define_crc);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var TABLE = [0, 49345, 49537, 320, 49921, 960, 640, 49729, 50689, 1728, 1920, 51009, 1280, 50625, 50305, 1088, 52225, 3264, 3456, 52545, 3840, 53185, 52865, 3648, 2560, 51905, 52097, 2880, 51457, 2496, 2176, 51265, 55297, 6336, 6528, 55617, 6912, 56257, 55937, 6720, 7680, 57025, 57217, 8e3, 56577, 7616, 7296, 56385, 5120, 54465, 54657, 5440, 55041, 6080, 5760, 54849, 53761, 4800, 4992, 54081, 4352, 53697, 53377, 4160, 61441, 12480, 12672, 61761, 13056, 62401, 62081, 12864, 13824, 63169, 63361, 14144, 62721, 13760, 13440, 62529, 15360, 64705, 64897, 15680, 65281, 16320, 16e3, 65089, 64001, 15040, 15232, 64321, 14592, 63937, 63617, 14400, 10240, 59585, 59777, 10560, 60161, 11200, 10880, 59969, 60929, 11968, 12160, 61249, 11520, 60865, 60545, 11328, 58369, 9408, 9600, 58689, 9984, 59329, 59009, 9792, 8704, 58049, 58241, 9024, 57601, 8640, 8320, 57409, 40961, 24768, 24960, 41281, 25344, 41921, 41601, 25152, 26112, 42689, 42881, 26432, 42241, 26048, 25728, 42049, 27648, 44225, 44417, 27968, 44801, 28608, 28288, 44609, 43521, 27328, 27520, 43841, 26880, 43457, 43137, 26688, 30720, 47297, 47489, 31040, 47873, 31680, 31360, 47681, 48641, 32448, 32640, 48961, 32e3, 48577, 48257, 31808, 46081, 29888, 30080, 46401, 30464, 47041, 46721, 30272, 29184, 45761, 45953, 29504, 45313, 29120, 28800, 45121, 20480, 37057, 37249, 20800, 37633, 21440, 21120, 37441, 38401, 22208, 22400, 38721, 21760, 38337, 38017, 21568, 39937, 23744, 23936, 40257, 24320, 40897, 40577, 24128, 23040, 39617, 39809, 23360, 39169, 22976, 22656, 38977, 34817, 18624, 18816, 35137, 19200, 35777, 35457, 19008, 19968, 36545, 36737, 20288, 36097, 19904, 19584, 35905, 17408, 33985, 34177, 17728, 34561, 18368, 18048, 34369, 33281, 17088, 17280, 33601, 16640, 33217, 32897, 16448];
  if (typeof Int32Array !== "undefined")
    TABLE = new Int32Array(TABLE);
  var crc16 = (0, _define_crc2.default)("crc-16", function(buf, previous) {
    if (!_buffer.Buffer.isBuffer(buf))
      buf = (0, _create_buffer2.default)(buf);
    var crc = ~~previous;
    for (var index = 0; index < buf.length; index++) {
      var byte = buf[index];
      crc = (TABLE[(crc ^ byte) & 255] ^ crc >> 8) & 65535;
    }
    return crc;
  });
  exports2.default = crc16;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/crc16.js
var require_crc162 = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = require_crc16().default;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/es6/crc16ccitt.js
var require_crc16ccitt = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _buffer = require("buffer");
  var _create_buffer = require_create_buffer();
  var _create_buffer2 = _interopRequireDefault(_create_buffer);
  var _define_crc = require_define_crc();
  var _define_crc2 = _interopRequireDefault(_define_crc);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var TABLE = [0, 4129, 8258, 12387, 16516, 20645, 24774, 28903, 33032, 37161, 41290, 45419, 49548, 53677, 57806, 61935, 4657, 528, 12915, 8786, 21173, 17044, 29431, 25302, 37689, 33560, 45947, 41818, 54205, 50076, 62463, 58334, 9314, 13379, 1056, 5121, 25830, 29895, 17572, 21637, 42346, 46411, 34088, 38153, 58862, 62927, 50604, 54669, 13907, 9842, 5649, 1584, 30423, 26358, 22165, 18100, 46939, 42874, 38681, 34616, 63455, 59390, 55197, 51132, 18628, 22757, 26758, 30887, 2112, 6241, 10242, 14371, 51660, 55789, 59790, 63919, 35144, 39273, 43274, 47403, 23285, 19156, 31415, 27286, 6769, 2640, 14899, 10770, 56317, 52188, 64447, 60318, 39801, 35672, 47931, 43802, 27814, 31879, 19684, 23749, 11298, 15363, 3168, 7233, 60846, 64911, 52716, 56781, 44330, 48395, 36200, 40265, 32407, 28342, 24277, 20212, 15891, 11826, 7761, 3696, 65439, 61374, 57309, 53244, 48923, 44858, 40793, 36728, 37256, 33193, 45514, 41451, 53516, 49453, 61774, 57711, 4224, 161, 12482, 8419, 20484, 16421, 28742, 24679, 33721, 37784, 41979, 46042, 49981, 54044, 58239, 62302, 689, 4752, 8947, 13010, 16949, 21012, 25207, 29270, 46570, 42443, 38312, 34185, 62830, 58703, 54572, 50445, 13538, 9411, 5280, 1153, 29798, 25671, 21540, 17413, 42971, 47098, 34713, 38840, 59231, 63358, 50973, 55100, 9939, 14066, 1681, 5808, 26199, 30326, 17941, 22068, 55628, 51565, 63758, 59695, 39368, 35305, 47498, 43435, 22596, 18533, 30726, 26663, 6336, 2273, 14466, 10403, 52093, 56156, 60223, 64286, 35833, 39896, 43963, 48026, 19061, 23124, 27191, 31254, 2801, 6864, 10931, 14994, 64814, 60687, 56684, 52557, 48554, 44427, 40424, 36297, 31782, 27655, 23652, 19525, 15522, 11395, 7392, 3265, 61215, 65342, 53085, 57212, 44955, 49082, 36825, 40952, 28183, 32310, 20053, 24180, 11923, 16050, 3793, 7920];
  if (typeof Int32Array !== "undefined")
    TABLE = new Int32Array(TABLE);
  var crc16ccitt = (0, _define_crc2.default)("ccitt", function(buf, previous) {
    if (!_buffer.Buffer.isBuffer(buf))
      buf = (0, _create_buffer2.default)(buf);
    var crc = typeof previous !== "undefined" ? ~~previous : 65535;
    for (var index = 0; index < buf.length; index++) {
      var byte = buf[index];
      crc = (TABLE[(crc >> 8 ^ byte) & 255] ^ crc << 8) & 65535;
    }
    return crc;
  });
  exports2.default = crc16ccitt;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/crc16_ccitt.js
var require_crc16_ccitt = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = require_crc16ccitt().default;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/es6/crc16modbus.js
var require_crc16modbus = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _buffer = require("buffer");
  var _create_buffer = require_create_buffer();
  var _create_buffer2 = _interopRequireDefault(_create_buffer);
  var _define_crc = require_define_crc();
  var _define_crc2 = _interopRequireDefault(_define_crc);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var TABLE = [0, 49345, 49537, 320, 49921, 960, 640, 49729, 50689, 1728, 1920, 51009, 1280, 50625, 50305, 1088, 52225, 3264, 3456, 52545, 3840, 53185, 52865, 3648, 2560, 51905, 52097, 2880, 51457, 2496, 2176, 51265, 55297, 6336, 6528, 55617, 6912, 56257, 55937, 6720, 7680, 57025, 57217, 8e3, 56577, 7616, 7296, 56385, 5120, 54465, 54657, 5440, 55041, 6080, 5760, 54849, 53761, 4800, 4992, 54081, 4352, 53697, 53377, 4160, 61441, 12480, 12672, 61761, 13056, 62401, 62081, 12864, 13824, 63169, 63361, 14144, 62721, 13760, 13440, 62529, 15360, 64705, 64897, 15680, 65281, 16320, 16e3, 65089, 64001, 15040, 15232, 64321, 14592, 63937, 63617, 14400, 10240, 59585, 59777, 10560, 60161, 11200, 10880, 59969, 60929, 11968, 12160, 61249, 11520, 60865, 60545, 11328, 58369, 9408, 9600, 58689, 9984, 59329, 59009, 9792, 8704, 58049, 58241, 9024, 57601, 8640, 8320, 57409, 40961, 24768, 24960, 41281, 25344, 41921, 41601, 25152, 26112, 42689, 42881, 26432, 42241, 26048, 25728, 42049, 27648, 44225, 44417, 27968, 44801, 28608, 28288, 44609, 43521, 27328, 27520, 43841, 26880, 43457, 43137, 26688, 30720, 47297, 47489, 31040, 47873, 31680, 31360, 47681, 48641, 32448, 32640, 48961, 32e3, 48577, 48257, 31808, 46081, 29888, 30080, 46401, 30464, 47041, 46721, 30272, 29184, 45761, 45953, 29504, 45313, 29120, 28800, 45121, 20480, 37057, 37249, 20800, 37633, 21440, 21120, 37441, 38401, 22208, 22400, 38721, 21760, 38337, 38017, 21568, 39937, 23744, 23936, 40257, 24320, 40897, 40577, 24128, 23040, 39617, 39809, 23360, 39169, 22976, 22656, 38977, 34817, 18624, 18816, 35137, 19200, 35777, 35457, 19008, 19968, 36545, 36737, 20288, 36097, 19904, 19584, 35905, 17408, 33985, 34177, 17728, 34561, 18368, 18048, 34369, 33281, 17088, 17280, 33601, 16640, 33217, 32897, 16448];
  if (typeof Int32Array !== "undefined")
    TABLE = new Int32Array(TABLE);
  var crc16modbus = (0, _define_crc2.default)("crc-16-modbus", function(buf, previous) {
    if (!_buffer.Buffer.isBuffer(buf))
      buf = (0, _create_buffer2.default)(buf);
    var crc = typeof previous !== "undefined" ? ~~previous : 65535;
    for (var index = 0; index < buf.length; index++) {
      var byte = buf[index];
      crc = (TABLE[(crc ^ byte) & 255] ^ crc >> 8) & 65535;
    }
    return crc;
  });
  exports2.default = crc16modbus;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/crc16_modbus.js
var require_crc16_modbus = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = require_crc16modbus().default;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/es6/crc16xmodem.js
var require_crc16xmodem = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _buffer = require("buffer");
  var _create_buffer = require_create_buffer();
  var _create_buffer2 = _interopRequireDefault(_create_buffer);
  var _define_crc = require_define_crc();
  var _define_crc2 = _interopRequireDefault(_define_crc);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var crc16xmodem = (0, _define_crc2.default)("xmodem", function(buf, previous) {
    if (!_buffer.Buffer.isBuffer(buf))
      buf = (0, _create_buffer2.default)(buf);
    var crc = typeof previous !== "undefined" ? ~~previous : 0;
    for (var index = 0; index < buf.length; index++) {
      var byte = buf[index];
      var code = crc >>> 8 & 255;
      code ^= byte & 255;
      code ^= code >>> 4;
      crc = crc << 8 & 65535;
      crc ^= code;
      code = code << 5 & 65535;
      crc ^= code;
      code = code << 7 & 65535;
      crc ^= code;
    }
    return crc;
  });
  exports2.default = crc16xmodem;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/crc16_xmodem.js
var require_crc16_xmodem = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = require_crc16xmodem().default;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/es6/crc16kermit.js
var require_crc16kermit = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _buffer = require("buffer");
  var _create_buffer = require_create_buffer();
  var _create_buffer2 = _interopRequireDefault(_create_buffer);
  var _define_crc = require_define_crc();
  var _define_crc2 = _interopRequireDefault(_define_crc);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var TABLE = [0, 4489, 8978, 12955, 17956, 22445, 25910, 29887, 35912, 40385, 44890, 48851, 51820, 56293, 59774, 63735, 4225, 264, 13203, 8730, 22181, 18220, 30135, 25662, 40137, 36160, 49115, 44626, 56045, 52068, 63999, 59510, 8450, 12427, 528, 5017, 26406, 30383, 17460, 21949, 44362, 48323, 36440, 40913, 60270, 64231, 51324, 55797, 12675, 8202, 4753, 792, 30631, 26158, 21685, 17724, 48587, 44098, 40665, 36688, 64495, 60006, 55549, 51572, 16900, 21389, 24854, 28831, 1056, 5545, 10034, 14011, 52812, 57285, 60766, 64727, 34920, 39393, 43898, 47859, 21125, 17164, 29079, 24606, 5281, 1320, 14259, 9786, 57037, 53060, 64991, 60502, 39145, 35168, 48123, 43634, 25350, 29327, 16404, 20893, 9506, 13483, 1584, 6073, 61262, 65223, 52316, 56789, 43370, 47331, 35448, 39921, 29575, 25102, 20629, 16668, 13731, 9258, 5809, 1848, 65487, 60998, 56541, 52564, 47595, 43106, 39673, 35696, 33800, 38273, 42778, 46739, 49708, 54181, 57662, 61623, 2112, 6601, 11090, 15067, 20068, 24557, 28022, 31999, 38025, 34048, 47003, 42514, 53933, 49956, 61887, 57398, 6337, 2376, 15315, 10842, 24293, 20332, 32247, 27774, 42250, 46211, 34328, 38801, 58158, 62119, 49212, 53685, 10562, 14539, 2640, 7129, 28518, 32495, 19572, 24061, 46475, 41986, 38553, 34576, 62383, 57894, 53437, 49460, 14787, 10314, 6865, 2904, 32743, 28270, 23797, 19836, 50700, 55173, 58654, 62615, 32808, 37281, 41786, 45747, 19012, 23501, 26966, 30943, 3168, 7657, 12146, 16123, 54925, 50948, 62879, 58390, 37033, 33056, 46011, 41522, 23237, 19276, 31191, 26718, 7393, 3432, 16371, 11898, 59150, 63111, 50204, 54677, 41258, 45219, 33336, 37809, 27462, 31439, 18516, 23005, 11618, 15595, 3696, 8185, 63375, 58886, 54429, 50452, 45483, 40994, 37561, 33584, 31687, 27214, 22741, 18780, 15843, 11370, 7921, 3960];
  if (typeof Int32Array !== "undefined")
    TABLE = new Int32Array(TABLE);
  var crc16kermit = (0, _define_crc2.default)("kermit", function(buf, previous) {
    if (!_buffer.Buffer.isBuffer(buf))
      buf = (0, _create_buffer2.default)(buf);
    var crc = typeof previous !== "undefined" ? ~~previous : 0;
    for (var index = 0; index < buf.length; index++) {
      var byte = buf[index];
      crc = (TABLE[(crc ^ byte) & 255] ^ crc >> 8) & 65535;
    }
    return crc;
  });
  exports2.default = crc16kermit;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/crc16_kermit.js
var require_crc16_kermit = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = require_crc16kermit().default;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/es6/crc24.js
var require_crc24 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _buffer = require("buffer");
  var _create_buffer = require_create_buffer();
  var _create_buffer2 = _interopRequireDefault(_create_buffer);
  var _define_crc = require_define_crc();
  var _define_crc2 = _interopRequireDefault(_define_crc);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var TABLE = [0, 8801531, 9098509, 825846, 9692897, 1419802, 1651692, 10452759, 10584377, 2608578, 2839604, 11344079, 3303384, 11807523, 12104405, 4128302, 12930697, 4391538, 5217156, 13227903, 5679208, 13690003, 14450021, 5910942, 6606768, 14844747, 15604413, 6837830, 16197969, 7431594, 8256604, 16494759, 840169, 9084178, 8783076, 18463, 10434312, 1670131, 1434117, 9678590, 11358416, 2825259, 2590173, 10602790, 4109873, 12122826, 11821884, 3289031, 13213536, 5231515, 4409965, 12912278, 5929345, 14431610, 13675660, 5693559, 6823513, 15618722, 14863188, 6588335, 16513208, 8238147, 7417269, 16212302, 1680338, 10481449, 9664223, 1391140, 9061683, 788936, 36926, 8838341, 12067563, 4091408, 3340262, 11844381, 2868234, 11372785, 10555655, 2579964, 14478683, 5939616, 5650518, 13661357, 5180346, 13190977, 12967607, 4428364, 8219746, 16457881, 16234863, 7468436, 15633027, 6866552, 6578062, 14816117, 1405499, 9649856, 10463030, 1698765, 8819930, 55329, 803287, 9047340, 11858690, 3325945, 4072975, 12086004, 2561507, 10574104, 11387118, 2853909, 13647026, 5664841, 5958079, 14460228, 4446803, 12949160, 13176670, 5194661, 7454091, 16249200, 16476294, 8201341, 14834538, 6559633, 6852199, 15647388, 3360676, 11864927, 12161705, 4185682, 10527045, 2551230, 2782280, 11286707, 9619101, 1346150, 1577872, 10379115, 73852, 8875143, 9172337, 899466, 16124205, 7357910, 8182816, 16421083, 6680524, 14918455, 15678145, 6911546, 5736468, 13747439, 14507289, 5968354, 12873461, 4334094, 5159928, 13170435, 4167245, 12180150, 11879232, 3346363, 11301036, 2767959, 2532769, 10545498, 10360692, 1596303, 1360505, 9604738, 913813, 9157998, 8856728, 92259, 16439492, 8164415, 7343561, 16138546, 6897189, 15692510, 14936872, 6662099, 5986813, 14488838, 13733104, 5750795, 13156124, 5174247, 4352529, 12855018, 2810998, 11315341, 10498427, 2522496, 12124823, 4148844, 3397530, 11901793, 9135439, 862644, 110658, 8912057, 1606574, 10407765, 9590435, 1317464, 15706879, 6940164, 6651890, 14889737, 8145950, 16384229, 16161043, 7394792, 5123014, 13133629, 12910283, 4370992, 14535975, 5997020, 5707818, 13718737, 2504095, 10516836, 11329682, 2796649, 11916158, 3383173, 4130419, 12143240, 8893606, 129117, 876971, 9121104, 1331783, 9576124, 10389322, 1625009, 14908182, 6633453, 6925851, 15721184, 7380471, 16175372, 16402682, 8127489, 4389423, 12891860, 13119266, 5137369, 13704398, 5722165, 6015427, 14517560];
  if (typeof Int32Array !== "undefined")
    TABLE = new Int32Array(TABLE);
  var crc24 = (0, _define_crc2.default)("crc-24", function(buf, previous) {
    if (!_buffer.Buffer.isBuffer(buf))
      buf = (0, _create_buffer2.default)(buf);
    var crc = typeof previous !== "undefined" ? ~~previous : 11994318;
    for (var index = 0; index < buf.length; index++) {
      var byte = buf[index];
      crc = (TABLE[(crc >> 16 ^ byte) & 255] ^ crc << 8) & 16777215;
    }
    return crc;
  });
  exports2.default = crc24;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/crc24.js
var require_crc242 = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = require_crc24().default;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/es6/crc32.js
var require_crc32 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _buffer = require("buffer");
  var _create_buffer = require_create_buffer();
  var _create_buffer2 = _interopRequireDefault(_create_buffer);
  var _define_crc = require_define_crc();
  var _define_crc2 = _interopRequireDefault(_define_crc);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var TABLE = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117];
  if (typeof Int32Array !== "undefined")
    TABLE = new Int32Array(TABLE);
  var crc32 = (0, _define_crc2.default)("crc-32", function(buf, previous) {
    if (!_buffer.Buffer.isBuffer(buf))
      buf = (0, _create_buffer2.default)(buf);
    var crc = previous === 0 ? 0 : ~~previous ^ -1;
    for (var index = 0; index < buf.length; index++) {
      var byte = buf[index];
      crc = TABLE[(crc ^ byte) & 255] ^ crc >>> 8;
    }
    return crc ^ -1;
  });
  exports2.default = crc32;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/crc32.js
var require_crc322 = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = require_crc32().default;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/es6/crcjam.js
var require_crcjam = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _buffer = require("buffer");
  var _create_buffer = require_create_buffer();
  var _create_buffer2 = _interopRequireDefault(_create_buffer);
  var _define_crc = require_define_crc();
  var _define_crc2 = _interopRequireDefault(_define_crc);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var TABLE = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117];
  if (typeof Int32Array !== "undefined")
    TABLE = new Int32Array(TABLE);
  var crcjam = (0, _define_crc2.default)("jam", function(buf) {
    var previous = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
    if (!_buffer.Buffer.isBuffer(buf))
      buf = (0, _create_buffer2.default)(buf);
    var crc = previous === 0 ? 0 : ~~previous;
    for (var index = 0; index < buf.length; index++) {
      var byte = buf[index];
      crc = TABLE[(crc ^ byte) & 255] ^ crc >>> 8;
    }
    return crc;
  });
  exports2.default = crcjam;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/crcjam.js
var require_crcjam2 = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = require_crcjam().default;
});

// ../../node_modules/.pnpm/crc@3.8.0/node_modules/crc/lib/index.js
var require_lib6 = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = {
    crc1: require_crc12(),
    crc8: require_crc82(),
    crc81wire: require_crc8_1wire(),
    crc16: require_crc162(),
    crc16ccitt: require_crc16_ccitt(),
    crc16modbus: require_crc16_modbus(),
    crc16xmodem: require_crc16_xmodem(),
    crc16kermit: require_crc16_kermit(),
    crc24: require_crc242(),
    crc32: require_crc322(),
    crcjam: require_crcjam2()
  };
});

// ../../node_modules/.pnpm/crc32-stream@3.0.1/node_modules/crc32-stream/lib/crc32-stream.js
var require_crc32_stream = __commonJS2((exports2, module2) => {
  "use strict";
  var {Transform} = require_readable2();
  var {crc32} = require_lib6();
  var CRC32Stream = class extends Transform {
    constructor(options) {
      super(options);
      this.checksum = Buffer.allocUnsafe(4);
      this.checksum.writeInt32BE(0, 0);
      this.rawSize = 0;
    }
    _transform(chunk, encoding, callback) {
      if (chunk) {
        this.checksum = crc32(chunk, this.checksum);
        this.rawSize += chunk.length;
      }
      callback(null, chunk);
    }
    digest(encoding) {
      const checksum = Buffer.allocUnsafe(4);
      checksum.writeUInt32BE(this.checksum >>> 0, 0);
      return encoding ? checksum.toString(encoding) : checksum;
    }
    hex() {
      return this.digest("hex").toUpperCase();
    }
    size() {
      return this.rawSize;
    }
  };
  module2.exports = CRC32Stream;
});

// ../../node_modules/.pnpm/crc32-stream@3.0.1/node_modules/crc32-stream/lib/deflate-crc32-stream.js
var require_deflate_crc32_stream = __commonJS2((exports2, module2) => {
  "use strict";
  var {DeflateRaw} = require("zlib");
  var {crc32} = require_lib6();
  var DeflateCRC32Stream = class extends DeflateRaw {
    constructor(options) {
      super(options);
      this.checksum = Buffer.allocUnsafe(4);
      this.checksum.writeInt32BE(0, 0);
      this.rawSize = 0;
      this.compressedSize = 0;
    }
    push(chunk, encoding) {
      if (chunk) {
        this.compressedSize += chunk.length;
      }
      return super.push(chunk, encoding);
    }
    write(chunk, enc, cb) {
      if (chunk) {
        this.checksum = crc32(chunk, this.checksum);
        this.rawSize += chunk.length;
      }
      return super.write(chunk, enc, cb);
    }
    digest(encoding) {
      const checksum = Buffer.allocUnsafe(4);
      checksum.writeUInt32BE(this.checksum >>> 0, 0);
      return encoding ? checksum.toString(encoding) : checksum;
    }
    hex() {
      return this.digest("hex").toUpperCase();
    }
    size(compressed = false) {
      if (compressed) {
        return this.compressedSize;
      } else {
        return this.rawSize;
      }
    }
  };
  module2.exports = DeflateCRC32Stream;
});

// ../../node_modules/.pnpm/crc32-stream@3.0.1/node_modules/crc32-stream/lib/index.js
var require_lib7 = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = {
    CRC32Stream: require_crc32_stream(),
    DeflateCRC32Stream: require_deflate_crc32_stream()
  };
});

// ../../node_modules/.pnpm/compress-commons@3.0.0/node_modules/compress-commons/lib/archivers/zip/zip-archive-output-stream.js
var require_zip_archive_output_stream = __commonJS2((exports2, module2) => {
  var inherits = require("util").inherits;
  var crc32 = require_buffer_crc32();
  var {CRC32Stream} = require_lib7();
  var {DeflateCRC32Stream} = require_lib7();
  var ArchiveOutputStream = require_archive_output_stream();
  var ZipArchiveEntry = require_zip_archive_entry();
  var GeneralPurposeBit = require_general_purpose_bit();
  var constants = require_constants9();
  var util2 = require_util9();
  var zipUtil = require_util8();
  var ZipArchiveOutputStream = module2.exports = function(options) {
    if (!(this instanceof ZipArchiveOutputStream)) {
      return new ZipArchiveOutputStream(options);
    }
    options = this.options = this._defaults(options);
    ArchiveOutputStream.call(this, options);
    this._entry = null;
    this._entries = [];
    this._archive = {
      centralLength: 0,
      centralOffset: 0,
      comment: "",
      finish: false,
      finished: false,
      processing: false,
      forceZip64: options.forceZip64,
      forceLocalTime: options.forceLocalTime
    };
  };
  inherits(ZipArchiveOutputStream, ArchiveOutputStream);
  ZipArchiveOutputStream.prototype._afterAppend = function(ae) {
    this._entries.push(ae);
    if (ae.getGeneralPurposeBit().usesDataDescriptor()) {
      this._writeDataDescriptor(ae);
    }
    this._archive.processing = false;
    this._entry = null;
    if (this._archive.finish && !this._archive.finished) {
      this._finish();
    }
  };
  ZipArchiveOutputStream.prototype._appendBuffer = function(ae, source, callback) {
    if (source.length === 0) {
      ae.setMethod(constants.METHOD_STORED);
    }
    var method = ae.getMethod();
    if (method === constants.METHOD_STORED) {
      ae.setSize(source.length);
      ae.setCompressedSize(source.length);
      ae.setCrc(crc32.unsigned(source));
    }
    this._writeLocalFileHeader(ae);
    if (method === constants.METHOD_STORED) {
      this.write(source);
      this._afterAppend(ae);
      callback(null, ae);
      return;
    } else if (method === constants.METHOD_DEFLATED) {
      this._smartStream(ae, callback).end(source);
      return;
    } else {
      callback(new Error("compression method " + method + " not implemented"));
      return;
    }
  };
  ZipArchiveOutputStream.prototype._appendStream = function(ae, source, callback) {
    ae.getGeneralPurposeBit().useDataDescriptor(true);
    ae.setVersionNeededToExtract(constants.MIN_VERSION_DATA_DESCRIPTOR);
    this._writeLocalFileHeader(ae);
    var smart = this._smartStream(ae, callback);
    source.once("error", function(err) {
      smart.emit("error", err);
      smart.end();
    });
    source.pipe(smart);
  };
  ZipArchiveOutputStream.prototype._defaults = function(o) {
    if (typeof o !== "object") {
      o = {};
    }
    if (typeof o.zlib !== "object") {
      o.zlib = {};
    }
    if (typeof o.zlib.level !== "number") {
      o.zlib.level = constants.ZLIB_BEST_SPEED;
    }
    o.forceZip64 = !!o.forceZip64;
    o.forceLocalTime = !!o.forceLocalTime;
    return o;
  };
  ZipArchiveOutputStream.prototype._finish = function() {
    this._archive.centralOffset = this.offset;
    this._entries.forEach(function(ae) {
      this._writeCentralFileHeader(ae);
    }.bind(this));
    this._archive.centralLength = this.offset - this._archive.centralOffset;
    if (this.isZip64()) {
      this._writeCentralDirectoryZip64();
    }
    this._writeCentralDirectoryEnd();
    this._archive.processing = false;
    this._archive.finish = true;
    this._archive.finished = true;
    this.end();
  };
  ZipArchiveOutputStream.prototype._normalizeEntry = function(ae) {
    if (ae.getMethod() === -1) {
      ae.setMethod(constants.METHOD_DEFLATED);
    }
    if (ae.getMethod() === constants.METHOD_DEFLATED) {
      ae.getGeneralPurposeBit().useDataDescriptor(true);
      ae.setVersionNeededToExtract(constants.MIN_VERSION_DATA_DESCRIPTOR);
    }
    if (ae.getTime() === -1) {
      ae.setTime(new Date(), this._archive.forceLocalTime);
    }
    ae._offsets = {
      file: 0,
      data: 0,
      contents: 0
    };
  };
  ZipArchiveOutputStream.prototype._smartStream = function(ae, callback) {
    var deflate = ae.getMethod() === constants.METHOD_DEFLATED;
    var process2 = deflate ? new DeflateCRC32Stream(this.options.zlib) : new CRC32Stream();
    var error = null;
    function handleStuff() {
      var digest = process2.digest().readUInt32BE(0);
      ae.setCrc(digest);
      ae.setSize(process2.size());
      ae.setCompressedSize(process2.size(true));
      this._afterAppend(ae);
      callback(error, ae);
    }
    process2.once("end", handleStuff.bind(this));
    process2.once("error", function(err) {
      error = err;
    });
    process2.pipe(this, {end: false});
    return process2;
  };
  ZipArchiveOutputStream.prototype._writeCentralDirectoryEnd = function() {
    var records = this._entries.length;
    var size = this._archive.centralLength;
    var offset = this._archive.centralOffset;
    if (this.isZip64()) {
      records = constants.ZIP64_MAGIC_SHORT;
      size = constants.ZIP64_MAGIC;
      offset = constants.ZIP64_MAGIC;
    }
    this.write(zipUtil.getLongBytes(constants.SIG_EOCD));
    this.write(constants.SHORT_ZERO);
    this.write(constants.SHORT_ZERO);
    this.write(zipUtil.getShortBytes(records));
    this.write(zipUtil.getShortBytes(records));
    this.write(zipUtil.getLongBytes(size));
    this.write(zipUtil.getLongBytes(offset));
    var comment = this.getComment();
    var commentLength = Buffer.byteLength(comment);
    this.write(zipUtil.getShortBytes(commentLength));
    this.write(comment);
  };
  ZipArchiveOutputStream.prototype._writeCentralDirectoryZip64 = function() {
    this.write(zipUtil.getLongBytes(constants.SIG_ZIP64_EOCD));
    this.write(zipUtil.getEightBytes(44));
    this.write(zipUtil.getShortBytes(constants.MIN_VERSION_ZIP64));
    this.write(zipUtil.getShortBytes(constants.MIN_VERSION_ZIP64));
    this.write(constants.LONG_ZERO);
    this.write(constants.LONG_ZERO);
    this.write(zipUtil.getEightBytes(this._entries.length));
    this.write(zipUtil.getEightBytes(this._entries.length));
    this.write(zipUtil.getEightBytes(this._archive.centralLength));
    this.write(zipUtil.getEightBytes(this._archive.centralOffset));
    this.write(zipUtil.getLongBytes(constants.SIG_ZIP64_EOCD_LOC));
    this.write(constants.LONG_ZERO);
    this.write(zipUtil.getEightBytes(this._archive.centralOffset + this._archive.centralLength));
    this.write(zipUtil.getLongBytes(1));
  };
  ZipArchiveOutputStream.prototype._writeCentralFileHeader = function(ae) {
    var gpb = ae.getGeneralPurposeBit();
    var method = ae.getMethod();
    var offsets = ae._offsets;
    var size = ae.getSize();
    var compressedSize = ae.getCompressedSize();
    if (ae.isZip64() || offsets.file > constants.ZIP64_MAGIC) {
      size = constants.ZIP64_MAGIC;
      compressedSize = constants.ZIP64_MAGIC;
      ae.setVersionNeededToExtract(constants.MIN_VERSION_ZIP64);
      var extraBuf = Buffer.concat([
        zipUtil.getShortBytes(constants.ZIP64_EXTRA_ID),
        zipUtil.getShortBytes(24),
        zipUtil.getEightBytes(ae.getSize()),
        zipUtil.getEightBytes(ae.getCompressedSize()),
        zipUtil.getEightBytes(offsets.file)
      ], 28);
      ae.setExtra(extraBuf);
    }
    this.write(zipUtil.getLongBytes(constants.SIG_CFH));
    this.write(zipUtil.getShortBytes(ae.getPlatform() << 8 | constants.VERSION_MADEBY));
    this.write(zipUtil.getShortBytes(ae.getVersionNeededToExtract()));
    this.write(gpb.encode());
    this.write(zipUtil.getShortBytes(method));
    this.write(zipUtil.getLongBytes(ae.getTimeDos()));
    this.write(zipUtil.getLongBytes(ae.getCrc()));
    this.write(zipUtil.getLongBytes(compressedSize));
    this.write(zipUtil.getLongBytes(size));
    var name = ae.getName();
    var comment = ae.getComment();
    var extra = ae.getCentralDirectoryExtra();
    if (gpb.usesUTF8ForNames()) {
      name = Buffer.from(name);
      comment = Buffer.from(comment);
    }
    this.write(zipUtil.getShortBytes(name.length));
    this.write(zipUtil.getShortBytes(extra.length));
    this.write(zipUtil.getShortBytes(comment.length));
    this.write(constants.SHORT_ZERO);
    this.write(zipUtil.getShortBytes(ae.getInternalAttributes()));
    this.write(zipUtil.getLongBytes(ae.getExternalAttributes()));
    if (offsets.file > constants.ZIP64_MAGIC) {
      this.write(zipUtil.getLongBytes(constants.ZIP64_MAGIC));
    } else {
      this.write(zipUtil.getLongBytes(offsets.file));
    }
    this.write(name);
    this.write(extra);
    this.write(comment);
  };
  ZipArchiveOutputStream.prototype._writeDataDescriptor = function(ae) {
    this.write(zipUtil.getLongBytes(constants.SIG_DD));
    this.write(zipUtil.getLongBytes(ae.getCrc()));
    if (ae.isZip64()) {
      this.write(zipUtil.getEightBytes(ae.getCompressedSize()));
      this.write(zipUtil.getEightBytes(ae.getSize()));
    } else {
      this.write(zipUtil.getLongBytes(ae.getCompressedSize()));
      this.write(zipUtil.getLongBytes(ae.getSize()));
    }
  };
  ZipArchiveOutputStream.prototype._writeLocalFileHeader = function(ae) {
    var gpb = ae.getGeneralPurposeBit();
    var method = ae.getMethod();
    var name = ae.getName();
    var extra = ae.getLocalFileDataExtra();
    if (ae.isZip64()) {
      gpb.useDataDescriptor(true);
      ae.setVersionNeededToExtract(constants.MIN_VERSION_ZIP64);
    }
    if (gpb.usesUTF8ForNames()) {
      name = Buffer.from(name);
    }
    ae._offsets.file = this.offset;
    this.write(zipUtil.getLongBytes(constants.SIG_LFH));
    this.write(zipUtil.getShortBytes(ae.getVersionNeededToExtract()));
    this.write(gpb.encode());
    this.write(zipUtil.getShortBytes(method));
    this.write(zipUtil.getLongBytes(ae.getTimeDos()));
    ae._offsets.data = this.offset;
    if (gpb.usesDataDescriptor()) {
      this.write(constants.LONG_ZERO);
      this.write(constants.LONG_ZERO);
      this.write(constants.LONG_ZERO);
    } else {
      this.write(zipUtil.getLongBytes(ae.getCrc()));
      this.write(zipUtil.getLongBytes(ae.getCompressedSize()));
      this.write(zipUtil.getLongBytes(ae.getSize()));
    }
    this.write(zipUtil.getShortBytes(name.length));
    this.write(zipUtil.getShortBytes(extra.length));
    this.write(name);
    this.write(extra);
    ae._offsets.contents = this.offset;
  };
  ZipArchiveOutputStream.prototype.getComment = function(comment) {
    return this._archive.comment !== null ? this._archive.comment : "";
  };
  ZipArchiveOutputStream.prototype.isZip64 = function() {
    return this._archive.forceZip64 || this._entries.length > constants.ZIP64_MAGIC_SHORT || this._archive.centralLength > constants.ZIP64_MAGIC || this._archive.centralOffset > constants.ZIP64_MAGIC;
  };
  ZipArchiveOutputStream.prototype.setComment = function(comment) {
    this._archive.comment = comment;
  };
});

// ../../node_modules/.pnpm/compress-commons@3.0.0/node_modules/compress-commons/lib/compress-commons.js
var require_compress_commons = __commonJS2((exports2, module2) => {
  module2.exports = {
    ArchiveEntry: require_archive_entry(),
    ZipArchiveEntry: require_zip_archive_entry(),
    ArchiveOutputStream: require_archive_output_stream(),
    ZipArchiveOutputStream: require_zip_archive_output_stream()
  };
});

// ../../node_modules/.pnpm/zip-stream@3.0.1/node_modules/zip-stream/index.js
var require_zip_stream = __commonJS2((exports2, module2) => {
  /**
   * ZipStream
   *
   * @ignore
   * @license [MIT]{@link https://github.com/archiverjs/node-zip-stream/blob/master/LICENSE}
   * @copyright (c) 2014 Chris Talkington, contributors.
   */
  var inherits = require("util").inherits;
  var ZipArchiveOutputStream = require_compress_commons().ZipArchiveOutputStream;
  var ZipArchiveEntry = require_compress_commons().ZipArchiveEntry;
  var util2 = require_archiver_utils();
  var ZipStream = module2.exports = function(options) {
    if (!(this instanceof ZipStream)) {
      return new ZipStream(options);
    }
    options = this.options = options || {};
    options.zlib = options.zlib || {};
    ZipArchiveOutputStream.call(this, options);
    if (typeof options.level === "number" && options.level >= 0) {
      options.zlib.level = options.level;
      delete options.level;
    }
    if (!options.forceZip64 && typeof options.zlib.level === "number" && options.zlib.level === 0) {
      options.store = true;
    }
    if (options.comment && options.comment.length > 0) {
      this.setComment(options.comment);
    }
  };
  inherits(ZipStream, ZipArchiveOutputStream);
  ZipStream.prototype._normalizeFileData = function(data) {
    data = util2.defaults(data, {
      type: "file",
      name: null,
      linkname: null,
      date: null,
      mode: null,
      store: this.options.store,
      comment: ""
    });
    var isDir = data.type === "directory";
    var isSymlink = data.type === "symlink";
    if (data.name) {
      data.name = util2.sanitizePath(data.name);
      if (!isSymlink && data.name.slice(-1) === "/") {
        isDir = true;
        data.type = "directory";
      } else if (isDir) {
        data.name += "/";
      }
    }
    if (isDir || isSymlink) {
      data.store = true;
    }
    data.date = util2.dateify(data.date);
    return data;
  };
  ZipStream.prototype.entry = function(source, data, callback) {
    if (typeof callback !== "function") {
      callback = this._emitErrorCallback.bind(this);
    }
    data = this._normalizeFileData(data);
    if (data.type !== "file" && data.type !== "directory" && data.type !== "symlink") {
      callback(new Error(data.type + " entries not currently supported"));
      return;
    }
    if (typeof data.name !== "string" || data.name.length === 0) {
      callback(new Error("entry name must be a non-empty string value"));
      return;
    }
    if (data.type === "symlink" && typeof data.linkname !== "string") {
      callback(new Error("entry linkname must be a non-empty string value when type equals symlink"));
      return;
    }
    var entry = new ZipArchiveEntry(data.name);
    entry.setTime(data.date, this.options.forceLocalTime);
    if (data.store) {
      entry.setMethod(0);
    }
    if (data.comment.length > 0) {
      entry.setComment(data.comment);
    }
    if (data.type === "symlink" && typeof data.mode !== "number") {
      data.mode = 40960;
    }
    if (typeof data.mode === "number") {
      if (data.type === "symlink") {
        data.mode |= 40960;
      }
      entry.setUnixMode(data.mode);
    }
    if (data.type === "symlink" && typeof data.linkname === "string") {
      source = Buffer.from(data.linkname);
    }
    return ZipArchiveOutputStream.prototype.entry.call(this, entry, source, callback);
  };
  ZipStream.prototype.finalize = function() {
    this.finish();
  };
});

// ../../node_modules/.pnpm/archiver@4.0.2/node_modules/archiver/lib/plugins/zip.js
var require_zip = __commonJS2((exports2, module2) => {
  /**
   * ZIP Format Plugin
   *
   * @module plugins/zip
   * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
   * @copyright (c) 2012-2014 Chris Talkington, contributors.
   */
  var engine = require_zip_stream();
  var util2 = require_archiver_utils();
  var Zip = function(options) {
    if (!(this instanceof Zip)) {
      return new Zip(options);
    }
    options = this.options = util2.defaults(options, {
      comment: "",
      forceUTC: false,
      store: false
    });
    this.supports = {
      directory: true,
      symlink: true
    };
    this.engine = new engine(options);
  };
  Zip.prototype.append = function(source, data, callback) {
    this.engine.entry(source, data, callback);
  };
  Zip.prototype.finalize = function() {
    this.engine.finalize();
  };
  Zip.prototype.on = function() {
    return this.engine.on.apply(this.engine, arguments);
  };
  Zip.prototype.pipe = function() {
    return this.engine.pipe.apply(this.engine, arguments);
  };
  Zip.prototype.unpipe = function() {
    return this.engine.unpipe.apply(this.engine, arguments);
  };
  module2.exports = Zip;
});

// ../../node_modules/.pnpm/bl@4.1.0/node_modules/bl/BufferList.js
var require_BufferList2 = __commonJS2((exports2, module2) => {
  "use strict";
  var {Buffer: Buffer2} = require("buffer");
  var symbol = Symbol.for("BufferList");
  function BufferList(buf) {
    if (!(this instanceof BufferList)) {
      return new BufferList(buf);
    }
    BufferList._init.call(this, buf);
  }
  BufferList._init = function _init(buf) {
    Object.defineProperty(this, symbol, {value: true});
    this._bufs = [];
    this.length = 0;
    if (buf) {
      this.append(buf);
    }
  };
  BufferList.prototype._new = function _new(buf) {
    return new BufferList(buf);
  };
  BufferList.prototype._offset = function _offset(offset) {
    if (offset === 0) {
      return [0, 0];
    }
    let tot = 0;
    for (let i = 0; i < this._bufs.length; i++) {
      const _t = tot + this._bufs[i].length;
      if (offset < _t || i === this._bufs.length - 1) {
        return [i, offset - tot];
      }
      tot = _t;
    }
  };
  BufferList.prototype._reverseOffset = function(blOffset) {
    const bufferId = blOffset[0];
    let offset = blOffset[1];
    for (let i = 0; i < bufferId; i++) {
      offset += this._bufs[i].length;
    }
    return offset;
  };
  BufferList.prototype.get = function get(index) {
    if (index > this.length || index < 0) {
      return void 0;
    }
    const offset = this._offset(index);
    return this._bufs[offset[0]][offset[1]];
  };
  BufferList.prototype.slice = function slice(start, end) {
    if (typeof start === "number" && start < 0) {
      start += this.length;
    }
    if (typeof end === "number" && end < 0) {
      end += this.length;
    }
    return this.copy(null, 0, start, end);
  };
  BufferList.prototype.copy = function copy2(dst, dstStart, srcStart, srcEnd) {
    if (typeof srcStart !== "number" || srcStart < 0) {
      srcStart = 0;
    }
    if (typeof srcEnd !== "number" || srcEnd > this.length) {
      srcEnd = this.length;
    }
    if (srcStart >= this.length) {
      return dst || Buffer2.alloc(0);
    }
    if (srcEnd <= 0) {
      return dst || Buffer2.alloc(0);
    }
    const copy3 = !!dst;
    const off = this._offset(srcStart);
    const len = srcEnd - srcStart;
    let bytes = len;
    let bufoff = copy3 && dstStart || 0;
    let start = off[1];
    if (srcStart === 0 && srcEnd === this.length) {
      if (!copy3) {
        return this._bufs.length === 1 ? this._bufs[0] : Buffer2.concat(this._bufs, this.length);
      }
      for (let i = 0; i < this._bufs.length; i++) {
        this._bufs[i].copy(dst, bufoff);
        bufoff += this._bufs[i].length;
      }
      return dst;
    }
    if (bytes <= this._bufs[off[0]].length - start) {
      return copy3 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
    }
    if (!copy3) {
      dst = Buffer2.allocUnsafe(len);
    }
    for (let i = off[0]; i < this._bufs.length; i++) {
      const l = this._bufs[i].length - start;
      if (bytes > l) {
        this._bufs[i].copy(dst, bufoff, start);
        bufoff += l;
      } else {
        this._bufs[i].copy(dst, bufoff, start, start + bytes);
        bufoff += l;
        break;
      }
      bytes -= l;
      if (start) {
        start = 0;
      }
    }
    if (dst.length > bufoff)
      return dst.slice(0, bufoff);
    return dst;
  };
  BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
    start = start || 0;
    end = typeof end !== "number" ? this.length : end;
    if (start < 0) {
      start += this.length;
    }
    if (end < 0) {
      end += this.length;
    }
    if (start === end) {
      return this._new();
    }
    const startOffset = this._offset(start);
    const endOffset = this._offset(end);
    const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
    if (endOffset[1] === 0) {
      buffers.pop();
    } else {
      buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
    }
    if (startOffset[1] !== 0) {
      buffers[0] = buffers[0].slice(startOffset[1]);
    }
    return this._new(buffers);
  };
  BufferList.prototype.toString = function toString(encoding, start, end) {
    return this.slice(start, end).toString(encoding);
  };
  BufferList.prototype.consume = function consume(bytes) {
    bytes = Math.trunc(bytes);
    if (Number.isNaN(bytes) || bytes <= 0)
      return this;
    while (this._bufs.length) {
      if (bytes >= this._bufs[0].length) {
        bytes -= this._bufs[0].length;
        this.length -= this._bufs[0].length;
        this._bufs.shift();
      } else {
        this._bufs[0] = this._bufs[0].slice(bytes);
        this.length -= bytes;
        break;
      }
    }
    return this;
  };
  BufferList.prototype.duplicate = function duplicate() {
    const copy2 = this._new();
    for (let i = 0; i < this._bufs.length; i++) {
      copy2.append(this._bufs[i]);
    }
    return copy2;
  };
  BufferList.prototype.append = function append(buf) {
    if (buf == null) {
      return this;
    }
    if (buf.buffer) {
      this._appendBuffer(Buffer2.from(buf.buffer, buf.byteOffset, buf.byteLength));
    } else if (Array.isArray(buf)) {
      for (let i = 0; i < buf.length; i++) {
        this.append(buf[i]);
      }
    } else if (this._isBufferList(buf)) {
      for (let i = 0; i < buf._bufs.length; i++) {
        this.append(buf._bufs[i]);
      }
    } else {
      if (typeof buf === "number") {
        buf = buf.toString();
      }
      this._appendBuffer(Buffer2.from(buf));
    }
    return this;
  };
  BufferList.prototype._appendBuffer = function appendBuffer(buf) {
    this._bufs.push(buf);
    this.length += buf.length;
  };
  BufferList.prototype.indexOf = function(search, offset, encoding) {
    if (encoding === void 0 && typeof offset === "string") {
      encoding = offset;
      offset = void 0;
    }
    if (typeof search === "function" || Array.isArray(search)) {
      throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
    } else if (typeof search === "number") {
      search = Buffer2.from([search]);
    } else if (typeof search === "string") {
      search = Buffer2.from(search, encoding);
    } else if (this._isBufferList(search)) {
      search = search.slice();
    } else if (Array.isArray(search.buffer)) {
      search = Buffer2.from(search.buffer, search.byteOffset, search.byteLength);
    } else if (!Buffer2.isBuffer(search)) {
      search = Buffer2.from(search);
    }
    offset = Number(offset || 0);
    if (isNaN(offset)) {
      offset = 0;
    }
    if (offset < 0) {
      offset = this.length + offset;
    }
    if (offset < 0) {
      offset = 0;
    }
    if (search.length === 0) {
      return offset > this.length ? this.length : offset;
    }
    const blOffset = this._offset(offset);
    let blIndex = blOffset[0];
    let buffOffset = blOffset[1];
    for (; blIndex < this._bufs.length; blIndex++) {
      const buff = this._bufs[blIndex];
      while (buffOffset < buff.length) {
        const availableWindow = buff.length - buffOffset;
        if (availableWindow >= search.length) {
          const nativeSearchResult = buff.indexOf(search, buffOffset);
          if (nativeSearchResult !== -1) {
            return this._reverseOffset([blIndex, nativeSearchResult]);
          }
          buffOffset = buff.length - search.length + 1;
        } else {
          const revOffset = this._reverseOffset([blIndex, buffOffset]);
          if (this._match(revOffset, search)) {
            return revOffset;
          }
          buffOffset++;
        }
      }
      buffOffset = 0;
    }
    return -1;
  };
  BufferList.prototype._match = function(offset, search) {
    if (this.length - offset < search.length) {
      return false;
    }
    for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
      if (this.get(offset + searchOffset) !== search[searchOffset]) {
        return false;
      }
    }
    return true;
  };
  (function() {
    const methods = {
      readDoubleBE: 8,
      readDoubleLE: 8,
      readFloatBE: 4,
      readFloatLE: 4,
      readInt32BE: 4,
      readInt32LE: 4,
      readUInt32BE: 4,
      readUInt32LE: 4,
      readInt16BE: 2,
      readInt16LE: 2,
      readUInt16BE: 2,
      readUInt16LE: 2,
      readInt8: 1,
      readUInt8: 1,
      readIntBE: null,
      readIntLE: null,
      readUIntBE: null,
      readUIntLE: null
    };
    for (const m2 in methods) {
      (function(m3) {
        if (methods[m3] === null) {
          BufferList.prototype[m3] = function(offset, byteLength) {
            return this.slice(offset, offset + byteLength)[m3](0, byteLength);
          };
        } else {
          BufferList.prototype[m3] = function(offset = 0) {
            return this.slice(offset, offset + methods[m3])[m3](0);
          };
        }
      })(m2);
    }
  })();
  BufferList.prototype._isBufferList = function _isBufferList(b) {
    return b instanceof BufferList || BufferList.isBufferList(b);
  };
  BufferList.isBufferList = function isBufferList(b) {
    return b != null && b[symbol];
  };
  module2.exports = BufferList;
});

// ../../node_modules/.pnpm/bl@4.1.0/node_modules/bl/bl.js
var require_bl = __commonJS2((exports2, module2) => {
  "use strict";
  var DuplexStream = require_readable2().Duplex;
  var inherits = require_inherits2();
  var BufferList = require_BufferList2();
  function BufferListStream(callback) {
    if (!(this instanceof BufferListStream)) {
      return new BufferListStream(callback);
    }
    if (typeof callback === "function") {
      this._callback = callback;
      const piper = function piper2(err) {
        if (this._callback) {
          this._callback(err);
          this._callback = null;
        }
      }.bind(this);
      this.on("pipe", function onPipe(src) {
        src.on("error", piper);
      });
      this.on("unpipe", function onUnpipe(src) {
        src.removeListener("error", piper);
      });
      callback = null;
    }
    BufferList._init.call(this, callback);
    DuplexStream.call(this);
  }
  inherits(BufferListStream, DuplexStream);
  Object.assign(BufferListStream.prototype, BufferList.prototype);
  BufferListStream.prototype._new = function _new(callback) {
    return new BufferListStream(callback);
  };
  BufferListStream.prototype._write = function _write(buf, encoding, callback) {
    this._appendBuffer(buf);
    if (typeof callback === "function") {
      callback();
    }
  };
  BufferListStream.prototype._read = function _read(size) {
    if (!this.length) {
      return this.push(null);
    }
    size = Math.min(size, this.length);
    this.push(this.slice(0, size));
    this.consume(size);
  };
  BufferListStream.prototype.end = function end(chunk) {
    DuplexStream.prototype.end.call(this, chunk);
    if (this._callback) {
      this._callback(null, this.slice());
      this._callback = null;
    }
  };
  BufferListStream.prototype._destroy = function _destroy(err, cb) {
    this._bufs.length = 0;
    this.length = 0;
    cb(err);
  };
  BufferListStream.prototype._isBufferList = function _isBufferList(b) {
    return b instanceof BufferListStream || b instanceof BufferList || BufferListStream.isBufferList(b);
  };
  BufferListStream.isBufferList = BufferList.isBufferList;
  module2.exports = BufferListStream;
  module2.exports.BufferListStream = BufferListStream;
  module2.exports.BufferList = BufferList;
});

// ../../node_modules/.pnpm/tar-stream@2.2.0/node_modules/tar-stream/headers.js
var require_headers = __commonJS2((exports2) => {
  var alloc = Buffer.alloc;
  var ZEROS = "0000000000000000000";
  var SEVENS = "7777777777777777777";
  var ZERO_OFFSET = "0".charCodeAt(0);
  var USTAR_MAGIC = Buffer.from("ustar\0", "binary");
  var USTAR_VER = Buffer.from("00", "binary");
  var GNU_MAGIC = Buffer.from("ustar ", "binary");
  var GNU_VER = Buffer.from(" \0", "binary");
  var MASK = parseInt("7777", 8);
  var MAGIC_OFFSET = 257;
  var VERSION_OFFSET = 263;
  var clamp2 = function(index, len, defaultValue) {
    if (typeof index !== "number")
      return defaultValue;
    index = ~~index;
    if (index >= len)
      return len;
    if (index >= 0)
      return index;
    index += len;
    if (index >= 0)
      return index;
    return 0;
  };
  var toType = function(flag) {
    switch (flag) {
      case 0:
        return "file";
      case 1:
        return "link";
      case 2:
        return "symlink";
      case 3:
        return "character-device";
      case 4:
        return "block-device";
      case 5:
        return "directory";
      case 6:
        return "fifo";
      case 7:
        return "contiguous-file";
      case 72:
        return "pax-header";
      case 55:
        return "pax-global-header";
      case 27:
        return "gnu-long-link-path";
      case 28:
      case 30:
        return "gnu-long-path";
    }
    return null;
  };
  var toTypeflag = function(flag) {
    switch (flag) {
      case "file":
        return 0;
      case "link":
        return 1;
      case "symlink":
        return 2;
      case "character-device":
        return 3;
      case "block-device":
        return 4;
      case "directory":
        return 5;
      case "fifo":
        return 6;
      case "contiguous-file":
        return 7;
      case "pax-header":
        return 72;
    }
    return 0;
  };
  var indexOf = function(block, num, offset, end) {
    for (; offset < end; offset++) {
      if (block[offset] === num)
        return offset;
    }
    return end;
  };
  var cksum = function(block) {
    var sum2 = 8 * 32;
    for (var i = 0; i < 148; i++)
      sum2 += block[i];
    for (var j = 156; j < 512; j++)
      sum2 += block[j];
    return sum2;
  };
  var encodeOct = function(val, n) {
    val = val.toString(8);
    if (val.length > n)
      return SEVENS.slice(0, n) + " ";
    else
      return ZEROS.slice(0, n - val.length) + val + " ";
  };
  function parse256(buf) {
    var positive;
    if (buf[0] === 128)
      positive = true;
    else if (buf[0] === 255)
      positive = false;
    else
      return null;
    var tuple = [];
    for (var i = buf.length - 1; i > 0; i--) {
      var byte = buf[i];
      if (positive)
        tuple.push(byte);
      else
        tuple.push(255 - byte);
    }
    var sum2 = 0;
    var l = tuple.length;
    for (i = 0; i < l; i++) {
      sum2 += tuple[i] * Math.pow(256, i);
    }
    return positive ? sum2 : -1 * sum2;
  }
  var decodeOct = function(val, offset, length) {
    val = val.slice(offset, offset + length);
    offset = 0;
    if (val[offset] & 128) {
      return parse256(val);
    } else {
      while (offset < val.length && val[offset] === 32)
        offset++;
      var end = clamp2(indexOf(val, 32, offset, val.length), val.length, val.length);
      while (offset < end && val[offset] === 0)
        offset++;
      if (end === offset)
        return 0;
      return parseInt(val.slice(offset, end).toString(), 8);
    }
  };
  var decodeStr = function(val, offset, length, encoding) {
    return val.slice(offset, indexOf(val, 0, offset, offset + length)).toString(encoding);
  };
  var addLength = function(str) {
    var len = Buffer.byteLength(str);
    var digits = Math.floor(Math.log(len) / Math.log(10)) + 1;
    if (len + digits >= Math.pow(10, digits))
      digits++;
    return len + digits + str;
  };
  exports2.decodeLongPath = function(buf, encoding) {
    return decodeStr(buf, 0, buf.length, encoding);
  };
  exports2.encodePax = function(opts) {
    var result = "";
    if (opts.name)
      result += addLength(" path=" + opts.name + "\n");
    if (opts.linkname)
      result += addLength(" linkpath=" + opts.linkname + "\n");
    var pax = opts.pax;
    if (pax) {
      for (var key in pax) {
        result += addLength(" " + key + "=" + pax[key] + "\n");
      }
    }
    return Buffer.from(result);
  };
  exports2.decodePax = function(buf) {
    var result = {};
    while (buf.length) {
      var i = 0;
      while (i < buf.length && buf[i] !== 32)
        i++;
      var len = parseInt(buf.slice(0, i).toString(), 10);
      if (!len)
        return result;
      var b = buf.slice(i + 1, len - 1).toString();
      var keyIndex = b.indexOf("=");
      if (keyIndex === -1)
        return result;
      result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1);
      buf = buf.slice(len);
    }
    return result;
  };
  exports2.encode = function(opts) {
    var buf = alloc(512);
    var name = opts.name;
    var prefix = "";
    if (opts.typeflag === 5 && name[name.length - 1] !== "/")
      name += "/";
    if (Buffer.byteLength(name) !== name.length)
      return null;
    while (Buffer.byteLength(name) > 100) {
      var i = name.indexOf("/");
      if (i === -1)
        return null;
      prefix += prefix ? "/" + name.slice(0, i) : name.slice(0, i);
      name = name.slice(i + 1);
    }
    if (Buffer.byteLength(name) > 100 || Buffer.byteLength(prefix) > 155)
      return null;
    if (opts.linkname && Buffer.byteLength(opts.linkname) > 100)
      return null;
    buf.write(name);
    buf.write(encodeOct(opts.mode & MASK, 6), 100);
    buf.write(encodeOct(opts.uid, 6), 108);
    buf.write(encodeOct(opts.gid, 6), 116);
    buf.write(encodeOct(opts.size, 11), 124);
    buf.write(encodeOct(opts.mtime.getTime() / 1e3 | 0, 11), 136);
    buf[156] = ZERO_OFFSET + toTypeflag(opts.type);
    if (opts.linkname)
      buf.write(opts.linkname, 157);
    USTAR_MAGIC.copy(buf, MAGIC_OFFSET);
    USTAR_VER.copy(buf, VERSION_OFFSET);
    if (opts.uname)
      buf.write(opts.uname, 265);
    if (opts.gname)
      buf.write(opts.gname, 297);
    buf.write(encodeOct(opts.devmajor || 0, 6), 329);
    buf.write(encodeOct(opts.devminor || 0, 6), 337);
    if (prefix)
      buf.write(prefix, 345);
    buf.write(encodeOct(cksum(buf), 6), 148);
    return buf;
  };
  exports2.decode = function(buf, filenameEncoding, allowUnknownFormat) {
    var typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET;
    var name = decodeStr(buf, 0, 100, filenameEncoding);
    var mode = decodeOct(buf, 100, 8);
    var uid = decodeOct(buf, 108, 8);
    var gid = decodeOct(buf, 116, 8);
    var size = decodeOct(buf, 124, 12);
    var mtime = decodeOct(buf, 136, 12);
    var type = toType(typeflag);
    var linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding);
    var uname = decodeStr(buf, 265, 32);
    var gname = decodeStr(buf, 297, 32);
    var devmajor = decodeOct(buf, 329, 8);
    var devminor = decodeOct(buf, 337, 8);
    var c = cksum(buf);
    if (c === 8 * 32)
      return null;
    if (c !== decodeOct(buf, 148, 8))
      throw new Error("Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?");
    if (USTAR_MAGIC.compare(buf, MAGIC_OFFSET, MAGIC_OFFSET + 6) === 0) {
      if (buf[345])
        name = decodeStr(buf, 345, 155, filenameEncoding) + "/" + name;
    } else if (GNU_MAGIC.compare(buf, MAGIC_OFFSET, MAGIC_OFFSET + 6) === 0 && GNU_VER.compare(buf, VERSION_OFFSET, VERSION_OFFSET + 2) === 0) {
    } else {
      if (!allowUnknownFormat) {
        throw new Error("Invalid tar header: unknown format.");
      }
    }
    if (typeflag === 0 && name && name[name.length - 1] === "/")
      typeflag = 5;
    return {
      name,
      mode,
      uid,
      gid,
      size,
      mtime: new Date(1e3 * mtime),
      type,
      linkname,
      uname,
      gname,
      devmajor,
      devminor
    };
  };
});

// ../../node_modules/.pnpm/tar-stream@2.2.0/node_modules/tar-stream/extract.js
var require_extract2 = __commonJS2((exports2, module2) => {
  var util2 = require("util");
  var bl = require_bl();
  var headers = require_headers();
  var Writable = require_readable2().Writable;
  var PassThrough = require_readable2().PassThrough;
  var noop = function() {
  };
  var overflow = function(size) {
    size &= 511;
    return size && 512 - size;
  };
  var emptyStream = function(self2, offset) {
    var s2 = new Source(self2, offset);
    s2.end();
    return s2;
  };
  var mixinPax = function(header, pax) {
    if (pax.path)
      header.name = pax.path;
    if (pax.linkpath)
      header.linkname = pax.linkpath;
    if (pax.size)
      header.size = parseInt(pax.size, 10);
    header.pax = pax;
    return header;
  };
  var Source = function(self2, offset) {
    this._parent = self2;
    this.offset = offset;
    PassThrough.call(this, {autoDestroy: false});
  };
  util2.inherits(Source, PassThrough);
  Source.prototype.destroy = function(err) {
    this._parent.destroy(err);
  };
  var Extract = function(opts) {
    if (!(this instanceof Extract))
      return new Extract(opts);
    Writable.call(this, opts);
    opts = opts || {};
    this._offset = 0;
    this._buffer = bl();
    this._missing = 0;
    this._partial = false;
    this._onparse = noop;
    this._header = null;
    this._stream = null;
    this._overflow = null;
    this._cb = null;
    this._locked = false;
    this._destroyed = false;
    this._pax = null;
    this._paxGlobal = null;
    this._gnuLongPath = null;
    this._gnuLongLinkPath = null;
    var self2 = this;
    var b = self2._buffer;
    var oncontinue = function() {
      self2._continue();
    };
    var onunlock = function(err) {
      self2._locked = false;
      if (err)
        return self2.destroy(err);
      if (!self2._stream)
        oncontinue();
    };
    var onstreamend = function() {
      self2._stream = null;
      var drain = overflow(self2._header.size);
      if (drain)
        self2._parse(drain, ondrain);
      else
        self2._parse(512, onheader);
      if (!self2._locked)
        oncontinue();
    };
    var ondrain = function() {
      self2._buffer.consume(overflow(self2._header.size));
      self2._parse(512, onheader);
      oncontinue();
    };
    var onpaxglobalheader = function() {
      var size = self2._header.size;
      self2._paxGlobal = headers.decodePax(b.slice(0, size));
      b.consume(size);
      onstreamend();
    };
    var onpaxheader = function() {
      var size = self2._header.size;
      self2._pax = headers.decodePax(b.slice(0, size));
      if (self2._paxGlobal)
        self2._pax = Object.assign({}, self2._paxGlobal, self2._pax);
      b.consume(size);
      onstreamend();
    };
    var ongnulongpath = function() {
      var size = self2._header.size;
      this._gnuLongPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding);
      b.consume(size);
      onstreamend();
    };
    var ongnulonglinkpath = function() {
      var size = self2._header.size;
      this._gnuLongLinkPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding);
      b.consume(size);
      onstreamend();
    };
    var onheader = function() {
      var offset = self2._offset;
      var header;
      try {
        header = self2._header = headers.decode(b.slice(0, 512), opts.filenameEncoding, opts.allowUnknownFormat);
      } catch (err) {
        self2.emit("error", err);
      }
      b.consume(512);
      if (!header) {
        self2._parse(512, onheader);
        oncontinue();
        return;
      }
      if (header.type === "gnu-long-path") {
        self2._parse(header.size, ongnulongpath);
        oncontinue();
        return;
      }
      if (header.type === "gnu-long-link-path") {
        self2._parse(header.size, ongnulonglinkpath);
        oncontinue();
        return;
      }
      if (header.type === "pax-global-header") {
        self2._parse(header.size, onpaxglobalheader);
        oncontinue();
        return;
      }
      if (header.type === "pax-header") {
        self2._parse(header.size, onpaxheader);
        oncontinue();
        return;
      }
      if (self2._gnuLongPath) {
        header.name = self2._gnuLongPath;
        self2._gnuLongPath = null;
      }
      if (self2._gnuLongLinkPath) {
        header.linkname = self2._gnuLongLinkPath;
        self2._gnuLongLinkPath = null;
      }
      if (self2._pax) {
        self2._header = header = mixinPax(header, self2._pax);
        self2._pax = null;
      }
      self2._locked = true;
      if (!header.size || header.type === "directory") {
        self2._parse(512, onheader);
        self2.emit("entry", header, emptyStream(self2, offset), onunlock);
        return;
      }
      self2._stream = new Source(self2, offset);
      self2.emit("entry", header, self2._stream, onunlock);
      self2._parse(header.size, onstreamend);
      oncontinue();
    };
    this._onheader = onheader;
    this._parse(512, onheader);
  };
  util2.inherits(Extract, Writable);
  Extract.prototype.destroy = function(err) {
    if (this._destroyed)
      return;
    this._destroyed = true;
    if (err)
      this.emit("error", err);
    this.emit("close");
    if (this._stream)
      this._stream.emit("close");
  };
  Extract.prototype._parse = function(size, onparse) {
    if (this._destroyed)
      return;
    this._offset += size;
    this._missing = size;
    if (onparse === this._onheader)
      this._partial = false;
    this._onparse = onparse;
  };
  Extract.prototype._continue = function() {
    if (this._destroyed)
      return;
    var cb = this._cb;
    this._cb = noop;
    if (this._overflow)
      this._write(this._overflow, void 0, cb);
    else
      cb();
  };
  Extract.prototype._write = function(data, enc, cb) {
    if (this._destroyed)
      return;
    var s2 = this._stream;
    var b = this._buffer;
    var missing = this._missing;
    if (data.length)
      this._partial = true;
    if (data.length < missing) {
      this._missing -= data.length;
      this._overflow = null;
      if (s2)
        return s2.write(data, cb);
      b.append(data);
      return cb();
    }
    this._cb = cb;
    this._missing = 0;
    var overflow2 = null;
    if (data.length > missing) {
      overflow2 = data.slice(missing);
      data = data.slice(0, missing);
    }
    if (s2)
      s2.end(data);
    else
      b.append(data);
    this._overflow = overflow2;
    this._onparse();
  };
  Extract.prototype._final = function(cb) {
    if (this._partial)
      return this.destroy(new Error("Unexpected end of data"));
    cb();
  };
  module2.exports = Extract;
});

// ../../node_modules/.pnpm/fs-constants@1.0.0/node_modules/fs-constants/index.js
var require_fs_constants = __commonJS2((exports2, module2) => {
  module2.exports = require("fs").constants || require("constants");
});

// ../../node_modules/.pnpm/end-of-stream@1.4.4/node_modules/end-of-stream/index.js
var require_end_of_stream2 = __commonJS2((exports2, module2) => {
  var once = require_once2();
  var noop = function() {
  };
  var isRequest = function(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  };
  var isChildProcess = function(stream) {
    return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
  };
  var eos = function(stream, opts, callback) {
    if (typeof opts === "function")
      return eos(stream, null, opts);
    if (!opts)
      opts = {};
    callback = once(callback || noop);
    var ws = stream._writableState;
    var rs = stream._readableState;
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var cancelled = false;
    var onlegacyfinish = function() {
      if (!stream.writable)
        onfinish();
    };
    var onfinish = function() {
      writable = false;
      if (!readable)
        callback.call(stream);
    };
    var onend = function() {
      readable = false;
      if (!writable)
        callback.call(stream);
    };
    var onexit = function(exitCode) {
      callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
    };
    var onerror = function(err) {
      callback.call(stream, err);
    };
    var onclose = function() {
      process.nextTick(onclosenexttick);
    };
    var onclosenexttick = function() {
      if (cancelled)
        return;
      if (readable && !(rs && (rs.ended && !rs.destroyed)))
        return callback.call(stream, new Error("premature close"));
      if (writable && !(ws && (ws.ended && !ws.destroyed)))
        return callback.call(stream, new Error("premature close"));
    };
    var onrequest = function() {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req)
        onrequest();
      else
        stream.on("request", onrequest);
    } else if (writable && !ws) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    if (isChildProcess(stream))
      stream.on("exit", onexit);
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false)
      stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
      cancelled = true;
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req)
        stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("exit", onexit);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  };
  module2.exports = eos;
});

// ../../node_modules/.pnpm/tar-stream@2.2.0/node_modules/tar-stream/pack.js
var require_pack2 = __commonJS2((exports2, module2) => {
  var constants = require_fs_constants();
  var eos = require_end_of_stream2();
  var inherits = require_inherits2();
  var alloc = Buffer.alloc;
  var Readable = require_readable2().Readable;
  var Writable = require_readable2().Writable;
  var StringDecoder = require("string_decoder").StringDecoder;
  var headers = require_headers();
  var DMODE = parseInt("755", 8);
  var FMODE = parseInt("644", 8);
  var END_OF_TAR = alloc(1024);
  var noop = function() {
  };
  var overflow = function(self2, size) {
    size &= 511;
    if (size)
      self2.push(END_OF_TAR.slice(0, 512 - size));
  };
  function modeToType(mode) {
    switch (mode & constants.S_IFMT) {
      case constants.S_IFBLK:
        return "block-device";
      case constants.S_IFCHR:
        return "character-device";
      case constants.S_IFDIR:
        return "directory";
      case constants.S_IFIFO:
        return "fifo";
      case constants.S_IFLNK:
        return "symlink";
    }
    return "file";
  }
  var Sink = function(to) {
    Writable.call(this);
    this.written = 0;
    this._to = to;
    this._destroyed = false;
  };
  inherits(Sink, Writable);
  Sink.prototype._write = function(data, enc, cb) {
    this.written += data.length;
    if (this._to.push(data))
      return cb();
    this._to._drain = cb;
  };
  Sink.prototype.destroy = function() {
    if (this._destroyed)
      return;
    this._destroyed = true;
    this.emit("close");
  };
  var LinkSink = function() {
    Writable.call(this);
    this.linkname = "";
    this._decoder = new StringDecoder("utf-8");
    this._destroyed = false;
  };
  inherits(LinkSink, Writable);
  LinkSink.prototype._write = function(data, enc, cb) {
    this.linkname += this._decoder.write(data);
    cb();
  };
  LinkSink.prototype.destroy = function() {
    if (this._destroyed)
      return;
    this._destroyed = true;
    this.emit("close");
  };
  var Void = function() {
    Writable.call(this);
    this._destroyed = false;
  };
  inherits(Void, Writable);
  Void.prototype._write = function(data, enc, cb) {
    cb(new Error("No body allowed for this entry"));
  };
  Void.prototype.destroy = function() {
    if (this._destroyed)
      return;
    this._destroyed = true;
    this.emit("close");
  };
  var Pack = function(opts) {
    if (!(this instanceof Pack))
      return new Pack(opts);
    Readable.call(this, opts);
    this._drain = noop;
    this._finalized = false;
    this._finalizing = false;
    this._destroyed = false;
    this._stream = null;
  };
  inherits(Pack, Readable);
  Pack.prototype.entry = function(header, buffer, callback) {
    if (this._stream)
      throw new Error("already piping an entry");
    if (this._finalized || this._destroyed)
      return;
    if (typeof buffer === "function") {
      callback = buffer;
      buffer = null;
    }
    if (!callback)
      callback = noop;
    var self2 = this;
    if (!header.size || header.type === "symlink")
      header.size = 0;
    if (!header.type)
      header.type = modeToType(header.mode);
    if (!header.mode)
      header.mode = header.type === "directory" ? DMODE : FMODE;
    if (!header.uid)
      header.uid = 0;
    if (!header.gid)
      header.gid = 0;
    if (!header.mtime)
      header.mtime = new Date();
    if (typeof buffer === "string")
      buffer = Buffer.from(buffer);
    if (Buffer.isBuffer(buffer)) {
      header.size = buffer.length;
      this._encode(header);
      var ok = this.push(buffer);
      overflow(self2, header.size);
      if (ok)
        process.nextTick(callback);
      else
        this._drain = callback;
      return new Void();
    }
    if (header.type === "symlink" && !header.linkname) {
      var linkSink = new LinkSink();
      eos(linkSink, function(err) {
        if (err) {
          self2.destroy();
          return callback(err);
        }
        header.linkname = linkSink.linkname;
        self2._encode(header);
        callback();
      });
      return linkSink;
    }
    this._encode(header);
    if (header.type !== "file" && header.type !== "contiguous-file") {
      process.nextTick(callback);
      return new Void();
    }
    var sink = new Sink(this);
    this._stream = sink;
    eos(sink, function(err) {
      self2._stream = null;
      if (err) {
        self2.destroy();
        return callback(err);
      }
      if (sink.written !== header.size) {
        self2.destroy();
        return callback(new Error("size mismatch"));
      }
      overflow(self2, header.size);
      if (self2._finalizing)
        self2.finalize();
      callback();
    });
    return sink;
  };
  Pack.prototype.finalize = function() {
    if (this._stream) {
      this._finalizing = true;
      return;
    }
    if (this._finalized)
      return;
    this._finalized = true;
    this.push(END_OF_TAR);
    this.push(null);
  };
  Pack.prototype.destroy = function(err) {
    if (this._destroyed)
      return;
    this._destroyed = true;
    if (err)
      this.emit("error", err);
    this.emit("close");
    if (this._stream && this._stream.destroy)
      this._stream.destroy();
  };
  Pack.prototype._encode = function(header) {
    if (!header.pax) {
      var buf = headers.encode(header);
      if (buf) {
        this.push(buf);
        return;
      }
    }
    this._encodePax(header);
  };
  Pack.prototype._encodePax = function(header) {
    var paxHeader = headers.encodePax({
      name: header.name,
      linkname: header.linkname,
      pax: header.pax
    });
    var newHeader = {
      name: "PaxHeader",
      mode: header.mode,
      uid: header.uid,
      gid: header.gid,
      size: paxHeader.length,
      mtime: header.mtime,
      type: "pax-header",
      linkname: header.linkname && "PaxHeader",
      uname: header.uname,
      gname: header.gname,
      devmajor: header.devmajor,
      devminor: header.devminor
    };
    this.push(headers.encode(newHeader));
    this.push(paxHeader);
    overflow(this, paxHeader.length);
    newHeader.size = header.size;
    newHeader.type = header.type;
    this.push(headers.encode(newHeader));
  };
  Pack.prototype._read = function(n) {
    var drain = this._drain;
    this._drain = noop;
    drain();
  };
  module2.exports = Pack;
});

// ../../node_modules/.pnpm/tar-stream@2.2.0/node_modules/tar-stream/index.js
var require_tar_stream = __commonJS2((exports2) => {
  exports2.extract = require_extract2();
  exports2.pack = require_pack2();
});

// ../../node_modules/.pnpm/archiver@4.0.2/node_modules/archiver/lib/plugins/tar.js
var require_tar2 = __commonJS2((exports2, module2) => {
  /**
   * TAR Format Plugin
   *
   * @module plugins/tar
   * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
   * @copyright (c) 2012-2014 Chris Talkington, contributors.
   */
  var zlib = require("zlib");
  var engine = require_tar_stream();
  var util2 = require_archiver_utils();
  var Tar = function(options) {
    if (!(this instanceof Tar)) {
      return new Tar(options);
    }
    options = this.options = util2.defaults(options, {
      gzip: false
    });
    if (typeof options.gzipOptions !== "object") {
      options.gzipOptions = {};
    }
    this.supports = {
      directory: true,
      symlink: true
    };
    this.engine = engine.pack(options);
    this.compressor = false;
    if (options.gzip) {
      this.compressor = zlib.createGzip(options.gzipOptions);
      this.compressor.on("error", this._onCompressorError.bind(this));
    }
  };
  Tar.prototype._onCompressorError = function(err) {
    this.engine.emit("error", err);
  };
  Tar.prototype.append = function(source, data, callback) {
    var self2 = this;
    data.mtime = data.date;
    function append(err, sourceBuffer) {
      if (err) {
        callback(err);
        return;
      }
      self2.engine.entry(data, sourceBuffer, function(err2) {
        callback(err2, data);
      });
    }
    if (data.sourceType === "buffer") {
      append(null, source);
    } else if (data.sourceType === "stream" && data.stats) {
      data.size = data.stats.size;
      var entry = self2.engine.entry(data, function(err) {
        callback(err, data);
      });
      source.pipe(entry);
    } else if (data.sourceType === "stream") {
      util2.collectStream(source, append);
    }
  };
  Tar.prototype.finalize = function() {
    this.engine.finalize();
  };
  Tar.prototype.on = function() {
    return this.engine.on.apply(this.engine, arguments);
  };
  Tar.prototype.pipe = function(destination, options) {
    if (this.compressor) {
      return this.engine.pipe.apply(this.engine, [this.compressor]).pipe(destination, options);
    } else {
      return this.engine.pipe.apply(this.engine, arguments);
    }
  };
  Tar.prototype.unpipe = function() {
    if (this.compressor) {
      return this.compressor.unpipe.apply(this.compressor, arguments);
    } else {
      return this.engine.unpipe.apply(this.engine, arguments);
    }
  };
  module2.exports = Tar;
});

// ../../node_modules/.pnpm/archiver@4.0.2/node_modules/archiver/lib/plugins/json.js
var require_json = __commonJS2((exports2, module2) => {
  /**
   * JSON Format Plugin
   *
   * @module plugins/json
   * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
   * @copyright (c) 2012-2014 Chris Talkington, contributors.
   */
  var inherits = require("util").inherits;
  var Transform = require_readable2().Transform;
  var crc32 = require_buffer_crc32();
  var util2 = require_archiver_utils();
  var Json = function(options) {
    if (!(this instanceof Json)) {
      return new Json(options);
    }
    options = this.options = util2.defaults(options, {});
    Transform.call(this, options);
    this.supports = {
      directory: true,
      symlink: true
    };
    this.files = [];
  };
  inherits(Json, Transform);
  Json.prototype._transform = function(chunk, encoding, callback) {
    callback(null, chunk);
  };
  Json.prototype._writeStringified = function() {
    var fileString = JSON.stringify(this.files);
    this.write(fileString);
  };
  Json.prototype.append = function(source, data, callback) {
    var self2 = this;
    data.crc32 = 0;
    function onend(err, sourceBuffer) {
      if (err) {
        callback(err);
        return;
      }
      data.size = sourceBuffer.length || 0;
      data.crc32 = crc32.unsigned(sourceBuffer);
      self2.files.push(data);
      callback(null, data);
    }
    if (data.sourceType === "buffer") {
      onend(null, source);
    } else if (data.sourceType === "stream") {
      util2.collectStream(source, onend);
    }
  };
  Json.prototype.finalize = function() {
    this._writeStringified();
    this.end();
  };
  module2.exports = Json;
});

// ../../node_modules/.pnpm/archiver@4.0.2/node_modules/archiver/index.js
var require_archiver = __commonJS2((exports2, module2) => {
  /**
   * Archiver Vending
   *
   * @ignore
   * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
   * @copyright (c) 2012-2014 Chris Talkington, contributors.
   */
  var Archiver = require_core6();
  var formats = {};
  var vending = function(format2, options) {
    return vending.create(format2, options);
  };
  vending.create = function(format2, options) {
    if (formats[format2]) {
      var instance = new Archiver(format2, options);
      instance.setFormat(format2);
      instance.setModule(new formats[format2](options));
      return instance;
    } else {
      throw new Error("create(" + format2 + "): format not registered");
    }
  };
  vending.registerFormat = function(format2, module3) {
    if (formats[format2]) {
      throw new Error("register(" + format2 + "): format already registered");
    }
    if (typeof module3 !== "function") {
      throw new Error("register(" + format2 + "): format module invalid");
    }
    if (typeof module3.prototype.append !== "function" || typeof module3.prototype.finalize !== "function") {
      throw new Error("register(" + format2 + "): format module missing methods");
    }
    formats[format2] = module3;
  };
  vending.registerFormat("zip", require_zip());
  vending.registerFormat("tar", require_tar2());
  vending.registerFormat("json", require_json());
  module2.exports = vending;
});

// ../../node_modules/.pnpm/tmp@0.2.1/node_modules/tmp/lib/tmp.js
var require_tmp = __commonJS2((exports2, module2) => {
  /*!
   * Tmp
   *
   * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>
   *
   * MIT Licensed
   */
  var fs2 = require("fs");
  var os2 = require("os");
  var path4 = require("path");
  var crypto2 = require("crypto");
  var _c = {fs: fs2.constants, os: os2.constants};
  var rimraf = require_rimraf2();
  var RANDOM_CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  var TEMPLATE_PATTERN = /XXXXXX/;
  var DEFAULT_TRIES = 3;
  var CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR);
  var IS_WIN32 = os2.platform() === "win32";
  var EBADF = _c.EBADF || _c.os.errno.EBADF;
  var ENOENT = _c.ENOENT || _c.os.errno.ENOENT;
  var DIR_MODE = 448;
  var FILE_MODE = 384;
  var EXIT = "exit";
  var _removeObjects = [];
  var FN_RMDIR_SYNC = fs2.rmdirSync.bind(fs2);
  var FN_RIMRAF_SYNC = rimraf.sync;
  var _gracefulCleanup = false;
  function tmpName(options, callback) {
    const args = _parseArguments(options, callback), opts = args[0], cb = args[1];
    try {
      _assertAndSanitizeOptions(opts);
    } catch (err) {
      return cb(err);
    }
    let tries = opts.tries;
    (function _getUniqueName() {
      try {
        const name = _generateTmpName(opts);
        fs2.stat(name, function(err) {
          if (!err) {
            if (tries-- > 0)
              return _getUniqueName();
            return cb(new Error("Could not get a unique tmp filename, max tries reached " + name));
          }
          cb(null, name);
        });
      } catch (err) {
        cb(err);
      }
    })();
  }
  function tmpNameSync(options) {
    const args = _parseArguments(options), opts = args[0];
    _assertAndSanitizeOptions(opts);
    let tries = opts.tries;
    do {
      const name = _generateTmpName(opts);
      try {
        fs2.statSync(name);
      } catch (e) {
        return name;
      }
    } while (tries-- > 0);
    throw new Error("Could not get a unique tmp filename, max tries reached");
  }
  function file(options, callback) {
    const args = _parseArguments(options, callback), opts = args[0], cb = args[1];
    tmpName(opts, function _tmpNameCreated(err, name) {
      if (err)
        return cb(err);
      fs2.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err2, fd) {
        if (err2)
          return cb(err2);
        if (opts.discardDescriptor) {
          return fs2.close(fd, function _discardCallback(possibleErr) {
            return cb(possibleErr, name, void 0, _prepareTmpFileRemoveCallback(name, -1, opts, false));
          });
        } else {
          const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
          cb(null, name, fd, _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, false));
        }
      });
    });
  }
  function fileSync(options) {
    const args = _parseArguments(options), opts = args[0];
    const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
    const name = tmpNameSync(opts);
    var fd = fs2.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);
    if (opts.discardDescriptor) {
      fs2.closeSync(fd);
      fd = void 0;
    }
    return {
      name,
      fd,
      removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, true)
    };
  }
  function dir(options, callback) {
    const args = _parseArguments(options, callback), opts = args[0], cb = args[1];
    tmpName(opts, function _tmpNameCreated(err, name) {
      if (err)
        return cb(err);
      fs2.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err2) {
        if (err2)
          return cb(err2);
        cb(null, name, _prepareTmpDirRemoveCallback(name, opts, false));
      });
    });
  }
  function dirSync(options) {
    const args = _parseArguments(options), opts = args[0];
    const name = tmpNameSync(opts);
    fs2.mkdirSync(name, opts.mode || DIR_MODE);
    return {
      name,
      removeCallback: _prepareTmpDirRemoveCallback(name, opts, true)
    };
  }
  function _removeFileAsync(fdPath, next) {
    const _handler = function(err) {
      if (err && !_isENOENT(err)) {
        return next(err);
      }
      next();
    };
    if (0 <= fdPath[0])
      fs2.close(fdPath[0], function() {
        fs2.unlink(fdPath[1], _handler);
      });
    else
      fs2.unlink(fdPath[1], _handler);
  }
  function _removeFileSync(fdPath) {
    let rethrownException = null;
    try {
      if (0 <= fdPath[0])
        fs2.closeSync(fdPath[0]);
    } catch (e) {
      if (!_isEBADF(e) && !_isENOENT(e))
        throw e;
    } finally {
      try {
        fs2.unlinkSync(fdPath[1]);
      } catch (e) {
        if (!_isENOENT(e))
          rethrownException = e;
      }
    }
    if (rethrownException !== null) {
      throw rethrownException;
    }
  }
  function _prepareTmpFileRemoveCallback(name, fd, opts, sync2) {
    const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [fd, name], sync2);
    const removeCallback = _prepareRemoveCallback(_removeFileAsync, [fd, name], sync2, removeCallbackSync);
    if (!opts.keep)
      _removeObjects.unshift(removeCallbackSync);
    return sync2 ? removeCallbackSync : removeCallback;
  }
  function _prepareTmpDirRemoveCallback(name, opts, sync2) {
    const removeFunction = opts.unsafeCleanup ? rimraf : fs2.rmdir.bind(fs2);
    const removeFunctionSync = opts.unsafeCleanup ? FN_RIMRAF_SYNC : FN_RMDIR_SYNC;
    const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name, sync2);
    const removeCallback = _prepareRemoveCallback(removeFunction, name, sync2, removeCallbackSync);
    if (!opts.keep)
      _removeObjects.unshift(removeCallbackSync);
    return sync2 ? removeCallbackSync : removeCallback;
  }
  function _prepareRemoveCallback(removeFunction, fileOrDirName, sync2, cleanupCallbackSync) {
    let called = false;
    return function _cleanupCallback(next) {
      if (!called) {
        const toRemove = cleanupCallbackSync || _cleanupCallback;
        const index = _removeObjects.indexOf(toRemove);
        if (index >= 0)
          _removeObjects.splice(index, 1);
        called = true;
        if (sync2 || removeFunction === FN_RMDIR_SYNC || removeFunction === FN_RIMRAF_SYNC) {
          return removeFunction(fileOrDirName);
        } else {
          return removeFunction(fileOrDirName, next || function() {
          });
        }
      }
    };
  }
  function _garbageCollector() {
    if (!_gracefulCleanup)
      return;
    while (_removeObjects.length) {
      try {
        _removeObjects[0]();
      } catch (e) {
      }
    }
  }
  function _randomChars(howMany) {
    let value = [], rnd = null;
    try {
      rnd = crypto2.randomBytes(howMany);
    } catch (e) {
      rnd = crypto2.pseudoRandomBytes(howMany);
    }
    for (var i = 0; i < howMany; i++) {
      value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);
    }
    return value.join("");
  }
  function _isBlank(s2) {
    return s2 === null || _isUndefined(s2) || !s2.trim();
  }
  function _isUndefined(obj) {
    return typeof obj === "undefined";
  }
  function _parseArguments(options, callback) {
    if (typeof options === "function") {
      return [{}, options];
    }
    if (_isUndefined(options)) {
      return [{}, callback];
    }
    const actualOptions = {};
    for (const key of Object.getOwnPropertyNames(options)) {
      actualOptions[key] = options[key];
    }
    return [actualOptions, callback];
  }
  function _generateTmpName(opts) {
    const tmpDir = opts.tmpdir;
    if (!_isUndefined(opts.name))
      return path4.join(tmpDir, opts.dir, opts.name);
    if (!_isUndefined(opts.template))
      return path4.join(tmpDir, opts.dir, opts.template).replace(TEMPLATE_PATTERN, _randomChars(6));
    const name = [
      opts.prefix ? opts.prefix : "tmp",
      "-",
      process.pid,
      "-",
      _randomChars(12),
      opts.postfix ? "-" + opts.postfix : ""
    ].join("");
    return path4.join(tmpDir, opts.dir, name);
  }
  function _assertAndSanitizeOptions(options) {
    options.tmpdir = _getTmpDir(options);
    const tmpDir = options.tmpdir;
    if (!_isUndefined(options.name))
      _assertIsRelative(options.name, "name", tmpDir);
    if (!_isUndefined(options.dir))
      _assertIsRelative(options.dir, "dir", tmpDir);
    if (!_isUndefined(options.template)) {
      _assertIsRelative(options.template, "template", tmpDir);
      if (!options.template.match(TEMPLATE_PATTERN))
        throw new Error(`Invalid template, found "${options.template}".`);
    }
    if (!_isUndefined(options.tries) && isNaN(options.tries) || options.tries < 0)
      throw new Error(`Invalid tries, found "${options.tries}".`);
    options.tries = _isUndefined(options.name) ? options.tries || DEFAULT_TRIES : 1;
    options.keep = !!options.keep;
    options.detachDescriptor = !!options.detachDescriptor;
    options.discardDescriptor = !!options.discardDescriptor;
    options.unsafeCleanup = !!options.unsafeCleanup;
    options.dir = _isUndefined(options.dir) ? "" : path4.relative(tmpDir, _resolvePath(options.dir, tmpDir));
    options.template = _isUndefined(options.template) ? void 0 : path4.relative(tmpDir, _resolvePath(options.template, tmpDir));
    options.template = _isBlank(options.template) ? void 0 : path4.relative(options.dir, options.template);
    options.name = _isUndefined(options.name) ? void 0 : _sanitizeName(options.name);
    options.prefix = _isUndefined(options.prefix) ? "" : options.prefix;
    options.postfix = _isUndefined(options.postfix) ? "" : options.postfix;
  }
  function _resolvePath(name, tmpDir) {
    const sanitizedName = _sanitizeName(name);
    if (sanitizedName.startsWith(tmpDir)) {
      return path4.resolve(sanitizedName);
    } else {
      return path4.resolve(path4.join(tmpDir, sanitizedName));
    }
  }
  function _sanitizeName(name) {
    if (_isBlank(name)) {
      return name;
    }
    return name.replace(/["']/g, "");
  }
  function _assertIsRelative(name, option, tmpDir) {
    if (option === "name") {
      if (path4.isAbsolute(name))
        throw new Error(`${option} option must not contain an absolute path, found "${name}".`);
      let basename = path4.basename(name);
      if (basename === ".." || basename === "." || basename !== name)
        throw new Error(`${option} option must not contain a path, found "${name}".`);
    } else {
      if (path4.isAbsolute(name) && !name.startsWith(tmpDir)) {
        throw new Error(`${option} option must be relative to "${tmpDir}", found "${name}".`);
      }
      let resolvedPath = _resolvePath(name, tmpDir);
      if (!resolvedPath.startsWith(tmpDir))
        throw new Error(`${option} option must be relative to "${tmpDir}", found "${resolvedPath}".`);
    }
  }
  function _isEBADF(error) {
    return _isExpectedError(error, -EBADF, "EBADF");
  }
  function _isENOENT(error) {
    return _isExpectedError(error, -ENOENT, "ENOENT");
  }
  function _isExpectedError(error, errno, code) {
    return IS_WIN32 ? error.code === code : error.code === code && error.errno === errno;
  }
  function setGracefulCleanup() {
    _gracefulCleanup = true;
  }
  function _getTmpDir(options) {
    return path4.resolve(_sanitizeName(options && options.tmpdir || os2.tmpdir()));
  }
  process.addListener(EXIT, _garbageCollector);
  Object.defineProperty(module2.exports, "tmpdir", {
    enumerable: true,
    configurable: false,
    get: function() {
      return _getTmpDir();
    }
  });
  module2.exports.dir = dir;
  module2.exports.dirSync = dirSync;
  module2.exports.file = file;
  module2.exports.fileSync = fileSync;
  module2.exports.tmpName = tmpName;
  module2.exports.tmpNameSync = tmpNameSync;
  module2.exports.setGracefulCleanup = setGracefulCleanup;
});

// ../../node_modules/.pnpm/ci-info@3.1.1/node_modules/ci-info/vendors.json
var require_vendors2 = __commonJS2((exports2, module2) => {
  module2.exports = [
    {
      name: "AppVeyor",
      constant: "APPVEYOR",
      env: "APPVEYOR",
      pr: "APPVEYOR_PULL_REQUEST_NUMBER"
    },
    {
      name: "Azure Pipelines",
      constant: "AZURE_PIPELINES",
      env: "SYSTEM_TEAMFOUNDATIONCOLLECTIONURI",
      pr: "SYSTEM_PULLREQUEST_PULLREQUESTID"
    },
    {
      name: "Bamboo",
      constant: "BAMBOO",
      env: "bamboo_planKey"
    },
    {
      name: "Bitbucket Pipelines",
      constant: "BITBUCKET",
      env: "BITBUCKET_COMMIT",
      pr: "BITBUCKET_PR_ID"
    },
    {
      name: "Bitrise",
      constant: "BITRISE",
      env: "BITRISE_IO",
      pr: "BITRISE_PULL_REQUEST"
    },
    {
      name: "Buddy",
      constant: "BUDDY",
      env: "BUDDY_WORKSPACE_ID",
      pr: "BUDDY_EXECUTION_PULL_REQUEST_ID"
    },
    {
      name: "Buildkite",
      constant: "BUILDKITE",
      env: "BUILDKITE",
      pr: {env: "BUILDKITE_PULL_REQUEST", ne: "false"}
    },
    {
      name: "CircleCI",
      constant: "CIRCLE",
      env: "CIRCLECI",
      pr: "CIRCLE_PULL_REQUEST"
    },
    {
      name: "Cirrus CI",
      constant: "CIRRUS",
      env: "CIRRUS_CI",
      pr: "CIRRUS_PR"
    },
    {
      name: "AWS CodeBuild",
      constant: "CODEBUILD",
      env: "CODEBUILD_BUILD_ARN"
    },
    {
      name: "Codeship",
      constant: "CODESHIP",
      env: {CI_NAME: "codeship"}
    },
    {
      name: "Drone",
      constant: "DRONE",
      env: "DRONE",
      pr: {DRONE_BUILD_EVENT: "pull_request"}
    },
    {
      name: "dsari",
      constant: "DSARI",
      env: "DSARI"
    },
    {
      name: "GitHub Actions",
      constant: "GITHUB_ACTIONS",
      env: "GITHUB_ACTIONS",
      pr: {GITHUB_EVENT_NAME: "pull_request"}
    },
    {
      name: "GitLab CI",
      constant: "GITLAB",
      env: "GITLAB_CI",
      pr: "CI_MERGE_REQUEST_ID"
    },
    {
      name: "GoCD",
      constant: "GOCD",
      env: "GO_PIPELINE_LABEL"
    },
    {
      name: "Hudson",
      constant: "HUDSON",
      env: "HUDSON_URL"
    },
    {
      name: "Jenkins",
      constant: "JENKINS",
      env: ["JENKINS_URL", "BUILD_ID"],
      pr: {any: ["ghprbPullId", "CHANGE_ID"]}
    },
    {
      name: "Magnum CI",
      constant: "MAGNUM",
      env: "MAGNUM"
    },
    {
      name: "Netlify CI",
      constant: "NETLIFY",
      env: "NETLIFY",
      pr: {env: "PULL_REQUEST", ne: "false"}
    },
    {
      name: "Nevercode",
      constant: "NEVERCODE",
      env: "NEVERCODE",
      pr: {env: "NEVERCODE_PULL_REQUEST", ne: "false"}
    },
    {
      name: "Render",
      constant: "RENDER",
      env: "RENDER",
      pr: {IS_PULL_REQUEST: "true"}
    },
    {
      name: "Sail CI",
      constant: "SAIL",
      env: "SAILCI",
      pr: "SAIL_PULL_REQUEST_NUMBER"
    },
    {
      name: "Semaphore",
      constant: "SEMAPHORE",
      env: "SEMAPHORE",
      pr: "PULL_REQUEST_NUMBER"
    },
    {
      name: "Screwdriver",
      constant: "SCREWDRIVER",
      env: "SCREWDRIVER",
      pr: {env: "SD_PULL_REQUEST", ne: "false"}
    },
    {
      name: "Shippable",
      constant: "SHIPPABLE",
      env: "SHIPPABLE",
      pr: {IS_PULL_REQUEST: "true"}
    },
    {
      name: "Solano CI",
      constant: "SOLANO",
      env: "TDDIUM",
      pr: "TDDIUM_PR_ID"
    },
    {
      name: "Strider CD",
      constant: "STRIDER",
      env: "STRIDER"
    },
    {
      name: "TaskCluster",
      constant: "TASKCLUSTER",
      env: ["TASK_ID", "RUN_ID"]
    },
    {
      name: "TeamCity",
      constant: "TEAMCITY",
      env: "TEAMCITY_VERSION"
    },
    {
      name: "Travis CI",
      constant: "TRAVIS",
      env: "TRAVIS",
      pr: {env: "TRAVIS_PULL_REQUEST", ne: "false"}
    },
    {
      name: "Vercel",
      constant: "VERCEL",
      env: "NOW_BUILDER"
    },
    {
      name: "Visual Studio App Center",
      constant: "APPCENTER",
      env: "APPCENTER_BUILD_ID"
    }
  ];
});

// ../../node_modules/.pnpm/ci-info@3.1.1/node_modules/ci-info/index.js
var require_ci_info2 = __commonJS2((exports2) => {
  "use strict";
  var vendors = require_vendors2();
  var env2 = process.env;
  Object.defineProperty(exports2, "_vendors", {
    value: vendors.map(function(v) {
      return v.constant;
    })
  });
  exports2.name = null;
  exports2.isPR = null;
  vendors.forEach(function(vendor) {
    const envs = Array.isArray(vendor.env) ? vendor.env : [vendor.env];
    const isCI = envs.every(function(obj) {
      return checkEnv(obj);
    });
    exports2[vendor.constant] = isCI;
    if (isCI) {
      exports2.name = vendor.name;
      switch (typeof vendor.pr) {
        case "string":
          exports2.isPR = !!env2[vendor.pr];
          break;
        case "object":
          if ("env" in vendor.pr) {
            exports2.isPR = vendor.pr.env in env2 && env2[vendor.pr.env] !== vendor.pr.ne;
          } else if ("any" in vendor.pr) {
            exports2.isPR = vendor.pr.any.some(function(key) {
              return !!env2[key];
            });
          } else {
            exports2.isPR = checkEnv(vendor.pr);
          }
          break;
        default:
          exports2.isPR = null;
      }
    }
  });
  exports2.isCI = !!(env2.CI || env2.CONTINUOUS_INTEGRATION || env2.BUILD_NUMBER || env2.RUN_ID || exports2.name || false);
  function checkEnv(obj) {
    if (typeof obj === "string")
      return !!env2[obj];
    return Object.keys(obj).every(function(k) {
      return env2[k] === obj[k];
    });
  }
});

// ../../node_modules/.pnpm/checkpoint-client@1.1.20/node_modules/checkpoint-client/dist/index.js
var require_dist18 = __commonJS2((exports, module) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  var fs = require("fs");
  var path = require("path");
  var os = require("os");
  var util = require("util");
  var crypto = require("crypto");
  var child_process = require("child_process");
  function _interopDefaultLegacy(e) {
    return e && typeof e === "object" && "default" in e ? e : {default: e};
  }
  var fs__default = /* @__PURE__ */ _interopDefaultLegacy(fs);
  var path__default = /* @__PURE__ */ _interopDefaultLegacy(path);
  var os__default = /* @__PURE__ */ _interopDefaultLegacy(os);
  var util__default = /* @__PURE__ */ _interopDefaultLegacy(util);
  var crypto__default = /* @__PURE__ */ _interopDefaultLegacy(crypto);
  var {open, write, close, rename, fsync, unlink} = fs__default["default"];
  var {join, dirname} = path__default["default"];
  var counter = 0;
  function cleanup(dest, err, cb) {
    unlink(dest, function() {
      cb(err);
    });
  }
  function closeAndCleanup(fd, dest, err, cb) {
    close(fd, cleanup.bind(null, dest, err, cb));
  }
  function writeLoop(fd, content, contentLength, offset, cb) {
    write(fd, content, offset, function(err, bytesWritten) {
      if (err) {
        cb(err);
        return;
      }
      return bytesWritten < contentLength - offset ? writeLoop(fd, content, contentLength, offset + bytesWritten, cb) : cb(null);
    });
  }
  function openLoop(dest, cb) {
    open(dest, "w", function(err, fd) {
      if (err) {
        return err.code === "EMFILE" ? openLoop(dest, cb) : cb(err);
      }
      cb(null, fd);
    });
  }
  function writeAtomic(path4, content, cb) {
    const tmp = join(dirname(path4), "." + process.pid + "." + counter++);
    openLoop(tmp, function(err, fd) {
      if (err) {
        cb(err);
        return;
      }
      const contentLength = Buffer.byteLength(content);
      writeLoop(fd, content, contentLength, 0, function(err2) {
        if (err2) {
          closeAndCleanup(fd, tmp, err2, cb);
          return;
        }
        fsync(fd, function(err3) {
          if (err3) {
            closeAndCleanup(fd, tmp, err3, cb);
            return;
          }
          close(fd, function(err4) {
            if (err4) {
              cleanup(tmp, err4, cb);
              return;
            }
            rename(tmp, path4, (err5) => {
              if (err5) {
                cleanup(tmp, err5, cb);
                return;
              }
              cb(null);
            });
          });
        });
      });
      content = null;
    });
  }
  var fastWriteAtomic = writeAtomic;
  var rnds8Pool = new Uint8Array(256);
  var poolPtr = rnds8Pool.length;
  function rng() {
    if (poolPtr > rnds8Pool.length - 16) {
      crypto__default["default"].randomFillSync(rnds8Pool);
      poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
  }
  var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  function validate(uuid) {
    return typeof uuid === "string" && REGEX.test(uuid);
  }
  var byteToHex = [];
  for (let i = 0; i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).substr(1));
  }
  function stringify(arr, offset = 0) {
    const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    if (!validate(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  }
  function v4(options, buf, offset) {
    options = options || {};
    const rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return stringify(rnds);
  }
  var homedir = os__default["default"].homedir();
  var tmpdir = os__default["default"].tmpdir();
  var {env} = process;
  var macos = (name) => {
    const library = path__default["default"].join(homedir, "Library");
    return {
      data: path__default["default"].join(library, "Application Support", name),
      config: path__default["default"].join(library, "Preferences", name),
      cache: path__default["default"].join(library, "Caches", name),
      log: path__default["default"].join(library, "Logs", name),
      temp: path__default["default"].join(tmpdir, name)
    };
  };
  var windows = (name) => {
    const appData = env.APPDATA || path__default["default"].join(homedir, "AppData", "Roaming");
    const localAppData = env.LOCALAPPDATA || path__default["default"].join(homedir, "AppData", "Local");
    return {
      data: path__default["default"].join(localAppData, name, "Data"),
      config: path__default["default"].join(appData, name, "Config"),
      cache: path__default["default"].join(localAppData, name, "Cache"),
      log: path__default["default"].join(localAppData, name, "Log"),
      temp: path__default["default"].join(tmpdir, name)
    };
  };
  var linux = (name) => {
    const username = path__default["default"].basename(homedir);
    return {
      data: path__default["default"].join(env.XDG_DATA_HOME || path__default["default"].join(homedir, ".local", "share"), name),
      config: path__default["default"].join(env.XDG_CONFIG_HOME || path__default["default"].join(homedir, ".config"), name),
      cache: path__default["default"].join(env.XDG_CACHE_HOME || path__default["default"].join(homedir, ".cache"), name),
      log: path__default["default"].join(env.XDG_STATE_HOME || path__default["default"].join(homedir, ".local", "state"), name),
      temp: path__default["default"].join(tmpdir, username, name)
    };
  };
  var envPaths = (name, options) => {
    if (typeof name !== "string") {
      throw new TypeError(`Expected string, got ${typeof name}`);
    }
    options = Object.assign({suffix: "nodejs"}, options);
    if (options.suffix) {
      name += `-${options.suffix}`;
    }
    if (process.platform === "darwin") {
      return macos(name);
    }
    if (process.platform === "win32") {
      return windows(name);
    }
    return linux(name);
  };
  var envPaths_1 = envPaths;
  var _default = envPaths;
  envPaths_1.default = _default;
  function createCommonjsModule(fn) {
    var module2 = {exports: {}};
    return fn(module2, module2.exports), module2.exports;
  }
  var semver = createCommonjsModule(function(module2, exports2) {
    exports2 = module2.exports = SemVer;
    var debug4;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug4 = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    } else {
      debug4 = function() {
      };
    }
    exports2.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER2 = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var re = exports2.re = [];
    var src = exports2.src = [];
    var t = exports2.tokens = {};
    var R = 0;
    function tok(n) {
      t[n] = R++;
    }
    tok("NUMERICIDENTIFIER");
    src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    tok("NUMERICIDENTIFIERLOOSE");
    src[t.NUMERICIDENTIFIERLOOSE] = "[0-9]+";
    tok("NONNUMERICIDENTIFIER");
    src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
    tok("MAINVERSION");
    src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")";
    tok("MAINVERSIONLOOSE");
    src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")";
    tok("PRERELEASEIDENTIFIER");
    src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASEIDENTIFIERLOOSE");
    src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASE");
    src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))";
    tok("PRERELEASELOOSE");
    src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))";
    tok("BUILDIDENTIFIER");
    src[t.BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
    tok("BUILD");
    src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))";
    tok("FULL");
    tok("FULLPLAIN");
    src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?";
    src[t.FULL] = "^" + src[t.FULLPLAIN] + "$";
    tok("LOOSEPLAIN");
    src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?";
    tok("LOOSE");
    src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$";
    tok("GTLT");
    src[t.GTLT] = "((?:<|>)?=?)";
    tok("XRANGEIDENTIFIERLOOSE");
    src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    tok("XRANGEIDENTIFIER");
    src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*";
    tok("XRANGEPLAIN");
    src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?)?)?";
    tok("XRANGEPLAINLOOSE");
    src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?)?)?";
    tok("XRANGE");
    src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$";
    tok("XRANGELOOSE");
    src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$";
    tok("COERCE");
    src[t.COERCE] = "(^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    tok("COERCERTL");
    re[t.COERCERTL] = new RegExp(src[t.COERCE], "g");
    tok("LONETILDE");
    src[t.LONETILDE] = "(?:~>?)";
    tok("TILDETRIM");
    src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+";
    re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
    var tildeTrimReplace = "$1~";
    tok("TILDE");
    src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$";
    tok("TILDELOOSE");
    src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$";
    tok("LONECARET");
    src[t.LONECARET] = "(?:\\^)";
    tok("CARETTRIM");
    src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+";
    re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
    var caretTrimReplace = "$1^";
    tok("CARET");
    src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$";
    tok("CARETLOOSE");
    src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$";
    tok("COMPARATORLOOSE");
    src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$";
    tok("COMPARATOR");
    src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$";
    tok("COMPARATORTRIM");
    src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")";
    re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
    var comparatorTrimReplace = "$1$2$3";
    tok("HYPHENRANGE");
    src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")\\s+-\\s+(" + src[t.XRANGEPLAIN] + ")\\s*$";
    tok("HYPHENRANGELOOSE");
    src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[t.XRANGEPLAINLOOSE] + ")\\s*$";
    tok("STAR");
    src[t.STAR] = "(<|>)?=?\\s*\\*";
    for (var i = 0; i < R; i++) {
      debug4(i, src[i]);
      if (!re[i]) {
        re[i] = new RegExp(src[i]);
      }
    }
    exports2.parse = parse2;
    function parse2(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      if (version.length > MAX_LENGTH) {
        return null;
      }
      var r = options.loose ? re[t.LOOSE] : re[t.FULL];
      if (!r.test(version)) {
        return null;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        return null;
      }
    }
    exports2.valid = valid;
    function valid(version, options) {
      var v = parse2(version, options);
      return v ? v.version : null;
    }
    exports2.clean = clean;
    function clean(version, options) {
      var s2 = parse2(version.trim().replace(/^[=v]+/, ""), options);
      return s2 ? s2.version : null;
    }
    exports2.SemVer = SemVer;
    function SemVer(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        if (version.loose === options.loose) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError("Invalid Version: " + version);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version, options);
      }
      debug4("SemVer", version, options);
      this.options = options;
      this.loose = !!options.loose;
      var m2 = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
      if (!m2) {
        throw new TypeError("Invalid Version: " + version);
      }
      this.raw = version;
      this.major = +m2[1];
      this.minor = +m2[2];
      this.patch = +m2[3];
      if (this.major > MAX_SAFE_INTEGER2 || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER2 || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER2 || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m2[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m2[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER2) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m2[5] ? m2[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug4("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i2 = 0;
      do {
        var a = this.prerelease[i2];
        var b = other.prerelease[i2];
        debug4("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.compareBuild = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      var i2 = 0;
      do {
        var a = this.build[i2];
        var b = other.build[i2];
        debug4("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports2.inc = inc;
    function inc(version, release, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports2.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse2(version1);
        var v2 = parse2(version2);
        var prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports2.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports2.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports2.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports2.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports2.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports2.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    exports2.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    exports2.compareBuild = compareBuild;
    function compareBuild(a, b, loose) {
      var versionA = new SemVer(a, loose);
      var versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    }
    exports2.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports2.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.compareBuild(a, b, loose);
      });
    }
    exports2.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.compareBuild(b, a, loose);
      });
    }
    exports2.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports2.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports2.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports2.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports2.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports2.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports2.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports2.Comparator = Comparator;
    function Comparator(comp, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }
      debug4("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug4("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      var m2 = comp.match(r);
      if (!m2) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m2[1] !== void 0 ? m2[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m2[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m2[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version) {
      debug4("Comparator.test", version, this.options.loose);
      if (this.semver === ANY || version === ANY) {
        return true;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        rangeTmp = new Range(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        rangeTmp = new Range(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports2.Range = Range;
    function Range(range, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        return new Range(range.value, options);
      }
      if (!(this instanceof Range)) {
        return new Range(range, options);
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + range);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      range = range.trim();
      var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug4("hyphen replace", range);
      range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
      debug4("comparator trim", range, re[t.COMPARATORTRIM]);
      range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
      range = range.replace(re[t.CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(" ");
      var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      var set = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };
    Range.prototype.intersects = function(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
          return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };
    function isSatisfiable(comparators, options) {
      var result = true;
      var remainingComparators = comparators.slice();
      var testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every(function(otherComparator) {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    }
    exports2.toComparators = toComparators;
    function toComparators(range, options) {
      return new Range(range, options).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options) {
      debug4("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug4("caret", comp);
      comp = replaceTildes(comp, options);
      debug4("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug4("xrange", comp);
      comp = replaceStars(comp, options);
      debug4("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options);
      }).join(" ");
    }
    function replaceTilde(comp, options) {
      var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, function(_2, M, m2, p, pr) {
        debug4("tilde", comp, _2, M, m2, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m2)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret = ">=" + M + "." + m2 + ".0 <" + M + "." + (+m2 + 1) + ".0";
        } else if (pr) {
          debug4("replaceTilde pr", pr);
          ret = ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + M + "." + (+m2 + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m2 + "." + p + " <" + M + "." + (+m2 + 1) + ".0";
        }
        debug4("tilde return", ret);
        return ret;
      });
    }
    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options);
      }).join(" ");
    }
    function replaceCaret(comp, options) {
      debug4("caret", comp, options);
      var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      return comp.replace(r, function(_2, M, m2, p, pr) {
        debug4("caret", comp, _2, M, m2, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m2)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret = ">=" + M + "." + m2 + ".0 <" + M + "." + (+m2 + 1) + ".0";
          } else {
            ret = ">=" + M + "." + m2 + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug4("replaceCaret pr", pr);
          if (M === "0") {
            if (m2 === "0") {
              ret = ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + M + "." + m2 + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + M + "." + (+m2 + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug4("no pr");
          if (M === "0") {
            if (m2 === "0") {
              ret = ">=" + M + "." + m2 + "." + p + " <" + M + "." + m2 + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m2 + "." + p + " <" + M + "." + (+m2 + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m2 + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug4("caret return", ret);
        return ret;
      });
    }
    function replaceXRanges(comp, options) {
      debug4("replaceXRanges", comp, options);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options);
      }).join(" ");
    }
    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m2, p, pr) {
        debug4("xRange", comp, ret, gtlt, M, m2, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m2);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m2 = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m2 = 0;
              p = 0;
            } else {
              m2 = +m2 + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m2 = +m2 + 1;
            }
          }
          ret = gtlt + M + "." + m2 + "." + p + pr;
        } else if (xm) {
          ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr;
        } else if (xp) {
          ret = ">=" + M + "." + m2 + ".0" + pr + " <" + M + "." + (+m2 + 1) + ".0" + pr;
        }
        debug4("xRange return", ret);
        return ret;
      });
    }
    function replaceStars(comp, options) {
      debug4("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range.prototype.test = function(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      for (var i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set, version, options) {
      for (var i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (i2 = 0; i2 < set.length; i2++) {
          debug4(set[i2].semver);
          if (set[i2].semver === ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            var allowed = set[i2].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports2.satisfies = satisfies;
    function satisfies(version, range, options) {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    }
    exports2.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options) {
      var max2 = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max2 || maxSV.compare(v) === -1) {
            max2 = v;
            maxSV = new SemVer(max2, options);
          }
        }
      });
      return max2;
    }
    exports2.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options) {
      var min2 = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min2 || minSV.compare(v) === 1) {
            min2 = v;
            minSV = new SemVer(min2, options);
          }
        }
      });
      return min2;
    }
    exports2.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }
    exports2.validRange = validRange;
    function validRange(range, options) {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports2.ltr = ltr;
    function ltr(version, range, options) {
      return outside(version, range, "<", options);
    }
    exports2.gtr = gtr;
    function gtr(version, range, options) {
      return outside(version, range, ">", options);
    }
    exports2.outside = outside;
    function outside(version, range, hilo, options) {
      version = new SemVer(version, options);
      range = new Range(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports2.prerelease = prerelease;
    function prerelease(version, options) {
      var parsed = parse2(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports2.intersects = intersects;
    function intersects(r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    }
    exports2.coerce = coerce;
    function coerce(version, options) {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      var match = null;
      if (!options.rtl) {
        match = version.match(re[t.COERCE]);
      } else {
        var next;
        while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        re[t.COERCERTL].lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      return parse2(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options);
    }
  });
  var {promisify} = util__default["default"];
  var useNativeRecursiveOption = semver.satisfies(process.version, ">=10.12.0");
  var checkPath = (pth) => {
    if (process.platform === "win32") {
      const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path__default["default"].parse(pth).root, ""));
      if (pathHasInvalidWinCharacters) {
        const error = new Error(`Path contains invalid characters: ${pth}`);
        error.code = "EINVAL";
        throw error;
      }
    }
  };
  var processOptions = (options) => {
    const defaults = {
      mode: 511,
      fs: fs__default["default"]
    };
    return {
      ...defaults,
      ...options
    };
  };
  var permissionError = (pth) => {
    const error = new Error(`operation not permitted, mkdir '${pth}'`);
    error.code = "EPERM";
    error.errno = -4048;
    error.path = pth;
    error.syscall = "mkdir";
    return error;
  };
  var makeDir = async (input, options) => {
    checkPath(input);
    options = processOptions(options);
    const mkdir2 = promisify(options.fs.mkdir);
    const stat2 = promisify(options.fs.stat);
    if (useNativeRecursiveOption && options.fs.mkdir === fs__default["default"].mkdir) {
      const pth = path__default["default"].resolve(input);
      await mkdir2(pth, {
        mode: options.mode,
        recursive: true
      });
      return pth;
    }
    const make = async (pth) => {
      try {
        await mkdir2(pth, options.mode);
        return pth;
      } catch (error) {
        if (error.code === "EPERM") {
          throw error;
        }
        if (error.code === "ENOENT") {
          if (path__default["default"].dirname(pth) === pth) {
            throw permissionError(pth);
          }
          if (error.message.includes("null bytes")) {
            throw error;
          }
          await make(path__default["default"].dirname(pth));
          return make(pth);
        }
        try {
          const stats = await stat2(pth);
          if (!stats.isDirectory()) {
            throw new Error("The path is not a directory");
          }
        } catch (_2) {
          throw error;
        }
        return pth;
      }
    };
    return make(path__default["default"].resolve(input));
  };
  var makeDir_1 = makeDir;
  var sync = (input, options) => {
    checkPath(input);
    options = processOptions(options);
    if (useNativeRecursiveOption && options.fs.mkdirSync === fs__default["default"].mkdirSync) {
      const pth = path__default["default"].resolve(input);
      fs__default["default"].mkdirSync(pth, {
        mode: options.mode,
        recursive: true
      });
      return pth;
    }
    const make = (pth) => {
      try {
        options.fs.mkdirSync(pth, options.mode);
      } catch (error) {
        if (error.code === "EPERM") {
          throw error;
        }
        if (error.code === "ENOENT") {
          if (path__default["default"].dirname(pth) === pth) {
            throw permissionError(pth);
          }
          if (error.message.includes("null bytes")) {
            throw error;
          }
          make(path__default["default"].dirname(pth));
          return make(pth);
        }
        try {
          if (!options.fs.statSync(pth).isDirectory()) {
            throw new Error("The path is not a directory");
          }
        } catch (_2) {
          throw error;
        }
      }
      return pth;
    };
    return make(path__default["default"].resolve(input));
  };
  makeDir_1.sync = sync;
  var exists = util.promisify(fs__default["default"].exists);
  var readFile = util.promisify(fs__default["default"].readFile);
  var writeFile = util.promisify(fastWriteAtomic);
  var PRISMA_SIGNATURE = "signature";
  var PRISMA_CACHE_FILE = "prisma";
  async function getSignature(signatureFile, cacheFile) {
    const dirs = envPaths_1(`checkpoint`);
    cacheFile = cacheFile || path__default["default"].join(dirs.cache, PRISMA_CACHE_FILE);
    signatureFile = signatureFile || path__default["default"].join(dirs.cache, PRISMA_SIGNATURE);
    if (await exists(signatureFile)) {
      const signature = await readSignature(signatureFile);
      if (signature) {
        return signature;
      }
    }
    if (await exists(cacheFile)) {
      const signature = await readSignature(cacheFile);
      if (signature) {
        await createSignatureFile(signatureFile, signature);
        return signature;
      }
    }
    return await createSignatureFile(signatureFile);
  }
  function isSignatureValid(signature) {
    return typeof signature === "string" && signature.length === 36;
  }
  async function readSignature(file) {
    try {
      const data = await readFile(file, "utf8");
      const {signature} = JSON.parse(data);
      if (isSignatureValid(signature)) {
        return signature;
      }
      return "";
    } catch (err) {
      return "";
    }
  }
  async function createSignatureFile(signatureFile, signature) {
    const signatureState = {
      signature: signature || v4()
    };
    await makeDir_1(path__default["default"].dirname(signatureFile));
    await writeFile(signatureFile, JSON.stringify(signatureState, null, "  "));
    return signatureState.signature;
  }
  var readdir = util__default["default"].promisify(fs__default["default"].readdir);
  var readFile$1 = util__default["default"].promisify(fs__default["default"].readFile);
  var mkdir = util__default["default"].promisify(fs__default["default"].mkdir);
  async function getInfo() {
    const cachePath = envPaths_1("checkpoint").cache;
    if (!fs__default["default"].existsSync(cachePath)) {
      await mkdir(cachePath, {recursive: true});
    }
    const dir = await readdir(cachePath);
    const cacheItems = [];
    for (const item of dir) {
      if (!item.includes("-")) {
        continue;
      }
      try {
        const jsonData = JSON.parse(await readFile$1(path__default["default"].join(cachePath, item), {encoding: "utf-8"}));
        if (jsonData.output && !jsonData.output.cli_path_hash) {
          jsonData.output.cli_path_hash = item.split("-")[1];
        }
        cacheItems.push(jsonData);
      } catch (e) {
        console.error(e);
      }
    }
    return {
      signature: await getSignature(),
      cachePath,
      cacheItems
    };
  }
  var writeFile$1 = util__default["default"].promisify(fastWriteAtomic);
  var readFile$2 = util__default["default"].promisify(fs__default["default"].readFile);
  var unlink$1 = util__default["default"].promisify(fs__default["default"].unlink);
  var defaultSchema = {
    last_reminder: 0,
    cached_at: 0,
    version: "",
    cli_path: "",
    output: {
      client_event_id: "",
      previous_client_event_id: "",
      product: "",
      cli_path_hash: "",
      local_timestamp: "",
      previous_version: "",
      current_version: "",
      current_release_date: 0,
      current_download_url: "",
      current_changelog_url: "",
      package: "",
      release_tag: "",
      install_command: "",
      project_website: "",
      outdated: false,
      alerts: []
    }
  };
  var Config = class {
    static async new(state, schema = defaultSchema) {
      await makeDir_1(path__default["default"].dirname(state.cache_file));
      return new Config(state, schema);
    }
    constructor(state, defaultSchema2) {
      this.state = state;
      this.defaultSchema = defaultSchema2;
    }
    async checkCache(newState) {
      const now = newState.now();
      const cache = await this.all();
      if (!cache) {
        return {cache: void 0, stale: true};
      }
      if (newState.version !== cache.version) {
        return {cache, stale: true};
      }
      if (now - cache.cached_at > newState.cache_duration) {
        return {cache, stale: true};
      }
      return {cache, stale: false};
    }
    async set(update) {
      const existing = await this.all() || {};
      const schema = Object.assign(existing, update);
      for (let k in this.defaultSchema) {
        if (typeof schema[k] === "undefined") {
          schema[k] = this.defaultSchema[k];
        }
      }
      await writeFile$1(this.state.cache_file, JSON.stringify(schema, null, "  "));
    }
    async all() {
      try {
        const data = await readFile$2(this.state.cache_file, "utf8");
        return JSON.parse(data);
      } catch (err) {
        return;
      }
    }
    async get(key) {
      const schema = await this.all();
      if (typeof schema === "undefined") {
        return;
      }
      return schema[key];
    }
    async reset() {
      await writeFile$1(this.state.cache_file, JSON.stringify(this.defaultSchema, null, "  "));
      return;
    }
    async delete() {
      try {
        await unlink$1(this.state.cache_file);
        return;
      } catch (err) {
        return;
      }
    }
  };
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  var ms = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  var childPath = path__default["default"].join(eval("__dirname"), "child");
  async function check(input) {
    const defaultCache = getCacheFile(input.product, input.cli_path_hash || "default");
    const ci = require_ci_info2();
    const state = {
      product: input.product,
      version: input.version,
      cli_install_type: input.cli_install_type || "",
      information: input.information || "",
      local_timestamp: input.local_timestamp || rfc3339(new Date()),
      project_hash: input.project_hash,
      cli_path: input.cli_path || "",
      cli_path_hash: input.cli_path_hash || "",
      endpoint: input.endpoint || "https://checkpoint.prisma.io",
      disable: typeof input.disable === "undefined" ? false : input.disable,
      arch: input.arch || os__default["default"].arch(),
      os: input.os || os__default["default"].platform(),
      node_version: input.node_version || process.version,
      ci: typeof input.ci !== "undefined" ? input.ci : ci.isCI,
      ci_name: typeof input.ci_name !== "undefined" ? input.ci_name || "" : ci.name || "",
      command: input.command || "",
      schema_providers: input.schema_providers || [],
      schema_preview_features: input.schema_preview_features || [],
      schema_generators_providers: input.schema_generators_providers || [],
      cache_file: input.cache_file || defaultCache,
      cache_duration: typeof input.cache_duration === "undefined" ? ms("12h") : input.cache_duration,
      remind_duration: typeof input.remind_duration === "undefined" ? ms("48h") : input.remind_duration,
      force: typeof input.force === "undefined" ? false : input.force,
      timeout: getTimeout(input.timeout),
      unref: typeof input.unref === "undefined" ? true : input.unref,
      child_path: input.child_path || childPath,
      now: () => Date.now(),
      client_event_id: input.client_event_id || "",
      previous_client_event_id: input.previous_client_event_id || "",
      check_if_update_available: false
    };
    if ((process.env["CHECKPOINT_DISABLE"] || state.disable) && !state.force) {
      return {
        status: "disabled"
      };
    }
    const config2 = await Config.new(state);
    const cacheResponse = await config2.checkCache(state);
    state.check_if_update_available = cacheResponse.stale === true || !cacheResponse.cache;
    const child = spawn(state);
    if (state.unref) {
      child.unref();
      child.disconnect();
    }
    if (cacheResponse.stale === true || !cacheResponse.cache) {
      return {
        status: "waiting",
        data: child
      };
    }
    for (const key of Object.keys(state)) {
      if (state[key]) {
        await config2.set({
          [key]: state[key]
        });
      }
    }
    const userReminded = state.now() - cacheResponse.cache.last_reminder < state.remind_duration;
    if (userReminded) {
      return {
        status: "reminded",
        data: cacheResponse.cache.output
      };
    }
    await config2.set({
      last_reminder: state.now()
    });
    return {
      status: "ok",
      data: cacheResponse.cache.output
    };
  }
  function getCacheFile(product, cacheIdentifier) {
    const dirs = envPaths_1(`checkpoint`);
    return path__default["default"].join(dirs.cache, `${product}-${cacheIdentifier}`);
  }
  function getTimeout(inputTimeout) {
    if (typeof inputTimeout !== "undefined") {
      return inputTimeout;
    }
    const timeoutString = process.env["CHECKPOINT_TIMEOUT"];
    if (typeof timeoutString === "undefined") {
      return 5e3;
    }
    const timeout = parseInt(timeoutString, 10);
    if (isNaN(timeout)) {
      return 5e3;
    }
    return timeout;
  }
  function getForkOpts(state) {
    if (state.unref === true) {
      return {
        detached: true,
        stdio: process.env.CHECKPOINT_DEBUG_STDOUT ? "inherit" : "ignore",
        env: process.env
      };
    }
    return {detached: false, stdio: "pipe", env: process.env};
  }
  function spawn(state) {
    return child_process.fork(childPath, [JSON.stringify(state)], getForkOpts(state));
  }
  function rfc3339(d2) {
    function pad(n) {
      return n < 10 ? "0" + n : n;
    }
    function timezoneOffset(offset) {
      let sign2;
      if (offset === 0) {
        return "Z";
      }
      sign2 = offset > 0 ? "-" : "+";
      offset = Math.abs(offset);
      return sign2 + pad(Math.floor(offset / 60)) + ":" + pad(offset % 60);
    }
    return d2.getFullYear() + "-" + pad(d2.getMonth() + 1) + "-" + pad(d2.getDate()) + "T" + pad(d2.getHours()) + ":" + pad(d2.getMinutes()) + ":" + pad(d2.getSeconds()) + timezoneOffset(d2.getTimezoneOffset());
  }
  exports.check = check;
  exports.getInfo = getInfo;
  exports.getSignature = getSignature;
});

// ../sdk/dist/utils/maskSchema.js
var require_maskSchema = __commonJS2((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    mapScalarValues: () => mapScalarValues,
    maskSchema: () => maskSchema2
  });
  function maskSchema2(schema) {
    const regex = /url\s*=\s*.+/;
    return schema.split("\n").map((line) => {
      const match = regex.exec(line);
      if (match) {
        return `${line.slice(0, match.index)}url = "***"`;
      }
      return line;
    }).join("\n");
  }
  function mapScalarValues(obj, mapper) {
    const result = {};
    for (const key in obj) {
      if (typeof obj[key] === "object") {
        result[key] = mapScalarValues(obj[key], mapper);
      } else {
        result[key] = mapper(obj[key]);
      }
    }
    return result;
  }
});

// ../sdk/dist/sendPanic.js
var require_sendPanic = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    ErrorKind: () => ErrorKind,
    createErrorReport: () => createErrorReport,
    makeErrorReportCompleted: () => makeErrorReportCompleted,
    sendPanic: () => sendPanic2
  });
  var import_get_platform2 = __toModule3(require_dist11());
  var import_archiver = __toModule3(require_archiver());
  var import_debug3 = __toModule3(require_dist7());
  var import_fs2 = __toModule3(require("fs"));
  var import_globby = __toModule3(require_globby2());
  var import_node_fetch = __toModule3(require_lib5());
  var import_os = __toModule3(require("os"));
  var import_path4 = __toModule3(require("path"));
  var import_strip_ansi = __toModule3(require_strip_ansi());
  var import_tmp = __toModule3(require_tmp());
  var checkpoint = __toModule3(require_dist18());
  var import_maskSchema = __toModule3(require_maskSchema());
  var import_panic = __toModule3(require_panic());
  var import_fetch_engine2 = __toModule3(require_dist15());
  var import_IntrospectionEngine = __toModule3(require_IntrospectionEngine());
  var debug4 = (0, import_debug3.default)("prisma:sendPanic");
  import_tmp.default.setGracefulCleanup();
  async function sendPanic2(error, cliVersion, binaryVersion) {
    try {
      let schema;
      let maskedSchema;
      if (error.schemaPath) {
        schema = import_fs2.default.readFileSync(error.schemaPath, "utf-8");
      }
      if (error.schema) {
        schema = error.schema;
      }
      if (schema) {
        maskedSchema = (0, import_maskSchema.maskSchema)(schema);
      }
      let sqlDump;
      let dbVersion;
      const schemaOrUrl = error.schema || error.introspectionUrl;
      if (error.area === import_panic.ErrorArea.INTROSPECTION_CLI && schemaOrUrl) {
        let engine;
        try {
          engine = new import_IntrospectionEngine.IntrospectionEngine();
          sqlDump = await engine.getDatabaseDescription(schemaOrUrl);
          dbVersion = await engine.getDatabaseVersion(schemaOrUrl);
          engine.stop();
        } catch (e) {
          debug4(e);
          if (engine && engine.isRunning) {
            engine.stop();
          }
        }
      }
      const migrateRequest = error.request ? JSON.stringify((0, import_maskSchema.mapScalarValues)(error.request, (value) => {
        if (typeof value === "string") {
          return (0, import_maskSchema.maskSchema)(value);
        }
        return value;
      })) : void 0;
      const params = {
        area: error.area,
        kind: ErrorKind.RUST_PANIC,
        cliVersion,
        binaryVersion,
        command: getCommand(),
        jsStackTrace: (0, import_strip_ansi.default)(error.stack || error.message),
        rustStackTrace: error.rustStack,
        operatingSystem: `${import_os.default.arch()} ${import_os.default.platform()} ${import_os.default.release()}`,
        platform: await (0, import_get_platform2.getPlatform)(),
        liftRequest: migrateRequest,
        schemaFile: maskedSchema,
        fingerprint: await checkpoint.getSignature(),
        sqlDump,
        dbVersion
      };
      const signedUrl = await createErrorReport(params);
      if (error.schemaPath) {
        const zip = await makeErrorZip(error);
        await uploadZip(zip, signedUrl);
      }
      const id = await makeErrorReportCompleted(signedUrl);
      return id;
    } catch (e) {
      debug4(e);
    }
  }
  function getCommand() {
    if (process.argv[2] === "introspect") {
      return "introspect";
    } else if (process.argv[2] === "db" && process.argv[3] === "pull") {
      return "db pull";
    }
    return process.argv.slice(2).join(" ");
  }
  async function uploadZip(zip, url) {
    return await (0, import_node_fetch.default)(url, {
      method: "PUT",
      agent: (0, import_fetch_engine2.getProxyAgent)(url),
      headers: {
        "Content-Length": String(zip.byteLength)
      },
      body: zip
    });
  }
  async function makeErrorZip(error) {
    if (!error.schemaPath) {
      throw new Error(`Can't make zip without schema path`);
    }
    const schemaDir = import_path4.default.dirname(error.schemaPath);
    const tmpFileObj = import_tmp.default.fileSync();
    const outputFile = import_fs2.default.createWriteStream(tmpFileObj.name);
    const zip = (0, import_archiver.default)("zip", {zlib: {level: 9}});
    zip.pipe(outputFile);
    const schemaFile = (0, import_maskSchema.maskSchema)(import_fs2.default.readFileSync(error.schemaPath, "utf-8"));
    zip.append(schemaFile, {name: import_path4.default.basename(error.schemaPath)});
    if (import_fs2.default.existsSync(schemaDir)) {
      const filePaths = await (0, import_globby.default)("migrations/**/*", {
        cwd: schemaDir
      });
      for (const filePath of filePaths) {
        let file = import_fs2.default.readFileSync(import_path4.default.resolve(schemaDir, filePath), "utf-8");
        if (filePath.endsWith("schema.prisma") || filePath.endsWith(import_path4.default.basename(error.schemaPath))) {
          file = (0, import_maskSchema.maskSchema)(file);
        }
        zip.append(file, {name: import_path4.default.basename(filePath)});
      }
    }
    zip.finalize();
    return new Promise((resolve, reject) => {
      outputFile.on("close", () => {
        const buffer = import_fs2.default.readFileSync(tmpFileObj.name);
        resolve(buffer);
      });
      zip.on("error", (err) => {
        reject(err);
      });
    });
  }
  var ErrorKind;
  (function(ErrorKind2) {
    ErrorKind2["JS_ERROR"] = "JS_ERROR";
    ErrorKind2["RUST_PANIC"] = "RUST_PANIC";
  })(ErrorKind || (ErrorKind = {}));
  async function createErrorReport(data) {
    const result = await request(`mutation ($data: CreateErrorReportInput!) {
    createErrorReport(data: $data)
  }`, {data});
    return result.createErrorReport;
  }
  async function makeErrorReportCompleted(signedUrl) {
    const result = await request(`mutation ($signedUrl: String!) {
  markErrorReportCompleted(signedUrl: $signedUrl)
}`, {signedUrl});
    return result.markErrorReportCompleted;
  }
  async function request(query, variables) {
    const url = "https://error-reports.prisma.sh/";
    const body = JSON.stringify({
      query,
      variables
    });
    return await (0, import_node_fetch.default)(url, {
      method: "POST",
      agent: (0, import_fetch_engine2.getProxyAgent)(url),
      body,
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json"
      }
    }).then((res) => res.json()).then((res) => {
      if (res.errors) {
        throw new Error(JSON.stringify(res.errors));
      }
      return res.data;
    });
  }
});

// ../sdk/dist/types.js
var require_types4 = __commonJS2((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  __markAsModule3(exports2);
});

// ../../node_modules/.pnpm/yocto-queue@0.1.0/node_modules/yocto-queue/index.js
var require_yocto_queue = __commonJS2((exports2, module2) => {
  var Node = class {
    constructor(value) {
      this.value = value;
      this.next = void 0;
    }
  };
  var Queue = class {
    constructor() {
      this.clear();
    }
    enqueue(value) {
      const node = new Node(value);
      if (this._head) {
        this._tail.next = node;
        this._tail = node;
      } else {
        this._head = node;
        this._tail = node;
      }
      this._size++;
    }
    dequeue() {
      const current = this._head;
      if (!current) {
        return;
      }
      this._head = this._head.next;
      this._size--;
      return current.value;
    }
    clear() {
      this._head = void 0;
      this._tail = void 0;
      this._size = 0;
    }
    get size() {
      return this._size;
    }
    *[Symbol.iterator]() {
      let current = this._head;
      while (current) {
        yield current.value;
        current = current.next;
      }
    }
  };
  module2.exports = Queue;
});

// ../../node_modules/.pnpm/p-limit@3.1.0/node_modules/p-limit/index.js
var require_p_limit3 = __commonJS2((exports2, module2) => {
  "use strict";
  var Queue = require_yocto_queue();
  var pLimit = (concurrency) => {
    if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
      throw new TypeError("Expected `concurrency` to be a number from 1 and up");
    }
    const queue = new Queue();
    let activeCount = 0;
    const next = () => {
      activeCount--;
      if (queue.size > 0) {
        queue.dequeue()();
      }
    };
    const run = async (fn, resolve, ...args) => {
      activeCount++;
      const result = (async () => fn(...args))();
      resolve(result);
      try {
        await result;
      } catch (e) {
      }
      next();
    };
    const enqueue = (fn, resolve, ...args) => {
      queue.enqueue(run.bind(null, fn, resolve, ...args));
      (async () => {
        await Promise.resolve();
        if (activeCount < concurrency && queue.size > 0) {
          queue.dequeue()();
        }
      })();
    };
    const generator = (fn, ...args) => new Promise((resolve) => {
      enqueue(fn, resolve, ...args);
    });
    Object.defineProperties(generator, {
      activeCount: {
        get: () => activeCount
      },
      pendingCount: {
        get: () => queue.size
      },
      clearQueue: {
        value: () => {
          queue.clear();
        }
      }
    });
    return generator;
  };
  module2.exports = pLimit;
});

// ../../node_modules/.pnpm/p-locate@5.0.0/node_modules/p-locate/index.js
var require_p_locate3 = __commonJS2((exports2, module2) => {
  "use strict";
  var pLimit = require_p_limit3();
  var EndError = class extends Error {
    constructor(value) {
      super();
      this.value = value;
    }
  };
  var testElement = async (element, tester) => tester(await element);
  var finder = async (element) => {
    const values = await Promise.all(element);
    if (values[1] === true) {
      throw new EndError(values[0]);
    }
    return false;
  };
  var pLocate = async (iterable, tester, options) => {
    options = {
      concurrency: Infinity,
      preserveOrder: true,
      ...options
    };
    const limit = pLimit(options.concurrency);
    const items = [...iterable].map((element) => [element, limit(testElement, element, tester)]);
    const checkLimit = pLimit(options.preserveOrder ? 1 : Infinity);
    try {
      await Promise.all(items.map((element) => checkLimit(finder, element)));
    } catch (error) {
      if (error instanceof EndError) {
        return error.value;
      }
      throw error;
    }
  };
  module2.exports = pLocate;
});

// ../../node_modules/.pnpm/locate-path@6.0.0/node_modules/locate-path/index.js
var require_locate_path3 = __commonJS2((exports2, module2) => {
  "use strict";
  var path4 = require("path");
  var fs2 = require("fs");
  var {promisify: promisify2} = require("util");
  var pLocate = require_p_locate3();
  var fsStat = promisify2(fs2.stat);
  var fsLStat = promisify2(fs2.lstat);
  var typeMappings = {
    directory: "isDirectory",
    file: "isFile"
  };
  function checkType({type}) {
    if (type in typeMappings) {
      return;
    }
    throw new Error(`Invalid type specified: ${type}`);
  }
  var matchType = (type, stat2) => type === void 0 || stat2[typeMappings[type]]();
  module2.exports = async (paths, options) => {
    options = {
      cwd: process.cwd(),
      type: "file",
      allowSymlinks: true,
      ...options
    };
    checkType(options);
    const statFn = options.allowSymlinks ? fsStat : fsLStat;
    return pLocate(paths, async (path_) => {
      try {
        const stat2 = await statFn(path4.resolve(options.cwd, path_));
        return matchType(options.type, stat2);
      } catch (e) {
        return false;
      }
    }, options);
  };
  module2.exports.sync = (paths, options) => {
    options = {
      cwd: process.cwd(),
      allowSymlinks: true,
      type: "file",
      ...options
    };
    checkType(options);
    const statFn = options.allowSymlinks ? fs2.statSync : fs2.lstatSync;
    for (const path_ of paths) {
      try {
        const stat2 = statFn(path4.resolve(options.cwd, path_));
        if (matchType(options.type, stat2)) {
          return path_;
        }
      } catch (e) {
      }
    }
  };
});

// ../../node_modules/.pnpm/find-up@5.0.0/node_modules/find-up/index.js
var require_find_up3 = __commonJS2((exports2, module2) => {
  "use strict";
  var path4 = require("path");
  var locatePath = require_locate_path3();
  var pathExists = require_path_exists2();
  var stop = Symbol("findUp.stop");
  module2.exports = async (name, options = {}) => {
    let directory = path4.resolve(options.cwd || "");
    const {root} = path4.parse(directory);
    const paths = [].concat(name);
    const runMatcher = async (locateOptions) => {
      if (typeof name !== "function") {
        return locatePath(paths, locateOptions);
      }
      const foundPath = await name(locateOptions.cwd);
      if (typeof foundPath === "string") {
        return locatePath([foundPath], locateOptions);
      }
      return foundPath;
    };
    while (true) {
      const foundPath = await runMatcher({...options, cwd: directory});
      if (foundPath === stop) {
        return;
      }
      if (foundPath) {
        return path4.resolve(directory, foundPath);
      }
      if (directory === root) {
        return;
      }
      directory = path4.dirname(directory);
    }
  };
  module2.exports.sync = (name, options = {}) => {
    let directory = path4.resolve(options.cwd || "");
    const {root} = path4.parse(directory);
    const paths = [].concat(name);
    const runMatcher = (locateOptions) => {
      if (typeof name !== "function") {
        return locatePath.sync(paths, locateOptions);
      }
      const foundPath = name(locateOptions.cwd);
      if (typeof foundPath === "string") {
        return locatePath.sync([foundPath], locateOptions);
      }
      return foundPath;
    };
    while (true) {
      const foundPath = runMatcher({...options, cwd: directory});
      if (foundPath === stop) {
        return;
      }
      if (foundPath) {
        return path4.resolve(directory, foundPath);
      }
      if (directory === root) {
        return;
      }
      directory = path4.dirname(directory);
    }
  };
  module2.exports.exists = pathExists;
  module2.exports.sync.exists = pathExists.sync;
  module2.exports.stop = stop;
});

// ../../node_modules/.pnpm/dotenv@10.0.0/node_modules/dotenv/lib/main.js
var require_main3 = __commonJS2((exports2, module2) => {
  var fs2 = require("fs");
  var path4 = require("path");
  var os2 = require("os");
  function log3(message) {
    console.log(`[dotenv][DEBUG] ${message}`);
  }
  var NEWLINE = "\n";
  var RE_INI_KEY_VAL = /^\s*([\w.-]+)\s*=\s*(.*)?\s*$/;
  var RE_NEWLINES = /\\n/g;
  var NEWLINES_MATCH = /\r\n|\n|\r/;
  function parse2(src, options) {
    const debug4 = Boolean(options && options.debug);
    const obj = {};
    src.toString().split(NEWLINES_MATCH).forEach(function(line, idx) {
      const keyValueArr = line.match(RE_INI_KEY_VAL);
      if (keyValueArr != null) {
        const key = keyValueArr[1];
        let val = keyValueArr[2] || "";
        const end = val.length - 1;
        const isDoubleQuoted = val[0] === '"' && val[end] === '"';
        const isSingleQuoted = val[0] === "'" && val[end] === "'";
        if (isSingleQuoted || isDoubleQuoted) {
          val = val.substring(1, end);
          if (isDoubleQuoted) {
            val = val.replace(RE_NEWLINES, NEWLINE);
          }
        } else {
          val = val.trim();
        }
        obj[key] = val;
      } else if (debug4) {
        log3(`did not match key and value when parsing line ${idx + 1}: ${line}`);
      }
    });
    return obj;
  }
  function resolveHome(envPath) {
    return envPath[0] === "~" ? path4.join(os2.homedir(), envPath.slice(1)) : envPath;
  }
  function config2(options) {
    let dotenvPath = path4.resolve(process.cwd(), ".env");
    let encoding = "utf8";
    let debug4 = false;
    if (options) {
      if (options.path != null) {
        dotenvPath = resolveHome(options.path);
      }
      if (options.encoding != null) {
        encoding = options.encoding;
      }
      if (options.debug != null) {
        debug4 = true;
      }
    }
    try {
      const parsed = parse2(fs2.readFileSync(dotenvPath, {encoding}), {debug: debug4});
      Object.keys(parsed).forEach(function(key) {
        if (!Object.prototype.hasOwnProperty.call(process.env, key)) {
          process.env[key] = parsed[key];
        } else if (debug4) {
          log3(`"${key}" is already defined in \`process.env\` and will not be overwritten`);
        }
      });
      return {parsed};
    } catch (e) {
      return {error: e};
    }
  }
  module2.exports.config = config2;
  module2.exports.parse = parse2;
});

// ../sdk/dist/dotenvExpand.js
var require_dotenvExpand = __commonJS2((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    dotenvExpand: () => dotenvExpand
  });
  function dotenvExpand(config2) {
    const environment = config2.ignoreProcessEnv ? {} : process.env;
    const interpolate = (envValue) => {
      const matches = envValue.match(/(.?\${(?:[a-zA-Z0-9_]+)?})/g) || [];
      return matches.reduce(function(newEnv, match) {
        const parts = /(.?)\${([a-zA-Z0-9_]+)?}/g.exec(match);
        if (!parts) {
          return newEnv;
        }
        const prefix = parts[1];
        let value, replacePart;
        if (prefix === "\\") {
          replacePart = parts[0];
          value = replacePart.replace("\\$", "$");
        } else {
          const key = parts[2];
          replacePart = parts[0].substring(prefix.length);
          value = Object.hasOwnProperty.call(environment, key) ? environment[key] : config2.parsed[key] || "";
          value = interpolate(value);
        }
        return newEnv.replace(replacePart, value);
      }, envValue);
    };
    for (const configKey in config2.parsed) {
      const value = Object.hasOwnProperty.call(environment, configKey) ? environment[configKey] : config2.parsed[configKey];
      config2.parsed[configKey] = interpolate(value);
    }
    for (const processKey in config2.parsed) {
      environment[processKey] = config2.parsed[processKey];
    }
    return config2;
  }
});

// ../sdk/dist/utils/tryLoadEnvs.js
var require_tryLoadEnvs = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    exists: () => exists2,
    loadEnv: () => loadEnv,
    pathsEqual: () => pathsEqual,
    tryLoadEnvs: () => tryLoadEnvs2
  });
  var import_chalk3 = __toModule3(require_source2());
  var import_debug3 = __toModule3(require_dist7());
  var import_dotenv = __toModule3(require_main3());
  var import_fs2 = __toModule3(require("fs"));
  var import_path4 = __toModule3(require("path"));
  var import_dotenvExpand = __toModule3(require_dotenvExpand());
  var debug4 = (0, import_debug3.default)("prisma:tryLoadEnv");
  function tryLoadEnvs2({
    rootEnvPath,
    schemaEnvPath
  }, opts = {
    conflictCheck: "none"
  }) {
    var _a, _b;
    const rootEnvInfo = loadEnv(rootEnvPath);
    if (opts.conflictCheck !== "none") {
      checkForConflicts(rootEnvInfo, schemaEnvPath, opts.conflictCheck);
    }
    let schemaEnvInfo = null;
    if (!pathsEqual(rootEnvInfo == null ? void 0 : rootEnvInfo.path, schemaEnvPath)) {
      schemaEnvInfo = loadEnv(schemaEnvPath);
    }
    if (!rootEnvInfo && !schemaEnvInfo) {
      debug4("No Environment variables loaded");
    }
    if (schemaEnvInfo == null ? void 0 : schemaEnvInfo.dotenvResult.error) {
      return console.error(import_chalk3.default.redBright.bold("Schema Env Error: ") + schemaEnvInfo.dotenvResult.error);
    }
    const messages = [rootEnvInfo == null ? void 0 : rootEnvInfo.message, schemaEnvInfo == null ? void 0 : schemaEnvInfo.message].filter(Boolean);
    return {
      message: messages.join("\n"),
      parsed: {
        ...(_a = rootEnvInfo == null ? void 0 : rootEnvInfo.dotenvResult) == null ? void 0 : _a.parsed,
        ...(_b = schemaEnvInfo == null ? void 0 : schemaEnvInfo.dotenvResult) == null ? void 0 : _b.parsed
      }
    };
  }
  function checkForConflicts(rootEnvInfo, envPath, type) {
    const parsedRootEnv = rootEnvInfo == null ? void 0 : rootEnvInfo.dotenvResult.parsed;
    const areNotTheSame = !pathsEqual(rootEnvInfo == null ? void 0 : rootEnvInfo.path, envPath);
    if (parsedRootEnv && envPath && areNotTheSame && import_fs2.default.existsSync(envPath)) {
      const envConfig = import_dotenv.default.parse(import_fs2.default.readFileSync(envPath));
      const conflicts = [];
      for (const k in envConfig) {
        if (parsedRootEnv[k] === envConfig[k]) {
          conflicts.push(k);
        }
      }
      if (conflicts.length > 0) {
        const relativeRootEnvPath = import_path4.default.relative(process.cwd(), rootEnvInfo.path);
        const relativeEnvPath = import_path4.default.relative(process.cwd(), envPath);
        if (type === "error") {
          const message = `There is a conflict between env var${conflicts.length > 1 ? "s" : ""} in ${import_chalk3.default.underline(relativeRootEnvPath)} and ${import_chalk3.default.underline(relativeEnvPath)}
Conflicting env vars:
${conflicts.map((conflict) => `  ${import_chalk3.default.bold(conflict)}`).join("\n")}

We suggest to move the contents of ${import_chalk3.default.underline(relativeEnvPath)} to ${import_chalk3.default.underline(relativeRootEnvPath)} to consolidate your env vars.
`;
          throw new Error(message);
        } else if (type === "warn") {
          const message = `Conflict for env var${conflicts.length > 1 ? "s" : ""} ${conflicts.map((c) => import_chalk3.default.bold(c)).join(", ")} in ${import_chalk3.default.underline(relativeRootEnvPath)} and ${import_chalk3.default.underline(relativeEnvPath)}
Env vars from ${import_chalk3.default.underline(relativeEnvPath)} overwrite the ones from ${import_chalk3.default.underline(relativeRootEnvPath)}
      `;
          console.warn(`${import_chalk3.default.yellow("warn(prisma)")} ${message}`);
        }
      }
    }
  }
  function loadEnv(envPath) {
    if (exists2(envPath)) {
      debug4(`Environment variables loaded from ${envPath}`);
      const debugEnv = process.env.DEBUG;
      let enableDebug = void 0;
      if (debugEnv && (debugEnv.startsWith("prisma") || debugEnv === "*")) {
        enableDebug = true;
      }
      return {
        dotenvResult: (0, import_dotenvExpand.dotenvExpand)(import_dotenv.default.config({
          path: envPath,
          debug: enableDebug
        })),
        message: import_chalk3.default.dim(`Environment variables loaded from ${import_path4.default.relative(process.cwd(), envPath)}`),
        path: envPath
      };
    } else {
      debug4(`Environment variables not found at ${envPath}`);
    }
    return null;
  }
  function pathsEqual(path1, path22) {
    return path1 && path22 && import_path4.default.resolve(path1) === import_path4.default.resolve(path22);
  }
  function exists2(p) {
    return Boolean(p && import_fs2.default.existsSync(p));
  }
});

// ../sdk/dist/utils/getEnvPaths.js
var require_getEnvPaths = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    getEnvPaths: () => getEnvPaths3
  });
  var import_debug3 = __toModule3(require_dist7());
  var import_find_up = __toModule3(require_find_up3());
  var import_path4 = __toModule3(require("path"));
  var import_fs2 = __toModule3(require("fs"));
  var import_getSchema = __toModule3(require_getSchema());
  var import_tryLoadEnvs = __toModule3(require_tryLoadEnvs());
  var debug4 = (0, import_debug3.default)("prisma:loadEnv");
  function getEnvPaths3(schemaPath, opts = {cwd: process.cwd()}) {
    var _a;
    const rootEnvPath = (_a = getProjectRootEnvPath({cwd: opts.cwd})) != null ? _a : null;
    const schemaEnvPathFromArgs = schemaPathToEnvPath(schemaPath);
    const schemaEnvPathFromPkgJson = schemaPathToEnvPath(readSchemaPathFromPkgJson());
    const schemaEnvPaths = [
      schemaEnvPathFromArgs,
      schemaEnvPathFromPkgJson,
      "./prisma/.env",
      "./.env"
    ];
    const schemaEnvPath = schemaEnvPaths.find(import_tryLoadEnvs.exists);
    return {rootEnvPath, schemaEnvPath};
  }
  function readSchemaPathFromPkgJson() {
    try {
      return (0, import_getSchema.getSchemaPathFromPackageJsonSync)(process.cwd());
    } catch (e) {
      return null;
    }
  }
  function getProjectRootEnvPath(opts) {
    const pkgJsonPath = import_find_up.default.sync((dir) => {
      const pkgPath = import_path4.default.join(dir, "package.json");
      if (import_find_up.default.exists(pkgPath)) {
        try {
          const pkg2 = JSON.parse(import_fs2.default.readFileSync(pkgPath, "utf8"));
          if (pkg2["name"] !== ".prisma/client") {
            debug4(`project root found at ${pkgPath}`);
            return pkgPath;
          }
        } catch (e) {
          debug4(`skipping package.json at ${pkgPath}`);
        }
      }
      return void 0;
    }, opts);
    if (!pkgJsonPath) {
      return null;
    }
    const candidate = import_path4.default.join(import_path4.default.dirname(pkgJsonPath), ".env");
    if (!import_fs2.default.existsSync(candidate)) {
      return null;
    }
    return candidate;
  }
  function schemaPathToEnvPath(schemaPath) {
    if (!schemaPath)
      return null;
    return import_path4.default.join(import_path4.default.dirname(schemaPath), ".env");
  }
});

// ../sdk/dist/utils/trimBlocksFromSchema.js
var require_trimBlocksFromSchema = __commonJS2((exports2) => {
  var __defProp3 = Object.defineProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  __export3(exports2, {
    trimBlocksFromSchema: () => trimBlocksFromSchema2,
    trimNewLine: () => trimNewLine2
  });
  function trimNewLine2(str) {
    if (str === "") {
      return str;
    }
    let newStr = str;
    if (/\r?\n|\r/.exec(newStr[0])) {
      newStr = newStr.slice(1);
    }
    if (newStr.length > 0 && /\r?\n|\r/.exec(newStr[newStr.length - 1])) {
      newStr = newStr.slice(0, newStr.length - 1);
    }
    return newStr;
  }
  function trimBlocksFromSchema2(str, blocks = ["model", "enum", "datasource", "generator"]) {
    const lines = str.split("\n");
    if (lines.length <= 2) {
      return str;
    }
    const modelPositions = [];
    let blockOpen = false;
    let currentStart = -1;
    lines.forEach((line, index) => {
      const trimmed = line.trim();
      if (blocks.some((b) => line.startsWith(b)) && line.endsWith("{")) {
        blockOpen = true;
        currentStart = index;
      }
      if (trimmed.endsWith("}") && currentStart > -1 && blockOpen) {
        modelPositions.push({
          start: currentStart,
          end: index
        });
        blockOpen = false;
        currentStart = -1;
      }
    });
    if (modelPositions.length === 0) {
      return str;
    }
    return trimNewLine2(modelPositions.reduceRight((acc, position) => {
      acc.splice(position.start, position.end - position.start + 1);
      return acc;
    }, lines).join("\n"));
  }
});

// ../sdk/dist/index.js
var require_dist19 = __commonJS2((exports2) => {
  var __create3 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames3 = Object.getOwnPropertyNames;
  var __getProtoOf3 = Object.getPrototypeOf;
  var __hasOwnProp3 = Object.prototype.hasOwnProperty;
  var __markAsModule3 = (target) => __defProp3(target, "__esModule", {value: true});
  var __export3 = (target, all) => {
    __markAsModule3(target);
    for (var name in all)
      __defProp3(target, name, {get: all[name], enumerable: true});
  };
  var __reExport2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames3(module22))
        if (!__hasOwnProp3.call(target, key) && key !== "default")
          __defProp3(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc3(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule3 = (module22) => {
    return __reExport2(__markAsModule3(__defProp3(module22 != null ? __create3(__getProtoOf3(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? {get: () => module22.default, enumerable: true} : {value: module22, enumerable: true})), module22);
  };
  __export3(exports2, {
    BinaryType: () => import_resolveBinary.BinaryType,
    Command: () => import_types.Command,
    Commands: () => import_types.Commands,
    CompiledGeneratorDefinition: () => import_types.CompiledGeneratorDefinition,
    DatabaseCredentials: () => import_types2.DatabaseCredentials,
    Dictionary: () => import_types.Dictionary,
    ErrorArea: () => import_panic.ErrorArea,
    Generator: () => import_Generator2.Generator,
    GeneratorConfig: () => import_types.GeneratorConfig,
    GeneratorDefinition: () => import_types.GeneratorDefinition,
    GeneratorDefinitionWithPackage: () => import_types.GeneratorDefinitionWithPackage,
    GeneratorFunction: () => import_types.GeneratorFunction,
    GeneratorOptions: () => import_types.GeneratorOptions,
    GeneratorPaths: () => import_predefinedGeneratorResolvers2.GeneratorPaths,
    HelpError: () => import_Help.HelpError,
    IntrospectionEngine: () => import_IntrospectionEngine.IntrospectionEngine,
    IntrospectionSchemaVersion: () => import_IntrospectionEngine.IntrospectionSchemaVersion,
    IntrospectionWarnings: () => import_IntrospectionEngine.IntrospectionWarnings,
    MigrateEngineExitCode: () => import_migrateEngineCommands.MigrateEngineExitCode,
    MigrateEngineLogLine: () => import_migrateEngineCommands.MigrateEngineLogLine,
    Platform: () => import_get_platform2.Platform,
    Position: () => import_trimBlocksFromSchema.Position,
    ProviderAliases: () => import_getGenerators.ProviderAliases,
    RustPanic: () => import_panic.RustPanic,
    arg: () => import_utils8.arg,
    canConnectToDatabase: () => import_migrateEngineCommands.canConnectToDatabase,
    createDatabase: () => import_migrateEngineCommands.createDatabase,
    credentialsToUri: () => import_convertCredentials.credentialsToUri,
    drawBox: () => import_drawBox.drawBox,
    dropDatabase: () => import_migrateEngineCommands.dropDatabase,
    engineEnvVarMap: () => import_resolveBinary.engineEnvVarMap,
    extractPreviewFeatures: () => import_extractPreviewFeatures2.extractPreviewFeatures,
    format: () => import_utils8.format,
    getCLIPathHash: () => import_hashes.getCLIPathHash,
    getCommandWithExecutor: () => import_getCommandWithExecutor.getCommandWithExecutor,
    getEnvPaths: () => import_getEnvPaths2.getEnvPaths,
    getGenerator: () => import_getGenerators.getGenerator,
    getGenerators: () => import_getGenerators.getGenerators,
    getNodeAPIName: () => import_get_platform2.getNodeAPIName,
    getPackedPackage: () => import_getPackedPackage.getPackedPackage,
    getPlatform: () => import_get_platform2.getPlatform,
    getProjectHash: () => import_hashes.getProjectHash,
    getRelativeSchemaPath: () => import_getSchema.getRelativeSchemaPath,
    getSchema: () => import_getSchema.getSchema,
    getSchemaDir: () => import_getSchema.getSchemaDir,
    getSchemaDirSync: () => import_getSchema.getSchemaDirSync,
    getSchemaPath: () => import_getSchema.getSchemaPath,
    getSchemaPathFromPackageJson: () => import_getSchema.getSchemaPathFromPackageJson,
    getSchemaPathFromPackageJsonSync: () => import_getSchema.getSchemaPathFromPackageJsonSync,
    getSchemaPathSync: () => import_getSchema.getSchemaPathSync,
    getSchemaSync: () => import_getSchema.getSchemaSync,
    highlightDatamodel: () => import_highlight.highlightDatamodel,
    highlightSql: () => import_highlight.highlightSql,
    highlightTS: () => import_highlight.highlightTS,
    isCi: () => import_isCi.isCi,
    isCurrentBinInstalledGlobally: () => import_isCurrentBinInstalledGlobally.isCurrentBinInstalledGlobally,
    isError: () => import_utils8.isError,
    keyBy: () => import_keyBy.keyBy,
    link: () => import_link.link,
    load: () => import_load.load,
    logger: () => logger2,
    mapPreviewFeatures: () => import_mapPreviewFeatures2.mapPreviewFeatures,
    maskSchema: () => import_maskSchema.maskSchema,
    missingGeneratorMessage: () => import_missingGeneratorMessage2.missingGeneratorMessage,
    parseBinaryTargetsEnvValue: () => import_parseEnvValue2.parseBinaryTargetsEnvValue,
    parseEnvValue: () => import_parseEnvValue2.parseEnvValue,
    pick: () => import_pick2.pick,
    printConfigWarnings: () => import_printConfigWarnings2.printConfigWarnings,
    resolveBinary: () => import_resolveBinary.resolveBinary,
    sendPanic: () => import_sendPanic.sendPanic,
    trimBlocksFromSchema: () => import_trimBlocksFromSchema.trimBlocksFromSchema,
    trimNewLine: () => import_trimBlocksFromSchema.trimNewLine,
    tryLoadEnvs: () => import_tryLoadEnvs.tryLoadEnvs,
    unknownCommand: () => import_Help.unknownCommand,
    uriToCredentials: () => import_convertCredentials.uriToCredentials
  });
  var import_getSchema = __toModule3(require_getSchema());
  var import_hashes = __toModule3(require_hashes());
  var import_Help = __toModule3(require_Help());
  var import_types = __toModule3(require_types2());
  var import_utils8 = __toModule3(require_utils5());
  var import_convertCredentials = __toModule3(require_convertCredentials());
  var import_drawBox = __toModule3(require_drawBox());
  __reExport2(exports2, __toModule3(require_engine_commands()));
  var import_Generator2 = __toModule3(require_Generator());
  var import_getCommandWithExecutor = __toModule3(require_getCommandWithExecutor());
  var import_getGenerators = __toModule3(require_getGenerators());
  var import_getPackedPackage = __toModule3(require_getPackedPackage());
  var import_highlight = __toModule3(require_highlight());
  var import_IntrospectionEngine = __toModule3(require_IntrospectionEngine());
  var import_isCi = __toModule3(require_isCi());
  var import_isCurrentBinInstalledGlobally = __toModule3(require_isCurrentBinInstalledGlobally());
  var import_keyBy = __toModule3(require_keyBy());
  var import_link = __toModule3(require_link());
  var logger2 = __toModule3(require_logger());
  var import_migrateEngineCommands = __toModule3(require_migrateEngineCommands());
  var import_panic = __toModule3(require_panic());
  var import_pick2 = __toModule3(require_pick());
  var import_predefinedGeneratorResolvers2 = __toModule3(require_predefinedGeneratorResolvers());
  var import_resolveBinary = __toModule3(require_resolveBinary());
  var import_sendPanic = __toModule3(require_sendPanic());
  var import_types2 = __toModule3(require_types4());
  var import_extractPreviewFeatures2 = __toModule3(require_extractPreviewFeatures());
  var import_getEnvPaths2 = __toModule3(require_getEnvPaths());
  var import_mapPreviewFeatures2 = __toModule3(require_mapPreviewFeatures());
  var import_maskSchema = __toModule3(require_maskSchema());
  var import_missingGeneratorMessage2 = __toModule3(require_missingGeneratorMessage());
  var import_parseEnvValue2 = __toModule3(require_parseEnvValue());
  var import_printConfigWarnings2 = __toModule3(require_printConfigWarnings());
  var import_load = __toModule3(require_load());
  var import_trimBlocksFromSchema = __toModule3(require_trimBlocksFromSchema());
  var import_tryLoadEnvs = __toModule3(require_tryLoadEnvs());
  var import_get_platform2 = __toModule3(require_dist11());
});

// ../../node_modules/.pnpm/path-exists@3.0.0/node_modules/path-exists/index.js
var require_path_exists3 = __commonJS2((exports2, module2) => {
  "use strict";
  var fs2 = require("fs");
  module2.exports = (fp) => new Promise((resolve) => {
    fs2.access(fp, (err) => {
      resolve(!err);
    });
  });
  module2.exports.sync = (fp) => {
    try {
      fs2.accessSync(fp);
      return true;
    } catch (err) {
      return false;
    }
  };
});

// ../../node_modules/.pnpm/p-locate@3.0.0/node_modules/p-locate/index.js
var require_p_locate4 = __commonJS2((exports2, module2) => {
  "use strict";
  var pLimit = require_p_limit2();
  var EndError = class extends Error {
    constructor(value) {
      super();
      this.value = value;
    }
  };
  var testElement = (el, tester) => Promise.resolve(el).then(tester);
  var finder = (el) => Promise.all(el).then((val) => val[1] === true && Promise.reject(new EndError(val[0])));
  module2.exports = (iterable, tester, opts) => {
    opts = Object.assign({
      concurrency: Infinity,
      preserveOrder: true
    }, opts);
    const limit = pLimit(opts.concurrency);
    const items = [...iterable].map((el) => [el, limit(testElement, el, tester)]);
    const checkLimit = pLimit(opts.preserveOrder ? 1 : Infinity);
    return Promise.all(items.map((el) => checkLimit(finder, el))).then(() => {
    }).catch((err) => err instanceof EndError ? err.value : Promise.reject(err));
  };
});

// ../../node_modules/.pnpm/locate-path@3.0.0/node_modules/locate-path/index.js
var require_locate_path4 = __commonJS2((exports2, module2) => {
  "use strict";
  var path4 = require("path");
  var pathExists = require_path_exists3();
  var pLocate = require_p_locate4();
  module2.exports = (iterable, options) => {
    options = Object.assign({
      cwd: process.cwd()
    }, options);
    return pLocate(iterable, (el) => pathExists(path4.resolve(options.cwd, el)), options);
  };
  module2.exports.sync = (iterable, options) => {
    options = Object.assign({
      cwd: process.cwd()
    }, options);
    for (const el of iterable) {
      if (pathExists.sync(path4.resolve(options.cwd, el))) {
        return el;
      }
    }
  };
});

// ../../node_modules/.pnpm/find-up@3.0.0/node_modules/find-up/index.js
var require_find_up4 = __commonJS2((exports2, module2) => {
  "use strict";
  var path4 = require("path");
  var locatePath = require_locate_path4();
  module2.exports = (filename, opts = {}) => {
    const startDir = path4.resolve(opts.cwd || "");
    const {root} = path4.parse(startDir);
    const filenames = [].concat(filename);
    return new Promise((resolve) => {
      (function find(dir) {
        locatePath(filenames, {cwd: dir}).then((file) => {
          if (file) {
            resolve(path4.join(dir, file));
          } else if (dir === root) {
            resolve(null);
          } else {
            find(path4.dirname(dir));
          }
        });
      })(startDir);
    });
  };
  module2.exports.sync = (filename, opts = {}) => {
    let dir = path4.resolve(opts.cwd || "");
    const {root} = path4.parse(dir);
    const filenames = [].concat(filename);
    while (true) {
      const file = locatePath.sync(filenames, {cwd: dir});
      if (file) {
        return path4.join(dir, file);
      }
      if (dir === root) {
        return null;
      }
      dir = path4.dirname(dir);
    }
  };
});

// ../../node_modules/.pnpm/pkg-up@3.1.0/node_modules/pkg-up/index.js
var require_pkg_up = __commonJS2((exports2, module2) => {
  "use strict";
  var findUp = require_find_up4();
  module2.exports = async ({cwd} = {}) => findUp("package.json", {cwd});
  module2.exports.sync = ({cwd} = {}) => findUp.sync("package.json", {cwd});
});

// ../../node_modules/.pnpm/pluralize@8.0.0/node_modules/pluralize/pluralize.js
var require_pluralize = __commonJS2((exports2, module2) => {
  (function(root, pluralize3) {
    if (typeof exports2 === "object" && typeof module2 === "object") {
      module2.exports = pluralize3();
    } else if (typeof define === "function" && define.amd) {
      define(function() {
        return pluralize3();
      });
    } else {
      root.pluralize = pluralize3();
    }
  })(exports2, function() {
    var pluralRules = [];
    var singularRules = [];
    var uncountables = {};
    var irregularPlurals = {};
    var irregularSingles = {};
    function sanitizeRule(rule) {
      if (typeof rule === "string") {
        return new RegExp("^" + rule + "$", "i");
      }
      return rule;
    }
    function restoreCase(word, token) {
      if (word === token)
        return token;
      if (word === word.toLowerCase())
        return token.toLowerCase();
      if (word === word.toUpperCase())
        return token.toUpperCase();
      if (word[0] === word[0].toUpperCase()) {
        return token.charAt(0).toUpperCase() + token.substr(1).toLowerCase();
      }
      return token.toLowerCase();
    }
    function interpolate(str, args) {
      return str.replace(/\$(\d{1,2})/g, function(match, index) {
        return args[index] || "";
      });
    }
    function replace(word, rule) {
      return word.replace(rule[0], function(match, index) {
        var result = interpolate(rule[1], arguments);
        if (match === "") {
          return restoreCase(word[index - 1], result);
        }
        return restoreCase(match, result);
      });
    }
    function sanitizeWord(token, word, rules) {
      if (!token.length || uncountables.hasOwnProperty(token)) {
        return word;
      }
      var len = rules.length;
      while (len--) {
        var rule = rules[len];
        if (rule[0].test(word))
          return replace(word, rule);
      }
      return word;
    }
    function replaceWord(replaceMap, keepMap, rules) {
      return function(word) {
        var token = word.toLowerCase();
        if (keepMap.hasOwnProperty(token)) {
          return restoreCase(word, token);
        }
        if (replaceMap.hasOwnProperty(token)) {
          return restoreCase(word, replaceMap[token]);
        }
        return sanitizeWord(token, word, rules);
      };
    }
    function checkWord(replaceMap, keepMap, rules, bool) {
      return function(word) {
        var token = word.toLowerCase();
        if (keepMap.hasOwnProperty(token))
          return true;
        if (replaceMap.hasOwnProperty(token))
          return false;
        return sanitizeWord(token, token, rules) === token;
      };
    }
    function pluralize3(word, count, inclusive) {
      var pluralized = count === 1 ? pluralize3.singular(word) : pluralize3.plural(word);
      return (inclusive ? count + " " : "") + pluralized;
    }
    pluralize3.plural = replaceWord(irregularSingles, irregularPlurals, pluralRules);
    pluralize3.isPlural = checkWord(irregularSingles, irregularPlurals, pluralRules);
    pluralize3.singular = replaceWord(irregularPlurals, irregularSingles, singularRules);
    pluralize3.isSingular = checkWord(irregularPlurals, irregularSingles, singularRules);
    pluralize3.addPluralRule = function(rule, replacement) {
      pluralRules.push([sanitizeRule(rule), replacement]);
    };
    pluralize3.addSingularRule = function(rule, replacement) {
      singularRules.push([sanitizeRule(rule), replacement]);
    };
    pluralize3.addUncountableRule = function(word) {
      if (typeof word === "string") {
        uncountables[word.toLowerCase()] = true;
        return;
      }
      pluralize3.addPluralRule(word, "$0");
      pluralize3.addSingularRule(word, "$0");
    };
    pluralize3.addIrregularRule = function(single, plural2) {
      plural2 = plural2.toLowerCase();
      single = single.toLowerCase();
      irregularSingles[single] = plural2;
      irregularPlurals[plural2] = single;
    };
    [
      ["I", "we"],
      ["me", "us"],
      ["he", "they"],
      ["she", "they"],
      ["them", "them"],
      ["myself", "ourselves"],
      ["yourself", "yourselves"],
      ["itself", "themselves"],
      ["herself", "themselves"],
      ["himself", "themselves"],
      ["themself", "themselves"],
      ["is", "are"],
      ["was", "were"],
      ["has", "have"],
      ["this", "these"],
      ["that", "those"],
      ["echo", "echoes"],
      ["dingo", "dingoes"],
      ["volcano", "volcanoes"],
      ["tornado", "tornadoes"],
      ["torpedo", "torpedoes"],
      ["genus", "genera"],
      ["viscus", "viscera"],
      ["stigma", "stigmata"],
      ["stoma", "stomata"],
      ["dogma", "dogmata"],
      ["lemma", "lemmata"],
      ["schema", "schemata"],
      ["anathema", "anathemata"],
      ["ox", "oxen"],
      ["axe", "axes"],
      ["die", "dice"],
      ["yes", "yeses"],
      ["foot", "feet"],
      ["eave", "eaves"],
      ["goose", "geese"],
      ["tooth", "teeth"],
      ["quiz", "quizzes"],
      ["human", "humans"],
      ["proof", "proofs"],
      ["carve", "carves"],
      ["valve", "valves"],
      ["looey", "looies"],
      ["thief", "thieves"],
      ["groove", "grooves"],
      ["pickaxe", "pickaxes"],
      ["passerby", "passersby"]
    ].forEach(function(rule) {
      return pluralize3.addIrregularRule(rule[0], rule[1]);
    });
    [
      [/s?$/i, "s"],
      [/[^\u0000-\u007F]$/i, "$0"],
      [/([^aeiou]ese)$/i, "$1"],
      [/(ax|test)is$/i, "$1es"],
      [/(alias|[^aou]us|t[lm]as|gas|ris)$/i, "$1es"],
      [/(e[mn]u)s?$/i, "$1s"],
      [/([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$/i, "$1"],
      [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1i"],
      [/(alumn|alg|vertebr)(?:a|ae)$/i, "$1ae"],
      [/(seraph|cherub)(?:im)?$/i, "$1im"],
      [/(her|at|gr)o$/i, "$1oes"],
      [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, "$1a"],
      [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, "$1a"],
      [/sis$/i, "ses"],
      [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, "$1$2ves"],
      [/([^aeiouy]|qu)y$/i, "$1ies"],
      [/([^ch][ieo][ln])ey$/i, "$1ies"],
      [/(x|ch|ss|sh|zz)$/i, "$1es"],
      [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, "$1ices"],
      [/\b((?:tit)?m|l)(?:ice|ouse)$/i, "$1ice"],
      [/(pe)(?:rson|ople)$/i, "$1ople"],
      [/(child)(?:ren)?$/i, "$1ren"],
      [/eaux$/i, "$0"],
      [/m[ae]n$/i, "men"],
      ["thou", "you"]
    ].forEach(function(rule) {
      return pluralize3.addPluralRule(rule[0], rule[1]);
    });
    [
      [/s$/i, ""],
      [/(ss)$/i, "$1"],
      [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i, "$1fe"],
      [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, "$1f"],
      [/ies$/i, "y"],
      [/\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$/i, "$1ie"],
      [/\b(mon|smil)ies$/i, "$1ey"],
      [/\b((?:tit)?m|l)ice$/i, "$1ouse"],
      [/(seraph|cherub)im$/i, "$1"],
      [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|[aeiou]ris)(?:es)?$/i, "$1"],
      [/(analy|diagno|parenthe|progno|synop|the|empha|cri|ne)(?:sis|ses)$/i, "$1sis"],
      [/(movie|twelve|abuse|e[mn]u)s$/i, "$1"],
      [/(test)(?:is|es)$/i, "$1is"],
      [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1us"],
      [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, "$1um"],
      [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, "$1on"],
      [/(alumn|alg|vertebr)ae$/i, "$1a"],
      [/(cod|mur|sil|vert|ind)ices$/i, "$1ex"],
      [/(matr|append)ices$/i, "$1ix"],
      [/(pe)(rson|ople)$/i, "$1rson"],
      [/(child)ren$/i, "$1"],
      [/(eau)x?$/i, "$1"],
      [/men$/i, "man"]
    ].forEach(function(rule) {
      return pluralize3.addSingularRule(rule[0], rule[1]);
    });
    [
      "adulthood",
      "advice",
      "agenda",
      "aid",
      "aircraft",
      "alcohol",
      "ammo",
      "analytics",
      "anime",
      "athletics",
      "audio",
      "bison",
      "blood",
      "bream",
      "buffalo",
      "butter",
      "carp",
      "cash",
      "chassis",
      "chess",
      "clothing",
      "cod",
      "commerce",
      "cooperation",
      "corps",
      "debris",
      "diabetes",
      "digestion",
      "elk",
      "energy",
      "equipment",
      "excretion",
      "expertise",
      "firmware",
      "flounder",
      "fun",
      "gallows",
      "garbage",
      "graffiti",
      "hardware",
      "headquarters",
      "health",
      "herpes",
      "highjinks",
      "homework",
      "housework",
      "information",
      "jeans",
      "justice",
      "kudos",
      "labour",
      "literature",
      "machinery",
      "mackerel",
      "mail",
      "media",
      "mews",
      "moose",
      "music",
      "mud",
      "manga",
      "news",
      "only",
      "personnel",
      "pike",
      "plankton",
      "pliers",
      "police",
      "pollution",
      "premises",
      "rain",
      "research",
      "rice",
      "salmon",
      "scissors",
      "series",
      "sewage",
      "shambles",
      "shrimp",
      "software",
      "species",
      "staff",
      "swine",
      "tennis",
      "traffic",
      "transportation",
      "trout",
      "tuna",
      "wealth",
      "welfare",
      "whiting",
      "wildebeest",
      "wildlife",
      "you",
      /pok[eé]mon$/i,
      /[^aeiou]ese$/i,
      /deer$/i,
      /fish$/i,
      /measles$/i,
      /o[iu]s$/i,
      /pox$/i,
      /sheep$/i
    ].forEach(pluralize3.addUncountableRule);
    return pluralize3;
  });
});

// ../../node_modules/.pnpm/js-levenshtein@1.1.6/node_modules/js-levenshtein/index.js
var require_js_levenshtein = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = function() {
    function _min(d0, d1, d2, bx, ay) {
      return d0 < d1 || d2 < d1 ? d0 > d2 ? d2 + 1 : d0 + 1 : bx === ay ? d1 : d1 + 1;
    }
    return function(a, b) {
      if (a === b) {
        return 0;
      }
      if (a.length > b.length) {
        var tmp = a;
        a = b;
        b = tmp;
      }
      var la = a.length;
      var lb = b.length;
      while (la > 0 && a.charCodeAt(la - 1) === b.charCodeAt(lb - 1)) {
        la--;
        lb--;
      }
      var offset = 0;
      while (offset < la && a.charCodeAt(offset) === b.charCodeAt(offset)) {
        offset++;
      }
      la -= offset;
      lb -= offset;
      if (la === 0 || lb < 3) {
        return lb;
      }
      var x = 0;
      var y2;
      var d0;
      var d1;
      var d2;
      var d3;
      var dd;
      var dy;
      var ay;
      var bx0;
      var bx1;
      var bx2;
      var bx3;
      var vector = [];
      for (y2 = 0; y2 < la; y2++) {
        vector.push(y2 + 1);
        vector.push(a.charCodeAt(offset + y2));
      }
      var len = vector.length - 1;
      for (; x < lb - 3; ) {
        bx0 = b.charCodeAt(offset + (d0 = x));
        bx1 = b.charCodeAt(offset + (d1 = x + 1));
        bx2 = b.charCodeAt(offset + (d2 = x + 2));
        bx3 = b.charCodeAt(offset + (d3 = x + 3));
        dd = x += 4;
        for (y2 = 0; y2 < len; y2 += 2) {
          dy = vector[y2];
          ay = vector[y2 + 1];
          d0 = _min(dy, d0, d1, bx0, ay);
          d1 = _min(d0, d1, d2, bx1, ay);
          d2 = _min(d1, d2, d3, bx2, ay);
          dd = _min(d2, d3, dd, bx3, ay);
          vector[y2] = dd;
          d3 = d2;
          d2 = d1;
          d1 = d0;
          d0 = dy;
        }
      }
      for (; x < lb; ) {
        bx0 = b.charCodeAt(offset + (d0 = x));
        dd = ++x;
        for (y2 = 0; y2 < len; y2 += 2) {
          dy = vector[y2];
          vector[y2] = dd = _min(dy, d0, dd, bx0, vector[y2 + 1]);
          d0 = dy;
        }
      }
      return dd;
    };
  }();
});

// ../../node_modules/.pnpm/flat-map-polyfill@0.3.8/node_modules/flat-map-polyfill/dist/cjs/array-species-create.js
var require_array_species_create = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  exports2.default = arraySpeciesCreate;
  function arraySpeciesCreate(originalArray, length) {
    var isArray = Array.isArray(originalArray);
    if (!isArray) {
      return Array(length);
    }
    var C = Object.getPrototypeOf(originalArray).constructor;
    if (C) {
      if ((typeof C === "undefined" ? "undefined" : _typeof(C)) === "object" || typeof C === "function") {
        C = C[Symbol.species.toString()];
        C = C !== null ? C : void 0;
      }
      if (C === void 0) {
        return Array(length);
      }
      if (typeof C !== "function") {
        throw TypeError("invalid constructor");
      }
      var result = new C(length);
      return result;
    }
  }
});

// ../../node_modules/.pnpm/flat-map-polyfill@0.3.8/node_modules/flat-map-polyfill/dist/cjs/flatten-into-array.js
var require_flatten_into_array = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = flattenIntoArray;
  function flattenIntoArray(target, source, start, depth, mapperFunction, thisArg) {
    var mapperFunctionProvied = mapperFunction !== void 0;
    var targetIndex = start;
    var sourceIndex = 0;
    var sourceLen = source.length;
    while (sourceIndex < sourceLen) {
      var p = sourceIndex;
      var exists2 = !!source[p];
      if (exists2 === true) {
        var element = source[p];
        if (element) {
          if (mapperFunctionProvied) {
            element = mapperFunction.call(thisArg, element, sourceIndex, target);
          }
          var spreadable = Object.getOwnPropertySymbols(element).includes(Symbol.isConcatSpreadable) || Array.isArray(element);
          if (spreadable === true && depth > 0) {
            var nextIndex = flattenIntoArray(target, element, targetIndex, depth - 1);
            targetIndex = nextIndex;
          } else {
            if (!Number.isSafeInteger(targetIndex)) {
              throw TypeError();
            }
            target[targetIndex] = element;
          }
        }
      }
      targetIndex += 1;
      sourceIndex += 1;
    }
    return targetIndex;
  }
});

// ../../node_modules/.pnpm/flat-map-polyfill@0.3.8/node_modules/flat-map-polyfill/dist/cjs/flatten.js
var require_flatten = __commonJS2(() => {
  "use strict";
  var _arraySpeciesCreate = require_array_species_create();
  var _arraySpeciesCreate2 = _interopRequireDefault(_arraySpeciesCreate);
  var _flattenIntoArray = require_flatten_into_array();
  var _flattenIntoArray2 = _interopRequireDefault(_flattenIntoArray);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  if (!Object.prototype.hasOwnProperty.call(Array.prototype, "flatten")) {
    Array.prototype.flatten = function flatten(depth) {
      var o = Object(this);
      var a = (0, _arraySpeciesCreate2.default)(o, this.length);
      var depthNum = depth !== void 0 ? Number(depth) : Infinity;
      (0, _flattenIntoArray2.default)(a, o, 0, depthNum);
      return a.filter(function(e) {
        return e !== void 0;
      });
    };
  }
});

// ../../node_modules/.pnpm/flat-map-polyfill@0.3.8/node_modules/flat-map-polyfill/dist/cjs/flat-map.js
var require_flat_map = __commonJS2(() => {
  "use strict";
  var _flattenIntoArray = require_flatten_into_array();
  var _flattenIntoArray2 = _interopRequireDefault(_flattenIntoArray);
  var _arraySpeciesCreate = require_array_species_create();
  var _arraySpeciesCreate2 = _interopRequireDefault(_arraySpeciesCreate);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  if (!Object.prototype.hasOwnProperty.call(Array.prototype, "flatMap")) {
    Array.prototype.flatMap = function flatMap(callbackFn, thisArg) {
      var o = Object(this);
      if (!callbackFn || typeof callbackFn.call !== "function") {
        throw TypeError("callbackFn must be callable.");
      }
      var t = thisArg !== void 0 ? thisArg : void 0;
      var a = (0, _arraySpeciesCreate2.default)(o, o.length);
      (0, _flattenIntoArray2.default)(a, o, 0, 1, callbackFn, t);
      return a.filter(function(x) {
        return x !== void 0;
      }, a);
    };
  }
});

// ../../node_modules/.pnpm/klona@2.0.4/node_modules/klona/dist/index.js
var require_dist20 = __commonJS2((exports2) => {
  function klona3(x) {
    if (typeof x !== "object")
      return x;
    var k, tmp, str = Object.prototype.toString.call(x);
    if (str === "[object Object]") {
      if (x.constructor !== Object && typeof x.constructor === "function") {
        tmp = new x.constructor();
        for (k in x) {
          if (tmp.hasOwnProperty(k) && tmp[k] !== x[k]) {
            tmp[k] = klona3(x[k]);
          }
        }
      } else {
        tmp = {};
        for (k in x) {
          if (k === "__proto__") {
            Object.defineProperty(tmp, k, {
              value: klona3(x[k]),
              configurable: true,
              enumerable: true,
              writable: true
            });
          } else {
            tmp[k] = klona3(x[k]);
          }
        }
      }
      return tmp;
    }
    if (str === "[object Array]") {
      k = x.length;
      for (tmp = Array(k); k--; ) {
        tmp[k] = klona3(x[k]);
      }
      return tmp;
    }
    if (str === "[object Set]") {
      tmp = new Set();
      x.forEach(function(val) {
        tmp.add(klona3(val));
      });
      return tmp;
    }
    if (str === "[object Map]") {
      tmp = new Map();
      x.forEach(function(val, key) {
        tmp.set(klona3(key), klona3(val));
      });
      return tmp;
    }
    if (str === "[object Date]") {
      return new Date(+x);
    }
    if (str === "[object RegExp]") {
      tmp = new RegExp(x.source, x.flags);
      tmp.lastIndex = x.lastIndex;
      return tmp;
    }
    if (str === "[object DataView]") {
      return new x.constructor(klona3(x.buffer));
    }
    if (str === "[object ArrayBuffer]") {
      return x.slice(0);
    }
    if (str.slice(-6) === "Array]") {
      return new x.constructor(x);
    }
    return x;
  }
  exports2.klona = klona3;
});

// src/generation/generateClient.ts
var require_generateClient = __commonJS2((exports, module) => {
  __markAsModule2(exports);
  __export2(exports, {
    DenylistError: () => DenylistError,
    buildClient: () => buildClient,
    generateClient: () => generateClient
  });
  var import_fetch_engine2 = __toModule2(require_dist15());
  var import_getVersion = __toModule2(require_getVersion());
  var import_copy = __toModule2(require_copy());
  var import_chalk3 = __toModule2(require_source2());
  var import_fs2 = __toModule2(require("fs"));
  var import_make_dir2 = __toModule2(require_make_dir2());
  var import_path4 = __toModule2(require("path"));
  var import_pkg_up = __toModule2(require_pkg_up());
  var import_util3 = __toModule2(require("util"));
  var remove = import_util3.promisify(import_fs2.default.unlink);
  var writeFile = import_util3.promisify(import_fs2.default.writeFile);
  var exists = import_util3.promisify(import_fs2.default.exists);
  var copyFile = import_util3.promisify(import_fs2.default.copyFile);
  var stat = import_util3.promisify(import_fs2.default.stat);
  var DenylistError = class extends Error {
    constructor(message) {
      super(message);
      this.name = "DenylistError";
      this.stack = void 0;
    }
  };
  async function buildClient({
    datamodel,
    schemaDir = process.cwd(),
    runtimePath = "@prisma/client/runtime",
    browser = false,
    binaryPaths,
    outputDir,
    generator,
    dmmf,
    datasources,
    engineVersion,
    clientVersion: clientVersion2,
    projectRoot,
    activeProvider
  }) {
    const document2 = getPrismaClientDMMF(dmmf);
    const clientEngineType = getClientEngineType(generator);
    const client = new TSClient({
      document: document2,
      runtimePath,
      browser,
      datasources,
      generator,
      platforms: clientEngineType === ClientEngineType.Library ? Object.keys(binaryPaths.libqueryEngine) : Object.keys(binaryPaths.queryEngine),
      schemaDir,
      outputDir,
      clientVersion: clientVersion2,
      engineVersion,
      projectRoot,
      activeProvider
    });
    const fileMap = {
      "index.d.ts": TS(client),
      "index.js": JS(client),
      "index-browser.js": BrowserJS(client)
    };
    return {
      fileMap,
      prismaClientDmmf: document2
    };
  }
  async function getDotPrismaDir(outputDir) {
    var _a;
    if (outputDir.endsWith("node_modules/@prisma/client")) {
      return import_path4.default.join(outputDir, "../../.prisma/client");
    }
    if (process.env.INIT_CWD && process.env.npm_lifecycle_event === "postinstall" && !((_a = process.env.PWD) == null ? void 0 : _a.includes(".pnpm"))) {
      if (import_fs2.default.existsSync(import_path4.default.join(process.env.INIT_CWD, "package.json"))) {
        return import_path4.default.join(process.env.INIT_CWD, "node_modules/.prisma/client");
      }
      const packagePath = await import_pkg_up.default({cwd: process.env.INIT_CWD});
      if (packagePath) {
        return import_path4.default.join(import_path4.default.dirname(packagePath), "node_modules/.prisma/client");
      }
    }
    return import_path4.default.join(outputDir, "../../.prisma/client");
  }
  async function generateClient({
    datamodel,
    datamodelPath,
    schemaDir = datamodelPath ? import_path4.default.dirname(datamodelPath) : process.cwd(),
    outputDir,
    transpile,
    runtimePath,
    browser,
    generator,
    dmmf,
    datasources,
    binaryPaths,
    testMode,
    copyRuntime,
    clientVersion,
    engineVersion,
    activeProvider
  }) {
    const useDotPrisma = testMode ? !runtimePath : !(generator == null ? void 0 : generator.isCustomOutput);
    const clientEngineType = getClientEngineType(generator);
    runtimePath = runtimePath || (useDotPrisma ? "@prisma/client/runtime" : "./runtime");
    const finalOutputDir = useDotPrisma ? await getDotPrismaDir(outputDir) : outputDir;
    const packageRoot = await import_pkg_up.default({cwd: import_path4.default.dirname(finalOutputDir)});
    const projectRoot = packageRoot ? import_path4.default.dirname(packageRoot) : process.cwd();
    const {prismaClientDmmf, fileMap} = await buildClient({
      datamodel,
      datamodelPath,
      schemaDir,
      transpile,
      runtimePath,
      browser,
      outputDir: finalOutputDir,
      generator,
      dmmf,
      datasources,
      binaryPaths,
      clientVersion,
      engineVersion,
      projectRoot,
      activeProvider
    });
    const denylistsErrors = validateDmmfAgainstDenylists(prismaClientDmmf);
    if (denylistsErrors) {
      let message = `${import_chalk3.default.redBright.bold("Error: ")}The schema at "${datamodelPath}" contains reserved keywords.
       Rename the following items:`;
      for (const error of denylistsErrors) {
        message += "\n         - " + error.message;
      }
      message += `
To learn more about how to rename models, check out https://pris.ly/d/naming-models`;
      throw new DenylistError(message);
    }
    await import_make_dir2.default(finalOutputDir);
    await import_make_dir2.default(import_path4.default.join(outputDir, "runtime"));
    await Promise.all(Object.entries(fileMap).map(async ([fileName, file]) => {
      const filePath = import_path4.default.join(finalOutputDir, fileName);
      if (await exists(filePath)) {
        await remove(filePath);
      }
      await writeFile(filePath, file);
    }));
    const runtimeSourceDir = testMode ? eval(`require('path').join(__dirname, '../../runtime')`) : eval(`require('path').join(__dirname, '../runtime')`);
    if (copyRuntime || !import_path4.default.resolve(outputDir).endsWith(`@prisma${import_path4.default.sep}client`)) {
      const copyTarget = import_path4.default.join(outputDir, "runtime");
      await import_make_dir2.default(copyTarget);
      if (runtimeSourceDir !== copyTarget) {
        await import_copy.default({
          from: runtimeSourceDir,
          to: copyTarget,
          recursive: true,
          parallelJobs: process.platform === "win32" ? 1 : 20,
          overwrite: true
        });
      }
    }
    const enginePath = clientEngineType === ClientEngineType.Library ? binaryPaths.libqueryEngine : binaryPaths.queryEngine;
    if (!enginePath) {
      throw new Error(`Prisma Client needs \`${clientEngineType === ClientEngineType.Library ? "libqueryEngine" : "queryEngine"}\` in the \`binaryPaths\` object.`);
    }
    if (transpile) {
      if (process.env.NETLIFY) {
        await import_make_dir2.default("/tmp/prisma-engines");
      }
      for (const [binaryTarget, filePath] of Object.entries(enginePath)) {
        const fileName = import_path4.default.basename(filePath);
        const target = process.env.NETLIFY && binaryTarget !== "rhel-openssl-1.0.x" ? import_path4.default.join("/tmp/prisma-engines", fileName) : import_path4.default.join(finalOutputDir, fileName);
        const [sourceFileSize, targetFileSize] = await Promise.all([
          fileSize(filePath),
          fileSize(target)
        ]);
        if (!targetFileSize) {
          if (import_fs2.default.existsSync(filePath)) {
            await copyFile(filePath, target);
            continue;
          } else {
            throw new Error(`File at ${filePath} is required but was not present`);
          }
        }
        if (targetFileSize && sourceFileSize && targetFileSize !== sourceFileSize) {
          await copyFile(filePath, target);
          continue;
        }
        const binaryName = clientEngineType === ClientEngineType.Binary ? import_fetch_engine2.BinaryType.queryEngine : import_fetch_engine2.BinaryType.libqueryEngine;
        const [sourceVersion, targetVersion] = await Promise.all([
          import_getVersion.getVersion(filePath, binaryName).catch(() => null),
          import_getVersion.getVersion(target, binaryName).catch(() => null)
        ]);
        if (sourceVersion && targetVersion && sourceVersion === targetVersion) {
        } else {
          await copyFile(filePath, target);
        }
      }
    }
    const datamodelTargetPath = import_path4.default.join(finalOutputDir, "schema.prisma");
    if (datamodelPath !== datamodelTargetPath) {
      await copyFile(datamodelPath, datamodelTargetPath);
    }
    if (!(generator == null ? void 0 : generator.isCustomOutput)) {
      const packageJsonTargetPath = import_path4.default.join(finalOutputDir, "package.json");
      const pkgJson = JSON.stringify({
        name: ".prisma/client",
        main: "index.js",
        types: "index.d.ts",
        browser: "index-browser.js"
      }, null, 2);
      await writeFile(packageJsonTargetPath, pkgJson);
    }
    if (!testMode && process.env.INIT_CWD) {
      const backupPath = import_path4.default.join(process.env.INIT_CWD, "node_modules/.prisma/client");
      if (finalOutputDir !== backupPath && !(generator == null ? void 0 : generator.isCustomOutput)) {
        await import_copy.default({
          from: finalOutputDir,
          to: backupPath,
          recursive: true,
          parallelJobs: process.platform === "win32" ? 1 : 20,
          overwrite: true
        });
      }
    }
    const proxyIndexJsPath = import_path4.default.join(outputDir, "index.js");
    const proxyIndexBrowserJsPath = import_path4.default.join(outputDir, "index-browser.js");
    const proxyIndexDTSPath = import_path4.default.join(outputDir, "index.d.ts");
    if (!import_fs2.default.existsSync(proxyIndexJsPath)) {
      await copyFile(import_path4.default.join(__dirname, "../../index.js"), proxyIndexJsPath);
    }
    if (!import_fs2.default.existsSync(proxyIndexDTSPath)) {
      await copyFile(import_path4.default.join(__dirname, "../../index.d.ts"), proxyIndexDTSPath);
    }
    if (!import_fs2.default.existsSync(proxyIndexBrowserJsPath)) {
      await copyFile(import_path4.default.join(__dirname, "../../index-browser.js"), proxyIndexBrowserJsPath);
    }
    return {prismaClientDmmf, fileMap};
  }
  async function fileSize(name) {
    try {
      const statResult = await stat(name);
      return statResult.size;
    } catch (e) {
      return null;
    }
  }
  function validateDmmfAgainstDenylists(prismaClientDmmf) {
    const errorArray = [];
    const denylists = {
      models: [
        "PrismaClient",
        "Prisma",
        "break",
        "case",
        "catch",
        "class",
        "const",
        "continue",
        "debugger",
        "default",
        "delete",
        "do",
        "else",
        "enum",
        "export",
        "extends",
        "false",
        "finally",
        "for",
        "function",
        "if",
        "implements",
        "import",
        "in",
        "instanceof",
        "interface",
        "let",
        "new",
        "null",
        "package",
        "private",
        "protected",
        "public",
        "return",
        "super",
        "switch",
        "this",
        "throw",
        "true",
        "try",
        "typeof",
        "var",
        "void",
        "while",
        "with",
        "yield"
      ],
      fields: ["AND", "OR", "NOT"],
      dynamic: []
    };
    if (prismaClientDmmf.datamodel.enums) {
      for (const it of prismaClientDmmf.datamodel.enums) {
        if (denylists.models.includes(it.name) || denylists.fields.includes(it.name)) {
          errorArray.push(Error(`"enum ${it.name}"`));
        }
      }
    }
    if (prismaClientDmmf.datamodel.models) {
      for (const it of prismaClientDmmf.datamodel.models) {
        if (denylists.models.includes(it.name) || denylists.fields.includes(it.name)) {
          errorArray.push(Error(`"model ${it.name}"`));
        }
      }
    }
    return errorArray.length > 0 ? errorArray : null;
  }
});

// package.json
var require_package3 = __commonJS2((exports2, module2) => {
  module2.exports = {
    name: "@prisma/client",
    version: "2.30.2",
    description: "Prisma Client is an auto-generated, type-safe and modern JavaScript/TypeScript ORM for Node.js that's tailored to your data. Supports MySQL, PostgreSQL, MariaDB, SQLite databases.",
    keywords: [
      "orm",
      "prisma2",
      "prisma",
      "client",
      "query",
      "database",
      "sql",
      "postgres",
      "postgresql",
      "mysql",
      "sqlite",
      "mariadb",
      "mssql",
      "typescript",
      "query-builder"
    ],
    main: "index.js",
    browser: "index-browser.js",
    types: "index.d.ts",
    license: "Apache-2.0",
    engines: {
      node: ">=12.2"
    },
    homepage: "https://www.prisma.io",
    repository: "git@github.com:prisma/prisma.git",
    author: "Tim Suchanek <suchanek@prisma.io>",
    maintainers: [
      "Tim Suchanek <suchanek@prisma.io>",
      "Jo\xEBl Galeran <galeran@prisma.io>",
      "William Luke <luke@prisma.io>",
      "Pierre-Antoine Mills <mills@prisma.io>"
    ],
    bugs: "https://github.com/prisma/prisma/issues",
    scripts: {
      dev: "DEV=true node helpers/build.js",
      build: "node helpers/build.js",
      test: "jest",
      format: "prettier --write .",
      lint: "eslint --cache --fix --ext .ts .",
      "lint-ci": "eslint --ext .ts .",
      generate: "node scripts/postinstall.js",
      postinstall: "node scripts/postinstall.js",
      prepare: "cp scripts/backup-index.js index.js && cp scripts/backup-index.d.ts index.d.ts",
      prepublishOnly: "pnpm run build",
      precommit: "lint-staged"
    },
    files: [
      "README.md",
      "runtime",
      "scripts",
      "generator-build",
      "index.js",
      "index.d.ts",
      "index-browser.js"
    ],
    devDependencies: {
      "@prisma/debug": "workspace:*",
      "@prisma/engine-core": "workspace:*",
      "@prisma/engines": "2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20",
      "@prisma/fetch-engine": "2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20",
      "@prisma/generator-helper": "workspace:*",
      "@prisma/get-platform": "2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20",
      "@prisma/migrate": "workspace:*",
      "@prisma/sdk": "workspace:*",
      "@timsuchanek/copy": "1.4.5",
      "@types/debug": "4.1.7",
      "@types/jest": "27.0.1",
      "@types/js-levenshtein": "1.1.0",
      "@types/mssql": "6.0.8",
      "@types/node": "12.20.19",
      "@types/pg": "8.6.1",
      "@typescript-eslint/eslint-plugin": "4.29.2",
      "@typescript-eslint/parser": "4.29.2",
      arg: "5.0.1",
      chalk: "4.1.2",
      "decimal.js": "10.3.1",
      esbuild: "0.8.53",
      "escape-string-regexp": "4.0.0",
      eslint: "7.32.0",
      "eslint-config-prettier": "8.3.0",
      "eslint-plugin-eslint-comments": "3.2.0",
      "eslint-plugin-jest": "24.4.0",
      "eslint-plugin-prettier": "3.4.0",
      execa: "5.1.1",
      "flat-map-polyfill": "0.3.8",
      "fs-monkey": "1.0.3",
      "get-own-enumerable-property-symbols": "3.0.2",
      "indent-string": "4.0.0",
      "is-obj": "2.0.0",
      "is-regexp": "2.1.0",
      jest: "27.0.6",
      "js-levenshtein": "1.1.6",
      klona: "2.0.4",
      "lint-staged": "11.1.2",
      "make-dir": "3.1.0",
      mariadb: "2.5.4",
      mssql: "7.2.0",
      pg: "8.7.1",
      "pkg-up": "3.1.0",
      pluralize: "8.0.0",
      prettier: "2.3.2",
      "replace-string": "3.1.0",
      rimraf: "3.0.2",
      rollup: "2.56.2",
      "rollup-plugin-dts": "3.0.2",
      "sort-keys": "4.2.0",
      "source-map-support": "0.5.19",
      "sql-template-tag": "4.0.0",
      "stacktrace-parser": "0.1.10",
      "strip-ansi": "6.0.0",
      "strip-indent": "3.0.0",
      "ts-jest": "27.0.5",
      "ts-node": "10.2.0",
      tsd: "0.17.0",
      typescript: "4.3.5"
    },
    peerDependencies: {
      prisma: "*"
    },
    peerDependenciesMeta: {
      prisma: {
        optional: true
      }
    },
    dependencies: {
      "@prisma/engines-version": "2.30.1-2.b8c35d44de987a9691890b3ddf3e2e7effb9bf20"
    },
    "lint-staged": {
      "*.ts": [
        "eslint",
        "prettier --write"
      ]
    }
  };
});

// src/generation/generator.ts
__markAsModule2(exports);
__export2(exports, {
  externalToInternalDmmf: () => externalToInternalDmmf,
  getDMMF: () => getDMMF2
});
var import_debug2 = __toModule2(require_dist7());
var import_engines_version3 = __toModule2(require_engines_version2());
var import_generator_helper2 = __toModule2(require_dist8());
var import_sdk = __toModule2(require_dist19());

// src/runtime/utils/getClientEngineType.ts
var ClientEngineType;
(function(ClientEngineType2) {
  ClientEngineType2["Library"] = "library";
  ClientEngineType2["Binary"] = "binary";
})(ClientEngineType || (ClientEngineType = {}));
var DEFAULT_CLIENT_ENGINE_TYPE = ClientEngineType.Binary;
function getClientEngineType(generatorConfig) {
  const engineTypeFromEnvVar = getEngineTypeFromEnvVar();
  if (engineTypeFromEnvVar)
    return engineTypeFromEnvVar;
  if ((generatorConfig == null ? void 0 : generatorConfig.config.engineType) === ClientEngineType.Library || (generatorConfig == null ? void 0 : generatorConfig.previewFeatures.includes("nApi"))) {
    return ClientEngineType.Library;
  } else if ((generatorConfig == null ? void 0 : generatorConfig.config.engineType) === ClientEngineType.Binary) {
    return ClientEngineType.Binary;
  }
  return DEFAULT_CLIENT_ENGINE_TYPE;
}
function getEngineTypeFromEnvVar() {
  const engineType = process.env.PRISMA_CLIENT_ENGINE_TYPE;
  if (engineType === ClientEngineType.Library) {
    return ClientEngineType.Library;
  } else if (engineType === ClientEngineType.Binary) {
    return ClientEngineType.Binary;
  } else {
    return void 0;
  }
}

// src/generation/getDMMF.ts
var import_getDmmf = __toModule2(require_getDmmf());

// src/runtime/externalToInternalDmmf.ts
var import_pluralize = __toModule2(require_pluralize());

// src/runtime/utils/common.ts
var import_chalk2 = __toModule2(require_source2());
var import_indent_string = __toModule2(require_indent_string2());
var import_js_levenshtein = __toModule2(require_js_levenshtein());

// ../../node_modules/.pnpm/decimal.js@10.3.1/node_modules/decimal.js/decimal.mjs
var EXP_LIMIT = 9e15;
var MAX_DIGITS = 1e9;
var NUMERALS = "0123456789abcdef";
var LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
var PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
var DEFAULTS = {
  precision: 20,
  rounding: 4,
  modulo: 1,
  toExpNeg: -7,
  toExpPos: 21,
  minE: -EXP_LIMIT,
  maxE: EXP_LIMIT,
  crypto: false
};
var inexact;
var quadrant;
var external = true;
var decimalError = "[DecimalError] ";
var invalidArgument = decimalError + "Invalid argument: ";
var precisionLimitExceeded = decimalError + "Precision limit exceeded";
var cryptoUnavailable = decimalError + "crypto unavailable";
var tag = "[object Decimal]";
var mathfloor = Math.floor;
var mathpow = Math.pow;
var isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
var isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
var isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
var isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
var BASE = 1e7;
var LOG_BASE = 7;
var MAX_SAFE_INTEGER = 9007199254740991;
var LN10_PRECISION = LN10.length - 1;
var PI_PRECISION = PI.length - 1;
var P = {toStringTag: tag};
P.absoluteValue = P.abs = function() {
  var x = new this.constructor(this);
  if (x.s < 0)
    x.s = 1;
  return finalise(x);
};
P.ceil = function() {
  return finalise(new this.constructor(this), this.e + 1, 2);
};
P.clampedTo = P.clamp = function(min2, max2) {
  var k, x = this, Ctor = x.constructor;
  min2 = new Ctor(min2);
  max2 = new Ctor(max2);
  if (!min2.s || !max2.s)
    return new Ctor(NaN);
  if (min2.gt(max2))
    throw Error(invalidArgument + max2);
  k = x.cmp(min2);
  return k < 0 ? min2 : x.cmp(max2) > 0 ? max2 : new Ctor(x);
};
P.comparedTo = P.cmp = function(y2) {
  var i, j, xdL, ydL, x = this, xd = x.d, yd = (y2 = new x.constructor(y2)).d, xs = x.s, ys = y2.s;
  if (!xd || !yd) {
    return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
  }
  if (!xd[0] || !yd[0])
    return xd[0] ? xs : yd[0] ? -ys : 0;
  if (xs !== ys)
    return xs;
  if (x.e !== y2.e)
    return x.e > y2.e ^ xs < 0 ? 1 : -1;
  xdL = xd.length;
  ydL = yd.length;
  for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
    if (xd[i] !== yd[i])
      return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
  }
  return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
};
P.cosine = P.cos = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.d)
    return new Ctor(NaN);
  if (!x.d[0])
    return new Ctor(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
};
P.cubeRoot = P.cbrt = function() {
  var e, m2, n, r, rep, s2, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  external = false;
  s2 = x.s * mathpow(x.s * x, 1 / 3);
  if (!s2 || Math.abs(s2) == 1 / 0) {
    n = digitsToString(x.d);
    e = x.e;
    if (s2 = (e - n.length + 1) % 3)
      n += s2 == 1 || s2 == -2 ? "0" : "00";
    s2 = mathpow(n, 1 / 3);
    e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));
    if (s2 == 1 / 0) {
      n = "5e" + e;
    } else {
      n = s2.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e;
    }
    r = new Ctor(n);
    r.s = x.s;
  } else {
    r = new Ctor(s2.toString());
  }
  sd = (e = Ctor.precision) + 3;
  for (; ; ) {
    t = r;
    t3 = t.times(t).times(t);
    t3plusx = t3.plus(x);
    r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise(t, e + 1, 0);
          if (t.times(t).times(t).eq(x)) {
            r = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise(r, e + 1, 1);
          m2 = !r.times(r).times(r).eq(x);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r, e, Ctor.rounding, m2);
};
P.decimalPlaces = P.dp = function() {
  var w2, d2 = this.d, n = NaN;
  if (d2) {
    w2 = d2.length - 1;
    n = (w2 - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
    w2 = d2[w2];
    if (w2)
      for (; w2 % 10 == 0; w2 /= 10)
        n--;
    if (n < 0)
      n = 0;
  }
  return n;
};
P.dividedBy = P.div = function(y2) {
  return divide(this, new this.constructor(y2));
};
P.dividedToIntegerBy = P.divToInt = function(y2) {
  var x = this, Ctor = x.constructor;
  return finalise(divide(x, new Ctor(y2), 0, 1, 1), Ctor.precision, Ctor.rounding);
};
P.equals = P.eq = function(y2) {
  return this.cmp(y2) === 0;
};
P.floor = function() {
  return finalise(new this.constructor(this), this.e + 1, 3);
};
P.greaterThan = P.gt = function(y2) {
  return this.cmp(y2) > 0;
};
P.greaterThanOrEqualTo = P.gte = function(y2) {
  var k = this.cmp(y2);
  return k == 1 || k === 0;
};
P.hyperbolicCosine = P.cosh = function() {
  var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);
  if (!x.isFinite())
    return new Ctor(x.s ? 1 / 0 : NaN);
  if (x.isZero())
    return one;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;
  if (len < 32) {
    k = Math.ceil(len / 3);
    n = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    n = "2.3283064365386962890625e-10";
  }
  x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);
  var cosh2_x, i = k, d8 = new Ctor(8);
  for (; i--; ) {
    cosh2_x = x.times(x);
    x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
  }
  return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P.hyperbolicSine = P.sinh = function() {
  var k, pr, rm, len, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;
  if (len < 3) {
    x = taylorSeries(Ctor, 2, x, x, true);
  } else {
    k = 1.4 * Math.sqrt(len);
    k = k > 16 ? 16 : k | 0;
    x = x.times(1 / tinyPow(5, k));
    x = taylorSeries(Ctor, 2, x, x, true);
    var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
    for (; k--; ) {
      sinh2_x = x.times(x);
      x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
    }
  }
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(x, pr, rm, true);
};
P.hyperbolicTangent = P.tanh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(x.s);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 7;
  Ctor.rounding = 1;
  return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
};
P.inverseCosine = P.acos = function() {
  var halfPi, x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
  if (k !== -1) {
    return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
  }
  if (x.isZero())
    return getPi(Ctor, pr + 4, rm).times(0.5);
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x = x.asin();
  halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return halfPi.minus(x);
};
P.inverseHyperbolicCosine = P.acosh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (x.lte(1))
    return new Ctor(x.eq(1) ? 0 : NaN);
  if (!x.isFinite())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
  Ctor.rounding = 1;
  external = false;
  x = x.times(x).minus(1).sqrt().plus(x);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.ln();
};
P.inverseHyperbolicSine = P.asinh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
  Ctor.rounding = 1;
  external = false;
  x = x.times(x).plus(1).sqrt().plus(x);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.ln();
};
P.inverseHyperbolicTangent = P.atanh = function() {
  var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.e >= 0)
    return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  xsd = x.sd();
  if (Math.max(xsd, pr) < 2 * -x.e - 1)
    return finalise(new Ctor(x), pr, rm, true);
  Ctor.precision = wpr = xsd - x.e;
  x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
  Ctor.precision = pr + 4;
  Ctor.rounding = 1;
  x = x.ln();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(0.5);
};
P.inverseSine = P.asin = function() {
  var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
  if (x.isZero())
    return new Ctor(x);
  k = x.abs().cmp(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (k !== -1) {
    if (k === 0) {
      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
      halfPi.s = x.s;
      return halfPi;
    }
    return new Ctor(NaN);
  }
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(2);
};
P.inverseTangent = P.atan = function() {
  var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
  if (!x.isFinite()) {
    if (!x.s)
      return new Ctor(NaN);
    if (pr + 4 <= PI_PRECISION) {
      r = getPi(Ctor, pr + 4, rm).times(0.5);
      r.s = x.s;
      return r;
    }
  } else if (x.isZero()) {
    return new Ctor(x);
  } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
    r = getPi(Ctor, pr + 4, rm).times(0.25);
    r.s = x.s;
    return r;
  }
  Ctor.precision = wpr = pr + 10;
  Ctor.rounding = 1;
  k = Math.min(28, wpr / LOG_BASE + 2 | 0);
  for (i = k; i; --i)
    x = x.div(x.times(x).plus(1).sqrt().plus(1));
  external = false;
  j = Math.ceil(wpr / LOG_BASE);
  n = 1;
  x2 = x.times(x);
  r = new Ctor(x);
  px = x;
  for (; i !== -1; ) {
    px = px.times(x2);
    t = r.minus(px.div(n += 2));
    px = px.times(x2);
    r = t.plus(px.div(n += 2));
    if (r.d[j] !== void 0)
      for (i = j; r.d[i] === t.d[i] && i--; )
        ;
  }
  if (k)
    r = r.times(2 << k - 1);
  external = true;
  return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P.isFinite = function() {
  return !!this.d;
};
P.isInteger = P.isInt = function() {
  return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
};
P.isNaN = function() {
  return !this.s;
};
P.isNegative = P.isNeg = function() {
  return this.s < 0;
};
P.isPositive = P.isPos = function() {
  return this.s > 0;
};
P.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
P.lessThan = P.lt = function(y2) {
  return this.cmp(y2) < 0;
};
P.lessThanOrEqualTo = P.lte = function(y2) {
  return this.cmp(y2) < 1;
};
P.logarithm = P.log = function(base) {
  var isBase10, d2, denominator, k, inf, num, sd, r, arg2 = this, Ctor = arg2.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
  if (base == null) {
    base = new Ctor(10);
    isBase10 = true;
  } else {
    base = new Ctor(base);
    d2 = base.d;
    if (base.s < 0 || !d2 || !d2[0] || base.eq(1))
      return new Ctor(NaN);
    isBase10 = base.eq(10);
  }
  d2 = arg2.d;
  if (arg2.s < 0 || !d2 || !d2[0] || arg2.eq(1)) {
    return new Ctor(d2 && !d2[0] ? -1 / 0 : arg2.s != 1 ? NaN : d2 ? 0 : 1 / 0);
  }
  if (isBase10) {
    if (d2.length > 1) {
      inf = true;
    } else {
      for (k = d2[0]; k % 10 === 0; )
        k /= 10;
      inf = k !== 1;
    }
  }
  external = false;
  sd = pr + guard;
  num = naturalLogarithm(arg2, sd);
  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
  r = divide(num, denominator, sd, 1);
  if (checkRoundingDigits(r.d, k = pr, rm)) {
    do {
      sd += 10;
      num = naturalLogarithm(arg2, sd);
      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
      r = divide(num, denominator, sd, 1);
      if (!inf) {
        if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
          r = finalise(r, pr + 1, 0);
        }
        break;
      }
    } while (checkRoundingDigits(r.d, k += 10, rm));
  }
  external = true;
  return finalise(r, pr, rm);
};
P.minus = P.sub = function(y2) {
  var d2, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
  y2 = new Ctor(y2);
  if (!x.d || !y2.d) {
    if (!x.s || !y2.s)
      y2 = new Ctor(NaN);
    else if (x.d)
      y2.s = -y2.s;
    else
      y2 = new Ctor(y2.d || x.s !== y2.s ? x : NaN);
    return y2;
  }
  if (x.s != y2.s) {
    y2.s = -y2.s;
    return x.plus(y2);
  }
  xd = x.d;
  yd = y2.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (yd[0])
      y2.s = -y2.s;
    else if (xd[0])
      y2 = new Ctor(x);
    else
      return new Ctor(rm === 3 ? -0 : 0);
    return external ? finalise(y2, pr, rm) : y2;
  }
  e = mathfloor(y2.e / LOG_BASE);
  xe = mathfloor(x.e / LOG_BASE);
  xd = xd.slice();
  k = xe - e;
  if (k) {
    xLTy = k < 0;
    if (xLTy) {
      d2 = xd;
      k = -k;
      len = yd.length;
    } else {
      d2 = yd;
      e = xe;
      len = xd.length;
    }
    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
    if (k > i) {
      k = i;
      d2.length = 1;
    }
    d2.reverse();
    for (i = k; i--; )
      d2.push(0);
    d2.reverse();
  } else {
    i = xd.length;
    len = yd.length;
    xLTy = i < len;
    if (xLTy)
      len = i;
    for (i = 0; i < len; i++) {
      if (xd[i] != yd[i]) {
        xLTy = xd[i] < yd[i];
        break;
      }
    }
    k = 0;
  }
  if (xLTy) {
    d2 = xd;
    xd = yd;
    yd = d2;
    y2.s = -y2.s;
  }
  len = xd.length;
  for (i = yd.length - len; i > 0; --i)
    xd[len++] = 0;
  for (i = yd.length; i > k; ) {
    if (xd[--i] < yd[i]) {
      for (j = i; j && xd[--j] === 0; )
        xd[j] = BASE - 1;
      --xd[j];
      xd[i] += BASE;
    }
    xd[i] -= yd[i];
  }
  for (; xd[--len] === 0; )
    xd.pop();
  for (; xd[0] === 0; xd.shift())
    --e;
  if (!xd[0])
    return new Ctor(rm === 3 ? -0 : 0);
  y2.d = xd;
  y2.e = getBase10Exponent(xd, e);
  return external ? finalise(y2, pr, rm) : y2;
};
P.modulo = P.mod = function(y2) {
  var q, x = this, Ctor = x.constructor;
  y2 = new Ctor(y2);
  if (!x.d || !y2.s || y2.d && !y2.d[0])
    return new Ctor(NaN);
  if (!y2.d || x.d && !x.d[0]) {
    return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
  }
  external = false;
  if (Ctor.modulo == 9) {
    q = divide(x, y2.abs(), 0, 3, 1);
    q.s *= y2.s;
  } else {
    q = divide(x, y2, 0, Ctor.modulo, 1);
  }
  q = q.times(y2);
  external = true;
  return x.minus(q);
};
P.naturalExponential = P.exp = function() {
  return naturalExponential(this);
};
P.naturalLogarithm = P.ln = function() {
  return naturalLogarithm(this);
};
P.negated = P.neg = function() {
  var x = new this.constructor(this);
  x.s = -x.s;
  return finalise(x);
};
P.plus = P.add = function(y2) {
  var carry, d2, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
  y2 = new Ctor(y2);
  if (!x.d || !y2.d) {
    if (!x.s || !y2.s)
      y2 = new Ctor(NaN);
    else if (!x.d)
      y2 = new Ctor(y2.d || x.s === y2.s ? x : NaN);
    return y2;
  }
  if (x.s != y2.s) {
    y2.s = -y2.s;
    return x.minus(y2);
  }
  xd = x.d;
  yd = y2.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (!yd[0])
      y2 = new Ctor(x);
    return external ? finalise(y2, pr, rm) : y2;
  }
  k = mathfloor(x.e / LOG_BASE);
  e = mathfloor(y2.e / LOG_BASE);
  xd = xd.slice();
  i = k - e;
  if (i) {
    if (i < 0) {
      d2 = xd;
      i = -i;
      len = yd.length;
    } else {
      d2 = yd;
      e = k;
      len = xd.length;
    }
    k = Math.ceil(pr / LOG_BASE);
    len = k > len ? k + 1 : len + 1;
    if (i > len) {
      i = len;
      d2.length = 1;
    }
    d2.reverse();
    for (; i--; )
      d2.push(0);
    d2.reverse();
  }
  len = xd.length;
  i = yd.length;
  if (len - i < 0) {
    i = len;
    d2 = yd;
    yd = xd;
    xd = d2;
  }
  for (carry = 0; i; ) {
    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
    xd[i] %= BASE;
  }
  if (carry) {
    xd.unshift(carry);
    ++e;
  }
  for (len = xd.length; xd[--len] == 0; )
    xd.pop();
  y2.d = xd;
  y2.e = getBase10Exponent(xd, e);
  return external ? finalise(y2, pr, rm) : y2;
};
P.precision = P.sd = function(z) {
  var k, x = this;
  if (z !== void 0 && z !== !!z && z !== 1 && z !== 0)
    throw Error(invalidArgument + z);
  if (x.d) {
    k = getPrecision(x.d);
    if (z && x.e + 1 > k)
      k = x.e + 1;
  } else {
    k = NaN;
  }
  return k;
};
P.round = function() {
  var x = this, Ctor = x.constructor;
  return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
};
P.sine = P.sin = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x = sine(Ctor, toLessThanHalfPi(Ctor, x));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
};
P.squareRoot = P.sqrt = function() {
  var m2, n, sd, r, rep, t, x = this, d2 = x.d, e = x.e, s2 = x.s, Ctor = x.constructor;
  if (s2 !== 1 || !d2 || !d2[0]) {
    return new Ctor(!s2 || s2 < 0 && (!d2 || d2[0]) ? NaN : d2 ? x : 1 / 0);
  }
  external = false;
  s2 = Math.sqrt(+x);
  if (s2 == 0 || s2 == 1 / 0) {
    n = digitsToString(d2);
    if ((n.length + e) % 2 == 0)
      n += "0";
    s2 = Math.sqrt(n);
    e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
    if (s2 == 1 / 0) {
      n = "5e" + e;
    } else {
      n = s2.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e;
    }
    r = new Ctor(n);
  } else {
    r = new Ctor(s2.toString());
  }
  sd = (e = Ctor.precision) + 3;
  for (; ; ) {
    t = r;
    r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise(t, e + 1, 0);
          if (t.times(t).eq(x)) {
            r = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise(r, e + 1, 1);
          m2 = !r.times(r).eq(x);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r, e, Ctor.rounding, m2);
};
P.tangent = P.tan = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 10;
  Ctor.rounding = 1;
  x = x.sin();
  x.s = 1;
  x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
};
P.times = P.mul = function(y2) {
  var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y2 = new Ctor(y2)).d;
  y2.s *= x.s;
  if (!xd || !xd[0] || !yd || !yd[0]) {
    return new Ctor(!y2.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y2.s / 0 : y2.s * 0);
  }
  e = mathfloor(x.e / LOG_BASE) + mathfloor(y2.e / LOG_BASE);
  xdL = xd.length;
  ydL = yd.length;
  if (xdL < ydL) {
    r = xd;
    xd = yd;
    yd = r;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }
  r = [];
  rL = xdL + ydL;
  for (i = rL; i--; )
    r.push(0);
  for (i = ydL; --i >= 0; ) {
    carry = 0;
    for (k = xdL + i; k > i; ) {
      t = r[k] + yd[i] * xd[k - i - 1] + carry;
      r[k--] = t % BASE | 0;
      carry = t / BASE | 0;
    }
    r[k] = (r[k] + carry) % BASE | 0;
  }
  for (; !r[--rL]; )
    r.pop();
  if (carry)
    ++e;
  else
    r.shift();
  y2.d = r;
  y2.e = getBase10Exponent(r, e);
  return external ? finalise(y2, Ctor.precision, Ctor.rounding) : y2;
};
P.toBinary = function(sd, rm) {
  return toStringBinary(this, 2, sd, rm);
};
P.toDecimalPlaces = P.toDP = function(dp, rm) {
  var x = this, Ctor = x.constructor;
  x = new Ctor(x);
  if (dp === void 0)
    return x;
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm === void 0)
    rm = Ctor.rounding;
  else
    checkInt32(rm, 0, 8);
  return finalise(x, dp + x.e + 1, rm);
};
P.toExponential = function(dp, rm) {
  var str, x = this, Ctor = x.constructor;
  if (dp === void 0) {
    str = finiteToString(x, true);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x = finalise(new Ctor(x), dp + 1, rm);
    str = finiteToString(x, true, dp + 1);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.toFixed = function(dp, rm) {
  var str, y2, x = this, Ctor = x.constructor;
  if (dp === void 0) {
    str = finiteToString(x);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    y2 = finalise(new Ctor(x), dp + x.e + 1, rm);
    str = finiteToString(y2, false, dp + y2.e + 1);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.toFraction = function(maxD) {
  var d2, d0, d1, d22, e, k, n, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;
  if (!xd)
    return new Ctor(x);
  n1 = d0 = new Ctor(1);
  d1 = n0 = new Ctor(0);
  d2 = new Ctor(d1);
  e = d2.e = getPrecision(xd) - x.e - 1;
  k = e % LOG_BASE;
  d2.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);
  if (maxD == null) {
    maxD = e > 0 ? d2 : n1;
  } else {
    n = new Ctor(maxD);
    if (!n.isInt() || n.lt(n1))
      throw Error(invalidArgument + n);
    maxD = n.gt(d2) ? e > 0 ? d2 : n1 : n;
  }
  external = false;
  n = new Ctor(digitsToString(xd));
  pr = Ctor.precision;
  Ctor.precision = e = xd.length * LOG_BASE * 2;
  for (; ; ) {
    q = divide(n, d2, 0, 1, 1);
    d22 = d0.plus(q.times(d1));
    if (d22.cmp(maxD) == 1)
      break;
    d0 = d1;
    d1 = d22;
    d22 = n1;
    n1 = n0.plus(q.times(d22));
    n0 = d22;
    d22 = d2;
    d2 = n.minus(q.times(d22));
    n = d22;
  }
  d22 = divide(maxD.minus(d0), d1, 0, 1, 1);
  n0 = n0.plus(d22.times(n1));
  d0 = d0.plus(d22.times(d1));
  n0.s = n1.s = x.s;
  r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
  Ctor.precision = pr;
  external = true;
  return r;
};
P.toHexadecimal = P.toHex = function(sd, rm) {
  return toStringBinary(this, 16, sd, rm);
};
P.toNearest = function(y2, rm) {
  var x = this, Ctor = x.constructor;
  x = new Ctor(x);
  if (y2 == null) {
    if (!x.d)
      return x;
    y2 = new Ctor(1);
    rm = Ctor.rounding;
  } else {
    y2 = new Ctor(y2);
    if (rm === void 0) {
      rm = Ctor.rounding;
    } else {
      checkInt32(rm, 0, 8);
    }
    if (!x.d)
      return y2.s ? x : y2;
    if (!y2.d) {
      if (y2.s)
        y2.s = x.s;
      return y2;
    }
  }
  if (y2.d[0]) {
    external = false;
    x = divide(x, y2, 0, rm, 1).times(y2);
    external = true;
    finalise(x);
  } else {
    y2.s = x.s;
    x = y2;
  }
  return x;
};
P.toNumber = function() {
  return +this;
};
P.toOctal = function(sd, rm) {
  return toStringBinary(this, 8, sd, rm);
};
P.toPower = P.pow = function(y2) {
  var e, k, pr, r, rm, s2, x = this, Ctor = x.constructor, yn = +(y2 = new Ctor(y2));
  if (!x.d || !y2.d || !x.d[0] || !y2.d[0])
    return new Ctor(mathpow(+x, yn));
  x = new Ctor(x);
  if (x.eq(1))
    return x;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (y2.eq(1))
    return finalise(x, pr, rm);
  e = mathfloor(y2.e / LOG_BASE);
  if (e >= y2.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
    r = intPow(Ctor, x, k, pr);
    return y2.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
  }
  s2 = x.s;
  if (s2 < 0) {
    if (e < y2.d.length - 1)
      return new Ctor(NaN);
    if ((y2.d[e] & 1) == 0)
      s2 = 1;
    if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
      x.s = s2;
      return x;
    }
  }
  k = mathpow(+x, yn);
  e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log("0." + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
  if (e > Ctor.maxE + 1 || e < Ctor.minE - 1)
    return new Ctor(e > 0 ? s2 / 0 : 0);
  external = false;
  Ctor.rounding = x.s = 1;
  k = Math.min(12, (e + "").length);
  r = naturalExponential(y2.times(naturalLogarithm(x, pr + k)), pr);
  if (r.d) {
    r = finalise(r, pr + 5, 1);
    if (checkRoundingDigits(r.d, pr, rm)) {
      e = pr + 10;
      r = finalise(naturalExponential(y2.times(naturalLogarithm(x, e + k)), e), e + 5, 1);
      if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
        r = finalise(r, pr + 1, 0);
      }
    }
  }
  r.s = s2;
  external = true;
  Ctor.rounding = rm;
  return finalise(r, pr, rm);
};
P.toPrecision = function(sd, rm) {
  var str, x = this, Ctor = x.constructor;
  if (sd === void 0) {
    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x = finalise(new Ctor(x), sd, rm);
    str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.toSignificantDigits = P.toSD = function(sd, rm) {
  var x = this, Ctor = x.constructor;
  if (sd === void 0) {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  }
  return finalise(new Ctor(x), sd, rm);
};
P.toString = function() {
  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.truncated = P.trunc = function() {
  return finalise(new this.constructor(this), this.e + 1, 1);
};
P.valueOf = P.toJSON = function() {
  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  return x.isNeg() ? "-" + str : str;
};
function digitsToString(d2) {
  var i, k, ws, indexOfLastWord = d2.length - 1, str = "", w2 = d2[0];
  if (indexOfLastWord > 0) {
    str += w2;
    for (i = 1; i < indexOfLastWord; i++) {
      ws = d2[i] + "";
      k = LOG_BASE - ws.length;
      if (k)
        str += getZeroString(k);
      str += ws;
    }
    w2 = d2[i];
    ws = w2 + "";
    k = LOG_BASE - ws.length;
    if (k)
      str += getZeroString(k);
  } else if (w2 === 0) {
    return "0";
  }
  for (; w2 % 10 === 0; )
    w2 /= 10;
  return str + w2;
}
function checkInt32(i, min2, max2) {
  if (i !== ~~i || i < min2 || i > max2) {
    throw Error(invalidArgument + i);
  }
}
function checkRoundingDigits(d2, i, rm, repeating) {
  var di, k, r, rd;
  for (k = d2[0]; k >= 10; k /= 10)
    --i;
  if (--i < 0) {
    i += LOG_BASE;
    di = 0;
  } else {
    di = Math.ceil((i + 1) / LOG_BASE);
    i %= LOG_BASE;
  }
  k = mathpow(10, LOG_BASE - i);
  rd = d2[di] % k | 0;
  if (repeating == null) {
    if (i < 3) {
      if (i == 0)
        rd = rd / 100 | 0;
      else if (i == 1)
        rd = rd / 10 | 0;
      r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
    } else {
      r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d2[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d2[di + 1] / k / 100 | 0) == 0;
    }
  } else {
    if (i < 4) {
      if (i == 0)
        rd = rd / 1e3 | 0;
      else if (i == 1)
        rd = rd / 100 | 0;
      else if (i == 2)
        rd = rd / 10 | 0;
      r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
    } else {
      r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d2[di + 1] / k / 1e3 | 0) == mathpow(10, i - 3) - 1;
    }
  }
  return r;
}
function convertBase(str, baseIn, baseOut) {
  var j, arr = [0], arrL, i = 0, strL = str.length;
  for (; i < strL; ) {
    for (arrL = arr.length; arrL--; )
      arr[arrL] *= baseIn;
    arr[0] += NUMERALS.indexOf(str.charAt(i++));
    for (j = 0; j < arr.length; j++) {
      if (arr[j] > baseOut - 1) {
        if (arr[j + 1] === void 0)
          arr[j + 1] = 0;
        arr[j + 1] += arr[j] / baseOut | 0;
        arr[j] %= baseOut;
      }
    }
  }
  return arr.reverse();
}
function cosine(Ctor, x) {
  var k, len, y2;
  if (x.isZero())
    return x;
  len = x.d.length;
  if (len < 32) {
    k = Math.ceil(len / 3);
    y2 = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    y2 = "2.3283064365386962890625e-10";
  }
  Ctor.precision += k;
  x = taylorSeries(Ctor, 1, x.times(y2), new Ctor(1));
  for (var i = k; i--; ) {
    var cos2x = x.times(x);
    x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
  }
  Ctor.precision -= k;
  return x;
}
var divide = function() {
  function multiplyInteger(x, k, base) {
    var temp, carry = 0, i = x.length;
    for (x = x.slice(); i--; ) {
      temp = x[i] * k + carry;
      x[i] = temp % base | 0;
      carry = temp / base | 0;
    }
    if (carry)
      x.unshift(carry);
    return x;
  }
  function compare(a, b, aL, bL) {
    var i, r;
    if (aL != bL) {
      r = aL > bL ? 1 : -1;
    } else {
      for (i = r = 0; i < aL; i++) {
        if (a[i] != b[i]) {
          r = a[i] > b[i] ? 1 : -1;
          break;
        }
      }
    }
    return r;
  }
  function subtract(a, b, aL, base) {
    var i = 0;
    for (; aL--; ) {
      a[aL] -= i;
      i = a[aL] < b[aL] ? 1 : 0;
      a[aL] = i * base + a[aL] - b[aL];
    }
    for (; !a[0] && a.length > 1; )
      a.shift();
  }
  return function(x, y2, pr, rm, dp, base) {
    var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign2 = x.s == y2.s ? 1 : -1, xd = x.d, yd = y2.d;
    if (!xd || !xd[0] || !yd || !yd[0]) {
      return new Ctor(!x.s || !y2.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : xd && xd[0] == 0 || !yd ? sign2 * 0 : sign2 / 0);
    }
    if (base) {
      logBase = 1;
      e = x.e - y2.e;
    } else {
      base = BASE;
      logBase = LOG_BASE;
      e = mathfloor(x.e / logBase) - mathfloor(y2.e / logBase);
    }
    yL = yd.length;
    xL = xd.length;
    q = new Ctor(sign2);
    qd = q.d = [];
    for (i = 0; yd[i] == (xd[i] || 0); i++)
      ;
    if (yd[i] > (xd[i] || 0))
      e--;
    if (pr == null) {
      sd = pr = Ctor.precision;
      rm = Ctor.rounding;
    } else if (dp) {
      sd = pr + (x.e - y2.e) + 1;
    } else {
      sd = pr;
    }
    if (sd < 0) {
      qd.push(1);
      more = true;
    } else {
      sd = sd / logBase + 2 | 0;
      i = 0;
      if (yL == 1) {
        k = 0;
        yd = yd[0];
        sd++;
        for (; (i < xL || k) && sd--; i++) {
          t = k * base + (xd[i] || 0);
          qd[i] = t / yd | 0;
          k = t % yd | 0;
        }
        more = k || i < xL;
      } else {
        k = base / (yd[0] + 1) | 0;
        if (k > 1) {
          yd = multiplyInteger(yd, k, base);
          xd = multiplyInteger(xd, k, base);
          yL = yd.length;
          xL = xd.length;
        }
        xi = yL;
        rem = xd.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; )
          rem[remL++] = 0;
        yz = yd.slice();
        yz.unshift(0);
        yd0 = yd[0];
        if (yd[1] >= base / 2)
          ++yd0;
        do {
          k = 0;
          cmp = compare(yd, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL)
              rem0 = rem0 * base + (rem[1] || 0);
            k = rem0 / yd0 | 0;
            if (k > 1) {
              if (k >= base)
                k = base - 1;
              prod = multiplyInteger(yd, k, base);
              prodL = prod.length;
              remL = rem.length;
              cmp = compare(prod, rem, prodL, remL);
              if (cmp == 1) {
                k--;
                subtract(prod, yL < prodL ? yz : yd, prodL, base);
              }
            } else {
              if (k == 0)
                cmp = k = 1;
              prod = yd.slice();
            }
            prodL = prod.length;
            if (prodL < remL)
              prod.unshift(0);
            subtract(rem, prod, remL, base);
            if (cmp == -1) {
              remL = rem.length;
              cmp = compare(yd, rem, yL, remL);
              if (cmp < 1) {
                k++;
                subtract(rem, yL < remL ? yz : yd, remL, base);
              }
            }
            remL = rem.length;
          } else if (cmp === 0) {
            k++;
            rem = [0];
          }
          qd[i++] = k;
          if (cmp && rem[0]) {
            rem[remL++] = xd[xi] || 0;
          } else {
            rem = [xd[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] !== void 0) && sd--);
        more = rem[0] !== void 0;
      }
      if (!qd[0])
        qd.shift();
    }
    if (logBase == 1) {
      q.e = e;
      inexact = more;
    } else {
      for (i = 1, k = qd[0]; k >= 10; k /= 10)
        i++;
      q.e = i + e * logBase - 1;
      finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
    }
    return q;
  };
}();
function finalise(x, sd, rm, isTruncated) {
  var digits, i, j, k, rd, roundUp, w2, xd, xdi, Ctor = x.constructor;
  out:
    if (sd != null) {
      xd = x.d;
      if (!xd)
        return x;
      for (digits = 1, k = xd[0]; k >= 10; k /= 10)
        digits++;
      i = sd - digits;
      if (i < 0) {
        i += LOG_BASE;
        j = sd;
        w2 = xd[xdi = 0];
        rd = w2 / mathpow(10, digits - j - 1) % 10 | 0;
      } else {
        xdi = Math.ceil((i + 1) / LOG_BASE);
        k = xd.length;
        if (xdi >= k) {
          if (isTruncated) {
            for (; k++ <= xdi; )
              xd.push(0);
            w2 = rd = 0;
            digits = 1;
            i %= LOG_BASE;
            j = i - LOG_BASE + 1;
          } else {
            break out;
          }
        } else {
          w2 = k = xd[xdi];
          for (digits = 1; k >= 10; k /= 10)
            digits++;
          i %= LOG_BASE;
          j = i - LOG_BASE + digits;
          rd = j < 0 ? 0 : w2 / mathpow(10, digits - j - 1) % 10 | 0;
        }
      }
      isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w2 : w2 % mathpow(10, digits - j - 1));
      roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && (i > 0 ? j > 0 ? w2 / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
      if (sd < 1 || !xd[0]) {
        xd.length = 0;
        if (roundUp) {
          sd -= x.e + 1;
          xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
          x.e = -sd || 0;
        } else {
          xd[0] = x.e = 0;
        }
        return x;
      }
      if (i == 0) {
        xd.length = xdi;
        k = 1;
        xdi--;
      } else {
        xd.length = xdi + 1;
        k = mathpow(10, LOG_BASE - i);
        xd[xdi] = j > 0 ? (w2 / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
      }
      if (roundUp) {
        for (; ; ) {
          if (xdi == 0) {
            for (i = 1, j = xd[0]; j >= 10; j /= 10)
              i++;
            j = xd[0] += k;
            for (k = 1; j >= 10; j /= 10)
              k++;
            if (i != k) {
              x.e++;
              if (xd[0] == BASE)
                xd[0] = 1;
            }
            break;
          } else {
            xd[xdi] += k;
            if (xd[xdi] != BASE)
              break;
            xd[xdi--] = 0;
            k = 1;
          }
        }
      }
      for (i = xd.length; xd[--i] === 0; )
        xd.pop();
    }
  if (external) {
    if (x.e > Ctor.maxE) {
      x.d = null;
      x.e = NaN;
    } else if (x.e < Ctor.minE) {
      x.e = 0;
      x.d = [0];
    }
  }
  return x;
}
function finiteToString(x, isExp, sd) {
  if (!x.isFinite())
    return nonFiniteToString(x);
  var k, e = x.e, str = digitsToString(x.d), len = str.length;
  if (isExp) {
    if (sd && (k = sd - len) > 0) {
      str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
    } else if (len > 1) {
      str = str.charAt(0) + "." + str.slice(1);
    }
    str = str + (x.e < 0 ? "e" : "e+") + x.e;
  } else if (e < 0) {
    str = "0." + getZeroString(-e - 1) + str;
    if (sd && (k = sd - len) > 0)
      str += getZeroString(k);
  } else if (e >= len) {
    str += getZeroString(e + 1 - len);
    if (sd && (k = sd - e - 1) > 0)
      str = str + "." + getZeroString(k);
  } else {
    if ((k = e + 1) < len)
      str = str.slice(0, k) + "." + str.slice(k);
    if (sd && (k = sd - len) > 0) {
      if (e + 1 === len)
        str += ".";
      str += getZeroString(k);
    }
  }
  return str;
}
function getBase10Exponent(digits, e) {
  var w2 = digits[0];
  for (e *= LOG_BASE; w2 >= 10; w2 /= 10)
    e++;
  return e;
}
function getLn10(Ctor, sd, pr) {
  if (sd > LN10_PRECISION) {
    external = true;
    if (pr)
      Ctor.precision = pr;
    throw Error(precisionLimitExceeded);
  }
  return finalise(new Ctor(LN10), sd, 1, true);
}
function getPi(Ctor, sd, rm) {
  if (sd > PI_PRECISION)
    throw Error(precisionLimitExceeded);
  return finalise(new Ctor(PI), sd, rm, true);
}
function getPrecision(digits) {
  var w2 = digits.length - 1, len = w2 * LOG_BASE + 1;
  w2 = digits[w2];
  if (w2) {
    for (; w2 % 10 == 0; w2 /= 10)
      len--;
    for (w2 = digits[0]; w2 >= 10; w2 /= 10)
      len++;
  }
  return len;
}
function getZeroString(k) {
  var zs = "";
  for (; k--; )
    zs += "0";
  return zs;
}
function intPow(Ctor, x, n, pr) {
  var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);
  external = false;
  for (; ; ) {
    if (n % 2) {
      r = r.times(x);
      if (truncate(r.d, k))
        isTruncated = true;
    }
    n = mathfloor(n / 2);
    if (n === 0) {
      n = r.d.length - 1;
      if (isTruncated && r.d[n] === 0)
        ++r.d[n];
      break;
    }
    x = x.times(x);
    truncate(x.d, k);
  }
  external = true;
  return r;
}
function isOdd(n) {
  return n.d[n.d.length - 1] & 1;
}
function maxOrMin(Ctor, args, ltgt) {
  var y2, x = new Ctor(args[0]), i = 0;
  for (; ++i < args.length; ) {
    y2 = new Ctor(args[i]);
    if (!y2.s) {
      x = y2;
      break;
    } else if (x[ltgt](y2)) {
      x = y2;
    }
  }
  return x;
}
function naturalExponential(x, sd) {
  var denominator, guard, j, pow2, sum2, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (!x.d || !x.d[0] || x.e > 17) {
    return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  t = new Ctor(0.03125);
  while (x.e > -2) {
    x = x.times(t);
    k += 5;
  }
  guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
  wpr += guard;
  denominator = pow2 = sum2 = new Ctor(1);
  Ctor.precision = wpr;
  for (; ; ) {
    pow2 = finalise(pow2.times(x), wpr, 1);
    denominator = denominator.times(++i);
    t = sum2.plus(divide(pow2, denominator, wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
      j = k;
      while (j--)
        sum2 = finalise(sum2.times(sum2), wpr, 1);
      if (sd == null) {
        if (rep < 3 && checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += 10;
          denominator = pow2 = t = new Ctor(1);
          i = 0;
          rep++;
        } else {
          return finalise(sum2, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum2;
      }
    }
    sum2 = t;
  }
}
function naturalLogarithm(y2, sd) {
  var c, c0, denominator, e, numerator, rep, sum2, t, wpr, x1, x2, n = 1, guard = 10, x = y2, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
    return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  Ctor.precision = wpr += guard;
  c = digitsToString(xd);
  c0 = c.charAt(0);
  if (Math.abs(e = x.e) < 15e14) {
    while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
      x = x.times(y2);
      c = digitsToString(x.d);
      c0 = c.charAt(0);
      n++;
    }
    e = x.e;
    if (c0 > 1) {
      x = new Ctor("0." + c);
      e++;
    } else {
      x = new Ctor(c0 + "." + c.slice(1));
    }
  } else {
    t = getLn10(Ctor, wpr + 2, pr).times(e + "");
    x = naturalLogarithm(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
    Ctor.precision = pr;
    return sd == null ? finalise(x, pr, rm, external = true) : x;
  }
  x1 = x;
  sum2 = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
  x2 = finalise(x.times(x), wpr, 1);
  denominator = 3;
  for (; ; ) {
    numerator = finalise(numerator.times(x2), wpr, 1);
    t = sum2.plus(divide(numerator, new Ctor(denominator), wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
      sum2 = sum2.times(2);
      if (e !== 0)
        sum2 = sum2.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
      sum2 = divide(sum2, new Ctor(n), wpr, 1);
      if (sd == null) {
        if (checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += guard;
          t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
          x2 = finalise(x.times(x), wpr, 1);
          denominator = rep = 1;
        } else {
          return finalise(sum2, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum2;
      }
    }
    sum2 = t;
    denominator += 2;
  }
}
function nonFiniteToString(x) {
  return String(x.s * x.s / 0);
}
function parseDecimal(x, str) {
  var e, i, len;
  if ((e = str.indexOf(".")) > -1)
    str = str.replace(".", "");
  if ((i = str.search(/e/i)) > 0) {
    if (e < 0)
      e = i;
    e += +str.slice(i + 1);
    str = str.substring(0, i);
  } else if (e < 0) {
    e = str.length;
  }
  for (i = 0; str.charCodeAt(i) === 48; i++)
    ;
  for (len = str.length; str.charCodeAt(len - 1) === 48; --len)
    ;
  str = str.slice(i, len);
  if (str) {
    len -= i;
    x.e = e = e - i - 1;
    x.d = [];
    i = (e + 1) % LOG_BASE;
    if (e < 0)
      i += LOG_BASE;
    if (i < len) {
      if (i)
        x.d.push(+str.slice(0, i));
      for (len -= LOG_BASE; i < len; )
        x.d.push(+str.slice(i, i += LOG_BASE));
      str = str.slice(i);
      i = LOG_BASE - str.length;
    } else {
      i -= len;
    }
    for (; i--; )
      str += "0";
    x.d.push(+str);
    if (external) {
      if (x.e > x.constructor.maxE) {
        x.d = null;
        x.e = NaN;
      } else if (x.e < x.constructor.minE) {
        x.e = 0;
        x.d = [0];
      }
    }
  } else {
    x.e = 0;
    x.d = [0];
  }
  return x;
}
function parseOther(x, str) {
  var base, Ctor, divisor, i, isFloat, len, p, xd, xe;
  if (str.indexOf("_") > -1) {
    str = str.replace(/(\d)_(?=\d)/g, "$1");
    if (isDecimal.test(str))
      return parseDecimal(x, str);
  } else if (str === "Infinity" || str === "NaN") {
    if (!+str)
      x.s = NaN;
    x.e = NaN;
    x.d = null;
    return x;
  }
  if (isHex.test(str)) {
    base = 16;
    str = str.toLowerCase();
  } else if (isBinary.test(str)) {
    base = 2;
  } else if (isOctal.test(str)) {
    base = 8;
  } else {
    throw Error(invalidArgument + str);
  }
  i = str.search(/p/i);
  if (i > 0) {
    p = +str.slice(i + 1);
    str = str.substring(2, i);
  } else {
    str = str.slice(2);
  }
  i = str.indexOf(".");
  isFloat = i >= 0;
  Ctor = x.constructor;
  if (isFloat) {
    str = str.replace(".", "");
    len = str.length;
    i = len - i;
    divisor = intPow(Ctor, new Ctor(base), i, i * 2);
  }
  xd = convertBase(str, base, BASE);
  xe = xd.length - 1;
  for (i = xe; xd[i] === 0; --i)
    xd.pop();
  if (i < 0)
    return new Ctor(x.s * 0);
  x.e = getBase10Exponent(xd, xe);
  x.d = xd;
  external = false;
  if (isFloat)
    x = divide(x, divisor, len * 4);
  if (p)
    x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
  external = true;
  return x;
}
function sine(Ctor, x) {
  var k, len = x.d.length;
  if (len < 3) {
    return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
  }
  k = 1.4 * Math.sqrt(len);
  k = k > 16 ? 16 : k | 0;
  x = x.times(1 / tinyPow(5, k));
  x = taylorSeries(Ctor, 2, x, x);
  var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
  for (; k--; ) {
    sin2_x = x.times(x);
    x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
  }
  return x;
}
function taylorSeries(Ctor, n, x, y2, isHyperbolic) {
  var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);
  external = false;
  x2 = x.times(x);
  u = new Ctor(y2);
  for (; ; ) {
    t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
    u = isHyperbolic ? y2.plus(t) : y2.minus(t);
    y2 = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
    t = u.plus(y2);
    if (t.d[k] !== void 0) {
      for (j = k; t.d[j] === u.d[j] && j--; )
        ;
      if (j == -1)
        break;
    }
    j = u;
    u = y2;
    y2 = t;
    t = j;
    i++;
  }
  external = true;
  t.d.length = k + 1;
  return t;
}
function tinyPow(b, e) {
  var n = b;
  while (--e)
    n *= b;
  return n;
}
function toLessThanHalfPi(Ctor, x) {
  var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);
  x = x.abs();
  if (x.lte(halfPi)) {
    quadrant = isNeg ? 4 : 1;
    return x;
  }
  t = x.divToInt(pi);
  if (t.isZero()) {
    quadrant = isNeg ? 3 : 2;
  } else {
    x = x.minus(t.times(pi));
    if (x.lte(halfPi)) {
      quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
      return x;
    }
    quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
  }
  return x.minus(pi).abs();
}
function toStringBinary(x, baseOut, sd, rm) {
  var base, e, i, k, len, roundUp, str, xd, y2, Ctor = x.constructor, isExp = sd !== void 0;
  if (isExp) {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  } else {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  }
  if (!x.isFinite()) {
    str = nonFiniteToString(x);
  } else {
    str = finiteToString(x);
    i = str.indexOf(".");
    if (isExp) {
      base = 2;
      if (baseOut == 16) {
        sd = sd * 4 - 3;
      } else if (baseOut == 8) {
        sd = sd * 3 - 2;
      }
    } else {
      base = baseOut;
    }
    if (i >= 0) {
      str = str.replace(".", "");
      y2 = new Ctor(1);
      y2.e = str.length - i;
      y2.d = convertBase(finiteToString(y2), 10, base);
      y2.e = y2.d.length;
    }
    xd = convertBase(str, 10, base);
    e = len = xd.length;
    for (; xd[--len] == 0; )
      xd.pop();
    if (!xd[0]) {
      str = isExp ? "0p+0" : "0";
    } else {
      if (i < 0) {
        e--;
      } else {
        x = new Ctor(x);
        x.d = xd;
        x.e = e;
        x = divide(x, y2, sd, rm, 0, base);
        xd = x.d;
        e = x.e;
        roundUp = inexact;
      }
      i = xd[sd];
      k = base / 2;
      roundUp = roundUp || xd[sd + 1] !== void 0;
      roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
      xd.length = sd;
      if (roundUp) {
        for (; ++xd[--sd] > base - 1; ) {
          xd[sd] = 0;
          if (!sd) {
            ++e;
            xd.unshift(1);
          }
        }
      }
      for (len = xd.length; !xd[len - 1]; --len)
        ;
      for (i = 0, str = ""; i < len; i++)
        str += NUMERALS.charAt(xd[i]);
      if (isExp) {
        if (len > 1) {
          if (baseOut == 16 || baseOut == 8) {
            i = baseOut == 16 ? 4 : 3;
            for (--len; len % i; len++)
              str += "0";
            xd = convertBase(str, base, baseOut);
            for (len = xd.length; !xd[len - 1]; --len)
              ;
            for (i = 1, str = "1."; i < len; i++)
              str += NUMERALS.charAt(xd[i]);
          } else {
            str = str.charAt(0) + "." + str.slice(1);
          }
        }
        str = str + (e < 0 ? "p" : "p+") + e;
      } else if (e < 0) {
        for (; ++e; )
          str = "0" + str;
        str = "0." + str;
      } else {
        if (++e > len)
          for (e -= len; e--; )
            str += "0";
        else if (e < len)
          str = str.slice(0, e) + "." + str.slice(e);
      }
    }
    str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
  }
  return x.s < 0 ? "-" + str : str;
}
function truncate(arr, len) {
  if (arr.length > len) {
    arr.length = len;
    return true;
  }
}
function abs(x) {
  return new this(x).abs();
}
function acos(x) {
  return new this(x).acos();
}
function acosh(x) {
  return new this(x).acosh();
}
function add(x, y2) {
  return new this(x).plus(y2);
}
function asin(x) {
  return new this(x).asin();
}
function asinh(x) {
  return new this(x).asinh();
}
function atan(x) {
  return new this(x).atan();
}
function atanh(x) {
  return new this(x).atanh();
}
function atan2(y2, x) {
  y2 = new this(y2);
  x = new this(x);
  var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
  if (!y2.s || !x.s) {
    r = new this(NaN);
  } else if (!y2.d && !x.d) {
    r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
    r.s = y2.s;
  } else if (!x.d || y2.isZero()) {
    r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
    r.s = y2.s;
  } else if (!y2.d || x.isZero()) {
    r = getPi(this, wpr, 1).times(0.5);
    r.s = y2.s;
  } else if (x.s < 0) {
    this.precision = wpr;
    this.rounding = 1;
    r = this.atan(divide(y2, x, wpr, 1));
    x = getPi(this, wpr, 1);
    this.precision = pr;
    this.rounding = rm;
    r = y2.s < 0 ? r.minus(x) : r.plus(x);
  } else {
    r = this.atan(divide(y2, x, wpr, 1));
  }
  return r;
}
function cbrt(x) {
  return new this(x).cbrt();
}
function ceil(x) {
  return finalise(x = new this(x), x.e + 1, 2);
}
function clamp(x, min2, max2) {
  return new this(x).clamp(min2, max2);
}
function config(obj) {
  if (!obj || typeof obj !== "object")
    throw Error(decimalError + "Object expected");
  var i, p, v, useDefaults = obj.defaults === true, ps = [
    "precision",
    1,
    MAX_DIGITS,
    "rounding",
    0,
    8,
    "toExpNeg",
    -EXP_LIMIT,
    0,
    "toExpPos",
    0,
    EXP_LIMIT,
    "maxE",
    0,
    EXP_LIMIT,
    "minE",
    -EXP_LIMIT,
    0,
    "modulo",
    0,
    9
  ];
  for (i = 0; i < ps.length; i += 3) {
    if (p = ps[i], useDefaults)
      this[p] = DEFAULTS[p];
    if ((v = obj[p]) !== void 0) {
      if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2])
        this[p] = v;
      else
        throw Error(invalidArgument + p + ": " + v);
    }
  }
  if (p = "crypto", useDefaults)
    this[p] = DEFAULTS[p];
  if ((v = obj[p]) !== void 0) {
    if (v === true || v === false || v === 0 || v === 1) {
      if (v) {
        if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
          this[p] = true;
        } else {
          throw Error(cryptoUnavailable);
        }
      } else {
        this[p] = false;
      }
    } else {
      throw Error(invalidArgument + p + ": " + v);
    }
  }
  return this;
}
function cos(x) {
  return new this(x).cos();
}
function cosh(x) {
  return new this(x).cosh();
}
function clone(obj) {
  var i, p, ps;
  function Decimal2(v) {
    var e, i2, t, x = this;
    if (!(x instanceof Decimal2))
      return new Decimal2(v);
    x.constructor = Decimal2;
    if (isDecimalInstance(v)) {
      x.s = v.s;
      if (external) {
        if (!v.d || v.e > Decimal2.maxE) {
          x.e = NaN;
          x.d = null;
        } else if (v.e < Decimal2.minE) {
          x.e = 0;
          x.d = [0];
        } else {
          x.e = v.e;
          x.d = v.d.slice();
        }
      } else {
        x.e = v.e;
        x.d = v.d ? v.d.slice() : v.d;
      }
      return;
    }
    t = typeof v;
    if (t === "number") {
      if (v === 0) {
        x.s = 1 / v < 0 ? -1 : 1;
        x.e = 0;
        x.d = [0];
        return;
      }
      if (v < 0) {
        v = -v;
        x.s = -1;
      } else {
        x.s = 1;
      }
      if (v === ~~v && v < 1e7) {
        for (e = 0, i2 = v; i2 >= 10; i2 /= 10)
          e++;
        if (external) {
          if (e > Decimal2.maxE) {
            x.e = NaN;
            x.d = null;
          } else if (e < Decimal2.minE) {
            x.e = 0;
            x.d = [0];
          } else {
            x.e = e;
            x.d = [v];
          }
        } else {
          x.e = e;
          x.d = [v];
        }
        return;
      } else if (v * 0 !== 0) {
        if (!v)
          x.s = NaN;
        x.e = NaN;
        x.d = null;
        return;
      }
      return parseDecimal(x, v.toString());
    } else if (t !== "string") {
      throw Error(invalidArgument + v);
    }
    if ((i2 = v.charCodeAt(0)) === 45) {
      v = v.slice(1);
      x.s = -1;
    } else {
      if (i2 === 43)
        v = v.slice(1);
      x.s = 1;
    }
    return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
  }
  Decimal2.prototype = P;
  Decimal2.ROUND_UP = 0;
  Decimal2.ROUND_DOWN = 1;
  Decimal2.ROUND_CEIL = 2;
  Decimal2.ROUND_FLOOR = 3;
  Decimal2.ROUND_HALF_UP = 4;
  Decimal2.ROUND_HALF_DOWN = 5;
  Decimal2.ROUND_HALF_EVEN = 6;
  Decimal2.ROUND_HALF_CEIL = 7;
  Decimal2.ROUND_HALF_FLOOR = 8;
  Decimal2.EUCLID = 9;
  Decimal2.config = Decimal2.set = config;
  Decimal2.clone = clone;
  Decimal2.isDecimal = isDecimalInstance;
  Decimal2.abs = abs;
  Decimal2.acos = acos;
  Decimal2.acosh = acosh;
  Decimal2.add = add;
  Decimal2.asin = asin;
  Decimal2.asinh = asinh;
  Decimal2.atan = atan;
  Decimal2.atanh = atanh;
  Decimal2.atan2 = atan2;
  Decimal2.cbrt = cbrt;
  Decimal2.ceil = ceil;
  Decimal2.clamp = clamp;
  Decimal2.cos = cos;
  Decimal2.cosh = cosh;
  Decimal2.div = div;
  Decimal2.exp = exp;
  Decimal2.floor = floor;
  Decimal2.hypot = hypot;
  Decimal2.ln = ln;
  Decimal2.log = log;
  Decimal2.log10 = log10;
  Decimal2.log2 = log2;
  Decimal2.max = max;
  Decimal2.min = min;
  Decimal2.mod = mod;
  Decimal2.mul = mul;
  Decimal2.pow = pow;
  Decimal2.random = random;
  Decimal2.round = round;
  Decimal2.sign = sign;
  Decimal2.sin = sin;
  Decimal2.sinh = sinh;
  Decimal2.sqrt = sqrt;
  Decimal2.sub = sub;
  Decimal2.sum = sum;
  Decimal2.tan = tan;
  Decimal2.tanh = tanh;
  Decimal2.trunc = trunc;
  if (obj === void 0)
    obj = {};
  if (obj) {
    if (obj.defaults !== true) {
      ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
      for (i = 0; i < ps.length; )
        if (!obj.hasOwnProperty(p = ps[i++]))
          obj[p] = this[p];
    }
  }
  Decimal2.config(obj);
  return Decimal2;
}
function div(x, y2) {
  return new this(x).div(y2);
}
function exp(x) {
  return new this(x).exp();
}
function floor(x) {
  return finalise(x = new this(x), x.e + 1, 3);
}
function hypot() {
  var i, n, t = new this(0);
  external = false;
  for (i = 0; i < arguments.length; ) {
    n = new this(arguments[i++]);
    if (!n.d) {
      if (n.s) {
        external = true;
        return new this(1 / 0);
      }
      t = n;
    } else if (t.d) {
      t = t.plus(n.times(n));
    }
  }
  external = true;
  return t.sqrt();
}
function isDecimalInstance(obj) {
  return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
}
function ln(x) {
  return new this(x).ln();
}
function log(x, y2) {
  return new this(x).log(y2);
}
function log2(x) {
  return new this(x).log(2);
}
function log10(x) {
  return new this(x).log(10);
}
function max() {
  return maxOrMin(this, arguments, "lt");
}
function min() {
  return maxOrMin(this, arguments, "gt");
}
function mod(x, y2) {
  return new this(x).mod(y2);
}
function mul(x, y2) {
  return new this(x).mul(y2);
}
function pow(x, y2) {
  return new this(x).pow(y2);
}
function random(sd) {
  var d2, e, k, n, i = 0, r = new this(1), rd = [];
  if (sd === void 0)
    sd = this.precision;
  else
    checkInt32(sd, 1, MAX_DIGITS);
  k = Math.ceil(sd / LOG_BASE);
  if (!this.crypto) {
    for (; i < k; )
      rd[i++] = Math.random() * 1e7 | 0;
  } else if (crypto.getRandomValues) {
    d2 = crypto.getRandomValues(new Uint32Array(k));
    for (; i < k; ) {
      n = d2[i];
      if (n >= 429e7) {
        d2[i] = crypto.getRandomValues(new Uint32Array(1))[0];
      } else {
        rd[i++] = n % 1e7;
      }
    }
  } else if (crypto.randomBytes) {
    d2 = crypto.randomBytes(k *= 4);
    for (; i < k; ) {
      n = d2[i] + (d2[i + 1] << 8) + (d2[i + 2] << 16) + ((d2[i + 3] & 127) << 24);
      if (n >= 214e7) {
        crypto.randomBytes(4).copy(d2, i);
      } else {
        rd.push(n % 1e7);
        i += 4;
      }
    }
    i = k / 4;
  } else {
    throw Error(cryptoUnavailable);
  }
  k = rd[--i];
  sd %= LOG_BASE;
  if (k && sd) {
    n = mathpow(10, LOG_BASE - sd);
    rd[i] = (k / n | 0) * n;
  }
  for (; rd[i] === 0; i--)
    rd.pop();
  if (i < 0) {
    e = 0;
    rd = [0];
  } else {
    e = -1;
    for (; rd[0] === 0; e -= LOG_BASE)
      rd.shift();
    for (k = 1, n = rd[0]; n >= 10; n /= 10)
      k++;
    if (k < LOG_BASE)
      e -= LOG_BASE - k;
  }
  r.e = e;
  r.d = rd;
  return r;
}
function round(x) {
  return finalise(x = new this(x), x.e + 1, this.rounding);
}
function sign(x) {
  x = new this(x);
  return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
}
function sin(x) {
  return new this(x).sin();
}
function sinh(x) {
  return new this(x).sinh();
}
function sqrt(x) {
  return new this(x).sqrt();
}
function sub(x, y2) {
  return new this(x).sub(y2);
}
function sum() {
  var i = 0, args = arguments, x = new this(args[i]);
  external = false;
  for (; x.s && ++i < args.length; )
    x = x.plus(args[i]);
  external = true;
  return finalise(x, this.precision, this.rounding);
}
function tan(x) {
  return new this(x).tan();
}
function tanh(x) {
  return new this(x).tanh();
}
function trunc(x) {
  return finalise(x = new this(x), x.e + 1, 1);
}
P[Symbol.for("nodejs.util.inspect.custom")] = P.toString;
P[Symbol.toStringTag] = "Decimal";
var Decimal = P.constructor = clone(DEFAULTS);
LN10 = new Decimal(LN10);
PI = new Decimal(PI);

// src/runtime/utils/common.ts
var keyBy2 = (collection, prop) => {
  const acc = {};
  for (const obj of collection) {
    const key = obj[prop];
    acc[key] = obj;
  }
  return acc;
};
var keyBy22 = (collection1, collection2, prop) => {
  const acc = {};
  for (const obj of collection1) {
    const key = obj[prop];
    acc[key] = obj;
  }
  for (const obj of collection2) {
    const key = obj[prop];
    acc[key] = obj;
  }
  return acc;
};
var ScalarTypeTable = {
  String: true,
  Int: true,
  Float: true,
  Boolean: true,
  Long: true,
  DateTime: true,
  ID: true,
  UUID: true,
  Json: true,
  Bytes: true,
  Decimal: true,
  BigInt: true
};
var needNamespace = {
  Json: "JsonValue",
  Decimal: "Decimal"
};
function needsNamespace(field, dmmf) {
  if (typeof field.type === "string") {
    if (dmmf.datamodelEnumMap[field.type]) {
      return false;
    }
    if (GraphQLScalarToJSTypeTable[field.type]) {
      return Boolean(needNamespace[field.type]);
    }
  }
  return true;
}
var GraphQLScalarToJSTypeTable = {
  String: "string",
  Int: "number",
  Float: "number",
  Boolean: "boolean",
  Long: "number",
  DateTime: ["Date", "string"],
  ID: "string",
  UUID: "string",
  Json: "JsonValue",
  Bytes: "Buffer",
  Decimal: ["Decimal", "number", "string"],
  BigInt: ["bigint", "number"]
};
var JSOutputTypeToInputType = {
  JsonValue: "InputJsonValue"
};
function argIsInputType(arg2) {
  if (typeof arg2 === "string") {
    return false;
  }
  return true;
}
function capitalize(str) {
  return str[0].toUpperCase() + str.slice(1);
}
function lowerCase(name) {
  return name.substring(0, 1).toLowerCase() + name.substring(1);
}
function isSchemaEnum(type) {
  return typeof type === "object" && type.name && typeof type.name === "string" && type.values && Array.isArray(type.values);
}

// src/runtime/externalToInternalDmmf.ts
function externalToInternalDmmf(document2) {
  return {
    ...document2,
    mappings: getMappings(document2.mappings, document2.datamodel)
  };
}
function getMappings(mappings, datamodel) {
  const modelOperations = mappings.modelOperations.filter((mapping) => {
    const model = datamodel.models.find((m2) => m2.name === mapping.model);
    if (!model) {
      throw new Error(`Mapping without model ${mapping.model}`);
    }
    return model.fields.some((f) => f.kind !== "object");
  }).map((mapping) => ({
    model: mapping.model,
    plural: import_pluralize.default(lowerCase(mapping.model)),
    findUnique: mapping.findUnique || mapping.findSingle,
    findFirst: mapping.findFirst,
    findMany: mapping.findMany,
    create: mapping.createOne || mapping.createSingle || mapping.create,
    createMany: mapping.createMany,
    delete: mapping.deleteOne || mapping.deleteSingle || mapping.delete,
    update: mapping.updateOne || mapping.updateSingle || mapping.update,
    deleteMany: mapping.deleteMany,
    updateMany: mapping.updateMany,
    upsert: mapping.upsertOne || mapping.upsertSingle || mapping.upsert,
    aggregate: mapping.aggregate,
    groupBy: mapping.groupBy
  }));
  return {
    modelOperations,
    otherOperations: mappings.otherOperations
  };
}

// src/generation/getDMMF.ts
function getPrismaClientDMMF(dmmf) {
  return externalToInternalDmmf(dmmf);
}
async function getDMMF2(options) {
  const dmmf = await import_getDmmf.getDMMF(options);
  return getPrismaClientDMMF(dmmf);
}

// ../../node_modules/.pnpm/flat-map-polyfill@0.3.8/node_modules/flat-map-polyfill/dist/cjs/index.js
"use strict";
require_flatten();
require_flat_map();

// src/generation/TSClient/Args.ts
var import_indent_string4 = __toModule2(require_indent_string2());

// src/runtime/dmmf-types.ts
var import_generator_helper = __toModule2(require_dist8());

// src/generation/utils.ts
var import_getNodeAPIName = __toModule2(require_getNodeAPIName2());
var import_indent_string2 = __toModule2(require_indent_string2());
var import_path2 = __toModule2(require("path"));
var Projection;
(function(Projection2) {
  Projection2["select"] = "select";
  Projection2["include"] = "include";
})(Projection || (Projection = {}));
function getPayloadName(modelName) {
  return `${modelName}GetPayload`;
}
function getSelectName(modelName) {
  return `${modelName}Select`;
}
function getAggregateName(modelName) {
  return `Aggregate${capitalize2(modelName)}`;
}
function getGroupByName(modelName) {
  return `${capitalize2(modelName)}GroupByOutputType`;
}
function getAvgAggregateName(modelName) {
  return `${capitalize2(modelName)}AvgAggregateOutputType`;
}
function getSumAggregateName(modelName) {
  return `${capitalize2(modelName)}SumAggregateOutputType`;
}
function getMinAggregateName(modelName) {
  return `${capitalize2(modelName)}MinAggregateOutputType`;
}
function getMaxAggregateName(modelName) {
  return `${capitalize2(modelName)}MaxAggregateOutputType`;
}
function getCountAggregateInputName(modelName) {
  return `${capitalize2(modelName)}CountAggregateInputType`;
}
function getCountAggregateOutputName(modelName) {
  return `${capitalize2(modelName)}CountAggregateOutputType`;
}
function getAggregateInputType(aggregateOutputType) {
  return aggregateOutputType.replace(/OutputType$/, "InputType");
}
function getGroupByArgsName(modelName) {
  return `${capitalize2(modelName)}GroupByArgs`;
}
function getGroupByPayloadName(modelName) {
  return `Get${capitalize2(modelName)}GroupByPayload`;
}
function getAggregateArgsName(modelName) {
  return `${capitalize2(modelName)}AggregateArgs`;
}
function getAggregateGetName(modelName) {
  return `Get${capitalize2(modelName)}AggregateType`;
}
function getIncludeName(modelName) {
  return `${modelName}Include`;
}
function getFieldArgName(field) {
  return getArgName(field.outputType.type.name, field.outputType.isList);
}
function getArgName(name, isList) {
  if (!isList) {
    return `${name}Args`;
  }
  return `${name}FindManyArgs`;
}
function getModelArgName(modelName, action) {
  if (!action) {
    return `${modelName}Args`;
  }
  switch (action) {
    case import_generator_helper.DMMF.ModelAction.findMany:
      return `${modelName}FindManyArgs`;
    case import_generator_helper.DMMF.ModelAction.findUnique:
      return `${modelName}FindUniqueArgs`;
    case import_generator_helper.DMMF.ModelAction.findFirst:
      return `${modelName}FindFirstArgs`;
    case import_generator_helper.DMMF.ModelAction.upsert:
      return `${modelName}UpsertArgs`;
    case import_generator_helper.DMMF.ModelAction.update:
      return `${modelName}UpdateArgs`;
    case import_generator_helper.DMMF.ModelAction.updateMany:
      return `${modelName}UpdateManyArgs`;
    case import_generator_helper.DMMF.ModelAction.delete:
      return `${modelName}DeleteArgs`;
    case import_generator_helper.DMMF.ModelAction.create:
      return `${modelName}CreateArgs`;
    case import_generator_helper.DMMF.ModelAction.createMany:
      return `${modelName}CreateManyArgs`;
    case import_generator_helper.DMMF.ModelAction.deleteMany:
      return `${modelName}DeleteManyArgs`;
    case import_generator_helper.DMMF.ModelAction.groupBy:
      return `${modelName}GroupByArgs`;
    case import_generator_helper.DMMF.ModelAction.aggregate:
      return getAggregateArgsName(modelName);
    case import_generator_helper.DMMF.ModelAction.count:
      return `${modelName}CountArgs`;
  }
}
function getType(name, isList, isOptional) {
  return name + (isList ? "[]" : "") + (isOptional ? " | null" : "");
}
function getSelectReturnType({
  name,
  actionName,
  renderPromise = true,
  hideCondition = false,
  isField = false
}) {
  if (actionName === "count") {
    return `Promise<number>`;
  }
  if (actionName === "aggregate")
    return `Promise<${getAggregateGetName(name)}<T>>`;
  const isList = actionName === import_generator_helper.DMMF.ModelAction.findMany;
  if (actionName === "deleteMany" || actionName === "updateMany" || actionName === "createMany") {
    return `PrismaPromise<BatchPayload>`;
  }
  if (isList || hideCondition) {
    const listOpen = isList ? "Array<" : "";
    const listClose = isList ? ">" : "";
    const promiseOpen = renderPromise ? "PrismaPromise<" : "";
    const promiseClose = renderPromise ? ">" : "";
    return `CheckSelect<T, ${promiseOpen}${listOpen}${name}${listClose}${promiseClose}, ${promiseOpen}${listOpen}${getPayloadName(name)}<T>${listClose}${promiseClose}>`;
  }
  if (actionName === "findFirst" || actionName === "findUnique") {
    if (isField) {
      return `CheckSelect<T, Prisma__${name}Client<${getType(name, isList)} | null >, Prisma__${name}Client<${getType(getPayloadName(name) + "<T>", isList)} | null >>`;
    }
    return `HasReject<GlobalRejectSettings, LocalRejectSettings, '${actionName}', '${name}'> extends True ? CheckSelect<T, Prisma__${name}Client<${getType(name, isList)}>, Prisma__${name}Client<${getType(getPayloadName(name) + "<T>", isList)}>> : CheckSelect<T, Prisma__${name}Client<${getType(name, isList)} | null >, Prisma__${name}Client<${getType(getPayloadName(name) + "<T>", isList)} | null >>`;
  }
  return `CheckSelect<T, Prisma__${name}Client<${getType(name, isList)}>, Prisma__${name}Client<${getType(getPayloadName(name) + "<T>", isList)}>>`;
}
function capitalize2(str) {
  return str[0].toUpperCase() + str.slice(1);
}
function unique(arr) {
  const {length} = arr;
  const result = [];
  const seen = new Set();
  loop:
    for (let i = 0; i < length; i++) {
      const value = arr[i];
      if (seen.has(value)) {
        continue loop;
      }
      seen.add(value);
      result.push(value);
    }
  return result;
}
function buildNFTEngineAnnotations(clientEngineType, platforms, cwdDirname) {
  if (platforms && process.env.NETLIFY) {
    platforms = ["rhel-openssl-1.0.x"];
  }
  const getQueryEngineFilename = (p) => clientEngineType === ClientEngineType.Binary ? `query-engine-${p}` : import_getNodeAPIName.getNodeAPIName(p, "fs");
  const buildAnnotation = (p) => {
    return `path.join(__dirname, '${getQueryEngineFilename(p)}');
path.join(process.cwd(), './${import_path2.default.join(cwdDirname, getQueryEngineFilename(p))}')`;
  };
  return platforms ? platforms.map(buildAnnotation).join("\n") : "";
}

// src/generation/TSClient/constants.ts
var TAB_SIZE = 2;

// src/generation/TSClient/helpers.ts
var import_pluralize2 = __toModule2(require_pluralize());

// src/generation/TSClient/jsdoc.ts
var Docs = {
  cursor: `{@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}`,
  pagination: `{@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}`,
  aggregations: `{@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}`,
  distinct: `{@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}`,
  sorting: `{@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}`
};
function addLinkToDocs(comment, docs) {
  return `${Docs[docs]}

${comment}`;
}
function getDeprecationString(since, replacement) {
  return `@deprecated since ${since} please use \`${replacement}\``;
}
var undefinedNote = `Note, that providing \`undefined\` is treated as the value not being there.
Read more here: https://pris.ly/d/null-undefined`;
var JSDocFields = {
  take: (singular, plural2) => addLinkToDocs(`Take \`\xB1n\` ${plural2} from the position of the cursor.`, "pagination"),
  skip: (singular, plural2) => addLinkToDocs(`Skip the first \`n\` ${plural2}.`, "pagination"),
  _count: (singular, plural2) => addLinkToDocs(`Count returned ${plural2}`, "aggregations"),
  _avg: () => addLinkToDocs(`Select which fields to average`, "aggregations"),
  _sum: () => addLinkToDocs(`Select which fields to sum`, "aggregations"),
  _min: () => addLinkToDocs(`Select which fields to find the minimum value`, "aggregations"),
  _max: () => addLinkToDocs(`Select which fields to find the maximum value`, "aggregations"),
  count: () => getDeprecationString("2.23.0", "_count"),
  avg: () => getDeprecationString("2.23.0", "_avg"),
  sum: () => getDeprecationString("2.23.0", "_sum"),
  min: () => getDeprecationString("2.23.0", "_min"),
  max: () => getDeprecationString("2.23.0", "_max"),
  distinct: (singular, plural2) => addLinkToDocs(`Filter by unique combinations of ${plural2}.`, "distinct"),
  orderBy: (singular, plural2) => addLinkToDocs(`Determine the order of ${plural2} to fetch.`, "sorting")
};
var JSDocs = {
  groupBy: {
    body: (ctx) => `Group by ${ctx.singular}.
${undefinedNote}
@param {${getGroupByArgsName(ctx.model.name)}} args - Group by arguments.
@example
// Group by city, order by createdAt, get count
const result = await prisma.user.groupBy({
  by: ['city', 'createdAt'],
  orderBy: {
    createdAt: true
  },
  _count: {
    _all: true
  },
})
`,
    fields: {}
  },
  create: {
    body: (ctx) => `Create a ${ctx.singular}.
@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to create a ${ctx.singular}.
@example
// Create one ${ctx.singular}
const ${ctx.singular} = await ${ctx.method}({
  data: {
    // ... data to create a ${ctx.singular}
  }
})
`,
    fields: {
      data: (singular) => `The data needed to create a ${singular}.`
    }
  },
  createMany: {
    body: (ctx) => `Create many ${ctx.plural}.
    @param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to create many ${ctx.plural}.
    @example
    // Create many ${ctx.plural}
    const ${lowerCase(ctx.mapping.model)} = await ${ctx.method}({
      data: {
        // ... provide data here
      }
    })
    `,
    fields: {
      data: (singular, plural2) => `The data used to create many ${plural2}.`
    }
  },
  findUnique: {
    body: (ctx) => `Find zero or one ${ctx.singular} that matches the filter.
@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to find a ${ctx.singular}
@example
// Get one ${ctx.singular}
const ${lowerCase(ctx.mapping.model)} = await ${ctx.method}({
  where: {
    // ... provide filter here
  }
})`,
    fields: {
      where: (singular) => `Filter, which ${singular} to fetch.`
    }
  },
  findFirst: {
    body: (ctx) => `Find the first ${ctx.singular} that matches the filter.
${undefinedNote}
@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to find a ${ctx.singular}
@example
// Get one ${ctx.singular}
const ${lowerCase(ctx.mapping.model)} = await ${ctx.method}({
  where: {
    // ... provide filter here
  }
})`,
    fields: {
      where: (singular) => `Filter, which ${singular} to fetch.`,
      orderBy: JSDocFields.orderBy,
      cursor: (singular, plural2) => addLinkToDocs(`Sets the position for searching for ${plural2}.`, "cursor"),
      take: JSDocFields.take,
      skip: JSDocFields.skip,
      distinct: JSDocFields.distinct
    }
  },
  findMany: {
    body: (ctx) => {
      const onlySelect = ctx.firstScalar ? `
// Only select the \`${ctx.firstScalar.name}\`
const ${lowerCase(ctx.mapping.model)}With${capitalize(ctx.firstScalar.name)}Only = await ${ctx.method}({ select: { ${ctx.firstScalar.name}: true } })` : "";
      return `Find zero or more ${ctx.plural} that matches the filter.
${undefinedNote}
@param {${getModelArgName(ctx.model.name, ctx.action)}=} args - Arguments to filter and select certain fields only.
@example
// Get all ${ctx.plural}
const ${ctx.mapping.plural} = await ${ctx.method}()

// Get first 10 ${ctx.plural}
const ${ctx.mapping.plural} = await ${ctx.method}({ take: 10 })
${onlySelect}
`;
    },
    fields: {
      where: (singular, plural2) => `Filter, which ${plural2} to fetch.`,
      orderBy: JSDocFields.orderBy,
      skip: JSDocFields.skip,
      cursor: (singular, plural2) => addLinkToDocs(`Sets the position for listing ${plural2}.`, "cursor"),
      take: JSDocFields.take
    }
  },
  update: {
    body: (ctx) => `Update one ${ctx.singular}.
@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to update one ${ctx.singular}.
@example
// Update one ${ctx.singular}
const ${lowerCase(ctx.mapping.model)} = await ${ctx.method}({
  where: {
    // ... provide filter here
  },
  data: {
    // ... provide data here
  }
})
`,
    fields: {
      data: (singular) => `The data needed to update a ${singular}.`,
      where: (singular) => `Choose, which ${singular} to update.`
    }
  },
  upsert: {
    body: (ctx) => `Create or update one ${ctx.singular}.
@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to update or create a ${ctx.singular}.
@example
// Update or create a ${ctx.singular}
const ${lowerCase(ctx.mapping.model)} = await ${ctx.method}({
  create: {
    // ... data to create a ${ctx.singular}
  },
  update: {
    // ... in case it already exists, update
  },
  where: {
    // ... the filter for the ${ctx.singular} we want to update
  }
})`,
    fields: {
      where: (singular) => `The filter to search for the ${singular} to update in case it exists.`,
      create: (singular) => `In case the ${singular} found by the \`where\` argument doesn't exist, create a new ${singular} with this data.`,
      update: (singular) => `In case the ${singular} was found with the provided \`where\` argument, update it with this data.`
    }
  },
  delete: {
    body: (ctx) => `Delete a ${ctx.singular}.
@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to delete one ${ctx.singular}.
@example
// Delete one ${ctx.singular}
const ${ctx.singular} = await ${ctx.method}({
  where: {
    // ... filter to delete one ${ctx.singular}
  }
})
`,
    fields: {
      where: (singular) => `Filter which ${singular} to delete.`
    }
  },
  aggregate: {
    body: (ctx) => `Allows you to perform aggregations operations on a ${ctx.singular}.
${undefinedNote}
@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Select which aggregations you would like to apply and on what fields.
@example
// Ordered by age ascending
// Where email contains prisma.io
// Limited to the 10 users
const aggregations = await prisma.user.aggregate({
  _avg: {
    age: true,
  },
  where: {
    email: {
      contains: "prisma.io",
    },
  },
  orderBy: {
    age: "asc",
  },
  take: 10,
})`,
    fields: {
      where: (singular) => `Filter which ${singular} to aggregate.`,
      orderBy: JSDocFields.orderBy,
      cursor: () => addLinkToDocs(`Sets the start position`, "cursor"),
      take: JSDocFields.take,
      skip: JSDocFields.skip,
      _count: JSDocFields._count,
      _avg: JSDocFields._avg,
      _sum: JSDocFields._sum,
      _min: JSDocFields._min,
      _max: JSDocFields._max,
      count: JSDocFields.count,
      avg: JSDocFields.avg,
      sum: JSDocFields.sum,
      min: JSDocFields.min,
      max: JSDocFields.max
    }
  },
  count: {
    body: (ctx) => `Count the number of ${ctx.plural}.
${undefinedNote}
@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to filter ${ctx.plural} to count.
@example
// Count the number of ${ctx.plural}
const count = await ${ctx.method}({
  where: {
    // ... the filter for the ${ctx.plural} we want to count
  }
})`,
    fields: {}
  },
  updateMany: {
    body: (ctx) => `Update zero or more ${ctx.plural}.
${undefinedNote}
@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to update one or more rows.
@example
// Update many ${ctx.plural}
const ${lowerCase(ctx.mapping.model)} = await ${ctx.method}({
  where: {
    // ... provide filter here
  },
  data: {
    // ... provide data here
  }
})
`,
    fields: {
      data: (singular, plural2) => `The data used to update ${plural2}.`,
      where: (singular, plural2) => `Filter which ${plural2} to update`
    }
  },
  deleteMany: {
    body: (ctx) => `Delete zero or more ${ctx.plural}.
@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to filter ${ctx.plural} to delete.
@example
// Delete a few ${ctx.plural}
const { count } = await ${ctx.method}({
  where: {
    // ... provide filter here
  }
})
`,
    fields: {
      where: (singular, plural2) => `Filter which ${plural2} to delete`
    }
  }
};

// src/generation/TSClient/helpers.ts
function getMethodJSDocBody(action, mapping, model) {
  var _a;
  const ctx = {
    singular: capitalize(mapping.model),
    plural: capitalize(mapping.plural),
    firstScalar: model.fields.find((f) => f.kind === "scalar"),
    method: `prisma.${lowerCase(mapping.model)}.${action}`,
    action,
    mapping,
    model
  };
  const jsdoc = (_a = JSDocs[action]) == null ? void 0 : _a.body(ctx);
  return jsdoc ? jsdoc : "";
}
function getMethodJSDoc(action, mapping, model) {
  return wrapComment(getMethodJSDocBody(action, mapping, model));
}
function getGenericMethod(name, actionName) {
  if (actionName === "count") {
    return "";
  }
  if (actionName === "aggregate") {
    return `<T extends ${getAggregateArgsName(name)}>`;
  }
  if (actionName === "findFirst" || actionName === "findUnique") {
    return `<T extends ${getModelArgName(name, actionName)},  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>`;
  }
  const modelArgName = getModelArgName(name, actionName);
  if (!modelArgName) {
    console.log({name, actionName});
  }
  return `<T extends ${modelArgName}>`;
}
function getArgs(name, actionName) {
  if (actionName === "count") {
    return `args?: Omit<${getModelArgName(name, import_generator_helper.DMMF.ModelAction.findMany)}, 'select' | 'include'>`;
  }
  if (actionName === "aggregate") {
    return `args: Subset<T, ${getAggregateArgsName(name)}>`;
  }
  return `args${actionName === import_generator_helper.DMMF.ModelAction.findMany || actionName === import_generator_helper.DMMF.ModelAction.findFirst || actionName === import_generator_helper.DMMF.ModelAction.deleteMany || actionName === import_generator_helper.DMMF.ModelAction.createMany ? "?" : ""}: SelectSubset<T, ${getModelArgName(name, actionName)}>`;
}
function wrapComment(str) {
  return `/**
${str.split("\n").map((l) => " * " + l).join("\n")}
**/`;
}
function getArgFieldJSDoc(type, action, field) {
  var _a, _b;
  if (!field || !action || !type)
    return;
  const fieldName = typeof field === "string" ? field : field.name;
  if (JSDocs[action] && ((_a = JSDocs[action]) == null ? void 0 : _a.fields[fieldName])) {
    const singular = type.name;
    const plural2 = import_pluralize2.default(type.name);
    const comment = (_b = JSDocs[action]) == null ? void 0 : _b.fields[fieldName](singular, plural2);
    return comment;
  }
  return void 0;
}
function escapeJson(str) {
  return str.replace(/\\n/g, "\\\\n").replace(/\\r/g, "\\\\r").replace(/\\t/g, "\\\\t");
}
var ExportCollector = class {
  constructor() {
    this.symbols = [];
  }
  addSymbol(symbol) {
    this.symbols.push(symbol);
  }
  getSymbols() {
    return unique(this.symbols);
  }
};

// src/generation/TSClient/Input.ts
var import_indent_string3 = __toModule2(require_indent_string2());

// src/runtime/utils/uniqueBy.ts
function uniqueBy(arr, callee) {
  const result = {};
  for (const value of arr) {
    const hash = callee(value);
    if (!result[hash]) {
      result[hash] = value;
    }
  }
  return Object.values(result);
}

// src/generation/TSClient/Input.ts
var InputField = class {
  constructor(field, prefixFilter = false, noEnumerable = false) {
    this.field = field;
    this.prefixFilter = prefixFilter;
    this.noEnumerable = noEnumerable;
  }
  toTS() {
    const {field} = this;
    const optionalStr = field.isRequired ? "" : "?";
    const deprecated = field.deprecation ? `@deprecated since ${field.deprecation.sinceVersion} because ${field.deprecation.reason}
` : "";
    const comment = `${field.comment ? field.comment + "\n" : ""}${deprecated}`;
    const jsdoc = comment ? wrapComment(comment) + "\n" : "";
    const fieldType = stringifyInputTypes(field.inputTypes, this.prefixFilter, this.noEnumerable);
    return `${jsdoc}${field.name}${optionalStr}: ${fieldType}`;
  }
};
function stringifyInputType(t, prefixFilter, noEnumerable = false) {
  var _a;
  let type = typeof t.type === "string" ? GraphQLScalarToJSTypeTable[t.type] || t.type : prefixFilter ? `Base${t.type.name}` : t.type.name;
  type = (_a = JSOutputTypeToInputType[type]) != null ? _a : type;
  if (type === "Null") {
    return "null";
  }
  if (t.isList) {
    const keyword = noEnumerable ? "Array" : "Enumerable";
    if (Array.isArray(type)) {
      return type.map((t2) => `${keyword}<${t2}>`).join(" | ");
    } else {
      return `${keyword}<${type}>`;
    }
  }
  if (Array.isArray(type)) {
    type = type.join(" | ");
  }
  return type;
}
function stringifyInputTypes(inputTypes, prefixFilter, noEnumerable = false) {
  const pairMap = Object.create(null);
  const singularPairIndexes = new Set();
  for (let i = 0; i < inputTypes.length; i++) {
    const inputType = inputTypes[i];
    if (argIsInputType(inputType.type)) {
      const {name} = inputType.type;
      if (typeof pairMap[name] === "number") {
        if (inputType.isList) {
          singularPairIndexes.add(pairMap[name]);
        } else {
          singularPairIndexes.add(i);
        }
      } else {
        pairMap[name] = i;
      }
    }
  }
  const filteredInputTypes = inputTypes.filter((t, i) => !singularPairIndexes.has(i));
  const inputObjectTypes = filteredInputTypes.filter((t) => t.location === "inputObjectTypes");
  const nonInputObjectTypes = filteredInputTypes.filter((t) => t.location !== "inputObjectTypes");
  const stringifiedInputObjectTypes = inputObjectTypes.reduce((acc, curr) => {
    const currentStringified = stringifyInputType(curr, prefixFilter, noEnumerable);
    if (acc.length > 0) {
      return `XOR<${acc}, ${currentStringified}>`;
    }
    return currentStringified;
  }, "");
  const stringifiedNonInputTypes = nonInputObjectTypes.map((type) => stringifyInputType(type, prefixFilter, noEnumerable)).join(" | ");
  if (stringifiedNonInputTypes.length === 0) {
    return stringifiedInputObjectTypes;
  }
  if (stringifiedInputObjectTypes.length === 0) {
    return stringifiedNonInputTypes;
  }
  return `${stringifiedInputObjectTypes} | ${stringifiedNonInputTypes}`;
}
var InputType = class {
  constructor(type, collector) {
    this.type = type;
    this.collector = collector;
  }
  toTS() {
    var _a;
    const {type} = this;
    (_a = this.collector) == null ? void 0 : _a.addSymbol(type.name);
    const fields = uniqueBy(type.fields, (f) => f.name);
    const body = `{
${import_indent_string3.default(fields.map((arg2) => {
      const noEnumerable = type.name.includes("Json") && type.name.includes("Filter") && arg2.name === "path";
      return new InputField(arg2, false, noEnumerable).toTS();
    }).join("\n"), TAB_SIZE)}
}`;
    return `
export type ${type.name} = ${body}`;
  }
};

// src/generation/TSClient/Args.ts
var ArgsType = class {
  constructor(args, type, action, collector) {
    this.args = args;
    this.type = type;
    this.action = action;
    this.collector = collector;
  }
  toTS() {
    var _a, _b, _c;
    const {action, args} = this;
    const {name} = this.type;
    for (const arg2 of args) {
      arg2.comment = getArgFieldJSDoc(this.type, action, arg2);
    }
    const selectName = getSelectName(name);
    (_a = this.collector) == null ? void 0 : _a.addSymbol(selectName);
    const bothArgsOptional = [
      {
        name: "select",
        isRequired: false,
        isNullable: true,
        inputTypes: [
          {
            type: selectName,
            location: "inputObjectTypes",
            isList: false
          },
          {
            type: "null",
            location: "scalar",
            isList: false
          }
        ],
        comment: `Select specific fields to fetch from the ${name}`
      }
    ];
    const hasRelationField = this.type.fields.some((f) => f.outputType.location === "outputObjectTypes");
    if (hasRelationField) {
      const includeName = getIncludeName(name);
      (_b = this.collector) == null ? void 0 : _b.addSymbol(includeName);
      bothArgsOptional.push({
        name: "include",
        isRequired: false,
        isNullable: true,
        inputTypes: [
          {
            type: includeName,
            location: "inputObjectTypes",
            isList: false
          },
          {
            type: "null",
            location: "scalar",
            isList: false
          }
        ],
        comment: `Choose, which related nodes to fetch as well.`
      });
    }
    const addRejectOnNotFound = action === import_generator_helper.DMMF.ModelAction.findUnique || action === import_generator_helper.DMMF.ModelAction.findFirst;
    if (addRejectOnNotFound) {
      bothArgsOptional.push({
        name: "rejectOnNotFound",
        isRequired: false,
        isNullable: true,
        inputTypes: [
          {
            type: "RejectOnNotFound",
            location: "scalar",
            isList: false
          }
        ],
        comment: `Throw an Error if a ${name} can't be found`
      });
    }
    bothArgsOptional.push(...args);
    const modelArgName = getModelArgName(name, action);
    (_c = this.collector) == null ? void 0 : _c.addSymbol(modelArgName);
    return `
/**
 * ${name} ${action ? action : "without action"}
 */
export type ${modelArgName} = {
${import_indent_string4.default(bothArgsOptional.map((arg2) => new InputField(arg2).toTS()).join("\n"), TAB_SIZE)}
}
`;
  }
};
var MinimalArgsType = class {
  constructor(args, model, action, collector) {
    this.args = args;
    this.model = model;
    this.action = action;
    this.collector = collector;
  }
  toTS() {
    var _a;
    const {action, args} = this;
    const {name} = this.model;
    const typeName = getModelArgName(name, action);
    (_a = this.collector) == null ? void 0 : _a.addSymbol(typeName);
    return `
/**
 * ${name} ${action ? action : "without action"}
 */
export type ${typeName} = {
${import_indent_string4.default(args.map((arg2) => new InputField(arg2).toTS()).join("\n"), TAB_SIZE)}
}
`;
  }
};

// src/generation/TSClient/Enum.ts
var import_indent_string5 = __toModule2(require_indent_string2());
var Enum = class {
  constructor(type, useNamespace, collector) {
    this.type = type;
    this.useNamespace = useNamespace;
    this.collector = collector;
    var _a;
    if (useNamespace) {
      (_a = this.collector) == null ? void 0 : _a.addSymbol(type.name);
    }
  }
  toJS() {
    const {type} = this;
    return `exports.${this.useNamespace ? "Prisma." : ""}${type.name} = makeEnum({
${import_indent_string5.default(type.values.map((v) => `${v}: '${v}'`).join(",\n"), TAB_SIZE)}
});`;
  }
  toTS() {
    const {type} = this;
    return `export const ${type.name}: {
${import_indent_string5.default(type.values.map((v) => `${v}: '${v}'`).join(",\n"), TAB_SIZE)}
};

export type ${type.name} = (typeof ${type.name})[keyof typeof ${type.name}]
`;
  }
};

// src/generation/TSClient/Generatable.ts
function JS(gen) {
  if (gen.toJS) {
    return gen.toJS();
  }
  return "";
}
function BrowserJS(gen) {
  if (gen.toBrowserJS) {
    return gen.toBrowserJS();
  }
  return "";
}
function TS(gen) {
  return gen.toTS();
}

// src/generation/TSClient/Model.ts
var import_indent_string9 = __toModule2(require_indent_string2());
var import_klona = __toModule2(require_dist20());

// src/generation/TSClient/Output.ts
var import_indent_string6 = __toModule2(require_indent_string2());
var ModelOutputField = class {
  constructor(dmmf, field, useNamespace = false) {
    this.dmmf = dmmf;
    this.field = field;
    this.useNamespace = useNamespace;
  }
  toTS() {
    const {field, useNamespace} = this;
    let fieldType = typeof field.type === "string" ? GraphQLScalarToJSTypeTable[field.type] || field.type : field.type[0].name;
    if (Array.isArray(fieldType)) {
      fieldType = fieldType[0];
    }
    const arrayStr = field.isList ? `[]` : "";
    const nullableStr = !field.isRequired && !field.isList ? " | null" : "";
    const namespaceStr = useNamespace && needsNamespace(field, this.dmmf) ? `Prisma.` : "";
    return `${field.name}: ${namespaceStr}${fieldType}${arrayStr}${nullableStr}`;
  }
};
var OutputField = class {
  constructor(dmmf, field, useNamespace = false) {
    this.dmmf = dmmf;
    this.field = field;
    this.useNamespace = useNamespace;
  }
  toTS() {
    const {field, useNamespace} = this;
    let fieldType;
    if (field.outputType.location === "scalar") {
      fieldType = GraphQLScalarToJSTypeTable[field.outputType.type];
    } else if (field.outputType.location === "enumTypes") {
      if (isSchemaEnum(field.outputType.type)) {
        fieldType = field.outputType.type.name;
      }
    } else {
      fieldType = field.outputType.type.name;
    }
    if (Array.isArray(fieldType)) {
      fieldType = fieldType[0];
    }
    const arrayStr = field.outputType.isList ? `[]` : "";
    const nullableStr = field.isNullable && !field.outputType.isList ? " | null" : "";
    const namespaceStr = useNamespace && needsNamespace({
      name: field.name,
      type: field.outputType.type,
      isList: field.outputType.isList,
      isRequired: !field.isNullable
    }, this.dmmf) ? `Prisma.` : "";
    const deprecated = field.deprecation ? `@deprecated since ${field.deprecation.sinceVersion} because ${field.deprecation.reason}` : "";
    const jsdoc = deprecated ? wrapComment(deprecated) + "\n" : "";
    return `${jsdoc}${field.name}: ${namespaceStr}${fieldType}${arrayStr}${nullableStr}`;
  }
};
var OutputType = class {
  constructor(dmmf, type, collector) {
    this.dmmf = dmmf;
    this.type = type;
    this.collector = collector;
    this.name = type.name;
    this.fields = type.fields;
    collector == null ? void 0 : collector.addSymbol(this.name);
  }
  toTS() {
    const {type} = this;
    return `
export type ${type.name} = {
${import_indent_string6.default(type.fields.map((field) => new OutputField(this.dmmf, {...field, ...field.outputType}).toTS()).join("\n"), TAB_SIZE)}
}`;
  }
};

// src/generation/TSClient/Payload.ts
var import_indent_string7 = __toModule2(require_indent_string2());
var PayloadType = class {
  constructor(type, skipFindMany = false) {
    this.type = type;
    this.skipFindMany = skipFindMany;
  }
  toTS() {
    const {type} = this;
    const {name} = type;
    const argsName = getArgName(name, false);
    const include = this.renderRelations(Projection.include);
    const select = this.renderRelations(Projection.select);
    const findManyArg = this.skipFindMany ? "" : ` | ${getModelArgName(name, import_generator_helper.DMMF.ModelAction.findMany)}`;
    return `export type ${getPayloadName(name)}<
  S extends boolean | null | undefined | ${argsName},
  U = keyof S
    > = S extends true
      ? ${name}
  : S extends undefined
  ? never
  : S extends ${argsName}${findManyArg}
  ?'include' extends U
  ? ${name} ${include.length > 0 ? ` & ${include}` : ""}
  : 'select' extends U
  ? ${select}
  : ${name}
: ${name}
`;
  }
  renderRelations(projection) {
    const {type} = this;
    const relations = type.fields.filter((f) => f.outputType.location === "outputObjectTypes");
    if (relations.length === 0 && projection === Projection.include) {
      return "";
    }
    const selectPrefix = projection === Projection.select ? `P extends keyof ${type.name} ?${type.name} [P]
: ` : "";
    return `{
  [P in TrueKeys<S['${projection}']>]: ${selectPrefix}
  ${import_indent_string7.default(relations.map((f) => `P extends '${f.name}'
? ${this.wrapType(f, `${getPayloadName(f.outputType.type.name)}<S['${projection}'][P]>`)} :`).join("\n"), 6)} never
} `;
  }
  wrapType(field, str) {
    const {outputType} = field;
    if (!field.isNullable && !outputType.isList) {
      return str;
    }
    if (outputType.isList) {
      return `Array < ${str}> `;
    }
    if (str === "Null") {
      return "null";
    }
    if (field.isNullable) {
      str += " | null";
    }
    return str;
  }
};

// src/generation/TSClient/SchemaOutput.ts
var import_indent_string8 = __toModule2(require_indent_string2());
var SchemaOutputField = class {
  constructor(field) {
    this.field = field;
  }
  toTS() {
    const {field} = this;
    let fieldType = typeof field.outputType.type === "string" ? GraphQLScalarToJSTypeTable[field.outputType.type] || field.outputType.type : field.outputType.type.name;
    if (Array.isArray(fieldType)) {
      fieldType = fieldType[0];
    }
    const arrayStr = field.outputType.isList ? `[]` : "";
    const nullableStr = field.isNullable ? " | null" : "";
    return `${field.name}: ${fieldType}${arrayStr}${nullableStr}`;
  }
};
var SchemaOutputType = class {
  constructor(type, collector) {
    this.type = type;
    this.collector = collector;
    this.name = type.name;
    this.fields = type.fields;
    collector == null ? void 0 : collector.addSymbol(this.name);
  }
  toTS() {
    const {type} = this;
    return `
export type ${type.name} = {
${import_indent_string8.default(type.fields.map((field) => new SchemaOutputField({...field, ...field.outputType}).toTS()).join("\n"), TAB_SIZE)}
}`;
  }
};

// src/generation/TSClient/Model.ts
var Model = class {
  constructor(model, dmmf, generator, collector) {
    this.model = model;
    this.dmmf = dmmf;
    this.generator = generator;
    this.collector = collector;
    this.type = dmmf.outputTypeMap[model.name];
    this.outputType = new OutputType(dmmf, this.type);
    this.mapping = dmmf.mappings.modelOperations.find((m2) => m2.model === model.name);
  }
  get argsTypes() {
    const {mapping, model} = this;
    if (!mapping) {
      return [];
    }
    const argsTypes = [];
    for (const action in import_generator_helper.DMMF.ModelAction) {
      const fieldName = mapping[action];
      if (!fieldName) {
        continue;
      }
      const field = this.dmmf.rootFieldMap[fieldName];
      if (!field) {
        throw new Error(`Oops this must not happen. Could not find field ${fieldName} on either Query or Mutation`);
      }
      if (action === "updateMany" || action === "deleteMany" || action === "createMany") {
        argsTypes.push(new MinimalArgsType(field.args, model, action, this.collector));
      } else if (action !== "groupBy" && action !== "aggregate") {
        argsTypes.push(new ArgsType(field.args, this.type, action, this.collector));
      }
    }
    argsTypes.push(new ArgsType([], this.type));
    return argsTypes;
  }
  getGroupByTypes() {
    const {model, mapping} = this;
    const groupByType = this.dmmf.outputTypeMap[getGroupByName(model.name)];
    if (!groupByType) {
      throw new Error(`Could not get group by type for model ${model.name}`);
    }
    const groupByRootField = this.dmmf.rootFieldMap[mapping.groupBy];
    if (!groupByRootField) {
      throw new Error(`Could not find groupBy root field for model ${model.name}. Mapping: ${mapping == null ? void 0 : mapping.groupBy}`);
    }
    const groupByArgsName = getGroupByArgsName(model.name);
    return `
    
    
export type ${groupByArgsName} = {
${import_indent_string9.default(groupByRootField.args.map((arg2) => {
      arg2.comment = getArgFieldJSDoc(this.type, import_generator_helper.DMMF.ModelAction.groupBy, arg2);
      return new InputField(arg2, false, arg2.name === "by").toTS();
    }).concat(groupByType.fields.filter((f) => f.outputType.location === "outputObjectTypes").map((f) => {
      if (f.outputType.location === "outputObjectTypes") {
        return `${f.name}?: ${getAggregateInputType(f.outputType.type.name)}${f.name === "_count" ? " | true" : ""}`;
      }
      return "";
    })).join("\n"), TAB_SIZE)}
}

${new OutputType(this.dmmf, groupByType).toTS()}

type ${getGroupByPayloadName(model.name)}<T extends ${groupByArgsName}> = Promise<
  Array<
    PickArray<${groupByType.name}, T['by']> & 
      {
        [P in ((keyof T) & (keyof ${groupByType.name}))]: P extends '_count' 
          ? T[P] extends boolean 
            ? number 
            : GetScalarType<T[P], ${groupByType.name}[P]> 
          : GetScalarType<T[P], ${groupByType.name}[P]>
      }
    > 
  >
`;
  }
  getAggregationTypes() {
    var _a, _b;
    const {model, mapping} = this;
    let aggregateType = this.dmmf.outputTypeMap[getAggregateName(model.name)];
    if (!aggregateType) {
      throw new Error(`Could not get aggregate type "${getAggregateName(model.name)}" for "${model.name}"`);
    }
    aggregateType = import_klona.klona(aggregateType);
    const aggregateRootField = this.dmmf.rootFieldMap[mapping.aggregate];
    if (!aggregateRootField) {
      throw new Error(`Could not find aggregate root field for model ${model.name}. Mapping: ${mapping == null ? void 0 : mapping.aggregate}`);
    }
    const aggregateTypes = [aggregateType];
    const avgType = this.dmmf.outputTypeMap[getAvgAggregateName(model.name)];
    const sumType = this.dmmf.outputTypeMap[getSumAggregateName(model.name)];
    const minType = this.dmmf.outputTypeMap[getMinAggregateName(model.name)];
    const maxType = this.dmmf.outputTypeMap[getMaxAggregateName(model.name)];
    const countType = this.dmmf.outputTypeMap[getCountAggregateOutputName(model.name)];
    if (avgType) {
      aggregateTypes.push(avgType);
    }
    if (sumType) {
      aggregateTypes.push(sumType);
    }
    if (minType) {
      aggregateTypes.push(minType);
    }
    if (maxType) {
      aggregateTypes.push(maxType);
    }
    if (countType) {
      aggregateTypes.push(countType);
    }
    for (const aggregateType2 of aggregateTypes) {
      (_a = this.collector) == null ? void 0 : _a.addSymbol(aggregateType2.name);
    }
    const aggregateArgsName = getAggregateArgsName(model.name);
    const aggregateName = getAggregateName(model.name);
    (_b = this.collector) == null ? void 0 : _b.addSymbol(aggregateArgsName);
    return `${aggregateTypes.map((type) => new SchemaOutputType(type, this.collector).toTS()).join("\n")}

${aggregateTypes.length > 1 ? aggregateTypes.slice(1).map((type) => {
      const newType = {
        name: getAggregateInputType(type.name),
        constraints: {
          maxNumFields: null,
          minNumFields: null
        },
        fields: type.fields.map((field) => ({
          ...field,
          name: field.name,
          isNullable: false,
          isRequired: false,
          inputTypes: [
            {
              isList: false,
              location: "scalar",
              type: "true"
            }
          ]
        }))
      };
      return new InputType(newType, this.collector).toTS();
    }).join("\n") : ""}

export type ${aggregateArgsName} = {
${import_indent_string9.default(aggregateRootField.args.map((arg2) => {
      arg2.comment = getArgFieldJSDoc(this.type, import_generator_helper.DMMF.ModelAction.aggregate, arg2);
      return new InputField(arg2).toTS();
    }).concat(aggregateType.fields.map((f) => {
      let data = "";
      const comment = getArgFieldJSDoc(this.type, import_generator_helper.DMMF.ModelAction.aggregate, f.name);
      data += comment ? wrapComment(comment) + "\n" : "";
      if (f.name === "_count" || f.name === "count") {
        data += `${f.name}?: true | ${getCountAggregateInputName(model.name)}`;
      } else {
        data += `${f.name}?: ${getAggregateInputType(f.outputType.type.name)}`;
      }
      return data;
    })).join("\n"), TAB_SIZE)}
}

export type ${getAggregateGetName(model.name)}<T extends ${getAggregateArgsName(model.name)}> = {
      [P in keyof T & keyof ${aggregateName}]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : GetScalarType<T[P], ${aggregateName}[P]>
    : GetScalarType<T[P], ${aggregateName}[P]>
}`;
  }
  toTSWithoutNamespace() {
    const {model} = this;
    return `/**
 * Model ${model.name}
 */

export type ${model.name} = {
${import_indent_string9.default(model.fields.filter((f) => f.kind !== "object" && f.kind !== "unsupported").map((field) => new ModelOutputField(this.dmmf, field, true).toTS()).join("\n"), TAB_SIZE)}
}
`;
  }
  toTS() {
    const {model, outputType} = this;
    if (!outputType) {
      return "";
    }
    const hasRelationField = model.fields.some((f) => f.kind === "object");
    const includeType = hasRelationField ? `
export type ${getIncludeName(model.name)} = {
${import_indent_string9.default(outputType.fields.filter((f) => f.outputType.location === "outputObjectTypes").map((f) => `${f.name}?: boolean` + (f.outputType.location === "outputObjectTypes" ? ` | ${getFieldArgName(f)}` : "")).join("\n"), TAB_SIZE)}
}
` : "";
    return `
/**
 * Model ${model.name}
 */

${this.getAggregationTypes()}

${this.getGroupByTypes()}

export type ${getSelectName(model.name)} = {
${import_indent_string9.default(outputType.fields.map((f) => `${f.name}?: boolean` + (f.outputType.location === "outputObjectTypes" ? ` | ${getFieldArgName(f)}` : "")).join("\n"), TAB_SIZE)}
}
${includeType}
${new PayloadType(this.outputType).toTS()}

${new ModelDelegate(this.outputType, this.dmmf, this.generator).toTS()}

// Custom InputTypes
${this.argsTypes.map(TS).join("\n")}
`;
  }
};
var ModelDelegate = class {
  constructor(outputType, dmmf, generator) {
    this.outputType = outputType;
    this.dmmf = dmmf;
    this.generator = generator;
  }
  toTS() {
    const {fields, name} = this.outputType;
    const mapping = this.dmmf.mappingsMap[name];
    if (!mapping) {
      return "";
    }
    const model = this.dmmf.modelMap[name];
    const actions = Object.entries(mapping).filter(([key, value]) => key !== "model" && key !== "plural" && key !== "aggregate" && key !== "groupBy" && value);
    const groupByArgsName = getGroupByArgsName(name);
    const countArgsName = getModelArgName(name, import_generator_helper.DMMF.ModelAction.count);
    return `type ${countArgsName} = Merge<
  Omit<${getModelArgName(name, import_generator_helper.DMMF.ModelAction.findMany)}, 'select' | 'include'> & {
    select?: ${getCountAggregateInputName(name)} | true
  }
>

export interface ${name}Delegate<GlobalRejectSettings> {
${import_indent_string9.default(actions.map(([actionName]) => `${getMethodJSDoc(actionName, mapping, model)}
${actionName}${getGenericMethod(name, actionName)}(
  ${getArgs(name, actionName)}
): ${getSelectReturnType({name, actionName, projection: Projection.select})}`).join("\n\n"), TAB_SIZE)}

${import_indent_string9.default(getMethodJSDoc(import_generator_helper.DMMF.ModelAction.count, mapping, model), TAB_SIZE)}
  count<T extends ${countArgsName}>(
    args?: Subset<T, ${countArgsName}>,
  ): PrismaPromise<
    T extends _Record<'select', any>
      ? T['select'] extends true
        ? number
        : GetScalarType<T['select'], ${getCountAggregateOutputName(name)}>
      : number
  >

${import_indent_string9.default(getMethodJSDoc(import_generator_helper.DMMF.ModelAction.aggregate, mapping, model), TAB_SIZE)}
  aggregate<T extends ${getAggregateArgsName(name)}>(args: Subset<T, ${getAggregateArgsName(name)}>): PrismaPromise<${getAggregateGetName(name)}<T>>

${import_indent_string9.default(getMethodJSDoc(import_generator_helper.DMMF.ModelAction.groupBy, mapping, model), TAB_SIZE)}
  groupBy<
    T extends ${groupByArgsName},
    HasSelectOrTake extends Or<
      Extends<'skip', Keys<T>>,
      Extends<'take', Keys<T>>
    >,
    OrderByArg extends True extends HasSelectOrTake
      ? { orderBy: ${groupByArgsName}['orderBy'] }
      : { orderBy?: ${groupByArgsName}['orderBy'] },
    OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends TupleToUnion<T['by']>,
    ByValid extends Has<ByFields, OrderFields>,
    HavingFields extends GetHavingFields<T['having']>,
    HavingValid extends Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? True : False,
    InputErrors extends ByEmpty extends True
    ? \`Error: "by" must not be empty.\`
    : HavingValid extends False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? \`Error: Field "\${P}" used in "having" needs to be provided in "by".\`
          : [
              Error,
              'Field ',
              P,
              \` in "having" needs to be provided in "by"\`,
            ]
      }[HavingFields]
    : 'take' extends Keys<T>
    ? 'orderBy' extends Keys<T>
      ? ByValid extends True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Keys<T>
    ? 'orderBy' extends Keys<T>
      ? ByValid extends True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
      }[OrderFields]
  >(args: SubsetIntersection<T, ${groupByArgsName}, OrderByArg> & InputErrors): {} extends InputErrors ? ${getGroupByPayloadName(name)}<T> : Promise<InputErrors>
}

/**
 * The delegate class that acts as a "Promise-like" for ${name}.
 * Why is this prefixed with \`Prisma__\`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export class Prisma__${name}Client<T> implements PrismaPromise<T> {
  [prisma]: true;
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';
${import_indent_string9.default(fields.filter((f) => f.outputType.location === "outputObjectTypes" && f.name !== "_count").map((f) => {
      const fieldTypeName = f.outputType.type.name;
      return `
${f.name}<T extends ${getFieldArgName(f)} = {}>(args?: Subset<T, ${getFieldArgName(f)}>): ${getSelectReturnType({
        name: fieldTypeName,
        actionName: f.outputType.isList ? import_generator_helper.DMMF.ModelAction.findMany : import_generator_helper.DMMF.ModelAction.findUnique,
        hideCondition: false,
        isField: true,
        renderPromise: true,
        fieldName: f.name,
        projection: Projection.select
      })};`;
    }).join("\n"), 2)}

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}`;
  }
};

// src/generation/TSClient/TSClient.ts
var import_getEnvPaths = __toModule2(require_getEnvPaths());
var import_indent_string13 = __toModule2(require_indent_string2());
var import_klona2 = __toModule2(require_dist20());
var import_path3 = __toModule2(require("path"));

// src/runtime/dmmf.ts
var DMMFClass = class {
  constructor({datamodel, schema, mappings}) {
    this.outputTypeToMergedOutputType = (outputType) => {
      const model = this.modelMap[outputType.name];
      return {
        ...outputType,
        isEmbedded: model ? model.isEmbedded : false,
        fields: outputType.fields
      };
    };
    this.datamodel = datamodel;
    this.schema = schema;
    this.mappings = mappings;
    this.enumMap = this.getEnumMap();
    this.datamodelEnumMap = this.getDatamodelEnumMap();
    this.queryType = this.getQueryType();
    this.mutationType = this.getMutationType();
    this.modelMap = this.getModelMap();
    this.outputTypes = this.getOutputTypes();
    this.outputTypeMap = this.getMergedOutputTypeMap();
    this.resolveOutputTypes();
    this.inputObjectTypes = this.schema.inputObjectTypes;
    this.inputTypeMap = this.getInputTypeMap();
    this.resolveInputTypes();
    this.resolveFieldArgumentTypes();
    this.mappingsMap = this.getMappingsMap();
    this.queryType = this.outputTypeMap.Query;
    this.mutationType = this.outputTypeMap.Mutation;
    this.rootFieldMap = this.getRootFieldMap();
  }
  get [Symbol.toStringTag]() {
    return "DMMFClass";
  }
  resolveOutputTypes() {
    for (const type of this.outputTypes.model) {
      for (const field of type.fields) {
        if (typeof field.outputType.type === "string" && !ScalarTypeTable[field.outputType.type]) {
          field.outputType.type = this.outputTypeMap[field.outputType.type] || this.outputTypeMap[field.outputType.type] || this.enumMap[field.outputType.type] || field.outputType.type;
        }
      }
      type.fieldMap = keyBy2(type.fields, "name");
    }
    for (const type of this.outputTypes.prisma) {
      for (const field of type.fields) {
        if (typeof field.outputType.type === "string" && !ScalarTypeTable[field.outputType.type]) {
          field.outputType.type = this.outputTypeMap[field.outputType.type] || this.outputTypeMap[field.outputType.type] || this.enumMap[field.outputType.type] || field.outputType.type;
        }
      }
      type.fieldMap = keyBy2(type.fields, "name");
    }
  }
  resolveInputTypes() {
    const inputTypes = this.inputObjectTypes.prisma;
    if (this.inputObjectTypes.model) {
      inputTypes.push(...this.inputObjectTypes.model);
    }
    for (const type of inputTypes) {
      for (const field of type.fields) {
        for (const fieldInputType of field.inputTypes) {
          const fieldType = fieldInputType.type;
          if (typeof fieldType === "string" && !ScalarTypeTable[fieldType] && (this.inputTypeMap[fieldType] || this.enumMap[fieldType])) {
            fieldInputType.type = this.inputTypeMap[fieldType] || this.enumMap[fieldType] || fieldType;
          }
        }
      }
      type.fieldMap = keyBy2(type.fields, "name");
    }
  }
  resolveFieldArgumentTypes() {
    for (const type of this.outputTypes.prisma) {
      for (const field of type.fields) {
        for (const arg2 of field.args) {
          for (const argInputType of arg2.inputTypes) {
            const argType = argInputType.type;
            if (typeof argType === "string" && !ScalarTypeTable[argType]) {
              argInputType.type = this.inputTypeMap[argType] || this.enumMap[argType] || argType;
            }
          }
        }
      }
    }
    for (const type of this.outputTypes.model) {
      for (const field of type.fields) {
        for (const arg2 of field.args) {
          for (const argInputType of arg2.inputTypes) {
            const argType = argInputType.type;
            if (typeof argType === "string" && !ScalarTypeTable[argType]) {
              argInputType.type = this.inputTypeMap[argType] || this.enumMap[argType] || argInputType.type;
            }
          }
        }
      }
    }
  }
  getQueryType() {
    return this.schema.outputObjectTypes.prisma.find((t) => t.name === "Query");
  }
  getMutationType() {
    return this.schema.outputObjectTypes.prisma.find((t) => t.name === "Mutation");
  }
  getOutputTypes() {
    return {
      model: this.schema.outputObjectTypes.model.map(this.outputTypeToMergedOutputType),
      prisma: this.schema.outputObjectTypes.prisma.map(this.outputTypeToMergedOutputType)
    };
  }
  getDatamodelEnumMap() {
    return keyBy2(this.datamodel.enums, "name");
  }
  getEnumMap() {
    return {
      ...keyBy2(this.schema.enumTypes.prisma, "name"),
      ...this.schema.enumTypes.model ? keyBy2(this.schema.enumTypes.model, "name") : void 0
    };
  }
  getModelMap() {
    return keyBy2(this.datamodel.models, "name");
  }
  getMergedOutputTypeMap() {
    return {
      ...keyBy2(this.outputTypes.model, "name"),
      ...keyBy2(this.outputTypes.prisma, "name")
    };
  }
  getInputTypeMap() {
    return {
      ...this.schema.inputObjectTypes.model ? keyBy2(this.schema.inputObjectTypes.model, "name") : void 0,
      ...keyBy2(this.schema.inputObjectTypes.prisma, "name")
    };
  }
  getMappingsMap() {
    return keyBy2(this.mappings.modelOperations, "model");
  }
  getRootFieldMap() {
    return keyBy22(this.queryType.fields, this.mutationType.fields, "name");
  }
};

// src/generation/TSClient/common.ts
var commonCodeJS = ({
  runtimePath,
  browser,
  clientVersion: clientVersion2,
  engineVersion
}) => `
Object.defineProperty(exports, "__esModule", { value: true });
${browser ? `
const {
  Decimal
} = require('${runtimePath}/index-browser')
` : `
const {
  PrismaClientKnownRequestError,
  PrismaClientUnknownRequestError,
  PrismaClientRustPanicError,
  PrismaClientInitializationError,
  PrismaClientValidationError,
  warnEnvConflicts,
  getPrismaClient,
  sqltag,
  empty,
  join,
  raw,
  Decimal,
  findSync
} = require('${runtimePath}')

const path = require('path')
`}

const Prisma = {}

exports.Prisma = Prisma

/**
 * Prisma Client JS version: ${clientVersion2}
 * Query Engine version: ${engineVersion}
 */
Prisma.prismaVersion = {
  client: "${clientVersion2}",
  engine: "${engineVersion}"
}

Prisma.PrismaClientKnownRequestError = ${notSupportOnBrowser("PrismaClientKnownRequestError", browser)};
Prisma.PrismaClientUnknownRequestError = ${notSupportOnBrowser("PrismaClientUnknownRequestError", browser)}
Prisma.PrismaClientRustPanicError = ${notSupportOnBrowser("PrismaClientRustPanicError", browser)}
Prisma.PrismaClientInitializationError = ${notSupportOnBrowser("PrismaClientInitializationError", browser)}
Prisma.PrismaClientValidationError = ${notSupportOnBrowser("PrismaClientValidationError", browser)}
Prisma.Decimal = Decimal

/**
 * Re-export of sql-template-tag
 */

Prisma.sql = ${notSupportOnBrowser("sqltag", browser)}
Prisma.empty = ${notSupportOnBrowser("empty", browser)}
Prisma.join = ${notSupportOnBrowser("join", browser)}
Prisma.raw = ${notSupportOnBrowser("raw", browser)}
Prisma.validator = () => (val) => val
`;
var notSupportOnBrowser = (fnc, browser) => {
  if (browser)
    return `() => {
  throw new Error(\`${fnc} is unable to be run in the browser.
In case this error is unexpected for you, please report it in https://github.com/prisma/prisma/issues\`,
)}`;
  return fnc;
};
var commonCodeTS = ({
  runtimePath,
  clientVersion: clientVersion2,
  engineVersion
}) => ({
  tsWithoutNamespace: () => `import * as runtime from '${runtimePath}';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends \`\${number}\` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};
`,
  ts: (hideFetcher) => `export import DMMF = runtime.DMMF

/**
 * Prisma Errors
 */
export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
export import PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export import sql = runtime.sqltag
export import empty = runtime.empty
export import join = runtime.join
export import raw = runtime.raw
export import Sql = runtime.Sql

/**
 * Decimal.js
 */
export import Decimal = runtime.Decimal

/**
 * Prisma Client JS version: ${clientVersion2}
 * Query Engine version: ${engineVersion}
 */
export type PrismaVersion = {
  client: string
}

export const prismaVersion: PrismaVersion 

/**
 * Utility Types
 */

/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON object.
 * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
 */
export type JsonObject = {[Key in string]?: JsonValue}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON array.
 */
export interface JsonArray extends Array<JsonValue> {}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches any valid JSON value.
 */
export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

/**
 * Same as JsonObject, but allows undefined
 */
export type InputJsonObject = {[Key in string]?: JsonValue}
 
export interface InputJsonArray extends Array<JsonValue> {}
 
export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
 type SelectAndInclude = {
  select: any
  include: any
}
type HasSelect = {
  select: any
}
type HasInclude = {
  include: any
}
type CheckSelect<T, S, U> = T extends SelectAndInclude
  ? 'Please either choose \`select\` or \`include\`'
  : T extends HasSelect
  ? U
  : T extends HasInclude
  ? U
  : S

/**
 * Get the type of the value, that the Promise holds.
 */
export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

/**
 * Get the return type of a function which returns a Promise.
 */
export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};


export type Enumerable<T> = T | Array<T>;

export type RequiredKeys<T> = {
  [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
}[keyof T]

export type TruthyKeys<T> = {
  [key in keyof T]: T[key] extends false | undefined | null ? never : key
}[keyof T]

export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

/**
 * Subset
 * @desc From \`T\` pick properties that exist in \`U\`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From \`T\` pick properties that exist in \`U\`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose \`select\` or \`include\`.'
    : {})

/**
 * Subset + Intersection
 * @desc From \`T\` pick properties that exist in \`U\` and intersect \`K\`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Buffer
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

/**
A [[Boolean]]
*/
export type Boolean = True | False

// /**
// 1
// */
export type True = 1

/**
0
*/
export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything \`never\` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

type Exact<A, W = unknown> = 
W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
{[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
{[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
: never;

type Narrowable = string | number | boolean | bigint;

type Cast<A, B> = A extends B ? A : B;

export const type: unique symbol;

export function validator<V>(): <S>(select: Exact<S, V>) => S;

/**
 * Used by group by
 */

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like \`Pick\`, but with an array
 */
type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
type ExcludeUnderscoreKeys<T extends string> = T extends \`_\${string}\` ? never : T

${!hideFetcher ? `class PrismaClientFetcher {
  private readonly prisma;
  private readonly debug;
  private readonly hooks?;
  constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
  request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
  sanitizeMessage(message: string): string;
  protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
}` : ""}
`
});

// src/generation/TSClient/Count.ts
var import_indent_string10 = __toModule2(require_indent_string2());
var Count = class {
  constructor(type, dmmf, generator, collector) {
    this.type = type;
    this.dmmf = dmmf;
    this.generator = generator;
    this.collector = collector;
  }
  get argsTypes() {
    const argsTypes = [];
    argsTypes.push(new ArgsType([], this.type));
    return argsTypes;
  }
  toTS() {
    const {type} = this;
    const {name} = type;
    const outputType = new OutputType(this.dmmf, this.type);
    return `
/**
 * Count Type ${name}
 */

${outputType.toTS()}

export type ${getSelectName(name)} = {
${import_indent_string10.default(type.fields.map((f) => `${f.name}?: boolean` + (f.outputType.location === "outputObjectTypes" ? ` | ${getFieldArgName(f)}` : "")).join("\n"), TAB_SIZE)}
}

${new PayloadType(outputType, true).toTS()}

${""}

// Custom InputTypes
${this.argsTypes.map(TS).join("\n")}
`;
  }
};

// src/generation/TSClient/PrismaClient.ts
var import_indent_string12 = __toModule2(require_indent_string2());

// src/generation/TSClient/Datasources.ts
var import_indent_string11 = __toModule2(require_indent_string2());
var Datasources = class {
  constructor(internalDatasources) {
    this.internalDatasources = internalDatasources;
  }
  toTS() {
    const sources = this.internalDatasources;
    return `export type Datasources = {
${import_indent_string11.default(sources.map((s2) => `${s2.name}?: Datasource`).join("\n"), 2)}
}`;
  }
};

// src/generation/TSClient/PrismaClient.ts
function interactiveTransactionDefinition() {
  const txPrismaClient = `Omit<PrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>`;
  const txOptions = `{ maxWait?: number, timeout?: number }`;
  return `
  $transaction<R>(fn: (prisma: ${txPrismaClient}) => Promise<R>, options?: ${txOptions}): Promise<R>`;
}
var PrismaClientClass = class {
  constructor(dmmf, internalDatasources, outputDir, browser, generator, sqliteDatasourceOverrides, cwd) {
    this.dmmf = dmmf;
    this.internalDatasources = internalDatasources;
    this.outputDir = outputDir;
    this.browser = browser;
    this.generator = generator;
    this.sqliteDatasourceOverrides = sqliteDatasourceOverrides;
    this.cwd = cwd;
  }
  get jsDoc() {
    const {dmmf} = this;
    const example = dmmf.mappings.modelOperations[0];
    return `/**
 * ##  Prisma Client \u02B2\u02E2
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * \`\`\`
 * const prisma = new PrismaClient()
 * // Fetch zero or more ${capitalize(example.plural)}
 * const ${lowerCase(example.plural)} = await prisma.${lowerCase(example.model)}.findMany()
 * \`\`\`
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */`;
  }
  toTSWithoutNamespace() {
    var _a;
    const {dmmf} = this;
    return `${this.jsDoc}
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

  ${import_indent_string12.default(this.jsDoc, TAB_SIZE)}

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * \`\`\`
   * // With parameters use prisma.$executeRaw\`\`, values will be escaped automatically
   * const result = await prisma.$executeRaw\`UPDATE User SET cool = \${true} WHERE id = \${1};\`
   * // Or
   * const result = await prisma.$executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * \`\`\`
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * \`\`\`
   * // With parameters use prisma.$queryRaw\`\`, values will be escaped automatically
   * const result = await prisma.$queryRaw\`SELECT * FROM User WHERE id = \${1} OR email = \${'ema.il'};\`
   * // Or
   * const result = await prisma.$queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * \`\`\`
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * \`\`\`
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * \`\`\`
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>${((_a = this.generator) == null ? void 0 : _a.previewFeatures.includes("interactiveTransactions")) ? interactiveTransactionDefinition() : ""}

    ${import_indent_string12.default(dmmf.mappings.modelOperations.filter((m2) => m2.findMany).map((m2) => {
      const methodName = lowerCase(m2.model);
      return `/**
 * \`prisma.${methodName}\`: Exposes CRUD operations for the **${m2.model}** model.
  * Example usage:
  * \`\`\`ts
  * // Fetch zero or more ${capitalize(m2.plural)}
  * const ${lowerCase(m2.plural)} = await prisma.${methodName}.findMany()
  * \`\`\`
  */
get ${methodName}(): Prisma.${m2.model}Delegate<GlobalReject>;`;
    }).join("\n\n"), 2)}
}`;
  }
  toTS() {
    return `${new Datasources(this.internalDatasources).toTS()}

export type RejectOnNotFound = boolean | ((error: Error) => Error)
export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
export type HasReject<
  GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
  LocalRejectSettings,
  Action extends PrismaAction,
  Model extends ModelName
> = LocalRejectSettings extends RejectOnNotFound
  ? IsReject<LocalRejectSettings>
  : GlobalRejectSettings extends RejectPerOperation
  ? Action extends keyof GlobalRejectSettings
    ? GlobalRejectSettings[Action] extends boolean
      ? IsReject<GlobalRejectSettings[Action]>
      : GlobalRejectSettings[Action] extends RejectPerModel
      ? Model extends keyof GlobalRejectSettings[Action]
        ? IsReject<GlobalRejectSettings[Action][Model]>
        : False
      : False
    : False
  : IsReject<GlobalRejectSettings>
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

export interface PrismaClientOptions {
  /**
   * Configure findUnique/findFirst to throw an error if the query returns null. 
   *  * @example
   * \`\`\`
   * // Reject on both findUnique/findFirst
   * rejectOnNotFound: true
   * // Reject only on findFirst with a custom error
   * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
   * // Reject on user.findUnique with a custom error
   * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
   * \`\`\`
   */
  rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
  /**
   * Overwrites the datasource url from your prisma.schema file
   */
  datasources?: Datasources

  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat

  /**
   * @example
   * \`\`\`
   * // Defaults to stdout
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events
   * log: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * ]
   * \`\`\`
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
   */
  log?: Array<LogLevel | LogDefinition>
}

export type Hooks = {
  beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
  GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
  : never

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findMany'
  | 'findFirst'
  | 'create'
  | 'createMany'
  | 'update'
  | 'updateMany'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'

/**
 * These options are being passed in to the middleware as "params"
 */
export type MiddlewareParams = {
  model?: ModelName
  action: PrismaAction
  args: any
  dataPath: string[]
  runInTransaction: boolean
}

/**
 * The \`T\` type makes sure, that the \`return proceed\` is not forgotten in the middleware implementation
 */
export type Middleware<T = any> = (
  params: MiddlewareParams,
  next: (params: MiddlewareParams) => Promise<T>,
) => Promise<T>

// tested in getLogLevel.test.ts
export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; `;
  }
};

// src/generation/TSClient/TSClient.ts
var TSClient = class {
  constructor(options) {
    this.options = options;
    this.dmmfString = escapeJson(JSON.stringify(options.document));
    this.dmmf = new DMMFClass(import_klona2.klona(options.document));
  }
  toJS() {
    var _a, _b;
    const {generator, sqliteDatasourceOverrides, outputDir, schemaDir} = this.options;
    const schemaPath = import_path3.default.join(schemaDir, "prisma.schema");
    const envPaths2 = import_getEnvPaths.getEnvPaths(schemaPath, {cwd: outputDir});
    const relativeEnvPaths = {
      rootEnvPath: envPaths2.rootEnvPath && import_path3.default.relative(outputDir, envPaths2.rootEnvPath),
      schemaEnvPath: envPaths2.schemaEnvPath && import_path3.default.relative(outputDir, envPaths2.schemaEnvPath)
    };
    const config2 = {
      generator,
      relativeEnvPaths,
      sqliteDatasourceOverrides,
      relativePath: import_path3.default.relative(outputDir, schemaDir),
      clientVersion: this.options.clientVersion,
      engineVersion: this.options.engineVersion,
      datasourceNames: this.options.datasources.map((d2) => d2.name),
      activeProvider: this.options.activeProvider
    };
    const clientEngineType = getClientEngineType(config2.generator);
    if (config2.generator) {
      config2.generator.config.engineType = clientEngineType;
    }
    const relativeOutputDir = import_path3.default.relative(process.cwd(), outputDir);
    const slsRelativeOutputDir = import_path3.default.relative(process.cwd(), outputDir).split(import_path3.default.sep).slice(1).join(import_path3.default.sep);
    const code = `${commonCodeJS({...this.options, browser: false})}

// folder where the generated client is found
const dirname = findSync(process.cwd(), [
  '${JSON.stringify(relativeOutputDir)}',
  '${JSON.stringify(slsRelativeOutputDir)}',
], ['d'], ['d'], 1)[0] || __dirname

/**
 * Enums
 */
// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275
function makeEnum(x) { return x; }

${this.dmmf.schema.enumTypes.prisma.map((type) => new Enum(type, true).toJS()).join("\n\n")}
${(_b = (_a = this.dmmf.schema.enumTypes.model) == null ? void 0 : _a.map((type) => new Enum(type, false).toJS()).join("\n\n")) != null ? _b : ""}

${new Enum({
      name: "ModelName",
      values: this.dmmf.mappings.modelOperations.map((m2) => m2.model)
    }, true).toJS()}


/**
 * DMMF
 */
const dmmfString = ${JSON.stringify(this.dmmfString)}

// We are parsing 2 times, as we want independent objects, because
// DMMFClass introduces circular references in the dmmf object
const dmmf = JSON.parse(dmmfString)
exports.Prisma.dmmf = JSON.parse(dmmfString)

/**
 * Create the Client
 */

const config = ${JSON.stringify(config2, null, 2)}
config.document = dmmf
config.dirname = dirname

/**
 * Only for env conflict warning
 * loading of env variable occurs in getPrismaClient
 */
const envPaths = {
  rootEnvPath: config.relativeEnvPaths.rootEnvPath && path.resolve(dirname, config.relativeEnvPaths.rootEnvPath),
  schemaEnvPath: config.relativeEnvPaths.schemaEnvPath && path.resolve(dirname, config.relativeEnvPaths.schemaEnvPath)
}
warnEnvConflicts(envPaths)

const PrismaClient = getPrismaClient(config)
exports.PrismaClient = PrismaClient

Object.assign(exports, Prisma)

/**
 * Build tool annotations
 * In order to make \`ncc\` and \`@vercel/nft\` happy.
 * The process.cwd() annotation is only needed for https://github.com/vercel/vercel/tree/master/packages/now-next
**/
${buildNFTEngineAnnotations(clientEngineType, this.options.platforms, relativeOutputDir)}
/**
 * Annotation for \`@vercel/nft\`
 * The process.cwd() annotation is only needed for https://github.com/vercel/vercel/tree/master/packages/now-next
**/
path.join(__dirname, 'schema.prisma');
path.join(process.cwd(), './${import_path3.default.join(relativeOutputDir, `schema.prisma`)}');
`;
    return code;
  }
  toTS() {
    var _a, _b, _c;
    const prismaClientClass = new PrismaClientClass(this.dmmf, this.options.datasources, this.options.outputDir, this.options.browser, this.options.generator, this.options.sqliteDatasourceOverrides, this.options.schemaDir);
    const collector = new ExportCollector();
    const commonCode = commonCodeTS(this.options);
    const models = Object.values(this.dmmf.modelMap).reduce((acc, model) => {
      if (this.dmmf.outputTypeMap[model.name]) {
        acc.push(new Model(model, this.dmmf, this.options.generator, collector));
      }
      return acc;
    }, []);
    const prismaEnums = this.dmmf.schema.enumTypes.prisma.map((type) => new Enum(type, true, collector).toTS());
    const modelEnums = (_a = this.dmmf.schema.enumTypes.model) == null ? void 0 : _a.map((type) => new Enum(type, false, collector).toTS());
    const countTypes = this.dmmf.schema.outputObjectTypes.prisma.filter((t) => t.name.endsWith("CountOutputType")).map((t) => new Count(t, this.dmmf, this.options.generator, collector));
    const code = `
/**
 * Client
**/

${commonCode.tsWithoutNamespace()}

${models.map((m2) => m2.toTSWithoutNamespace()).join("\n")}
${modelEnums && modelEnums.length > 0 ? `
/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

${modelEnums.join("\n\n")}
` : ""}
${prismaClientClass.toTSWithoutNamespace()}

export namespace Prisma {
${import_indent_string13.default(`${commonCode.ts()}
${new Enum({
      name: "ModelName",
      values: this.dmmf.mappings.modelOperations.map((m2) => m2.model)
    }, true, collector).toTS()}

${prismaClientClass.toTS()}
export type Datasource = {
  url?: string
}

/**
 * Count Types
 */

${countTypes.map((t) => t.toTS()).join("\n")}

/**
 * Models
 */
${models.map((model) => model.toTS()).join("\n")}

/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

${prismaEnums.join("\n\n")}

/**
 * Deep Input Types
 */

${this.dmmf.inputObjectTypes.prisma.reduce((acc, inputType) => {
      if (inputType.name.includes("Json") && inputType.name.includes("Filter")) {
        const baseName = `Required<${inputType.name}Base>`;
        acc.push(`export type ${inputType.name} = 
  | PatchUndefined<
      Either<${baseName}, Exclude<keyof ${baseName}, 'path'>>,
      ${baseName}
    >
  | OptionalFlat<Omit<${baseName}, 'path'>>`);
        collector == null ? void 0 : collector.addSymbol(inputType.name);
        acc.push(new InputType({...inputType, name: `${inputType.name}Base`}, collector).toTS());
      } else {
        acc.push(new InputType(inputType, collector).toTS());
      }
      return acc;
    }, []).join("\n")}

${(_c = (_b = this.dmmf.inputObjectTypes.model) == null ? void 0 : _b.map((inputType) => new InputType(inputType, collector).toTS()).join("\n")) != null ? _c : ""}

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */

export type BatchPayload = {
  count: number
}

/**
 * DMMF
 */
export const dmmf: runtime.DMMF.Document;
`, 2)}}`;
    return code;
  }
  toBrowserJS() {
    var _a, _b;
    const code = `${commonCodeJS({...this.options, browser: true})}
/**
 * Enums
 */
// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275
function makeEnum(x) { return x; }

${this.dmmf.schema.enumTypes.prisma.map((type) => new Enum(type, true).toJS()).join("\n\n")}
${(_b = (_a = this.dmmf.schema.enumTypes.model) == null ? void 0 : _a.map((type) => new Enum(type, false).toJS()).join("\n\n")) != null ? _b : ""}

${new Enum({
      name: "ModelName",
      values: this.dmmf.mappings.modelOperations.map((m2) => m2.model)
    }, true).toJS()}

/**
 * Create the Client
 */
class PrismaClient {
  constructor() {
    throw new Error(
      \`PrismaClient is unable to be run in the browser.
In case this error is unexpected for you, please report it in https://github.com/prisma/prisma/issues\`,
    )
  }
}
exports.PrismaClient = PrismaClient

Object.assign(exports, Prisma)
`;
    return code;
  }
};

// src/generation/generator.ts
var import_generateClient = __toModule2(require_generateClient());
var debug3 = import_debug2.default("prisma:client:generator");
var pkg = require_package3();
var clientVersion = pkg.version;
if (require.main === module) {
  import_generator_helper2.generatorHandler({
    onManifest(config2) {
      const requiredEngine = getClientEngineType(config2) === ClientEngineType.Library ? "libqueryEngine" : "queryEngine";
      debug3(`requiredEngine: ${requiredEngine}`);
      return {
        defaultOutput: ".prisma/client",
        prettyName: "Prisma Client",
        requiresEngines: [requiredEngine],
        version: clientVersion,
        requiresEngineVersion: import_engines_version3.enginesVersion
      };
    },
    async onGenerate(options) {
      var _a;
      const outputDir = typeof options.generator.output === "string" ? options.generator.output : import_sdk.parseEnvValue(options.generator.output);
      return import_generateClient.generateClient({
        datamodel: options.datamodel,
        datamodelPath: options.schemaPath,
        binaryPaths: options.binaryPaths,
        datasources: options.datasources,
        outputDir,
        copyRuntime: Boolean(options.generator.config.copyRuntime),
        dmmf: options.dmmf,
        generator: options.generator,
        engineVersion: options.version,
        clientVersion,
        transpile: true,
        activeProvider: (_a = options.datasources[0]) == null ? void 0 : _a.activeProvider
      });
    }
  });
}
